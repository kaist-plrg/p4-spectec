;; ../../../../spec-concrete/0-aux.watsup:18.1-18.21
def $sum(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:19.1-19.21
def $max(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:20.1-20.21
def $min(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:26.1-27.17
def $int_to_text(int) : text =

;; ../../../../spec-concrete/0-aux.watsup:29.1-30.17
def $concat_text(text*) : text =

   ;; ../../../../spec-concrete/0-aux.watsup:32.1-32.27
   clause 0(text*{text <- text*}) = ""
      -- if text*{text <- text*} matches []

   ;; ../../../../spec-concrete/0-aux.watsup:33.1-33.52
   clause 1(text*{text <- text*}) = t ++ $concat_text(t'*{t' <- t'*})
      -- if text*{text <- text*} matches _ :: _
      -- let t :: t'*{t' <- t'*} = text*{text <- text*}

;; ../../../../spec-concrete/0-aux.watsup:35.1-35.37
def $strip_prefix(text, text) : text =

;; ../../../../spec-concrete/0-aux.watsup:36.1-36.37
def $strip_suffix(text, text) : text =

;; ../../../../spec-concrete/0-aux.watsup:42.1-42.23
def $init_(nat) : nat* =

   ;; ../../../../spec-concrete/0-aux.watsup:43.1-43.20
   clause 0(nat) = []
      -- if (nat = 0)

   ;; ../../../../spec-concrete/0-aux.watsup:44.1-46.22
   clause 1(n) = n' :: $init_(n')
      -- if (n =/= 0)
      -- let int = (n - 1)
      -- if int <: nat
      -- let n' = int as nat

;; ../../../../spec-concrete/0-aux.watsup:48.1-48.29
def $repeat_<X>(X, nat) : X* =

   ;; ../../../../spec-concrete/0-aux.watsup:50.1-50.28
   clause 0(X, nat) = []
      -- if (nat = 0)

   ;; ../../../../spec-concrete/0-aux.watsup:51.1-53.22
   clause 1(X, n) = [X] ++ $repeat_<X>(X, n')
      -- if (n =/= 0)
      -- let int = (n - 1)
      -- if int <: nat
      -- let n' = int as nat

;; ../../../../spec-concrete/0-aux.watsup:55.1-56.26
def $rev_<X>(X*) : X* =

;; ../../../../spec-concrete/0-aux.watsup:58.1-59.23
def $concat_<X>(X**) : X* =

;; ../../../../spec-concrete/0-aux.watsup:61.1-61.39
def $partition_<X>(X*, nat) : (X*, X*) =

;; ../../../../spec-concrete/0-aux.watsup:63.1-64.23
def $assoc_<X, Y>(X, (X, Y)*) : Y? =

;; ../../../../spec-concrete/0-aux.watsup:66.1-67.28
def $distinct_<K>(K*) : bool =

;; ../../../../spec-concrete/0-aux.watsup:73.17-73.24
syntax set<K> = 
   | `{%}`(K*)

;; ../../../../spec-concrete/0-aux.watsup:75.1-76.43
def $empty_set<K> : set<K> =

   ;; ../../../../spec-concrete/0-aux.watsup:77.1-77.29
   clause 0 = `{%}`_set<K>([])

;; ../../../../spec-concrete/0-aux.watsup:79.1-80.36
def $in_set<K>(K, set<K>) : bool =

   ;; ../../../../spec-concrete/0-aux.watsup:81.1-81.39
   clause 0(K, `{%}`_set<K>(K'*{K' <- K'*})) = K <- K'*{K' <- K'*}

;; ../../../../spec-concrete/0-aux.watsup:83.1-84.37
def $intersect_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:86.1-87.37
def $union_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:89.1-90.37
def $unions_set<K>(set<K>*) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:92.1-93.42
def $diff_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:95.1-96.40
def $sub_set<K>(set<K>, set<K>) : bool =

;; ../../../../spec-concrete/0-aux.watsup:98.1-99.33
def $eq_set<K>(set<K>, set<K>) : bool =

;; ../../../../spec-concrete/0-aux.watsup:105.21-105.27
syntax pair<K, V> = 
   | `%->%`(K, V)

;; ../../../../spec-concrete/0-aux.watsup:108.20-108.37
syntax map<K, V> = set<pair<K, V>>

;; ../../../../spec-concrete/0-aux.watsup:110.1-111.43
def $empty_map<K, V> : map<K, V> =

   ;; ../../../../spec-concrete/0-aux.watsup:113.1-113.32
   clause 0 = `{%}`_set<pair<K, V>>([])

;; ../../../../spec-concrete/0-aux.watsup:115.1-116.55
def $dom_map<K, V>(map<K, V>) : set<K> =

   ;; ../../../../spec-concrete/0-aux.watsup:118.1-118.45
   clause 0(`{%}`_set<pair<K, V>>(`%->%`_pair<K, V>(K, V)*{K <- K*, V <- V*})) = `{%}`_set<K>(K*{K <- K*})

;; ../../../../spec-concrete/0-aux.watsup:120.1-121.25
def $find_map<K, V>(map<K, V>, K) : V? =

;; ../../../../spec-concrete/0-aux.watsup:123.1-124.25
def $find_maps<K, V>(map<K, V>*, K) : V? =

;; ../../../../spec-concrete/0-aux.watsup:126.1-127.71
def $add_map<K, V>(map<K, V>, K, V) : map<K, V> =

;; ../../../../spec-concrete/0-aux.watsup:129.1-130.71
def $adds_map<K, V>(map<K, V>, K*, V*) : map<K, V> =

;; ../../../../spec-concrete/0-aux.watsup:132.1-133.71
def $update_map<K, V>(map<K, V>, K, V) : map<K, V> =

;; ../../../../spec-concrete/1-syntax.watsup:5.15-5.18
syntax bits = int

;; ../../../../spec-concrete/1-syntax.watsup:6.16-6.19
syntax width = nat

;; ../../../../spec-concrete/1-syntax.watsup:9.1-11.20
syntax number = 
   | `INT%`(int)
   | `FINT%%`(width, bits)
   | `FBIT%%`(width, bits)

;; ../../../../spec-concrete/1-syntax.watsup:21.15-21.19
syntax name = text

;; ../../../../spec-concrete/1-syntax.watsup:28.1-29.17
syntax prefixedName = 
   | `TOP%`(name)
   | `CURRENT%`(name)

;; ../../../../spec-concrete/1-syntax.watsup:31.1-31.47
def $flatten_prefixedName(prefixedName) : name =

   ;; ../../../../spec-concrete/1-syntax.watsup:32.1-32.50
   clause 0(prefixedName) = "." ++ name
      -- if prefixedName matches `TOP%`
      -- let `TOP%`_prefixedName(name) = prefixedName

   ;; ../../../../spec-concrete/1-syntax.watsup:33.1-33.47
   clause 1(prefixedName) = name
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(name) = prefixedName

;; ../../../../spec-concrete/1-syntax.watsup:39.20-39.41
syntax direction = 
   | `NO`()
   | `IN`()
   | `OUT`()
   | `INOUT`()

;; ../../../../spec-concrete/1-syntax.watsup:52.1-59.21
syntax baseType = 
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(expression)
   | `FBitT%`(expression)
   | `VBitT%`(expression)

;; ../../../../spec-concrete/1-syntax.watsup:68.3-68.21
syntax nameType = 
   | `NameT%`(prefixedName)

;; ../../../../spec-concrete/1-syntax.watsup:71.3-71.35
syntax specializedType = 
   | `SpecT%%`(prefixedName, typeArgument*)

;; ../../../../spec-concrete/1-syntax.watsup:74.1-75.20
syntax namedType = 
   | `NameT%`(prefixedName)
   | `SpecT%%`(prefixedName, typeArgument*)

;; ../../../../spec-concrete/1-syntax.watsup:82.3-82.36
syntax headerStackType = 
   | `HeaderStackT%%`(namedType, expression)

;; ../../../../spec-concrete/1-syntax.watsup:88.19-88.37
syntax listType = 
   | `ListT%`(typeArgument)

;; ../../../../spec-concrete/1-syntax.watsup:94.20-94.40
syntax tupleType = 
   | `TupleT%`(typeArgument*)

;; ../../../../spec-concrete/1-syntax.watsup:101.1-105.14
syntax type = 
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(expression)
   | `FBitT%`(expression)
   | `VBitT%`(expression)
   | `NameT%`(prefixedName)
   | `SpecT%%`(prefixedName, typeArgument*)
   | `HeaderStackT%%`(namedType, expression)
   | `ListT%`(typeArgument)
   | `TupleT%`(typeArgument*)

;; ../../../../spec-concrete/1-syntax.watsup:108.1-109.10
syntax typeOrVoid = 
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(expression)
   | `FBitT%`(expression)
   | `VBitT%`(expression)
   | `NameT%`(prefixedName)
   | `SpecT%%`(prefixedName, typeArgument*)
   | `HeaderStackT%%`(namedType, expression)
   | `ListT%`(typeArgument)
   | `TupleT%`(typeArgument*)
   | `VoidT`()

;; ../../../../spec-concrete/1-syntax.watsup:115.24-115.28
syntax typeParameter = name

;; ../../../../spec-concrete/1-syntax.watsup:124.3-124.35
syntax parameter = 
   | `%%%%`(direction, type, name, initializer?)

;; ../../../../spec-concrete/1-syntax.watsup:130.31-130.40
syntax constructorParameter = parameter

;; ../../../../spec-concrete/1-syntax.watsup:136.26-136.41
syntax namedExpression = 
   | `%%`(name, expression)

;; ../../../../spec-concrete/1-syntax.watsup:147.1-149.14
syntax literalExpression = 
   | `BoolE%`(bool)
   | `NumE%`(number)
   | `StrE%`(text)

;; ../../../../spec-concrete/1-syntax.watsup:155.30-155.48
syntax referenceExpression = 
   | `NameE%`(prefixedName)

;; ../../../../spec-concrete/1-syntax.watsup:161.28-161.36
syntax defaultExpression = 
   | `DefaultE`()

;; ../../../../spec-concrete/1-syntax.watsup:167.15-167.43
syntax unop = 
   | `BNOT`()
   | `LNOT`()
   | `UPLUS`()
   | `UMINUS`()

;; ../../../../spec-concrete/1-syntax.watsup:169.26-169.45
syntax unaryExpression = 
   | `UnE%%`(unop, expression)

;; ../../../../spec-concrete/1-syntax.watsup:172.1-180.15
syntax binop = 
   | `PLUS`()
   | `SPLUS`()
   | `MINUS`()
   | `SMINUS`()
   | `MUL`()
   | `DIV`()
   | `MOD`()
   | `SHL`()
   | `SHR`()
   | `LE`()
   | `GE`()
   | `LT`()
   | `GT`()
   | `EQ`()
   | `NE`()
   | `BAND`()
   | `BXOR`()
   | `BOR`()
   | `CONCAT`()
   | `LAND`()
   | `LOR`()

;; ../../../../spec-concrete/1-syntax.watsup:182.27-182.59
syntax binaryExpression = 
   | `BinE%%%`(expression, binop, expression)

;; ../../../../spec-concrete/1-syntax.watsup:185.3-185.41
syntax ternaryExpression = 
   | `TernE%%%`(expression, expression, expression)

;; ../../../../spec-concrete/1-syntax.watsup:191.25-191.46
syntax castExpression = 
   | `CastE%%`(type, expression)

;; ../../../../spec-concrete/1-syntax.watsup:198.1-201.36
syntax dataExpression = 
   | `InvalidE`()
   | `SeqE%`(expression*)
   | `RecordE%`(namedExpression*)
   | `RecordDefaultE%`(namedExpression*)

;; ../../../../spec-concrete/1-syntax.watsup:207.32-207.44
syntax errorAccessExpression = 
   | `ErrAccE%`(name)

;; ../../../../spec-concrete/1-syntax.watsup:210.1-211.29
syntax memberAccessExpression = 
   | `TypeAccE%%`(prefixedName, name)
   | `ExprAccE%%`(expression, name)

;; ../../../../spec-concrete/1-syntax.watsup:214.1-215.45
syntax indexAccessExpression = 
   | `ArrAccE%%`(expression, expression)
   | `BitAccE%%%`(expression, expression, expression)

;; ../../../../spec-concrete/1-syntax.watsup:218.1-220.26
syntax accessExpression = 
   | `ErrAccE%`(name)
   | `TypeAccE%%`(prefixedName, name)
   | `ExprAccE%%`(expression, name)
   | `ArrAccE%%`(expression, expression)
   | `BitAccE%%%`(expression, expression, expression)

;; ../../../../spec-concrete/1-syntax.watsup:231.1-232.30
syntax callExpression = 
   | `CallE%%%`(routineTarget, typeArgument*, argument*)
   | `InstE%%`(namedType, argument*)

;; ../../../../spec-concrete/1-syntax.watsup:239.1-248.19
syntax expression = 
   | `BoolE%`(bool)
   | `NumE%`(number)
   | `StrE%`(text)
   | `NameE%`(prefixedName)
   | `DefaultE`()
   | `UnE%%`(unop, expression)
   | `BinE%%%`(expression, binop, expression)
   | `TernE%%%`(expression, expression, expression)
   | `CastE%%`(type, expression)
   | `InvalidE`()
   | `SeqE%`(expression*)
   | `RecordE%`(namedExpression*)
   | `RecordDefaultE%`(namedExpression*)
   | `ErrAccE%`(name)
   | `TypeAccE%%`(prefixedName, name)
   | `ExprAccE%%`(expression, name)
   | `ArrAccE%%`(expression, expression)
   | `BitAccE%%%`(expression, expression, expression)
   | `CallE%%%`(routineTarget, typeArgument*, argument*)
   | `InstE%%`(namedType, argument*)

;; ../../../../spec-concrete/1-syntax.watsup:250.24-250.34
syntax routineTarget = expression

;; ../../../../spec-concrete/1-syntax.watsup:257.1-261.9
syntax keysetExpression = 
   | `ExprK%`(expression)
   | `MaskK%%`(expression, expression)
   | `RangeK%%`(expression, expression)
   | `DefaultK`()
   | `AnyK`()

;; ../../../../spec-concrete/1-syntax.watsup:268.1-270.9
syntax typeArgument = 
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(expression)
   | `FBitT%`(expression)
   | `VBitT%`(expression)
   | `NameT%`(prefixedName)
   | `SpecT%%`(prefixedName, typeArgument*)
   | `HeaderStackT%%`(namedType, expression)
   | `ListT%`(typeArgument)
   | `TupleT%`(typeArgument*)
   | `VoidT`()
   | `AnyT`()

;; ../../../../spec-concrete/1-syntax.watsup:277.1-280.9
syntax argument = 
   | `ExprA%`(expression)
   | `NameA%%`(name, expression)
   | `NameAnyA%`(name)
   | `AnyA`()

;; ../../../../spec-concrete/1-syntax.watsup:287.1-290.41
syntax lvalue = 
   | `NameL%`(prefixedName)
   | `LvalueAccL%%`(lvalue, name)
   | `ArrAccL%%`(lvalue, expression)
   | `BitAccL%%%`(lvalue, expression, expression)

;; ../../../../spec-concrete/1-syntax.watsup:300.25-300.31
syntax emptyStatement = 
   | `EmptyS`()

;; ../../../../spec-concrete/1-syntax.watsup:306.30-306.55
syntax assignmentStatement = 
   | `AssignS%%`(lvalue, expression)

;; ../../../../spec-concrete/1-syntax.watsup:313.3-313.39
syntax callStatement = 
   | `CallS%%%`(lvalue, typeArgument*, argument*)

;; ../../../../spec-concrete/1-syntax.watsup:319.37-319.62
syntax directApplicationStatement = 
   | `InstS%%`(namedType, argument*)

;; ../../../../spec-concrete/1-syntax.watsup:325.26-325.45
syntax returnStatement = 
   | `ReturnS%`(expression?)

;; ../../../../spec-concrete/1-syntax.watsup:331.24-331.29
syntax exitStatement = 
   | `ExitS`()

;; ../../../../spec-concrete/1-syntax.watsup:340.3-340.32
syntax blockStatement = 
   | `BlockS%`(blockElementStatement*)

;; ../../../../spec-concrete/1-syntax.watsup:349.3-349.38
syntax conditionalStatement = 
   | `IfS%%%`(expression, statement, statement?)

;; ../../../../spec-concrete/1-syntax.watsup:356.1-357.21
syntax switchLabel = 
   | `DefaultL`()
   | `ExprL%`(expression)

;; ../../../../spec-concrete/1-syntax.watsup:360.1-361.38
syntax switchCase = 
   | `FallC%`(switchLabel)
   | `MatchC%%`(switchLabel, blockStatement)

;; ../../../../spec-concrete/1-syntax.watsup:363.26-363.56
syntax switchStatement = 
   | `SwitchS%%`(expression, switchCase*)

;; ../../../../spec-concrete/1-syntax.watsup:370.1-378.20
syntax statement = 
   | `EmptyS`()
   | `AssignS%%`(lvalue, expression)
   | `CallS%%%`(lvalue, typeArgument*, argument*)
   | `InstS%%`(namedType, argument*)
   | `ReturnS%`(expression?)
   | `ExitS`()
   | `BlockS%`(blockElementStatement*)
   | `IfS%%%`(expression, statement, statement?)
   | `SwitchS%%`(expression, switchCase*)

;; ../../../../spec-concrete/1-syntax.watsup:388.22-388.32
syntax initializer = expression

;; ../../../../spec-concrete/1-syntax.watsup:391.3-391.31
syntax constantDeclaration = 
   | `ConstD%%%`(type, name, initializer)

;; ../../../../spec-concrete/1-syntax.watsup:394.3-394.30
syntax variableDeclaration = 
   | `VarD%%%`(type, name, initializer?)

;; ../../../../spec-concrete/1-syntax.watsup:397.1-399.14
syntax blockElementStatement = 
   | `ConstD%%%`(type, name, initializer)
   | `VarD%%%`(type, name, initializer?)
   | `EmptyS`()
   | `AssignS%%`(lvalue, expression)
   | `CallS%%%`(lvalue, typeArgument*, argument*)
   | `InstS%%`(namedType, argument*)
   | `ReturnS%`(expression?)
   | `ExitS`()
   | `BlockS%`(blockElementStatement*)
   | `IfS%%%`(expression, statement, statement?)
   | `SwitchS%%`(expression, switchCase*)

;; ../../../../spec-concrete/1-syntax.watsup:406.3-407.49
syntax functionDeclaration = 
   | `FuncD%%%%%`(typeOrVoid, name, typeParameter*, parameter*, blockStatement)

;; ../../../../spec-concrete/1-syntax.watsup:414.3-414.41
syntax actionDeclaration = 
   | `ActionD%%%`(name, parameter*, blockStatement)

;; ../../../../spec-concrete/1-syntax.watsup:423.3-423.47
syntax instantiation = 
   | `InstD%%%%`(type, argument*, name, objectInitializer?)

;; ../../../../spec-concrete/1-syntax.watsup:426.1-427.18
syntax objectDeclaration = 
   | `FuncD%%%%%`(typeOrVoid, name, typeParameter*, parameter*, blockStatement)
   | `InstD%%%%`(type, argument*, name, objectInitializer?)

;; ../../../../spec-concrete/1-syntax.watsup:429.28-429.46
syntax objectInitializer = objectDeclaration*

;; ../../../../spec-concrete/1-syntax.watsup:435.27-435.37
syntax errorDeclaration = 
   | `ErrD%`(name*)

;; ../../../../spec-concrete/1-syntax.watsup:441.31-441.47
syntax matchKindDeclaration = 
   | `MatchKindD%`(name*)

;; ../../../../spec-concrete/1-syntax.watsup:452.1-453.38
syntax enumTypeDeclaration = 
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(type, name, namedExpression*)

;; ../../../../spec-concrete/1-syntax.watsup:459.20-459.29
syntax typeField = 
   | `%%`(type, name)

;; ../../../../spec-concrete/1-syntax.watsup:462.3-462.41
syntax structTypeDeclaration = 
   | `StructD%%%`(name, typeParameter*, typeField*)

;; ../../../../spec-concrete/1-syntax.watsup:465.3-465.41
syntax headerTypeDeclaration = 
   | `HeaderD%%%`(name, typeParameter*, typeField*)

;; ../../../../spec-concrete/1-syntax.watsup:468.3-468.46
syntax headerUnionTypeDeclaration = 
   | `HeaderUnionD%%%`(name, typeParameter*, typeField*)

;; ../../../../spec-concrete/1-syntax.watsup:471.1-474.31
syntax derivedTypeDeclaration = 
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(type, name, namedExpression*)
   | `StructD%%%`(name, typeParameter*, typeField*)
   | `HeaderD%%%`(name, typeParameter*, typeField*)
   | `HeaderUnionD%%%`(name, typeParameter*, typeField*)

;; ../../../../spec-concrete/1-syntax.watsup:481.1-482.36
syntax typedefType = 
   | `PlainT%`(type)
   | `DerivedT%`(derivedTypeDeclaration)

;; ../../../../spec-concrete/1-syntax.watsup:485.1-486.23
syntax typedefDeclaration = 
   | `TypeDefD%%`(typedefType, name)
   | `NewTypeD%%`(type, name)

;; ../../../../spec-concrete/1-syntax.watsup:493.3-494.40
syntax externFunctionDeclaration = 
   | `ExternFuncD%%%%`(typeOrVoid, name, typeParameter*, parameter*)

;; ../../../../spec-concrete/1-syntax.watsup:497.1-499.62
syntax methodPrototype = 
   | `ConsM%%`(name, constructorParameter*)
   | `MethodM%%%%`(typeOrVoid, name, typeParameter*, parameter*)
   | `AbstractMethodM%%%%`(typeOrVoid, name, typeParameter*, parameter*)

;; ../../../../spec-concrete/1-syntax.watsup:502.3-502.53
syntax externObjectDeclaration = 
   | `ExternObjectD%%%`(name, typeParameter*, methodPrototype*)

;; ../../../../spec-concrete/1-syntax.watsup:505.1-506.28
syntax externDeclaration = 
   | `ExternFuncD%%%%`(typeOrVoid, name, typeParameter*, parameter*)
   | `ExternObjectD%%%`(name, typeParameter*, methodPrototype*)

;; ../../../../spec-concrete/1-syntax.watsup:516.21-516.43
syntax selectCase = 
   | `%%`(keysetExpression*, name)

;; ../../../../spec-concrete/1-syntax.watsup:523.1-524.36
syntax stateExpression = 
   | `NameE%`(name)
   | `SelectE%%`(expression*, selectCase*)

;; ../../../../spec-concrete/1-syntax.watsup:526.30-526.52
syntax transitionStatement = 
   | `TransS%`(stateExpression)

;; ../../../../spec-concrete/1-syntax.watsup:533.1-535.13
syntax valueSetType = 
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(expression)
   | `FBitT%`(expression)
   | `VBitT%`(expression)
   | `TupleT%`(typeArgument*)
   | `NameT%`(prefixedName)

;; ../../../../spec-concrete/1-syntax.watsup:538.3-538.41
syntax valueSetDeclaration = 
   | `ValueSetD%%%`(valueSetType, expression, name)

;; ../../../../spec-concrete/1-syntax.watsup:545.3-545.45
syntax parserTypeDeclaration = 
   | `ParserTypeD%%%`(name, typeParameter*, parameter*)

;; ../../../../spec-concrete/1-syntax.watsup:554.3-554.32
syntax parserBlockStatement = 
   | `ParserBlockS%`(parserStatement*)

;; ../../../../spec-concrete/1-syntax.watsup:557.1-564.25
syntax parserStatement = 
   | `ConstD%%%`(type, name, initializer)
   | `VarD%%%`(type, name, initializer?)
   | `EmptyS`()
   | `AssignS%%`(lvalue, expression)
   | `CallS%%%`(lvalue, typeArgument*, argument*)
   | `InstS%%`(namedType, argument*)
   | `ParserBlockS%`(parserStatement*)
   | `IfS%%%`(expression, statement, statement?)

;; ../../../../spec-concrete/1-syntax.watsup:567.3-567.45
syntax parserState = 
   | `%%%`(name, parserStatement*, transitionStatement?)

;; ../../../../spec-concrete/1-syntax.watsup:570.1-573.24
syntax parserLocalDeclaration = 
   | `ConstD%%%`(type, name, initializer)
   | `InstD%%%%`(type, argument*, name, objectInitializer?)
   | `VarD%%%`(type, name, initializer?)
   | `ValueSetD%%%`(valueSetType, expression, name)

;; ../../../../spec-concrete/1-syntax.watsup:576.3-578.47
syntax parserDeclaration = 
   | `ParserD%%%%%%`(name, typeParameter*, parameter*, constructorParameter*, parserLocalDeclaration*, parserState*)

;; ../../../../spec-concrete/1-syntax.watsup:588.16-588.21
syntax const = 
   | `CONST`()

;; ../../../../spec-concrete/1-syntax.watsup:594.19-594.34
syntax tableKey = 
   | `%%`(expression, name)

;; ../../../../spec-concrete/1-syntax.watsup:600.31-600.53
syntax tableActionReference = 
   | `%%`(prefixedName, argument*)

;; ../../../../spec-concrete/1-syntax.watsup:602.22-602.42
syntax tableAction = tableActionReference

;; ../../../../spec-concrete/1-syntax.watsup:608.29-608.39
syntax tableEntryPriority = expression

;; ../../../../spec-concrete/1-syntax.watsup:611.3-612.48
syntax tableEntry = 
   | `%%%%`(const?, tableEntryPriority?, keysetExpression*, tableActionReference)

;; ../../../../spec-concrete/1-syntax.watsup:619.1-622.36
syntax tableProperty = 
   | `KeyP%`(tableKey*)
   | `ActionP%`(tableAction*)
   | `EntryP%%`(const?, tableEntry*)
   | `CustomP%%%`(const?, name, initializer)

;; ../../../../spec-concrete/1-syntax.watsup:625.3-625.29
syntax tableDeclaration = 
   | `TableD%%`(name, tableProperty*)

;; ../../../../spec-concrete/1-syntax.watsup:632.3-632.46
syntax controlTypeDeclaration = 
   | `ControlTypeD%%%`(name, typeParameter*, parameter*)

;; ../../../../spec-concrete/1-syntax.watsup:638.22-638.36
syntax controlBody = blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:641.1-645.21
syntax controlLocalDeclaration = 
   | `ConstD%%%`(type, name, initializer)
   | `InstD%%%%`(type, argument*, name, objectInitializer?)
   | `VarD%%%`(type, name, initializer?)
   | `ActionD%%%`(name, parameter*, blockStatement)
   | `TableD%%`(name, tableProperty*)

;; ../../../../spec-concrete/1-syntax.watsup:648.3-650.48
syntax controlDeclaration = 
   | `ControlD%%%%%%`(name, typeParameter*, parameter*, constructorParameter*, controlLocalDeclaration*, controlBody)

;; ../../../../spec-concrete/1-syntax.watsup:657.3-657.57
syntax packageTypeDeclaration = 
   | `PackageTypeD%%%`(name, typeParameter*, constructorParameter*)

;; ../../../../spec-concrete/1-syntax.watsup:664.1-668.27
syntax typeDeclaration = 
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(type, name, namedExpression*)
   | `StructD%%%`(name, typeParameter*, typeField*)
   | `HeaderD%%%`(name, typeParameter*, typeField*)
   | `HeaderUnionD%%%`(name, typeParameter*, typeField*)
   | `TypeDefD%%`(typedefType, name)
   | `NewTypeD%%`(type, name)
   | `ParserTypeD%%%`(name, typeParameter*, parameter*)
   | `ControlTypeD%%%`(name, typeParameter*, parameter*)
   | `PackageTypeD%%%`(name, typeParameter*, constructorParameter*)

;; ../../../../spec-concrete/1-syntax.watsup:675.1-684.20
syntax declaration = 
   | `ConstD%%%`(type, name, initializer)
   | `InstD%%%%`(type, argument*, name, objectInitializer?)
   | `FuncD%%%%%`(typeOrVoid, name, typeParameter*, parameter*, blockStatement)
   | `ActionD%%%`(name, parameter*, blockStatement)
   | `ErrD%`(name*)
   | `MatchKindD%`(name*)
   | `ExternFuncD%%%%`(typeOrVoid, name, typeParameter*, parameter*)
   | `ExternObjectD%%%`(name, typeParameter*, methodPrototype*)
   | `ParserD%%%%%%`(name, typeParameter*, parameter*, constructorParameter*, parserLocalDeclaration*, parserState*)
   | `ControlD%%%%%%`(name, typeParameter*, parameter*, constructorParameter*, controlLocalDeclaration*, controlBody)
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(type, name, namedExpression*)
   | `StructD%%%`(name, typeParameter*, typeField*)
   | `HeaderD%%%`(name, typeParameter*, typeField*)
   | `HeaderUnionD%%%`(name, typeParameter*, typeField*)
   | `TypeDefD%%`(typedefType, name)
   | `NewTypeD%%`(type, name)
   | `ParserTypeD%%%`(name, typeParameter*, parameter*)
   | `ControlTypeD%%%`(name, typeParameter*, parameter*)
   | `PackageTypeD%%%`(name, typeParameter*, constructorParameter*)

;; ../../../../spec-concrete/1-syntax.watsup:690.20-690.32
syntax p4program = declaration*

;; ../../../../spec-concrete/2.0-domain.watsup:5.13-5.17
syntax id = text

;; ../../../../spec-concrete/2.0-domain.watsup:11.14-11.16
syntax tid = id

;; ../../../../spec-concrete/2.0-domain.watsup:13.1-13.23
def $fresh_tid : tid =

;; ../../../../spec-concrete/2.0-domain.watsup:14.1-14.28
def $fresh_tids(nat) : tid* =

   ;; ../../../../spec-concrete/2.0-domain.watsup:16.1-16.25
   clause 0(nat) = []
      -- if (nat = 0)

   ;; ../../../../spec-concrete/2.0-domain.watsup:17.1-19.22
   clause 1(n) = $fresh_tid :: $fresh_tids(n')
      -- if (n =/= 0)
      -- let int = (n - 1)
      -- if int <: nat
      -- let n' = int as nat

;; ../../../../spec-concrete/2.0-domain.watsup:29.14-29.21
syntax pid = 
   | `%%`(id, bool)

;; ../../../../spec-concrete/2.0-domain.watsup:30.14-30.21
syntax rid = 
   | `%%`(id, pid*)

;; ../../../../spec-concrete/2.0-domain.watsup:32.1-32.33
def $rid(name, parameter*) : rid =

   ;; ../../../../spec-concrete/2.0-domain.watsup:35.1-36.26
   clause 0(name, parameter*{parameter <- parameter*}) = `%%`_rid(name, $pid(parameter)*{parameter <- parameter*})

;; ../../../../spec-concrete/2.0-domain.watsup:33.1-33.26
def $pid(parameter) : pid =

   ;; ../../../../spec-concrete/2.0-domain.watsup:38.1-38.36
   clause 0(`%%%%`_parameter(_direction, _type, name, initializer?{initializer <- initializer?})) = `%%`_pid(name, false)
      -- if initializer?{initializer <- initializer?} matches ()

   ;; ../../../../spec-concrete/2.0-domain.watsup:39.1-39.43
   clause 1(`%%%%`_parameter(_direction, _type, name, initializer'?{initializer' <- initializer'?})) = `%%`_pid(name, true)
      -- if initializer'?{initializer' <- initializer'?} matches (_)
      -- let ?(initializer) = initializer'?{initializer' <- initializer'?}

;; ../../../../spec-concrete/2.0-domain.watsup:45.14-45.17
syntax cid = rid

;; ../../../../spec-concrete/2.0-domain.watsup:47.1-47.44
def $cid(name, constructorParameter*) : cid =

   ;; ../../../../spec-concrete/2.0-domain.watsup:49.1-50.38
   clause 0(name, constructorParameter*{constructorParameter <- constructorParameter*}) = $rid(name, constructorParameter*{constructorParameter <- constructorParameter*})

;; ../../../../spec-concrete/2.1.1-value.watsup:14.1-17.14
syntax primitiveValue = 
   | `BoolV%`(bool)
   | `ErrV%`(id)
   | `MatchKindV%`(id)
   | `StrV%`(text)

;; ../../../../spec-concrete/2.1.1-value.watsup:24.1-27.27
syntax numberValue = 
   | `IntV%`(int)
   | `FIntV%%`(width, bits)
   | `FBitV%%`(width, bits)
   | `VBitV%%%`(width, width, bits)

;; ../../../../spec-concrete/2.1.1-value.watsup:30.1-31.16
syntax baseValue = 
   | `BoolV%`(bool)
   | `ErrV%`(id)
   | `MatchKindV%`(id)
   | `StrV%`(text)
   | `IntV%`(int)
   | `FIntV%%`(width, bits)
   | `FBitV%%`(width, bits)
   | `VBitV%%%`(width, width, bits)

;; ../../../../spec-concrete/2.1.1-value.watsup:39.20-39.32
syntax listValue = 
   | `ListV%`(value*)

;; ../../../../spec-concrete/2.1.1-value.watsup:40.21-40.35
syntax tupleValue = 
   | `TupleV%`(value*)

;; ../../../../spec-concrete/2.1.1-value.watsup:41.27-41.54
syntax headerStackValue = 
   | `HeaderStackV%%%`(value*, nat, nat)

;; ../../../../spec-concrete/2.1.1-value.watsup:43.21-43.29
syntax fieldValue = 
   | `%%`(value, id)

;; ../../../../spec-concrete/2.1.1-value.watsup:45.22-45.45
syntax structValue = 
   | `StructV%%`(tid, fieldValue*)

;; ../../../../spec-concrete/2.1.1-value.watsup:46.22-46.50
syntax headerValue = 
   | `HeaderV%%%`(tid, bool, fieldValue*)

;; ../../../../spec-concrete/2.1.1-value.watsup:47.27-47.55
syntax headerUnionValue = 
   | `HeaderUnionV%%`(tid, fieldValue*)

;; ../../../../spec-concrete/2.1.1-value.watsup:50.1-51.24
syntax enumValue = 
   | `EnumV%%`(tid, id)
   | `SEnumV%%%`(tid, id, value)

;; ../../../../spec-concrete/2.1.1-value.watsup:54.1-60.14
syntax dataValue = 
   | `ListV%`(value*)
   | `TupleV%`(value*)
   | `HeaderStackV%%%`(value*, nat, nat)
   | `StructV%%`(tid, fieldValue*)
   | `HeaderV%%%`(tid, bool, fieldValue*)
   | `HeaderUnionV%%`(tid, fieldValue*)
   | `EnumV%%`(tid, id)
   | `SEnumV%%%`(tid, id, value)

;; ../../../../spec-concrete/2.1.1-value.watsup:66.23-66.31
syntax defaultValue = 
   | `DefaultV`()

;; ../../../../spec-concrete/2.1.1-value.watsup:68.29-68.43
syntax invalidHeaderValue = 
   | `InvalidHeaderV`()

;; ../../../../spec-concrete/2.1.1-value.watsup:71.1-72.23
syntax sequenceValue = 
   | `SeqV%`(value*)
   | `SeqDefaultV%`(value*)

;; ../../../../spec-concrete/2.1.1-value.watsup:75.1-76.31
syntax recordValue = 
   | `RecordV%`(fieldValue*)
   | `RecordDefaultV%`(fieldValue*)

;; ../../../../spec-concrete/2.1.1-value.watsup:79.1-81.26
syntax setValue = 
   | `SingletonSetV%`(value)
   | `MaskSetV%%`(value, value)
   | `RangeSetV%%`(value, value)

;; ../../../../spec-concrete/2.1.1-value.watsup:84.1-85.33
syntax tableValue = 
   | `TableEnumV%%`(tid, id)
   | `TableStructV%%`(tid, fieldValue*)

;; ../../../../spec-concrete/2.1.1-value.watsup:88.1-93.15
syntax synthesizedValue = 
   | `DefaultV`()
   | `InvalidHeaderV`()
   | `SeqV%`(value*)
   | `SeqDefaultV%`(value*)
   | `RecordV%`(fieldValue*)
   | `RecordDefaultV%`(fieldValue*)
   | `SingletonSetV%`(value)
   | `MaskSetV%%`(value, value)
   | `RangeSetV%%`(value, value)
   | `TableEnumV%%`(tid, id)
   | `TableStructV%%`(tid, fieldValue*)

;; ../../../../spec-concrete/2.1.1-value.watsup:100.1-102.21
syntax value = 
   | `BoolV%`(bool)
   | `ErrV%`(id)
   | `MatchKindV%`(id)
   | `StrV%`(text)
   | `IntV%`(int)
   | `FIntV%%`(width, bits)
   | `FBitV%%`(width, bits)
   | `VBitV%%%`(width, width, bits)
   | `ListV%`(value*)
   | `TupleV%`(value*)
   | `HeaderStackV%%%`(value*, nat, nat)
   | `StructV%%`(tid, fieldValue*)
   | `HeaderV%%%`(tid, bool, fieldValue*)
   | `HeaderUnionV%%`(tid, fieldValue*)
   | `EnumV%%`(tid, id)
   | `SEnumV%%%`(tid, id, value)
   | `DefaultV`()
   | `InvalidHeaderV`()
   | `SeqV%`(value*)
   | `SeqDefaultV%`(value*)
   | `RecordV%`(fieldValue*)
   | `RecordDefaultV%`(fieldValue*)
   | `SingletonSetV%`(value)
   | `MaskSetV%%`(value, value)
   | `RangeSetV%%`(value, value)
   | `TableEnumV%%`(tid, id)
   | `TableStructV%%`(tid, fieldValue*)

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:5.1-5.28
def $to_int(int, int) : int =

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:12.1-12.31
def $to_bitstr(int, int) : int =

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:18.1-18.29
def $to_number(value) : int? =

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:20.1-20.27
   clause 0(value) = ?(i)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i) = numberValue

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:21.1-21.42
   clause 1(value) = ?($to_int(w as int, i))
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i) = numberValue

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:22.1-22.30
   clause 2(value) = ?(i)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(_width, i) = numberValue

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:23.1-23.32
   clause 3(value) = ?(i)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `VBitV%%%`
      -- let `VBitV%%%`_numberValue(_width, _width', i) = numberValue

   ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:24.1-25.15
   clause 4(_value) = ?()
      -- otherwise

;; ../../../../spec-concrete/2.2.1-type.watsup:14.1-18.9
syntax primitiveTypeIR = 
   | `VoidT`()
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()

;; ../../../../spec-concrete/2.2.1-type.watsup:25.1-28.14
syntax numberTypeIR = 
   | `IntT`()
   | `FIntT%`(nat)
   | `FBitT%`(nat)
   | `VBitT%`(nat)

;; ../../../../spec-concrete/2.2.1-type.watsup:31.1-32.17
syntax baseTypeIR = 
   | `VoidT`()
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(nat)
   | `FBitT%`(nat)
   | `VBitT%`(nat)

;; ../../../../spec-concrete/2.2.1-type.watsup:42.1-43.32
syntax namedTypeIR = 
   | `NameT%`(tid)
   | `SpecT%%`(polyTypeDefIR, typeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:54.1-55.20
syntax aliasTypeIR = 
   | `DefT%%`(tid, typeIR)
   | `NewT%%`(tid, typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:61.21-61.33
syntax listTypeIR = 
   | `ListT%`(typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:62.22-62.36
syntax tupleTypeIR = 
   | `TupleT%`(typeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:63.28-63.51
syntax headerStackTypeIR = 
   | `HeaderStackT%%`(typeIR, nat)

;; ../../../../spec-concrete/2.2.1-type.watsup:65.22-65.31
syntax fieldTypeIR = 
   | `%%`(typeIR, id)

;; ../../../../spec-concrete/2.2.1-type.watsup:67.23-67.47
syntax structTypeIR = 
   | `StructT%%`(tid, fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:68.23-68.47
syntax headerTypeIR = 
   | `HeaderT%%`(tid, fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:69.28-69.57
syntax headerUnionTypeIR = 
   | `HeaderUnionT%%`(tid, fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:71.23-71.31
syntax valueFieldIR = 
   | `%%`(id, value)

;; ../../../../spec-concrete/2.2.1-type.watsup:74.1-75.36
syntax enumTypeIR = 
   | `EnumT%%`(tid, id*)
   | `SEnumT%%%`(tid, typeIR, valueFieldIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:78.1-84.15
syntax dataTypeIR = 
   | `ListT%`(typeIR)
   | `TupleT%`(typeIR*)
   | `HeaderStackT%%`(typeIR, nat)
   | `StructT%%`(tid, fieldTypeIR*)
   | `HeaderT%%`(tid, fieldTypeIR*)
   | `HeaderUnionT%%`(tid, fieldTypeIR*)
   | `EnumT%%`(tid, id*)
   | `SEnumT%%%`(tid, typeIR, valueFieldIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:93.29-93.67
syntax externObjectTypeIR = 
   | `ExternT%%`(tid, map<rid, routineTypeDefIR>)

;; ../../../../spec-concrete/2.2.1-type.watsup:94.29-94.53
syntax parserObjectTypeIR = 
   | `ParserT%`(parameterTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:95.30-95.55
syntax controlObjectTypeIR = 
   | `ControlT%`(parameterTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:96.30-96.50
syntax packageObjectTypeIR = 
   | `PackageT%%`(tid, typeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:97.28-97.45
syntax tableObjectTypeIR = 
   | `TableT%%`(tid, typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:100.1-104.22
syntax objectTypeIR = 
   | `ExternT%%`(tid, map<rid, routineTypeDefIR>)
   | `ParserT%`(parameterTypeIR*)
   | `ControlT%`(parameterTypeIR*)
   | `PackageT%%`(tid, typeIR*)
   | `TableT%%`(tid, typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:107.1-109.17
syntax definedTypeIR = 
   | `DefT%%`(tid, typeIR)
   | `NewT%%`(tid, typeIR)
   | `ListT%`(typeIR)
   | `TupleT%`(typeIR*)
   | `HeaderStackT%%`(typeIR, nat)
   | `StructT%%`(tid, fieldTypeIR*)
   | `HeaderT%%`(tid, fieldTypeIR*)
   | `HeaderUnionT%%`(tid, fieldTypeIR*)
   | `EnumT%%`(tid, id*)
   | `SEnumT%%%`(tid, typeIR, valueFieldIR*)
   | `ExternT%%`(tid, map<rid, routineTypeDefIR>)
   | `ParserT%`(parameterTypeIR*)
   | `ControlT%`(parameterTypeIR*)
   | `PackageT%%`(tid, typeIR*)
   | `TableT%%`(tid, typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:115.24-115.32
syntax defaultTypeIR = 
   | `DefaultT`()

;; ../../../../spec-concrete/2.2.1-type.watsup:117.30-117.44
syntax invalidHeaderTypeIR = 
   | `InvalidHeaderT`()

;; ../../../../spec-concrete/2.2.1-type.watsup:120.1-121.24
syntax sequenceTypeIR = 
   | `SeqT%`(typeIR*)
   | `SeqDefaultT%`(typeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:124.1-125.32
syntax recordTypeIR = 
   | `RecordT%`(fieldTypeIR*)
   | `RecordDefaultT%`(fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:127.20-127.31
syntax setTypeIR = 
   | `SetT%`(typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:130.1-131.34
syntax tableTypeIR = 
   | `TableEnumT%%`(tid, id*)
   | `TableStructT%%`(tid, fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:134.1-139.16
syntax synthesizedTypeIR = 
   | `DefaultT`()
   | `InvalidHeaderT`()
   | `SeqT%`(typeIR*)
   | `SeqDefaultT%`(typeIR*)
   | `RecordT%`(fieldTypeIR*)
   | `RecordDefaultT%`(fieldTypeIR*)
   | `SetT%`(typeIR)
   | `TableEnumT%%`(tid, id*)
   | `TableStructT%%`(tid, fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:146.1-149.22
syntax typeIR = 
   | `VoidT`()
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(nat)
   | `FBitT%`(nat)
   | `VBitT%`(nat)
   | `NameT%`(tid)
   | `SpecT%%`(polyTypeDefIR, typeIR*)
   | `DefT%%`(tid, typeIR)
   | `NewT%%`(tid, typeIR)
   | `ListT%`(typeIR)
   | `TupleT%`(typeIR*)
   | `HeaderStackT%%`(typeIR, nat)
   | `StructT%%`(tid, fieldTypeIR*)
   | `HeaderT%%`(tid, fieldTypeIR*)
   | `HeaderUnionT%%`(tid, fieldTypeIR*)
   | `EnumT%%`(tid, id*)
   | `SEnumT%%%`(tid, typeIR, valueFieldIR*)
   | `ExternT%%`(tid, map<rid, routineTypeDefIR>)
   | `ParserT%`(parameterTypeIR*)
   | `ControlT%`(parameterTypeIR*)
   | `PackageT%%`(tid, typeIR*)
   | `TableT%%`(tid, typeIR)
   | `DefaultT`()
   | `InvalidHeaderT`()
   | `SeqT%`(typeIR*)
   | `SeqDefaultT%`(typeIR*)
   | `RecordT%`(fieldTypeIR*)
   | `RecordDefaultT%`(fieldTypeIR*)
   | `SetT%`(typeIR)
   | `TableEnumT%%`(tid, id*)
   | `TableStructT%%`(tid, fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:155.24-155.37
syntax monoTypeDefIR = 
   | `MonoTD%`(typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:157.24-157.47
syntax polyTypeDefIR = 
   | `PolyTD%%%`(typeIR, tid*, tid*)

;; ../../../../spec-concrete/2.2.1-type.watsup:160.1-161.18
syntax typeDefIR = 
   | `MonoTD%`(typeIR)
   | `PolyTD%%%`(typeIR, tid*, tid*)

;; ../../../../spec-concrete/2.2.1-type.watsup:167.26-167.52
syntax parameterTypeIR = 
   | `%%%%`(direction, typeIR, id, value?)

;; ../../../../spec-concrete/2.2.1-type.watsup:174.1-183.29
syntax routineTypeIR = 
   | `BuiltinFuncT%%`(parameterTypeIR*, typeIR)
   | `FuncT%%`(parameterTypeIR*, typeIR)
   | `ExternFuncT%%`(parameterTypeIR*, typeIR)
   | `ActionT%`(parameterTypeIR*)
   | `BuiltinMethodT%%`(parameterTypeIR*, typeIR)
   | `ExternMethodT%%`(parameterTypeIR*, typeIR)
   | `ExternAbstractMethodT%%`(parameterTypeIR*, typeIR)
   | `ParserApplyMethodT%`(parameterTypeIR*)
   | `ControlApplyMethodT%`(parameterTypeIR*)
   | `TableApplyMethodT%`(typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:189.31-189.51
syntax monoRoutineTypeDefIR = 
   | `MonoTD%`(routineTypeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:191.31-191.61
syntax polyRoutineTypeDefIR = 
   | `PolyTD%%%`(routineTypeIR, tid*, tid*)

;; ../../../../spec-concrete/2.2.1-type.watsup:194.1-195.25
syntax routineTypeDefIR = 
   | `MonoTD%`(routineTypeIR)
   | `PolyTD%%%`(routineTypeIR, tid*, tid*)

;; ../../../../spec-concrete/2.2.1-type.watsup:201.37-201.52
syntax constructorParameterTypeIR = parameterTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:208.3-208.50
syntax constructorTypeIR = 
   | `ConstructorT%%`(constructorParameterTypeIR*, typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:214.31-214.65
syntax constructorTypeDefIR = 
   | `PolyTD%%%`(constructorTypeIR, tid*, tid*)

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:9.1-9.34
def $is_baseTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:10.1-10.38
   clause 0(typeIR) = true
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:11.1-12.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:16.1-16.39
def $is_primitiveTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:17.1-17.48
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:18.1-19.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:21.1-21.35
def $is_void_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:22.1-22.34
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `VoidT`

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:23.1-24.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:26.1-26.35
def $is_bool_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:27.1-27.34
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:28.1-29.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:31.1-31.36
def $is_error_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:32.1-32.34
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ErrT`

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:33.1-34.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:36.1-36.40
def $is_matchkind_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:37.1-37.44
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `MatchKindT`

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:38.1-39.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:41.1-41.37
def $is_string_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:42.1-42.35
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:43.1-44.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:48.1-48.36
def $is_numberTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:49.1-49.42
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:50.1-51.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:53.1-53.44
def $is_arbitrary_int_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:54.1-54.42
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:55.1-56.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:58.1-58.40
def $is_fixed_int_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:59.1-59.41
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:60.1-61.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:63.1-63.40
def $is_fixed_bit_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:64.1-64.41
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:65.1-66.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:76.1-76.34
def $is_dataTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:77.1-77.38
   clause 0(typeIR) = true
      -- if typeIR <: dataTypeIR
      -- let dataTypeIR = typeIR as dataTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:78.1-79.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:81.1-81.41
def $is_headerStackTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:82.1-82.52
   clause 0(typeIR) = true
      -- if typeIR <: headerStackTypeIR
      -- let headerStackTypeIR = typeIR as headerStackTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:83.1-84.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:88.1-88.36
def $is_objectTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:89.1-89.42
   clause 0(typeIR) = true
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:90.1-91.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:93.1-93.44
def $is_extern_object_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:94.1-94.56
   clause 0(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let externObjectTypeIR = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:95.1-96.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:98.1-98.44
def $is_parser_object_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:99.1-99.56
   clause 0(typeIR) = true
      -- if typeIR <: parserObjectTypeIR
      -- let parserObjectTypeIR = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:100.1-101.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:103.1-103.45
def $is_control_object_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:104.1-104.58
   clause 0(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let controlObjectTypeIR = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:105.1-106.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:108.1-108.45
def $is_package_object_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:109.1-109.58
   clause 0(typeIR) = true
      -- if typeIR <: packageObjectTypeIR
      -- let packageObjectTypeIR = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:110.1-111.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:113.1-113.43
def $is_table_object_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:114.1-114.56
   clause 0(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let controlObjectTypeIR = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:115.1-116.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:120.1-120.41
def $is_synthesizedTypeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:121.1-121.52
   clause 0(typeIR) = true
      -- if typeIR <: tableObjectTypeIR
      -- let tableObjectTypeIR = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:122.1-123.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:125.1-125.34
def $is_set_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:126.1-126.34
   clause 0(typeIR) = true
      -- if typeIR <: setTypeIR
      -- let `SetT%`_setTypeIR(_typeIR) = typeIR as setTypeIR

   ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:127.1-128.15
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:5.16-5.24
syntax bound = set<tid>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:6.16-6.32
syntax theta = map<tid, typeIR>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:8.1-8.31
def $free_type(typeIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:33.1-33.38
   clause 0(typeIR) = `{%}`_set<tid>([])
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:37.1-37.37
   clause 1(typeIR) = `{%}`_set<tid>([tid])
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(tid) = namedTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:39.1-42.59
   clause 2(typeIR') = $union_set<tid>(bound_base, bound_args)
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(polyTypeDefIR, typeIR*{typeIR <- typeIR*}) = namedTypeIR
      -- let bound_base = $free_typeDef(polyTypeDefIR as typeDefIR)
      -- let bound_args = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:46.1-46.51
   clause 3(typeIR') = $free_type(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `DefT%%`
      -- let `DefT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:48.1-48.51
   clause 4(typeIR') = $free_type(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:52.1-52.50
   clause 5(typeIR') = $free_type(typeIR)
      -- if typeIR' <: listTypeIR
      -- let `ListT%`_listTypeIR(typeIR) = typeIR' as listTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:54.1-55.42
   clause 6(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR*{typeIR <- typeIR*}) = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:57.1-57.59
   clause 7(typeIR') = $free_type(typeIR)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, _nat) = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:59.1-60.42
   clause 8(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as structTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:62.1-63.42
   clause 9(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:65.1-66.42
   clause 10(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as headerUnionTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:68.1-68.37
   clause 11(typeIR) = `{%}`_set<tid>([])
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(_tid, _id*{_id <- _id*}) = enumTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:70.1-70.55
   clause 12(typeIR') = $free_type(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:74.1-75.62
   clause 13(typeIR) = $unions_set<tid>($free_routineTypeDef(routineTypeDefIR)*{routineTypeDefIR <- routineTypeDefIR*})
      -- if typeIR <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(_tid, `{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(_rid, routineTypeDefIR)*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*})) = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:77.1-80.64
   clause 14(typeIR) = bound_params
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = typeIR as parserObjectTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:82.1-85.64
   clause 15(typeIR) = bound_params
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = typeIR as controlObjectTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:87.1-88.42
   clause 16(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(tid, typeIR*{typeIR <- typeIR*}) = typeIR' as packageObjectTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:90.1-90.53
   clause 17(typeIR') = $free_type(typeIR)
      -- if typeIR' <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, typeIR) = typeIR' as tableObjectTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:94.1-94.36
   clause 18(typeIR) = `{%}`_set<tid>([])
      -- if typeIR <: defaultTypeIR
      -- let defaultTypeIR = typeIR as defaultTypeIR
      -- if (defaultTypeIR = `DefaultT`_defaultTypeIR())

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:96.1-96.42
   clause 19(typeIR) = `{%}`_set<tid>([])
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = `InvalidHeaderT`_invalidHeaderTypeIR())

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:98.1-99.42
   clause 20(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR*{typeIR <- typeIR*}) = sequenceTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:101.1-102.42
   clause 21(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR*{typeIR <- typeIR*}) = sequenceTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:104.1-105.42
   clause 22(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RecordT%`
      -- let `RecordT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = recordTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:107.1-108.42
   clause 23(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RecordDefaultT%`
      -- let `RecordDefaultT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = recordTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:110.1-111.23
   clause 24(typeIR') = $free_type(typeIR)
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR) = typeIR' as setTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:113.1-113.42
   clause 25(typeIR) = `{%}`_set<tid>([])
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TableEnumT%%`
      -- let `TableEnumT%%`_tableTypeIR(_tid, _id*{_id <- _id*}) = tableTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:115.1-115.44
   clause 26(typeIR) = `{%}`_set<tid>([])
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TableStructT%%`
      -- let `TableStructT%%`_tableTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = tableTypeIR

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:9.1-9.37
def $free_typeDef(typeDefIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:121.1-121.54
   clause 0(typeDefIR) = $free_type(typeIR)
      -- if typeDefIR <: monoTypeDefIR
      -- let `MonoTD%`_monoTypeDefIR(typeIR) = typeDefIR as monoTypeDefIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:123.1-126.49
   clause 1(typeDefIR) = $diff_set<tid>(bound_base, bound_tparams)
      -- if typeDefIR <: polyTypeDefIR
      -- let `PolyTD%%%`_polyTypeDefIR(typeIR_base, tid*{tid <- tid*}, tid_hidden*{tid_hidden <- tid_hidden*}) = typeDefIR as polyTypeDefIR
      -- let bound_base = $free_type(typeIR_base)
      -- let bound_tparams = `{%}`_set<tid>(tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*})

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:10.1-10.49
def $free_parameterType(parameterTypeIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:132.1-132.59
   clause 0(`%%%%`_parameterTypeIR(_direction, typeIR, _id, _value?{_value <- _value?})) = $free_type(typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:11.1-11.45
def $free_routineType(routineTypeIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:138.1-144.43
   clause 0(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR matches `BuiltinFuncT%%`
      -- let `BuiltinFuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:146.1-152.43
   clause 1(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR matches `FuncT%%`
      -- let `FuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:154.1-160.43
   clause 2(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR matches `ExternFuncT%%`
      -- let `ExternFuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:162.1-167.64
   clause 3(routineTypeIR) = bound_params
      -- if routineTypeIR matches `ActionT%`
      -- let `ActionT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:169.1-175.43
   clause 4(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR matches `BuiltinMethodT%%`
      -- let `BuiltinMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:177.1-183.43
   clause 5(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR matches `ExternMethodT%%`
      -- let `ExternMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:185.1-191.43
   clause 6(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
      -- if routineTypeIR matches `ExternAbstractMethodT%%`
      -- let `ExternAbstractMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
      -- let bound_ret = $free_type(typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:193.1-198.64
   clause 7(routineTypeIR) = bound_params
      -- if routineTypeIR matches `ParserApplyMethodT%`
      -- let `ParserApplyMethodT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:200.1-205.64
   clause 8(routineTypeIR) = bound_params
      -- if routineTypeIR matches `ControlApplyMethodT%`
      -- let `ControlApplyMethodT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:207.1-211.43
   clause 9(routineTypeIR) = bound_ret
      -- if routineTypeIR matches `TableApplyMethodT%`
      -- let `TableApplyMethodT%`_routineTypeIR(typeIR_ret) = routineTypeIR
      -- let bound_ret = $free_type(typeIR_ret)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:12.1-12.51
def $free_routineTypeDef(routineTypeDefIR) : bound =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:217.1-218.37
   clause 0(routineTypeDefIR) = $free_routineType(routineTypeIR)
      -- if routineTypeDefIR <: monoRoutineTypeDefIR
      -- let `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) = routineTypeDefIR as monoRoutineTypeDefIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:220.1-225.49
   clause 1(routineTypeDefIR) = $diff_set<tid>(bound_base, bound_tparams)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, tid*{tid <- tid*}, tid_hidden*{tid_hidden <- tid_hidden*}) = routineTypeDefIR as polyRoutineTypeDefIR
      -- let bound_base = $free_routineType(routineTypeIR)
      -- let bound_tparams = `{%}`_set<tid>(tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*})

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:14.1-14.40
def $subst_type(theta, typeIR) : typeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:231.1-231.43
   clause 0(set<pair<tid, typeIR>>, typeIR) = typeIR
      -- if (set<pair<tid, typeIR>> = `{%}`_set<pair<tid, typeIR>>([]))

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:232.1-233.15
   clause 1(theta, typeIR) = $subst_type'(theta, typeIR)
      -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:15.1-15.41
def $subst_type'(theta, typeIR) : typeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:237.1-238.52
   clause 0(theta, typeIR') = typeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(tid) = namedTypeIR
      -- let typeIR''?{typeIR'' <- typeIR''?} = $find_map<tid, typeIR>(theta, tid)
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:240.1-244.54
   clause 1(theta, typeIR') = `SpecT%%`_namedTypeIR(polyTypeDefIR_subst, typeIR_subst*{typeIR_subst <- typeIR_subst*}) as typeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(polyTypeDefIR, typeIR*{typeIR <- typeIR*}) = namedTypeIR
      -- let typeDefIR = $subst_typeDef'(theta, polyTypeDefIR as typeDefIR)
      -- if typeDefIR <: polyTypeDefIR
      -- let polyTypeDefIR_subst = typeDefIR as polyTypeDefIR
      -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:248.1-250.51
   clause 2(theta, typeIR') = `DefT%%`_aliasTypeIR(tid, typeIR_subst) as typeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `DefT%%`
      -- let `DefT%%`_aliasTypeIR(tid, typeIR) = aliasTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:252.1-254.51
   clause 3(theta, typeIR') = `NewT%%`_aliasTypeIR(tid, typeIR_subst) as typeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(tid, typeIR) = aliasTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:258.1-260.51
   clause 4(theta, typeIR') = `ListT%`_listTypeIR(typeIR_subst) as typeIR
      -- if typeIR' <: listTypeIR
      -- let `ListT%`_listTypeIR(typeIR) = typeIR' as listTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:262.1-264.54
   clause 5(theta, typeIR') = `TupleT%`_tupleTypeIR(typeIR_subst*{typeIR_subst <- typeIR_subst*}) as typeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR*{typeIR <- typeIR*}) = typeIR' as tupleTypeIR
      -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:266.1-268.51
   clause 6(theta, typeIR') = `HeaderStackT%%`_headerStackTypeIR(typeIR_subst, n) as typeIR
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n) = typeIR' as headerStackTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:270.1-275.58
   clause 7(theta, typeIR) = `StructT%%`_structTypeIR(tid, `%%`_fieldTypeIR(typeIR_f_subst, id_f)*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*}) as typeIR
      -- if typeIR <: structTypeIR
      -- let `StructT%%`_structTypeIR(tid, `%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = typeIR as structTypeIR
      -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:277.1-282.58
   clause 8(theta, typeIR) = `HeaderT%%`_headerTypeIR(tid, `%%`_fieldTypeIR(typeIR_f_subst, id_f)*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*}) as typeIR
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(tid, `%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = typeIR as headerTypeIR
      -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:284.1-289.58
   clause 9(theta, typeIR) = `HeaderUnionT%%`_headerUnionTypeIR(tid, `%%`_fieldTypeIR(typeIR_f_subst, id_f)*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*}) as typeIR
      -- if typeIR <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(tid, `%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = typeIR as headerUnionTypeIR
      -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:291.1-296.51
   clause 10(theta, typeIR') = `SEnumT%%%`_enumTypeIR(tid, typeIR_subst, valueFieldIR*{valueFieldIR <- valueFieldIR*}) as typeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(tid, typeIR, valueFieldIR*{valueFieldIR <- valueFieldIR*}) = enumTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:300.1-306.60
   clause 11(theta, typeIR) = `ExternT%%`_externObjectTypeIR(tid, `{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(rid, routineTypeDefIR_subst)*{rid <- rid*, routineTypeDefIR_subst <- routineTypeDefIR_subst*})) as typeIR
      -- if typeIR <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(tid, `{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(rid, routineTypeDefIR)*{rid <- rid*, routineTypeDefIR <- routineTypeDefIR*})) = typeIR as externObjectTypeIR
      -- (let routineTypeDefIR_subst = $subst_routineTypeDef'(theta, routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*, routineTypeDefIR_subst <- routineTypeDefIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:308.1-311.58
   clause 12(theta, typeIR) = `ParserT%`_parserObjectTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}) as typeIR
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = typeIR as parserObjectTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:313.1-316.58
   clause 13(theta, typeIR) = `ControlT%`_controlObjectTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}) as typeIR
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = typeIR as controlObjectTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:318.1-320.54
   clause 14(theta, typeIR') = `PackageT%%`_packageObjectTypeIR(tid, typeIR_subst*{typeIR_subst <- typeIR_subst*}) as typeIR
      -- if typeIR' <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(tid, typeIR*{typeIR <- typeIR*}) = typeIR' as packageObjectTypeIR
      -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:322.1-324.51
   clause 15(theta, typeIR') = `TableT%%`_tableObjectTypeIR(tid, typeIR_subst) as typeIR
      -- if typeIR' <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(tid, typeIR) = typeIR' as tableObjectTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:328.1-330.54
   clause 16(theta, typeIR') = `SeqT%`_sequenceTypeIR(typeIR_subst*{typeIR_subst <- typeIR_subst*}) as typeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR*{typeIR <- typeIR*}) = sequenceTypeIR
      -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:332.1-334.54
   clause 17(theta, typeIR') = `SeqDefaultT%`_sequenceTypeIR(typeIR_subst*{typeIR_subst <- typeIR_subst*}) as typeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR*{typeIR <- typeIR*}) = sequenceTypeIR
      -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:336.1-341.58
   clause 18(theta, typeIR) = `RecordT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_f_subst, id_f)*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*}) as typeIR
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordT%`
      -- let `RecordT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = recordTypeIR
      -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:343.1-348.58
   clause 19(theta, typeIR) = `RecordDefaultT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_f_subst, id_f)*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*}) as typeIR
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordDefaultT%`
      -- let `RecordDefaultT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = recordTypeIR
      -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:350.1-352.51
   clause 20(theta, typeIR') = `SetT%`_setTypeIR(typeIR_subst) as typeIR
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR) = typeIR' as setTypeIR
      -- let typeIR_subst = $subst_type'(theta, typeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:356.1-357.15
   clause 21(theta, typeIR) = typeIR
      -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:16.1-16.49
def $subst_typeDef(theta, typeDefIR) : typeDefIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:363.1-363.52
   clause 0(set<pair<tid, typeIR>>, typeDefIR) = typeDefIR
      -- if (set<pair<tid, typeIR>> = `{%}`_set<pair<tid, typeIR>>([]))

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:364.1-366.15
   clause 1(theta, typeDefIR) = $subst_typeDef'(theta, typeDefIR)
      -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:17.1-17.50
def $subst_typeDef'(theta, typeDefIR) : typeDefIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:368.1-368.79
   clause 0(theta, typeDefIR) = `MonoTD%`_monoTypeDefIR($subst_type'(theta, typeIR)) as typeDefIR
      -- if typeDefIR <: monoTypeDefIR
      -- let `MonoTD%`_monoTypeDefIR(typeIR) = typeDefIR as monoTypeDefIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:370.1-389.62
   clause 1(theta, typeDefIR) = `PolyTD%%%`_polyTypeDefIR(typeIR_base_subst, tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*}, tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*}) as typeDefIR
      -- if typeDefIR <: polyTypeDefIR
      -- let `PolyTD%%%`_polyTypeDefIR(typeIR_base, tid*{tid <- tid*}, tid_hidden*{tid_hidden <- tid_hidden*}) = typeDefIR as polyTypeDefIR
      -- let `{%}`_set<tid>(tid_free*{tid_free <- tid_free*}) = $diff_set<tid>($free_type(typeIR_base), `{%}`_set<tid>(tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}))
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_free) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}
      -- let bound_capture = $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*})
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- (if ~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}
      -- let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} = tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|]
      -- let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} = tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|]
      -- let theta' = $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, `NameT%`_namedTypeIR(tid_fresh_spec) as typeIR*{tid_fresh_spec <- tid_fresh_spec*})
      -- let theta'' = $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, `NameT%`_namedTypeIR(tid_fresh_hidden) as typeIR*{tid_fresh_hidden <- tid_fresh_hidden*})
      -- let typeIR_base_subst = $subst_type(theta'', typeIR_base)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:18.1-18.67
def $subst_parameterType(theta, parameterTypeIR) : parameterTypeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:395.1-396.20
   clause 0(set<pair<tid, typeIR>>, parameterTypeIR) = parameterTypeIR
      -- if (set<pair<tid, typeIR>> = `{%}`_set<pair<tid, typeIR>>([]))

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:397.1-399.15
   clause 1(theta, parameterTypeIR) = $subst_parameterType'(theta, parameterTypeIR)
      -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:19.1-19.68
def $subst_parameterType'(theta, parameterTypeIR) : parameterTypeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:401.1-403.51
   clause 0(theta, `%%%%`_parameterTypeIR(direction, typeIR, id, value?{value <- value?})) = `%%%%`_parameterTypeIR(direction, typeIR_subst, id, value?{value <- value?})
      -- let typeIR_subst = $subst_type'(theta, typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:20.1-20.61
def $subst_routineType(theta, routineTypeIR) : routineTypeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:409.1-410.18
   clause 0(set<pair<tid, typeIR>>, routineTypeIR) = routineTypeIR
      -- if (set<pair<tid, typeIR>> = `{%}`_set<pair<tid, typeIR>>([]))

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:411.1-413.15
   clause 1(theta, routineTypeIR) = $subst_routineType'(theta, routineTypeIR)
      -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:21.1-21.62
def $subst_routineType'(theta, routineTypeIR) : routineTypeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:415.1-422.59
   clause 0(theta, routineTypeIR) = `BuiltinFuncT%%`_routineTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}, typeIR_ret_subst)
      -- if routineTypeIR matches `BuiltinFuncT%%`
      -- let `BuiltinFuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:424.1-431.59
   clause 1(theta, routineTypeIR) = `FuncT%%`_routineTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}, typeIR_ret_subst)
      -- if routineTypeIR matches `FuncT%%`
      -- let `FuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:433.1-440.59
   clause 2(theta, routineTypeIR) = `ExternFuncT%%`_routineTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}, typeIR_ret_subst)
      -- if routineTypeIR matches `ExternFuncT%%`
      -- let `ExternFuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:442.1-448.58
   clause 3(theta, routineTypeIR) = `ActionT%`_routineTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*})
      -- if routineTypeIR matches `ActionT%`
      -- let `ActionT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:450.1-457.59
   clause 4(theta, routineTypeIR) = `BuiltinMethodT%%`_routineTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}, typeIR_ret_subst)
      -- if routineTypeIR matches `BuiltinMethodT%%`
      -- let `BuiltinMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:459.1-466.59
   clause 5(theta, routineTypeIR) = `ExternMethodT%%`_routineTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}, typeIR_ret_subst)
      -- if routineTypeIR matches `ExternMethodT%%`
      -- let `ExternMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:468.1-475.59
   clause 6(theta, routineTypeIR) = `ExternAbstractMethodT%%`_routineTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}, typeIR_ret_subst)
      -- if routineTypeIR matches `ExternAbstractMethodT%%`
      -- let `ExternAbstractMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:477.1-483.58
   clause 7(theta, routineTypeIR) = `ParserApplyMethodT%`_routineTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*})
      -- if routineTypeIR matches `ParserApplyMethodT%`
      -- let `ParserApplyMethodT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:485.1-491.58
   clause 8(theta, routineTypeIR) = `ControlApplyMethodT%`_routineTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*})
      -- if routineTypeIR matches `ControlApplyMethodT%`
      -- let `ControlApplyMethodT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:493.1-498.59
   clause 9(theta, routineTypeIR) = `TableApplyMethodT%`_routineTypeIR(typeIR_ret_subst)
      -- if routineTypeIR matches `TableApplyMethodT%`
      -- let `TableApplyMethodT%`_routineTypeIR(typeIR_ret) = routineTypeIR
      -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:22.1-22.70
def $subst_routineTypeDef(theta, routineTypeDefIR) : routineTypeDefIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:504.1-505.21
   clause 0(set<pair<tid, typeIR>>, routineTypeDefIR) = routineTypeDefIR
      -- if (set<pair<tid, typeIR>> = `{%}`_set<pair<tid, typeIR>>([]))

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:506.1-508.15
   clause 1(theta, routineTypeDefIR) = $subst_routineTypeDef'(theta, routineTypeDefIR)
      -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:23.1-23.71
def $subst_routineTypeDef'(theta, routineTypeDefIR) : routineTypeDefIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:510.1-511.53
   clause 0(theta, routineTypeDefIR) = `MonoTD%`_monoRoutineTypeDefIR($subst_routineType'(theta, routineTypeIR)) as routineTypeDefIR
      -- if routineTypeDefIR <: monoRoutineTypeDefIR
      -- let `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) = routineTypeDefIR as monoRoutineTypeDefIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:513.1-532.73
   clause 1(theta, routineTypeDefIR) = `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR_subst, tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*}, tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*}) as routineTypeDefIR
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, tid*{tid <- tid*}, tid_hidden*{tid_hidden <- tid_hidden*}) = routineTypeDefIR as polyRoutineTypeDefIR
      -- let `{%}`_set<tid>(tid_free*{tid_free <- tid_free*}) = $diff_set<tid>($free_routineType(routineTypeIR), `{%}`_set<tid>(tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}))
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_free) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}
      -- let bound_capture = $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*})
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- (if ~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}
      -- let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} = tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|]
      -- let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} = tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|]
      -- let theta' = $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, `NameT%`_namedTypeIR(tid_fresh_spec) as typeIR*{tid_fresh_spec <- tid_fresh_spec*})
      -- let theta'' = $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, `NameT%`_namedTypeIR(tid_fresh_hidden) as typeIR*{tid_fresh_hidden <- tid_fresh_hidden*})
      -- let routineTypeIR_subst = $subst_routineType(theta'', routineTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:24.1-24.73
def $subst_constructorType(theta, constructorTypeIR) : constructorTypeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:538.1-539.22
   clause 0(set<pair<tid, typeIR>>, constructorTypeIR) = constructorTypeIR
      -- if (set<pair<tid, typeIR>> = `{%}`_set<pair<tid, typeIR>>([]))

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:540.1-542.15
   clause 1(theta, constructorTypeIR) = $subst_constructorType'(theta, constructorTypeIR)
      -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:25.1-25.74
def $subst_constructorType'(theta, constructorTypeIR) : constructorTypeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:544.1-551.59
   clause 0(theta, `ConstructorT%%`_constructorTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_obj)) = `ConstructorT%%`_constructorTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}, typeIR_obj_subst)
      -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
      -- let typeIR_obj_subst = $subst_type'(theta, typeIR_obj)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:561.1-561.53
def $specialize_typeDef(typeDefIR, typeIR*) : typeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:563.1-563.53
   clause 0(typeDefIR, typeIR'*{typeIR' <- typeIR'*}) = typeIR
      -- if typeDefIR <: monoTypeDefIR
      -- let `MonoTD%`_monoTypeDefIR(typeIR) = typeDefIR as monoTypeDefIR
      -- if typeIR'*{typeIR' <- typeIR'*} matches []

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:565.1-568.49
   clause 1(typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = $subst_type(theta, typeIR_base)
      -- if typeDefIR <: polyTypeDefIR
      -- let `PolyTD%%%`_polyTypeDefIR(typeIR_base, tid*{tid <- tid*}, tid_hidden*{tid_hidden <- tid_hidden*}) = typeDefIR as polyTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- let theta = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid_tparam, typeIR_arg)*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*})

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:574.1-575.26
def $specialize_routineTypeDef(routineTypeDefIR, typeIR*) : (routineTypeIR, tid*) =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:577.1-578.25
   clause 0(routineTypeDefIR, typeIR*{typeIR <- typeIR*}) = (routineTypeIR, [])
      -- if routineTypeDefIR <: monoRoutineTypeDefIR
      -- let `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) = routineTypeDefIR as monoRoutineTypeDefIR
      -- if typeIR*{typeIR <- typeIR*} matches []

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:580.1-587.49
   clause 1(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), [])
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, tid*{tid <- tid*}, tid_hidden*{tid_hidden <- tid_hidden*}) = routineTypeDefIR as polyRoutineTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
      -- let theta = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid_tparam, typeIR_arg)*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:589.1-597.56
   clause 2(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*})
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, tid*{tid <- tid*}, tid_hidden*{tid_hidden <- tid_hidden*}) = routineTypeDefIR as polyRoutineTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if ((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|)
      -- let theta = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid_tparam, `NameT%`_namedTypeIR(tid_fresh) as typeIR)*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:599.1-610.53
   clause 3(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*})
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, tid*{tid <- tid*}, tid_hidden*{tid_hidden <- tid_hidden*}) = routineTypeDefIR as polyRoutineTypeDefIR
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} = typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ `NameT%`_namedTypeIR(tid_fresh) as typeIR*{tid_fresh <- tid_fresh*}
      -- let theta = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid_tparam, typeIR_arg_new)*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*})

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:616.1-617.30
def $specialize_constructorTypeDef(constructorTypeDefIR, typeIR*) : (constructorTypeIR, tid*) =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:619.1-628.57
   clause 0(`PolyTD%%%`_constructorTypeDefIR(constructorTypeIR, tid*{tid <- tid*}, tid_hidden*{tid_hidden <- tid_hidden*}), typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, [])
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
      -- let theta = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid_tparam, typeIR_arg)*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*})
      -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:630.1-640.57
   clause 1(`PolyTD%%%`_constructorTypeDefIR(constructorTypeIR, tid*{tid <- tid*}, tid_hidden*{tid_hidden <- tid_hidden*}), typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, tid_fresh*{tid_fresh <- tid_fresh*})
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if ((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|)
      -- let theta = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid_tparam, `NameT%`_namedTypeIR(tid_fresh) as typeIR)*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*})
      -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:642.1-655.57
   clause 2(`PolyTD%%%`_constructorTypeDefIR(constructorTypeIR, tid*{tid <- tid*}, tid_hidden*{tid_hidden <- tid_hidden*}), typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, tid_fresh*{tid_fresh <- tid_fresh*})
      -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
      -- if (((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|)
      -- let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} = typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ `NameT%`_namedTypeIR(tid_fresh) as typeIR*{tid_fresh <- tid_fresh*}
      -- let theta = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid_tparam, typeIR_arg_new)*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*})
      -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:662.1-662.28
def $canon(typeIR) : typeIR =

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:664.1-665.65
   clause 0(typeIR') = $canon(typeIR)
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(polyTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = namedTypeIR
      -- let typeIR = $specialize_typeDef(polyTypeDefIR as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:667.1-667.43
   clause 1(typeIR') = $canon(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `DefT%%`
      -- let `DefT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:669.1-670.15
   clause 2(typeIR) = typeIR
      -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:7.1-7.38
def $is_nominal_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:10.1-11.40
   clause 0(typeIR) = $is_nominal_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:8.1-8.39
def $is_nominal_typeIR'(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:12.1-12.41
   clause 0(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `DefT%%`
      -- let `DefT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:13.1-13.44
   clause 1(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as structTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:14.1-14.44
   clause 2(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:15.1-15.49
   clause 3(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:16.1-16.42
   clause 4(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(_tid, _id*{_id <- _id*}) = enumTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:17.1-17.45
   clause 5(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, _typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:18.1-18.44
   clause 6(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(_tid, _map<rid, routineTypeDefIR>) = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:19.1-19.43
   clause 7(typeIR) = true
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, _typeIR) = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:20.1-21.15
   clause 8(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:25.1-25.42
def $is_defaultable_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:28.1-29.44
   clause 0(typeIR) = $is_defaultable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:26.1-26.43
def $is_defaultable_typeIR'(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:30.1-30.42
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:31.1-31.41
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ErrT`

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:32.1-32.41
   clause 2(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:33.1-33.49
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:34.1-35.35
   clause 4(typeIR') = $is_defaultable_typeIR(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `DefT%%`
      -- let `DefT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:36.1-37.40
   clause 5(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR*{typeIR <- typeIR*}) = typeIR' as tupleTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:38.1-39.35
   clause 6(typeIR') = $is_defaultable_typeIR(typeIR)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, _nat) = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:40.1-41.40
   clause 7(typeIR') = true
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as structTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:42.1-43.40
   clause 8(typeIR') = true
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as headerTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:44.1-45.40
   clause 9(typeIR') = true
      -- if typeIR' <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as headerUnionTypeIR
      -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:46.1-46.46
   clause 10(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(_tid, _id*{_id <- _id*}) = enumTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:47.1-48.35
   clause 11(typeIR') = $is_defaultable_typeIR(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:49.1-50.15
   clause 12(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:54.1-54.40
def $is_equalable_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:57.1-58.42
   clause 0(typeIR) = $is_equalable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:55.1-55.41
def $is_equalable_typeIR'(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:59.1-59.41
   clause 0(typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `VoidT`

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:60.1-60.43
   clause 1(typeIR) = false
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:61.1-61.47
   clause 2(typeIR) = false
      -- if typeIR <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(_tid, _map<rid, routineTypeDefIR>) = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:62.1-62.45
   clause 3(typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:63.1-63.46
   clause 4(typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:64.1-64.48
   clause 5(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(_tid, _typeIR*{_typeIR <- _typeIR*}) = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:65.1-65.46
   clause 6(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, _typeIR) = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:66.1-66.44
   clause 7(typeIR) = false
      -- if typeIR <: defaultTypeIR
      -- let defaultTypeIR = typeIR as defaultTypeIR
      -- if (defaultTypeIR = `DefaultT`_defaultTypeIR())

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:67.1-67.49
   clause 8(typeIR) = false
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(_typeIR*{_typeIR <- _typeIR*}) = sequenceTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:68.1-68.52
   clause 9(typeIR) = false
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordDefaultT%`
      -- let `RecordDefaultT%`_recordTypeIR(_fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = recordTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:69.1-69.50
   clause 10(typeIR) = false
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = `InvalidHeaderT`_invalidHeaderTypeIR())

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:70.1-70.42
   clause 11(typeIR) = false
      -- if typeIR <: setTypeIR
      -- let `SetT%`_setTypeIR(_typeIR) = typeIR as setTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:71.1-71.50
   clause 12(typeIR) = false
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TableEnumT%%`
      -- let `TableEnumT%%`_tableTypeIR(_tid, _id*{_id <- _id*}) = tableTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:72.1-72.52
   clause 13(typeIR) = false
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TableStructT%%`
      -- let `TableStructT%%`_tableTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = tableTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:73.1-74.15
   clause 14(typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:78.1-78.41
def $is_assignable_typeIR(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:81.1-82.43
   clause 0(typeIR) = $is_assignable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:79.1-79.42
def $is_assignable_typeIR'(typeIR) : bool =

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:83.1-83.42
   clause 0(typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `VoidT`

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:84.1-84.41
   clause 1(typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:85.1-85.41
   clause 2(typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:86.1-86.49
   clause 3(typeIR) = false
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:87.1-87.54
   clause 4(typeIR) = false
      -- if typeIR <: synthesizedTypeIR
      -- let synthesizedTypeIR = typeIR as synthesizedTypeIR

   ;; ../../../../spec-concrete/2.2.4-type-util.watsup:88.1-89.15
   clause 5(typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:5.1-7.20
relation Type_alpha: `%~~%`(typeIR, typeIR)

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:27.1-28.27
   rule basetype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR
      -- if typeIR' <: baseTypeIR
      -- let baseTypeIR' = typeIR' as baseTypeIR
      -- if (baseTypeIR = baseTypeIR')

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:32.1-33.30
   rule nametype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(tid) = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `NameT%`
      -- let `NameT%`_namedTypeIR(tid') = namedTypeIR'
      -- if (tid = tid')

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:35.1-43.41
   rule spectype-nominal: `%~~%`(typeIR, typeIR')
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(polyTypeDefIR_a, typeIR_a*{typeIR_a <- typeIR_a*}) = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(polyTypeDefIR_b, typeIR_b*{typeIR_b <- typeIR_b*}) = namedTypeIR'
      -- let typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a as typeDefIR, typeIR_a*{typeIR_a <- typeIR_a*})
      -- let typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b as typeDefIR, typeIR_b*{typeIR_b <- typeIR_b*})
      -- if Type_alpha: `%~~%`(typeIR_a_spec, typeIR_b_spec) holds
      -- if ($is_nominal_typeIR(typeIR_a_spec) /\ $is_nominal_typeIR(typeIR_b_spec))
      -- (if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:45.1-52.46
   rule spectype-structural: `%~~%`(typeIR, typeIR')
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(polyTypeDefIR_a, typeIR_a*{typeIR_a <- typeIR_a*}) = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(polyTypeDefIR_b, typeIR_b*{typeIR_b <- typeIR_b*}) = namedTypeIR'
      -- let typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a as typeDefIR, typeIR_a*{typeIR_a <- typeIR_a*})
      -- let typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b as typeDefIR, typeIR_b*{typeIR_b <- typeIR_b*})
      -- if Type_alpha: `%~~%`(typeIR_a_spec, typeIR_b_spec) holds
      -- if (~$is_nominal_typeIR(typeIR_a_spec) /\ ~$is_nominal_typeIR(typeIR_b_spec))

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:56.1-58.38
   rule typedeftype-left: `%~~%`(typeIR, typeIR_b)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `DefT%%`
      -- let `DefT%%`_aliasTypeIR(_tid, typeIR_a) = aliasTypeIR
      -- if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:60.1-62.38
   rule typedeftype-right: `%~~%`(typeIR_a, typeIR)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `DefT%%`
      -- let `DefT%%`_aliasTypeIR(_tid, typeIR_b) = aliasTypeIR
      -- if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:64.1-66.38
   rule newtype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(tid, typeIR_a) = aliasTypeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR' = typeIR' as aliasTypeIR
      -- if aliasTypeIR' matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(tid', typeIR_b) = aliasTypeIR'
      -- if (tid = tid')
      -- if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:70.1-72.38
   rule listtype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: listTypeIR
      -- let `ListT%`_listTypeIR(typeIR_a) = typeIR as listTypeIR
      -- if typeIR' <: listTypeIR
      -- let `ListT%`_listTypeIR(typeIR_b) = typeIR' as listTypeIR
      -- if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:74.1-76.41
   rule tupletype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = typeIR as tupleTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR_b*{typeIR_b <- typeIR_b*}) = typeIR' as tupleTypeIR
      -- (if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:78.1-80.38
   rule stacktype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR_a, n_s) = typeIR as headerStackTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR_b, n_s') = typeIR' as headerStackTypeIR
      -- if (n_s = n_s')
      -- if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:82.1-85.45
   rule structtype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: structTypeIR
      -- let `StructT%%`_structTypeIR(tid, `%%`_fieldTypeIR(typeIR_f_a, id_f)*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*}) = typeIR as structTypeIR
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(tid', `%%`_fieldTypeIR(typeIR_f_b, id_f')*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*}) = typeIR' as structTypeIR
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: `%~~%`(typeIR_f_a, typeIR_f_b) holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:87.1-90.45
   rule headertype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(tid, `%%`_fieldTypeIR(typeIR_f_a, id_f)*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*}) = typeIR as headerTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(tid', `%%`_fieldTypeIR(typeIR_f_b, id_f')*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*}) = typeIR' as headerTypeIR
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: `%~~%`(typeIR_f_a, typeIR_f_b) holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:92.1-95.45
   rule headeruniontype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(tid, `%%`_fieldTypeIR(typeIR_f_a, id_f)*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*}) = typeIR as headerUnionTypeIR
      -- if typeIR' <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(tid', `%%`_fieldTypeIR(typeIR_f_b, id_f')*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*}) = typeIR' as headerUnionTypeIR
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: `%~~%`(typeIR_f_a, typeIR_f_b) holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:97.1-98.41
   rule enumtype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(tid, id_f*{id_f <- id_f*}) = enumTypeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR' = typeIR' as enumTypeIR
      -- if enumTypeIR' matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(tid', id_f'*{id_f' <- id_f'*}) = enumTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:100.1-103.38
   rule serenumtype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(tid, typeIR_a, `%%`_valueFieldIR(id_f, value_f)*{id_f <- id_f*, value_f <- value_f*}) = enumTypeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR' = typeIR' as enumTypeIR
      -- if enumTypeIR' matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(tid', typeIR_b, `%%`_valueFieldIR(id_f', value_f')*{id_f' <- id_f'*, value_f' <- value_f'*}) = enumTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if (value_f = value_f'))*{value_f <- value_f*, value_f' <- value_f'*}
      -- if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:107.1-119.73
   rule externtype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(tid, `{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(rid_a, routineTypeDefIR_a)*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*})) = typeIR as externObjectTypeIR
      -- if typeIR' <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(tid', `{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(rid_b, routineTypeDefIR_b)*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*})) = typeIR' as externObjectTypeIR
      -- if (tid = tid')
      -- if $eq_set<rid>(`{%}`_set<rid>(rid_a*{rid_a <- rid_a*}), `{%}`_set<rid>(rid_b*{rid_b <- rid_b*}))
      -- (let routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} = $find_map<rid, routineTypeDefIR>(`{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(rid_a, routineTypeDefIR_a)*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*}), rid_a))*{rid_a <- rid_a*, routineTypeDefIR? <- routineTypeDefIR?*}
      -- (if routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} matches (_))*{routineTypeDefIR? <- routineTypeDefIR?*}
      -- (let ?(routineTypeDefIR_a') = routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?})*{routineTypeDefIR? <- routineTypeDefIR?*, routineTypeDefIR_a' <- routineTypeDefIR_a'*}
      -- (let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_map<rid, routineTypeDefIR>(`{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(rid_b, routineTypeDefIR_b)*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*}), rid_a))*{rid_a <- rid_a*, routineTypeDefIR'? <- routineTypeDefIR'?*}
      -- (if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_))*{routineTypeDefIR'? <- routineTypeDefIR'?*}
      -- (let ?(routineTypeDefIR_b') = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?})*{routineTypeDefIR'? <- routineTypeDefIR'?*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}
      -- (if RoutineTypeDef_alpha: `%~~%`(routineTypeDefIR_a', routineTypeDefIR_b') holds)*{routineTypeDefIR_a' <- routineTypeDefIR_a'*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:121.1-123.68
   rule parsertype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}) = typeIR as parserObjectTypeIR
      -- if typeIR' <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}) = typeIR' as parserObjectTypeIR
      -- (if ParameterType_alpha: `%~~%`(parameterTypeIR_a, parameterTypeIR_b) holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:125.1-127.68
   rule controltype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}) = typeIR as controlObjectTypeIR
      -- if typeIR' <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}) = typeIR' as controlObjectTypeIR
      -- (if ParameterType_alpha: `%~~%`(parameterTypeIR_a, parameterTypeIR_b) holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:129.1-131.41
   rule packagetype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(tid, typeIR_a*{typeIR_a <- typeIR_a*}) = typeIR as packageObjectTypeIR
      -- if typeIR' <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(tid', typeIR_b*{typeIR_b <- typeIR_b*}) = typeIR' as packageObjectTypeIR
      -- if (tid = tid')
      -- (if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:133.1-135.38
   rule tabletype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(tid, typeIR_a) = typeIR as tableObjectTypeIR
      -- if typeIR' <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(tid', typeIR_b) = typeIR' as tableObjectTypeIR
      -- if (tid = tid')
      -- if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:139.1-140.23
   rule defaulttype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: defaultTypeIR
      -- let defaultTypeIR = typeIR as defaultTypeIR
      -- if (defaultTypeIR = `DefaultT`_defaultTypeIR())
      -- if typeIR' <: defaultTypeIR
      -- let defaultTypeIR' = typeIR' as defaultTypeIR
      -- if (defaultTypeIR' = `DefaultT`_defaultTypeIR())

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:142.1-144.41
   rule sequencetype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR' matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_b*{typeIR_b <- typeIR_b*}) = sequenceTypeIR'
      -- (if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:146.1-148.41
   rule sequencedefaulttype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR' matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR_b*{typeIR_b <- typeIR_b*}) = sequenceTypeIR'
      -- (if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:150.1-152.41
   rule recordtype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordT%`
      -- let `RecordT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_a, id)*{id <- id*, typeIR_a <- typeIR_a*}) = recordTypeIR
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR' = typeIR' as recordTypeIR
      -- if recordTypeIR' matches `RecordT%`
      -- let `RecordT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_b, id')*{id' <- id'*, typeIR_b <- typeIR_b*}) = recordTypeIR'
      -- (if (id = id'))*{id <- id*, id' <- id'*}
      -- (if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:154.1-157.41
   rule recorddefaulttype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordDefaultT%`
      -- let `RecordDefaultT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_a, id)*{id <- id*, typeIR_a <- typeIR_a*}) = recordTypeIR
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR' = typeIR' as recordTypeIR
      -- if recordTypeIR' matches `RecordDefaultT%`
      -- let `RecordDefaultT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_b, id')*{id' <- id'*, typeIR_b <- typeIR_b*}) = recordTypeIR'
      -- (if (id = id'))*{id <- id*, id' <- id'*}
      -- (if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:159.1-160.35
   rule invalidtype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = `InvalidHeaderT`_invalidHeaderTypeIR())
      -- if typeIR' <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR' = typeIR' as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR' = `InvalidHeaderT`_invalidHeaderTypeIR())

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:162.1-164.38
   rule settype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR_a) = typeIR as setTypeIR
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR_b) = typeIR' as setTypeIR
      -- if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:166.1-167.51
   rule tableenumtype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TableEnumT%%`
      -- let `TableEnumT%%`_tableTypeIR(tid, id_f*{id_f <- id_f*}) = tableTypeIR
      -- if typeIR' <: tableTypeIR
      -- let tableTypeIR' = typeIR' as tableTypeIR
      -- if tableTypeIR' matches `TableEnumT%%`
      -- let `TableEnumT%%`_tableTypeIR(tid', id_f'*{id_f' <- id_f'*}) = tableTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:169.1-172.45
   rule tablestructtype: `%~~%`(typeIR, typeIR')
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TableStructT%%`
      -- let `TableStructT%%`_tableTypeIR(tid, `%%`_fieldTypeIR(typeIR_f_a, id_f)*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*}) = tableTypeIR
      -- if typeIR' <: tableTypeIR
      -- let tableTypeIR' = typeIR' as tableTypeIR
      -- if tableTypeIR' matches `TableStructT%%`
      -- let `TableStructT%%`_tableTypeIR(tid', `%%`_fieldTypeIR(typeIR_f_b, id_f')*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*}) = tableTypeIR'
      -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
      -- if (tid = tid')
      -- (if Type_alpha: `%~~%`(typeIR_f_a, typeIR_f_b) holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:9.1-11.20
relation ParameterType_alpha: `%~~%`(parameterTypeIR, parameterTypeIR)

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:178.1-180.38
   rule : `%~~%`(`%%%%`_parameterTypeIR(_direction, typeIR_a, _id, _value?{_value <- _value?}), `%%%%`_parameterTypeIR(_direction', typeIR_b, _id', _value'?{_value' <- _value'?}))
      -- if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:13.1-15.20
relation RoutineType_alpha: `%~~%`(routineTypeIR, routineTypeIR)

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:186.1-190.46
   rule builtinfunction: `%~~%`(routineTypeIR, routineTypeIR')
      -- if routineTypeIR matches `BuiltinFuncT%%`
      -- let `BuiltinFuncT%%`_routineTypeIR(parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}, typeIR_ret_a) = routineTypeIR
      -- if routineTypeIR' matches `BuiltinFuncT%%`
      -- let `BuiltinFuncT%%`_routineTypeIR(parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}, typeIR_ret_b) = routineTypeIR'
      -- (if ParameterType_alpha: `%~~%`(parameterTypeIR_a, parameterTypeIR_b) holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: `%~~%`(typeIR_ret_a, typeIR_ret_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:192.1-196.46
   rule function: `%~~%`(routineTypeIR, routineTypeIR')
      -- if routineTypeIR matches `FuncT%%`
      -- let `FuncT%%`_routineTypeIR(parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}, typeIR_ret_a) = routineTypeIR
      -- if routineTypeIR' matches `FuncT%%`
      -- let `FuncT%%`_routineTypeIR(parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}, typeIR_ret_b) = routineTypeIR'
      -- (if ParameterType_alpha: `%~~%`(parameterTypeIR_a, parameterTypeIR_b) holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: `%~~%`(typeIR_ret_a, typeIR_ret_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:198.1-200.68
   rule action: `%~~%`(routineTypeIR, routineTypeIR')
      -- if routineTypeIR matches `ActionT%`
      -- let `ActionT%`_routineTypeIR(parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}) = routineTypeIR
      -- if routineTypeIR' matches `ActionT%`
      -- let `ActionT%`_routineTypeIR(parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}) = routineTypeIR'
      -- (if ParameterType_alpha: `%~~%`(parameterTypeIR_a, parameterTypeIR_b) holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:202.1-206.46
   rule externfunction: `%~~%`(routineTypeIR, routineTypeIR')
      -- if routineTypeIR matches `ExternFuncT%%`
      -- let `ExternFuncT%%`_routineTypeIR(parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}, typeIR_ret_a) = routineTypeIR
      -- if routineTypeIR' matches `ExternFuncT%%`
      -- let `ExternFuncT%%`_routineTypeIR(parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}, typeIR_ret_b) = routineTypeIR'
      -- (if ParameterType_alpha: `%~~%`(parameterTypeIR_a, parameterTypeIR_b) holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: `%~~%`(typeIR_ret_a, typeIR_ret_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:208.1-212.46
   rule builtinmethod: `%~~%`(routineTypeIR, routineTypeIR')
      -- if routineTypeIR matches `BuiltinMethodT%%`
      -- let `BuiltinMethodT%%`_routineTypeIR(parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}, typeIR_ret_a) = routineTypeIR
      -- if routineTypeIR' matches `BuiltinMethodT%%`
      -- let `BuiltinMethodT%%`_routineTypeIR(parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}, typeIR_ret_b) = routineTypeIR'
      -- (if ParameterType_alpha: `%~~%`(parameterTypeIR_a, parameterTypeIR_b) holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: `%~~%`(typeIR_ret_a, typeIR_ret_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:214.1-218.46
   rule externmethod: `%~~%`(routineTypeIR, routineTypeIR')
      -- if routineTypeIR matches `ExternMethodT%%`
      -- let `ExternMethodT%%`_routineTypeIR(parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}, typeIR_ret_a) = routineTypeIR
      -- if routineTypeIR' matches `ExternMethodT%%`
      -- let `ExternMethodT%%`_routineTypeIR(parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}, typeIR_ret_b) = routineTypeIR'
      -- (if ParameterType_alpha: `%~~%`(parameterTypeIR_a, parameterTypeIR_b) holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: `%~~%`(typeIR_ret_a, typeIR_ret_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:220.1-224.46
   rule externmethod-abstract: `%~~%`(routineTypeIR, routineTypeIR')
      -- if routineTypeIR matches `ExternAbstractMethodT%%`
      -- let `ExternAbstractMethodT%%`_routineTypeIR(parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}, typeIR_ret_a) = routineTypeIR
      -- if routineTypeIR' matches `ExternAbstractMethodT%%`
      -- let `ExternAbstractMethodT%%`_routineTypeIR(parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}, typeIR_ret_b) = routineTypeIR'
      -- (if ParameterType_alpha: `%~~%`(parameterTypeIR_a, parameterTypeIR_b) holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
      -- if Type_alpha: `%~~%`(typeIR_ret_a, typeIR_ret_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:226.1-229.68
   rule parserapply: `%~~%`(routineTypeIR, routineTypeIR')
      -- if routineTypeIR matches `ParserApplyMethodT%`
      -- let `ParserApplyMethodT%`_routineTypeIR(parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}) = routineTypeIR
      -- if routineTypeIR' matches `ParserApplyMethodT%`
      -- let `ParserApplyMethodT%`_routineTypeIR(parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}) = routineTypeIR'
      -- (if ParameterType_alpha: `%~~%`(parameterTypeIR_a, parameterTypeIR_b) holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:231.1-234.68
   rule controlapply: `%~~%`(routineTypeIR, routineTypeIR')
      -- if routineTypeIR matches `ControlApplyMethodT%`
      -- let `ControlApplyMethodT%`_routineTypeIR(parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}) = routineTypeIR
      -- if routineTypeIR' matches `ControlApplyMethodT%`
      -- let `ControlApplyMethodT%`_routineTypeIR(parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}) = routineTypeIR'
      -- (if ParameterType_alpha: `%~~%`(parameterTypeIR_a, parameterTypeIR_b) holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:236.1-239.46
   rule tableapply: `%~~%`(routineTypeIR, routineTypeIR')
      -- if routineTypeIR matches `TableApplyMethodT%`
      -- let `TableApplyMethodT%`_routineTypeIR(typeIR_ret_a) = routineTypeIR
      -- if routineTypeIR' matches `TableApplyMethodT%`
      -- let `TableApplyMethodT%`_routineTypeIR(typeIR_ret_b) = routineTypeIR'
      -- if Type_alpha: `%~~%`(typeIR_ret_a, typeIR_ret_b) holds

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:17.1-19.20
relation RoutineTypeDef_alpha: `%~~%`(routineTypeDefIR, routineTypeDefIR)

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:245.1-247.59
   rule mono: `%~~%`(routineTypeDefIR, routineTypeDefIR')
      -- if routineTypeDefIR <: monoRoutineTypeDefIR
      -- let `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR_a) = routineTypeDefIR as monoRoutineTypeDefIR
      -- if routineTypeDefIR' <: monoRoutineTypeDefIR
      -- let `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR_b) = routineTypeDefIR' as monoRoutineTypeDefIR
      -- if RoutineType_alpha: `%~~%`(routineTypeIR_a, routineTypeIR_b) holds

   ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:249.1-268.71
   rule poly: `%~~%`(routineTypeDefIR, routineTypeDefIR')
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR_a, tid_a*{tid_a <- tid_a*}, tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}) = routineTypeDefIR as polyRoutineTypeDefIR
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR_b, tid_b*{tid_b <- tid_b*}, tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}) = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if (|tid_a*{tid_a <- tid_a*}| = |tid_b*{tid_b <- tid_b*}|)
      -- if (|tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}| = |tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}|)
      -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids((|tid_a*{tid_a <- tid_a*}| + |tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}|))
      -- let tid_a'*{tid_a' <- tid_a'*} = tid_a*{tid_a <- tid_a*} ++ tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}
      -- let theta_a = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid_a', `NameT%`_namedTypeIR(tid_fresh) as typeIR)*{tid_a' <- tid_a'*, tid_fresh <- tid_fresh*})
      -- let routineTypeIR_a_subst = $subst_routineType(theta_a, routineTypeIR_a)
      -- let tid_b'*{tid_b' <- tid_b'*} = tid_b*{tid_b <- tid_b*} ++ tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}
      -- let theta_b = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid_b', `NameT%`_namedTypeIR(tid_fresh) as typeIR)*{tid_b' <- tid_b'*, tid_fresh <- tid_fresh*})
      -- let routineTypeIR_b_subst = $subst_routineType(theta_b, routineTypeIR_b)
      -- if RoutineType_alpha: `%~~%`(routineTypeIR_a_subst, routineTypeIR_b_subst) holds

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:5.14-5.30
syntax ctk = 
   | `LCTK`()
   | `CTK`()
   | `DYN`()

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:7.1-7.30
def $join_ctk(ctk, ctk) : ctk =

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:9.1-9.33
   clause 0(ctk, ctk') = `LCTK`_ctk()
      -- if ctk matches `LCTK`
      -- if ctk' matches `LCTK`

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:10.1-10.31
   clause 1(ctk, ctk') = `CTK`_ctk()
      -- if ctk matches `LCTK`
      -- if ctk' matches `CTK`

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:11.1-11.31
   clause 2(ctk, ctk') = `CTK`_ctk()
      -- if ctk matches `CTK`
      -- if ctk' matches `LCTK`

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:12.1-12.30
   clause 3(ctk, ctk') = `CTK`_ctk()
      -- if ctk matches `CTK`
      -- if ctk' matches `CTK`

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:13.1-14.15
   clause 4(ctk_a, ctk_b) = `DYN`_ctk()
      -- otherwise

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:16.1-16.27
def $joins_ctk(ctk*) : ctk =

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:18.1-18.27
   clause 0(ctk*{ctk <- ctk*}) = `LCTK`_ctk()
      -- if ctk*{ctk <- ctk*} matches []

   ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:19.1-20.41
   clause 1(ctk*{ctk <- ctk*}) = $join_ctk(ctk_h, $joins_ctk(ctk_t*{ctk_t <- ctk_t*}))
      -- if ctk*{ctk <- ctk*} matches _ :: _
      -- let ctk_h :: ctk_t*{ctk_t <- ctk_t*} = ctk*{ctk <- ctk*}

;; ../../../../spec-concrete/3-numerics.watsup:5.1-5.21
def $pow2(nat) : int =

;; ../../../../spec-concrete/3-numerics.watsup:7.1-7.25
def $shl(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:8.1-8.25
def $shr(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:9.1-9.36
def $shr_arith(int, int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:11.1-11.21
def $bneg(int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:12.1-12.26
def $band(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:13.1-13.26
def $bxor(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:14.1-14.25
def $bor(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:16.1-16.33
def $bitacc(int, int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:24.1-24.28
def $un_bnot(value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:26.1-27.22
   clause 0(value) = `FBitV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i) = numberValue
      -- let i' = $bneg(i)

;; ../../../../spec-concrete/3-numerics.watsup:31.1-31.28
def $un_lnot(value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:33.1-33.35
   clause 0(value) = `BoolV%`_primitiveValue(~b) as value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `BoolV%`
      -- let `BoolV%`_primitiveValue(b) = primitiveValue

;; ../../../../spec-concrete/3-numerics.watsup:37.1-37.28
def $un_plus(value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:39.1-39.30
   clause 0(value) = `IntV%`_numberValue(i) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i) = numberValue

   ;; ../../../../spec-concrete/3-numerics.watsup:40.1-40.36
   clause 1(value) = `FBitV%%`_numberValue(w, i) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i) = numberValue

   ;; ../../../../spec-concrete/3-numerics.watsup:41.1-41.36
   clause 2(value) = `FIntV%%`_numberValue(w, i) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i) = numberValue

;; ../../../../spec-concrete/3-numerics.watsup:45.1-45.29
def $un_minus(value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:47.1-47.35
   clause 0(value) = `IntV%`_numberValue(-i) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i) = numberValue

   ;; ../../../../spec-concrete/3-numerics.watsup:48.1-49.29
   clause 1(value) = `FBitV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i) = numberValue
      -- let i' = ($pow2(w) - i)

   ;; ../../../../spec-concrete/3-numerics.watsup:50.1-51.46
   clause 2(value) = `FIntV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i) = numberValue
      -- let i' = $to_bitstr(w as int, $to_int(w as int, -i))

;; ../../../../spec-concrete/3-numerics.watsup:59.1-59.36
def $bin_plus(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:61.1-61.54
   clause 0(value, value') = `IntV%`_numberValue((i_l + i_r)) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:62.1-65.43
   clause 1(value, value') = `FBitV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' + i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:66.1-69.43
   clause 2(value, value') = `FIntV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' + i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:84.1-87.43
   clause 3(value, value') = `FIntV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' - i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:102.1-105.43
   clause 4(value, value') = `FIntV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' * i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:73.1-73.39
def $bin_satplus(value, value) : value =

;; ../../../../spec-concrete/3-numerics.watsup:77.1-77.37
def $bin_minus(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:79.1-79.55
   clause 0(value, value') = `IntV%`_numberValue((i_l - i_r)) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:80.1-83.43
   clause 1(value, value') = `FBitV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' - i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:98.1-101.43
   clause 2(value, value') = `FBitV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, (i_l' * i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:91.1-91.40
def $bin_satminus(value, value) : value =

;; ../../../../spec-concrete/3-numerics.watsup:95.1-95.35
def $bin_mul(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:97.1-97.53
   clause 0(value, value') = `IntV%`_numberValue((i_l * i_r)) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

;; ../../../../spec-concrete/3-numerics.watsup:109.1-109.35
def $bin_div(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:111.1-111.53
   clause 0(value, value') = `IntV%`_numberValue((i_l / i_r)) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

;; ../../../../spec-concrete/3-numerics.watsup:115.1-115.35
def $bin_mod(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:117.1-117.53
   clause 0(value, value') = `IntV%`_numberValue((i_l \ i_r)) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

;; ../../../../spec-concrete/3-numerics.watsup:121.1-121.35
def $bin_shl(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:123.1-123.55
   clause 0(value, value') = `IntV%`_numberValue($shl(i_l, i_r)) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:124.1-124.60
   clause 1(value, value') = `IntV%`_numberValue($shl(i_l, i_r)) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_r, i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:125.1-126.33
   clause 2(value, value') = `IntV%`_numberValue($shl(i_l, i_r')) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_r' = $to_int(w_r as int, i_r)

   ;; ../../../../spec-concrete/3-numerics.watsup:128.1-129.57
   clause 3(value, value') = $bin_shl(`FBitV%%`_numberValue(w_l, i_l) as value, `FBitV%%`_numberValue(w_l, $to_int(w_l as int, i_r)) as value)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:130.1-131.45
   clause 4(value, value') = `FBitV%%`_numberValue(w_l, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i' = $to_bitstr(w_l as int, $shl(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:132.1-134.46
   clause 5(value, value') = `FBitV%%`_numberValue(w_l, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_r' = $to_int(w_r as int, i_r)
      -- let i' = $to_bitstr(w_l as int, $shl(i_l, i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:136.1-137.57
   clause 6(value, value') = $bin_shl(`FIntV%%`_numberValue(w_l, i_l) as value, `FIntV%%`_numberValue(w_l, $to_int(w_l as int, i_r)) as value)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:138.1-140.46
   clause 7(value, value') = `FIntV%%`_numberValue(w_l, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i' = $to_bitstr(w_l as int, $shl(i_l', i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:141.1-144.47
   clause 8(value, value') = `FIntV%%`_numberValue(w_l, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_r' = $to_int(w_r as int, i_r)
      -- let i' = $to_bitstr(w_l as int, $shl(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:148.1-148.35
def $bin_shr(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:150.1-150.55
   clause 0(value, value') = `IntV%`_numberValue($shr(i_l, i_r)) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:151.1-151.60
   clause 1(value, value') = `IntV%`_numberValue($shr(i_l, i_r)) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_r, i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:152.1-153.33
   clause 2(value, value') = `IntV%`_numberValue($shr(i_l, i_r')) as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_r' = $to_int(w_r as int, i_r)

   ;; ../../../../spec-concrete/3-numerics.watsup:155.1-156.57
   clause 3(value, value') = $bin_shr(`FBitV%%`_numberValue(w_l, i_l) as value, `FBitV%%`_numberValue(w_l, $to_int(w_l as int, i_r)) as value)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:157.1-158.45
   clause 4(value, value') = `FBitV%%`_numberValue(w_l, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i' = $to_bitstr(w_l as int, $shr(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:159.1-161.46
   clause 5(value, value') = `FBitV%%`_numberValue(w_l, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_r' = $to_int(w_r as int, i_r)
      -- let i' = $to_bitstr(w_l as int, $shr(i_l, i_r'))

   ;; ../../../../spec-concrete/3-numerics.watsup:163.1-167.34
   clause 6(value, value') = `FIntV%%`_numberValue(w_l, i'') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' < 0 as int)
      -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:168.1-172.34
   clause 7(value, value') = `FIntV%%`_numberValue(w_l, i'') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' >= 0 as int)
      -- let i' = $shr(i_l, i_r)
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:173.1-177.34
   clause 8(value, value') = `FIntV%%`_numberValue(w_l, i'') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' < 0 as int)
      -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:178.1-182.34
   clause 9(value, value') = `FIntV%%`_numberValue(w_l, i'') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- if (i_l' >= 0 as int)
      -- let i' = $shr(i_l, i_r)
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:183.1-188.34
   clause 10(value, value') = `FIntV%%`_numberValue(w_l, i'') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_r' = $to_int(w_r as int, i_r)
      -- if (i_l' < 0 as int)
      -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
      -- let i'' = $to_bitstr(w_l as int, i')

   ;; ../../../../spec-concrete/3-numerics.watsup:189.1-194.34
   clause 11(value, value') = `FIntV%%`_numberValue(w_l, i'') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_r' = $to_int(w_r as int, i_r)
      -- if (i_l' >= 0 as int)
      -- let i' = $shr(i_l, i_r)
      -- let i'' = $to_bitstr(w_l as int, i')

;; ../../../../spec-concrete/3-numerics.watsup:198.1-198.33
def $bin_le(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:200.1-200.48
   clause 0(value, value') = (i_l <= i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:201.1-201.54
   clause 1(value, value') = (i_l <= i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')

   ;; ../../../../spec-concrete/3-numerics.watsup:202.1-204.31
   clause 2(value, value') = (i_l' <= i_r')
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:208.1-208.33
def $bin_ge(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:210.1-210.48
   clause 0(value, value') = (i_l >= i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:211.1-211.54
   clause 1(value, value') = (i_l >= i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')

   ;; ../../../../spec-concrete/3-numerics.watsup:212.1-214.31
   clause 2(value, value') = (i_l' >= i_r')
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:218.1-218.33
def $bin_lt(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:220.1-220.47
   clause 0(value, value') = (i_l < i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:221.1-221.53
   clause 1(value, value') = (i_l < i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')

   ;; ../../../../spec-concrete/3-numerics.watsup:222.1-224.31
   clause 2(value, value') = (i_l' < i_r')
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:228.1-228.33
def $bin_gt(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:230.1-230.47
   clause 0(value, value') = (i_l > i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_r) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:231.1-231.53
   clause 1(value, value') = (i_l > i_r)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')

   ;; ../../../../spec-concrete/3-numerics.watsup:232.1-234.31
   clause 2(value, value') = (i_l' > i_r')
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:238.1-238.33
def $bin_eq(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:242.1-243.42
   clause 0(value, value') = (primitiveValue_a = primitiveValue_b)
      -- if value <: primitiveValue
      -- let primitiveValue_a = value as primitiveValue
      -- if value' <: primitiveValue
      -- let primitiveValue_b = value' as primitiveValue

   ;; ../../../../spec-concrete/3-numerics.watsup:245.1-245.46
   clause 1(value, value') = (i_a = i_b)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i_a) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `IntV%`
      -- let `IntV%`_numberValue(i_b) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:246.1-246.71
   clause 2(value, value') = ((w_a = w_b) /\ (i_a = i_b))
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_a, i_a) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_b, i_b) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:247.1-247.71
   clause 3(value, value') = ((w_a = w_b) /\ (i_a = i_b))
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_a, i_a) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_b, i_b) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:248.1-248.75
   clause 4(value, value') = ((w_a = w_b) /\ (i_a = i_b))
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `VBitV%%%`
      -- let `VBitV%%%`_numberValue(w_a, _width, i_a) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `VBitV%%%`
      -- let `VBitV%%%`_numberValue(w_b, _width', i_b) = numberValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:250.1-251.33
   clause 5(value, value') = $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})
      -- if value <: listValue
      -- let `ListV%`_listValue(value_a*{value_a <- value_a*}) = value as listValue
      -- if value' <: listValue
      -- let `ListV%`_listValue(value_b*{value_b <- value_b*}) = value' as listValue

   ;; ../../../../spec-concrete/3-numerics.watsup:252.1-253.33
   clause 6(value, value') = $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})
      -- if value <: tupleValue
      -- let `TupleV%`_tupleValue(value_a*{value_a <- value_a*}) = value as tupleValue
      -- if value' <: tupleValue
      -- let `TupleV%`_tupleValue(value_b*{value_b <- value_b*}) = value' as tupleValue

   ;; ../../../../spec-concrete/3-numerics.watsup:254.1-255.52
   clause 7(value, value') = ($bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*}) /\ (n_s_a = n_s_b))
      -- if value <: headerStackValue
      -- let `HeaderStackV%%%`_headerStackValue(value_a*{value_a <- value_a*}, _nat, n_s_a) = value as headerStackValue
      -- if value' <: headerStackValue
      -- let `HeaderStackV%%%`_headerStackValue(value_b*{value_b <- value_b*}, _nat', n_s_b) = value' as headerStackValue

   ;; ../../../../spec-concrete/3-numerics.watsup:256.1-261.67
   clause 8(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
      -- if value <: structValue
      -- let `StructV%%`_structValue(tid_a, `%%`_fieldValue(value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}) = value as structValue
      -- if value' <: structValue
      -- let `StructV%%`_structValue(tid_b, `%%`_fieldValue(value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}) = value' as structValue

   ;; ../../../../spec-concrete/3-numerics.watsup:262.1-268.67
   clause 9(value, value') = (((tid_a = tid_b) /\ (b_a = b_b)) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
      -- if value <: headerValue
      -- let `HeaderV%%%`_headerValue(tid_a, b_a, `%%`_fieldValue(value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}) = value as headerValue
      -- if value' <: headerValue
      -- let `HeaderV%%%`_headerValue(tid_b, b_b, `%%`_fieldValue(value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}) = value' as headerValue

   ;; ../../../../spec-concrete/3-numerics.watsup:269.1-274.67
   clause 10(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
      -- if value <: headerUnionValue
      -- let `HeaderUnionV%%`_headerUnionValue(tid_a, `%%`_fieldValue(value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}) = value as headerUnionValue
      -- if value' <: headerUnionValue
      -- let `HeaderUnionV%%`_headerUnionValue(tid_b, `%%`_fieldValue(value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}) = value' as headerUnionValue

   ;; ../../../../spec-concrete/3-numerics.watsup:275.1-276.41
   clause 11(value, value') = ((tid_a = tid_b) /\ (id_f_a = id_f_b))
      -- if value <: enumValue
      -- let enumValue = value as enumValue
      -- if enumValue matches `EnumV%%`
      -- let `EnumV%%`_enumValue(tid_a, id_f_a) = enumValue
      -- if value' <: enumValue
      -- let enumValue' = value' as enumValue
      -- if enumValue' matches `EnumV%%`
      -- let `EnumV%%`_enumValue(tid_b, id_f_b) = enumValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:277.1-278.74
   clause 12(value, value') = (((tid_a = tid_b) /\ (id_f_a = id_f_b)) /\ $bin_eq(value_f_a, value_f_b))
      -- if value <: enumValue
      -- let enumValue = value as enumValue
      -- if enumValue matches `SEnumV%%%`
      -- let `SEnumV%%%`_enumValue(tid_a, id_f_a, value_f_a) = enumValue
      -- if value' <: enumValue
      -- let enumValue' = value' as enumValue
      -- if enumValue' matches `SEnumV%%%`
      -- let `SEnumV%%%`_enumValue(tid_b, id_f_b, value_f_b) = enumValue'

   ;; ../../../../spec-concrete/3-numerics.watsup:279.1-279.51
   clause 13(value, value') = true
      -- if value <: invalidHeaderValue
      -- let invalidHeaderValue = value as invalidHeaderValue
      -- if (invalidHeaderValue = `InvalidHeaderV`_invalidHeaderValue())
      -- if value' <: invalidHeaderValue
      -- let invalidHeaderValue' = value' as invalidHeaderValue
      -- if (invalidHeaderValue' = `InvalidHeaderV`_invalidHeaderValue())

;; ../../../../spec-concrete/3-numerics.watsup:239.1-239.36
def $bin_eqs(value*, value*) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:281.1-281.30
   clause 0(value*{value <- value*}, value'*{value' <- value'*}) = true
      -- if value*{value <- value*} matches []
      -- if value'*{value' <- value'*} matches []

   ;; ../../../../spec-concrete/3-numerics.watsup:282.1-282.34
   clause 1(value*{value <- value*}, value'*{value' <- value'*}) = false
      -- if value*{value <- value*} matches []
      -- if value'*{value' <- value'*} matches _ :: _
      -- let _value :: _value'*{_value' <- _value'*} = value'*{value' <- value'*}

   ;; ../../../../spec-concrete/3-numerics.watsup:283.1-283.34
   clause 2(value*{value <- value*}, value'*{value' <- value'*}) = false
      -- if value*{value <- value*} matches _ :: _
      -- let _value :: _value'*{_value' <- _value'*} = value*{value <- value*}
      -- if value'*{value' <- value'*} matches []

   ;; ../../../../spec-concrete/3-numerics.watsup:284.1-285.70
   clause 3(value*{value <- value*}, value'*{value' <- value'*}) = ($bin_eq(value_a_h, value_b_h) /\ $bin_eqs(value_a_t*{value_a_t <- value_a_t*}, value_b_t*{value_b_t <- value_b_t*}))
      -- if value*{value <- value*} matches _ :: _
      -- let value_a_h :: value_a_t*{value_a_t <- value_a_t*} = value*{value <- value*}
      -- if value'*{value' <- value'*} matches _ :: _
      -- let value_b_h :: value_b_t*{value_b_t <- value_b_t*} = value'*{value' <- value'*}

;; ../../../../spec-concrete/3-numerics.watsup:240.1-240.55
def $bin_eqs_fields((value, id)*, (value, id)*) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:287.1-287.37
   clause 0((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = true
      -- if (value, id)*{(value, id) <- (value, id)*} matches []
      -- if (value, id)'*{(value, id)' <- (value, id)'*} matches []

   ;; ../../../../spec-concrete/3-numerics.watsup:288.1-288.41
   clause 1((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = false
      -- if (value, id)*{(value, id) <- (value, id)*} matches []
      -- if (value, id)'*{(value, id)' <- (value, id)'*} matches _ :: _
      -- let _(value, id) :: _(value, id)'*{_(value, id)' <- _(value, id)'*} = (value, id)'*{(value, id)' <- (value, id)'*}

   ;; ../../../../spec-concrete/3-numerics.watsup:289.1-289.41
   clause 2((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = false
      -- if (value, id)*{(value, id) <- (value, id)*} matches _ :: _
      -- let _(value, id) :: _(value, id)'*{_(value, id)' <- _(value, id)'*} = (value, id)*{(value, id) <- (value, id)*}
      -- if (value, id)'*{(value, id)' <- (value, id)'*} matches []

   ;; ../../../../spec-concrete/3-numerics.watsup:290.1-294.67
   clause 3((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = (((id_a_h = id_b_h) /\ $bin_eq(value_a_h, value_b_h)) /\ $bin_eqs_fields((value_a_t, id_a_t)*{id_a_t <- id_a_t*, value_a_t <- value_a_t*}, (value_b_t, id_b_t)*{id_b_t <- id_b_t*, value_b_t <- value_b_t*}))
      -- if (value, id)*{(value, id) <- (value, id)*} matches _ :: _
      -- let (value_a_h, id_a_h) :: (value_a_t, id_a_t)*{id_a_t <- id_a_t*, value_a_t <- value_a_t*} = (value, id)*{(value, id) <- (value, id)*}
      -- if (value, id)'*{(value, id)' <- (value, id)'*} matches _ :: _
      -- let (value_b_h, id_b_h) :: (value_b_t, id_b_t)*{id_b_t <- id_b_t*, value_b_t <- value_b_t*} = (value, id)'*{(value, id)' <- (value, id)'*}

;; ../../../../spec-concrete/3-numerics.watsup:298.1-298.33
def $bin_ne(value, value) : bool =

   ;; ../../../../spec-concrete/3-numerics.watsup:300.1-300.59
   clause 0(value_l, value_r) = ~$bin_eq(value_l, value_r)

;; ../../../../spec-concrete/3-numerics.watsup:304.1-304.36
def $bin_band(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:306.1-307.44
   clause 0(value, value') = `FBitV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i' = $to_bitstr(w as int, $band(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:309.1-312.46
   clause 1(value, value') = `FIntV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, $band(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:316.1-316.36
def $bin_bxor(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:318.1-319.44
   clause 0(value, value') = `FBitV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i' = $to_bitstr(w as int, $bxor(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:321.1-324.46
   clause 1(value, value') = `FIntV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, $bxor(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:328.1-328.35
def $bin_bor(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:330.1-331.43
   clause 0(value, value') = `FBitV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i' = $to_bitstr(w as int, $bor(i_l, i_r))

   ;; ../../../../spec-concrete/3-numerics.watsup:333.1-336.45
   clause 1(value, value') = `FIntV%%`_numberValue(w, i') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w', i_r) = numberValue'
      -- if (w = w')
      -- let i_l' = $to_int(w as int, i_l)
      -- let i_r' = $to_int(w as int, i_r)
      -- let i' = $to_bitstr(w as int, $bor(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:340.1-340.38
def $bin_concat(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:342.1-346.35
   clause 0(value, value') = `FBitV%%`_numberValue(w, i'') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_l' = $shl(i_l, w_r as int)
      -- let i_l'' = (i_l' + i_r)
      -- let w = (w_l + w_r)
      -- let i'' = $to_bitstr(w as int, i_l'')

   ;; ../../../../spec-concrete/3-numerics.watsup:347.1-351.35
   clause 1(value, value') = `FBitV%%`_numberValue(w, i'') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_l' = $shl(i_l, w_r as int)
      -- let i_l'' = (i_l' + i_r)
      -- let w = (w_l + w_r)
      -- let i'' = $to_bitstr(w as int, i_l'')

   ;; ../../../../spec-concrete/3-numerics.watsup:353.1-358.37
   clause 2(value, value') = `FIntV%%`_numberValue(w, i''') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_l'' = $shl(i_l', w_r as int)
      -- let i_l''' = (i_l'' + i_r)
      -- let w = (w_l + w_r)
      -- let i''' = $to_bitstr(w as int, i_l''')

   ;; ../../../../spec-concrete/3-numerics.watsup:359.1-364.37
   clause 3(value, value') = `FIntV%%`_numberValue(w, i''') as value
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_l, i_l) = numberValue
      -- if value' <: numberValue
      -- let numberValue' = value' as numberValue
      -- if numberValue' matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w_r, i_r) = numberValue'
      -- let i_l' = $to_int(w_l as int, i_l)
      -- let i_l'' = $shl(i_l', w_r as int)
      -- let i_l''' = (i_l'' + i_r)
      -- let w = (w_l + w_r)
      -- let i''' = $to_bitstr(w as int, i_l''')

;; ../../../../spec-concrete/3-numerics.watsup:368.1-368.36
def $bin_land(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:370.1-370.57
   clause 0(value, value') = `BoolV%`_primitiveValue((b_l /\ b_r)) as value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `BoolV%`
      -- let `BoolV%`_primitiveValue(b_l) = primitiveValue
      -- if value' <: primitiveValue
      -- let primitiveValue' = value' as primitiveValue
      -- if primitiveValue' matches `BoolV%`
      -- let `BoolV%`_primitiveValue(b_r) = primitiveValue'

;; ../../../../spec-concrete/3-numerics.watsup:374.1-374.35
def $bin_lor(value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:376.1-376.56
   clause 0(value, value') = `BoolV%`_primitiveValue((b_l \/ b_r)) as value
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `BoolV%`
      -- let `BoolV%`_primitiveValue(b_l) = primitiveValue
      -- if value' <: primitiveValue
      -- let primitiveValue' = value' as primitiveValue
      -- if primitiveValue' matches `BoolV%`
      -- let `BoolV%`_primitiveValue(b_r) = primitiveValue'

;; ../../../../spec-concrete/3-numerics.watsup:382.1-382.36
def $cast_op(typeIR, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:399.1-399.54
   clause 0(typeIR, value) = $cast_bool(typeIR, b)
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `BoolV%`
      -- let `BoolV%`_primitiveValue(b) = primitiveValue

   ;; ../../../../spec-concrete/3-numerics.watsup:415.1-415.55
   clause 1(typeIR, value) = $cast_arbint(typeIR, i)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `IntV%`
      -- let `IntV%`_numberValue(i) = numberValue

   ;; ../../../../spec-concrete/3-numerics.watsup:433.1-433.61
   clause 2(typeIR, value) = $cast_fixbit(typeIR, w, i)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, i) = numberValue

   ;; ../../../../spec-concrete/3-numerics.watsup:450.1-450.61
   clause 3(typeIR, value) = $cast_fixint(typeIR, w, i)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FIntV%%`
      -- let `FIntV%%`_numberValue(w, i) = numberValue

   ;; ../../../../spec-concrete/3-numerics.watsup:463.1-464.48
   clause 4(typeIR, value) = $cast_struct(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if value <: structValue
      -- let `StructV%%`_structValue(tid, `%%`_fieldValue(value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = value as structValue

   ;; ../../../../spec-concrete/3-numerics.watsup:477.1-478.51
   clause 5(typeIR, value) = $cast_header(typeIR, tid, b, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if value <: headerValue
      -- let `HeaderV%%%`_headerValue(tid, b, `%%`_fieldValue(value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = value as headerValue

   ;; ../../../../spec-concrete/3-numerics.watsup:482.1-482.65
   clause 6(typeIR, value') = $cast_op(typeIR, value)
      -- if value' <: enumValue
      -- let enumValue = value' as enumValue
      -- if enumValue matches `SEnumV%%%`
      -- let `SEnumV%%%`_enumValue(_tid, _id, value) = enumValue

   ;; ../../../../spec-concrete/3-numerics.watsup:511.1-511.67
   clause 7(typeIR, value') = $cast_sequence(typeIR, value*{value <- value*})
      -- if value' <: sequenceValue
      -- let sequenceValue = value' as sequenceValue
      -- if sequenceValue matches `SeqV%`
      -- let `SeqV%`_sequenceValue(value*{value <- value*}) = sequenceValue

   ;; ../../../../spec-concrete/3-numerics.watsup:539.1-540.39
   clause 8(typeIR, value') = $cast_record(typeIR, (value, id)*{id <- id*, value <- value*})
      -- if value' <: recordValue
      -- let recordValue = value' as recordValue
      -- if recordValue matches `RecordV%`
      -- let `RecordV%`_recordValue(`%%`_fieldValue(value, id)*{id <- id*, value <- value*}) = recordValue

   ;; ../../../../spec-concrete/3-numerics.watsup:546.1-546.50
   clause 9(typeIR, value) = $default(typeIR)
      -- if value <: defaultValue
      -- let defaultValue = value as defaultValue
      -- if (defaultValue = `DefaultV`_defaultValue())

   ;; ../../../../spec-concrete/3-numerics.watsup:561.1-561.61
   clause 10(typeIR, value) = $cast_invalid(typeIR)
      -- if value <: invalidHeaderValue
      -- let invalidHeaderValue = value as invalidHeaderValue
      -- if (invalidHeaderValue = `InvalidHeaderV`_invalidHeaderValue())

   ;; ../../../../spec-concrete/3-numerics.watsup:596.1-597.39
   clause 11(typeIR, value') = $cast_set_singleton(typeIR, value)
      -- if value' <: setValue
      -- let setValue = value' as setValue
      -- if setValue matches `SingletonSetV%`
      -- let `SingletonSetV%`_setValue(value) = setValue

   ;; ../../../../spec-concrete/3-numerics.watsup:598.1-599.45
   clause 12(typeIR, value) = $cast_set_mask(typeIR, value_b, value_m)
      -- if value <: setValue
      -- let setValue = value as setValue
      -- if setValue matches `MaskSetV%%`
      -- let `MaskSetV%%`_setValue(value_b, value_m) = setValue

   ;; ../../../../spec-concrete/3-numerics.watsup:600.1-601.46
   clause 13(typeIR, value) = $cast_set_range(typeIR, value_l, value_u)
      -- if value <: setValue
      -- let setValue = value as setValue
      -- if setValue matches `RangeSetV%%`
      -- let `RangeSetV%%`_setValue(value_l, value_u) = setValue

;; ../../../../spec-concrete/3-numerics.watsup:384.1-384.29
def $default(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:608.1-608.49
   clause 0(typeIR) = $default'($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:385.1-385.30
def $default'(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:610.1-610.35
   clause 0(typeIR) = `BoolV%`_primitiveValue(false) as value
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/3-numerics.watsup:611.1-611.37
   clause 1(typeIR) = `ErrV%`_primitiveValue("NoError") as value
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ErrT`

   ;; ../../../../spec-concrete/3-numerics.watsup:612.1-612.30
   clause 2(typeIR) = `StrV%`_primitiveValue("") as value
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`

   ;; ../../../../spec-concrete/3-numerics.watsup:614.1-614.29
   clause 3(typeIR) = `IntV%`_numberValue(0 as int) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/3-numerics.watsup:615.1-615.35
   clause 4(typeIR) = `FBitV%%`_numberValue(w, 0 as bits) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:616.1-616.35
   clause 5(typeIR) = `FIntV%%`_numberValue(w, 0 as bits) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:617.1-617.37
   clause 6(typeIR) = `VBitV%%%`_numberValue(w, 0, 0 as bits) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VBitT%`
      -- let `VBitT%`_numberTypeIR(w) = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:619.1-619.57
   clause 7(typeIR') = `TupleV%`_tupleValue($default(typeIR)*{typeIR <- typeIR*}) as value
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR*{typeIR <- typeIR*}) = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:621.1-622.56
   clause 8(typeIR') = `HeaderStackV%%%`_headerStackValue(value*{value <- value*}, 0, n_s) as value
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n_s) = typeIR' as headerStackTypeIR
      -- let value*{value <- value*} = $repeat_<value>($default(typeIR), n_s)

   ;; ../../../../spec-concrete/3-numerics.watsup:624.1-625.43
   clause 9(typeIR) = `StructV%%`_structValue(tid, `%%`_fieldValue($default(typeIR_f), id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) as value
      -- if typeIR <: structTypeIR
      -- let `StructT%%`_structTypeIR(tid, `%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = typeIR as structTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:627.1-628.49
   clause 10(typeIR) = `HeaderV%%%`_headerValue(tid, false, `%%`_fieldValue($default(typeIR_f), id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) as value
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(tid, `%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:630.1-631.48
   clause 11(typeIR) = `HeaderUnionV%%`_headerUnionValue(tid, `%%`_fieldValue($default(typeIR_f), id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) as value
      -- if typeIR <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(tid, `%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:633.1-633.58
   clause 12(typeIR) = `EnumV%%`_enumValue(tid, id_f_h) as value
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(tid, id*{id <- id*}) = enumTypeIR
      -- if id*{id <- id*} matches _ :: _
      -- let id_f_h :: _id*{_id <- _id*} = id*{id <- id*}

   ;; ../../../../spec-concrete/3-numerics.watsup:635.1-638.67
   clause 13(typeIR') = `SEnumV%%%`_enumValue(tid, id_zero, value_zero) as value
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(tid, typeIR, `%%`_valueFieldIR(id_f, value_f)*{id_f <- id_f*, value_f <- value_f*}) = enumTypeIR
      -- let value_zero = $cast_arbint(typeIR, 0 as int)
      -- let id?{id <- id?} = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
      -- if id?{id <- id?} matches (_)
      -- let ?(id_zero) = id?{id <- id?}

   ;; ../../../../spec-concrete/3-numerics.watsup:640.1-644.34
   clause 14(typeIR') = `SEnumV%%%`_enumValue(tid, id_zero, value_zero) as value
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(tid, typeIR, `%%`_valueFieldIR(id_f, value_f)*{id_f <- id_f*, value_f <- value_f*}) = enumTypeIR
      -- let value_zero = $cast_arbint(typeIR, 0 as int)
      -- if (?() = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}))
      -- let id_zero = "__UNSPECIFIED"

;; ../../../../spec-concrete/3-numerics.watsup:389.1-389.37
def $cast_bool(typeIR, bool) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:392.1-392.59
   clause 0(typeIR, b) = $cast_bool'($canon(typeIR), b)

;; ../../../../spec-concrete/3-numerics.watsup:390.1-390.38
def $cast_bool'(typeIR, bool) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:394.1-394.36
   clause 0(typeIR, b) = `BoolV%`_primitiveValue(b) as value
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/3-numerics.watsup:395.1-395.43
   clause 1(typeIR, bool) = `FBitV%%`_numberValue(w, 1 as bits) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR
      -- if (bool = true)

   ;; ../../../../spec-concrete/3-numerics.watsup:396.1-396.44
   clause 2(typeIR, bool) = `FBitV%%`_numberValue(w, 0 as bits) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR
      -- if (bool = false)

   ;; ../../../../spec-concrete/3-numerics.watsup:397.1-397.58
   clause 3(typeIR', b) = $cast_bool(typeIR, b)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:403.1-403.38
def $cast_arbint(typeIR, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:406.1-406.63
   clause 0(typeIR, i) = $cast_arbint'($canon(typeIR), i)

;; ../../../../spec-concrete/3-numerics.watsup:404.1-404.39
def $cast_arbint'(typeIR, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:408.1-408.44
   clause 0(typeIR, i) = `BoolV%`_primitiveValue((i = 0 as int)) as value
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/3-numerics.watsup:409.1-409.36
   clause 1(typeIR, i) = `IntV%`_numberValue(i) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/3-numerics.watsup:410.1-410.59
   clause 2(typeIR, i) = `FIntV%%`_numberValue(w, $to_bitstr(w as int, i)) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:411.1-411.59
   clause 3(typeIR, i) = `FBitV%%`_numberValue(w, $to_bitstr(w as int, i)) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:412.1-412.62
   clause 4(typeIR', i) = $cast_arbint(typeIR, i)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:413.1-413.74
   clause 5(typeIR', i) = `SingletonSetV%`_setValue($cast_arbint(typeIR, i)) as value
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR) = typeIR' as setTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:419.1-419.43
def $cast_fixbit(typeIR, nat, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:422.1-422.69
   clause 0(typeIR, w, i) = $cast_fixbit'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:420.1-420.44
def $cast_fixbit'(typeIR, nat, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:424.1-424.47
   clause 0(typeIR, w, i) = `BoolV%`_primitiveValue((i = 1 as int)) as value
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/3-numerics.watsup:425.1-425.39
   clause 1(typeIR, _nat, i) = `IntV%`_numberValue(i) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/3-numerics.watsup:426.1-427.33
   clause 2(typeIR, _nat, i) = `FBitV%%`_numberValue(w_to, i') as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w_to) = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, i)

   ;; ../../../../spec-concrete/3-numerics.watsup:428.1-429.33
   clause 3(typeIR, _nat, i) = `FIntV%%`_numberValue(w_to, i') as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w_to) = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, i)

   ;; ../../../../spec-concrete/3-numerics.watsup:430.1-430.68
   clause 4(typeIR', w, i) = $cast_fixbit(typeIR, w, i)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:431.1-431.80
   clause 5(typeIR', w, i) = `SingletonSetV%`_setValue($cast_fixbit(typeIR, w, i)) as value
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR) = typeIR' as setTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:437.1-437.43
def $cast_fixint(typeIR, nat, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:440.1-440.69
   clause 0(typeIR, w, i) = $cast_fixint'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:438.1-438.44
def $cast_fixint'(typeIR, nat, int) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:442.1-442.51
   clause 0(typeIR, w, i) = `IntV%`_numberValue($to_int(w as int, i)) as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/3-numerics.watsup:443.1-444.50
   clause 1(typeIR, w_from, i) = `FBitV%%`_numberValue(w_to, i') as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w_to) = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, $to_int(w_from as int, i))

   ;; ../../../../spec-concrete/3-numerics.watsup:445.1-446.50
   clause 2(typeIR, w_from, i) = `FIntV%%`_numberValue(w_to, i') as value
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w_to) = numberTypeIR
      -- let i' = $to_bitstr(w_to as int, $to_int(w_from as int, i))

   ;; ../../../../spec-concrete/3-numerics.watsup:447.1-447.68
   clause 3(typeIR', w, i) = $cast_fixint(typeIR, w, i)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:448.1-448.80
   clause 4(typeIR', w, i) = `SingletonSetV%`_setValue($cast_fixint(typeIR, w, i)) as value
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR) = typeIR' as setTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:454.1-454.52
def $cast_struct(typeIR, tid, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:457.1-458.57
   clause 0(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = $cast_struct'($canon(typeIR), tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../spec-concrete/3-numerics.watsup:455.1-455.53
def $cast_struct'(typeIR, tid, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:460.1-461.32
   clause 0(typeIR, tid', (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = `StructV%%`_structValue(tid, `%%`_fieldValue(value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) as value
      -- if typeIR <: structTypeIR
      -- let `StructT%%`_structTypeIR(tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as structTypeIR
      -- if (tid = tid')

;; ../../../../spec-concrete/3-numerics.watsup:468.1-468.58
def $cast_header(typeIR, tid, bool, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:471.1-472.60
   clause 0(typeIR, tid, b, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = $cast_header'($canon(typeIR), tid, b, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../spec-concrete/3-numerics.watsup:469.1-469.59
def $cast_header'(typeIR, tid, bool, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:474.1-475.34
   clause 0(typeIR, tid', b, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = `HeaderV%%%`_headerValue(tid, b, `%%`_fieldValue(value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) as value
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerTypeIR
      -- if (tid = tid')

;; ../../../../spec-concrete/3-numerics.watsup:486.1-486.43
def $cast_sequence(typeIR, value*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:489.1-490.44
   clause 0(typeIR, value*{value <- value*}) = $cast_sequence'($canon(typeIR), value*{value <- value*})

;; ../../../../spec-concrete/3-numerics.watsup:487.1-487.44
def $cast_sequence'(typeIR, value*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:492.1-493.35
   clause 0(typeIR', value*{value <- value*}) = `ListV%`_listValue($cast_op(typeIR, value)*{value <- value*}) as value
      -- if typeIR' <: listTypeIR
      -- let `ListT%`_listTypeIR(typeIR) = typeIR' as listTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:495.1-496.36
   clause 1(typeIR', value*{value <- value*}) = `TupleV%`_tupleValue($cast_op(typeIR, value)*{typeIR <- typeIR*, value <- value*}) as value
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR*{typeIR <- typeIR*}) = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:498.1-501.25
   clause 2(typeIR', value*{value <- value*}) = `HeaderStackV%%%`_headerStackValue(value_cast*{value_cast <- value_cast*}, n_idx, n_s) as value
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n_s) = typeIR' as headerStackTypeIR
      -- (let value_cast = $cast_op(typeIR, value))*{value <- value*, value_cast <- value_cast*}
      -- let n_idx = |value*{value <- value*}|

   ;; ../../../../spec-concrete/3-numerics.watsup:503.1-505.50
   clause 3(typeIR, value*{value <- value*}) = `StructV%%`_structValue(tid, `%%`_fieldValue(value_cast, id_f)*{id_f <- id_f*, value_cast <- value_cast*}) as value
      -- if typeIR <: structTypeIR
      -- let `StructT%%`_structTypeIR(tid, `%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = typeIR as structTypeIR
      -- (let value_cast = $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

   ;; ../../../../spec-concrete/3-numerics.watsup:507.1-509.50
   clause 4(typeIR, value*{value <- value*}) = `HeaderV%%%`_headerValue(tid, true, `%%`_fieldValue(value_cast, id_f)*{id_f <- id_f*, value_cast <- value_cast*}) as value
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(tid, `%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = typeIR as headerTypeIR
      -- (let value_cast = $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

;; ../../../../spec-concrete/3-numerics.watsup:517.1-517.47
def $cast_record(typeIR, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:520.1-521.48
   clause 0(typeIR, (value, id)*{id <- id*, value <- value*}) = $cast_record'($canon(typeIR), (value, id)*{id <- id*, value <- value*})

;; ../../../../spec-concrete/3-numerics.watsup:518.1-518.48
def $cast_record'(typeIR, (value, id)*) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:523.1-529.57
   clause 0(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = `StructV%%`_structValue(tid, `%%`_fieldValue(value_f_cast, id_f)*{id_f <- id_f*, value_f_cast <- value_f_cast*}) as value
      -- if typeIR <: structTypeIR
      -- let `StructT%%`_structTypeIR(tid, `%%`_fieldTypeIR(typeIR_t_f, id_t_f)*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*}) = typeIR as structTypeIR
      -- (let value?{value <- value?} = $find_map<id, value>(`{%}`_set<pair<id, value>>(`%->%`_pair<id, value>(id_f, value_f)*{id_f <- id_f*, value_f <- value_f*}), id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}
      -- (if value?{value <- value?} matches (_))*{value? <- value?*}
      -- (let ?(value_f') = value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}
      -- (let value_f_cast = $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

   ;; ../../../../spec-concrete/3-numerics.watsup:531.1-537.57
   clause 1(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = `HeaderV%%%`_headerValue(tid, true, `%%`_fieldValue(value_f_cast, id_f)*{id_f <- id_f*, value_f_cast <- value_f_cast*}) as value
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(tid, `%%`_fieldTypeIR(typeIR_t_f, id_t_f)*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*}) = typeIR as headerTypeIR
      -- (let value?{value <- value?} = $find_map<id, value>(`{%}`_set<pair<id, value>>(`%->%`_pair<id, value>(id_f, value_f)*{id_f <- id_f*, value_f <- value_f*}), id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}
      -- (if value?{value <- value?} matches (_))*{value? <- value?*}
      -- (let ?(value_f') = value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}
      -- (let value_f_cast = $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

;; ../../../../spec-concrete/3-numerics.watsup:550.1-550.34
def $cast_invalid(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:553.1-553.59
   clause 0(typeIR) = $cast_invalid'($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:551.1-551.35
def $cast_invalid'(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:555.1-556.29
   clause 0(typeIR) = $default(typeIR)
      -- let typeIR' = typeIR
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:558.1-559.34
   clause 1(typeIR) = $default(typeIR)
      -- let typeIR' = typeIR
      -- if typeIR' <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR' as headerUnionTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:565.1-565.47
def $cast_set_singleton(typeIR, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:568.1-569.48
   clause 0(typeIR, value) = $cast_set_singleton'($canon(typeIR), value)

;; ../../../../spec-concrete/3-numerics.watsup:566.1-566.48
def $cast_set_singleton'(typeIR, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:571.1-572.42
   clause 0(typeIR', value) = `SingletonSetV%`_setValue($cast_op(typeIR, value)) as value
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR) = typeIR' as setTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:574.1-574.49
def $cast_set_mask(typeIR, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:577.1-578.54
   clause 0(typeIR, value_b, value_m) = $cast_set_mask'($canon(typeIR), value_b, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:575.1-575.50
def $cast_set_mask'(typeIR, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:580.1-583.49
   clause 0(typeIR', value_b, value_m) = `MaskSetV%%`_setValue(value_b_cast, value_m_cast) as value
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR) = typeIR' as setTypeIR
      -- let value_b_cast = $cast_op(typeIR, value_b)
      -- let value_m_cast = $cast_op(typeIR, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:585.1-585.50
def $cast_set_range(typeIR, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:588.1-589.55
   clause 0(typeIR, value_l, value_u) = $cast_set_range'($canon(typeIR), value_l, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:586.1-586.51
def $cast_set_range'(typeIR, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:591.1-594.49
   clause 0(typeIR', value_l, value_u) = `RangeSetV%%`_setValue(value_l_cast, value_u_cast) as value
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR) = typeIR' as setTypeIR
      -- let value_l_cast = $cast_op(typeIR, value_l)
      -- let value_u_cast = $cast_op(typeIR, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:650.1-650.44
def $bitacc_op(value, value, value) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:652.1-657.35
   clause 0(value_b, value_h, value_l) = `FBitV%%`_numberValue(w, i) as value
      -- let int?{int <- int?} = $to_number(value_b)
      -- if int?{int <- int?} matches (_)
      -- let ?(i_b) = int?{int <- int?}
      -- let int'?{int' <- int'?} = $to_number(value_h)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(i_h) = int'?{int' <- int'?}
      -- let int''?{int'' <- int''?} = $to_number(value_l)
      -- if int''?{int'' <- int''?} matches (_)
      -- let ?(i_l) = int''?{int'' <- int''?}
      -- let int''' = ((i_h + 1 as int) - i_l)
      -- if int''' <: nat
      -- let w = int''' as nat
      -- let i = $bitacc(i_b, i_h, i_l)

;; ../../../../spec-concrete/3-numerics.watsup:663.1-663.32
def $sizeof(typeIR, id) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:703.1-704.34
   clause 0(typeIR, text) = $sizeof_minSizeInBits(typeIR)
      -- if (text = "minSizeInBits")

   ;; ../../../../spec-concrete/3-numerics.watsup:711.1-712.35
   clause 1(typeIR, text) = $sizeof_minSizeInBytes(typeIR)
      -- if (text = "minSizeInBytes")

   ;; ../../../../spec-concrete/3-numerics.watsup:740.1-741.34
   clause 2(typeIR, text) = $sizeof_maxSizeInBits(typeIR)
      -- if (text = "maxSizeInBits")

   ;; ../../../../spec-concrete/3-numerics.watsup:748.1-749.35
   clause 3(typeIR, text) = $sizeof_maxSizeInBytes(typeIR)
      -- if (text = "maxSizeInBytes")

;; ../../../../spec-concrete/3-numerics.watsup:665.1-665.42
def $sizeof_minSizeInBits(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:679.1-680.40
   clause 0(typeIR) = `IntV%`_numberValue($sizeof_minSizeInBits'(typeIR) as int) as value

;; ../../../../spec-concrete/3-numerics.watsup:666.1-666.41
def $sizeof_minSizeInBits'(typeIR) : nat =

   ;; ../../../../spec-concrete/3-numerics.watsup:681.1-682.44
   clause 0(typeIR) = $sizeof_minSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:667.1-667.42
def $sizeof_minSizeInBits''(typeIR) : nat =

   ;; ../../../../spec-concrete/3-numerics.watsup:684.1-684.39
   clause 0(typeIR) = 1
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/3-numerics.watsup:685.1-685.41
   clause 1(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:686.1-686.41
   clause 2(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:687.1-687.41
   clause 3(typeIR) = 0
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VBitT%`
      -- let `VBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:688.1-689.35
   clause 4(typeIR') = $sizeof_minSizeInBits'(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:690.1-691.35
   clause 5(typeIR') = $sizeof_minSizeInBits'(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:692.1-693.42
   clause 6(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR*{typeIR <- typeIR*}) = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:694.1-695.47
   clause 7(typeIR') = ($sizeof_minSizeInBits'(typeIR) * n_size)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n_size) = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:696.1-697.42
   clause 8(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as structTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:698.1-699.42
   clause 9(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:700.1-701.42
   clause 10(typeIR') = $min($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as headerUnionTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:669.1-669.43
def $sizeof_minSizeInBytes(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:708.1-709.48
   clause 0(typeIR) = `IntV%`_numberValue((n_size / 8) as int) as value
      -- let n_size = $sizeof_minSizeInBits'(typeIR)

;; ../../../../spec-concrete/3-numerics.watsup:671.1-671.42
def $sizeof_maxSizeInBits(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:716.1-717.40
   clause 0(typeIR) = `IntV%`_numberValue($sizeof_maxSizeInBits'(typeIR) as int) as value

;; ../../../../spec-concrete/3-numerics.watsup:672.1-672.41
def $sizeof_maxSizeInBits'(typeIR) : nat =

   ;; ../../../../spec-concrete/3-numerics.watsup:718.1-719.44
   clause 0(typeIR) = $sizeof_maxSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:673.1-673.42
def $sizeof_maxSizeInBits''(typeIR) : nat =

   ;; ../../../../spec-concrete/3-numerics.watsup:721.1-721.39
   clause 0(typeIR) = 1
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/3-numerics.watsup:722.1-722.41
   clause 1(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:723.1-723.41
   clause 2(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:724.1-724.41
   clause 3(typeIR) = w
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VBitT%`
      -- let `VBitT%`_numberTypeIR(w) = numberTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:725.1-726.35
   clause 4(typeIR') = $sizeof_maxSizeInBits'(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:727.1-728.35
   clause 5(typeIR') = $sizeof_maxSizeInBits'(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:729.1-730.42
   clause 6(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR*{typeIR <- typeIR*}) = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:731.1-732.47
   clause 7(typeIR') = ($sizeof_maxSizeInBits'(typeIR) * n_size)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n_size) = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:733.1-734.42
   clause 8(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as structTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:735.1-736.42
   clause 9(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/3-numerics.watsup:737.1-738.42
   clause 10(typeIR') = $max($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
      -- if typeIR' <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as headerUnionTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:675.1-675.43
def $sizeof_maxSizeInBytes(typeIR) : value =

   ;; ../../../../spec-concrete/3-numerics.watsup:745.1-746.48
   clause 0(typeIR) = `IntV%`_numberValue((n_size / 8) as int) as value
      -- let n_size = $sizeof_maxSizeInBits'(typeIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:8.3-8.47
syntax parameterIR = 
   | `%%%%`(direction, typeIR, name, constantInitializerIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:14.33-14.44
syntax constructorParameterIR = parameterIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:22.28-22.50
syntax namedExpressionIR = 
   | `%%`(name, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:32.30-32.47
syntax literalExpressionIR = literalExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:38.32-38.51
syntax referenceExpressionIR = referenceExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:44.30-44.38
syntax defaultExpressionIR = 
   | `DefaultE`()

;; ../../../../spec-concrete/4-ir-syntax.watsup:51.3-51.29
syntax unaryExpressionIR = 
   | `UnE%%`(unop, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:54.3-54.49
syntax binaryExpressionIR = 
   | `BinE%%%`(typedExpressionIR, binop, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:57.3-57.62
syntax ternaryExpressionIR = 
   | `TernE%%%`(typedExpressionIR, typedExpressionIR, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:63.27-63.57
syntax castExpressionIR = 
   | `CastE%%`(typeIR, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:70.1-74.38
syntax dataExpressionIR = 
   | `InvalidE`()
   | `SeqE%`(typedExpressionIR*)
   | `SeqDefaultE%`(typedExpressionIR*)
   | `RecordE%`(namedExpressionIR*)
   | `RecordDefaultE%`(namedExpressionIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:80.34-80.55
syntax errorAccessExpressionIR = errorAccessExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:83.1-84.36
syntax memberAccessExpressionIR = 
   | `TypeAccE%%`(prefixedName, name)
   | `ExprAccE%%`(typedExpressionIR, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:87.1-88.66
syntax indexAccessExpressionIR = 
   | `ArrAccE%%`(typedExpressionIR, typedExpressionIR)
   | `BitAccE%%%`(typedExpressionIR, typedExpressionIR, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:91.1-93.28
syntax accessExpressionIR = 
   | `ErrAccE%`(name)
   | `TypeAccE%%`(prefixedName, name)
   | `ExprAccE%%`(typedExpressionIR, name)
   | `ArrAccE%%`(typedExpressionIR, typedExpressionIR)
   | `BitAccE%%%`(typedExpressionIR, typedExpressionIR, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:105.1-106.51
syntax callExpressionIR = 
   | `CallE%%%`(routineTargetIR, typeArgumentIR*, argumentIR*)
   | `InstE%%%`(prefixedName, typeArgumentIR*, argumentIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:113.1-122.21
syntax expressionIR = 
   | `BoolE%`(bool)
   | `NumE%`(number)
   | `StrE%`(text)
   | `NameE%`(prefixedName)
   | `DefaultE`()
   | `UnE%%`(unop, typedExpressionIR)
   | `BinE%%%`(typedExpressionIR, binop, typedExpressionIR)
   | `TernE%%%`(typedExpressionIR, typedExpressionIR, typedExpressionIR)
   | `CastE%%`(typeIR, typedExpressionIR)
   | `InvalidE`()
   | `SeqE%`(typedExpressionIR*)
   | `SeqDefaultE%`(typedExpressionIR*)
   | `RecordE%`(namedExpressionIR*)
   | `RecordDefaultE%`(namedExpressionIR*)
   | `ErrAccE%`(name)
   | `TypeAccE%%`(prefixedName, name)
   | `ExprAccE%%`(typedExpressionIR, name)
   | `ArrAccE%%`(typedExpressionIR, typedExpressionIR)
   | `BitAccE%%%`(typedExpressionIR, typedExpressionIR, typedExpressionIR)
   | `CallE%%%`(routineTargetIR, typeArgumentIR*, argumentIR*)
   | `InstE%%%`(prefixedName, typeArgumentIR*, argumentIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:124.27-124.42
syntax expressionNoteIR = 
   | `(%%)`(typeIR, ctk)

;; ../../../../spec-concrete/4-ir-syntax.watsup:126.28-126.57
syntax typedExpressionIR = 
   | `%%`(expressionIR, expressionNoteIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:129.1-131.28
syntax routineTargetIR = 
   | `FuncT%`(prefixedName)
   | `MethodT%%`(typedExpressionIR, name)
   | `TypeT%%`(prefixedName, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:138.1-142.9
syntax keysetExpressionIR = 
   | `ExprK%`(typedExpressionIR)
   | `MaskK%%`(typedExpressionIR, typedExpressionIR)
   | `RangeK%%`(typedExpressionIR, typedExpressionIR)
   | `DefaultK`()
   | `AnyK`()

;; ../../../../spec-concrete/4-ir-syntax.watsup:148.25-148.31
syntax typeArgumentIR = typeIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:155.1-158.9
syntax argumentIR = 
   | `ExprA%`(typedExpressionIR)
   | `NameA%%`(name, typedExpressionIR)
   | `NameAnyA%`(name)
   | `AnyA`()

;; ../../../../spec-concrete/4-ir-syntax.watsup:167.1-170.62
syntax lvalueIR = 
   | `NameL%`(prefixedName)
   | `LvalueAccL%%`(typedLvalueIR, name)
   | `ArrAccL%%`(typedLvalueIR, typedExpressionIR)
   | `BitAccL%%%`(typedLvalueIR, typedExpressionIR, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:172.23-172.34
syntax lvalueNoteIR = 
   | `(%)`(typeIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:174.24-174.45
syntax typedLvalueIR = 
   | `%%`(lvalueIR, lvalueNoteIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:184.27-184.41
syntax emptyStatementIR = emptyStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:191.3-191.42
syntax assignmentStatementIR = 
   | `AssignS%%`(typedLvalueIR, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:198.3-198.52
syntax callStatementIR = 
   | `CallS%%%`(routineTargetIR, typeArgumentIR*, argumentIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:205.3-205.33
syntax directApplicationStatementIR = 
   | `InstS%%`(prefixedName, argumentIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:212.3-212.29
syntax returnStatementIR = 
   | `ReturnS%`(typedExpressionIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:218.26-218.39
syntax exitStatementIR = exitStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:227.3-227.34
syntax blockStatementIR = 
   | `BlockS%`(blockElementStatementIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:236.3-236.49
syntax conditionalStatementIR = 
   | `IfS%%%`(typedExpressionIR, statementIR, statementIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:243.1-244.28
syntax switchLabelIR = 
   | `DefaultL`()
   | `ExprL%`(typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:247.1-248.42
syntax switchCaseIR = 
   | `FallC%`(switchLabelIR)
   | `MatchC%%`(switchLabelIR, blockStatementIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:251.3-251.42
syntax switchStatementIR = 
   | `SwitchS%%`(typedExpressionIR, switchCaseIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:258.1-266.22
syntax statementIR = 
   | `EmptyS`()
   | `AssignS%%`(typedLvalueIR, typedExpressionIR)
   | `CallS%%%`(routineTargetIR, typeArgumentIR*, argumentIR*)
   | `InstS%%`(prefixedName, argumentIR*)
   | `ReturnS%`(typedExpressionIR?)
   | `ExitS`()
   | `BlockS%`(blockElementStatementIR*)
   | `IfS%%%`(typedExpressionIR, statementIR, statementIR?)
   | `SwitchS%%`(typedExpressionIR, switchCaseIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:276.32-276.37
syntax constantInitializerIR = value

;; ../../../../spec-concrete/4-ir-syntax.watsup:279.3-279.43
syntax constantDeclarationIR = 
   | `ConstD%%%`(typeIR, name, constantInitializerIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:281.24-281.41
syntax initializerIR = typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:284.3-284.34
syntax variableDeclarationIR = 
   | `VarD%%%`(typeIR, name, initializerIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:287.1-289.16
syntax blockElementStatementIR = 
   | `ConstD%%%`(typeIR, name, constantInitializerIR)
   | `VarD%%%`(typeIR, name, initializerIR?)
   | `EmptyS`()
   | `AssignS%%`(typedLvalueIR, typedExpressionIR)
   | `CallS%%%`(routineTargetIR, typeArgumentIR*, argumentIR*)
   | `InstS%%`(prefixedName, argumentIR*)
   | `ReturnS%`(typedExpressionIR?)
   | `ExitS`()
   | `BlockS%`(blockElementStatementIR*)
   | `IfS%%%`(typedExpressionIR, statementIR, statementIR?)
   | `SwitchS%%`(typedExpressionIR, switchCaseIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:296.3-297.68
syntax functionDeclarationIR = 
   | `FuncD%%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*, blockStatementIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:304.3-304.45
syntax actionDeclarationIR = 
   | `ActionD%%%`(name, parameterIR*, blockStatementIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:313.3-313.82
syntax instantiationIR = 
   | `InstD%%%%%%`(typeIR, prefixedName, typeArgumentIR*, argumentIR*, name, objectInitializerIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:316.1-317.20
syntax objectDeclarationIR = 
   | `FuncD%%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*, blockStatementIR)
   | `InstD%%%%%%`(typeIR, prefixedName, typeArgumentIR*, argumentIR*, name, objectInitializerIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:319.30-319.50
syntax objectInitializerIR = objectDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:325.29-325.45
syntax errorDeclarationIR = errorDeclaration

;; ../../../../spec-concrete/4-ir-syntax.watsup:331.33-331.53
syntax matchKindDeclarationIR = matchKindDeclaration

;; ../../../../spec-concrete/4-ir-syntax.watsup:342.1-343.42
syntax enumTypeDeclarationIR = 
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(typeIR, name, namedExpressionIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:349.22-349.33
syntax typeFieldIR = 
   | `%%`(typeIR, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:352.3-352.58
syntax structTypeDeclarationIR = 
   | `StructD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:355.3-355.58
syntax headerTypeDeclarationIR = 
   | `HeaderD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:358.3-358.63
syntax headerUnionTypeDeclarationIR = 
   | `HeaderUnionD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:361.1-364.33
syntax derivedTypeDeclarationIR = 
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(typeIR, name, namedExpressionIR*)
   | `StructD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `HeaderD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `HeaderUnionD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:371.1-372.38
syntax typedefTypeIR = 
   | `PlainT%`(typeIR)
   | `DerivedT%`(derivedTypeDeclarationIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:375.1-376.25
syntax typedefDeclarationIR = 
   | `TypeDefD%%`(typedefTypeIR, name)
   | `NewTypeD%%`(typeIR, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:383.3-384.57
syntax externFunctionDeclarationIR = 
   | `ExternFuncD%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:387.1-389.75
syntax methodPrototypeIR = 
   | `ConsM%%%`(name, typeParameter*, constructorParameterIR*)
   | `MethodM%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*)
   | `AbstractMethodM%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:392.3-392.55
syntax externObjectDeclarationIR = 
   | `ExternObjectD%%%`(name, typeParameter*, methodPrototypeIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:395.1-396.30
syntax externDeclarationIR = 
   | `ExternFuncD%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*)
   | `ExternObjectD%%%`(name, typeParameter*, methodPrototypeIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:406.23-406.47
syntax selectCaseIR = 
   | `%%`(keysetExpressionIR*, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:413.1-414.45
syntax stateExpressionIR = 
   | `NameE%`(name)
   | `SelectE%%`(typedExpressionIR*, selectCaseIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:417.3-417.28
syntax transitionStatementIR = 
   | `TransS%`(stateExpressionIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:424.3-424.42
syntax valueSetDeclarationIR = 
   | `ValueSetD%%%`(typeIR, typedExpressionIR, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:431.3-431.62
syntax parserTypeDeclarationIR = 
   | `ParserTypeD%%%%`(name, typeParameter*, typeParameter*, parameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:440.3-440.34
syntax parserBlockStatementIR = 
   | `ParserBlockS%`(parserStatementIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:443.1-450.27
syntax parserStatementIR = 
   | `ConstD%%%`(typeIR, name, constantInitializerIR)
   | `VarD%%%`(typeIR, name, initializerIR?)
   | `EmptyS`()
   | `AssignS%%`(typedLvalueIR, typedExpressionIR)
   | `CallS%%%`(routineTargetIR, typeArgumentIR*, argumentIR*)
   | `InstS%%`(prefixedName, argumentIR*)
   | `ParserBlockS%`(parserStatementIR*)
   | `IfS%%%`(typedExpressionIR, statementIR, statementIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:453.3-453.48
syntax parserStateIR = 
   | `%%%`(name, parserStatementIR*, transitionStatementIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:456.1-459.26
syntax parserLocalDeclarationIR = 
   | `ConstD%%%`(typeIR, name, constantInitializerIR)
   | `InstD%%%%%%`(typeIR, prefixedName, typeArgumentIR*, argumentIR*, name, objectInitializerIR?)
   | `VarD%%%`(typeIR, name, initializerIR?)
   | `ValueSetD%%%`(typeIR, typedExpressionIR, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:462.3-464.51
syntax parserDeclarationIR = 
   | `ParserD%%%%%%`(name, typeParameter*, parameterIR*, constructorParameterIR*, parserLocalDeclarationIR*, parserStateIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:478.21-478.43
syntax tableKeyIR = 
   | `%%`(typedExpressionIR, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:484.33-484.57
syntax tableActionReferenceIR = 
   | `%%`(prefixedName, argumentIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:486.24-486.46
syntax tableActionIR = tableActionReferenceIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:492.31-492.48
syntax tableEntryPriorityIR = typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:495.3-496.52
syntax tableEntryIR = 
   | `%%%%`(const?, tableEntryPriorityIR?, keysetExpressionIR*, tableActionReferenceIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:503.1-508.51
syntax tablePropertyIR = 
   | `KeyP%`(tableKeyIR*)
   | `ActionP%`(tableActionIR*)
   | `DefaultActionP%%`(const?, tableActionIR)
   | `EntryP%%`(const?, tableEntryIR*)
   | `CustomP%%%`(const?, name, initializerIR)
   | `CustomConstP%%%`(const?, name, constantInitializerIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:511.3-511.38
syntax tableDeclarationIR = 
   | `TableD%%%`(typeIR, name, tablePropertyIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:518.3-518.63
syntax controlTypeDeclarationIR = 
   | `ControlTypeD%%%%`(name, typeParameter*, typeParameter*, parameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:524.24-524.40
syntax controlBodyIR = blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:527.1-531.23
syntax controlLocalDeclarationIR = 
   | `ConstD%%%`(typeIR, name, constantInitializerIR)
   | `InstD%%%%%%`(typeIR, prefixedName, typeArgumentIR*, argumentIR*, name, objectInitializerIR?)
   | `VarD%%%`(typeIR, name, initializerIR?)
   | `ActionD%%%`(name, parameterIR*, blockStatementIR)
   | `TableD%%%`(typeIR, name, tablePropertyIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:534.3-536.52
syntax controlDeclarationIR = 
   | `ControlD%%%%%%`(name, typeParameter*, parameterIR*, constructorParameterIR*, controlLocalDeclarationIR*, controlBodyIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:543.3-543.74
syntax packageTypeDeclarationIR = 
   | `PackageTypeD%%%%`(name, typeParameter*, typeParameter*, constructorParameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:550.1-554.29
syntax typeDeclarationIR = 
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(typeIR, name, namedExpressionIR*)
   | `StructD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `HeaderD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `HeaderUnionD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `TypeDefD%%`(typedefTypeIR, name)
   | `NewTypeD%%`(typeIR, name)
   | `ParserTypeD%%%%`(name, typeParameter*, typeParameter*, parameterIR*)
   | `ControlTypeD%%%%`(name, typeParameter*, typeParameter*, parameterIR*)
   | `PackageTypeD%%%%`(name, typeParameter*, typeParameter*, constructorParameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:561.1-570.22
syntax declarationIR = 
   | `ConstD%%%`(typeIR, name, constantInitializerIR)
   | `InstD%%%%%%`(typeIR, prefixedName, typeArgumentIR*, argumentIR*, name, objectInitializerIR?)
   | `FuncD%%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*, blockStatementIR)
   | `ActionD%%%`(name, parameterIR*, blockStatementIR)
   | `ErrD%`(name*)
   | `MatchKindD%`(name*)
   | `ExternFuncD%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*)
   | `ExternObjectD%%%`(name, typeParameter*, methodPrototypeIR*)
   | `ParserD%%%%%%`(name, typeParameter*, parameterIR*, constructorParameterIR*, parserLocalDeclarationIR*, parserStateIR*)
   | `ControlD%%%%%%`(name, typeParameter*, parameterIR*, constructorParameterIR*, controlLocalDeclarationIR*, controlBodyIR)
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(typeIR, name, namedExpressionIR*)
   | `StructD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `HeaderD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `HeaderUnionD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `TypeDefD%%`(typedefTypeIR, name)
   | `NewTypeD%%`(typeIR, name)
   | `ParserTypeD%%%%`(name, typeParameter*, typeParameter*, parameterIR*)
   | `ControlTypeD%%%%`(name, typeParameter*, typeParameter*, parameterIR*)
   | `PackageTypeD%%%%`(name, typeParameter*, typeParameter*, constructorParameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:576.22-576.36
syntax p4programIR = declarationIR*

;; ../../../../spec-concrete/5.0-flow.watsup:5.15-5.25
syntax flow = 
   | `CONT`()
   | `RET`()

;; ../../../../spec-concrete/5.0-flow.watsup:9.1-9.34
def $join_flow(flow, flow) : flow =

   ;; ../../../../spec-concrete/5.0-flow.watsup:10.1-10.31
   clause 0(flow, flow') = `RET`_flow()
      -- if flow matches `RET`
      -- if flow' matches `RET`

   ;; ../../../../spec-concrete/5.0-flow.watsup:11.1-12.15
   clause 1(f_a, f_b) = `CONT`_flow()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:5.20-5.47
syntax varTypeIR = 
   | `%%%%`(direction, typeIR, ctk, value?)

;; ../../../../spec-concrete/5.01-env.watsup:12.16-12.34
syntax frame = map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:14.1-14.27
def $empty_frame : frame =

   ;; ../../../../spec-concrete/5.01-env.watsup:15.1-15.47
   clause 0 = $empty_map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:18.16-18.35
syntax tdenv = map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:20.1-20.27
def $empty_tdenv : tdenv =

   ;; ../../../../spec-concrete/5.01-env.watsup:21.1-21.48
   clause 0 = $empty_map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:24.16-24.42
syntax rdenv = map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:26.1-26.27
def $empty_rdenv : rdenv =

   ;; ../../../../spec-concrete/5.01-env.watsup:27.1-27.55
   clause 0 = $empty_map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:30.16-30.46
syntax cdenv = map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:32.1-32.27
def $empty_cdenv : cdenv =

   ;; ../../../../spec-concrete/5.01-env.watsup:33.1-33.59
   clause 0 = $empty_map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:39.1-39.39
def $check_routine_name(id, id) : bool =

   ;; ../../../../spec-concrete/5.01-env.watsup:40.1-40.50
   clause 0(id_l, id_r) = (id_l = id_r)

;; ../../../../spec-concrete/5.01-env.watsup:42.1-42.37
def $check_arity(id?*, id*) : bool =

   ;; ../../../../spec-concrete/5.01-env.watsup:43.1-43.72
   clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| = |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:45.1-45.42
def $check_arity_more(id?*, id*) : bool =

   ;; ../../../../spec-concrete/5.01-env.watsup:46.1-46.77
   clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:48.1-48.42
def $check_arity_less(id?*, id*) : bool =

   ;; ../../../../spec-concrete/5.01-env.watsup:49.1-49.77
   clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| < |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:51.1-51.53
def $get_missing_default_parameters(pid*, id*) : id* =

   ;; ../../../../spec-concrete/5.01-env.watsup:53.1-53.56
   clause 0(pid*{pid <- pid*}, id_arg*{id_arg <- id_arg*}) = []
      -- if pid*{pid <- pid*} matches []

   ;; ../../../../spec-concrete/5.01-env.watsup:54.1-59.47
   clause 1(pid*{pid <- pid*}, id_arg*{id_arg <- id_arg*}) = id_param_h :: $get_missing_default_parameters(pid_t*{pid_t <- pid_t*}, id_arg*{id_arg <- id_arg*})
      -- if pid*{pid <- pid*} matches _ :: _
      -- let `%%`_pid(id_param_h, bool) :: pid_t*{pid_t <- pid_t*} = pid*{pid <- pid*}
      -- if (bool = true)
      -- if ~$in_set<id>(id_param_h, `{%}`_set<id>(id_arg*{id_arg <- id_arg*}))

   ;; ../../../../spec-concrete/5.01-env.watsup:60.1-65.46
   clause 2(pid*{pid <- pid*}, id_arg*{id_arg <- id_arg*}) = $get_missing_default_parameters(pid_t*{pid_t <- pid_t*}, id_arg*{id_arg <- id_arg*})
      -- if pid*{pid <- pid*} matches _ :: _
      -- let `%%`_pid(id_param_h, bool) :: pid_t*{pid_t <- pid_t*} = pid*{pid <- pid*}
      -- if (bool = true)
      -- if $in_set<id>(id_param_h, `{%}`_set<id>(id_arg*{id_arg <- id_arg*}))

   ;; ../../../../spec-concrete/5.01-env.watsup:66.1-70.53
   clause 3(pid*{pid <- pid*}, id_arg*{id_arg <- id_arg*}) = $get_missing_default_parameters(pid_t*{pid_t <- pid_t*}, id_arg*{id_arg <- id_arg*})
      -- if pid*{pid <- pid*} matches _ :: _
      -- let `%%`_pid(id_param_h, bool) :: pid_t*{pid_t <- pid_t*} = pid*{pid <- pid*}
      -- if (bool = false)

;; ../../../../spec-concrete/5.01-env.watsup:73.1-73.61
def $find_match_named<V>(rid, V, id*, pid*) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:75.1-77.50
   clause 0(rid, V, id_arg*{id_arg <- id_arg*}, `%%`_pid(id_param, bool_param)*{bool_param <- bool_param*, id_param <- id_param*}) = ?((rid, V, []))
      -- if $eq_set<id>(`{%}`_set<id>(id_arg*{id_arg <- id_arg*}), `{%}`_set<id>(id_param*{id_param <- id_param*}))

   ;; ../../../../spec-concrete/5.01-env.watsup:78.1-79.15
   clause 1(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:82.1-82.69
def $find_match_named_default<V>(rid, V, id*, pid*) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:84.1-91.18
   clause 0(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?((rid, V, id_default*{id_default <- id_default*}))
      -- let id_default*{id_default <- id_default*} = $get_missing_default_parameters(pid*{pid <- pid*}, id_arg*{id_arg <- id_arg*})
      -- if ($find_match_named<V>(rid, V, id_arg*{id_arg <- id_arg*} ++ id_default*{id_default <- id_default*}, pid*{pid <- pid*}) =/= ?())

   ;; ../../../../spec-concrete/5.01-env.watsup:92.1-93.15
   clause 1(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:96.1-96.74
def $find_match_unnamed_default<V>(rid, V, id?*, pid*) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:98.1-100.71
   clause 0(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*}) = ?((rid, V, id_default*{id_default <- id_default*}))
      -- let (_pid*{_pid <- _pid*}, `%%`_pid(id_default, bool)*{bool <- bool*, id_default <- id_default*}) = $partition_<pid>(pid*{pid <- pid*}, |id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}|)
      -- (if (bool = true))*{bool <- bool*}

   ;; ../../../../spec-concrete/5.01-env.watsup:101.1-102.15
   clause 1(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:105.1-105.64
def $find_matching<V>(id, id?*, id*, rid, V) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:108.1-110.42
   clause 0(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, `%%`_rid(id_r', pid_r'*{pid_r' <- pid_r'*}), V) = ?()
      -- if ~$check_routine_name(id_r, id_r')

   ;; ../../../../spec-concrete/5.01-env.watsup:112.1-118.50
   clause 1(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, `%%`_rid(id_r', `%%`_pid(id_param', bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V) = ?()
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity_more(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:120.1-130.45
   clause 2(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, `%%`_rid(id_r', `%%`_pid(id_param', bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V) = $find_match_named<V>(`%%`_rid(id_r', `%%`_pid(id_param', bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V, id_arg'*{id_arg' <- id_arg'*}, `%%`_pid(id_param', bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*})
      -- if (|id_arg'*{id_arg' <- id_arg'*}| > 0)
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:132.1-138.45
   clause 3(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id*{id <- id*}, `%%`_rid(id_r', `%%`_pid(id_param', bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V) = ?((`%%`_rid(id_r', `%%`_pid(id_param', bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V, []))
      -- if id*{id <- id*} matches []
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:140.1-150.50
   clause 4(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, `%%`_rid(id_r', `%%`_pid(id_param', bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V) = $find_match_named_default<V>(`%%`_rid(id_r', `%%`_pid(id_param', bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V, id_arg'*{id_arg' <- id_arg'*}, `%%`_pid(id_param', bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*})
      -- if (|id_arg'*{id_arg' <- id_arg'*}| > 0)
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:152.1-161.50
   clause 5(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id*{id <- id*}, `%%`_rid(id_r', `%%`_pid(id_param', bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V) = $find_match_unnamed_default<V>(`%%`_rid(id_r', `%%`_pid(id_param', bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, `%%`_pid(id_param', bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*})
      -- if id*{id <- id*} matches []
      -- if $check_routine_name(id_r, id_r')
      -- if $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

   ;; ../../../../spec-concrete/5.01-env.watsup:163.1-168.15
   clause 6(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid, V) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:171.1-171.67
def $find_matchings<V>(id, id?*, id*, rid*, V*) : (rid, V, id*)* =

   ;; ../../../../spec-concrete/5.01-env.watsup:173.1-177.8
   clause 0(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = []
      -- if rid*{rid <- rid*} matches []
      -- if V*{V <- V*} matches []

   ;; ../../../../spec-concrete/5.01-env.watsup:178.1-183.72
   clause 1(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})
      -- if rid*{rid <- rid*} matches _ :: _
      -- let rid_h :: rid_t*{rid_t <- rid_t*} = rid*{rid <- rid*}
      -- if V*{V <- V*} matches _ :: _
      -- let V_h :: V_t*{V_t <- V_t*} = V*{V <- V*}
      -- if ($find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h) = ?())

   ;; ../../../../spec-concrete/5.01-env.watsup:184.1-190.66
   clause 2(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid'*{rid' <- rid'*}, V'*{V' <- V'*}) = (rid, V, id_default*{id_default <- id_default*}) :: $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})
      -- if rid'*{rid' <- rid'*} matches _ :: _
      -- let rid_h :: rid_t*{rid_t <- rid_t*} = rid'*{rid' <- rid'*}
      -- if V'*{V' <- V'*} matches _ :: _
      -- let V_h :: V_t*{V_t <- V_t*} = V'*{V' <- V'*}
      -- let (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} = $find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h)
      -- if (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} matches (_)
      -- let ?((rid, V, id_default*{id_default <- id_default*})) = (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?}

   ;; ../../../../spec-concrete/5.01-env.watsup:191.1-196.15
   clause 3(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = []
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:199.1-199.66
def $find_overloaded<V>(map<rid, V>, id, id?*) : (rid, V, id*)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:202.1-208.71
   clause 0(`{%}`_set<pair<rid, V>>(`%->%`_pair<rid, V>(rid, V)*{V <- V*, rid <- rid*}), id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
      -- if (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)
      -- (let id?{id <- id?} = id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}
      -- (if id?{id <- id?} matches (_))*{id? <- id?*}
      -- (let ?(id_arg') = id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}
      -- if ($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = [])

   ;; ../../../../spec-concrete/5.01-env.watsup:209.1-216.65
   clause 1(`{%}`_set<pair<rid, V>>(`%->%`_pair<rid, V>(rid, V)*{V <- V*, rid <- rid*}), id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?((rid', V', id_default*{id_default <- id_default*}))
      -- if (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)
      -- (let id?{id <- id?} = id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}
      -- (if id?{id <- id?} matches (_))*{id? <- id?*}
      -- (let ?(id_arg') = id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}
      -- let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*})
      -- if (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches [ _/1 ]
      -- let [(rid', V', id_default*{id_default <- id_default*})] = (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*}

   ;; ../../../../spec-concrete/5.01-env.watsup:218.1-223.66
   clause 2(`{%}`_set<pair<rid, V>>(`%->%`_pair<rid, V>(rid, V)*{V <- V*, rid <- rid*}), id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
      -- (if (id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}
      -- if ($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*}) = [])

   ;; ../../../../spec-concrete/5.01-env.watsup:224.1-230.60
   clause 3(`{%}`_set<pair<rid, V>>(`%->%`_pair<rid, V>(rid, V)*{V <- V*, rid <- rid*}), id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?((rid', V', id_default*{id_default <- id_default*}))
      -- (if (id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}
      -- let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*})
      -- if (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches [ _/1 ]
      -- let [(rid', V', id_default*{id_default <- id_default*})] = (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*}

   ;; ../../../../spec-concrete/5.01-env.watsup:232.1-236.15
   clause 4(`{%}`_set<pair<rid, V>>(`%->%`_pair<rid, V>(rid, V)*{V <- V*, rid <- rid*}), id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:242.1-242.57
def $find_non_overloaded<V>(map<rid, V>, id) : (rid, V)? =

   ;; ../../../../spec-concrete/5.01-env.watsup:245.1-246.68
   clause 0(`{%}`_set<pair<rid, V>>(`%->%`_pair<rid, V>(rid, V)*{V <- V*, rid <- rid*}), id) = ?((rid', V'))
      -- let (rid, V)*{(rid, V) <- (rid, V)*} = $find_non_overloadeds<V>(`{%}`_set<pair<rid, V>>(`%->%`_pair<rid, V>(rid, V)*{V <- V*, rid <- rid*}), id)
      -- if (rid, V)*{(rid, V) <- (rid, V)*} matches [ _/1 ]
      -- let [(rid', V')] = (rid, V)*{(rid, V) <- (rid, V)*}

   ;; ../../../../spec-concrete/5.01-env.watsup:247.1-248.15
   clause 1(`{%}`_set<pair<rid, V>>(`%->%`_pair<rid, V>(rid, V)*{V <- V*, rid <- rid*}), id) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:243.1-243.58
def $find_non_overloadeds<V>(map<rid, V>, id) : (rid, V)* =

   ;; ../../../../spec-concrete/5.01-env.watsup:250.1-250.49
   clause 0(set<pair<rid, V>>, id) = []
      -- if (set<pair<rid, V>> = `{%}`_set<pair<rid, V>>([]))

   ;; ../../../../spec-concrete/5.01-env.watsup:251.1-257.59
   clause 1(`{%}`_set<pair<rid, V>>(pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}), id) = (rid_h, V_h) :: (rid_t_found, V_t_found)*{V_t_found <- V_t_found*, rid_t_found <- rid_t_found*}
      -- if pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches _ :: _
      -- let `%->%`_pair<rid, V>(rid_h, V_h) :: `%->%`_pair<rid, V>(rid_t, V_t)*{V_t <- V_t*, rid_t <- rid_t*} = pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}
      -- let `%%`_rid(id', _pid*{_pid <- _pid*}) = rid_h
      -- if (id' = id)
      -- let (rid_t_found, V_t_found)*{V_t_found <- V_t_found*, rid_t_found <- rid_t_found*} = $find_non_overloadeds<V>(`{%}`_set<pair<rid, V>>(`%->%`_pair<rid, V>(rid_t, V_t)*{V_t <- V_t*, rid_t <- rid_t*}), id)

   ;; ../../../../spec-concrete/5.01-env.watsup:258.1-265.59
   clause 2(`{%}`_set<pair<rid, V>>(pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}), id) = (rid_t_found, V_t_found)*{V_t_found <- V_t_found*, rid_t_found <- rid_t_found*}
      -- if pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches _ :: _
      -- let `%->%`_pair<rid, V>(rid_h, V_h) :: `%->%`_pair<rid, V>(rid_t, V_t)*{V_t <- V_t*, rid_t <- rid_t*} = pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}
      -- let `%%`_rid(id_h, _pid*{_pid <- _pid*}) = rid_h
      -- if (id =/= id_h)
      -- let (rid_t_found, V_t_found)*{V_t_found <- V_t_found*, rid_t_found <- rid_t_found*} = $find_non_overloadeds<V>(`{%}`_set<pair<rid, V>>(`%->%`_pair<rid, V>(rid_t, V_t)*{V_t <- V_t*, rid_t <- rid_t*}), id)

;; ../../../../spec-concrete/5.02.1-context.watsup:5.17-5.39
syntax cursor = 
   | `GLOBAL`()
   | `BLOCK`()
   | `LOCAL`()

;; ../../../../spec-concrete/5.02.1-context.watsup:16.3-19.18
syntax globalTypingLayer = {`CDENV%`(cdenv), `TDENV%`(tdenv), `RDENV%`(rdenv), `FRAME%`(frame)}

;; ../../../../spec-concrete/5.02.1-context.watsup:24.1-28.12
syntax blockKind = 
   | `EMPTY`()
   | `EXTERN`()
   | `PARSER`()
   | `CONTROL`()
   | `PACKAGE`()

;; ../../../../spec-concrete/5.02.1-context.watsup:30.1-30.43
def $is_extern_blockKind(blockKind) : bool =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:31.1-31.57
   clause 0(blockKind) = (blockKind = `EXTERN`_blockKind())

;; ../../../../spec-concrete/5.02.1-context.watsup:33.1-33.43
def $is_parser_blockKind(blockKind) : bool =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:34.1-34.57
   clause 0(blockKind) = (blockKind = `PARSER`_blockKind())

;; ../../../../spec-concrete/5.02.1-context.watsup:36.1-36.44
def $is_control_blockKind(blockKind) : bool =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:37.1-37.59
   clause 0(blockKind) = (blockKind = `CONTROL`_blockKind())

;; ../../../../spec-concrete/5.02.1-context.watsup:39.1-39.44
def $is_package_blockKind(blockKind) : bool =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:40.1-40.59
   clause 0(blockKind) = (blockKind = `PACKAGE`_blockKind())

;; ../../../../spec-concrete/5.02.1-context.watsup:43.3-47.18
syntax blockTypingLayer = {`ID%`(id), `KIND%`(blockKind), `TDENV%`(tdenv), `RDENV%`(rdenv), `FRAME%`(frame)}

;; ../../../../spec-concrete/5.02.1-context.watsup:52.1-60.21
syntax localKind = 
   | `EMPTY`()
   | `FUNC%`(typeIR)
   | `EXTERNFUNC%`(typeIR)
   | `ACTION`()
   | `EXTERNMETHOD%`(typeIR)
   | `EXTERNABSTRACTMETHOD%`(typeIR)
   | `PARSERSTATE`()
   | `CONTROLAPPLYMETHOD`()
   | `TABLEAPPLYMETHOD`()

;; ../../../../spec-concrete/5.02.1-context.watsup:62.1-62.45
def $is_function_localKind(localKind) : bool =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:63.1-63.42
   clause 0(localKind) = true
      -- if localKind matches `FUNC%`
      -- let `FUNC%`_localKind(_typeIR) = localKind

   ;; ../../../../spec-concrete/5.02.1-context.watsup:64.1-65.15
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../spec-concrete/5.02.1-context.watsup:67.1-67.52
def $is_extern_function_localKind(localKind) : bool =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:68.1-68.55
   clause 0(localKind) = true
      -- if localKind matches `EXTERNFUNC%`
      -- let `EXTERNFUNC%`_localKind(_typeIR) = localKind

   ;; ../../../../spec-concrete/5.02.1-context.watsup:69.1-70.15
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../spec-concrete/5.02.1-context.watsup:72.1-72.43
def $is_action_localKind(localKind) : bool =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:73.1-73.40
   clause 0(localKind) = true
      -- if localKind matches `ACTION`

   ;; ../../../../spec-concrete/5.02.1-context.watsup:74.1-75.15
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../spec-concrete/5.02.1-context.watsup:77.1-77.50
def $is_extern_method_localKind(localKind) : bool =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:78.1-78.55
   clause 0(localKind) = true
      -- if localKind matches `EXTERNMETHOD%`
      -- let `EXTERNMETHOD%`_localKind(_typeIR) = localKind

   ;; ../../../../spec-concrete/5.02.1-context.watsup:79.1-80.15
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../spec-concrete/5.02.1-context.watsup:82.1-82.59
def $is_extern_abstract_method_localKind(localKind) : bool =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:83.1-83.72
   clause 0(localKind) = true
      -- if localKind matches `EXTERNABSTRACTMETHOD%`
      -- let `EXTERNABSTRACTMETHOD%`_localKind(_typeIR) = localKind

   ;; ../../../../spec-concrete/5.02.1-context.watsup:84.1-85.15
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../spec-concrete/5.02.1-context.watsup:87.1-87.49
def $is_parser_state_localKind(localKind) : bool =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:88.1-88.51
   clause 0(localKind) = true
      -- if localKind matches `PARSERSTATE`

   ;; ../../../../spec-concrete/5.02.1-context.watsup:89.1-90.15
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../spec-concrete/5.02.1-context.watsup:92.1-92.57
def $is_control_apply_method_localKind(localKind) : bool =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:93.1-93.66
   clause 0(localKind) = true
      -- if localKind matches `CONTROLAPPLYMETHOD`

   ;; ../../../../spec-concrete/5.02.1-context.watsup:94.1-95.15
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../spec-concrete/5.02.1-context.watsup:97.1-97.55
def $is_table_apply_method_localKind(localKind) : bool =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:98.1-98.62
   clause 0(localKind) = true
      -- if localKind matches `TABLEAPPLYMETHOD`

   ;; ../../../../spec-concrete/5.02.1-context.watsup:99.1-100.15
   clause 1(_localKind) = false
      -- otherwise

;; ../../../../spec-concrete/5.02.1-context.watsup:103.3-106.20
syntax localTypingLayer = {`ID%`(id), `KIND%`(localKind), `TDENV%`(tdenv), `FRAMES%`(frame*)}

;; ../../../../spec-concrete/5.02.1-context.watsup:113.3-115.29
syntax typingContext = {`GLOBAL%`(globalTypingLayer), `BLOCK%`(blockTypingLayer), `LOCAL%`(localTypingLayer)}

;; ../../../../spec-concrete/5.02.1-context.watsup:123.1-123.41
def $empty_typingContext : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:125.1-145.35
   clause 0 = TC
      -- let globalTypingLayer = {CDENV $empty_cdenv, TDENV $empty_tdenv, RDENV $empty_rdenv, FRAME $empty_frame}
      -- let blockTypingLayer = {ID "", KIND `EMPTY`_blockKind(), TDENV $empty_tdenv, RDENV $empty_rdenv, FRAME $empty_frame}
      -- let localTypingLayer = {ID "", KIND `EMPTY`_localKind(), TDENV $empty_tdenv, FRAMES [$empty_frame]}
      -- let TC = {GLOBAL globalTypingLayer, BLOCK blockTypingLayer, LOCAL localTypingLayer}

;; ../../../../spec-concrete/5.02.1-context.watsup:151.1-151.42
def $bound(cursor, typingContext) : bound =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:153.1-153.34
   clause 0(cursor, TC) = `{%}`_set<tid>([])
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.02.1-context.watsup:154.1-154.65
   clause 1(cursor, TC) = $dom_map<tid, typeDefIR>(TC.BLOCK.TDENV)
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.02.1-context.watsup:155.1-157.63
   clause 2(cursor, TC) = $union_set<tid>(bound_block, bound_local)
      -- if cursor matches `LOCAL`
      -- let bound_block = $bound(`BLOCK`_cursor(), TC)
      -- let bound_local = $dom_map<tid, typeDefIR>(TC.LOCAL.TDENV)

;; ../../../../spec-concrete/5.02.1-context.watsup:163.1-163.42
def $enter(typingContext) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:165.1-165.72
   clause 0(TC) = TC[LOCAL.FRAMES = $empty_frame :: TC.LOCAL.FRAMES]

;; ../../../../spec-concrete/5.02.1-context.watsup:167.1-167.41
def $exit(typingContext) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:169.1-170.46
   clause 0(TC) = TC[LOCAL.FRAMES = frame_t*{frame_t <- frame_t*}]
      -- let frame*{frame <- frame*} = TC.LOCAL.FRAMES
      -- if frame*{frame <- frame*} matches _ :: _
      -- let frame_h :: frame_t*{frame_t <- frame_t*} = frame*{frame <- frame*}

;; ../../../../spec-concrete/5.02.1-context.watsup:178.1-178.67
def $add_var(cursor, typingContext, id, varTypeIR) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:181.1-187.50
   clause 0(cursor, TC, id, varTypeIR) = TC'
      -- if cursor matches `GLOBAL`
      -- let frame = TC.GLOBAL.FRAME
      -- if ~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))
      -- let `%%%%`_varTypeIR(_direction, typeIR, _ctk, _value?{_value <- _value?}) = varTypeIR
      -- if ((id = "main") => $is_package_object_typeIR($canon(typeIR)))
      -- let frame_update = $add_map<id, varTypeIR>(frame, id, varTypeIR)
      -- let TC' = TC[GLOBAL.FRAME = frame_update]

   ;; ../../../../spec-concrete/5.02.1-context.watsup:188.1-193.49
   clause 1(cursor, TC, id, varTypeIR) = TC'
      -- if cursor matches `BLOCK`
      -- let frame = TC.BLOCK.FRAME
      -- if ~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))
      -- if (id =/= "main")
      -- let frame_update = $add_map<id, varTypeIR>(TC.BLOCK.FRAME, id, varTypeIR)
      -- let TC' = TC[BLOCK.FRAME = frame_update]

   ;; ../../../../spec-concrete/5.02.1-context.watsup:194.1-200.44
   clause 2(cursor, TC, id, varTypeIR) = TC'
      -- if cursor matches `LOCAL`
      -- let frame'*{frame' <- frame'*} = TC.LOCAL.FRAMES
      -- if frame'*{frame' <- frame'*} matches _ :: _
      -- let frame_h :: frame_t*{frame_t <- frame_t*} = frame'*{frame' <- frame'*}
      -- if ~$in_set<id>(id, $dom_map<id, varTypeIR>(frame_h))
      -- if (id =/= "main")
      -- let frame_h_update = $add_map<id, varTypeIR>(frame_h, id, varTypeIR)
      -- let frame*{frame <- frame*} = frame_h_update :: frame_t*{frame_t <- frame_t*}
      -- let TC' = TC[LOCAL.FRAMES = frame*{frame <- frame*}]

;; ../../../../spec-concrete/5.02.1-context.watsup:179.1-179.70
def $add_vars(cursor, typingContext, id*, varTypeIR*) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:202.1-202.36
   clause 0(p, TC, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*}) = TC
      -- if id*{id <- id*} matches []
      -- if varTypeIR*{varTypeIR <- varTypeIR*} matches []

   ;; ../../../../spec-concrete/5.02.1-context.watsup:203.1-205.54
   clause 1(p, TC, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*}) = TC''
      -- if id*{id <- id*} matches _ :: _
      -- let id_h :: id_t*{id_t <- id_t*} = id*{id <- id*}
      -- if varTypeIR*{varTypeIR <- varTypeIR*} matches _ :: _
      -- let varTypeIR_h :: varTypeIR_t*{varTypeIR_t <- varTypeIR_t*} = varTypeIR*{varTypeIR <- varTypeIR*}
      -- let TC' = $add_var(p, TC, id_h, varTypeIR_h)
      -- let TC'' = $add_vars(p, TC', id_t*{id_t <- id_t*}, varTypeIR_t*{varTypeIR_t <- varTypeIR_t*})

;; ../../../../spec-concrete/5.02.1-context.watsup:209.1-209.75
def $add_parameter(cursor, typingContext, parameterTypeIR) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:212.1-214.50
   clause 0(cursor, TC, `%%%%`_parameterTypeIR(direction, typeIR, id, value?{value <- value?})) = TC'
      -- if direction matches `NO`
      -- let varTypeIR = `%%%%`_varTypeIR(`NO`_direction(), typeIR, `CTK`_ctk(), value?{value <- value?})
      -- let TC' = $add_var(cursor, TC, id, varTypeIR)

   ;; ../../../../spec-concrete/5.02.1-context.watsup:215.1-218.50
   clause 1(cursor, TC, `%%%%`_parameterTypeIR(direction, typeIR, id, value?{value <- value?})) = TC'
      -- if (((direction = `IN`_direction()) \/ (direction = `OUT`_direction())) \/ (direction = `INOUT`_direction()))
      -- let varTypeIR = `%%%%`_varTypeIR(direction, typeIR, `DYN`_ctk(), value?{value <- value?})
      -- let TC' = $add_var(cursor, TC, id, varTypeIR)

;; ../../../../spec-concrete/5.02.1-context.watsup:210.1-210.77
def $add_parameters(cursor, typingContext, parameterTypeIR*) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:220.1-220.42
   clause 0(cursor, TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../spec-concrete/5.02.1-context.watsup:221.1-223.64
   clause 1(cursor, TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC''
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let TC' = $add_parameter(cursor, TC, parameterTypeIR_h)
      -- let TC'' = $add_parameters(cursor, TC', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.02.1-context.watsup:227.1-227.78
def $add_constructorParameter(typingContext, parameterTypeIR) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:230.1-232.49
   clause 0(TC, `%%%%`_parameterTypeIR(direction, typeIR, id, value?{value <- value?})) = TC'
      -- if value?{value <- value?} matches ()
      -- let varTypeIR = `%%%%`_varTypeIR(direction, typeIR, `CTK`_ctk(), ?())
      -- let TC' = $add_var(`BLOCK`_cursor(), TC, id, varTypeIR)

   ;; ../../../../spec-concrete/5.02.1-context.watsup:233.1-235.49
   clause 1(TC, `%%%%`_parameterTypeIR(direction, typeIR, id, value'?{value' <- value'?})) = TC'
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}
      -- let varTypeIR = `%%%%`_varTypeIR(direction, typeIR, `CTK`_ctk(), ?(value))
      -- let TC' = $add_var(`BLOCK`_cursor(), TC, id, varTypeIR)

;; ../../../../spec-concrete/5.02.1-context.watsup:228.1-228.80
def $add_constructorParameters(typingContext, parameterTypeIR*) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:237.1-237.45
   clause 0(TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../spec-concrete/5.02.1-context.watsup:238.1-240.67
   clause 1(TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC''
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let TC' = $add_constructorParameter(TC, parameterTypeIR_h)
      -- let TC'' = $add_constructorParameters(TC', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.02.1-context.watsup:244.1-244.69
def $add_type(cursor, typingContext, tid, typeDefIR) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:245.1-250.50
   clause 0(cursor, TC, tid, typeDefIR) = TC'
      -- if cursor matches `GLOBAL`
      -- let tdenv = TC.GLOBAL.TDENV
      -- if ~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))
      -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
      -- let TC' = TC[GLOBAL.TDENV = tdenv_update]

   ;; ../../../../spec-concrete/5.02.1-context.watsup:251.1-256.49
   clause 1(cursor, TC, tid, typeDefIR) = TC'
      -- if cursor matches `BLOCK`
      -- let tdenv = TC.BLOCK.TDENV
      -- if ~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))
      -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
      -- let TC' = TC[BLOCK.TDENV = tdenv_update]

   ;; ../../../../spec-concrete/5.02.1-context.watsup:257.1-262.49
   clause 2(cursor, TC, tid, typeDefIR) = TC'
      -- if cursor matches `LOCAL`
      -- let tdenv = TC.LOCAL.TDENV
      -- if ~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))
      -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
      -- let TC' = TC[LOCAL.TDENV = tdenv_update]

;; ../../../../spec-concrete/5.02.1-context.watsup:264.1-264.72
def $add_types(cursor, typingContext, tid*, typeDefIR*) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:265.1-265.37
   clause 0(p, TC, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*}) = TC
      -- if tid*{tid <- tid*} matches []
      -- if typeDefIR*{typeDefIR <- typeDefIR*} matches []

   ;; ../../../../spec-concrete/5.02.1-context.watsup:266.1-268.56
   clause 1(p, TC, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*}) = TC''
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if typeDefIR*{typeDefIR <- typeDefIR*} matches _ :: _
      -- let typeDefIR_h :: typeDefIR_t*{typeDefIR_t <- typeDefIR_t*} = typeDefIR*{typeDefIR <- typeDefIR*}
      -- let TC' = $add_type(p, TC, tid_h, typeDefIR_h)
      -- let TC'' = $add_types(p, TC', tid_t*{tid_t <- tid_t*}, typeDefIR_t*{typeDefIR_t <- typeDefIR_t*})

;; ../../../../spec-concrete/5.02.1-context.watsup:272.1-272.88
def $add_routine_overload(cursor, typingContext, rid, routineTypeDefIR) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:274.1-279.50
   clause 0(cursor, TC, rid, routineTypeDefIR) = TC'
      -- if cursor matches `GLOBAL`
      -- let rdenv = TC.GLOBAL.RDENV
      -- if ~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let TC' = TC[GLOBAL.RDENV = rdenv_update]

   ;; ../../../../spec-concrete/5.02.1-context.watsup:280.1-285.49
   clause 1(cursor, TC, rid, routineTypeDefIR) = TC'
      -- if cursor matches `BLOCK`
      -- let rdenv = TC.BLOCK.RDENV
      -- if ~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let TC' = TC[BLOCK.RDENV = rdenv_update]

;; ../../../../spec-concrete/5.02.1-context.watsup:287.1-287.92
def $add_routine_non_overload(cursor, typingContext, rid, routineTypeDefIR) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:289.1-296.50
   clause 0(cursor, TC, rid, routineTypeDefIR) = TC'
      -- if cursor matches `GLOBAL`
      -- let rdenv = TC.GLOBAL.RDENV
      -- let `%%`_rid(id, _pid*{_pid <- _pid*}) = rid
      -- let `{%}`_set<rid>(`%%`_rid(id_k, _pid'*{_pid' <- _pid'*})*{_pid'* <- _pid'**, id_k <- id_k*}) = $dom_map<rid, routineTypeDefIR>(rdenv)
      -- if ~$in_set<id>(id, `{%}`_set<id>(id_k*{id_k <- id_k*}))
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let TC' = TC[GLOBAL.RDENV = rdenv_update]

   ;; ../../../../spec-concrete/5.02.1-context.watsup:297.1-304.49
   clause 1(cursor, TC, rid, routineTypeDefIR) = TC'
      -- if cursor matches `BLOCK`
      -- let rdenv = TC.BLOCK.RDENV
      -- let `%%`_rid(id, _pid*{_pid <- _pid*}) = rid
      -- let `{%}`_set<rid>(`%%`_rid(id_k, _pid'*{_pid' <- _pid'*})*{_pid'* <- _pid'**, id_k <- id_k*}) = $dom_map<rid, routineTypeDefIR>(rdenv)
      -- if ~$in_set<id>(id, `{%}`_set<id>(id_k*{id_k <- id_k*}))
      -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let TC' = TC[BLOCK.RDENV = rdenv_update]

;; ../../../../spec-concrete/5.02.1-context.watsup:308.1-308.79
def $add_constructor(typingContext, cid, constructorTypeDefIR) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:311.1-316.50
   clause 0(TC, cid, constructorTypeDefIR) = TC'
      -- let cdenv = TC.GLOBAL.CDENV
      -- if ~$in_set<cid>(cid, $dom_map<cid, constructorTypeDefIR>(cdenv))
      -- let cdenv_update = $add_map<cid, constructorTypeDefIR>(cdenv, cid, constructorTypeDefIR)
      -- let TC' = TC[GLOBAL.CDENV = cdenv_update]

;; ../../../../spec-concrete/5.02.1-context.watsup:309.1-309.82
def $add_constructors(typingContext, cid*, constructorTypeDefIR*) : typingContext =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:318.1-318.41
   clause 0(TC, cid*{cid <- cid*}, constructorTypeDefIR*{constructorTypeDefIR <- constructorTypeDefIR*}) = TC
      -- if cid*{cid <- cid*} matches []
      -- if constructorTypeDefIR*{constructorTypeDefIR <- constructorTypeDefIR*} matches []

   ;; ../../../../spec-concrete/5.02.1-context.watsup:319.1-326.71
   clause 1(TC, cid*{cid <- cid*}, constructorTypeDefIR*{constructorTypeDefIR <- constructorTypeDefIR*}) = TC''
      -- if cid*{cid <- cid*} matches _ :: _
      -- let cid_h :: cid_t*{cid_t <- cid_t*} = cid*{cid <- cid*}
      -- if constructorTypeDefIR*{constructorTypeDefIR <- constructorTypeDefIR*} matches _ :: _
      -- let constructorTypeDefIR_h :: constructorTypeDefIR_t*{constructorTypeDefIR_t <- constructorTypeDefIR_t*} = constructorTypeDefIR*{constructorTypeDefIR <- constructorTypeDefIR*}
      -- let TC' = $add_constructor(TC, cid_h, constructorTypeDefIR_h)
      -- let TC'' = $add_constructors(TC', cid_t*{cid_t <- cid_t*}, constructorTypeDefIR_t*{constructorTypeDefIR_t <- constructorTypeDefIR_t*})

;; ../../../../spec-concrete/5.02.1-context.watsup:334.1-334.64
def $find_var(cursor, typingContext, prefixedName) : varTypeIR? =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:336.1-337.32
   clause 0(p, TC, prefixedName) = $find_map<id, varTypeIR>(frame, id)
      -- if prefixedName matches `TOP%`
      -- let `TOP%`_prefixedName(id) = prefixedName
      -- let frame = TC.GLOBAL.FRAME

   ;; ../../../../spec-concrete/5.02.1-context.watsup:338.1-339.32
   clause 1(cursor, TC, prefixedName) = $find_map<id, varTypeIR>(frame, id)
      -- if cursor matches `GLOBAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let frame = TC.GLOBAL.FRAME

   ;; ../../../../spec-concrete/5.02.1-context.watsup:340.1-342.56
   clause 2(cursor, TC, prefixedName) = ?(varTypeIR)
      -- if cursor matches `BLOCK`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let frame = TC.BLOCK.FRAME
      -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
      -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}

   ;; ../../../../spec-concrete/5.02.1-context.watsup:343.1-345.50
   clause 3(cursor, TC, prefixedName) = $find_var(`GLOBAL`_cursor(), TC, `CURRENT%`_prefixedName(id))
      -- if cursor matches `BLOCK`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let frame = TC.BLOCK.FRAME
      -- if (?() = $find_map<id, varTypeIR>(frame, id))

   ;; ../../../../spec-concrete/5.02.1-context.watsup:346.1-348.58
   clause 4(cursor, TC, prefixedName) = ?(varTypeIR)
      -- if cursor matches `LOCAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let frame*{frame <- frame*} = TC.LOCAL.FRAMES
      -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id)
      -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
      -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}

   ;; ../../../../spec-concrete/5.02.1-context.watsup:349.1-351.52
   clause 5(cursor, TC, prefixedName) = $find_var(`BLOCK`_cursor(), TC, `CURRENT%`_prefixedName(id))
      -- if cursor matches `LOCAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let frame*{frame <- frame*} = TC.LOCAL.FRAMES
      -- if (?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

;; ../../../../spec-concrete/5.02.1-context.watsup:355.1-355.62
def $find_value(cursor, typingContext, prefixedName) : value? =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:357.1-359.59
   clause 0(p, TC, prefixedName) = value?{value <- value?}
      -- if prefixedName matches `TOP%`
      -- let `TOP%`_prefixedName(id) = prefixedName
      -- let frame = TC.GLOBAL.FRAME
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(`%%%%`_varTypeIR(_direction, _typeIR, _ctk, value?{value <- value?})) = varTypeIR?{varTypeIR <- varTypeIR?}

   ;; ../../../../spec-concrete/5.02.1-context.watsup:360.1-362.50
   clause 1(p, TC, prefixedName) = ?()
      -- if prefixedName matches `TOP%`
      -- let `TOP%`_prefixedName(id) = prefixedName
      -- let frame = TC.GLOBAL.FRAME
      -- if (?() = $find_map<id, varTypeIR>(frame, id))

   ;; ../../../../spec-concrete/5.02.1-context.watsup:363.1-365.59
   clause 2(cursor, TC, prefixedName) = value?{value <- value?}
      -- if cursor matches `GLOBAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let frame = TC.GLOBAL.FRAME
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(`%%%%`_varTypeIR(_direction, _typeIR, _ctk, value?{value <- value?})) = varTypeIR?{varTypeIR <- varTypeIR?}

   ;; ../../../../spec-concrete/5.02.1-context.watsup:366.1-368.50
   clause 3(cursor, TC, prefixedName) = ?()
      -- if cursor matches `GLOBAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let frame = TC.GLOBAL.FRAME
      -- if (?() = $find_map<id, varTypeIR>(frame, id))

   ;; ../../../../spec-concrete/5.02.1-context.watsup:369.1-371.59
   clause 4(cursor, TC, prefixedName) = value?{value <- value?}
      -- if cursor matches `BLOCK`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let frame = TC.BLOCK.FRAME
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(`%%%%`_varTypeIR(_direction, _typeIR, _ctk, value?{value <- value?})) = varTypeIR?{varTypeIR <- varTypeIR?}

   ;; ../../../../spec-concrete/5.02.1-context.watsup:372.1-374.50
   clause 5(cursor, TC, prefixedName) = $find_value(`GLOBAL`_cursor(), TC, `CURRENT%`_prefixedName(id))
      -- if cursor matches `BLOCK`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let frame = TC.BLOCK.FRAME
      -- if (?() = $find_map<id, varTypeIR>(frame, id))

   ;; ../../../../spec-concrete/5.02.1-context.watsup:375.1-377.61
   clause 6(cursor, TC, prefixedName) = value?{value <- value?}
      -- if cursor matches `LOCAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let frame*{frame <- frame*} = TC.LOCAL.FRAMES
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(`%%%%`_varTypeIR(_direction, _typeIR, _ctk, value?{value <- value?})) = varTypeIR?{varTypeIR <- varTypeIR?}

   ;; ../../../../spec-concrete/5.02.1-context.watsup:378.1-380.52
   clause 7(cursor, TC, prefixedName) = $find_value(`BLOCK`_cursor(), TC, `CURRENT%`_prefixedName(id))
      -- if cursor matches `LOCAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let frame*{frame <- frame*} = TC.LOCAL.FRAMES
      -- if (?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

;; ../../../../spec-concrete/5.02.1-context.watsup:384.1-384.65
def $find_type(cursor, typingContext, prefixedName) : typeDefIR? =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:386.1-388.32
   clause 0(p, TC, prefixedName) = $find_map<tid, typeDefIR>(tdenv, tid)
      -- if prefixedName matches `TOP%`
      -- let `TOP%`_prefixedName(tid) = prefixedName
      -- let tdenv = TC.GLOBAL.TDENV

   ;; ../../../../spec-concrete/5.02.1-context.watsup:389.1-391.32
   clause 1(cursor, TC, prefixedName) = $find_map<tid, typeDefIR>(tdenv, tid)
      -- if cursor matches `GLOBAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(tid) = prefixedName
      -- let tdenv = TC.GLOBAL.TDENV

   ;; ../../../../spec-concrete/5.02.1-context.watsup:392.1-394.58
   clause 2(cursor, TC, prefixedName) = ?(typeDefIR)
      -- if cursor matches `BLOCK`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(tid) = prefixedName
      -- let tdenv = TC.BLOCK.TDENV
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_map<tid, typeDefIR>(tdenv, tid)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}

   ;; ../../../../spec-concrete/5.02.1-context.watsup:395.1-397.52
   clause 3(cursor, TC, prefixedName) = $find_type(`GLOBAL`_cursor(), TC, `CURRENT%`_prefixedName(tid))
      -- if cursor matches `BLOCK`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(tid) = prefixedName
      -- let tdenv = TC.BLOCK.TDENV
      -- if (?() = $find_map<tid, typeDefIR>(tdenv, tid))

   ;; ../../../../spec-concrete/5.02.1-context.watsup:398.1-400.60
   clause 4(cursor, TC, prefixedName) = ?(typeDefIR)
      -- if cursor matches `LOCAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(tid) = prefixedName
      -- let tdenv*{tdenv <- tdenv*} = [TC.LOCAL.TDENV]
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}

   ;; ../../../../spec-concrete/5.02.1-context.watsup:401.1-403.54
   clause 5(cursor, TC, prefixedName) = $find_type(`BLOCK`_cursor(), TC, `CURRENT%`_prefixedName(tid))
      -- if cursor matches `LOCAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(tid) = prefixedName
      -- let tdenv*{tdenv <- tdenv*} = [TC.LOCAL.TDENV]
      -- if (?() = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid))

;; ../../../../spec-concrete/5.02.1-context.watsup:407.1-407.41
def $ids_arguments(argumentIR*) : id?* =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:410.1-410.62
   clause 0(argumentIR*{argumentIR <- argumentIR*}) = $id_argument(argumentIR)*{argumentIR <- argumentIR*}

;; ../../../../spec-concrete/5.02.1-context.watsup:408.1-408.35
def $id_argument(argumentIR) : id? =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:411.1-411.32
   clause 0(argumentIR) = ?()
      -- if argumentIR matches `ExprA%`
      -- let `ExprA%`_argumentIR(_typedExpressionIR) = argumentIR

   ;; ../../../../spec-concrete/5.02.1-context.watsup:412.1-412.38
   clause 1(argumentIR) = ?(name)
      -- if argumentIR matches `NameA%%`
      -- let `NameA%%`_argumentIR(name, _typedExpressionIR) = argumentIR

   ;; ../../../../spec-concrete/5.02.1-context.watsup:413.1-413.39
   clause 2(argumentIR) = ?(name)
      -- if argumentIR matches `NameAnyA%`
      -- let `NameAnyA%`_argumentIR(name) = argumentIR

   ;; ../../../../spec-concrete/5.02.1-context.watsup:414.1-414.29
   clause 3(argumentIR) = ?()
      -- if argumentIR matches `AnyA`

;; ../../../../spec-concrete/5.02.1-context.watsup:416.1-417.34
def $find_routine_overloaded(cursor, typingContext, prefixedName, argumentIR*) : (rid, routineTypeDefIR, id*)? =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:419.1-422.49
   clause 0(p, TC, prefixedName, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedName matches `TOP%`
      -- let `TOP%`_prefixedName(id) = prefixedName
      -- let rdenv = TC.GLOBAL.RDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

   ;; ../../../../spec-concrete/5.02.1-context.watsup:423.1-426.49
   clause 1(cursor, TC, prefixedName, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if cursor matches `GLOBAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let rdenv = TC.GLOBAL.RDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

   ;; ../../../../spec-concrete/5.02.1-context.watsup:427.1-432.66
   clause 2(cursor, TC, prefixedName, argumentIR*{argumentIR <- argumentIR*}) = ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*}))
      -- if cursor matches `BLOCK`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let rdenv = TC.BLOCK.RDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}

   ;; ../../../../spec-concrete/5.02.1-context.watsup:433.1-438.66
   clause 3(cursor, TC, prefixedName, argumentIR*{argumentIR <- argumentIR*}) = $find_routine_overloaded(`GLOBAL`_cursor(), TC, `CURRENT%`_prefixedName(id), argumentIR*{argumentIR <- argumentIR*})
      -- if cursor matches `BLOCK`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let rdenv = TC.BLOCK.RDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
      -- if (?() = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}))

   ;; ../../../../spec-concrete/5.02.1-context.watsup:439.1-440.65
   clause 4(cursor, TC, prefixedName, argumentIR*{argumentIR <- argumentIR*}) = $find_routine_overloaded(`BLOCK`_cursor(), TC, `CURRENT%`_prefixedName(id), argumentIR*{argumentIR <- argumentIR*})
      -- if cursor matches `LOCAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName

;; ../../../../spec-concrete/5.02.1-context.watsup:442.1-443.29
def $find_routine_non_overloaded(cursor, typingContext, prefixedName) : (rid, routineTypeDefIR)? =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:445.1-446.64
   clause 0(p, TC, prefixedName) = $find_non_overloaded<routineTypeDefIR>(TC.GLOBAL.RDENV, id)
      -- if prefixedName matches `TOP%`
      -- let `TOP%`_prefixedName(id) = prefixedName

   ;; ../../../../spec-concrete/5.02.1-context.watsup:447.1-448.64
   clause 1(cursor, TC, prefixedName) = $find_non_overloaded<routineTypeDefIR>(TC.GLOBAL.RDENV, id)
      -- if cursor matches `GLOBAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName

   ;; ../../../../spec-concrete/5.02.1-context.watsup:449.1-451.67
   clause 2(cursor, TC, prefixedName) = ?((rid, routineTypeDefIR))
      -- if cursor matches `BLOCK`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?} = $find_non_overloaded<routineTypeDefIR>(TC.BLOCK.RDENV, id)
      -- if (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?} matches (_)
      -- let ?((rid, routineTypeDefIR)) = (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?}

   ;; ../../../../spec-concrete/5.02.1-context.watsup:452.1-455.67
   clause 3(cursor, TC, prefixedName) = $find_routine_non_overloaded(`GLOBAL`_cursor(), TC, `CURRENT%`_prefixedName(id))
      -- if cursor matches `BLOCK`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- if (?() = $find_non_overloaded<routineTypeDefIR>(TC.BLOCK.RDENV, id))

   ;; ../../../../spec-concrete/5.02.1-context.watsup:456.1-457.56
   clause 4(cursor, TC, prefixedName) = $find_routine_non_overloaded(`BLOCK`_cursor(), TC, `CURRENT%`_prefixedName(id))
      -- if cursor matches `LOCAL`
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName

;; ../../../../spec-concrete/5.02.1-context.watsup:461.1-462.38
def $find_constructor_overloaded(typingContext, prefixedName, argumentIR*) : (rid, constructorTypeDefIR, id*)? =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:464.1-467.49
   clause 0(TC, prefixedName, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedName matches `TOP%`
      -- let `TOP%`_prefixedName(id) = prefixedName
      -- let cdenv = TC.GLOBAL.CDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

   ;; ../../../../spec-concrete/5.02.1-context.watsup:468.1-471.49
   clause 1(TC, prefixedName, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let cdenv = TC.GLOBAL.CDENV
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

;; ../../../../spec-concrete/5.02.1-context.watsup:473.1-474.33
def $find_constructors_non_overloaded(typingContext, prefixedName) : (rid, constructorTypeDefIR)* =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:476.1-478.32
   clause 0(TC, prefixedName) = $find_non_overloadeds<constructorTypeDefIR>(cdenv, id)
      -- if prefixedName matches `TOP%`
      -- let `TOP%`_prefixedName(id) = prefixedName
      -- let cdenv = TC.GLOBAL.CDENV

   ;; ../../../../spec-concrete/5.02.1-context.watsup:479.1-481.32
   clause 1(TC, prefixedName) = $find_non_overloadeds<constructorTypeDefIR>(cdenv, id)
      -- if prefixedName matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(id) = prefixedName
      -- let cdenv = TC.GLOBAL.CDENV

;; ../../../../spec-concrete/5.02.1-context.watsup:485.1-485.47
def $find_return_type(typingContext) : typeIR? =

   ;; ../../../../spec-concrete/5.02.1-context.watsup:487.1-488.40
   clause 0(TC) = ?(typeIR_ret)
      -- let localKind = TC.LOCAL.KIND
      -- if localKind matches `FUNC%`
      -- let `FUNC%`_localKind(typeIR_ret) = localKind

   ;; ../../../../spec-concrete/5.02.1-context.watsup:489.1-490.46
   clause 1(TC) = ?(typeIR_ret)
      -- let localKind = TC.LOCAL.KIND
      -- if localKind matches `EXTERNFUNC%`
      -- let `EXTERNFUNC%`_localKind(typeIR_ret) = localKind

   ;; ../../../../spec-concrete/5.02.1-context.watsup:491.1-492.31
   clause 2(TC) = ?(`VoidT`_primitiveTypeIR() as typeIR)
      -- if (`ACTION`_localKind() = TC.LOCAL.KIND)

   ;; ../../../../spec-concrete/5.02.1-context.watsup:493.1-494.48
   clause 3(TC) = ?(typeIR_ret)
      -- let localKind = TC.LOCAL.KIND
      -- if localKind matches `EXTERNMETHOD%`
      -- let `EXTERNMETHOD%`_localKind(typeIR_ret) = localKind

   ;; ../../../../spec-concrete/5.02.1-context.watsup:495.1-497.22
   clause 4(TC) = ?(typeIR_ret)
      -- let localKind = TC.LOCAL.KIND
      -- if localKind matches `EXTERNABSTRACTMETHOD%`
      -- let `EXTERNABSTRACTMETHOD%`_localKind(typeIR_ret) = localKind

   ;; ../../../../spec-concrete/5.02.1-context.watsup:498.1-499.43
   clause 5(TC) = ?(`VoidT`_primitiveTypeIR() as typeIR)
      -- if (`CONTROLAPPLYMETHOD`_localKind() = TC.LOCAL.KIND)

   ;; ../../../../spec-concrete/5.02.1-context.watsup:500.1-501.15
   clause 6(TC) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.02.2-table-context.watsup:5.19-5.31
syntax matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.02.2-table-context.watsup:7.22-7.67
syntax matchAction = (prefixedName, parameterTypeIR*, argumentIR*)

;; ../../../../spec-concrete/5.02.2-table-context.watsup:10.3-13.24
syntax matchPriority = {`VALUES%`(nat*), `INIT%`(bool), `DELTA%`(nat), `LARGEST_WINS%`(bool)}

;; ../../../../spec-concrete/5.02.2-table-context.watsup:16.3-17.17
syntax matchEntry = {`SIZE%`(nat), `CONST%`(bool)}

;; ../../../../spec-concrete/5.02.2-table-context.watsup:21.1-27.11
syntax matchMode = 
   | `NOPRI`()
   | `NOPRILPM%`(nat)
   | `PRI`()
   | `PRILPM`()

;; ../../../../spec-concrete/5.02.2-table-context.watsup:30.3-34.21
syntax tableContext = {`KEYS%`(matchKey*), `ACTIONS%`(matchAction*), `PRIORITIES%`(matchPriority), `ENTRIES%`(matchEntry), `MODE%`(matchMode)}

;; ../../../../spec-concrete/5.02.2-table-context.watsup:44.1-46.10
syntax tableEntryState = 
   | `LPM%`(nat)
   | `NOLPM`()

;; ../../../../spec-concrete/5.02.2-table-context.watsup:54.1-54.38
def $empty_tableContext : tableContext =

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:55.1-68.25
   clause 0 = {KEYS [], ACTIONS [], PRIORITIES matchPriority, ENTRIES matchEntry, MODE `NOPRI`_matchMode()}
      -- let matchPriority = {VALUES [], INIT false, DELTA 1, LARGEST_WINS true}
      -- let matchEntry = {SIZE 0, CONST true}

;; ../../../../spec-concrete/5.02.2-table-context.watsup:76.1-76.54
def $add_key(tableContext, id, typeIR) : tableContext =

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:78.1-80.32
   clause 0(TBLC, id, typeIR) = TBLC[KEYS = TBLC.KEYS ++ [matchKey]]
      -- let matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.02.2-table-context.watsup:84.1-84.90
def $add_action(tableContext, prefixedName, parameterTypeIR*, argumentIR*) : tableContext =

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:86.1-88.68
   clause 0(TBLC, prefixedName, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = TBLC[ACTIONS = TBLC.ACTIONS ++ [matchAction]]
      -- let matchAction = (prefixedName, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*})

;; ../../../../spec-concrete/5.02.2-table-context.watsup:92.1-92.58
def $add_table_priority(tableContext, nat) : tableContext =

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:94.1-95.65
   clause 0(TBLC, n) = TBLC[PRIORITIES.VALUES = TBLC.PRIORITIES.VALUES ++ [n]]

;; ../../../../spec-concrete/5.02.2-table-context.watsup:103.1-103.58
def $update_mode(tableContext, id, typeIR) : tableContext =

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:106.1-106.77
   clause 0(TBLC, id, typeIR) = $update_mode'(TBLC, id, $canon(typeIR))

;; ../../../../spec-concrete/5.02.2-table-context.watsup:104.1-104.59
def $update_mode'(tableContext, id, typeIR) : tableContext =

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:107.1-108.26
   clause 0(TBLC, text, typeIR) = TBLC[MODE = `NOPRILPM%`_matchMode(n)]
      -- if (text = "lpm")
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(n) = numberTypeIR
      -- if (TBLC.MODE = `NOPRI`_matchMode())

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:109.1-110.26
   clause 1(TBLC, text, typeIR) = TBLC[MODE = `NOPRILPM%`_matchMode(n)]
      -- if (text = "lpm")
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(n) = numberTypeIR
      -- if (TBLC.MODE = `NOPRI`_matchMode())

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:111.1-112.26
   clause 2(TBLC, text, typeIR) = TBLC[MODE = `NOPRILPM%`_matchMode(n)]
      -- if (text = "lpm")
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VBitT%`
      -- let `VBitT%`_numberTypeIR(n) = numberTypeIR
      -- if (TBLC.MODE = `NOPRI`_matchMode())

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:113.1-114.38
   clause 3(TBLC, text, typeIR') = $update_mode(TBLC, "lpm", typeIR)
      -- if (text = "lpm")
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:115.1-116.24
   clause 4(TBLC, text, _typeIR) = TBLC[MODE = `PRILPM`_matchMode()]
      -- if (text = "lpm")
      -- if (TBLC.MODE = `PRI`_matchMode())

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:117.1-118.26
   clause 5(TBLC, text, _typeIR) = TBLC[MODE = `PRI`_matchMode()]
      -- if (text = "range")
      -- if (TBLC.MODE = `NOPRI`_matchMode())

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:119.1-120.26
   clause 6(TBLC, text, _typeIR) = TBLC[MODE = `PRI`_matchMode()]
      -- if (text = "ternary")
      -- if (TBLC.MODE = `NOPRI`_matchMode())

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:121.1-122.26
   clause 7(TBLC, text, _typeIR) = TBLC[MODE = `PRI`_matchMode()]
      -- if (text = "optional")
      -- if (TBLC.MODE = `NOPRI`_matchMode())

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:123.1-124.31
   clause 8(TBLC, text, _typeIR) = TBLC[MODE = `PRILPM`_matchMode()]
      -- if (text = "range")
      -- let matchMode = TBLC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM%`_matchMode(_nat) = matchMode

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:125.1-126.31
   clause 9(TBLC, text, _typeIR) = TBLC[MODE = `PRILPM`_matchMode()]
      -- if (text = "ternary")
      -- let matchMode = TBLC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM%`_matchMode(_nat) = matchMode

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:127.1-128.31
   clause 10(TBLC, text, _typeIR) = TBLC[MODE = `PRILPM`_matchMode()]
      -- if (text = "optional")
      -- let matchMode = TBLC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM%`_matchMode(_nat) = matchMode

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:129.1-130.15
   clause 11(TBLC, _id, _typeIR) = TBLC
      -- otherwise

;; ../../../../spec-concrete/5.02.2-table-context.watsup:138.1-138.80
def $find_action(tableContext, prefixedName) : (parameterTypeIR*, argumentIR*)? =

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:141.1-141.81
   clause 0(TBLC, prefixedName) = $find_action'(TBLC.ACTIONS, prefixedName)

;; ../../../../spec-concrete/5.02.2-table-context.watsup:139.1-139.81
def $find_action'(matchAction*, prefixedName) : (parameterTypeIR*, argumentIR*)? =

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:143.1-143.43
   clause 0(matchAction*{matchAction <- matchAction*}, prefixedName) = ?()
      -- if matchAction*{matchAction <- matchAction*} matches []

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:145.1-147.70
   clause 1(matchAction*{matchAction <- matchAction*}, prefixedName) = ?((parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}))
      -- if matchAction*{matchAction <- matchAction*} matches _ :: _
      -- let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} = matchAction*{matchAction <- matchAction*}
      -- let (prefixedName', parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = matchAction_h
      -- if (prefixedName' = prefixedName)

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:149.1-152.40
   clause 2(matchAction*{matchAction <- matchAction*}, prefixedName) = $find_action'(matchAction_t*{matchAction_t <- matchAction_t*}, prefixedName)
      -- if matchAction*{matchAction <- matchAction*} matches _ :: _
      -- let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} = matchAction*{matchAction <- matchAction*}
      -- let (prefixedName_h, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentIR*{_argumentIR <- _argumentIR*}) = matchAction_h
      -- if (prefixedName_h =/= prefixedName)

;; ../../../../spec-concrete/5.02.2-table-context.watsup:156.1-156.50
def $find_table_priority_last(tableContext) : nat =

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:158.1-161.25
   clause 0(TBLC) = n*{n <- n*}[n']
      -- let n*{n <- n*} = TBLC.PRIORITIES.VALUES
      -- if (|n*{n <- n*}| > 0)
      -- let int = (|n*{n <- n*}| - 1)
      -- if int <: nat
      -- let n' = int as nat

;; ../../../../spec-concrete/5.02.2-table-context.watsup:167.1-167.78
def $join_tableEntryState(tableEntryState, tableEntryState) : tableEntryState =

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:169.1-169.48
   clause 0(tableEntryState, tableEntryState') = `LPM%`_tableEntryState(n)
      -- if tableEntryState matches `NOLPM`
      -- if tableEntryState' matches `LPM%`
      -- let `LPM%`_tableEntryState(n) = tableEntryState'

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:170.1-170.48
   clause 1(tableEntryState, tableEntryState') = `LPM%`_tableEntryState(n)
      -- if tableEntryState matches `LPM%`
      -- let `LPM%`_tableEntryState(n) = tableEntryState
      -- if tableEntryState' matches `NOLPM`

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:171.1-171.48
   clause 2(tableEntryState, tableEntryState') = `NOLPM`_tableEntryState()
      -- if tableEntryState matches `NOLPM`
      -- if tableEntryState' matches `NOLPM`

;; ../../../../spec-concrete/5.02.2-table-context.watsup:173.1-173.40
def $tableEntry_lpm_prefix(value) : nat =

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:176.1-176.70
   clause 0(value) = $tableEntry_lpm_prefix'(value, 0)

;; ../../../../spec-concrete/5.02.2-table-context.watsup:174.1-174.46
def $tableEntry_lpm_prefix'(value, nat) : nat =

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:177.1-177.60
   clause 0(value, n_prefix) = n_prefix
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(nat, _bits) = numberValue
      -- if (nat = 0)

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:178.1-184.29
   clause 1(value, n_prefix) = $tableEntry_lpm_prefix'(value', (n_prefix + 1))
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, bits) = numberValue
      -- if bits <: nat
      -- let n = bits as nat
      -- if (w =/= 0)
      -- let int = (w - 1)
      -- if int <: nat
      -- let w' = int as nat
      -- if ((n \ 2) =/= 0)
      -- let int' = ((n - 1) / 2 as int)
      -- if int' <: nat
      -- let n' = int' as nat
      -- let value' = `FBitV%%`_numberValue(w', n' as bits) as value

   ;; ../../../../spec-concrete/5.02.2-table-context.watsup:185.1-190.35
   clause 2(value, nat) = $tableEntry_lpm_prefix'(value', 0)
      -- if value <: numberValue
      -- let numberValue = value as numberValue
      -- if numberValue matches `FBitV%%`
      -- let `FBitV%%`_numberValue(w, bits) = numberValue
      -- if bits <: nat
      -- let n = bits as nat
      -- if (nat = 0)
      -- if (w =/= 0)
      -- let int = (w - 1)
      -- if int <: nat
      -- let w' = int as nat
      -- if ((n \ 2) = 0)
      -- let value' = `FBitV%%`_numberValue(w', (n / 2) as bits) as value

;; ../../../../spec-concrete/5.03-wellformed.watsup:5.1-7.20
relation Type_wf: `%|-%`(bound, typeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:74.1-75.22
   rule basetype: `%|-%`(bound, typeIR)
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:79.1-81.33
   rule tid: `%|-%`(bound, typeIR)
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(tid) = namedTypeIR
      -- if $in_set<tid>(tid, bound)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:83.1-86.30
   rule spectype: `%|-%`(bound, typeIR')
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(polyTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = namedTypeIR
      -- let typeIR = $specialize_typeDef(polyTypeDefIR as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if Type_wf: `%|-%`(bound, typeIR) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:105.1-108.30
   rule typedeftype: `%|-%`(bound, typeIR')
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `DefT%%`
      -- let `DefT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR
      -- if $nestable_typedef(typeIR)
      -- if Type_wf: `%|-%`(bound, typeIR) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:122.1-125.30
   rule newtype: `%|-%`(bound, typeIR')
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR
      -- if $nestable_new(typeIR)
      -- if Type_wf: `%|-%`(bound, typeIR) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:144.1-147.30
   rule listttype: `%|-%`(bound, typeIR')
      -- if typeIR' <: listTypeIR
      -- let `ListT%`_listTypeIR(typeIR) = typeIR' as listTypeIR
      -- if $nestable_list(typeIR)
      -- if Type_wf: `%|-%`(bound, typeIR) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:170.1-173.33
   rule tupletype: `%|-%`(bound, typeIR')
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR*{typeIR <- typeIR*}) = typeIR' as tupleTypeIR
      -- (if $nestable_tuple(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: `%|-%`(bound, typeIR) holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:185.1-188.30
   rule stacktype: `%|-%`(bound, typeIR')
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, _nat) = typeIR' as headerStackTypeIR
      -- if $nestable_headerstack(typeIR)
      -- if Type_wf: `%|-%`(bound, typeIR) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:211.1-215.33
   rule structtype: `%|-%`(bound, typeIR')
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR, id)*{id <- id*, typeIR <- typeIR*}) = typeIR' as structTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if $nestable_struct(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: `%|-%`(bound, typeIR) holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:248.1-252.33
   rule headertype: `%|-%`(bound, typeIR')
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR, id)*{id <- id*, typeIR <- typeIR*}) = typeIR' as headerTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if $nestable_header(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: `%|-%`(bound, typeIR) holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:265.1-269.33
   rule headeruniontype: `%|-%`(bound, typeIR')
      -- if typeIR' <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, `%%`_fieldTypeIR(typeIR, id)*{id <- id*, typeIR <- typeIR*}) = typeIR' as headerUnionTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if $nestable_headerunion(typeIR))*{typeIR <- typeIR*}
      -- (if Type_wf: `%|-%`(bound, typeIR) holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:271.1-273.28
   rule enumtype: `%|-%`(bound, typeIR)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(_tid, id*{id <- id*}) = enumTypeIR
      -- if $distinct_<id>(id*{id <- id*})

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:299.1-303.30
   rule serenumtype: `%|-%`(bound, typeIR')
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR, `%%`_valueFieldIR(id, _value)*{_value <- _value*, id <- id*}) = enumTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- if $nestable_serenum(typeIR)
      -- if Type_wf: `%|-%`(bound, typeIR) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:307.1-309.53
   rule externtype: `%|-%`(bound, typeIR)
      -- if typeIR <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(_tid, `{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(_rid, routineTypeDefIR)*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*})) = typeIR as externObjectTypeIR
      -- (if RoutineTypeDef_wf: `%|-%`(bound, routineTypeDefIR) holds)*{routineTypeDefIR <- routineTypeDefIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:311.1-313.50
   rule parsertype: `%|-%`(bound, typeIR)
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = typeIR as parserObjectTypeIR
      -- if ParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:315.1-317.50
   rule controltype: `%|-%`(bound, typeIR)
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = typeIR as controlObjectTypeIR
      -- if ParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:319.1-321.33
   rule packagetype: `%|-%`(bound, typeIR')
      -- if typeIR' <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(tid, typeIR*{typeIR <- typeIR*}) = typeIR' as packageObjectTypeIR
      -- (if Type_wf: `%|-%`(bound, typeIR) holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:323.1-326.30
   rule tabletype: `%|-%`(bound, typeIR')
      -- if typeIR' <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, typeIR) = typeIR' as tableObjectTypeIR
      -- let typeIR'' = $canon(typeIR)
      -- if typeIR'' <: tableTypeIR
      -- let tableTypeIR = typeIR'' as tableTypeIR
      -- if tableTypeIR matches `TableStructT%%`
      -- let `TableStructT%%`_tableTypeIR(_tid', _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = tableTypeIR
      -- if Type_wf: `%|-%`(bound, typeIR) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:330.1-331.20
   rule defaulttype: `%|-%`(bound, typeIR)
      -- if typeIR <: defaultTypeIR
      -- let defaultTypeIR = typeIR as defaultTypeIR
      -- if (defaultTypeIR = `DefaultT`_defaultTypeIR())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:333.1-335.33
   rule sequencetype: `%|-%`(bound, typeIR')
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR*{typeIR <- typeIR*}) = sequenceTypeIR
      -- (if Type_wf: `%|-%`(bound, typeIR) holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:337.1-339.33
   rule sequencedefaulttype: `%|-%`(bound, typeIR')
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR*{typeIR <- typeIR*}) = sequenceTypeIR
      -- (if Type_wf: `%|-%`(bound, typeIR) holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:341.1-344.33
   rule recordtype: `%|-%`(bound, typeIR')
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RecordT%`
      -- let `RecordT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR, id)*{id <- id*, typeIR <- typeIR*}) = recordTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if Type_wf: `%|-%`(bound, typeIR) holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:346.1-349.33
   rule recorddefaulttype: `%|-%`(bound, typeIR')
      -- if typeIR' <: recordTypeIR
      -- let recordTypeIR = typeIR' as recordTypeIR
      -- if recordTypeIR matches `RecordDefaultT%`
      -- let `RecordDefaultT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR, id)*{id <- id*, typeIR <- typeIR*}) = recordTypeIR
      -- if $distinct_<id>(id*{id <- id*})
      -- (if Type_wf: `%|-%`(bound, typeIR) holds)*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:351.1-352.26
   rule invalidtype: `%|-%`(bound, typeIR)
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = `InvalidHeaderT`_invalidHeaderTypeIR())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:407.1-410.30
   rule settype: `%|-%`(bound, typeIR')
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR) = typeIR' as setTypeIR
      -- if $nestable_set(typeIR)
      -- if Type_wf: `%|-%`(bound, typeIR) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:412.1-414.28
   rule tableenumtype: `%|-%`(bound, typeIR)
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TableEnumT%%`
      -- let `TableEnumT%%`_tableTypeIR(_tid, id*{id <- id*}) = tableTypeIR
      -- if $distinct_<id>(id*{id <- id*})

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:416.1-417.28
   rule tablestructtype: `%|-%`(bound, typeIR)
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TableStructT%%`
      -- let `TableStructT%%`_tableTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = tableTypeIR

;; ../../../../spec-concrete/5.03-wellformed.watsup:9.1-11.20
relation TypeDef_wf: `%|-%`(bound, typeDefIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:423.1-425.30
   rule mono: `%|-%`(bound, typeDefIR)
      -- if typeDefIR <: monoTypeDefIR
      -- let `MonoTD%`_monoTypeDefIR(typeIR) = typeDefIR as monoTypeDefIR
      -- if Type_wf: `%|-%`(bound, typeIR) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:427.1-432.36
   rule poly: `%|-%`(bound, typeDefIR)
      -- if typeDefIR <: polyTypeDefIR
      -- let `PolyTD%%%`_polyTypeDefIR(typeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) = typeDefIR as polyTypeDefIR
      -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
      -- let bound_inner = $union_set<tid>(bound, `{%}`_set<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}))
      -- if Type_wf: `%|-%`(bound_inner, typeIR) holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:13.1-15.20
relation ParameterType_wf: `%|-%`(bound, parameterTypeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:49.1-53.26
   rule default-none: `%|-%`(bound, `%%%%`_parameterTypeIR(direction, typeIR, _id, value?{value <- value?}))
      -- if value?{value <- value?} matches ()
      -- if Type_wf: `%|-%`(bound, typeIR) holds
      -- if ($is_extern_object_typeIR($canon(typeIR)) => (direction = `NO`_direction()))

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:55.1-60.26
   rule default-some: `%|-%`(bound, `%%%%`_parameterTypeIR(direction, typeIR, _id, value'?{value' <- value'?}))
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}
      -- if Type_wf: `%|-%`(bound, typeIR) holds
      -- if ((direction = `IN`_direction()) \/ (direction = `NO`_direction()))
      -- if ($is_extern_object_typeIR($canon(typeIR)) => (direction = `NO`_direction()))

;; ../../../../spec-concrete/5.03-wellformed.watsup:17.1-19.20
relation ParameterTypes_wf: `%|-%`(bound, parameterTypeIR*)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:62.1-66.51
   rule : `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- (let `%%%%`_parameterTypeIR(_direction, _typeIR, id, _value?{_value <- _value?}) = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
      -- if $distinct_<id>(id*{id <- id*})
      -- (if ParameterType_wf: `%|-%`(bound, parameterTypeIR) holds)*{parameterTypeIR <- parameterTypeIR*}

;; ../../../../spec-concrete/5.03-wellformed.watsup:21.1-23.20
relation RoutineType_wf: `%|-%`(bound, routineTypeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:440.1-443.34
   rule builtinfunction: `%|-%`(bound, routineTypeIR)
      -- if routineTypeIR matches `BuiltinFuncT%%`
      -- let `BuiltinFuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- if ParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- if Type_wf: `%|-%`(bound, typeIR_ret) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:458.1-463.34
   rule functiontype: `%|-%`(bound, routineTypeIR)
      -- if routineTypeIR matches `FuncT%%`
      -- let `FuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- if ParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- (let `%%%%`_parameterTypeIR(direction, typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_function(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: `%|-%`(bound, typeIR_ret) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:491.1-496.45
   rule actiontype: `%|-%`(bound, routineTypeIR)
      -- if routineTypeIR matches `ActionT%`
      -- let `ActionT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- if ParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- (let `%%%%`_parameterTypeIR(direction, typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- if $directionless_trailing(direction*{direction <- direction*})
      -- (if $nestable_action(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:514.1-519.34
   rule externfunctiontype: `%|-%`(bound, routineTypeIR)
      -- if routineTypeIR matches `ExternFuncT%%`
      -- let `ExternFuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- if ParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- (let `%%%%`_parameterTypeIR(direction, typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_externfunction(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: `%|-%`(bound, typeIR_ret) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:523.1-526.34
   rule builtinmethod: `%|-%`(bound, routineTypeIR)
      -- if routineTypeIR matches `BuiltinMethodT%%`
      -- let `BuiltinMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- if ParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- if Type_wf: `%|-%`(bound, typeIR_ret) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:544.1-549.34
   rule externmethod: `%|-%`(bound, routineTypeIR)
      -- if routineTypeIR matches `ExternMethodT%%`
      -- let `ExternMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- if ParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- (let `%%%%`_parameterTypeIR(direction, typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_externmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: `%|-%`(bound, typeIR_ret) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:567.1-572.34
   rule externabstractmethod: `%|-%`(bound, routineTypeIR)
      -- if routineTypeIR matches `ExternAbstractMethodT%%`
      -- let `ExternAbstractMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- if ParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- (let `%%%%`_parameterTypeIR(direction, typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_externabstractmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
      -- if Type_wf: `%|-%`(bound, typeIR_ret) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:590.1-594.56
   rule parserapplymethod: `%|-%`(bound, routineTypeIR)
      -- if routineTypeIR matches `ParserApplyMethodT%`
      -- let `ParserApplyMethodT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- if ParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- (let `%%%%`_parameterTypeIR(direction, typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_parserapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:611.1-615.57
   rule controlapplymethod: `%|-%`(bound, routineTypeIR)
      -- if routineTypeIR matches `ControlApplyMethodT%`
      -- let `ControlApplyMethodT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- if ParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- (let `%%%%`_parameterTypeIR(direction, typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_controlapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:617.1-618.48
   rule tableapplymethod: `%|-%`(bound, routineTypeIR)
      -- if routineTypeIR matches `TableApplyMethodT%`
      -- let `TableApplyMethodT%`_routineTypeIR(typeIR) = routineTypeIR
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TableStructT%%`
      -- let `TableStructT%%`_tableTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = tableTypeIR

;; ../../../../spec-concrete/5.03-wellformed.watsup:25.1-27.20
relation RoutineTypeDef_wf: `%|-%`(bound, routineTypeDefIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:624.1-626.44
   rule mono: `%|-%`(bound, routineTypeDefIR)
      -- if routineTypeDefIR <: monoRoutineTypeDefIR
      -- let `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) = routineTypeDefIR as monoRoutineTypeDefIR
      -- if RoutineType_wf: `%|-%`(bound, routineTypeIR) holds

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:628.1-633.50
   rule poly: `%|-%`(bound, routineTypeDefIR)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) = routineTypeDefIR as polyRoutineTypeDefIR
      -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
      -- let bound_inner = $union_set<tid>(bound, `{%}`_set<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}))
      -- if RoutineType_wf: `%|-%`(bound_inner, routineTypeIR) holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:29.1-31.20
relation ConstructorParameterType_wf: `%|-%`(bound, parameterTypeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:639.1-641.30
   rule : `%|-%`(bound, `%%%%`_parameterTypeIR(direction, typeIR, _id, _value?{_value <- _value?}))
      -- if direction matches `NO`
      -- if Type_wf: `%|-%`(bound, typeIR) holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:33.1-35.20
relation ConstructorParameterTypes_wf: `%|-%`(bound, parameterTypeIR*)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:643.1-647.62
   rule : `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- (let `%%%%`_parameterTypeIR(_direction, _typeIR, id, _value?{_value <- _value?}) = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
      -- if $distinct_<id>(id*{id <- id*})
      -- (if ConstructorParameterType_wf: `%|-%`(bound, parameterTypeIR) holds)*{parameterTypeIR <- parameterTypeIR*}

;; ../../../../spec-concrete/5.03-wellformed.watsup:37.1-39.20
relation ConstructorType_wf: `%|-%`(bound, constructorTypeIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:665.1-671.46
   rule externtype: `%|-%`(bound, `ConstructorT%%`_constructorTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_object))
      -- if ConstructorParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- if Type_wf: `%|-%`(bound, typeIR_object) holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(_tid, _map<rid, routineTypeDefIR>) = typeIR' as externObjectTypeIR
      -- (let `%%%%`_parameterTypeIR(_direction, typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_extern(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:684.1-690.46
   rule parsertype: `%|-%`(bound, `ConstructorT%%`_constructorTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_object))
      -- if ConstructorParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- if Type_wf: `%|-%`(bound, typeIR_object) holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR' as parserObjectTypeIR
      -- (let `%%%%`_parameterTypeIR(_direction, typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_parser(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:703.1-709.47
   rule controltype: `%|-%`(bound, `ConstructorT%%`_constructorTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_object))
      -- if ConstructorParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- if Type_wf: `%|-%`(bound, typeIR_object) holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR' as controlObjectTypeIR
      -- (let `%%%%`_parameterTypeIR(_direction, typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_control(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:720.1-726.47
   rule packagetype: `%|-%`(bound, `ConstructorT%%`_constructorTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_object))
      -- if ConstructorParameterTypes_wf: `%|-%`(bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) holds
      -- if Type_wf: `%|-%`(bound, typeIR_object) holds
      -- let typeIR' = $canon(typeIR_object)
      -- if typeIR' <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(_tid, _typeIR*{_typeIR <- _typeIR*}) = typeIR' as packageObjectTypeIR
      -- (let `%%%%`_parameterTypeIR(_direction, typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
      -- (if $nestable_constructor_package(typeIR))*{typeIR <- typeIR*}

;; ../../../../spec-concrete/5.03-wellformed.watsup:41.1-43.20
relation ConstructorTypeDef_wf: `%|-%`(bound, constructorTypeDefIR)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:732.1-738.58
   rule : `%|-%`(bound, `PolyTD%%%`_constructorTypeDefIR(constructorTypeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}))
      -- let `ConstructorT%%`_constructorTypeIR(_constructorParameterTypeIR*{_constructorParameterTypeIR <- _constructorParameterTypeIR*}, typeIR_object) = constructorTypeIR
      -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
      -- let bound_inner = $union_set<tid>(bound, `{%}`_set<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}))
      -- if ConstructorType_wf: `%|-%`(bound_inner, constructorTypeIR) holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:90.1-90.37
def $nestable_typedef(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:93.1-93.67
   clause 0(typeIR) = $nestable'_typedef($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:91.1-91.38
def $nestable'_typedef(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:94.1-94.37
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:95.1-95.36
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ErrT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:96.1-96.36
   clause 2(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:97.1-97.44
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:98.1-98.39
   clause 4(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:99.1-99.40
   clause 5(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:100.1-100.42
   clause 6(typeIR) = true
      -- if typeIR <: dataTypeIR
      -- let dataTypeIR = typeIR as dataTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:101.1-101.78
   clause 7(typeIR) = ~$is_table_object_typeIR(objectTypeIR as typeIR)
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:102.1-103.15
   clause 8(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:110.1-110.33
def $nestable_new(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:113.1-113.59
   clause 0(typeIR) = $nestable'_new($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:111.1-111.34
def $nestable'_new(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:114.1-114.33
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:115.1-115.35
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:116.1-116.35
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:117.1-117.35
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:118.1-118.36
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:119.1-120.15
   clause 5(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:129.1-129.34
def $nestable_list(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:132.1-132.61
   clause 0(typeIR) = $nestable'_list($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:130.1-130.35
def $nestable'_list(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:133.1-133.34
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:134.1-134.33
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ErrT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:135.1-135.39
   clause 2(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `MatchKindT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:136.1-136.33
   clause 3(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:137.1-137.41
   clause 4(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:138.1-138.36
   clause 5(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:139.1-139.37
   clause 6(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:140.1-140.39
   clause 7(typeIR) = true
      -- if typeIR <: dataTypeIR
      -- let dataTypeIR = typeIR as dataTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:141.1-142.15
   clause 8(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:149.1-149.35
def $nestable_tuple(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:152.1-152.63
   clause 0(typeIR) = $nestable'_tuple($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:150.1-150.36
def $nestable'_tuple(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:153.1-153.35
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:154.1-154.34
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ErrT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:155.1-155.37
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:156.1-156.37
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:157.1-157.37
   clause 4(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VBitT%`
      -- let `VBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:158.1-158.37
   clause 5(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:159.1-159.38
   clause 6(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:160.1-160.38
   clause 7(typeIR) = true
      -- if typeIR <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(_typeIR*{_typeIR <- _typeIR*}) = typeIR as tupleTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:161.1-161.51
   clause 8(typeIR') = true
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, _nat) = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:162.1-162.41
   clause 9(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as structTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:163.1-163.41
   clause 10(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:164.1-164.46
   clause 11(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:165.1-165.39
   clause 12(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(_tid, _id*{_id <- _id*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:166.1-166.42
   clause 13(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, _typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:167.1-168.15
   clause 14(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:175.1-175.41
def $nestable_headerstack(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:178.1-178.75
   clause 0(typeIR) = $nestable'_headerstack($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:176.1-176.42
def $nestable'_headerstack(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:179.1-179.43
   clause 0(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:180.1-180.47
   clause 1(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:181.1-181.52
   clause 2(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:182.1-183.15
   clause 3(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:190.1-190.36
def $nestable_struct(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:193.1-193.65
   clause 0(typeIR) = $nestable'_struct($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:191.1-191.37
def $nestable'_struct(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:194.1-194.36
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:195.1-195.35
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ErrT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:196.1-196.38
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:197.1-197.38
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:198.1-198.38
   clause 4(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VBitT%`
      -- let `VBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:199.1-199.38
   clause 5(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:200.1-200.39
   clause 6(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:201.1-201.39
   clause 7(typeIR) = true
      -- if typeIR <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(_typeIR*{_typeIR <- _typeIR*}) = typeIR as tupleTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:202.1-202.52
   clause 8(typeIR') = true
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, _nat) = typeIR' as headerStackTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:203.1-203.42
   clause 9(typeIR) = true
      -- if typeIR <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as structTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:204.1-204.42
   clause 10(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:205.1-205.47
   clause 11(typeIR) = true
      -- if typeIR <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:206.1-206.40
   clause 12(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(_tid, _id*{_id <- _id*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:207.1-207.43
   clause 13(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, _typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:208.1-209.15
   clause 14(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:217.1-217.36
def $nestable_header(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:222.1-222.65
   clause 0(typeIR) = $nestable'_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:218.1-218.37
def $nestable'_header(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:223.1-223.36
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:224.1-224.38
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:225.1-225.38
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:226.1-226.38
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `VBitT%`
      -- let `VBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:227.1-227.38
   clause 4(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:228.1-228.39
   clause 5(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:229.1-229.43
   clause 6(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, _typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:230.1-231.44
   clause 7(typeIR') = true
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as structTypeIR
      -- (if $nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:232.1-233.15
   clause 8(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:219.1-219.46
def $nestable_struct_in_header(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:235.1-236.48
   clause 0(typeIR) = $nestable'_struct_in_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:220.1-220.47
def $nestable'_struct_in_header(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:237.1-237.46
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:238.1-238.48
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:239.1-239.48
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:240.1-240.48
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:241.1-241.49
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:242.1-242.53
   clause 5(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, _typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:243.1-244.44
   clause 6(typeIR') = true
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR, _id)*{_id <- _id*, typeIR <- typeIR*}) = typeIR' as structTypeIR
      -- (if $nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:245.1-246.15
   clause 7(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:254.1-254.41
def $nestable_headerunion(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:257.1-258.43
   clause 0(typeIR) = $nestable'_headerunion($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:255.1-255.42
def $nestable'_headerunion(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:259.1-259.43
   clause 0(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:260.1-260.44
   clause 1(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:261.1-261.47
   clause 2(typeIR) = true
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:262.1-263.15
   clause 3(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:275.1-275.37
def $nestable_serenum(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:280.1-281.39
   clause 0(typeIR) = $nestable'_serenum($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:276.1-276.38
def $nestable'_serenum(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:282.1-282.39
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:283.1-283.39
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:284.1-284.39
   clause 2(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:285.1-286.37
   clause 3(typeIR') = $nestable_new_in_serenum(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:287.1-288.15
   clause 4(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:277.1-277.44
def $nestable_new_in_serenum(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:290.1-291.46
   clause 0(typeIR) = $nestable_new_in_serenum'($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:278.1-278.45
def $nestable_new_in_serenum'(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:292.1-292.46
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:293.1-293.46
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:294.1-294.46
   clause 2(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:295.1-295.47
   clause 3(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:296.1-297.15
   clause 4(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:354.1-354.33
def $nestable_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:361.1-361.59
   clause 0(typeIR) = $nestable'_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:355.1-355.34
def $nestable'_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:362.1-362.33
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:363.1-363.32
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ErrT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:364.1-364.35
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:365.1-365.35
   clause 3(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:366.1-366.35
   clause 4(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:367.1-367.36
   clause 5(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:368.1-369.40
   clause 6(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR*{typeIR <- typeIR*}) = typeIR' as tupleTypeIR
      -- (if $nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:370.1-370.37
   clause 7(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(_tid, _id*{_id <- _id*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:371.1-371.40
   clause 8(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, _typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:372.1-373.43
   clause 9(typeIR') = true
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR*{typeIR <- typeIR*}) = sequenceTypeIR
      -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:374.1-375.15
   clause 10(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:356.1-356.42
def $nestable_tuple_in_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:377.1-378.44
   clause 0(typeIR) = $nestable'_tuple_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:357.1-357.43
def $nestable'_tuple_in_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:379.1-379.42
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:380.1-380.44
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:381.1-381.44
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:382.1-382.44
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:383.1-383.45
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:384.1-385.40
   clause 5(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR*{typeIR <- typeIR*}) = typeIR' as tupleTypeIR
      -- (if $nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:386.1-386.46
   clause 6(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(_tid, _id*{_id <- _id*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:387.1-387.49
   clause 7(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, _typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:388.1-389.15
   clause 8(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:358.1-358.45
def $nestable_sequence_in_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:391.1-392.47
   clause 0(typeIR) = $nestable'_sequence_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:359.1-359.46
def $nestable'_sequence_in_set(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:393.1-393.45
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:394.1-394.47
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:395.1-395.47
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:396.1-396.47
   clause 3(typeIR) = true
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(_tid) = namedTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:397.1-397.48
   clause 4(typeIR) = true
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, _typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:398.1-399.43
   clause 5(typeIR') = true
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR*{typeIR <- typeIR*}) = typeIR' as tupleTypeIR
      -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:400.1-400.49
   clause 6(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(_tid, _id*{_id <- _id*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:401.1-401.52
   clause 7(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, _typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:402.1-403.43
   clause 8(typeIR') = true
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR*{typeIR <- typeIR*}) = sequenceTypeIR
      -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:404.1-405.15
   clause 9(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:445.1-445.49
def $nestable_function(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:448.1-449.51
   clause 0(direction, typeIR) = $nestable_function'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:446.1-446.50
def $nestable_function'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:450.1-451.25
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:452.1-453.25
   clause 1(direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:454.1-454.57
   clause 2(direction, typeIR) = false
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:455.1-456.15
   clause 3(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:465.1-465.47
def $directionless_trailing(direction*) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:468.1-469.65
   clause 0(direction*{direction <- direction*}) = $directionless_trailing'($rev_<direction>(direction*{direction <- direction*}), true)

;; ../../../../spec-concrete/5.03-wellformed.watsup:466.1-466.54
def $directionless_trailing'(direction*, bool) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:471.1-471.44
   clause 0(direction*{direction <- direction*}, _bool) = true
      -- if direction*{direction <- direction*} matches []

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:472.1-473.49
   clause 1(direction'*{direction' <- direction'*}, bool) = $directionless_trailing'(direction_t*{direction_t <- direction_t*}, true)
      -- if direction'*{direction' <- direction'*} matches _ :: _
      -- let direction :: direction_t*{direction_t <- direction_t*} = direction'*{direction' <- direction'*}
      -- if direction matches `NO`
      -- if (bool = true)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:474.1-474.64
   clause 2(direction'*{direction' <- direction'*}, bool) = false
      -- if direction'*{direction' <- direction'*} matches _ :: _
      -- let direction :: direction_t*{direction_t <- direction_t*} = direction'*{direction' <- direction'*}
      -- if direction matches `NO`
      -- if (bool = false)

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:475.1-477.27
   clause 3(direction*{direction <- direction*}, _bool) = $directionless_trailing'(direction_t*{direction_t <- direction_t*}, false)
      -- if direction*{direction <- direction*} matches _ :: _
      -- let direction_h :: direction_t*{direction_t <- direction_t*} = direction*{direction <- direction*}
      -- if (direction_h =/= `NO`_direction())

;; ../../../../spec-concrete/5.03-wellformed.watsup:479.1-479.47
def $nestable_action(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:482.1-483.49
   clause 0(direction, typeIR) = $nestable_action'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:480.1-480.48
def $nestable_action'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:484.1-485.25
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:486.1-486.39
   clause 1(_direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:487.1-487.47
   clause 2(_direction, typeIR) = false
      -- if typeIR <: objectTypeIR
      -- let objectTypeIR = typeIR as objectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:488.1-489.15
   clause 3(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:498.1-498.55
def $nestable_externfunction(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:501.1-502.57
   clause 0(direction, typeIR) = $nestable_externfunction'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:499.1-499.56
def $nestable_externfunction'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:503.1-504.25
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:505.1-506.25
   clause 1(direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:507.1-507.60
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:508.1-508.61
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:509.1-509.63
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(_tid, _typeIR*{_typeIR <- _typeIR*}) = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:510.1-510.61
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, _typeIR) = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:511.1-512.15
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:528.1-528.53
def $nestable_externmethod(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:531.1-532.55
   clause 0(direction, typeIR) = $nestable_externmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:529.1-529.54
def $nestable_externmethod'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:533.1-534.25
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:535.1-536.25
   clause 1(direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:537.1-537.58
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:538.1-538.59
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:539.1-539.61
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(_tid, _typeIR*{_typeIR <- _typeIR*}) = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:540.1-540.59
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, _typeIR) = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:541.1-542.15
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:551.1-551.61
def $nestable_externabstractmethod(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:554.1-555.63
   clause 0(direction, typeIR) = $nestable_externabstractmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:552.1-552.62
def $nestable_externabstractmethod'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:556.1-557.25
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:558.1-559.25
   clause 1(direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:560.1-560.66
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:561.1-561.67
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:562.1-562.69
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(_tid, _typeIR*{_typeIR <- _typeIR*}) = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:563.1-563.67
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, _typeIR) = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:564.1-565.15
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:574.1-574.58
def $nestable_parserapplymethod(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:577.1-578.60
   clause 0(direction, typeIR) = $nestable_parserapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:575.1-575.59
def $nestable_parserapplymethod'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:579.1-580.25
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:581.1-582.25
   clause 1(direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:583.1-583.63
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:584.1-584.64
   clause 3(direction, typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:585.1-585.66
   clause 4(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(_tid, _typeIR*{_typeIR <- _typeIR*}) = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:586.1-586.64
   clause 5(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, _typeIR) = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:587.1-588.15
   clause 6(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:596.1-596.59
def $nestable_controlapplymethod(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:599.1-600.61
   clause 0(direction, typeIR) = $nestable_controlapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:597.1-597.60
def $nestable_controlapplymethod'(direction, typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:601.1-602.25
   clause 0(direction, typeIR) = false
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `StrT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:603.1-604.25
   clause 1(direction, typeIR) = false
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if (direction =/= `NO`_direction())

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:605.1-605.64
   clause 2(direction, typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:606.1-606.67
   clause 3(direction, typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(_tid, _typeIR*{_typeIR <- _typeIR*}) = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:607.1-607.65
   clause 4(direction, typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, _typeIR) = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:608.1-609.15
   clause 5(_direction, _typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:653.1-653.48
def $nestable_constructor_extern(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:656.1-657.50
   clause 0(typeIR) = $nestable'_constructor_extern($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:654.1-654.49
def $nestable'_constructor_extern(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:658.1-658.53
   clause 0(typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:659.1-659.54
   clause 1(typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:660.1-660.56
   clause 2(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(_tid, _typeIR*{_typeIR <- _typeIR*}) = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:661.1-661.54
   clause 3(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, _typeIR) = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:662.1-663.15
   clause 4(_typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:673.1-673.48
def $nestable_constructor_parser(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:676.1-677.50
   clause 0(typeIR) = $nestable'_constructor_parser($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:674.1-674.49
def $nestable'_constructor_parser(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:678.1-678.54
   clause 0(typeIR) = false
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:679.1-679.56
   clause 1(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(_tid, _typeIR*{_typeIR <- _typeIR*}) = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:680.1-680.54
   clause 2(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, _typeIR) = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:681.1-682.15
   clause 3(_typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:692.1-692.49
def $nestable_constructor_control(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:695.1-696.51
   clause 0(typeIR) = $nestable'_constructor_control($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:693.1-693.50
def $nestable'_constructor_control(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:697.1-697.54
   clause 0(typeIR) = false
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:698.1-698.57
   clause 1(typeIR) = false
      -- if typeIR <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(_tid, _typeIR*{_typeIR <- _typeIR*}) = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:699.1-699.55
   clause 2(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, _typeIR) = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:700.1-701.15
   clause 3(_typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:711.1-711.49
def $nestable_constructor_package(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:714.1-715.51
   clause 0(typeIR) = $nestable'_constructor_package($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:712.1-712.50
def $nestable'_constructor_package(typeIR) : bool =

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:716.1-716.55
   clause 0(typeIR) = false
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, _typeIR) = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.03-wellformed.watsup:717.1-718.15
   clause 1(_typeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.04-typing-relation.watsup:6.1-8.23
relation Eval_static: `%%|-%~>%`(cursor, typingContext, typedExpressionIR, value)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:15.1-16.40
   rule literalExpressionIR-boolE: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `BoolV%`_primitiveValue(b) as value)
      -- if expressionIR <: literalExpression
      -- let literalExpression = expressionIR as literalExpression
      -- if literalExpression matches `BoolE%`
      -- let `BoolE%`_literalExpression(b) = literalExpression

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:20.1-21.44
   rule literalExpressionIR-numE-arbint: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `IntV%`_numberValue(i) as value)
      -- if expressionIR <: literalExpression
      -- let literalExpression = expressionIR as literalExpression
      -- if literalExpression matches `NumE%`
      -- let `NumE%`_literalExpression(number) = literalExpression
      -- if number matches `INT%`
      -- let `INT%`_number(i) = number

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:23.1-24.50
   rule literalExpressionIR-numE-fixbit: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `FBitV%%`_numberValue(n, i) as value)
      -- if expressionIR <: literalExpression
      -- let literalExpression = expressionIR as literalExpression
      -- if literalExpression matches `NumE%`
      -- let `NumE%`_literalExpression(number) = literalExpression
      -- if number matches `FBIT%%`
      -- let `FBIT%%`_number(n, i) = number

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:26.1-27.50
   rule literalExpressionIR-numE-fixint: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `FIntV%%`_numberValue(n, i) as value)
      -- if expressionIR <: literalExpression
      -- let literalExpression = expressionIR as literalExpression
      -- if literalExpression matches `NumE%`
      -- let `NumE%`_literalExpression(number) = literalExpression
      -- if number matches `FINT%%`
      -- let `FINT%%`_number(n, i) = number

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:31.1-32.38
   rule literalExpressionIR-strE: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `StrV%`_primitiveValue(t) as value)
      -- if expressionIR <: literalExpression
      -- let literalExpression = expressionIR as literalExpression
      -- if literalExpression matches `StrE%`
      -- let `StrE%`_literalExpression(t) = literalExpression

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:37.1-39.49
   rule referenceExpression: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), value)
      -- if expressionIR <: referenceExpression
      -- let `NameE%`_referenceExpression(prefixedName) = expressionIR as referenceExpression
      -- let value'?{value' <- value'?} = $find_value(p, TC, prefixedName)
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:44.1-45.40
   rule defaultExpressionIR: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `DefaultV`_defaultValue() as value)
      -- if expressionIR <: defaultExpressionIR
      -- let defaultExpressionIR = expressionIR as defaultExpressionIR
      -- if (defaultExpressionIR = `DefaultE`_defaultExpressionIR())

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:50.1-52.53
   rule unaryExpressionIR-bnot: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $un_bnot(value))
      -- if expressionIR <: unaryExpressionIR
      -- let `UnE%%`_unaryExpressionIR(unop, typedExpressionIR) = expressionIR as unaryExpressionIR
      -- if unop matches `BNOT`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR, value)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:54.1-56.53
   rule unaryExpressionIR-lnot: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $un_lnot(value))
      -- if expressionIR <: unaryExpressionIR
      -- let `UnE%%`_unaryExpressionIR(unop, typedExpressionIR) = expressionIR as unaryExpressionIR
      -- if unop matches `LNOT`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR, value)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:58.1-60.53
   rule unaryExpressionIR-plus: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $un_plus(value))
      -- if expressionIR <: unaryExpressionIR
      -- let `UnE%%`_unaryExpressionIR(unop, typedExpressionIR) = expressionIR as unaryExpressionIR
      -- if unop matches `UPLUS`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR, value)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:62.1-64.53
   rule unaryExpressionIR-minus: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $un_minus(value))
      -- if expressionIR <: unaryExpressionIR
      -- let `UnE%%`_unaryExpressionIR(unop, typedExpressionIR) = expressionIR as unaryExpressionIR
      -- if unop matches `UMINUS`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR, value)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:70.1-74.57
   rule binaryExpressionIR-plus: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_plus(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `PLUS`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:76.1-80.57
   rule binaryExpressionIR-satplus: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_satplus(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `SPLUS`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:82.1-86.57
   rule binaryExpressionIR-minus: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_minus(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `MINUS`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:88.1-92.57
   rule binaryExpressionIR-satminus: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_satminus(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `SMINUS`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:94.1-98.57
   rule binaryExpressionIR-mul: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_mul(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `MUL`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:100.1-104.57
   rule binaryExpressionIR-div: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_div(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `DIV`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:106.1-110.57
   rule binaryExpressionIR-shl: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_shl(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `SHL`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:112.1-116.57
   rule binaryExpressionIR-shr: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_shr(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `SHR`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:118.1-122.57
   rule binaryExpressionIR-le: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `BoolV%`_primitiveValue($bin_le(value_l, value_r)) as value)
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `LE`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:124.1-128.57
   rule binaryExpressionIR-ge: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `BoolV%`_primitiveValue($bin_ge(value_l, value_r)) as value)
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `GE`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:130.1-134.57
   rule binaryExpressionIR-lt: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `BoolV%`_primitiveValue($bin_lt(value_l, value_r)) as value)
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `LT`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:136.1-140.57
   rule binaryExpressionIR-gt: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `BoolV%`_primitiveValue($bin_gt(value_l, value_r)) as value)
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `GT`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:142.1-146.57
   rule binaryExpressionIR-eq: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `BoolV%`_primitiveValue($bin_eq(value_l, value_r)) as value)
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `EQ`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:148.1-152.57
   rule binaryExpressionIR-ne: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `BoolV%`_primitiveValue($bin_ne(value_l, value_r)) as value)
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `NE`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:154.1-158.57
   rule binaryExpressionIR-band: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_band(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `BAND`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:160.1-164.57
   rule binaryExpressionIR-bxor: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_bxor(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `BXOR`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:166.1-170.57
   rule binaryExpressionIR-bor: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_bor(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `BOR`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:172.1-176.57
   rule binaryExpressionIR-concat: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_concat(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `CONCAT`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:178.1-182.57
   rule binaryExpressionIR-land: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_land(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `LAND`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:184.1-188.57
   rule binaryExpressionIR-lor: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bin_lor(value_l, value_r))
      -- if expressionIR <: binaryExpressionIR
      -- let `BinE%%%`_binaryExpressionIR(typedExpressionIR_l, binop, typedExpressionIR_r) = expressionIR as binaryExpressionIR
      -- if binop matches `LOR`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_l, value_l)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r, value_r)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:194.1-199.63
   rule ternaryExpressionIR-true: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), value_true)
      -- if expressionIR <: ternaryExpressionIR
      -- let `TernE%%%`_ternaryExpressionIR(typedExpressionIR_cond, typedExpressionIR_true, typedExpressionIR_false) = expressionIR as ternaryExpressionIR
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_cond, value)
      -- if (value = `BoolV%`_primitiveValue(true) as value)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_true, value_true)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:201.1-206.65
   rule ternaryExpressionIR-false: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), value_false)
      -- if expressionIR <: ternaryExpressionIR
      -- let `TernE%%%`_ternaryExpressionIR(typedExpressionIR_cond, typedExpressionIR_true, typedExpressionIR_false) = expressionIR as ternaryExpressionIR
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_cond, value)
      -- if (value = `BoolV%`_primitiveValue(false) as value)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_false, value_false)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:211.1-214.45
   rule castExpression: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), value_cast)
      -- if expressionIR <: castExpressionIR
      -- let `CastE%%`_castExpressionIR(typeIR, typedExpressionIR) = expressionIR as castExpressionIR
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR, value)
      -- let value_cast = $cast_op(typeIR, value)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:221.1-222.46
   rule dataExpressionIR-invalidE: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `InvalidHeaderV`_invalidHeaderValue() as value)
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `InvalidE`

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:226.1-228.56
   rule dataExpressionIR-seqE: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `SeqV%`_sequenceValue(value*{value <- value*}) as value)
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `SeqE%`
      -- let `SeqE%`_dataExpressionIR(typedExpressionIR*{typedExpressionIR <- typedExpressionIR*}) = dataExpressionIR
      -- (Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR, value))*{typedExpressionIR <- typedExpressionIR*, value <- value*}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:232.1-234.56
   rule dataExpressionIR-seqdefaultE: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `SeqDefaultV%`_sequenceValue(value*{value <- value*}) as value)
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `SeqDefaultE%`
      -- let `SeqDefaultE%`_dataExpressionIR(typedExpressionIR*{typedExpressionIR <- typedExpressionIR*}) = dataExpressionIR
      -- (Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR, value))*{typedExpressionIR <- typedExpressionIR*, value <- value*}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:238.1-241.56
   rule dataExpressionIR-recordE: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `RecordV%`_recordValue(`%%`_fieldValue(value, name)*{name <- name*, value <- value*}) as value)
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `RecordE%`
      -- let `RecordE%`_dataExpressionIR(`%%`_namedExpressionIR(name, typedExpressionIR)*{name <- name*, typedExpressionIR <- typedExpressionIR*}) = dataExpressionIR
      -- (Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR, value))*{typedExpressionIR <- typedExpressionIR*, value <- value*}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:245.1-248.56
   rule dataExpressionIR-recorddefaultE: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), `RecordDefaultV%`_recordValue(`%%`_fieldValue(value, name)*{name <- name*, value <- value*}) as value)
      -- if expressionIR <: dataExpressionIR
      -- let dataExpressionIR = expressionIR as dataExpressionIR
      -- if dataExpressionIR matches `RecordDefaultE%`
      -- let `RecordDefaultE%`_dataExpressionIR(`%%`_namedExpressionIR(name, typedExpressionIR)*{name <- name*, typedExpressionIR <- typedExpressionIR*}) = dataExpressionIR
      -- (Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR, value))*{typedExpressionIR <- typedExpressionIR*, value <- value*}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:256.1-259.61
   rule errorAccessExpressionIR: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), value_error)
      -- if expressionIR <: errorAccessExpression
      -- let `ErrAccE%`_errorAccessExpression(name) = expressionIR as errorAccessExpression
      -- let name_error = "error." ++ name
      -- let value?{value <- value?} = $find_value(p, TC, `CURRENT%`_prefixedName(name_error))
      -- if value?{value <- value?} matches (_)
      -- let ?(value_error) = value?{value <- value?}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:266.1-271.27
   rule memberAccessExpressionIR-typeaccE-enum: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)), `EnumV%%`_enumValue(tid, name) as value)
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessExpressionIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessExpressionIR matches `TypeAccE%%`
      -- let `TypeAccE%%`_memberAccessExpressionIR(prefixedName, name) = memberAccessExpressionIR
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedName)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: monoTypeDefIR
      -- let `MonoTD%`_monoTypeDefIR(typeIR) = typeDefIR as monoTypeDefIR
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(tid, id_member*{id_member <- id_member*}) = enumTypeIR
      -- if name <- id_member*{id_member <- id_member*}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:273.1-279.61
   rule memberAccessExpressionIR-typeaccE-senum: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)), `SEnumV%%%`_enumValue(tid, name, value) as value)
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessExpressionIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessExpressionIR matches `TypeAccE%%`
      -- let `TypeAccE%%`_memberAccessExpressionIR(prefixedName, name) = memberAccessExpressionIR
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedName)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: monoTypeDefIR
      -- let `MonoTD%`_monoTypeDefIR(typeIR') = typeDefIR as monoTypeDefIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(tid, typeIR, `%%`_valueFieldIR(id_member, value_member)*{id_member <- id_member*, value_member <- value_member*}) = enumTypeIR
      -- let value'?{value' <- value'?} = $assoc_<id, value>(name, (id_member, value_member)*{id_member <- id_member*, value_member <- value_member*})
      -- if value'?{value' <- value'?} matches (_)
      -- let ?(value) = value'?{value' <- value'?}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:283.1-286.44
   rule memberAccessExpressionIR-expraccE-headerstack: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)), `IntV%`_numberValue(n_size as int) as value)
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessExpressionIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessExpressionIR matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, text) = memberAccessExpressionIR
      -- if (text = "size")
      -- let typeIR = typeIR_base
      -- if typeIR <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(_typeIR, n_size) = typeIR as headerStackTypeIR

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:288.1-293.67
   rule memberAccessExpressionIR-expraccE-struct: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)), value)
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessExpressionIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessExpressionIR matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, name) = memberAccessExpressionIR
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_base, value_base)
      -- let value' = value_base
      -- if value' <: structValue
      -- let `StructV%%`_structValue(_tid, `%%`_fieldValue(value_field, id_field)*{id_field <- id_field*, value_field <- value_field*}) = value' as structValue
      -- let value''?{value'' <- value''?} = $assoc_<id, value>(name, (id_field, value_field)*{id_field <- id_field*, value_field <- value_field*})
      -- if value''?{value'' <- value''?} matches (_)
      -- let ?(value) = value''?{value'' <- value''?}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:295.1-300.67
   rule memberAccessExpressionIR-expraccE-header: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)), value)
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessExpressionIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessExpressionIR matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, name) = memberAccessExpressionIR
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_base, value_base)
      -- let value' = value_base
      -- if value' <: headerValue
      -- let `HeaderV%%%`_headerValue(_tid, _bool, `%%`_fieldValue(value_field, id_field)*{id_field <- id_field*, value_field <- value_field*}) = value' as headerValue
      -- let value''?{value'' <- value''?} = $assoc_<id, value>(name, (id_field, value_field)*{id_field <- id_field*, value_field <- value_field*})
      -- if value''?{value'' <- value''?} matches (_)
      -- let ?(value) = value''?{value'' <- value''?}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:302.1-307.67
   rule memberAccessExpressionIR-expraccE-headerunion: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)), value)
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessExpressionIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessExpressionIR matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, name) = memberAccessExpressionIR
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_base, value_base)
      -- let value' = value_base
      -- if value' <: headerUnionValue
      -- let `HeaderUnionV%%`_headerUnionValue(_tid, `%%`_fieldValue(value_field, id_field)*{id_field <- id_field*, value_field <- value_field*}) = value' as headerUnionValue
      -- let value''?{value'' <- value''?} = $assoc_<id, value>(name, (id_field, value_field)*{id_field <- id_field*, value_field <- value_field*})
      -- if value''?{value'' <- value''?} matches (_)
      -- let ?(value) = value''?{value'' <- value''?}

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:314.1-322.34
   rule indexAccessExpressionIR-arraccE-tuple: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), value)
      -- if expressionIR <: indexAccessExpressionIR
      -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
      -- if indexAccessExpressionIR matches `ArrAccE%%`
      -- let `ArrAccE%%`_indexAccessExpressionIR(typedExpressionIR_base, typedExpressionIR_index) = indexAccessExpressionIR
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_base, value_base)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_index, value_index)
      -- let value' = value_base
      -- if value' <: tupleValue
      -- let `TupleV%`_tupleValue(value_e*{value_e <- value_e*}) = value' as tupleValue
      -- let int'?{int' <- int'?} = $to_number(value_index)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < |value_e*{value_e <- value_e*}|)
      -- let value = value_e*{value_e <- value_e*}[n_index]

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:324.1-332.34
   rule indexAccessExpressionIR-arraccE-stack: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), value)
      -- if expressionIR <: indexAccessExpressionIR
      -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
      -- if indexAccessExpressionIR matches `ArrAccE%%`
      -- let `ArrAccE%%`_indexAccessExpressionIR(typedExpressionIR_base, typedExpressionIR_index) = indexAccessExpressionIR
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_base, value_base)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_index, value_index)
      -- let value' = value_base
      -- if value' <: headerStackValue
      -- let `HeaderStackV%%%`_headerStackValue(value_e*{value_e <- value_e*}, _nat, _nat') = value' as headerStackValue
      -- let int'?{int' <- int'?} = $to_number(value_index)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < |value_e*{value_e <- value_e*}|)
      -- let value = value_e*{value_e <- value_e*}[n_index]

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:336.1-342.59
   rule indexAccessExpressionIR-bitaccE: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $bitacc_op(value_base, value_hi, value_lo))
      -- if expressionIR <: indexAccessExpressionIR
      -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
      -- if indexAccessExpressionIR matches `BitAccE%%%`
      -- let `BitAccE%%%`_indexAccessExpressionIR(typedExpressionIR_base, typedExpressionIR_hi, typedExpressionIR_lo) = indexAccessExpressionIR
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_base, value_base)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_hi, value_hi)
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_lo, value_lo)

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:355.1-360.54
   rule callExpressionIR-methodT-size: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $sizeof(typeIR_base, name))
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `CallE%%%`
      -- let `CallE%%%`_callExpressionIR(routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}) = callExpressionIR
      -- if routineTargetIR matches `MethodT%%`
      -- let `MethodT%%`_routineTargetIR(typedExpressionIR_base, name) = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk')) = typedExpressionIR_base
      -- if name <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:364.1-369.54
   rule callExpressionIR-typeT-size-mono: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $sizeof(typeIR_base, name))
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `CallE%%%`
      -- let `CallE%%%`_callExpressionIR(routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}) = callExpressionIR
      -- if routineTargetIR matches `TypeT%%`
      -- let `TypeT%%`_routineTargetIR(prefixedName, name) = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedName)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: monoTypeDefIR
      -- let `MonoTD%`_monoTypeDefIR(typeIR_base) = typeDefIR as monoTypeDefIR
      -- if name <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:371.1-376.54
   rule callExpressionIR-typeT-size-poly: `%%|-%~>%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)), $sizeof(typeIR_base, name))
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `CallE%%%`
      -- let `CallE%%%`_callExpressionIR(routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}) = callExpressionIR
      -- if routineTargetIR matches `TypeT%%`
      -- let `TypeT%%`_routineTargetIR(prefixedName, name) = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedName)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let `PolyTD%%%`_polyTypeDefIR(typeIR_base, tid*{tid <- tid*}, tid'*{tid' <- tid'*}) = typeDefIR as polyTypeDefIR
      -- if tid*{tid <- tid*} matches []
      -- if tid'*{tid' <- tid'*} matches []
      -- if name <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

;; ../../../../spec-concrete/5.04-typing-relation.watsup:15.1-17.23
relation Type_ok: `%%|-%:%%`(cursor, typingContext, typeOrVoid, typeIR, tid*)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:11.1-12.28
   rule boolean: `%%|-%:%%`(p, TC, typeOrVoid, `BoolT`_primitiveTypeIR() as typeIR, [])
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `BoolT`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:16.1-17.26
   rule error: `%%|-%:%%`(p, TC, typeOrVoid, `ErrT`_primitiveTypeIR() as typeIR, [])
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `ErrT`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:21.1-22.38
   rule matchkind: `%%|-%:%%`(p, TC, typeOrVoid, `MatchKindT`_primitiveTypeIR() as typeIR, [])
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `MatchKindT`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:26.1-27.26
   rule string: `%%|-%:%%`(p, TC, typeOrVoid, `StrT`_primitiveTypeIR() as typeIR, [])
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `StrT`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:31.1-32.26
   rule arbint: `%%|-%:%%`(p, TC, typeOrVoid, `IntT`_numberTypeIR() as typeIR, [])
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `IntT`

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:36.1-42.17
   rule fixint-expr: `%%|-%:%%`(p, TC, typeOrVoid, `FIntT%`_numberTypeIR(n) as typeIR, [])
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `FIntT%`
      -- let `FIntT%`_baseType(expression) = baseType
      -- Expr_ok: `%%|-%:%`(p, TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(_typeIR, ctk)) = typedExpressionIR
      -- if ctk matches `LCTK`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR, value)
      -- let int'?{int' <- int'?} = $to_number(value)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n = int as nat
      -- if (n > 0)

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:46.1-51.30
   rule fixbit-expr: `%%|-%:%%`(p, TC, typeOrVoid, `FBitT%`_numberTypeIR(n) as typeIR, [])
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `FBitT%`
      -- let `FBitT%`_baseType(expression) = baseType
      -- Expr_ok: `%%|-%:%`(p, TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(_typeIR, ctk)) = typedExpressionIR
      -- if ctk matches `LCTK`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR, value)
      -- let int'?{int' <- int'?} = $to_number(value)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:55.1-60.30
   rule varbit-expr: `%%|-%:%%`(p, TC, typeOrVoid, `VBitT%`_numberTypeIR(n) as typeIR, [])
      -- if typeOrVoid <: baseType
      -- let baseType = typeOrVoid as baseType
      -- if baseType matches `VBitT%`
      -- let `VBitT%`_baseType(expression) = baseType
      -- Expr_ok: `%%|-%:%`(p, TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(_typeIR, ctk)) = typedExpressionIR
      -- if ctk matches `LCTK`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR, value)
      -- let int'?{int' <- int'?} = $to_number(value)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n = int as nat

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:68.1-70.56
   rule nameType-mono: `%%|-%:%%`(p, TC, typeOrVoid, typeIR, [])
      -- if typeOrVoid <: nameType
      -- let `NameT%`_nameType(prefixedName) = typeOrVoid as nameType
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedName)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: monoTypeDefIR
      -- let `MonoTD%`_monoTypeDefIR(typeIR) = typeDefIR as monoTypeDefIR

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:72.1-74.56
   rule nameType-poly: `%%|-%:%%`(p, TC, typeOrVoid, `SpecT%%`_namedTypeIR(polyTypeDefIR, []) as typeIR, [])
      -- if typeOrVoid <: nameType
      -- let `NameT%`_nameType(prefixedName) = typeOrVoid as nameType
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedName)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let polyTypeDefIR = typeDefIR as polyTypeDefIR

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:79.1-81.56
   rule specializedType-mono: `%%|-%:%%`(p, TC, typeOrVoid, typeIR, [])
      -- if typeOrVoid <: specializedType
      -- let `SpecT%%`_specializedType(prefixedName, typeArgument*{typeArgument <- typeArgument*}) = typeOrVoid as specializedType
      -- if typeArgument*{typeArgument <- typeArgument*} matches []
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedName)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: monoTypeDefIR
      -- let `MonoTD%`_monoTypeDefIR(typeIR) = typeDefIR as monoTypeDefIR

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:83.1-88.70
   rule specializedType-poly: `%%|-%:%%`(p, TC, typeOrVoid, `SpecT%%`_namedTypeIR(polyTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) as typeIR, tid_fresh*{tid_fresh <- tid_fresh*})
      -- if typeOrVoid <: specializedType
      -- let `SpecT%%`_specializedType(prefixedName, typeArgument*{typeArgument <- typeArgument*}) = typeOrVoid as specializedType
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedName)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let polyTypeDefIR = typeDefIR as polyTypeDefIR
      -- let `PolyTD%%%`_polyTypeDefIR(typeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) = polyTypeDefIR
      -- TypeArguments_ok: `%%|-%:%%`(p, TC, typeArgument*{typeArgument <- typeArgument*}, typeIR_arg*{typeIR_arg <- typeIR_arg*}, tid_fresh*{tid_fresh <- tid_fresh*})

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:93.1-105.58
   rule headerStackType-nameType-expression: `%%|-%:%%`(p, TC, typeOrVoid, `SpecT%%`_namedTypeIR(polyTypeDefIR_stack, [typeIR_base]) as typeIR, [])
      -- if typeOrVoid <: headerStackType
      -- let `HeaderStackT%%`_headerStackType(namedType, expression_size) = typeOrVoid as headerStackType
      -- if namedType <: nameType
      -- let nameType = namedType as nameType
      -- Type_ok: `%%|-%:%%`(p, TC, nameType as typeOrVoid, typeIR_base, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- Expr_ok: `%%|-%:%`(p, TC, expression_size, typedExpressionIR_size)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(_typeIR, ctk)) = typedExpressionIR_size
      -- if ctk matches `LCTK`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_size, value_size)
      -- let int'?{int' <- int'?} = $to_number(value_size)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n_size = int as nat
      -- let typeIR_stack = `HeaderStackT%%`_headerStackTypeIR(`NameT%`_namedTypeIR("T") as typeIR, n_size) as typeIR
      -- let polyTypeDefIR_stack = `PolyTD%%%`_polyTypeDefIR(typeIR_stack, ["T"], [])

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:107.1-119.58
   rule headerStackType-specializedType-expression: `%%|-%:%%`(p, TC, typeOrVoid, `SpecT%%`_namedTypeIR(polyTypeDefIR_stack, [typeIR_base]) as typeIR, tid_fresh*{tid_fresh <- tid_fresh*})
      -- if typeOrVoid <: headerStackType
      -- let `HeaderStackT%%`_headerStackType(namedType, expression_size) = typeOrVoid as headerStackType
      -- if namedType <: specializedType
      -- let specializedType = namedType as specializedType
      -- Type_ok: `%%|-%:%%`(p, TC, specializedType as typeOrVoid, typeIR_base, tid_fresh*{tid_fresh <- tid_fresh*})
      -- Expr_ok: `%%|-%:%`(p, TC, expression_size, typedExpressionIR_size)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(_typeIR, ctk)) = typedExpressionIR_size
      -- if ctk matches `LCTK`
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_size, value_size)
      -- let int'?{int' <- int'?} = $to_number(value_size)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n_size = int as nat
      -- let typeIR_stack = `HeaderStackT%%`_headerStackTypeIR(`NameT%`_namedTypeIR("T") as typeIR, n_size) as typeIR
      -- let polyTypeDefIR_stack = `PolyTD%%%`_polyTypeDefIR(typeIR_stack, ["T"], [])

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:124.1-131.56
   rule listType: `%%|-%:%%`(p, TC, typeOrVoid, `SpecT%%`_namedTypeIR(polyTypeDefIR_list, [typeIR_arg]) as typeIR, tid_fresh*{tid_fresh <- tid_fresh*})
      -- if typeOrVoid <: listType
      -- let `ListT%`_listType(typeArgument) = typeOrVoid as listType
      -- TypeArgument_ok: `%%|-%:%%`(p, TC, typeArgument, typeIR_arg, tid_fresh*{tid_fresh <- tid_fresh*})
      -- let typeIR_list = `ListT%`_listTypeIR(`NameT%`_namedTypeIR("T") as typeIR) as typeIR
      -- let polyTypeDefIR_list = `PolyTD%%%`_polyTypeDefIR(typeIR_list, ["T"], [])

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:136.1-145.66
   rule tupleType: `%%|-%:%%`(p, TC, typeOrVoid, `SpecT%%`_namedTypeIR(polyTypeDefIR_tuple, typeIR_arg*{typeIR_arg <- typeIR_arg*}) as typeIR, tid_fresh*{tid_fresh <- tid_fresh*})
      -- if typeOrVoid <: tupleType
      -- let `TupleT%`_tupleType(typeArgument*{typeArgument <- typeArgument*}) = typeOrVoid as tupleType
      -- TypeArguments_ok: `%%|-%:%%`(p, TC, typeArgument*{typeArgument <- typeArgument*}, typeIR_arg*{typeIR_arg <- typeIR_arg*}, tid_fresh*{tid_fresh <- tid_fresh*})
      -- let i_idx*{i_idx <- i_idx*} = $init_(|typeIR_arg*{typeIR_arg <- typeIR_arg*}|) as int*
      -- (let tid_tparam = "T" ++ $int_to_text(i_idx))*{i_idx <- i_idx*, tid_tparam <- tid_tparam*}
      -- let typeIR_tuple = `TupleT%`_tupleTypeIR(`NameT%`_namedTypeIR(tid_tparam) as typeIR*{tid_tparam <- tid_tparam*}) as typeIR
      -- let polyTypeDefIR_tuple = `PolyTD%%%`_polyTypeDefIR(typeIR_tuple, tid_tparam*{tid_tparam <- tid_tparam*}, [])

   ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:149.1-150.28
   rule void: `%%|-%:%%`(p, TC, typeOrVoid, `VoidT`_primitiveTypeIR() as typeIR, [])
      -- if typeOrVoid matches `VoidT`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:19.1-21.23
relation TypeArgument_ok: `%%|-%:%%`(cursor, typingContext, typeArgument, typeArgumentIR, tid*)

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:9.1-11.46
   rule type: `%%|-%:%%`(p, TC, typeArgument, typeIR, tid_impl*{tid_impl <- tid_impl*})
      -- if typeArgument <: type
      -- let type = typeArgument as type
      -- Type_ok: `%%|-%:%%`(p, TC, type as typeOrVoid, typeIR, tid_impl*{tid_impl <- tid_impl*})

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:15.1-16.28
   rule voidT: `%%|-%:%%`(p, TC, typeArgument, `VoidT`_primitiveTypeIR() as typeArgumentIR, [])
      -- if typeArgument matches `VoidT`

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:20.1-22.32
   rule anyT: `%%|-%:%%`(p, TC, typeArgument, `NameT%`_namedTypeIR(tid_impl) as typeArgumentIR, [tid_impl])
      -- if typeArgument matches `AnyT`
      -- let tid_impl = $fresh_tid

;; ../../../../spec-concrete/5.04-typing-relation.watsup:23.1-25.23
relation TypeArguments_ok: `%%|-%:%%`(cursor, typingContext, typeArgument*, typeArgumentIR*, tid*)

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:30.1-31.24
   rule : `%%|-%:%%`(p, TC, typeArgument*{typeArgument <- typeArgument*}, [], [])
      -- if typeArgument*{typeArgument <- typeArgument*} matches []

   ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:33.1-40.47
   rule : `%%|-%:%%`(p, TC, typeArgument*{typeArgument <- typeArgument*}, typeArgumentIR_h :: typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*}, tid_impl*{tid_impl <- tid_impl*})
      -- if typeArgument*{typeArgument <- typeArgument*} matches _ :: _
      -- let typeArgument_h :: typeArgument_t*{typeArgument_t <- typeArgument_t*} = typeArgument*{typeArgument <- typeArgument*}
      -- TypeArgument_ok: `%%|-%:%%`(p, TC, typeArgument_h, typeArgumentIR_h, tid_impl_h*{tid_impl_h <- tid_impl_h*})
      -- TypeArguments_ok: `%%|-%:%%`(p, TC, typeArgument_t*{typeArgument_t <- typeArgument_t*}, typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*}, tid_impl_t*{tid_impl_t <- tid_impl_t*})
      -- let tid_impl*{tid_impl <- tid_impl*} = tid_impl_h*{tid_impl_h <- tid_impl_h*} ++ tid_impl_t*{tid_impl_t <- tid_impl_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:31.1-31.54
relation Sub_expl: `%<:%`(typeIR, typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:5.1-9.54
   rule : `%<:%`(typeIR_a, typeIR_b)
      -- let typeIR_a_canon = $canon(typeIR_a)
      -- let typeIR_b_canon = $canon(typeIR_b)
      -- if Sub_expl_canon: `%<:%`(typeIR_a_canon, typeIR_b_canon) holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:32.1-32.60
relation Sub_expl_canon: `%<:%`(typeIR, typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:11.1-13.38
   rule equals: `%<:%`(typeIR_a, typeIR_b)
      -- if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:15.1-18.46
   rule not-equals: `%<:%`(typeIR_a, typeIR_b)
      -- if ~Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds
      -- if Sub_expl_canon_neq: `%<:%`(typeIR_a, typeIR_b) holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:33.1-33.64
relation Sub_expl_canon_neq: `%<:%`(typeIR, typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:20.1-21.19
   rule fixbit-boolean: `%<:%`(typeIR, typeIR')
      -- if (typeIR = `FBitT%`_numberTypeIR(1) as typeIR)
      -- if typeIR' <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR' as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:23.1-24.19
   rule boolean-fixbit: `%<:%`(typeIR, typeIR')
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`
      -- if (typeIR' = `FBitT%`_numberTypeIR(1) as typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:26.1-27.16
   rule arbint-boolean: `%<:%`(typeIR, typeIR')
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR' as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:29.1-30.18
   rule arbint-fixint: `%<:%`(typeIR, typeIR')
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR'

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:32.1-33.18
   rule arbint-fixbit: `%<:%`(typeIR, typeIR')
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR'

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:35.1-36.18
   rule fixint-fixint: `%<:%`(typeIR, typeIR')
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `IntT`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:38.1-39.25
   rule fixint-fixint: `%<:%`(typeIR, typeIR')
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w_a) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w_b) = numberTypeIR'

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:41.1-42.21
   rule fixint-fixbit: `%<:%`(typeIR, typeIR')
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:44.1-45.18
   rule fixbit-arbint: `%<:%`(typeIR, typeIR')
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `IntT`

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:47.1-48.21
   rule fixbit-fixint: `%<:%`(typeIR, typeIR')
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:50.1-51.25
   rule fixbit-fixbit: `%<:%`(typeIR, typeIR')
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w_a) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w_b) = numberTypeIR'

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:53.1-55.36
   rule newtype-left: `%<:%`(typeIR, typeIR_b)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR_a) = aliasTypeIR
      -- if Sub_impl: `%<:%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:57.1-59.36
   rule newtype-right: `%<:%`(typeIR_a, typeIR)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR_b) = aliasTypeIR
      -- if Sub_impl: `%<:%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:61.1-63.36
   rule serenum-left: `%<:%`(typeIR, typeIR_b)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR_a, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR
      -- if Sub_impl: `%<:%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:65.1-67.36
   rule serenum-right: `%<:%`(typeIR_a, typeIR)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR_b, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR
      -- if Sub_impl: `%<:%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:69.1-71.41
   rule default: `%<:%`(typeIR, typeIR_b)
      -- if typeIR <: defaultTypeIR
      -- let defaultTypeIR = typeIR as defaultTypeIR
      -- if (defaultTypeIR = `DefaultT`_defaultTypeIR())
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:73.1-74.32
   rule invalidheader-header: `%<:%`(typeIR, typeIR')
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = `InvalidHeaderT`_invalidHeaderTypeIR())
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:76.1-77.37
   rule invalidheader-headerunion: `%<:%`(typeIR, typeIR')
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = `InvalidHeaderT`_invalidHeaderTypeIR())
      -- if typeIR' <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR' as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:79.1-81.39
   rule seq-list: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: listTypeIR
      -- let `ListT%`_listTypeIR(typeIR_b) = typeIR' as listTypeIR
      -- (if Sub_expl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:83.1-85.39
   rule seq-tuple: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR_b*{typeIR_b <- typeIR_b*}) = typeIR' as tupleTypeIR
      -- (if Sub_expl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:87.1-90.39
   rule seq-stack: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR_b, n_size) = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)
      -- (if Sub_expl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:92.1-94.39
   rule seq-struct: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) = typeIR' as structTypeIR
      -- (if Sub_expl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:96.1-98.39
   rule seq-header: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) = typeIR' as headerTypeIR
      -- (if Sub_expl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:100.1-106.50
   rule seqdefault-tuple: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR_b*{typeIR_b <- typeIR_b*}) = typeIR' as tupleTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_expl: `%<:%`(typeIR_a, typeIR_b_non_default) holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:108.1-112.41
   rule seqdefault-stack: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR_b, n_size) = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)
      -- (if Sub_expl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*}
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:114.1-120.50
   rule seqdefault-struct: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) = typeIR' as structTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_expl: `%<:%`(typeIR_a, typeIR_b_non_default) holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:122.1-128.50
   rule seqdefault-header: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) = typeIR' as headerTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_expl: `%<:%`(typeIR_a, typeIR_b_non_default) holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:130.1-137.55
   rule record-struct: `%<:%`(typeIR, typeIR')
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordT%`
      -- let `RecordT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_a, id_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}) = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) = typeIR' as structTypeIR
      -- if $eq_set<id>(`{%}`_set<id>(id_a*{id_a <- id_a*}), `{%}`_set<id>(id_b*{id_b <- id_b*}))
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_a, typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_b, typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_expl: `%<:%`(typeIR_a_aligned, typeIR_b_aligned) holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:139.1-146.55
   rule record-header: `%<:%`(typeIR, typeIR')
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordT%`
      -- let `RecordT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_a, id_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}) = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) = typeIR' as headerTypeIR
      -- if $eq_set<id>(`{%}`_set<id>(id_a*{id_a <- id_a*}), `{%}`_set<id>(id_b*{id_b <- id_b*}))
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_a, typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_b, typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_expl: `%<:%`(typeIR_a_aligned, typeIR_b_aligned) holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:148.1-161.50
   rule recorddefault-struct: `%<:%`(typeIR, typeIR')
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordDefaultT%`
      -- let `RecordDefaultT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_a, id_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}) = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) = typeIR' as structTypeIR
      -- if $sub_set<id>(`{%}`_set<id>(id_a*{id_a <- id_a*}), `{%}`_set<id>(id_b*{id_b <- id_b*}))
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_a, typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_b, typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_expl: `%<:%`(typeIR_a_aligned, typeIR_b_non_default_aligned) holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let `{%}`_set<id>(id_default*{id_default <- id_default*}) = $diff_set<id>(`{%}`_set<id>(id_b*{id_b <- id_b*}), `{%}`_set<id>(id_a*{id_a <- id_a*}))
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_b, typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}), id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:163.1-176.50
   rule recorddefault-header: `%<:%`(typeIR, typeIR')
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordDefaultT%`
      -- let `RecordDefaultT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_a, id_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}) = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) = typeIR' as headerTypeIR
      -- if $sub_set<id>(`{%}`_set<id>(id_a*{id_a <- id_a*}), `{%}`_set<id>(id_b*{id_b <- id_b*}))
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_a, typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_b, typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_expl: `%<:%`(typeIR_a_aligned, typeIR_b_non_default_aligned) holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let `{%}`_set<id>(id_default*{id_default <- id_default*}) = $diff_set<id>(`{%}`_set<id>(id_b*{id_b <- id_b*}), `{%}`_set<id>(id_a*{id_a <- id_a*}))
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_b, typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}), id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:178.1-180.36
   rule set-set: `%<:%`(typeIR, typeIR')
      -- if typeIR <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR_a) = typeIR as setTypeIR
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR_b) = typeIR' as setTypeIR
      -- if Sub_expl: `%<:%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:182.1-185.36
   rule non-set-set: `%<:%`(typeIR_a, typeIR)
      -- if typeIR <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR_b) = typeIR as setTypeIR
      -- if ~$is_set_typeIR(typeIR_a)
      -- if Sub_expl: `%<:%`(typeIR_a, typeIR_b) holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:35.1-35.54
relation Sub_impl: `%<:%`(typeIR, typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:191.1-195.54
   rule : `%<:%`(typeIR_a, typeIR_b)
      -- let typeIR_a_canon = $canon(typeIR_a)
      -- let typeIR_b_canon = $canon(typeIR_b)
      -- if Sub_impl_canon: `%<:%`(typeIR_a_canon, typeIR_b_canon) holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:36.1-36.60
relation Sub_impl_canon: `%<:%`(typeIR, typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:197.1-199.38
   rule equals: `%<:%`(typeIR_a, typeIR_b)
      -- if Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:201.1-204.46
   rule not-equals: `%<:%`(typeIR_a, typeIR_b)
      -- if ~Type_alpha: `%~~%`(typeIR_a, typeIR_b) holds
      -- if Sub_impl_canon_neq: `%<:%`(typeIR_a, typeIR_b) holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:37.1-37.64
relation Sub_impl_canon_neq: `%<:%`(typeIR, typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:206.1-207.18
   rule arbint-fixint: `%<:%`(typeIR, typeIR')
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR'

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:209.1-210.18
   rule arbint-fixbit: `%<:%`(typeIR, typeIR')
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR'

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:212.1-214.36
   rule serenum-left: `%<:%`(typeIR, typeIR_b)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR_a, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR
      -- if Sub_impl: `%<:%`(typeIR_a, typeIR_b) holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:216.1-218.41
   rule default: `%<:%`(typeIR, typeIR_b)
      -- if typeIR <: defaultTypeIR
      -- let defaultTypeIR = typeIR as defaultTypeIR
      -- if (defaultTypeIR = `DefaultT`_defaultTypeIR())
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:220.1-221.32
   rule invalidheader-header: `%<:%`(typeIR, typeIR')
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = `InvalidHeaderT`_invalidHeaderTypeIR())
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR' as headerTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:223.1-224.37
   rule invalidheader-headerunion: `%<:%`(typeIR, typeIR')
      -- if typeIR <: invalidHeaderTypeIR
      -- let invalidHeaderTypeIR = typeIR as invalidHeaderTypeIR
      -- if (invalidHeaderTypeIR = `InvalidHeaderT`_invalidHeaderTypeIR())
      -- if typeIR' <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR' as headerUnionTypeIR

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:226.1-228.39
   rule seq-list: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: listTypeIR
      -- let `ListT%`_listTypeIR(typeIR_b) = typeIR' as listTypeIR
      -- (if Sub_impl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:230.1-232.39
   rule seq-tuple: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR_b*{typeIR_b <- typeIR_b*}) = typeIR' as tupleTypeIR
      -- (if Sub_impl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:234.1-237.39
   rule seq-stack: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR_b, n_size) = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)
      -- (if Sub_impl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:239.1-241.39
   rule seq-struct: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) = typeIR' as structTypeIR
      -- (if Sub_impl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:243.1-245.39
   rule seq-header: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) = typeIR' as headerTypeIR
      -- (if Sub_impl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:247.1-249.39
   rule seq-seq: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: sequenceTypeIR
      -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
      -- if sequenceTypeIR' matches `SeqT%`
      -- let `SeqT%`_sequenceTypeIR(typeIR_b*{typeIR_b <- typeIR_b*}) = sequenceTypeIR'
      -- (if Sub_impl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:251.1-257.50
   rule seqdefault-tuple: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR_b*{typeIR_b <- typeIR_b*}) = typeIR' as tupleTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_impl: `%<:%`(typeIR_a, typeIR_b_non_default) holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:259.1-263.41
   rule seqdefault-stack: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR_b, n_size) = typeIR' as headerStackTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)
      -- (if Sub_impl: `%<:%`(typeIR_a, typeIR_b) holds)*{typeIR_a <- typeIR_a*}
      -- if $is_defaultable_typeIR(typeIR_b)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:265.1-271.50
   rule seqdefault-struct: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) = typeIR' as structTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_impl: `%<:%`(typeIR_a, typeIR_b_non_default) holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:273.1-279.50
   rule seqdefault-header: `%<:%`(typeIR, typeIR')
      -- if typeIR <: sequenceTypeIR
      -- let sequenceTypeIR = typeIR as sequenceTypeIR
      -- if sequenceTypeIR matches `SeqDefaultT%`
      -- let `SeqDefaultT%`_sequenceTypeIR(typeIR_a*{typeIR_a <- typeIR_a*}) = sequenceTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) = typeIR' as headerTypeIR
      -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
      -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
      -- (if Sub_impl: `%<:%`(typeIR_a, typeIR_b_non_default) holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:281.1-288.55
   rule record-struct: `%<:%`(typeIR, typeIR')
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordT%`
      -- let `RecordT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_a, id_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}) = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) = typeIR' as structTypeIR
      -- if $eq_set<id>(`{%}`_set<id>(id_a*{id_a <- id_a*}), `{%}`_set<id>(id_b*{id_b <- id_b*}))
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_a, typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_b, typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_impl: `%<:%`(typeIR_a_aligned, typeIR_b_aligned) holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:290.1-297.55
   rule record-header: `%<:%`(typeIR, typeIR')
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordT%`
      -- let `RecordT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_a, id_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}) = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) = typeIR' as headerTypeIR
      -- if $eq_set<id>(`{%}`_set<id>(id_a*{id_a <- id_a*}), `{%}`_set<id>(id_b*{id_b <- id_b*}))
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_a, typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_b, typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
      -- (if Sub_impl: `%<:%`(typeIR_a_aligned, typeIR_b_aligned) holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:299.1-312.50
   rule recorddefault-struct: `%<:%`(typeIR, typeIR')
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordDefaultT%`
      -- let `RecordDefaultT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_a, id_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}) = recordTypeIR
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) = typeIR' as structTypeIR
      -- if $sub_set<id>(`{%}`_set<id>(id_a*{id_a <- id_a*}), `{%}`_set<id>(id_b*{id_b <- id_b*}))
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_a, typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_b, typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_impl: `%<:%`(typeIR_a_aligned, typeIR_b_non_default_aligned) holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let `{%}`_set<id>(id_default*{id_default <- id_default*}) = $diff_set<id>(`{%}`_set<id>(id_b*{id_b <- id_b*}), `{%}`_set<id>(id_a*{id_a <- id_a*}))
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_b, typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}), id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:314.1-327.50
   rule recorddefault-header: `%<:%`(typeIR, typeIR')
      -- if typeIR <: recordTypeIR
      -- let recordTypeIR = typeIR as recordTypeIR
      -- if recordTypeIR matches `RecordDefaultT%`
      -- let `RecordDefaultT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_a, id_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}) = recordTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR_b, id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) = typeIR' as headerTypeIR
      -- if $sub_set<id>(`{%}`_set<id>(id_a*{id_a <- id_a*}), `{%}`_set<id>(id_b*{id_b <- id_b*}))
      -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_a, typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
      -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
      -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
      -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_b, typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
      -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
      -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- (if Sub_impl: `%<:%`(typeIR_a_aligned, typeIR_b_non_default_aligned) holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
      -- let `{%}`_set<id>(id_default*{id_default <- id_default*}) = $diff_set<id>(`{%}`_set<id>(id_b*{id_b <- id_b*}), `{%}`_set<id>(id_a*{id_a <- id_a*}))
      -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>(`{%}`_set<pair<id, typeIR>>(`%->%`_pair<id, typeIR>(id_b, typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}), id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
      -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
      -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
      -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:43.1-45.23
relation Expr_ok: `%%|-%:%`(cursor, typingContext, expression, typedExpressionIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:12.1-14.43
   rule literalExpression-boolE: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BoolE%`_literalExpression(b) as expressionIR, expressionNoteIR))
      -- if expression <: literalExpression
      -- let literalExpression = expression as literalExpression
      -- if literalExpression matches `BoolE%`
      -- let `BoolE%`_literalExpression(b) = literalExpression
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(`BoolT`_primitiveTypeIR() as typeIR, `LCTK`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:18.1-20.42
   rule literalExpression-numE-arbint: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`NumE%`_literalExpression(`INT%`_number(i)) as expressionIR, expressionNoteIR))
      -- if expression <: literalExpression
      -- let literalExpression = expression as literalExpression
      -- if literalExpression matches `NumE%`
      -- let `NumE%`_literalExpression(number) = literalExpression
      -- if number matches `INT%`
      -- let `INT%`_number(i) = number
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(`IntT`_numberTypeIR() as typeIR, `LCTK`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:22.1-24.47
   rule literalExpression-numE-fixint: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`NumE%`_literalExpression(`FINT%%`_number(n, i)) as expressionIR, expressionNoteIR))
      -- if expression <: literalExpression
      -- let literalExpression = expression as literalExpression
      -- if literalExpression matches `NumE%`
      -- let `NumE%`_literalExpression(number) = literalExpression
      -- if number matches `FINT%%`
      -- let `FINT%%`_number(n, i) = number
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(`FIntT%`_numberTypeIR(n) as typeIR, `LCTK`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:26.1-28.47
   rule literalExpression-numE-fixbit: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`NumE%`_literalExpression(`FBIT%%`_number(n, i)) as expressionIR, expressionNoteIR))
      -- if expression <: literalExpression
      -- let literalExpression = expression as literalExpression
      -- if literalExpression matches `NumE%`
      -- let `NumE%`_literalExpression(number) = literalExpression
      -- if number matches `FBIT%%`
      -- let `FBIT%%`_number(n, i) = number
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(`FBitT%`_numberTypeIR(n) as typeIR, `LCTK`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:32.1-34.42
   rule literalExpression-strE: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`StrE%`_literalExpression(t) as expressionIR, expressionNoteIR))
      -- if expression <: literalExpression
      -- let literalExpression = expression as literalExpression
      -- if literalExpression matches `StrE%`
      -- let `StrE%`_literalExpression(t) = literalExpression
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(`StrT`_primitiveTypeIR() as typeIR, `LCTK`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:39.1-42.43
   rule referenceExpression: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`NameE%`_referenceExpression(prefixedName) as expressionIR, expressionNoteIR))
      -- if expression <: referenceExpression
      -- let `NameE%`_referenceExpression(prefixedName) = expression as referenceExpression
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedName)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(`%%%%`_varTypeIR(_direction, typeIR, ctk, _value?{_value <- _value?})) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, ctk)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:47.1-49.46
   rule defaultExpression: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`DefaultE`_defaultExpressionIR() as expressionIR, expressionNoteIR))
      -- if expression <: defaultExpression
      -- let defaultExpression = expression as defaultExpression
      -- if (defaultExpression = `DefaultE`_defaultExpression())
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(`DefaultT`_defaultTypeIR() as typeIR, `LCTK`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:65.1-75.55
   rule unaryExpression-lnot: `%%|-%:%`(p, TC, expression', `%%`_typedExpressionIR(`UnE%%`_unaryExpressionIR(`LNOT`_unop(), typedExpressionIR_reduced) as expressionIR, expressionNoteIR))
      -- if expression' <: unaryExpression
      -- let `UnE%%`_unaryExpression(unop, expression) = expression' as unaryExpression
      -- if unop matches `LNOT`
      -- Expr_ok: `%%|-%:%`(p, TC, expression, typedExpressionIR)
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_lnot)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let `%%`_typedExpressionIR(_expressionIR, expressionNoteIR) = typedExpressionIR_reduced

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:88.1-98.55
   rule unaryExpression-bnot: `%%|-%:%`(p, TC, expression', `%%`_typedExpressionIR(`UnE%%`_unaryExpressionIR(`BNOT`_unop(), typedExpressionIR_reduced) as expressionIR, expressionNoteIR))
      -- if expression' <: unaryExpression
      -- let `UnE%%`_unaryExpression(unop, expression) = expression' as unaryExpression
      -- if unop matches `BNOT`
      -- Expr_ok: `%%|-%:%`(p, TC, expression, typedExpressionIR)
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_bnot)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let `%%`_typedExpressionIR(_expressionIR, expressionNoteIR) = typedExpressionIR_reduced

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:112.1-123.55
   rule unaryExpression-uplusminus: `%%|-%:%`(p, TC, expression', `%%`_typedExpressionIR(`UnE%%`_unaryExpressionIR(unop, typedExpressionIR_reduced) as expressionIR, expressionNoteIR))
      -- if expression' <: unaryExpression
      -- let `UnE%%`_unaryExpression(unop, expression) = expression' as unaryExpression
      -- if ((unop = `UPLUS`_unop()) \/ (unop = `UMINUS`_unop()))
      -- Expr_ok: `%%|-%:%`(p, TC, expression, typedExpressionIR)
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_uplusminus)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let `%%`_typedExpressionIR(_expressionIR, expressionNoteIR) = typedExpressionIR_reduced

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:142.1-165.59
   rule binaryExpression-plusminusmult: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BinE%%%`_binaryExpressionIR(typedExpressionIR_l_reduced, binop, typedExpressionIR_r_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: binaryExpression
      -- let `BinE%%%`_binaryExpression(expression_l, binop, expression_r) = expression as binaryExpression
      -- if binop <- [`PLUS`_binop(), `MINUS`_binop(), `MUL`_binop()]
      -- Expr_ok: `%%|-%:%`(p, TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_plusminusmul)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_reduced, ctk_l_reduced)) = typedExpressionIR_l_reduced
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(_typeIR, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_reduced, ctk_reduced)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:179.1-202.59
   rule binaryExpression-satplusminus: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BinE%%%`_binaryExpressionIR(typedExpressionIR_l_reduced, binop, typedExpressionIR_r_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: binaryExpression
      -- let `BinE%%%`_binaryExpression(expression_l, binop, expression_r) = expression as binaryExpression
      -- if binop <- [`SPLUS`_binop(), `SMINUS`_binop()]
      -- Expr_ok: `%%|-%:%`(p, TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_satplusminus)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_reduced, ctk_l_reduced)) = typedExpressionIR_l_reduced
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(_typeIR, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_reduced, ctk_reduced)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:215.1-243.59
   rule binaryExpression-divmod-lctk: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BinE%%%`_binaryExpressionIR(typedExpressionIR_l_reduced, binop, typedExpressionIR_r_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: binaryExpression
      -- let `BinE%%%`_binaryExpression(expression_l, binop, expression_r) = expression as binaryExpression
      -- if binop <- [`DIV`_binop(), `MOD`_binop()]
      -- Expr_ok: `%%|-%:%`(p, TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_reduced, ctk_l_reduced)) = typedExpressionIR_l_reduced
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(_typeIR, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- if (ctk_r_reduced = `LCTK`_ctk())
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_r_reduced, value_r)
      -- let int'?{int' <- int'?} = $to_number(value_r)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n_r = int as nat
      -- if (n_r > 0)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_reduced, ctk_reduced)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:245.1-271.59
   rule binaryExpression-divmod-non-lctk: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BinE%%%`_binaryExpressionIR(typedExpressionIR_l_reduced, binop, typedExpressionIR_r_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: binaryExpression
      -- let `BinE%%%`_binaryExpression(expression_l, binop, expression_r) = expression as binaryExpression
      -- if binop <- [`DIV`_binop(), `MOD`_binop()]
      -- Expr_ok: `%%|-%:%`(p, TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_reduced, ctk_l_reduced)) = typedExpressionIR_l_reduced
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(_typeIR, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- if (ctk_r_reduced =/= `LCTK`_ctk())
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_reduced, ctk_reduced)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:292.1-315.61
   rule binaryExpression-shift-fixbit: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BinE%%%`_binaryExpressionIR(typedExpressionIR_l_reduced, binop, typedExpressionIR_r_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: binaryExpression
      -- let `BinE%%%`_binaryExpression(expression_l, binop, expression_r) = expression as binaryExpression
      -- if binop <- [`SHL`_binop(), `SHR`_binop()]
      -- Expr_ok: `%%|-%:%`(p, TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_l_reduced, ctk_l_reduced)) = typedExpressionIR_l_reduced
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_r_reduced, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- if $is_fixed_bit_typeIR(typeIR_r_reduced)
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_l_reduced, ctk_reduced)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:317.1-342.61
   rule binaryExpression-shift-integer: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BinE%%%`_binaryExpressionIR(typedExpressionIR_l_reduced, binop, typedExpressionIR_r_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: binaryExpression
      -- let `BinE%%%`_binaryExpression(expression_l, binop, expression_r) = expression as binaryExpression
      -- if binop <- [`SHL`_binop(), `SHR`_binop()]
      -- Expr_ok: `%%|-%:%`(p, TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_l_reduced, ctk_l_reduced)) = typedExpressionIR_l_reduced
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_r_reduced, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- if (ctk_r_reduced = `LCTK`_ctk())
      -- if ($is_arbitrary_int_typeIR(typeIR_r_reduced) \/ $is_fixed_int_typeIR(typeIR_r_reduced))
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_l_reduced, ctk_reduced)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:346.1-365.47
   rule binaryExpression-eq-ne: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BinE%%%`_binaryExpressionIR(typedExpressionIR_l_cast, binop, typedExpressionIR_r_cast) as expressionIR, expressionNoteIR))
      -- if expression <: binaryExpression
      -- let `BinE%%%`_binaryExpression(expression_l, binop, expression_r) = expression as binaryExpression
      -- if binop <- [`EQ`_binop(), `NE`_binop()]
      -- Expr_ok: `%%|-%:%`(p, TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_cast, ctk_l_cast)) = typedExpressionIR_l_cast
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(_typeIR, ctk_r_cast)) = typedExpressionIR_r_cast
      -- if $is_equalable_typeIR(typeIR_cast)
      -- let ctk_cast = $join_ctk(ctk_l_cast, ctk_r_cast)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(`BoolT`_primitiveTypeIR() as typeIR, ctk_cast)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:380.1-403.50
   rule binaryExpression-compare: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BinE%%%`_binaryExpressionIR(typedExpressionIR_l_reduced, binop, typedExpressionIR_r_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: binaryExpression
      -- let `BinE%%%`_binaryExpression(expression_l, binop, expression_r) = expression as binaryExpression
      -- if binop <- [`LE`_binop(), `GE`_binop(), `LT`_binop(), `GT`_binop()]
      -- Expr_ok: `%%|-%:%`(p, TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_compare)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_reduced, ctk_l_reduced)) = typedExpressionIR_l_reduced
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(_typeIR, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(`BoolT`_primitiveTypeIR() as typeIR, ctk_reduced)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:417.1-440.59
   rule binaryExpression-bitwise: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BinE%%%`_binaryExpressionIR(typedExpressionIR_l_reduced, binop, typedExpressionIR_r_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: binaryExpression
      -- let `BinE%%%`_binaryExpression(expression_l, binop, expression_r) = expression as binaryExpression
      -- if binop <- [`BAND`_binop(), `BXOR`_binop(), `BOR`_binop()]
      -- Expr_ok: `%%|-%:%`(p, TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_bitwise)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_reduced, ctk_l_reduced)) = typedExpressionIR_l_reduced
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(_typeIR, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_reduced, ctk_reduced)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:468.1-491.59
   rule binaryExpression-concat: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BinE%%%`_binaryExpressionIR(typedExpressionIR_l_reduced, `CONCAT`_binop(), typedExpressionIR_r_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: binaryExpression
      -- let `BinE%%%`_binaryExpression(expression_l, binop, expression_r) = expression as binaryExpression
      -- if binop matches `CONCAT`
      -- Expr_ok: `%%|-%:%`(p, TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_concat)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_l_reduced, ctk_l_reduced)) = typedExpressionIR_l_reduced
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_r_reduced, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- let typeIR?{typeIR <- typeIR?} = $result_concat(typeIR_l_reduced, typeIR_r_reduced)
      -- if typeIR?{typeIR <- typeIR?} matches (_)
      -- let ?(typeIR_reduced) = typeIR?{typeIR <- typeIR?}
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_reduced, ctk_reduced)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:504.1-527.59
   rule binaryExpression-logical: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BinE%%%`_binaryExpressionIR(typedExpressionIR_l_reduced, binop, typedExpressionIR_r_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: binaryExpression
      -- let `BinE%%%`_binaryExpression(expression_l, binop, expression_r) = expression as binaryExpression
      -- if binop <- [`LAND`_binop(), `LOR`_binop()]
      -- Expr_ok: `%%|-%:%`(p, TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_logical)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_reduced, ctk_l_reduced)) = typedExpressionIR_l_reduced
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(_typeIR, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_reduced, ctk_reduced)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:533.1-554.48
   rule ternaryExpression: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`TernE%%%`_ternaryExpressionIR(typedExpressionIR_cond, typedExpressionIR_true_cast, typedExpressionIR_false_cast) as expressionIR, expressionNoteIR))
      -- if expression <: ternaryExpression
      -- let `TernE%%%`_ternaryExpression(expression_cond, expression_true, expression_false) = expression as ternaryExpression
      -- Expr_ok: `%%|-%:%`(p, TC, expression_cond, typedExpressionIR_cond)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, ctk_cond)) = typedExpressionIR_cond
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`
      -- Expr_ok: `%%|-%:%`(p, TC, expression_true, typedExpressionIR_true)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_false, typedExpressionIR_false)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_true, typedExpressionIR_false)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_true_cast, typedExpressionIR_false_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_cast, ctk_true_cast)) = typedExpressionIR_true_cast
      -- let `%%`_typedExpressionIR(_expressionIR'', `(%%)`_expressionNoteIR(_typeIR, ctk_false_cast)) = typedExpressionIR_false_cast
      -- if ($is_arbitrary_int_typeIR(typeIR_cast) => (ctk_cond =/= `DYN`_ctk()))
      -- let ctk = $joins_ctk([ctk_cond, ctk_true_cast, ctk_false_cast])
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_cast, ctk)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:559.1-572.45
   rule castExpression: `%%|-%:%`(p, TC, expression', `%%`_typedExpressionIR(`CastE%%`_castExpressionIR(typeIR_t, typedExpressionIR) as expressionIR, expressionNoteIR))
      -- if expression' <: castExpression
      -- let `CastE%%`_castExpression(type_t, expression) = expression' as castExpression
      -- Type_ok: `%%|-%:%%`(p, TC, type_t as typeOrVoid, typeIR_t, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(p, TC), typeIR_t) holds
      -- Expr_ok: `%%|-%:%`(p, TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, ctk)) = typedExpressionIR
      -- if Sub_expl: `%<:%`(typeIR, typeIR_t) holds
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_t, ctk)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:579.1-581.52
   rule dataExpression-invalidE: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`InvalidE`_dataExpressionIR() as expressionIR, expressionNoteIR))
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `InvalidE`
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(`InvalidHeaderT`_invalidHeaderTypeIR() as typeIR, `LCTK`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:585.1-597.43
   rule dataExpression-seqE-no-default: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`SeqE%`_dataExpressionIR(typedExpressionIR_e*{typedExpressionIR_e <- typedExpressionIR_e*}) as expressionIR, expressionNoteIR))
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `SeqE%`
      -- let `SeqE%`_dataExpression(expression_e*{expression_e <- expression_e*}) = dataExpression
      -- if ~`DefaultE`_defaultExpression() as expression <- expression_e*{expression_e <- expression_e*}
      -- (Expr_ok: `%%|-%:%`(p, TC, expression_e, typedExpressionIR_e))*{expression_e <- expression_e*, typedExpressionIR_e <- typedExpressionIR_e*}
      -- (let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_e, ctk_e)) = typedExpressionIR_e)*{_expressionIR <- _expressionIR*, ctk_e <- ctk_e*, typeIR_e <- typeIR_e*, typedExpressionIR_e <- typedExpressionIR_e*}
      -- let typeIR = `SeqT%`_sequenceTypeIR(typeIR_e*{typeIR_e <- typeIR_e*}) as typeIR
      -- let ctk = $joins_ctk(ctk_e*{ctk_e <- ctk_e*})
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, ctk)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:599.1-614.43
   rule dataExpression-seqE-default: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`SeqDefaultE%`_dataExpressionIR(typedExpressionIR_e_h*{typedExpressionIR_e_h <- typedExpressionIR_e_h*}) as expressionIR, expressionNoteIR))
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `SeqE%`
      -- let `SeqE%`_dataExpression(expression_e*{expression_e <- expression_e*}) = dataExpression
      -- if `DefaultE`_defaultExpression() as expression <- expression_e*{expression_e <- expression_e*}
      -- let expression''*{expression'' <- expression''*} = $rev_<expression>(expression_e*{expression_e <- expression_e*})
      -- if expression''*{expression'' <- expression''*} matches _ :: _
      -- let expression' :: expression_e_h_rev*{expression_e_h_rev <- expression_e_h_rev*} = expression''*{expression'' <- expression''*}
      -- if expression' <: defaultExpression
      -- let defaultExpression = expression' as defaultExpression
      -- if (defaultExpression = `DefaultE`_defaultExpression())
      -- let expression_e_h*{expression_e_h <- expression_e_h*} = $rev_<expression>(expression_e_h_rev*{expression_e_h_rev <- expression_e_h_rev*})
      -- if ~`DefaultE`_defaultExpression() as expression <- expression_e_h*{expression_e_h <- expression_e_h*}
      -- (Expr_ok: `%%|-%:%`(p, TC, expression_e_h, typedExpressionIR_e_h))*{expression_e_h <- expression_e_h*, typedExpressionIR_e_h <- typedExpressionIR_e_h*}
      -- (let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_e_h, ctk_e_h)) = typedExpressionIR_e_h)*{_expressionIR <- _expressionIR*, ctk_e_h <- ctk_e_h*, typeIR_e_h <- typeIR_e_h*, typedExpressionIR_e_h <- typedExpressionIR_e_h*}
      -- let typeIR = `SeqDefaultT%`_sequenceTypeIR(typeIR_e_h*{typeIR_e_h <- typeIR_e_h*}) as typeIR
      -- let ctk = $joins_ctk(ctk_e_h*{ctk_e_h <- ctk_e_h*})
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, ctk)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:618.1-628.43
   rule dataExpression-recordE: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`RecordE%`_dataExpressionIR(`%%`_namedExpressionIR(name_f, typedExpressionIR_f)*{name_f <- name_f*, typedExpressionIR_f <- typedExpressionIR_f*}) as expressionIR, expressionNoteIR))
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `RecordE%`
      -- let `RecordE%`_dataExpression(`%%`_namedExpression(name_f, expression_f)*{expression_f <- expression_f*, name_f <- name_f*}) = dataExpression
      -- (Expr_ok: `%%|-%:%`(p, TC, expression_f, typedExpressionIR_f))*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- (let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_f, ctk_f)) = typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- let typeIR = `RecordT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_f, name_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}) as typeIR
      -- let ctk = $joins_ctk(ctk_f*{ctk_f <- ctk_f*})
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, ctk)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:632.1-642.43
   rule dataExpression-recorddefaultE: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`RecordDefaultE%`_dataExpressionIR(`%%`_namedExpressionIR(name_f, typedExpressionIR_f)*{name_f <- name_f*, typedExpressionIR_f <- typedExpressionIR_f*}) as expressionIR, expressionNoteIR))
      -- if expression <: dataExpression
      -- let dataExpression = expression as dataExpression
      -- if dataExpression matches `RecordDefaultE%`
      -- let `RecordDefaultE%`_dataExpression(`%%`_namedExpression(name_f, expression_f)*{expression_f <- expression_f*, name_f <- name_f*}) = dataExpression
      -- (Expr_ok: `%%|-%:%`(p, TC, expression_f, typedExpressionIR_f))*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- (let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_f, ctk_f)) = typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}
      -- let typeIR = `RecordDefaultT%`_recordTypeIR(`%%`_fieldTypeIR(typeIR_f, name_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}) as typeIR
      -- let ctk = $joins_ctk(ctk_f*{ctk_f <- ctk_f*})
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, ctk)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:650.1-656.42
   rule accessExpression-errorAccessExpression: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`ErrAccE%`_errorAccessExpression(name) as expressionIR, expressionNoteIR))
      -- if expression <: errorAccessExpression
      -- let `ErrAccE%`_errorAccessExpression(name) = expression as errorAccessExpression
      -- let name_error = "error." ++ name
      -- if (?(`ErrV%`_primitiveValue(name) as value) = $find_value(p, TC, `CURRENT%`_prefixedName(name_error)))
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(`ErrT`_primitiveTypeIR() as typeIR, `LCTK`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:663.1-673.49
   rule accessExpression-memberAccessExpression-typeaccE-enum: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`TypeAccE%%`_memberAccessExpressionIR(prefixedName_base, name) as expressionIR, expressionNoteIR))
      -- if expression <: memberAccessExpression
      -- let memberAccessExpression = expression as memberAccessExpression
      -- if memberAccessExpression matches `TypeAccE%%`
      -- let `TypeAccE%%`_memberAccessExpression(prefixedName_base, name) = memberAccessExpression
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedName_base)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: monoTypeDefIR
      -- let `MonoTD%`_monoTypeDefIR(typeIR_base) = typeDefIR as monoTypeDefIR
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(_tid, id_f*{id_f <- id_f*}) = enumTypeIR
      -- if name <- id_f*{id_f <- id_f*}
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_base, `LCTK`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:675.1-685.49
   rule accessExpression-memberAccessExpression-typeaccE-senum: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`TypeAccE%%`_memberAccessExpressionIR(prefixedName_base, name) as expressionIR, expressionNoteIR))
      -- if expression <: memberAccessExpression
      -- let memberAccessExpression = expression as memberAccessExpression
      -- if memberAccessExpression matches `TypeAccE%%`
      -- let `TypeAccE%%`_memberAccessExpression(prefixedName_base, name) = memberAccessExpression
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedName_base)
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: monoTypeDefIR
      -- let `MonoTD%`_monoTypeDefIR(typeIR_base) = typeDefIR as monoTypeDefIR
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, _typeIR, `%%`_valueFieldIR(id_f, _value)*{_value <- _value*, id_f <- id_f*}) = enumTypeIR
      -- if name <- id_f*{id_f <- id_f*}
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_base, `LCTK`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:689.1-699.48
   rule accessExpression-memberAccessExpression-expraccE-stack-size: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, "size") as expressionIR, expressionNoteIR))
      -- if expression <: memberAccessExpression
      -- let memberAccessExpression = expression as memberAccessExpression
      -- if memberAccessExpression matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpression(expression_base, text) = memberAccessExpression
      -- if (text = "size")
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n_size) = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(`FBitT%`_numberTypeIR(32) as typeIR, `LCTK`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:701.1-714.47
   rule accessExpression-memberAccessExpression-expraccE-stack-lastIndex: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, "lastIndex") as expressionIR, expressionNoteIR))
      -- if expression <: memberAccessExpression
      -- let memberAccessExpression = expression as memberAccessExpression
      -- if memberAccessExpression matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpression(expression_base, text) = memberAccessExpression
      -- if (text = "lastIndex")
      -- if (((p = `BLOCK`_cursor()) /\ $is_parser_blockKind(TC.BLOCK.KIND)) \/ ((p = `LOCAL`_cursor()) /\ $is_parser_state_localKind(TC.LOCAL.KIND)))
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n_size) = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(`FBitT%`_numberTypeIR(32) as typeIR, `DYN`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:716.1-729.43
   rule accessExpression-memberAccessExpression-expraccE-stack-last: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, "last") as expressionIR, expressionNoteIR))
      -- if expression <: memberAccessExpression
      -- let memberAccessExpression = expression as memberAccessExpression
      -- if memberAccessExpression matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpression(expression_base, text) = memberAccessExpression
      -- if (text = "last")
      -- if (((p = `BLOCK`_cursor()) /\ $is_parser_blockKind(TC.BLOCK.KIND)) \/ ((p = `LOCAL`_cursor()) /\ $is_parser_state_localKind(TC.LOCAL.KIND)))
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n_size) = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, `DYN`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:731.1-744.43
   rule accessExpression-memberAccessExpression-expraccE-stack-next: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, "next") as expressionIR, expressionNoteIR))
      -- if expression <: memberAccessExpression
      -- let memberAccessExpression = expression as memberAccessExpression
      -- if memberAccessExpression matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpression(expression_base, text) = memberAccessExpression
      -- if (text = "next")
      -- if (((p = `BLOCK`_cursor()) /\ $is_parser_blockKind(TC.BLOCK.KIND)) \/ ((p = `LOCAL`_cursor()) /\ $is_parser_state_localKind(TC.LOCAL.KIND)))
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n_size) = typeIR' as headerStackTypeIR
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, `DYN`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:746.1-758.48
   rule accessExpression-memberAccessExpression-expraccE-struct: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, name) as expressionIR, expressionNoteIR))
      -- if expression <: memberAccessExpression
      -- let memberAccessExpression = expression as memberAccessExpression
      -- if memberAccessExpression matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpression(expression_base, name) = memberAccessExpression
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, ctk_base)) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = typeIR' as structTypeIR
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<name, typeIR>(name, (id_f, typeIR_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, ctk_base)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:760.1-772.48
   rule accessExpression-memberAccessExpression-expraccE-header: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, name) as expressionIR, expressionNoteIR))
      -- if expression <: memberAccessExpression
      -- let memberAccessExpression = expression as memberAccessExpression
      -- if memberAccessExpression matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpression(expression_base, name) = memberAccessExpression
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, ctk_base)) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = typeIR' as headerTypeIR
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<name, typeIR>(name, (id_f, typeIR_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, ctk_base)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:774.1-786.48
   rule accessExpression-memberAccessExpression-expraccE-union: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, name) as expressionIR, expressionNoteIR))
      -- if expression <: memberAccessExpression
      -- let memberAccessExpression = expression as memberAccessExpression
      -- if memberAccessExpression matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpression(expression_base, name) = memberAccessExpression
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, ctk_base)) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, `%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = typeIR' as headerUnionTypeIR
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<name, typeIR>(name, (id_f, typeIR_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, ctk_base)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:788.1-800.43
   rule accessExpression-memberAccessExpression-expraccE-tablestruct: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, name) as expressionIR, expressionNoteIR))
      -- if expression <: memberAccessExpression
      -- let memberAccessExpression = expression as memberAccessExpression
      -- if memberAccessExpression matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpression(expression_base, name) = memberAccessExpression
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: tableTypeIR
      -- let tableTypeIR = typeIR' as tableTypeIR
      -- if tableTypeIR matches `TableStructT%%`
      -- let `TableStructT%%`_tableTypeIR(_tid, `%%`_fieldTypeIR(typeIR_f, id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) = tableTypeIR
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<name, typeIR>(name, (id_f, typeIR_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, `DYN`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:818.1-843.60
   rule indexAccessExpression-arraccE-tuple: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`ArrAccE%%`_indexAccessExpressionIR(typedExpressionIR_base, typedExpressionIR_index_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `ArrAccE%%`
      -- let `ArrAccE%%`_indexAccessExpression(expression_base, expression_index) = indexAccessExpression
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_index, typedExpressionIR_index)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, ctk_base)) = typedExpressionIR_base
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_index, ctk_index)) = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR_e*{typeIR_e <- typeIR_e*}) = typeIR as tupleTypeIR
      -- if (ctk_index = `LCTK`_ctk())
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_index_reduced, value_index)
      -- let int'?{int' <- int'?} = $to_number(value_index)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < |typeIR_e*{typeIR_e <- typeIR_e*}|)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_e*{typeIR_e <- typeIR_e*}[n_index], ctk_base)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:845.1-870.48
   rule indexAccessExpression-arraccE-stack-lctk: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`ArrAccE%%`_indexAccessExpressionIR(typedExpressionIR_base, typedExpressionIR_index_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `ArrAccE%%`
      -- let `ArrAccE%%`_indexAccessExpression(expression_base, expression_index) = indexAccessExpression
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_index, typedExpressionIR_index)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, ctk_base)) = typedExpressionIR_base
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_index, ctk_index)) = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n_size) = typeIR' as headerStackTypeIR
      -- if (ctk_index = `LCTK`_ctk())
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_index_reduced, value_index)
      -- let int'?{int' <- int'?} = $to_number(value_index)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < n_size)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, ctk_base)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:872.1-895.43
   rule indexAccessExpression-arraccE-stack-non-lctk: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`ArrAccE%%`_indexAccessExpressionIR(typedExpressionIR_base, typedExpressionIR_index_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `ArrAccE%%`
      -- let `ArrAccE%%`_indexAccessExpression(expression_base, expression_index) = indexAccessExpression
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_index, typedExpressionIR_index)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, ctk_base)) = typedExpressionIR_base
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_index, ctk_index)) = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n_size) = typeIR' as headerStackTypeIR
      -- if (ctk_index =/= `LCTK`_ctk())
      -- let ctk = $join_ctk(ctk_base, ctk_index)
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, ctk)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:936.1-984.56
   rule indexAccessExpression-bitaccE: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(`BitAccE%%%`_indexAccessExpressionIR(typedExpressionIR_base, typedExpressionIR_hi_reduced, typedExpressionIR_lo_reduced) as expressionIR, expressionNoteIR))
      -- if expression <: indexAccessExpression
      -- let indexAccessExpression = expression as indexAccessExpression
      -- if indexAccessExpression matches `BitAccE%%%`
      -- let `BitAccE%%%`_indexAccessExpression(expression_base, expression_hi, expression_lo) = indexAccessExpression
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_hi, typedExpressionIR_hi)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_lo, typedExpressionIR_lo)
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_base, $compat_bitslice_base)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_base_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base_reduced, ctk_base_reduced)) = typedExpressionIR_base_reduced
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_hi_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} = $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index)
      -- if typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} matches (_)
      -- let ?(typedExpressionIR_lo_reduced) = typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?}
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_hi_reduced, ctk_hi_reduced)) = typedExpressionIR_hi_reduced
      -- let `%%`_typedExpressionIR(_expressionIR'', `(%%)`_expressionNoteIR(typeIR_lo_reduced, ctk_lo_reduced)) = typedExpressionIR_lo_reduced
      -- if (ctk_hi_reduced = `LCTK`_ctk())
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_hi_reduced, value_hi)
      -- let int'?{int' <- int'?} = $to_number(value_hi)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n_hi = int as nat
      -- if (ctk_lo_reduced = `LCTK`_ctk())
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_lo_reduced, value_lo)
      -- let int'''?{int''' <- int'''?} = $to_number(value_lo)
      -- if int'''?{int''' <- int'''?} matches (_)
      -- let ?(int'') = int'''?{int''' <- int'''?}
      -- if int'' <: nat
      -- let n_lo = int'' as nat
      -- if $is_valid_bitslice(typeIR_base_reduced, n_lo, n_hi)
      -- let int'''' = ((n_hi - n_lo) + 1 as int)
      -- if int'''' <: nat
      -- let n' = int'''' as nat
      -- let typeIR = `FBitT%`_numberTypeIR(n') as typeIR
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR, ctk_base_reduced)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1003.1-1028.47
   rule callExpression-callE: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(callExpressionIR as expressionIR, expressionNoteIR))
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `CallE%%%`
      -- let `CallE%%%`_callExpression(routineTarget, typeArgument*{typeArgument <- typeArgument*}, argument*{argument <- argument*}) = callExpression
      -- RoutineTarget_ok: `%%|-%:%`(p, TC, routineTarget, routineTargetIR)
      -- TypeArguments_ok: `%%|-%:%%`(p, TC, typeArgument*{typeArgument <- typeArgument*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (Argument_ok: `%%|-%:%`(p, TC, argument, argumentIR))*{argument <- argument*, argumentIR <- argumentIR*}
      -- RoutineType_ok: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, routineTypeIR, tid_inserted*{tid_inserted <- tid_inserted*}, id_default*{id_default <- id_default*})
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Call_ok: `%%|-%%%%%:%%%`(p, TC, routineTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_infer*{tid_infer <- tid_infer*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_ret, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if (typeIR_ret =/= `VoidT`_primitiveTypeIR() as typeIR)
      -- let ctk = $is_static_routineTarget(routineTargetIR)
      -- let callExpressionIR = `CallE%%%`_callExpressionIR(routineTargetIR, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_ret, ctk)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1059.1-1076.50
   rule callExpression-instE-nameType: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(callExpressionIR as expressionIR, expressionNoteIR))
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `InstE%%`
      -- let `InstE%%`_callExpression(namedType, argument*{argument <- argument*}) = callExpression
      -- if namedType <: nameType
      -- let `NameT%`_nameType(prefixedName) = namedType as nameType
      -- (Argument_ok: `%%|-%:%`(p, TC, argument, argumentIR))*{argument <- argument*, argumentIR <- argumentIR*}
      -- ConstructorType_ok: `%%|-%%%:%%%`(p, TC, prefixedName, [], argumentIR*{argumentIR <- argumentIR*}, constructorTypeIR, tid_impl*{tid_impl <- tid_impl*}, id_default*{id_default <- id_default*})
      -- Inst_ok: `%%%|-%%%%%:%%%`(p, TC, `ANON`_instctxt(), constructorTypeIR, [], tid_impl*{tid_impl <- tid_impl*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_object, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if $is_concrete_extern_object(typeIR_object)
      -- let callExpressionIR = `InstE%%%`_callExpressionIR(prefixedName, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_object, `CTK`_ctk())

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1080.1-1101.50
   rule callExpression-instE-specializedType: `%%|-%:%`(p, TC, expression, `%%`_typedExpressionIR(callExpressionIR as expressionIR, expressionNoteIR))
      -- if expression <: callExpression
      -- let callExpression = expression as callExpression
      -- if callExpression matches `InstE%%`
      -- let `InstE%%`_callExpression(namedType, argument*{argument <- argument*}) = callExpression
      -- if namedType <: specializedType
      -- let `SpecT%%`_specializedType(prefixedName, typeArgument*{typeArgument <- typeArgument*}) = namedType as specializedType
      -- TypeArguments_ok: `%%|-%:%%`(p, TC, typeArgument*{typeArgument <- typeArgument*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (Argument_ok: `%%|-%:%`(p, TC, argument, argumentIR))*{argument <- argument*, argumentIR <- argumentIR*}
      -- ConstructorType_ok: `%%|-%%%:%%%`(p, TC, prefixedName, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, constructorTypeIR, tid_inserted*{tid_inserted <- tid_inserted*}, id_default*{id_default <- id_default*})
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Inst_ok: `%%%|-%%%%%:%%%`(p, TC, `ANON`_instctxt(), constructorTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_infer*{tid_infer <- tid_infer*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_object, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if $is_concrete_extern_object(typeIR_object)
      -- let callExpressionIR = `InstE%%%`_callExpressionIR(prefixedName, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let expressionNoteIR = `(%%)`_expressionNoteIR(typeIR_object, `CTK`_ctk())

;; ../../../../spec-concrete/5.04-typing-relation.watsup:51.1-53.23
relation Argument_ok: `%%|-%:%`(cursor, typingContext, argument, argumentIR)

   ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:9.1-11.53
   rule exprA: `%%|-%:%`(p, TC, argument, `ExprA%`_argumentIR(typedExpressionIR))
      -- if argument matches `ExprA%`
      -- let `ExprA%`_argument(expression) = argument
      -- Expr_ok: `%%|-%:%`(p, TC, expression, typedExpressionIR)

   ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:15.1-17.53
   rule nameA: `%%|-%:%`(p, TC, argument, `NameA%%`_argumentIR(name, typedExpressionIR))
      -- if argument matches `NameA%%`
      -- let `NameA%%`_argument(name, expression) = argument
      -- Expr_ok: `%%|-%:%`(p, TC, expression, typedExpressionIR)

   ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:21.1-22.40
   rule nameanyA: `%%|-%:%`(p, TC, argument, `NameAnyA%`_argumentIR(name))
      -- if argument matches `NameAnyA%`
      -- let `NameAnyA%`_argument(name) = argument

   ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:26.1-27.22
   rule anyA: `%%|-%:%`(p, TC, argument, `AnyA`_argumentIR())
      -- if argument matches `AnyA`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:59.1-61.23
relation Lvalue_ok: `%%|-%:%`(cursor, typingContext, lvalue, typedLvalueIR)

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:9.1-12.45
   rule nameL: `%%|-%:%`(p, TC, lvalue, `%%`_typedLvalueIR(`NameL%`_lvalueIR(prefixedName), `(%)`_lvalueNoteIR(typeIR)))
      -- if lvalue matches `NameL%`
      -- let `NameL%`_lvalue(prefixedName) = lvalue
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedName)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(`%%%%`_varTypeIR(direction, typeIR, ctk, value?{value <- value?})) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if ctk matches `DYN`
      -- if value?{value <- value?} matches ()
      -- if ((direction = `OUT`_direction()) \/ (direction = `INOUT`_direction()))

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:16.1-30.57
   rule lvalueaccL-stack-next-last: `%%|-%:%`(p, TC, lvalue, typedLvalueIR)
      -- if lvalue matches `LvalueAccL%%`
      -- let `LvalueAccL%%`_lvalue(lvalue_base, name) = lvalue
      -- Lvalue_ok: `%%|-%:%`(p, TC, lvalue_base, typedLvalueIR_base)
      -- let `%%`_typedLvalueIR(_lvalueIR, `(%)`_lvalueNoteIR(typeIR_base)) = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, _nat) = typeIR' as headerStackTypeIR
      -- if ((name = "next") \/ (name = "last"))
      -- if (((p = `BLOCK`_cursor()) /\ $is_parser_blockKind(TC.BLOCK.KIND)) \/ ((p = `LOCAL`_cursor()) /\ $is_parser_state_localKind(TC.LOCAL.KIND)))
      -- let typedLvalueIR = `%%`_typedLvalueIR(`LvalueAccL%%`_lvalueIR(typedLvalueIR_base, name), `(%)`_lvalueNoteIR(typeIR))

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:32.1-43.57
   rule lvalueaccL-struct: `%%|-%:%`(p, TC, lvalue, typedLvalueIR)
      -- if lvalue matches `LvalueAccL%%`
      -- let `LvalueAccL%%`_lvalue(lvalue_base, name) = lvalue
      -- Lvalue_ok: `%%|-%:%`(p, TC, lvalue_base, typedLvalueIR_base)
      -- let `%%`_typedLvalueIR(_lvalueIR, `(%)`_lvalueNoteIR(typeIR_base)) = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(_tid, `%%`_fieldTypeIR(typeIR_f, name_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}) = typeIR' as structTypeIR
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<name, typeIR>(name, (name_f, typeIR_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let typedLvalueIR = `%%`_typedLvalueIR(`LvalueAccL%%`_lvalueIR(typedLvalueIR_base, name), `(%)`_lvalueNoteIR(typeIR))

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:45.1-56.57
   rule lvalueaccL-header: `%%|-%:%`(p, TC, lvalue, typedLvalueIR)
      -- if lvalue matches `LvalueAccL%%`
      -- let `LvalueAccL%%`_lvalue(lvalue_base, name) = lvalue
      -- Lvalue_ok: `%%|-%:%`(p, TC, lvalue_base, typedLvalueIR_base)
      -- let `%%`_typedLvalueIR(_lvalueIR, `(%)`_lvalueNoteIR(typeIR_base)) = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, `%%`_fieldTypeIR(typeIR_f, name_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}) = typeIR' as headerTypeIR
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<name, typeIR>(name, (name_f, typeIR_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let typedLvalueIR = `%%`_typedLvalueIR(`LvalueAccL%%`_lvalueIR(typedLvalueIR_base, name), `(%)`_lvalueNoteIR(typeIR))

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:58.1-69.57
   rule lvalueaccL-union: `%%|-%:%`(p, TC, lvalue, typedLvalueIR)
      -- if lvalue matches `LvalueAccL%%`
      -- let `LvalueAccL%%`_lvalue(lvalue_base, name) = lvalue
      -- Lvalue_ok: `%%|-%:%`(p, TC, lvalue_base, typedLvalueIR_base)
      -- let `%%`_typedLvalueIR(_lvalueIR, `(%)`_lvalueNoteIR(typeIR_base)) = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, `%%`_fieldTypeIR(typeIR_f, name_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}) = typeIR' as headerUnionTypeIR
      -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<name, typeIR>(name, (name_f, typeIR_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*})
      -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
      -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
      -- let typedLvalueIR = `%%`_typedLvalueIR(`LvalueAccL%%`_lvalueIR(typedLvalueIR_base, name), `(%)`_lvalueNoteIR(typeIR))

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:73.1-98.22
   rule arraccL-stack-lctk: `%%|-%:%`(p, TC, lvalue, typedLvalueIR)
      -- if lvalue matches `ArrAccL%%`
      -- let `ArrAccL%%`_lvalue(lvalue_base, expression_index) = lvalue
      -- Lvalue_ok: `%%|-%:%`(p, TC, lvalue_base, typedLvalueIR_base)
      -- let `%%`_typedLvalueIR(_lvalueIR, `(%)`_lvalueNoteIR(typeIR_base)) = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n_size) = typeIR' as headerStackTypeIR
      -- Expr_ok: `%%|-%:%`(p, TC, expression_index, typedExpressionIR_index)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_index, ctk_index)) = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- if (ctk_index = `LCTK`_ctk())
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_index_reduced, value_index)
      -- let int'?{int' <- int'?} = $to_number(value_index)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n_index = int as nat
      -- if (n_index < n_size)
      -- let typedLvalueIR = `%%`_typedLvalueIR(`ArrAccL%%`_lvalueIR(typedLvalueIR_base, typedExpressionIR_index_reduced), `(%)`_lvalueNoteIR(typeIR))

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:100.1-122.22
   rule arraccL-stack-non-lctk: `%%|-%:%`(p, TC, lvalue, typedLvalueIR)
      -- if lvalue matches `ArrAccL%%`
      -- let `ArrAccL%%`_lvalue(lvalue_base, expression_index) = lvalue
      -- Lvalue_ok: `%%|-%:%`(p, TC, lvalue_base, typedLvalueIR_base)
      -- let `%%`_typedLvalueIR(_lvalueIR, `(%)`_lvalueNoteIR(typeIR_base)) = typedLvalueIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, n_size) = typeIR' as headerStackTypeIR
      -- Expr_ok: `%%|-%:%`(p, TC, expression_index, typedExpressionIR_index)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_index, ctk_index)) = typedExpressionIR_index
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- if (ctk_index =/= `LCTK`_ctk())
      -- let typedLvalueIR = `%%`_typedLvalueIR(`ArrAccL%%`_lvalueIR(typedLvalueIR_base, typedExpressionIR_index_reduced), `(%)`_lvalueNoteIR(typeIR))

   ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:126.1-168.22
   rule bitaccL: `%%|-%:%`(p, TC, lvalue, typedLvalueIR)
      -- if lvalue matches `BitAccL%%%`
      -- let `BitAccL%%%`_lvalue(lvalue_base, expression_hi, expression_lo) = lvalue
      -- Lvalue_ok: `%%|-%:%`(p, TC, lvalue_base, typedLvalueIR_base)
      -- let `%%`_typedLvalueIR(_lvalueIR, `(%)`_lvalueNoteIR(typeIR_base)) = typedLvalueIR_base
      -- if $compat_bitslice_base(typeIR_base)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_hi, typedExpressionIR_hi)
      -- Expr_ok: `%%|-%:%`(p, TC, expression_lo, typedExpressionIR_lo)
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_hi_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_lo_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_hi_reduced, ctk_hi_reduced)) = typedExpressionIR_hi_reduced
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_lo_reduced, ctk_lo_reduced)) = typedExpressionIR_lo_reduced
      -- if (ctk_hi_reduced = `LCTK`_ctk())
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_hi_reduced, value_hi)
      -- let int'?{int' <- int'?} = $to_number(value_hi)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n_hi = int as nat
      -- if (ctk_lo_reduced = `LCTK`_ctk())
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_lo_reduced, value_lo)
      -- let int'''?{int''' <- int'''?} = $to_number(value_lo)
      -- if int'''?{int''' <- int'''?} matches (_)
      -- let ?(int'') = int'''?{int''' <- int'''?}
      -- if int'' <: nat
      -- let n_lo = int'' as nat
      -- if $is_valid_bitslice(typeIR_base, n_lo, n_hi)
      -- let int'''' = ((n_hi - n_lo) + 1 as int)
      -- if int'''' <: nat
      -- let n' = int'''' as nat
      -- let typeIR = `FBitT%`_numberTypeIR(n') as typeIR
      -- let typedLvalueIR = `%%`_typedLvalueIR(`BitAccL%%%`_lvalueIR(typedLvalueIR_base, typedExpressionIR_hi_reduced, typedExpressionIR_lo_reduced), `(%)`_lvalueNoteIR(typeIR))

;; ../../../../spec-concrete/5.04-typing-relation.watsup:67.1-69.26
relation Stmt_ok: `%%%|-%:%%%`(cursor, typingContext, flow, statement, typingContext, flow, statementIR)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:10.1-11.33
   rule emptyStatement: `%%%|-%:%%%`(p, TC, f, statement, TC, f, `EmptyS`_emptyStatement() as statementIR)
      -- if statement <: emptyStatement
      -- let emptyStatement = statement as emptyStatement
      -- if (emptyStatement = `EmptyS`_emptyStatement())

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:16.1-28.76
   rule assignmentStatement: `%%%|-%:%%%`(p, TC, f, statement, TC, f, `AssignS%%`_assignmentStatementIR(typedLvalueIR, typedExpressionIR_cast) as statementIR)
      -- if statement <: assignmentStatement
      -- let `AssignS%%`_assignmentStatement(lvalue, expression) = statement as assignmentStatement
      -- Lvalue_ok: `%%|-%:%`(p, TC, lvalue, typedLvalueIR)
      -- Expr_ok: `%%|-%:%`(p, TC, expression, typedExpressionIR)
      -- let `%%`_typedLvalueIR(_lvalueIR, `(%)`_lvalueNoteIR(typeIR_l)) = typedLvalueIR
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_r, _ctk)) = typedExpressionIR
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR_l)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:33.1-52.72
   rule callStatement: `%%%|-%:%%%`(p, TC, f, statement, TC, f, callStatementIR as statementIR)
      -- if statement <: callStatement
      -- let `CallS%%%`_callStatement(lvalue_routine, typeArgument*{typeArgument <- typeArgument*}, argument*{argument <- argument*}) = statement as callStatement
      -- RoutineTarget_lvalue_ok: `%%|-%:%`(p, TC, lvalue_routine, routineTargetIR)
      -- TypeArguments_ok: `%%|-%:%%`(p, TC, typeArgument*{typeArgument <- typeArgument*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (Argument_ok: `%%|-%:%`(p, TC, argument, argumentIR))*{argument <- argument*, argumentIR <- argumentIR*}
      -- RoutineType_ok: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, routineTypeIR, tid_inserted*{tid_inserted <- tid_inserted*}, id_default*{id_default <- id_default*})
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Call_ok: `%%|-%%%%%:%%%`(p, TC, routineTypeIR, [], tid_infer*{tid_infer <- tid_infer*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_ret, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let callStatementIR = `CallS%%%`_callStatementIR(routineTargetIR, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:67.1-88.75
   rule directApplicationStatement: `%%%|-%:%%%`(p, TC_0, f, statement, TC_0, f, directApplicationStatementIR as statementIR)
      -- if statement <: directApplicationStatement
      -- let `InstS%%`_directApplicationStatement(namedType, argument*{argument <- argument*}) = statement as directApplicationStatement
      -- Expr_ok: `%%|-%:%`(p, TC_0, `InstE%%`_callExpression(namedType, []) as expression, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(typeIR_object, _ctk)))
      -- if expressionIR <: callExpressionIR
      -- let callExpressionIR = expressionIR as callExpressionIR
      -- if callExpressionIR matches `InstE%%%`
      -- let `InstE%%%`_callExpressionIR(prefixedName, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}) = callExpressionIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if $compat_direct_application(typeIR_object)
      -- let name_object = "__direct_application"
      -- let TC_1 = $add_var(p, TC_0, name_object, `%%%%`_varTypeIR(`NO`_direction(), typeIR_object, `CTK`_ctk(), ?()))
      -- let lvalue = `LvalueAccL%%`_lvalue(`NameL%`_lvalue(`CURRENT%`_prefixedName(name_object)), "apply")
      -- Stmt_ok: `%%%|-%:%%%`(p, TC_1, f, `CallS%%%`_callStatement(lvalue, [], argument*{argument <- argument*}) as statement, _typingContext, _flow, statementIR)
      -- if statementIR <: callStatementIR
      -- let callStatementIR = statementIR as callStatementIR
      -- let `CallS%%%`_callStatementIR(routineTargetIR, typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}) = callStatementIR
      -- if (routineTargetIR = `MethodT%%`_routineTargetIR(`%%`_typedExpressionIR(`NameE%`_referenceExpression(`CURRENT%`_prefixedName(name_object)) as expressionIR, `(%%)`_expressionNoteIR(typeIR_object, `CTK`_ctk())), "apply"))
      -- if typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} matches []
      -- let directApplicationStatementIR = `InstS%%`_directApplicationStatementIR(prefixedName, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:93.1-96.38
   rule returnStatement-none: `%%%|-%:%%%`(cursor, TC, f, statement, TC, `RET`_flow(), `ReturnS%`_returnStatementIR(?()) as statementIR)
      -- if cursor matches `LOCAL`
      -- if (statement = `ReturnS%`_returnStatement(?()) as statement)
      -- if (?(`VoidT`_primitiveTypeIR() as typeIR) = $find_return_type(TC))

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:98.1-109.78
   rule returnStatement-some: `%%%|-%:%%%`(cursor, TC, f, statement, TC, `RET`_flow(), `ReturnS%`_returnStatementIR(?(typedExpressionIR_cast)) as statementIR)
      -- if cursor matches `LOCAL`
      -- if statement <: returnStatement
      -- let `ReturnS%`_returnStatement(expression'?{expression' <- expression'?}) = statement as returnStatement
      -- if expression'?{expression' <- expression'?} matches (_)
      -- let ?(expression) = expression'?{expression' <- expression'?}
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, _ctk)) = typedExpressionIR
      -- let typeIR'?{typeIR' <- typeIR'?} = $find_return_type(TC)
      -- if typeIR'?{typeIR' <- typeIR'?} matches (_)
      -- let ?(typeIR_ret) = typeIR'?{typeIR' <- typeIR'?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR_ret)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:114.1-115.31
   rule exitStatement: `%%%|-%:%%%`(p, TC, f, statement, TC, f, `ExitS`_exitStatement() as statementIR)
      -- if statement <: exitStatement
      -- let exitStatement = statement as exitStatement
      -- if (exitStatement = `ExitS`_exitStatement())

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:119.1-122.53
   rule blockStatement: `%%%|-%:%%%`(cursor, TC_0, f_0, statement, TC_1, f_1, blockStatementIR as statementIR)
      -- if cursor matches `LOCAL`
      -- if statement <: blockStatement
      -- let blockStatement = statement as blockStatement
      -- Block_ok: `%%|-%:%%%`(TC_0, f_0, blockStatement, TC_1, f_1, blockStatementIR)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:127.1-136.73
   rule conditionalStatement-none: `%%%|-%:%%%`(p, TC, f, statement', TC, f, `IfS%%%`_conditionalStatementIR(typedExpressionIR_cond, statementIR_then, ?()) as statementIR)
      -- if statement' <: conditionalStatement
      -- let `IfS%%%`_conditionalStatement(expression_cond, statement_then, statement?{statement <- statement?}) = statement' as conditionalStatement
      -- if statement?{statement <- statement?} matches ()
      -- Expr_ok: `%%|-%:%`(p, TC, expression_cond, typedExpressionIR_cond)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, _ctk)) = typedExpressionIR_cond
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`
      -- Stmt_ok: `%%%|-%:%%%`(p, TC, f, statement_then, TC_then, f_then, statementIR_then)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:138.1-149.44
   rule conditionalStatement-some: `%%%|-%:%%%`(p, TC, f, statement', TC, f_post, `IfS%%%`_conditionalStatementIR(typedExpressionIR_cond, statementIR_then, ?(statementIR_else)) as statementIR)
      -- if statement' <: conditionalStatement
      -- let `IfS%%%`_conditionalStatement(expression_cond, statement_then, statement?{statement <- statement?}) = statement' as conditionalStatement
      -- if statement?{statement <- statement?} matches (_)
      -- let ?(statement_else) = statement?{statement <- statement?}
      -- Expr_ok: `%%|-%:%`(p, TC, expression_cond, typedExpressionIR_cond)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, _ctk)) = typedExpressionIR_cond
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`
      -- Stmt_ok: `%%%|-%:%%%`(p, TC, f, statement_then, TC_then, f_then, statementIR_then)
      -- Stmt_ok: `%%%|-%:%%%`(p, TC, f, statement_else, TC_else, f_else, statementIR_else)
      -- let f_post = $join_flow(f_then, f_else)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:229.1-245.55
   rule switch-table-apply: `%%%|-%:%%%`(cursor, TC, f, statement, TC, f_post, switchStatementIR as statementIR)
      -- if cursor matches `LOCAL`
      -- if statement <: switchStatement
      -- let `SwitchS%%`_switchStatement(expression_switch, switchCase*{switchCase <- switchCase*}) = statement as switchStatement
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_switch, typedExpressionIR_switch)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_switch, _ctk)) = typedExpressionIR_switch
      -- let typeIR = $canon(typeIR_switch)
      -- if typeIR <: tableTypeIR
      -- let tableTypeIR = typeIR as tableTypeIR
      -- if tableTypeIR matches `TableEnumT%%`
      -- let `TableEnumT%%`_tableTypeIR(tid_table_enum, _id*{_id <- _id*}) = tableTypeIR
      -- let tid_table = $strip_prefix($strip_suffix(tid_table_enum, ")"), "action_list(")
      -- SwitchCases_table_ok: `%%%|-%:%%%`(TC, f, tid_table, switchCase*{switchCase <- switchCase*}, f_post, switchCaseIR*{switchCaseIR <- switchCaseIR*}, switchLabel*{switchLabel <- switchLabel*})
      -- if $distinct_<switchLabel>(switchLabel*{switchLabel <- switchLabel*})
      -- let switchStatementIR = `SwitchS%%`_switchStatementIR(typedExpressionIR_switch, switchCaseIR*{switchCaseIR <- switchCaseIR*})

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:331.1-346.55
   rule switch-general: `%%%|-%:%%%`(cursor, TC, f, statement, TC, f_post, switchStatementIR as statementIR)
      -- if cursor matches `LOCAL`
      -- if statement <: switchStatement
      -- let `SwitchS%%`_switchStatement(expression_switch, switchCase*{switchCase <- switchCase*}) = statement as switchStatement
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_switch, typedExpressionIR_switch)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_switch, _ctk)) = typedExpressionIR_switch
      -- if $compat_switch(typeIR_switch)
      -- SwitchCases_general_ok: `%%%|-%:%%%`(TC, f, typeIR_switch, switchCase*{switchCase <- switchCase*}, f_post, switchCaseIR*{switchCaseIR <- switchCaseIR*}, switchLabel*{switchLabel <- switchLabel*})
      -- if $distinct_<switchLabel>(switchLabel*{switchLabel <- switchLabel*})
      -- let switchStatementIR = `SwitchS%%`_switchStatementIR(typedExpressionIR_switch, switchCaseIR*{switchCaseIR <- switchCaseIR*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:71.1-73.26
relation Stmts_ok: `%%%|-%:%%%`(cursor, typingContext, flow, statement*, typingContext, flow, statementIR*)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:75.1-78.23
relation BlockElementStmt_ok: `%%|-%:%%%`(typingContext, flow, blockElementStatement, typingContext, flow, blockElementStatementIR)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:354.1-356.77
   rule constantDeclaration: `%%|-%:%%%`(TC_0, f, blockElementStatement, TC_1, f, constantDeclarationIR as blockElementStatementIR)
      -- if blockElementStatement <: constantDeclaration
      -- let constantDeclaration = blockElementStatement as constantDeclaration
      -- Decl_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_0, constantDeclaration as declaration, TC_1, declarationIR)
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:361.1-372.53
   rule variableDeclaration-none: `%%|-%:%%%`(TC_0, f, blockElementStatement, TC_1, f, variableDeclarationIR as blockElementStatementIR)
      -- if blockElementStatement <: variableDeclaration
      -- let `VarD%%%`_variableDeclaration(type, name, initializer?{initializer <- initializer?}) = blockElementStatement as variableDeclaration
      -- if initializer?{initializer <- initializer?} matches ()
      -- Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`LOCAL`_cursor(), TC_0), typeIR) holds
      -- if $is_assignable_typeIR(typeIR)
      -- let TC_1 = $add_var(`LOCAL`_cursor(), TC_0, name, `%%%%`_varTypeIR(`INOUT`_direction(), typeIR, `DYN`_ctk(), ?()))
      -- let variableDeclarationIR = `VarD%%%`_variableDeclarationIR(typeIR, name, ?())

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:374.1-392.53
   rule variableDeclaration-some: `%%|-%:%%%`(TC_0, f, blockElementStatement, TC_1, f, variableDeclarationIR as blockElementStatementIR)
      -- if blockElementStatement <: variableDeclaration
      -- let `VarD%%%`_variableDeclaration(type, name, initializer?{initializer <- initializer?}) = blockElementStatement as variableDeclaration
      -- if initializer?{initializer <- initializer?} matches (_)
      -- let ?(expression_init) = initializer?{initializer <- initializer?}
      -- Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`LOCAL`_cursor(), TC_0), typeIR) holds
      -- if $is_assignable_typeIR(typeIR)
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC_0, expression_init, typedExpressionIR_init)
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let TC_1 = $add_var(`LOCAL`_cursor(), TC_0, name, `%%%%`_varTypeIR(`INOUT`_direction(), typeIR, `DYN`_ctk(), ?()))
      -- let variableDeclarationIR = `VarD%%%`_variableDeclarationIR(typeIR, name, ?(typedExpressionIR_init_cast))

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:396.1-398.66
   rule statement: `%%|-%:%%%`(TC_0, f, blockElementStatement, TC_1, f_post, statementIR as blockElementStatementIR)
      -- if blockElementStatement <: statement
      -- let statement = blockElementStatement as statement
      -- Stmt_ok: `%%%|-%:%%%`(`LOCAL`_cursor(), TC_0, f, statement, TC_1, f_post, statementIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:80.1-83.23
relation BlockElementStmts_ok: `%%|-%:%%%`(typingContext, flow, blockElementStatement*, typingContext, flow, blockElementStatementIR*)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:404.1-405.25
   rule nil: `%%|-%:%%%`(TC, f, blockElementStatement*{blockElementStatement <- blockElementStatement*}, TC, f, [])
      -- if blockElementStatement*{blockElementStatement <- blockElementStatement*} matches []

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:407.1-413.75
   rule cons: `%%|-%:%%%`(TC_0, f_0, blockElementStatement*{blockElementStatement <- blockElementStatement*}, TC_2, f_2, blockElementStatementIR_h :: blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*})
      -- if blockElementStatement*{blockElementStatement <- blockElementStatement*} matches _ :: _
      -- let blockElementStatement_h :: blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} = blockElementStatement*{blockElementStatement <- blockElementStatement*}
      -- BlockElementStmt_ok: `%%|-%:%%%`(TC_0, f_0, blockElementStatement_h, TC_1, f_1, blockElementStatementIR_h)
      -- BlockElementStmts_ok: `%%|-%:%%%`(TC_1, f_1, blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*}, TC_2, f_2, blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:85.1-88.23
relation Block_ok: `%%|-%:%%%`(typingContext, flow, blockStatement, typingContext, flow, blockStatementIR)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:421.1-430.59
   rule : `%%|-%:%%%`(TC_0, f, `BlockS%`_blockStatement(blockElementStatement*{blockElementStatement <- blockElementStatement*}), TC_3, f_post, blockStatementIR)
      -- let TC_1 = $enter(TC_0)
      -- BlockElementStmts_ok: `%%|-%:%%%`(TC_1, f, blockElementStatement*{blockElementStatement <- blockElementStatement*}, TC_2, f_post, blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*})
      -- let TC_3 = $exit(TC_2)
      -- let blockStatementIR = `BlockS%`_blockStatementIR(blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:95.1-97.23
relation Parameter_ok: `%%|-%:%%`(cursor, typingContext, parameter, parameterIR, tid*)

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:8.1-13.30
   rule none: `%%|-%:%%`(p, TC, `%%%%`_parameter(direction, type, name, initializer?{initializer <- initializer?}), `%%%%`_parameterIR(direction, typeIR, name, ?()), tid_fresh*{tid_fresh <- tid_fresh*})
      -- if initializer?{initializer <- initializer?} matches ()
      -- Type_ok: `%%|-%:%%`(p, TC, type as typeOrVoid, typeIR, tid_fresh*{tid_fresh <- tid_fresh*})
      -- let bound = $union_set<tid>($bound(p, TC), `{%}`_set<tid>(tid_fresh*{tid_fresh <- tid_fresh*}))
      -- if Type_wf: `%|-%`(bound, typeIR) holds

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:15.1-31.68
   rule some: `%%|-%:%%`(p, TC, `%%%%`_parameter(direction, type, name, initializer?{initializer <- initializer?}), `%%%%`_parameterIR(direction, typeIR, name, ?(value_init)), tid_fresh*{tid_fresh <- tid_fresh*})
      -- if initializer?{initializer <- initializer?} matches (_)
      -- let ?(expression_init) = initializer?{initializer <- initializer?}
      -- Type_ok: `%%|-%:%%`(p, TC, type as typeOrVoid, typeIR, tid_fresh*{tid_fresh <- tid_fresh*})
      -- let bound = $union_set<tid>($bound(p, TC), `{%}`_set<tid>(tid_fresh*{tid_fresh <- tid_fresh*}))
      -- if Type_wf: `%|-%`(bound, typeIR) holds
      -- Expr_ok: `%%|-%:%`(p, TC, expression_init, typedExpressionIR_init)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_init, ctk)) = typedExpressionIR_init
      -- if ctk matches `LCTK`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- Eval_static: `%%|-%~>%`(p, TC, typedExpressionIR_init_cast, value_init)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:99.1-101.23
relation Parameters_ok: `%%|-%:%%`(cursor, typingContext, parameter*, parameterIR*, tid*)

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:39.1-40.24
   rule nil: `%%|-%:%%`(p, TC, parameter*{parameter <- parameter*}, [], [])
      -- if parameter*{parameter <- parameter*} matches []

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:42.1-46.71
   rule cons: `%%|-%:%%`(p, TC, parameter*{parameter <- parameter*}, parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*}, tid_fresh_h*{tid_fresh_h <- tid_fresh_h*} ++ tid_fresh_t*{tid_fresh_t <- tid_fresh_t*})
      -- if parameter*{parameter <- parameter*} matches _ :: _
      -- let parameter_h :: parameter_t*{parameter_t <- parameter_t*} = parameter*{parameter <- parameter*}
      -- Parameter_ok: `%%|-%:%%`(p, TC, parameter_h, parameterIR_h, tid_fresh_h*{tid_fresh_h <- tid_fresh_h*})
      -- Parameters_ok: `%%|-%:%%`(p, TC, parameter_t*{parameter_t <- parameter_t*}, parameterIR_t*{parameterIR_t <- parameterIR_t*}, tid_fresh_t*{tid_fresh_t <- tid_fresh_t*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:103.1-103.48
def $parameterIR(parameterIR) : parameterTypeIR =

   ;; ../../../../spec-concrete/5.04-typing-relation.watsup:104.1-105.30
   clause 0(`%%%%`_parameterIR(direction, typeIR, name, constantInitializerIR?{constantInitializerIR <- constantInitializerIR?})) = `%%%%`_parameterTypeIR(direction, typeIR, name, ?())
      -- if constantInitializerIR?{constantInitializerIR <- constantInitializerIR?} matches ()

   ;; ../../../../spec-concrete/5.04-typing-relation.watsup:106.1-107.32
   clause 1(`%%%%`_parameterIR(direction, typeIR, name, constantInitializerIR?{constantInitializerIR <- constantInitializerIR?})) = `%%%%`_parameterTypeIR(direction, typeIR, name, ?(value))
      -- if constantInitializerIR?{constantInitializerIR <- constantInitializerIR?} matches (_)
      -- let ?(value) = constantInitializerIR?{constantInitializerIR <- constantInitializerIR?}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:109.1-112.23
relation ConstructorParameter_ok: `%%|-%:%%`(cursor, typingContext, constructorParameter, constructorParameterIR, tid*)

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:54.1-57.61
   rule : `%%|-%:%%`(p, TC, constructorParameter, constructorParameterIR, tid_fresh*{tid_fresh <- tid_fresh*})
      -- Parameter_ok: `%%|-%:%%`(p, TC, constructorParameter, constructorParameterIR, tid_fresh*{tid_fresh <- tid_fresh*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:114.1-117.23
relation ConstructorParameters_ok: `%%|-%:%%`(cursor, typingContext, constructorParameter*, constructorParameterIR*, tid*)

   ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:65.1-68.63
   rule : `%%|-%:%%`(p, TC, constructorParameter*{constructorParameter <- constructorParameter*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, tid_fresh*{tid_fresh <- tid_fresh*})
      -- Parameters_ok: `%%|-%:%%`(p, TC, constructorParameter*{constructorParameter <- constructorParameter*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, tid_fresh*{tid_fresh <- tid_fresh*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:119.1-119.81
def $constructorParameterIR(constructorParameterIR) : constructorParameterTypeIR =

   ;; ../../../../spec-concrete/5.04-typing-relation.watsup:120.1-121.41
   clause 0(constructorParameterIR) = $parameterIR(constructorParameterIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:127.1-129.23
relation ExternMethod_ok: `%%|-%:%%`(typingContext, tid, methodPrototype, typingContext, methodPrototypeIR)

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:9.1-34.65
   rule methodM: `%%|-%:%%`(TC_0, tid_extern, methodPrototype, TC_4, methodPrototypeIR)
      -- if methodPrototype matches `MethodM%%%%`
      -- let `MethodM%%%%`_methodPrototype(typeOrVoid, name, typeParameter*{typeParameter <- typeParameter*}, parameter*{parameter <- parameter*}) = methodPrototype
      -- if (name =/= tid_extern)
      -- (let tid_expl = typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(`LOCAL`_cursor(), TC_0, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_1, typeOrVoid, typeIR_ret, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- let TC_2 = TC_1[LOCAL.KIND = `EXTERNMETHOD%`_localKind(typeIR_ret)]
      -- Parameters_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_2, parameter*{parameter <- parameter*}, parameterIR*{parameterIR <- parameterIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_3 = $add_parameters(`LOCAL`_cursor(), TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let rid = $rid(name, parameter*{parameter <- parameter*})
      -- let routineTypeIR = `ExternMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret)
      -- let routineTypeDefIR = `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR
      -- if RoutineTypeDef_wf: `%|-%`($bound(`BLOCK`_cursor(), TC_0), routineTypeDefIR) holds
      -- let TC_4 = $add_routine_overload(`BLOCK`_cursor(), TC_0, rid, routineTypeDefIR)
      -- let methodPrototypeIR = `MethodM%%%%%`_methodPrototypeIR(typeIR_ret, name, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}, parameterIR*{parameterIR <- parameterIR*})

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:38.1-63.73
   rule abstractmethodM: `%%|-%:%%`(TC_0, tid_extern, methodPrototype, TC_4, methodPrototypeIR)
      -- if methodPrototype matches `AbstractMethodM%%%%`
      -- let `AbstractMethodM%%%%`_methodPrototype(typeOrVoid, name, typeParameter*{typeParameter <- typeParameter*}, parameter*{parameter <- parameter*}) = methodPrototype
      -- if (name =/= tid_extern)
      -- (let tid_expl = typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(`LOCAL`_cursor(), TC_0, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_1, typeOrVoid, typeIR_ret, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- let TC_2 = TC_1[LOCAL.KIND = `EXTERNABSTRACTMETHOD%`_localKind(typeIR_ret)]
      -- Parameters_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_2, parameter*{parameter <- parameter*}, parameterIR*{parameterIR <- parameterIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_3 = $add_parameters(`LOCAL`_cursor(), TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let rid = $rid(name, parameter*{parameter <- parameter*})
      -- let routineTypeIR = `ExternAbstractMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret)
      -- let routineTypeDefIR = `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR
      -- if RoutineTypeDef_wf: `%|-%`($bound(`BLOCK`_cursor(), TC_0), routineTypeDefIR) holds
      -- let TC_4 = $add_routine_non_overload(`BLOCK`_cursor(), TC_0, rid, routineTypeDefIR)
      -- let methodPrototypeIR = `AbstractMethodM%%%%%`_methodPrototypeIR(typeIR_ret, name, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}, parameterIR*{parameterIR <- parameterIR*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:131.1-133.23
relation ExternMethods_ok: `%%|-%:%%`(typingContext, tid, methodPrototype*, typingContext, methodPrototypeIR*)

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:71.1-72.32
   rule nil: `%%|-%:%%`(TC, tid_extern, methodPrototype*{methodPrototype <- methodPrototype*}, TC, [])
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:74.1-80.68
   rule cons: `%%|-%:%%`(TC_0, tid_extern, methodPrototype*{methodPrototype <- methodPrototype*}, TC_2, methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- ExternMethod_ok: `%%|-%:%%`(TC_0, tid_extern, methodPrototype_h, TC_1, methodPrototypeIR_h)
      -- ExternMethods_ok: `%%|-%:%%`(TC_1, tid_extern, methodPrototype_t*{methodPrototype_t <- methodPrototype_t*}, TC_2, methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:135.1-137.23
relation ExternConstructor_ok: `%%|-%:%%`(typingContext, tid, methodPrototype, typingContext, methodPrototypeIR)

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:90.1-116.53
   rule : `%%|-%:%%`(TC_0, tid_extern, methodPrototype, TC_1, methodPrototypeIR)
      -- if methodPrototype matches `ConsM%%`
      -- let `ConsM%%`_methodPrototype(name, constructorParameter*{constructorParameter <- constructorParameter*}) = methodPrototype
      -- if (name = tid_extern)
      -- ConstructorParameters_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_0, constructorParameter*{constructorParameter <- constructorParameter*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(`GLOBAL`_cursor(), TC_0, `CURRENT%`_prefixedName(name))
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let `PolyTD%%%`_polyTypeDefIR(typeIR_extern, tid_expl*{tid_expl <- tid_expl*}, tid*{tid <- tid*}) = typeDefIR as polyTypeDefIR
      -- if tid*{tid <- tid*} matches []
      -- let cid = $cid(name, constructorParameter*{constructorParameter <- constructorParameter*})
      -- let typeIR_extern_spec = `SpecT%%`_namedTypeIR(`PolyTD%%%`_polyTypeDefIR(typeIR_extern, tid_expl*{tid_expl <- tid_expl*}, []), `NameT%`_namedTypeIR(tid_expl) as typeIR*{tid_expl <- tid_expl*}) as typeIR
      -- let constructorTypeIR = `ConstructorT%%`_constructorTypeIR(constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*}, typeIR_extern_spec)
      -- let constructorTypeDefIR = `PolyTD%%%`_constructorTypeDefIR(constructorTypeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*})
      -- if ConstructorTypeDef_wf: `%|-%`($bound(`BLOCK`_cursor(), TC_0), constructorTypeDefIR) holds
      -- let TC_1 = $add_constructor(TC_0, cid, constructorTypeDefIR)
      -- let methodPrototypeIR = `ConsM%%%`_methodPrototypeIR(name, tid_impl*{tid_impl <- tid_impl*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:139.1-141.23
relation ExternConstructors_ok: `%%|-%:%%`(typingContext, tid, methodPrototype*, typingContext, methodPrototypeIR*)

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:124.1-125.32
   rule nil: `%%|-%:%%`(TC, tid_extern, methodPrototype*{methodPrototype <- methodPrototype*}, TC, [])
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

   ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:127.1-133.73
   rule cons: `%%|-%:%%`(TC_0, tid_extern, methodPrototype*{methodPrototype <- methodPrototype*}, TC_2, methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- ExternConstructor_ok: `%%|-%:%%`(TC_0, tid_extern, methodPrototype_h, TC_1, methodPrototypeIR_h)
      -- ExternConstructors_ok: `%%|-%:%%`(TC_1, tid_extern, methodPrototype_t*{methodPrototype_t <- methodPrototype_t*}, TC_2, methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:147.1-149.23
relation ParserTransition_ok: `%%|-%:%`(typingContext, name*, transitionStatement, transitionStatementIR)

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:9.1-15.52
   rule nameE: `%%|-%:%`(TC_0, name_state*{name_state <- name_state*}, `TransS%`_transitionStatement(stateExpression), transitionStatementIR)
      -- if stateExpression matches `NameE%`
      -- let `NameE%`_stateExpression(name) = stateExpression
      -- if name <- name_state*{name_state <- name_state*}
      -- let transitionStatementIR = `TransS%`_transitionStatementIR(?(`NameE%`_stateExpressionIR(name)))

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:197.1-209.62
   rule selectE: `%%|-%:%`(TC_0, name_state*{name_state <- name_state*}, `TransS%`_transitionStatement(stateExpression), transitionStatementIR)
      -- if stateExpression matches `SelectE%%`
      -- let `SelectE%%`_stateExpression(expression_key*{expression_key <- expression_key*}, selectCase*{selectCase <- selectCase*}) = stateExpression
      -- (Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC_0, expression_key, typedExpressionIR_key))*{expression_key <- expression_key*, typedExpressionIR_key <- typedExpressionIR_key*}
      -- (let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_key, _ctk)) = typedExpressionIR_key)*{_ctk <- _ctk*, _expressionIR <- _expressionIR*, typeIR_key <- typeIR_key*, typedExpressionIR_key <- typedExpressionIR_key*}
      -- (if Type_wf: `%|-%`($bound(`LOCAL`_cursor(), TC_0), `SetT%`_setTypeIR(typeIR_key) as typeIR) holds)*{typeIR_key <- typeIR_key*}
      -- (SelectCase_ok: `%%%|-%:%`(TC_0, name_state*{name_state <- name_state*}, typeIR_key*{typeIR_key <- typeIR_key*}, selectCase, selectCaseIR))*{selectCase <- selectCase*, selectCaseIR <- selectCaseIR*}
      -- let transitionStatementIR = `TransS%`_transitionStatementIR(?(`SelectE%%`_stateExpressionIR(typedExpressionIR_key*{typedExpressionIR_key <- typedExpressionIR_key*}, selectCaseIR*{selectCaseIR <- selectCaseIR*})))

;; ../../../../spec-concrete/5.04-typing-relation.watsup:151.1-153.20
relation ParserStmt_ok: `%|-%:%%`(typingContext, parserStatement, typingContext, parserStatementIR)

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:219.1-223.55
   rule constantDeclaration: `%|-%:%%`(TC_0, parserStatement, TC_1, constantDeclarationIR as parserStatementIR)
      -- if parserStatement <: constantDeclaration
      -- let constantDeclaration = parserStatement as constantDeclaration
      -- Decl_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_0, constantDeclaration as declaration, TC_1, declarationIR)
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:228.1-239.53
   rule variableDeclaration-none: `%|-%:%%`(TC_0, parserStatement, TC_1, variableDeclarationIR as parserStatementIR)
      -- if parserStatement <: variableDeclaration
      -- let `VarD%%%`_variableDeclaration(type, name, initializer?{initializer <- initializer?}) = parserStatement as variableDeclaration
      -- if initializer?{initializer <- initializer?} matches ()
      -- Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`LOCAL`_cursor(), TC_0), typeIR) holds
      -- if $is_assignable_typeIR(typeIR)
      -- let TC_1 = $add_var(`LOCAL`_cursor(), TC_0, name, `%%%%`_varTypeIR(`INOUT`_direction(), typeIR, `DYN`_ctk(), ?()))
      -- let variableDeclarationIR = `VarD%%%`_variableDeclarationIR(typeIR, name, ?())

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:241.1-259.53
   rule variableDeclaration-some: `%|-%:%%`(TC_0, parserStatement, TC_1, variableDeclarationIR as parserStatementIR)
      -- if parserStatement <: variableDeclaration
      -- let `VarD%%%`_variableDeclaration(type, name, initializer?{initializer <- initializer?}) = parserStatement as variableDeclaration
      -- if initializer?{initializer <- initializer?} matches (_)
      -- let ?(expression_init) = initializer?{initializer <- initializer?}
      -- Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`LOCAL`_cursor(), TC_0), typeIR) holds
      -- if $is_assignable_typeIR(typeIR)
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC_0, expression_init, typedExpressionIR_init)
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let TC_1 = $add_var(`LOCAL`_cursor(), TC_0, name, `%%%%`_varTypeIR(`INOUT`_direction(), typeIR, `DYN`_ctk(), ?()))
      -- let variableDeclarationIR = `VarD%%%`_variableDeclarationIR(typeIR, name, ?(typedExpressionIR_init_cast))

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:263.1-267.53
   rule emptyStatement: `%|-%:%%`(TC, parserStatement, TC, emptyStatementIR as parserStatementIR)
      -- if parserStatement <: emptyStatement
      -- let emptyStatement = parserStatement as emptyStatement
      -- Stmt_ok: `%%%|-%:%%%`(`LOCAL`_cursor(), TC, `CONT`_flow(), emptyStatement as statement, _typingContext, _flow, statementIR)
      -- if statementIR <: emptyStatementIR
      -- let emptyStatementIR = statementIR as emptyStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:271.1-275.62
   rule assignmentStatement: `%|-%:%%`(TC_0, parserStatement, TC_1, assignmentStatementIR as parserStatementIR)
      -- if parserStatement <: assignmentStatement
      -- let assignmentStatement = parserStatement as assignmentStatement
      -- Stmt_ok: `%%%|-%:%%%`(`LOCAL`_cursor(), TC_0, `CONT`_flow(), assignmentStatement as statement, TC_1, _flow, statementIR)
      -- if statementIR <: assignmentStatementIR
      -- let assignmentStatementIR = statementIR as assignmentStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:279.1-283.56
   rule callStatement: `%|-%:%%`(TC_0, parserStatement, TC_1, callStatementIR as parserStatementIR)
      -- if parserStatement <: callStatement
      -- let callStatement = parserStatement as callStatement
      -- Stmt_ok: `%%%|-%:%%%`(`LOCAL`_cursor(), TC_0, `CONT`_flow(), callStatement as statement, TC_1, _flow, statementIR)
      -- if statementIR <: callStatementIR
      -- let callStatementIR = statementIR as callStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:287.1-291.69
   rule directApplicationStatement: `%|-%:%%`(TC_0, parserStatement, TC_1, directApplicationStatementIR as parserStatementIR)
      -- if parserStatement <: directApplicationStatement
      -- let directApplicationStatement = parserStatement as directApplicationStatement
      -- Stmt_ok: `%%%|-%:%%%`(`LOCAL`_cursor(), TC_0, `CONT`_flow(), directApplicationStatement as statement, TC_1, _flow, statementIR)
      -- if statementIR <: directApplicationStatementIR
      -- let directApplicationStatementIR = statementIR as directApplicationStatementIR

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:296.1-304.65
   rule parserBlockStatement: `%|-%:%%`(TC_0, parserStatement', TC_3, parserBlockStatementIR as parserStatementIR)
      -- if parserStatement' <: parserBlockStatement
      -- let `ParserBlockS%`_parserBlockStatement(parserStatement*{parserStatement <- parserStatement*}) = parserStatement' as parserBlockStatement
      -- let TC_1 = $enter(TC_0)
      -- ParserStmts_ok: `%|-%:%%`(TC_1, parserStatement*{parserStatement <- parserStatement*}, TC_2, parserStatementIR*{parserStatementIR <- parserStatementIR*})
      -- let TC_3 = $exit(TC_2)
      -- let parserBlockStatementIR = `ParserBlockS%`_parserBlockStatementIR(parserStatementIR*{parserStatementIR <- parserStatementIR*})

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:308.1-312.63
   rule conditionalStatement: `%|-%:%%`(TC_0, parserStatement, TC_1, conditionalStatementIR as parserStatementIR)
      -- if parserStatement <: conditionalStatement
      -- let conditionalStatement = parserStatement as conditionalStatement
      -- Stmt_ok: `%%%|-%:%%%`(`LOCAL`_cursor(), TC_0, `CONT`_flow(), conditionalStatement as statement, TC_1, _flow, statementIR)
      -- if statementIR <: conditionalStatementIR
      -- let conditionalStatementIR = statementIR as conditionalStatementIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:155.1-157.20
relation ParserStmts_ok: `%|-%:%%`(typingContext, parserStatement*, typingContext, parserStatementIR*)

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:320.1-321.21
   rule nil: `%|-%:%%`(TC, parserStatement*{parserStatement <- parserStatement*}, TC, [])
      -- if parserStatement*{parserStatement <- parserStatement*} matches []

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:323.1-329.55
   rule cons: `%|-%:%%`(TC_0, parserStatement*{parserStatement <- parserStatement*}, TC_2, parserStatementIR_h :: parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*})
      -- if parserStatement*{parserStatement <- parserStatement*} matches _ :: _
      -- let parserStatement_h :: parserStatement_t*{parserStatement_t <- parserStatement_t*} = parserStatement*{parserStatement <- parserStatement*}
      -- ParserStmt_ok: `%|-%:%%`(TC_0, parserStatement_h, TC_1, parserStatementIR_h)
      -- ParserStmts_ok: `%|-%:%%`(TC_1, parserStatement_t*{parserStatement_t <- parserStatement_t*}, TC_2, parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:159.1-161.23
relation ParserState_ok: `%%|-%:%`(typingContext, name*, parserState, parserStateIR)

   ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:8.1-21.54
   rule none: `%%|-%:%`(TC_0, name_state*{name_state <- name_state*}, `%%%`_parserState(name, parserStatement*{parserStatement <- parserStatement*}, transitionStatement?{transitionStatement <- transitionStatement?}), parserStateIR)
      -- if transitionStatement?{transitionStatement <- transitionStatement?} matches ()
      -- let TC_1 = $enter(TC_0)
      -- ParserStmts_ok: `%|-%:%%`(TC_1, parserStatement*{parserStatement <- parserStatement*}, TC_2, parserStatementIR*{parserStatementIR <- parserStatementIR*})
      -- let transitionStatementIR = `TransS%`_transitionStatementIR(?(`NameE%`_stateExpressionIR("reject")))
      -- let TC_3 = $exit(TC_2)
      -- let parserStateIR = `%%%`_parserStateIR(name, parserStatementIR*{parserStatementIR <- parserStatementIR*}, transitionStatementIR)

   ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:23.1-37.54
   rule some: `%%|-%:%`(TC_0, name_state*{name_state <- name_state*}, `%%%`_parserState(name, parserStatement*{parserStatement <- parserStatement*}, transitionStatement'?{transitionStatement' <- transitionStatement'?}), parserStateIR)
      -- if transitionStatement'?{transitionStatement' <- transitionStatement'?} matches (_)
      -- let ?(transitionStatement) = transitionStatement'?{transitionStatement' <- transitionStatement'?}
      -- let TC_1 = $enter(TC_0)
      -- ParserStmts_ok: `%|-%:%%`(TC_1, parserStatement*{parserStatement <- parserStatement*}, TC_2, parserStatementIR*{parserStatementIR <- parserStatementIR*})
      -- ParserTransition_ok: `%%|-%:%`(TC_2, name_state*{name_state <- name_state*}, transitionStatement, transitionStatementIR)
      -- let TC_3 = $exit(TC_2)
      -- let parserStateIR = `%%%`_parserStateIR(name, parserStatementIR*{parserStatementIR <- parserStatementIR*}, transitionStatementIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:163.1-165.20
relation ParserStates_ok: `%|-%:%`(typingContext, parserState*, parserStateIR*)

   ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:45.1-56.75
   rule : `%|-%:%`(TC, parserState*{parserState <- parserState*}, parserStateIR*{parserStateIR <- parserStateIR*})
      -- (let `%%%`_parserState(name_state, _parserStatement*{_parserStatement <- _parserStatement*}, _transitionStatement?{_transitionStatement <- _transitionStatement?}) = parserState)*{_parserStatement* <- _parserStatement**, _transitionStatement? <- _transitionStatement?*, name_state <- name_state*, parserState <- parserState*}
      -- if $distinct_<name>(name_state*{name_state <- name_state*})
      -- if "start" <- name_state*{name_state <- name_state*}
      -- if (~"accept" <- name_state*{name_state <- name_state*} /\ ~"reject" <- name_state*{name_state <- name_state*})
      -- let name_state_impl*{name_state_impl <- name_state_impl*} = "accept" :: "reject" :: name_state*{name_state <- name_state*}
      -- (ParserState_ok: `%%|-%:%`(TC, name_state_impl*{name_state_impl <- name_state_impl*}, parserState, parserStateIR))*{parserState <- parserState*, parserStateIR <- parserStateIR*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:167.1-170.20
relation ParserLocalDecl_ok: `%|-%:%%`(typingContext, parserLocalDeclaration, typingContext, parserLocalDeclarationIR)

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:9.1-13.55
   rule constantDeclaration: `%|-%:%%`(TC_0, parserLocalDeclaration, TC_1, constantDeclarationIR as parserLocalDeclarationIR)
      -- if parserLocalDeclaration <: constantDeclaration
      -- let constantDeclaration = parserLocalDeclaration as constantDeclaration
      -- Decl_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_0, constantDeclaration as declaration, TC_1, declarationIR)
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:17.1-21.49
   rule instantiation: `%|-%:%%`(TC_0, parserLocalDeclaration, TC_1, instantiationIR as parserLocalDeclarationIR)
      -- if parserLocalDeclaration <: instantiation
      -- let instantiation = parserLocalDeclaration as instantiation
      -- Decl_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_0, instantiation as declaration, TC_1, declarationIR)
      -- if declarationIR <: instantiationIR
      -- let instantiationIR = declarationIR as instantiationIR

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:26.1-37.53
   rule variableDeclaration-none: `%|-%:%%`(TC_0, parserLocalDeclaration, TC_1, variableDeclarationIR as parserLocalDeclarationIR)
      -- if parserLocalDeclaration <: variableDeclaration
      -- let `VarD%%%`_variableDeclaration(type, name, initializer?{initializer <- initializer?}) = parserLocalDeclaration as variableDeclaration
      -- if initializer?{initializer <- initializer?} matches ()
      -- Type_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`BLOCK`_cursor(), TC_0), typeIR) holds
      -- if $is_assignable_typeIR(typeIR)
      -- let TC_1 = $add_var(`BLOCK`_cursor(), TC_0, name, `%%%%`_varTypeIR(`INOUT`_direction(), typeIR, `DYN`_ctk(), ?()))
      -- let variableDeclarationIR = `VarD%%%`_variableDeclarationIR(typeIR, name, ?())

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:39.1-57.53
   rule variableDeclaration-some: `%|-%:%%`(TC_0, parserLocalDeclaration, TC_1, variableDeclarationIR as parserLocalDeclarationIR)
      -- if parserLocalDeclaration <: variableDeclaration
      -- let `VarD%%%`_variableDeclaration(type, name, initializer?{initializer <- initializer?}) = parserLocalDeclaration as variableDeclaration
      -- if initializer?{initializer <- initializer?} matches (_)
      -- let ?(expression_init) = initializer?{initializer <- initializer?}
      -- Type_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`BLOCK`_cursor(), TC_0), typeIR) holds
      -- if $is_assignable_typeIR(typeIR)
      -- Expr_ok: `%%|-%:%`(`BLOCK`_cursor(), TC_0, expression_init, typedExpressionIR_init)
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let TC_1 = $add_var(`BLOCK`_cursor(), TC_0, name, `%%%%`_varTypeIR(`INOUT`_direction(), typeIR, `DYN`_ctk(), ?()))
      -- let variableDeclarationIR = `VarD%%%`_variableDeclarationIR(typeIR, name, ?(typedExpressionIR_init_cast))

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:63.1-79.48
   rule valueSetDeclaration: `%|-%:%%`(TC_0, parserLocalDeclaration, TC_1, valueSetDeclarationIR as parserLocalDeclarationIR)
      -- if parserLocalDeclaration <: valueSetDeclaration
      -- let `ValueSetD%%%`_valueSetDeclaration(valueSetType, expression, name) = parserLocalDeclaration as valueSetDeclaration
      -- Type_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_0, valueSetType as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`BLOCK`_cursor(), TC_0), `SetT%`_setTypeIR(typeIR) as typeIR) holds
      -- Expr_ok: `%%|-%:%`(`BLOCK`_cursor(), TC_0, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(_typeIR, ctk)) = typedExpressionIR
      -- if (ctk =/= `DYN`_ctk())
      -- let TC_1 = $add_var(`BLOCK`_cursor(), TC_0, name, `%%%%`_varTypeIR(`NO`_direction(), `SetT%`_setTypeIR(typeIR) as typeIR, `CTK`_ctk(), ?()))
      -- let valueSetDeclarationIR = `ValueSetD%%%`_valueSetDeclarationIR(typeIR, typedExpressionIR, name)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:172.1-175.20
relation ParserLocalDecls_ok: `%|-%:%%`(typingContext, parserLocalDeclaration*, typingContext, parserLocalDeclarationIR*)

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:87.1-88.21
   rule nil: `%|-%:%%`(TC, parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}, TC, [])
      -- if parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} matches []

   ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:90.1-96.67
   rule cons: `%|-%:%%`(TC_0, parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}, TC_2, parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*})
      -- if parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} matches _ :: _
      -- let parserLocalDeclaration_h :: parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} = parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}
      -- ParserLocalDecl_ok: `%|-%:%%`(TC_0, parserLocalDeclaration_h, TC_1, parserLocalDeclarationIR_h)
      -- ParserLocalDecls_ok: `%|-%:%%`(TC_1, parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*}, TC_2, parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:181.1-183.23
relation TableKey_ok: `%%|-%:%%`(typingContext, tableContext, tableKey, tableContext, tableKeyIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:51.1-67.54
   rule : `%%|-%:%%`(TC, TBLC_0, `%%`_tableKey(expression, name_matchkind), TBLC_2, tableKeyIR)
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, _ctk)) = typedExpressionIR
      -- if Type_wf: `%|-%`($bound(`LOCAL`_cursor(), TC), `SetT%`_setTypeIR(typeIR) as typeIR) holds
      -- if (?(`MatchKindV%`_primitiveValue(name_matchkind) as value) = $find_value(`LOCAL`_cursor(), TC, `CURRENT%`_prefixedName(name_matchkind)))
      -- if $compat_table_key(name_matchkind, typeIR)
      -- let TBLC_1 = $update_mode(TBLC_0, name_matchkind, typeIR)
      -- let TBLC_2 = $add_key(TBLC_1, name_matchkind, typeIR)
      -- let tableKeyIR = `%%`_tableKeyIR(typedExpressionIR, name_matchkind)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:185.1-187.23
relation TableKeys_ok: `%%|-%:%%`(typingContext, tableContext, tableKey*, tableContext, tableKeyIR*)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:75.1-76.28
   rule nil: `%%|-%:%%`(TC, TBLC, tableKey*{tableKey <- tableKey*}, TBLC, [])
      -- if tableKey*{tableKey <- tableKey*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:78.1-82.67
   rule cons: `%%|-%:%%`(TC, TBLC_0, tableKey*{tableKey <- tableKey*}, TBLC_2, tableKeyIR_h :: tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*})
      -- if tableKey*{tableKey <- tableKey*} matches _ :: _
      -- let tableKey_h :: tableKey_t*{tableKey_t <- tableKey_t*} = tableKey*{tableKey <- tableKey*}
      -- TableKey_ok: `%%|-%:%%`(TC, TBLC_0, tableKey_h, TBLC_1, tableKeyIR_h)
      -- TableKeys_ok: `%%|-%:%%`(TC, TBLC_1, tableKey_t*{tableKey_t <- tableKey_t*}, TBLC_2, tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:189.1-192.23
relation Call_action_partial_ok: `%|-%%:%%%`(typingContext, parameterTypeIR*, argumentIR*, parameterTypeIR*, parameterTypeIR*, argumentIR*)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:106.1-117.42
   rule : `%|-%%:%%%`(TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}, parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- if (|parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- Call_convention_ok: `%%%|-%%:%`(`LOCAL`_cursor(), TC, `ACTION`_actctxt(), parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:194.1-196.23
relation TableAction_ok: `%%|-%:%%`(typingContext, tableContext, tableAction, tableContext, tableActionIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:122.1-137.54
   rule tableActionReference: `%%|-%:%%`(TC, TBLC_0, `%%`_tableActionReference(prefixedName, argument*{argument <- argument*}), TBLC_1, tableActionIR)
      -- let (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?} = $find_routine_non_overloaded(`LOCAL`_cursor(), TC, prefixedName)
      -- if (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?} matches (_)
      -- let ?((_rid, routineTypeDefIR)) = (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?}
      -- if routineTypeDefIR <: monoRoutineTypeDefIR
      -- let `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) = routineTypeDefIR as monoRoutineTypeDefIR
      -- if routineTypeIR matches `ActionT%`
      -- let `ActionT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- (Argument_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, argument, argumentIR))*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_action_partial_ok: `%|-%%:%%%`(TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}, parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let TBLC_1 = $add_action(TBLC_0, prefixedName, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let tableActionIR = `%%`_tableActionReferenceIR(prefixedName, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:198.1-200.23
relation TableActions_ok: `%%|-%:%%`(typingContext, tableContext, tableAction*, tableContext, tableActionIR*)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:145.1-146.28
   rule nil: `%%|-%:%%`(TC, TBLC, tableAction*{tableAction <- tableAction*}, TBLC, [])
      -- if tableAction*{tableAction <- tableAction*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:148.1-152.76
   rule cons: `%%|-%:%%`(TC, TBLC_0, tableAction*{tableAction <- tableAction*}, TBLC_2, tableActionIR_h :: tableActionIR_t*{tableActionIR_t <- tableActionIR_t*})
      -- if tableAction*{tableAction <- tableAction*} matches _ :: _
      -- let tableAction_h :: tableAction_t*{tableAction_t <- tableAction_t*} = tableAction*{tableAction <- tableAction*}
      -- TableAction_ok: `%%|-%:%%`(TC, TBLC_0, tableAction_h, TBLC_1, tableActionIR_h)
      -- TableActions_ok: `%%|-%:%%`(TC, TBLC_1, tableAction_t*{tableAction_t <- tableAction_t*}, TBLC_2, tableActionIR_t*{tableActionIR_t <- tableActionIR_t*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:202.1-205.23
relation Call_action_default_ok: `%|-%%:%%%`(typingContext, parameterTypeIR*, argumentIR*, parameterTypeIR*, parameterTypeIR*, argumentIR*)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:160.1-169.42
   rule : `%|-%%:%%%`(TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}, parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- Call_convention_ok: `%%%|-%%:%`(`LOCAL`_cursor(), TC, `ACTION`_actctxt(), parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:207.1-209.23
relation TableDefaultAction_ok: `%%|-%:%`(typingContext, tableContext, initializer, tableActionReferenceIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:173.1-177.54
   rule nameE: `%%|-%:%`(TC, TBLC, initializer, `%%`_tableActionReferenceIR(prefixedName, []))
      -- if initializer <: referenceExpression
      -- let `NameE%`_referenceExpression(prefixedName) = initializer as referenceExpression
      -- if (?(([], [])) = $find_action(TBLC, prefixedName))

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:181.1-200.57
   rule callE: `%%|-%:%`(TC, TBLC, initializer, `%%`_tableActionReferenceIR(prefixedName, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}))
      -- if initializer <: callExpression
      -- let callExpression = initializer as callExpression
      -- if callExpression matches `CallE%%%`
      -- let `CallE%%%`_callExpression(routineTarget, typeArgument*{typeArgument <- typeArgument*}, argument*{argument <- argument*}) = callExpression
      -- if routineTarget <: referenceExpression
      -- let `NameE%`_referenceExpression(prefixedName) = routineTarget as referenceExpression
      -- if typeArgument*{typeArgument <- typeArgument*} matches []
      -- let (parameterTypeIR*, argumentIR*)?{(parameterTypeIR*, argumentIR*) <- (parameterTypeIR*, argumentIR*)?} = $find_action(TBLC, prefixedName)
      -- if (parameterTypeIR*, argumentIR*)?{(parameterTypeIR*, argumentIR*) <- (parameterTypeIR*, argumentIR*)?} matches (_)
      -- let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) = (parameterTypeIR*, argumentIR*)?{(parameterTypeIR*, argumentIR*) <- (parameterTypeIR*, argumentIR*)?}
      -- (Argument_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, argument, argumentIR))*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_action_default_ok: `%|-%%:%%%`(TC, parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR*{argumentIR <- argumentIR*}, parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}, parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} = argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} = argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- (if (argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:211.1-213.23
relation TableEntry_keysets_ok: `%%|-%:%%`(typingContext, tableContext, keysetExpression*, tableEntryState, keysetExpressionIR*)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:384.1-387.21
   rule defaultK-noprilpm: `%%|-%:%%`(TC, TBLC, keysetExpression*{keysetExpression <- keysetExpression*}, TBLS, [`DefaultK`_keysetExpressionIR()])
      -- if (keysetExpression*{keysetExpression <- keysetExpression*} = [`DefaultK`_keysetExpression()])
      -- let matchMode = TBLC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM%`_matchMode(n) = matchMode
      -- let TBLS = `LPM%`_tableEntryState(n)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:389.1-392.21
   rule defaultK-else: `%%|-%:%%`(TC, TBLC, keysetExpression*{keysetExpression <- keysetExpression*}, TBLS, [`DefaultK`_keysetExpressionIR()])
      -- if (keysetExpression*{keysetExpression <- keysetExpression*} = [`DefaultK`_keysetExpression()])
      -- if (((TBLC.MODE = `NOPRI`_matchMode()) \/ (TBLC.MODE = `PRI`_matchMode())) \/ (TBLC.MODE = `PRILPM`_matchMode()))
      -- let TBLS = `NOLPM`_tableEntryState()

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:396.1-399.21
   rule anyK-noprilpm: `%%|-%:%%`(TC, TBLC, keysetExpression*{keysetExpression <- keysetExpression*}, TBLS, [`AnyK`_keysetExpressionIR()])
      -- if (keysetExpression*{keysetExpression <- keysetExpression*} = [`AnyK`_keysetExpression()])
      -- let matchMode = TBLC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM%`_matchMode(n) = matchMode
      -- let TBLS = `LPM%`_tableEntryState(0)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:401.1-404.21
   rule anyK-else: `%%|-%:%%`(TC, TBLC, keysetExpression*{keysetExpression <- keysetExpression*}, TBLS, [`AnyK`_keysetExpressionIR()])
      -- if (keysetExpression*{keysetExpression <- keysetExpression*} = [`AnyK`_keysetExpression()])
      -- if (((TBLC.MODE = `NOPRI`_matchMode()) \/ (TBLC.MODE = `PRI`_matchMode())) \/ (TBLC.MODE = `PRILPM`_matchMode()))
      -- let TBLS = `NOLPM`_tableEntryState()

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:408.1-418.48
   rule list: `%%|-%:%%`(TC, TBLC, keysetExpression*{keysetExpression <- keysetExpression*}, TBLS, keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*})
      -- if ((keysetExpression*{keysetExpression <- keysetExpression*} =/= [`AnyK`_keysetExpression()]) /\ (keysetExpression*{keysetExpression <- keysetExpression*} =/= [`DefaultK`_keysetExpression()]))
      -- if (|TBLC.KEYS| = |keysetExpression*{keysetExpression <- keysetExpression*}|)
      -- TableEntry_keysets_ok': `%%%|-%%:%%`(TC, TBLC, `NOLPM`_tableEntryState(), TBLC.KEYS, keysetExpression*{keysetExpression <- keysetExpression*}, TBLS, keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:215.1-217.23
relation TableEntry_action_ok: `%%|-%:%`(typingContext, tableContext, tableActionReference, tableActionReferenceIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:426.1-445.57
   rule : `%%|-%:%`(TC, TBLC, `%%`_tableActionReference(prefixedName, argument*{argument <- argument*}), `%%`_tableActionReferenceIR(prefixedName, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}))
      -- let (parameterTypeIR*, argumentIR*)?{(parameterTypeIR*, argumentIR*) <- (parameterTypeIR*, argumentIR*)?} = $find_action(TBLC, prefixedName)
      -- if (parameterTypeIR*, argumentIR*)?{(parameterTypeIR*, argumentIR*) <- (parameterTypeIR*, argumentIR*)?} matches (_)
      -- let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) = (parameterTypeIR*, argumentIR*)?{(parameterTypeIR*, argumentIR*) <- (parameterTypeIR*, argumentIR*)?}
      -- (Argument_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, argument, argumentIR))*{argument <- argument*, argumentIR <- argumentIR*}
      -- Call_action_default_ok: `%|-%%:%%%`(TC, parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR*{argumentIR <- argumentIR*}, parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}, parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} = argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} = argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
      -- (if (argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:219.1-222.26
relation TableEntry_priority_ok: `%%%|-%:%%`(typingContext, tableContext, tableEntryState, tableEntryPriority?, tableContext, tableEntryPriorityIR?)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:455.1-457.26
   rule none-nopri: `%%%|-%:%%`(TC, TBLC, TBLS, tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}, TBLC, ?())
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if (TBLC.MODE = `NOPRI`_matchMode())

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:459.1-462.28
   rule none-noprilpm: `%%%|-%:%%`(TC, TBLC, TBLS, tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}, TBLC, ?())
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- let matchMode = TBLC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM%`_matchMode(n) = matchMode
      -- let tableEntryState = TBLS
      -- if tableEntryState matches `LPM%`
      -- let `LPM%`_tableEntryState(n_prefix) = tableEntryState

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:464.1-477.58
   rule none-pri-prilpm-init-largest-wins: `%%%|-%:%%`(TC, TBLC_0, TBLS, tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}, TBLC_1, ?(typedExpressionIR))
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if ((TBLC_0.MODE = `PRI`_matchMode()) \/ (TBLC_0.MODE = `PRILPM`_matchMode()))
      -- if (TBLC_0.PRIORITIES.VALUES = [])
      -- if TBLC_0.PRIORITIES.LARGEST_WINS
      -- let n_size = TBLC_0.ENTRIES.SIZE
      -- let n_delta = TBLC_0.PRIORITIES.DELTA
      -- let int = (((n_size - 1) * n_delta as int) + 1 as int)
      -- if int <: nat
      -- let n = int as nat
      -- let TBLC_1 = $add_table_priority(TBLC_0, n)
      -- let typedExpressionIR = `%%`_typedExpressionIR(`NumE%`_literalExpression(`INT%`_number(n as int)) as expressionIR, `(%%)`_expressionNoteIR(`IntT`_numberTypeIR() as typeIR, `LCTK`_ctk()))

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:479.1-489.58
   rule none-pri-prilpm-init-non-largest-wins: `%%%|-%:%%`(TC, TBLC_0, TBLS, tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}, TBLC_1, ?(typedExpressionIR))
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if ((TBLC_0.MODE = `PRI`_matchMode()) \/ (TBLC_0.MODE = `PRILPM`_matchMode()))
      -- if (TBLC_0.PRIORITIES.VALUES = [])
      -- if ~TBLC_0.PRIORITIES.LARGEST_WINS
      -- let TBLC_1 = $add_table_priority(TBLC_0, 1)
      -- let typedExpressionIR = `%%`_typedExpressionIR(`NumE%`_literalExpression(`INT%`_number(1 as int)) as expressionIR, `(%%)`_expressionNoteIR(`IntT`_numberTypeIR() as typeIR, `LCTK`_ctk()))

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:491.1-504.58
   rule none-pri-prilpm-non-init-largest-wins: `%%%|-%:%%`(TC, TBLC_0, TBLS, tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}, TBLC_1, ?(typedExpressionIR))
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if ((TBLC_0.MODE = `PRI`_matchMode()) \/ (TBLC_0.MODE = `PRILPM`_matchMode()))
      -- if (TBLC_0.PRIORITIES.VALUES =/= [])
      -- if TBLC_0.PRIORITIES.LARGEST_WINS
      -- let n_last = $find_table_priority_last(TBLC_0)
      -- let n_delta = TBLC_0.PRIORITIES.DELTA
      -- let int = (n_last - n_delta)
      -- if int <: nat
      -- let n = int as nat
      -- let TBLC_1 = $add_table_priority(TBLC_0, n)
      -- let typedExpressionIR = `%%`_typedExpressionIR(`NumE%`_literalExpression(`INT%`_number(n as int)) as expressionIR, `(%%)`_expressionNoteIR(`IntT`_numberTypeIR() as typeIR, `LCTK`_ctk()))

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:506.1-519.58
   rule none-pri-prilpm-non-init-non-largest-wins: `%%%|-%:%%`(TC, TBLC_0, TBLS, tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}, TBLC_1, ?(typedExpressionIR))
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
      -- if ((TBLC_0.MODE = `PRI`_matchMode()) \/ (TBLC_0.MODE = `PRILPM`_matchMode()))
      -- if (TBLC_0.PRIORITIES.VALUES =/= [])
      -- if ~TBLC_0.PRIORITIES.LARGEST_WINS
      -- let n_last = $find_table_priority_last(TBLC_0)
      -- let n_delta = TBLC_0.PRIORITIES.DELTA
      -- let n = (n_last + n_delta)
      -- let TBLC_1 = $add_table_priority(TBLC_0, n)
      -- let typedExpressionIR = `%%`_typedExpressionIR(`NumE%`_literalExpression(`INT%`_number(n as int)) as expressionIR, `(%%)`_expressionNoteIR(`IntT`_numberTypeIR() as typeIR, `LCTK`_ctk()))

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:521.1-535.48
   rule some-pri-prilpm-init: `%%%|-%:%%`(TC, TBLC_0, TBLS, tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}, TBLC_2, ?(typedExpressionIR))
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches (_)
      -- let ?(expression) = tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}
      -- if ((TBLC_0.MODE = `PRI`_matchMode()) \/ (TBLC_0.MODE = `PRILPM`_matchMode()))
      -- if ~TBLC_0.ENTRIES.CONST
      -- if (TBLC_0.PRIORITIES.VALUES = [])
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(_typeIR, ctk)) = typedExpressionIR
      -- if ctk matches `LCTK`
      -- Eval_static: `%%|-%~>%`(`LOCAL`_cursor(), TC, typedExpressionIR, value)
      -- let int'?{int' <- int'?} = $to_number(value)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n = int as nat
      -- let TBLC_1 = TBLC_0[PRIORITIES.INIT = true]
      -- let TBLC_2 = $add_table_priority(TBLC_1, n)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:537.1-551.48
   rule some-pri-prilpm-non-init: `%%%|-%:%%`(TC, TBLC_0, TBLS, tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}, TBLC_1, ?(typedExpressionIR))
      -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches (_)
      -- let ?(expression) = tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}
      -- if ((TBLC_0.MODE = `PRI`_matchMode()) \/ (TBLC_0.MODE = `PRILPM`_matchMode()))
      -- if ~TBLC_0.ENTRIES.CONST
      -- if (TBLC_0.PRIORITIES.VALUES =/= [])
      -- if TBLC_0.PRIORITIES.INIT
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(_typeIR, ctk)) = typedExpressionIR
      -- if ctk matches `LCTK`
      -- Eval_static: `%%|-%~>%`(`LOCAL`_cursor(), TC, typedExpressionIR, value)
      -- let int'?{int' <- int'?} = $to_number(value)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n = int as nat
      -- let TBLC_1 = $add_table_priority(TBLC_0, n)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:224.1-226.23
relation TableEntry_ok: `%%|-%:%%`(typingContext, tableContext, tableEntry, tableContext, tableEntryIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:556.1-570.58
   rule : `%%|-%:%%`(TC, TBLC_0, `%%%%`_tableEntry(const?{const <- const?}, tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}, keysetExpression*{keysetExpression <- keysetExpression*}, tableActionReference), TBLC_1, tableEntryIR)
      -- TableEntry_keysets_ok: `%%|-%:%%`(TC, TBLC_0, keysetExpression*{keysetExpression <- keysetExpression*}, TBLS, keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*})
      -- TableEntry_action_ok: `%%|-%:%`(TC, TBLC_0, tableActionReference, tableActionReferenceIR)
      -- TableEntry_priority_ok: `%%%|-%:%%`(TC, TBLC_0, TBLS, tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}, TBLC_1, tableEntryPriorityIR?{tableEntryPriorityIR <- tableEntryPriorityIR?})
      -- let tableEntryIR = `%%%%`_tableEntryIR(const?{const <- const?}, tableEntryPriorityIR?{tableEntryPriorityIR <- tableEntryPriorityIR?}, keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*}, tableActionReferenceIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:228.1-230.23
relation TableEntries_ok: `%%|-%:%%`(typingContext, tableContext, tableEntry*, tableContext, tableEntryIR*)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:578.1-579.28
   rule nil: `%%|-%:%%`(TC, TBLC, tableEntry*{tableEntry <- tableEntry*}, TBLC, [])
      -- if tableEntry*{tableEntry <- tableEntry*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:581.1-585.74
   rule cons: `%%|-%:%%`(TC, TBLC_0, tableEntry*{tableEntry <- tableEntry*}, TBLC_2, tableEntryIR_h :: tableEntryIR_t*{tableEntryIR_t <- tableEntryIR_t*})
      -- if tableEntry*{tableEntry <- tableEntry*} matches _ :: _
      -- let tableEntry_h :: tableEntry_t*{tableEntry_t <- tableEntry_t*} = tableEntry*{tableEntry <- tableEntry*}
      -- TableEntry_ok: `%%|-%:%%`(TC, TBLC_0, tableEntry_h, TBLC_1, tableEntryIR_h)
      -- TableEntries_ok: `%%|-%:%%`(TC, TBLC_1, tableEntry_t*{tableEntry_t <- tableEntry_t*}, TBLC_2, tableEntryIR_t*{tableEntryIR_t <- tableEntryIR_t*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:232.1-234.23
relation TableProperty_ok: `%%|-%:%%`(typingContext, tableContext, tableProperty, tableContext, tablePropertyIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:595.1-598.63
   rule keyP: `%%|-%:%%`(TC, TBLC_0, tableProperty, TBLC_1, `KeyP%`_tablePropertyIR(tableKeyIR*{tableKeyIR <- tableKeyIR*}))
      -- if tableProperty matches `KeyP%`
      -- let `KeyP%`_tableProperty(tableKey*{tableKey <- tableKey*}) = tableProperty
      -- TableKeys_ok: `%%|-%:%%`(TC, TBLC_0, tableKey*{tableKey <- tableKey*}, TBLC_1, tableKeyIR*{tableKeyIR <- tableKeyIR*})

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:602.1-605.72
   rule actionP: `%%|-%:%%`(TC, TBLC_0, tableProperty, TBLC_1, `ActionP%`_tablePropertyIR(tableActionIR*{tableActionIR <- tableActionIR*}))
      -- if tableProperty matches `ActionP%`
      -- let `ActionP%`_tableProperty(tableAction*{tableAction <- tableAction*}) = tableProperty
      -- TableActions_ok: `%%|-%:%%`(TC, TBLC_0, tableAction*{tableAction <- tableAction*}, TBLC_1, tableActionIR*{tableActionIR <- tableActionIR*})

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:609.1-619.70
   rule entryP: `%%|-%:%%`(TC, TBLC_0, tableProperty, TBLC_3, `EntryP%%`_tablePropertyIR(const?{const <- const?}, tableEntryIR*{tableEntryIR <- tableEntryIR*}))
      -- if tableProperty matches `EntryP%%`
      -- let `EntryP%%`_tableProperty(const?{const <- const?}, tableEntry*{tableEntry <- tableEntry*}) = tableProperty
      -- if ((|TBLC_0.KEYS| = 0) => (|tableEntry*{tableEntry <- tableEntry*}| = 0))
      -- let TBLC_1 = TBLC_0[ENTRIES.SIZE = |tableEntry*{tableEntry <- tableEntry*}|]
      -- let TBLC_2 = TBLC_1[ENTRIES.CONST = (const?{const <- const?} = ?(`CONST`_const()))]
      -- TableEntries_ok: `%%|-%:%%`(TC, TBLC_2, tableEntry*{tableEntry <- tableEntry*}, TBLC_3, tableEntryIR*{tableEntryIR <- tableEntryIR*})

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:623.1-629.71
   rule customP-default-action: `%%|-%:%%`(TC, TBLC, tableProperty, TBLC, tablePropertyIR)
      -- if tableProperty matches `CustomP%%%`
      -- let `CustomP%%%`_tableProperty(const?{const <- const?}, text, initializer) = tableProperty
      -- if (text = "default_action")
      -- TableDefaultAction_ok: `%%|-%:%`(TC, TBLC, initializer, tableActionReferenceIR)
      -- let tablePropertyIR = `DefaultActionP%%`_tablePropertyIR(const?{const <- const?}, tableActionReferenceIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:631.1-641.66
   rule customP-size: `%%|-%:%%`(TC, TBLC, tableProperty, TBLC, tablePropertyIR)
      -- if tableProperty matches `CustomP%%%`
      -- let `CustomP%%%`_tableProperty(const?{const <- const?}, text, expression) = tableProperty
      -- if (text = "size")
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, _ctk)) = typedExpressionIR
      -- if (($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))
      -- let tablePropertyIR = `CustomP%%%`_tablePropertyIR(const?{const <- const?}, "size", typedExpressionIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:643.1-655.66
   rule customP-largest-priority-wins: `%%|-%:%%`(TC, TBLC_0, tableProperty, TBLC_1, tablePropertyIR)
      -- if tableProperty matches `CustomP%%%`
      -- let `CustomP%%%`_tableProperty(const?{const <- const?}, text, expression) = tableProperty
      -- if (text = "largest_priority_wins")
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, expressionNoteIR) = typedExpressionIR
      -- if (expressionNoteIR = `(%%)`_expressionNoteIR(`BoolT`_primitiveTypeIR() as typeIR, `LCTK`_ctk()))
      -- Eval_static: `%%|-%~>%`(`LOCAL`_cursor(), TC, typedExpressionIR, value)
      -- if value <: primitiveValue
      -- let primitiveValue = value as primitiveValue
      -- if primitiveValue matches `BoolV%`
      -- let `BoolV%`_primitiveValue(b_largest_priority_wins) = primitiveValue
      -- let TBLC_1 = TBLC_0[PRIORITIES.LARGEST_WINS = b_largest_priority_wins]
      -- let tablePropertyIR = `CustomConstP%%%`_tablePropertyIR(const?{const <- const?}, "largest_priority_wins", `BoolV%`_primitiveValue(b_largest_priority_wins) as constantInitializerIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:657.1-673.60
   rule customP-priority-delta: `%%|-%:%%`(TC, TBLC_0, tableProperty, TBLC_1, tablePropertyIR)
      -- if tableProperty matches `CustomP%%%`
      -- let `CustomP%%%`_tableProperty(const?{const <- const?}, text, expression) = tableProperty
      -- if (text = "priority_delta")
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, ctk)) = typedExpressionIR
      -- if ctk matches `LCTK`
      -- if (($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))
      -- Eval_static: `%%|-%~>%`(`LOCAL`_cursor(), TC, typedExpressionIR, value)
      -- let int'?{int' <- int'?} = $to_number(value)
      -- if int'?{int' <- int'?} matches (_)
      -- let ?(int) = int'?{int' <- int'?}
      -- if int <: nat
      -- let n_delta = int as nat
      -- if (n_delta > 0)
      -- let TBLC_1 = TBLC_0[PRIORITIES.DELTA = n_delta]
      -- let tablePropertyIR = `CustomConstP%%%`_tablePropertyIR(const?{const <- const?}, "priority_delta", `IntV%`_numberValue(n_delta as int) as constantInitializerIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:675.1-685.64
   rule customP: `%%|-%:%%`(TC, TBLC, tableProperty, TBLC, tablePropertyIR)
      -- if tableProperty matches `CustomP%%%`
      -- let `CustomP%%%`_tableProperty(const?{const <- const?}, name, expression) = tableProperty
      -- if (((name =/= "size") /\ (name =/= "largest_priority_wins")) /\ (name =/= "priority_delta"))
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let tablePropertyIR = `CustomP%%%`_tablePropertyIR(const?{const <- const?}, name, typedExpressionIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:236.1-238.23
relation TableProperties_ok: `%%|-%:%%`(typingContext, tableContext, tableProperty*, tableContext, tablePropertyIR*)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:693.1-694.28
   rule nil: `%%|-%:%%`(TC, TBLC, tableProperty*{tableProperty <- tableProperty*}, TBLC, [])
      -- if tableProperty*{tableProperty <- tableProperty*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:696.1-700.83
   rule cons: `%%|-%:%%`(TC, TBLC_0, tableProperty*{tableProperty <- tableProperty*}, TBLC_2, tablePropertyIR_h :: tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*})
      -- if tableProperty*{tableProperty <- tableProperty*} matches _ :: _
      -- let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty*{tableProperty <- tableProperty*}
      -- TableProperty_ok: `%%|-%:%%`(TC, TBLC_0, tableProperty_h, TBLC_1, tablePropertyIR_h)
      -- TableProperties_ok: `%%|-%:%%`(TC, TBLC_1, tableProperty_t*{tableProperty_t <- tableProperty_t*}, TBLC_2, tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:240.1-242.20
relation Table_ok: `%|-%:%%`(typingContext, tableProperty*, tableContext, tablePropertyIR*)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:748.1-756.79
   rule : `%|-%:%%`(TC, tableProperty*{tableProperty <- tableProperty*}, TBLC_1, tablePropertyIR*{tablePropertyIR <- tablePropertyIR*})
      -- if ($count_table_keys(tableProperty*{tableProperty <- tableProperty*}) <= 1)
      -- if ($count_table_actions(tableProperty*{tableProperty <- tableProperty*}) = 1)
      -- let TBLC_0 = $empty_tableContext
      -- TableProperties_ok: `%%|-%:%%`(TC, TBLC_0, tableProperty*{tableProperty <- tableProperty*}, TBLC_1, tablePropertyIR*{tablePropertyIR <- tablePropertyIR*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:244.1-246.23
relation TableType_ok: `%%|-%:%%`(typingContext, tableContext, name, typingContext, typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:758.1-783.55
   rule : `%%|-%:%%`(TC_0, TBLC, name, TC_1, typeIR_table)
      -- let tid_enum = "action_list(" ++ name ++ ")"
      -- let (prefixedName_action, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentIR*{_argumentIR <- _argumentIR*})*{_argumentIR* <- _argumentIR**, _parameterTypeIR* <- _parameterTypeIR**, prefixedName_action <- prefixedName_action*} = TBLC.ACTIONS
      -- (let id_enum_field = $flatten_prefixedName(prefixedName_action))*{id_enum_field <- id_enum_field*, prefixedName_action <- prefixedName_action*}
      -- let typeIR_table_enum = `TableEnumT%%`_tableTypeIR(tid_enum, id_enum_field*{id_enum_field <- id_enum_field*}) as typeIR
      -- (let value_enum_field = `TableEnumV%%`_tableValue(tid_enum, id_enum_field) as value)*{id_enum_field <- id_enum_field*, value_enum_field <- value_enum_field*}
      -- (let varTypeIR_enum_field = `%%%%`_varTypeIR(`NO`_direction(), typeIR_table_enum, `LCTK`_ctk(), ?(value_enum_field)))*{value_enum_field <- value_enum_field*, varTypeIR_enum_field <- varTypeIR_enum_field*}
      -- let TC_1 = $add_vars(`BLOCK`_cursor(), TC_0, tid_enum ++ "." ++ id_enum_field*{id_enum_field <- id_enum_field*}, varTypeIR_enum_field*{varTypeIR_enum_field <- varTypeIR_enum_field*})
      -- let tid_struct = "apply_result(" ++ name ++ ")"
      -- let typeIR_table_struct = `TableStructT%%`_tableTypeIR(tid_struct, [`%%`_fieldTypeIR(`BoolT`_primitiveTypeIR() as typeIR, "hit"), `%%`_fieldTypeIR(`BoolT`_primitiveTypeIR() as typeIR, "miss"), `%%`_fieldTypeIR(typeIR_table_enum, "action_run")]) as typeIR
      -- let typeIR_table = `TableT%%`_tableObjectTypeIR(name, typeIR_table_struct) as typeIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:248.1-251.20
relation ControlLocalDecl_ok: `%|-%:%%`(typingContext, controlLocalDeclaration, typingContext, controlLocalDeclarationIR)

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:9.1-13.55
   rule constantDeclaration: `%|-%:%%`(TC_0, controlLocalDeclaration, TC_1, constantDeclarationIR as controlLocalDeclarationIR)
      -- if controlLocalDeclaration <: constantDeclaration
      -- let constantDeclaration = controlLocalDeclaration as constantDeclaration
      -- Decl_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_0, constantDeclaration as declaration, TC_1, declarationIR)
      -- if declarationIR <: constantDeclarationIR
      -- let constantDeclarationIR = declarationIR as constantDeclarationIR

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:17.1-21.49
   rule instantiation: `%|-%:%%`(TC_0, controlLocalDeclaration, TC_1, instantiationIR as controlLocalDeclarationIR)
      -- if controlLocalDeclaration <: instantiation
      -- let instantiation = controlLocalDeclaration as instantiation
      -- Decl_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_0, instantiation as declaration, TC_1, declarationIR)
      -- if declarationIR <: instantiationIR
      -- let instantiationIR = declarationIR as instantiationIR

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:26.1-37.53
   rule variableDeclaration-none: `%|-%:%%`(TC_0, controlLocalDeclaration, TC_1, variableDeclarationIR as controlLocalDeclarationIR)
      -- if controlLocalDeclaration <: variableDeclaration
      -- let `VarD%%%`_variableDeclaration(type, name, initializer?{initializer <- initializer?}) = controlLocalDeclaration as variableDeclaration
      -- if initializer?{initializer <- initializer?} matches ()
      -- Type_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`BLOCK`_cursor(), TC_0), typeIR) holds
      -- if $is_assignable_typeIR(typeIR)
      -- let TC_1 = $add_var(`BLOCK`_cursor(), TC_0, name, `%%%%`_varTypeIR(`INOUT`_direction(), typeIR, `DYN`_ctk(), ?()))
      -- let variableDeclarationIR = `VarD%%%`_variableDeclarationIR(typeIR, name, ?())

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:39.1-57.53
   rule variableDeclaration-some: `%|-%:%%`(TC_0, controlLocalDeclaration, TC_1, variableDeclarationIR as controlLocalDeclarationIR)
      -- if controlLocalDeclaration <: variableDeclaration
      -- let `VarD%%%`_variableDeclaration(type, name, initializer?{initializer <- initializer?}) = controlLocalDeclaration as variableDeclaration
      -- if initializer?{initializer <- initializer?} matches (_)
      -- let ?(expression_init) = initializer?{initializer <- initializer?}
      -- Type_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`BLOCK`_cursor(), TC_0), typeIR) holds
      -- if $is_assignable_typeIR(typeIR)
      -- Expr_ok: `%%|-%:%`(`BLOCK`_cursor(), TC_0, expression_init, typedExpressionIR_init)
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let TC_1 = $add_var(`BLOCK`_cursor(), TC_0, name, `%%%%`_varTypeIR(`INOUT`_direction(), typeIR, `DYN`_ctk(), ?()))
      -- let variableDeclarationIR = `VarD%%%`_variableDeclarationIR(typeIR, name, ?(typedExpressionIR_init_cast))

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:61.1-65.53
   rule actionDeclaration: `%|-%:%%`(TC_0, controlLocalDeclaration, TC_1, actionDeclarationIR as controlLocalDeclarationIR)
      -- if controlLocalDeclaration <: actionDeclaration
      -- let actionDeclaration = controlLocalDeclaration as actionDeclaration
      -- Decl_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_0, actionDeclaration as declaration, TC_1, declarationIR)
      -- if declarationIR <: actionDeclarationIR
      -- let actionDeclarationIR = declarationIR as actionDeclarationIR

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:70.1-82.50
   rule tableDeclaration: `%|-%:%%`(TC_0, controlLocalDeclaration, TC_3, tableDeclarationIR as controlLocalDeclarationIR)
      -- if controlLocalDeclaration <: tableDeclaration
      -- let `TableD%%`_tableDeclaration(name, tableProperty*{tableProperty <- tableProperty*}) = controlLocalDeclaration as tableDeclaration
      -- let TC_1 = TC_0[LOCAL.KIND = `TABLEAPPLYMETHOD`_localKind()]
      -- Table_ok: `%|-%:%%`(TC_1, tableProperty*{tableProperty <- tableProperty*}, TBLC, tablePropertyIR*{tablePropertyIR <- tablePropertyIR*})
      -- TableType_ok: `%%|-%:%%`(TC_1, TBLC, name, TC_2, typeIR_table)
      -- let TC_3 = $add_var(`BLOCK`_cursor(), TC_2, name, `%%%%`_varTypeIR(`NO`_direction(), typeIR_table, `DYN`_ctk(), ?()))
      -- let tableDeclarationIR = `TableD%%%`_tableDeclarationIR(typeIR_table, name, tablePropertyIR*{tablePropertyIR <- tablePropertyIR*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:253.1-256.20
relation ControlLocalDecls_ok: `%|-%:%%`(typingContext, controlLocalDeclaration*, typingContext, controlLocalDeclarationIR*)

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:90.1-91.21
   rule nil: `%|-%:%%`(TC, controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}, TC, [])
      -- if controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} matches []

   ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:93.1-99.69
   rule cons: `%|-%:%%`(TC_0, controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}, TC_2, controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*})
      -- if controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} matches _ :: _
      -- let controlLocalDeclaration_h :: controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} = controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}
      -- ControlLocalDecl_ok: `%|-%:%%`(TC_0, controlLocalDeclaration_h, TC_1, controlLocalDeclarationIR_h)
      -- ControlLocalDecls_ok: `%|-%:%%`(TC_1, controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*}, TC_2, controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:262.1-264.23
relation Decl_ok: `%%|-%:%%`(cursor, typingContext, declaration, typingContext, declarationIR)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:8.1-26.57
   rule constantDeclaration: `%%|-%:%%`(p, TC_0, declaration, TC_1, constantDeclarationIR as declarationIR)
      -- if declaration <: constantDeclaration
      -- let `ConstD%%%`_constantDeclaration(type, name, expression_value) = declaration as constantDeclaration
      -- Type_ok: `%%|-%:%%`(p, TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(p, TC_0), typeIR) holds
      -- Expr_ok: `%%|-%:%`(p, TC_0, expression_value, typedExpressionIR_value)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(_typeIR, ctk)) = typedExpressionIR_value
      -- if ctk matches `LCTK`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_value, typeIR)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_value_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- Eval_static: `%%|-%~>%`(p, TC_0, typedExpressionIR_value_cast, value)
      -- let TC_1 = $add_var(p, TC_0, name, `%%%%`_varTypeIR(`NO`_direction(), typeIR, `LCTK`_ctk(), ?(value)))
      -- let constantDeclarationIR = `ConstD%%%`_constantDeclarationIR(typeIR, name, value)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:31.1-48.56
   rule instantiation-nameT-none: `%%|-%:%%`(p, TC_0, declaration, TC_1, instantiationIR as declarationIR)
      -- if declaration <: instantiation
      -- let `InstD%%%%`_instantiation(type, argument*{argument <- argument*}, name, objectInitializer?{objectInitializer <- objectInitializer?}) = declaration as instantiation
      -- if type <: nameType
      -- let `NameT%`_nameType(prefixedName) = type as nameType
      -- if objectInitializer?{objectInitializer <- objectInitializer?} matches ()
      -- (Argument_ok: `%%|-%:%`(p, TC_0, argument, argumentIR))*{argument <- argument*, argumentIR <- argumentIR*}
      -- ConstructorType_ok: `%%|-%%%:%%%`(p, TC_0, prefixedName, [], argumentIR*{argumentIR <- argumentIR*}, constructorTypeIR, tid_impl*{tid_impl <- tid_impl*}, id_default*{id_default <- id_default*})
      -- Inst_ok: `%%%|-%%%%%:%%%`(p, TC_0, `NAMED`_instctxt(), constructorTypeIR, [], tid_impl*{tid_impl <- tid_impl*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_object, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let TC_1 = $add_var(p, TC_0, name, `%%%%`_varTypeIR(`NO`_direction(), typeIR_object, `CTK`_ctk(), ?()))
      -- let instantiationIR = `InstD%%%%%%`_instantiationIR(typeIR_object, prefixedName, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR*{argumentIR <- argumentIR*}, name, ?())

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:50.1-71.56
   rule instantiation-specT-none: `%%|-%:%%`(p, TC_0, declaration, TC_1, instantiationIR as declarationIR)
      -- if declaration <: instantiation
      -- let `InstD%%%%`_instantiation(type, argument*{argument <- argument*}, name, objectInitializer?{objectInitializer <- objectInitializer?}) = declaration as instantiation
      -- if type <: specializedType
      -- let `SpecT%%`_specializedType(prefixedName, typeArgument*{typeArgument <- typeArgument*}) = type as specializedType
      -- if objectInitializer?{objectInitializer <- objectInitializer?} matches ()
      -- TypeArguments_ok: `%%|-%:%%`(p, TC_0, typeArgument*{typeArgument <- typeArgument*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (Argument_ok: `%%|-%:%`(p, TC_0, argument, argumentIR))*{argument <- argument*, argumentIR <- argumentIR*}
      -- ConstructorType_ok: `%%|-%%%:%%%`(p, TC_0, prefixedName, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, constructorTypeIR, tid_inserted*{tid_inserted <- tid_inserted*}, id_default*{id_default <- id_default*})
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Inst_ok: `%%%|-%%%%%:%%%`(p, TC_0, `NAMED`_instctxt(), constructorTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_infer*{tid_infer <- tid_infer*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_object, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let TC_1 = $add_var(p, TC_0, name, `%%%%`_varTypeIR(`NO`_direction(), typeIR_object, `CTK`_ctk(), ?()))
      -- let instantiationIR = `InstD%%%%%%`_instantiationIR(typeIR_object, prefixedName, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR*{argumentIR <- argumentIR*}, name, ?())

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:169.1-208.73
   rule instantiation-nameT-objectInitializer: `%%|-%:%%`(p, TC_0, declaration, TC_2, instantiationIR as declarationIR)
      -- if declaration <: instantiation
      -- let `InstD%%%%`_instantiation(type, argument*{argument <- argument*}, name, objectInitializer?{objectInitializer <- objectInitializer?}) = declaration as instantiation
      -- if type <: nameType
      -- let `NameT%`_nameType(prefixedName) = type as nameType
      -- if objectInitializer?{objectInitializer <- objectInitializer?} matches (_)
      -- let ?(objectDeclaration*{objectDeclaration <- objectDeclaration*}) = objectInitializer?{objectInitializer <- objectInitializer?}
      -- (Argument_ok: `%%|-%:%`(p, TC_0, argument, argumentIR))*{argument <- argument*, argumentIR <- argumentIR*}
      -- ConstructorType_ok: `%%|-%%%:%%%`(p, TC_0, prefixedName, [], argumentIR*{argumentIR <- argumentIR*}, constructorTypeIR, tid_impl*{tid_impl <- tid_impl*}, id_default*{id_default <- id_default*})
      -- Inst_ok: `%%%|-%%%%%:%%%`(p, TC_0, `NAMED`_instctxt(), constructorTypeIR, [], tid_impl*{tid_impl <- tid_impl*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_object, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if $is_extern_object_typeIR($canon(typeIR_object))
      -- let typeIR' = typeIR_object
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(`PolyTD%%%`_polyTypeDefIR(typeIR, tid_expl*{tid_expl <- tid_expl*}, tid'*{tid' <- tid'*}), typeIR_arg*{typeIR_arg <- typeIR_arg*}) = namedTypeIR
      -- if typeIR <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(tid_extern, rdenv_extern) = typeIR as externObjectTypeIR
      -- if (tid'*{tid' <- tid'*} = tid_impl*{tid_impl <- tid_impl*})
      -- let TC_1 = $add_var(`LOCAL`_cursor(), TC_0, "this", `%%%%`_varTypeIR(`NO`_direction(), typeIR_object, `CTK`_ctk(), ?()))
      -- Decls_object_ok: `%%%%|-%:%%%`(p, TC_1, `{%}`_set<pair<id, varTypeIR>>([]), `{%}`_set<pair<rid, routineTypeDefIR>>([]), objectDeclaration*{objectDeclaration <- objectDeclaration*}, frame_init, rdenv_init, objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*})
      -- let tid*{tid <- tid*} = tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}
      -- let theta = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid, typeIR_arg)*{tid <- tid*, typeIR_arg <- typeIR_arg*})
      -- let rdenv_init_subst = $subst_rdenv(theta, rdenv_extern, rdenv_init)
      -- let typeIR_object_init = `SpecT%%`_namedTypeIR(`PolyTD%%%`_polyTypeDefIR(`ExternT%%`_externObjectTypeIR(tid_extern, rdenv_init_subst) as typeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}), typeIR_arg*{typeIR_arg <- typeIR_arg*}) as typeIR
      -- if $is_concrete_extern_object(typeIR_object_init)
      -- let TC_2 = $add_var(p, TC_0, name, `%%%%`_varTypeIR(`NO`_direction(), typeIR_object_init, `CTK`_ctk(), ?()))
      -- let instantiationIR = `InstD%%%%%%`_instantiationIR(typeIR_object_init, prefixedName, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR*{argumentIR <- argumentIR*}, name, ?(objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*}))

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:210.1-253.73
   rule instantiation-specT-objectInitializer: `%%|-%:%%`(p, TC_0, declaration, TC_2, instantiationIR as declarationIR)
      -- if declaration <: instantiation
      -- let `InstD%%%%`_instantiation(type, argument*{argument <- argument*}, name, objectInitializer?{objectInitializer <- objectInitializer?}) = declaration as instantiation
      -- if type <: specializedType
      -- let `SpecT%%`_specializedType(prefixedName, typeArgument*{typeArgument <- typeArgument*}) = type as specializedType
      -- if objectInitializer?{objectInitializer <- objectInitializer?} matches (_)
      -- let ?(objectDeclaration*{objectDeclaration <- objectDeclaration*}) = objectInitializer?{objectInitializer <- objectInitializer?}
      -- TypeArguments_ok: `%%|-%:%%`(p, TC_0, typeArgument*{typeArgument <- typeArgument*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (Argument_ok: `%%|-%:%`(p, TC_0, argument, argumentIR))*{argument <- argument*, argumentIR <- argumentIR*}
      -- ConstructorType_ok: `%%|-%%%:%%%`(p, TC_0, prefixedName, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, constructorTypeIR, tid_inserted*{tid_inserted <- tid_inserted*}, id_default*{id_default <- id_default*})
      -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
      -- Inst_ok: `%%%|-%%%%%:%%%`(p, TC_0, `NAMED`_instctxt(), constructorTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_infer*{tid_infer <- tid_infer*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_object, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if $is_extern_object_typeIR($canon(typeIR_object))
      -- let typeIR' = typeIR_object
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR = typeIR' as namedTypeIR
      -- if namedTypeIR matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(`PolyTD%%%`_polyTypeDefIR(typeIR, tid_expl*{tid_expl <- tid_expl*}, tid'*{tid' <- tid'*}), typeIR_arg*{typeIR_arg <- typeIR_arg*}) = namedTypeIR
      -- if typeIR <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(tid_extern, rdenv_extern) = typeIR as externObjectTypeIR
      -- if (tid'*{tid' <- tid'*} = tid_impl*{tid_impl <- tid_impl*})
      -- let TC_1 = $add_var(`LOCAL`_cursor(), TC_0, "this", `%%%%`_varTypeIR(`NO`_direction(), typeIR_object, `CTK`_ctk(), ?()))
      -- Decls_object_ok: `%%%%|-%:%%%`(p, TC_1, `{%}`_set<pair<id, varTypeIR>>([]), `{%}`_set<pair<rid, routineTypeDefIR>>([]), objectDeclaration*{objectDeclaration <- objectDeclaration*}, frame_init, rdenv_init, objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*})
      -- let tid*{tid <- tid*} = tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}
      -- let theta = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid, typeIR_arg)*{tid <- tid*, typeIR_arg <- typeIR_arg*})
      -- let rdenv_init_subst = $subst_rdenv(theta, rdenv_extern, rdenv_init)
      -- let typeIR_object_init = `SpecT%%`_namedTypeIR(`PolyTD%%%`_polyTypeDefIR(`ExternT%%`_externObjectTypeIR(tid_extern, rdenv_init_subst) as typeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}), typeIR_arg*{typeIR_arg <- typeIR_arg*}) as typeIR
      -- if $is_concrete_extern_object(typeIR_object_init)
      -- let TC_2 = $add_var(p, TC_0, name, `%%%%`_varTypeIR(`NO`_direction(), typeIR_object_init, `CTK`_ctk(), ?()))
      -- let instantiationIR = `InstD%%%%%%`_instantiationIR(typeIR_object_init, prefixedName, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR*{argumentIR <- argumentIR*}, name, ?(objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*}))

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:259.1-285.60
   rule functionDeclaration: `%%|-%:%%`(p, TC_0, declaration, TC_4, functionDeclarationIR as declarationIR)
      -- if declaration <: functionDeclaration
      -- let `FuncD%%%%%`_functionDeclaration(typeOrVoid, name, typeParameter*{typeParameter <- typeParameter*}, parameter*{parameter <- parameter*}, blockStatement) = declaration as functionDeclaration
      -- (let tid_expl = typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(`LOCAL`_cursor(), TC_0, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_1, typeOrVoid, typeIR_ret, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- Parameters_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_1, parameter*{parameter <- parameter*}, parameterIR*{parameterIR <- parameterIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_2 = $add_parameters(`LOCAL`_cursor(), TC_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let TC_3 = TC_2[LOCAL.KIND = `FUNC%`_localKind(typeIR_ret)]
      -- Block_ok: `%%|-%:%%%`(TC_3, `CONT`_flow(), blockStatement, _typingContext, f, blockStatementIR)
      -- if ((f = `RET`_flow()) \/ (typeIR_ret = `VoidT`_primitiveTypeIR() as typeIR))
      -- let rid = $rid(name, parameter*{parameter <- parameter*})
      -- let routineTypeIR = `FuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret)
      -- let routineTypeDefIR = `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR
      -- if RoutineTypeDef_wf: `%|-%`($bound(p, TC_0), routineTypeDefIR) holds
      -- let TC_4 = $add_routine_overload(p, TC_0, rid, routineTypeDefIR)
      -- let functionDeclarationIR = `FuncD%%%%%%`_functionDeclarationIR(typeIR_ret, name, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}, parameterIR*{parameterIR <- parameterIR*}, blockStatementIR)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:290.1-309.51
   rule actionDeclaration: `%%|-%:%%`(p, TC_0, declaration, TC_3, actionDeclarationIR as declarationIR)
      -- if declaration <: actionDeclaration
      -- let `ActionD%%%`_actionDeclaration(name, parameter*{parameter <- parameter*}, blockStatement) = declaration as actionDeclaration
      -- let TC_1 = TC_0[LOCAL.KIND = `ACTION`_localKind()]
      -- Parameters_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_1, parameter*{parameter <- parameter*}, parameterIR*{parameterIR <- parameterIR*}, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_2 = $add_parameters(`LOCAL`_cursor(), TC_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- Block_ok: `%%|-%:%%%`(TC_2, `CONT`_flow(), blockStatement, _typingContext, _flow, blockStatementIR)
      -- let rid = $rid(name, parameter*{parameter <- parameter*})
      -- let routineTypeIR = `ActionT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- if RoutineTypeDef_wf: `%|-%`($bound(p, TC_0), `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) as routineTypeDefIR) holds
      -- let TC_3 = $add_routine_non_overload(p, TC_0, rid, `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) as routineTypeDefIR)
      -- let actionDeclarationIR = `ActionD%%%`_actionDeclarationIR(name, parameterIR*{parameterIR <- parameterIR*}, blockStatementIR)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:314.1-321.81
   rule errorDeclaration: `%%|-%:%%`(cursor, TC_0, declaration, TC_1, `ErrD%`_errorDeclaration(name*{name <- name*}) as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: errorDeclaration
      -- let `ErrD%`_errorDeclaration(name*{name <- name*}) = declaration as errorDeclaration
      -- if $distinct_<name>(name*{name <- name*})
      -- (let name_error = "error." ++ name)*{name <- name*, name_error <- name_error*}
      -- (let value_error = `ErrV%`_primitiveValue(name) as value)*{name <- name*, value_error <- value_error*}
      -- let TC_1 = $add_vars(`GLOBAL`_cursor(), TC_0, name_error*{name_error <- name_error*}, `%%%%`_varTypeIR(`NO`_direction(), `ErrT`_primitiveTypeIR() as typeIR, `LCTK`_ctk(), ?(value_error))*{value_error <- value_error*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:326.1-332.86
   rule matchKindDeclaration: `%%|-%:%%`(cursor, TC_0, declaration, TC_1, `MatchKindD%`_matchKindDeclaration(name*{name <- name*}) as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: matchKindDeclaration
      -- let `MatchKindD%`_matchKindDeclaration(name*{name <- name*}) = declaration as matchKindDeclaration
      -- if $distinct_<name>(name*{name <- name*})
      -- (let value_match_kind = `MatchKindV%`_primitiveValue(name) as value)*{name <- name*, value_match_kind <- value_match_kind*}
      -- let TC_1 = $add_vars(`GLOBAL`_cursor(), TC_0, name*{name <- name*}, `%%%%`_varTypeIR(`NO`_direction(), `MatchKindT`_primitiveTypeIR() as typeIR, `LCTK`_ctk(), ?(value_match_kind))*{value_match_kind <- value_match_kind*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:341.1-363.69
   rule externDeclaration-externFunctionDeclaration: `%%|-%:%%`(cursor, TC_0, declaration, TC_4, externFunctionDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: externFunctionDeclaration
      -- let `ExternFuncD%%%%`_externFunctionDeclaration(typeOrVoid, name, typeParameter*{typeParameter <- typeParameter*}, parameter*{parameter <- parameter*}) = declaration as externFunctionDeclaration
      -- (let tid_expl = typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(`LOCAL`_cursor(), TC_0, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_1, typeOrVoid, typeIR_ret, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- let TC_2 = TC_1[LOCAL.KIND = `EXTERNFUNC%`_localKind(typeIR_ret)]
      -- Parameters_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_2, parameter*{parameter <- parameter*}, parameterIR*{parameterIR <- parameterIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_3 = $add_parameters(`LOCAL`_cursor(), TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let rid = $rid(name, parameter*{parameter <- parameter*})
      -- let routineTypeIR = `ExternFuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret)
      -- let routineTypeDefIR = `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR
      -- if RoutineTypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), routineTypeDefIR) holds
      -- let TC_4 = $add_routine_overload(`GLOBAL`_cursor(), TC_0, rid, routineTypeDefIR)
      -- let externFunctionDeclarationIR = `ExternFuncD%%%%%`_externFunctionDeclarationIR(typeIR_ret, name, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}, parameterIR*{parameterIR <- parameterIR*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:391.1-420.71
   rule externDeclaration-externObjectDeclaration: `%%|-%:%%`(cursor, TC_0, declaration, TC_8, externObjectDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: externObjectDeclaration
      -- let `ExternObjectD%%%`_externObjectDeclaration(name, typeParameter*{typeParameter <- typeParameter*}, methodPrototype*{methodPrototype <- methodPrototype*}) = declaration as externObjectDeclaration
      -- let (methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*}, methodPrototype_method*{methodPrototype_method <- methodPrototype_method*}) = $split_constructors(methodPrototype*{methodPrototype <- methodPrototype*})
      -- let TC_1 = TC_0[BLOCK.KIND = `EXTERN`_blockKind()]
      -- (let tid_expl = typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_2 = $add_types(`BLOCK`_cursor(), TC_1, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- ExternMethods_ok: `%%|-%:%%`(TC_2, name, methodPrototype_method*{methodPrototype_method <- methodPrototype_method*}, TC_3, methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*})
      -- let typeIR_extern = `ExternT%%`_externObjectTypeIR(name, TC_3.BLOCK.RDENV) as typeIR
      -- let typeDefIR_extern = `PolyTD%%%`_polyTypeDefIR(typeIR_extern, tid_expl*{tid_expl <- tid_expl*}, []) as typeDefIR
      -- let TC_4 = $add_type(`GLOBAL`_cursor(), TC_0, name, typeDefIR_extern)
      -- let TC_5 = TC_4[BLOCK.KIND = `EXTERN`_blockKind()]
      -- let TC_6 = $add_types(`BLOCK`_cursor(), TC_5, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- ExternConstructors_ok: `%%|-%:%%`(TC_6, name, methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*}, TC_7, methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*})
      -- let TC_8 = TC_4[GLOBAL.CDENV = TC_7.GLOBAL.CDENV]
      -- let externObjectDeclarationIR = `ExternObjectD%%%`_externObjectDeclarationIR(name, tid_expl*{tid_expl <- tid_expl*}, methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*} ++ methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:428.1-469.51
   rule parserDeclaration: `%%|-%:%%`(cursor, TC_0, declaration, TC_6, parserDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: parserDeclaration
      -- let `ParserD%%%%%%`_parserDeclaration(name, typeParameter*{typeParameter <- typeParameter*}, parameter*{parameter <- parameter*}, constructorParameter*{constructorParameter <- constructorParameter*}, parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}, parserState*{parserState <- parserState*}) = declaration as parserDeclaration
      -- if typeParameter*{typeParameter <- typeParameter*} matches []
      -- let TC_1 = TC_0[BLOCK.KIND = `PARSER`_blockKind()]
      -- ConstructorParameters_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_1, constructorParameter*{constructorParameter <- constructorParameter*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let TC_2 = $add_parameters(`BLOCK`_cursor(), TC_1, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*})
      -- Parameters_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_2, parameter*{parameter <- parameter*}, parameterIR*{parameterIR <- parameterIR*}, tid'*{tid' <- tid'*})
      -- if tid'*{tid' <- tid'*} matches []
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_3 = $add_parameters(`BLOCK`_cursor(), TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- ParserLocalDecls_ok: `%|-%:%%`(TC_3, parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}, TC_4, parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*})
      -- let TC_5 = TC_4[LOCAL.KIND = `PARSERSTATE`_localKind()]
      -- ParserStates_ok: `%|-%:%`(TC_5, parserState*{parserState <- parserState*}, parserStateIR*{parserStateIR <- parserStateIR*})
      -- let routineTypeIR = `ParserApplyMethodT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- if RoutineTypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) as routineTypeDefIR) holds
      -- let cid = $cid(name, constructorParameter*{constructorParameter <- constructorParameter*})
      -- let typeIR_parser = `ParserT%`_parserObjectTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) as typeIR
      -- let typeIR_parser_spec = `SpecT%%`_namedTypeIR(`PolyTD%%%`_polyTypeDefIR(typeIR_parser, [], []), []) as typeIR
      -- let constructorTypeIR = `ConstructorT%%`_constructorTypeIR(constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*}, typeIR_parser_spec)
      -- let constructorTypeDefIR = `PolyTD%%%`_constructorTypeDefIR(constructorTypeIR, [], [])
      -- if ConstructorTypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), constructorTypeDefIR) holds
      -- let TC_6 = $add_constructor(TC_0, cid, constructorTypeDefIR)
      -- let parserDeclarationIR = `ParserD%%%%%%`_parserDeclarationIR(name, [], parameterIR*{parameterIR <- parameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}, parserStateIR*{parserStateIR <- parserStateIR*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:477.1-518.51
   rule controlDeclaration: `%%|-%:%%`(cursor, TC_0, declaration, TC_6, controlDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: controlDeclaration
      -- let `ControlD%%%%%%`_controlDeclaration(name, typeParameter*{typeParameter <- typeParameter*}, parameter*{parameter <- parameter*}, constructorParameter*{constructorParameter <- constructorParameter*}, controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}, controlBody) = declaration as controlDeclaration
      -- if typeParameter*{typeParameter <- typeParameter*} matches []
      -- let TC_1 = TC_0[BLOCK.KIND = `CONTROL`_blockKind()]
      -- ConstructorParameters_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_1, constructorParameter*{constructorParameter <- constructorParameter*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- let TC_2 = $add_parameters(`BLOCK`_cursor(), TC_1, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*})
      -- Parameters_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_2, parameter*{parameter <- parameter*}, parameterIR*{parameterIR <- parameterIR*}, tid'*{tid' <- tid'*})
      -- if tid'*{tid' <- tid'*} matches []
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_3 = $add_parameters(`BLOCK`_cursor(), TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- ControlLocalDecls_ok: `%|-%:%%`(TC_3, controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}, TC_4, controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*})
      -- let TC_5 = TC_4[LOCAL.KIND = `CONTROLAPPLYMETHOD`_localKind()]
      -- Block_ok: `%%|-%:%%%`(TC_5, `CONT`_flow(), controlBody, _typingContext, _flow, controlBodyIR)
      -- let routineTypeIR = `ControlApplyMethodT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- if RoutineTypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) as routineTypeDefIR) holds
      -- let cid = $cid(name, constructorParameter*{constructorParameter <- constructorParameter*})
      -- let typeIR_control = `ControlT%`_controlObjectTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) as typeIR
      -- let typeIR_control_spec = `SpecT%%`_namedTypeIR(`PolyTD%%%`_polyTypeDefIR(typeIR_control, [], []), []) as typeIR
      -- let constructorTypeIR = `ConstructorT%%`_constructorTypeIR(constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*}, typeIR_control_spec)
      -- let constructorTypeDefIR = `PolyTD%%%`_constructorTypeDefIR(constructorTypeIR, [], [])
      -- if ConstructorTypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), constructorTypeDefIR) holds
      -- let TC_6 = $add_constructor(TC_0, cid, constructorTypeDefIR)
      -- let controlDeclarationIR = `ControlD%%%%%%`_controlDeclarationIR(name, [], parameterIR*{parameterIR <- parameterIR*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}, controlBodyIR)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:531.1-544.55
   rule typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration-enumD: `%%|-%:%%`(cursor, TC_0, declaration, TC_2, enumTypeDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: enumTypeDeclaration
      -- let enumTypeDeclaration = declaration as enumTypeDeclaration
      -- if enumTypeDeclaration matches `EnumD%%`
      -- let `EnumD%%`_enumTypeDeclaration(name, name_field*{name_field <- name_field*}) = enumTypeDeclaration
      -- let typeIR_enum = `EnumT%%`_enumTypeIR(name, name_field*{name_field <- name_field*}) as typeIR
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), `MonoTD%`_monoTypeDefIR(typeIR_enum) as typeDefIR) holds
      -- let TC_1 = $add_type(`GLOBAL`_cursor(), TC_0, name, `MonoTD%`_monoTypeDefIR(typeIR_enum) as typeDefIR)
      -- (let id_field = name ++ "." ++ name_field)*{id_field <- id_field*, name_field <- name_field*}
      -- (let value_field = `EnumV%%`_enumValue(name, name_field) as value)*{name_field <- name_field*, value_field <- value_field*}
      -- let TC_2 = $add_vars(`GLOBAL`_cursor(), TC_1, id_field*{id_field <- id_field*}, `%%%%`_varTypeIR(`NO`_direction(), typeIR_enum, `LCTK`_ctk(), ?(value_field))*{value_field <- value_field*})
      -- let enumTypeDeclarationIR = `EnumD%%`_enumTypeDeclarationIR(name, name_field*{name_field <- name_field*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:589.1-610.52
   rule typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration-senumD: `%%|-%:%%`(cursor, TC_0, declaration, TC_3, enumTypeDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: enumTypeDeclaration
      -- let enumTypeDeclaration = declaration as enumTypeDeclaration
      -- if enumTypeDeclaration matches `SEnumD%%%`
      -- let `SEnumD%%%`_enumTypeDeclaration(type, name, namedExpression_field*{namedExpression_field <- namedExpression_field*}) = enumTypeDeclaration
      -- Type_ok: `%%|-%:%%`(`GLOBAL`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), typeIR) holds
      -- Enum_serializable_fields_ok: `%%%|-%:%%%`(TC_0, name, typeIR, namedExpression_field*{namedExpression_field <- namedExpression_field*}, TC_1, namedExpressionIR_field*{namedExpressionIR_field <- namedExpressionIR_field*}, value_field*{value_field <- value_field*})
      -- (let `%%`_namedExpressionIR(name_field, _typedExpressionIR) = namedExpressionIR_field)*{_typedExpressionIR <- _typedExpressionIR*, name_field <- name_field*, namedExpressionIR_field <- namedExpressionIR_field*}
      -- (let id_field = name ++ "." ++ name_field)*{id_field <- id_field*, name_field <- name_field*}
      -- let typeIR_enum = `SEnumT%%%`_enumTypeIR(name, typeIR, `%%`_valueFieldIR(name_field, value_field)*{name_field <- name_field*, value_field <- value_field*}) as typeIR
      -- let TC_2 = $add_vars(`GLOBAL`_cursor(), TC_0, id_field*{id_field <- id_field*}, `%%%%`_varTypeIR(`NO`_direction(), typeIR_enum, `LCTK`_ctk(), ?(value_field))*{value_field <- value_field*})
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), `MonoTD%`_monoTypeDefIR(typeIR_enum) as typeDefIR) holds
      -- let TC_3 = $add_type(`GLOBAL`_cursor(), TC_2, name, `MonoTD%`_monoTypeDefIR(typeIR_enum) as typeDefIR)
      -- let enumTypeDeclarationIR = `SEnumD%%%`_enumTypeDeclarationIR(typeIR, name, namedExpressionIR_field*{namedExpressionIR_field <- namedExpressionIR_field*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:616.1-633.68
   rule typeDeclaration-derivedTypeDeclaration-structTypeDeclaration: `%%|-%:%%`(cursor, TC_0, declaration, TC_2, structTypeDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: structTypeDeclaration
      -- let `StructD%%%`_structTypeDeclaration(name, typeParameter*{typeParameter <- typeParameter*}, typeField*{typeField <- typeField*}) = declaration as structTypeDeclaration
      -- (let tid_expl = typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(`BLOCK`_cursor(), TC_0, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- (let `%%`_typeField(type_field, name_field) = typeField)*{name_field <- name_field*, typeField <- typeField*, type_field <- type_field*}
      -- (Type_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_1, type_field as typeOrVoid, typeIR_field, tid_impl_field*{tid_impl_field <- tid_impl_field*}))*{tid_impl_field* <- tid_impl_field**, typeIR_field <- typeIR_field*, type_field <- type_field*}
      -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_field*{tid_impl_field <- tid_impl_field*}*{tid_impl_field* <- tid_impl_field**})
      -- let typeIR_struct = `StructT%%`_structTypeIR(name, `%%`_fieldTypeIR(typeIR_field, name_field)*{name_field <- name_field*, typeIR_field <- typeIR_field*}) as typeIR
      -- let typeDefIR_struct = `PolyTD%%%`_polyTypeDefIR(typeIR_struct, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) as typeDefIR
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), typeDefIR_struct) holds
      -- let TC_2 = $add_type(`GLOBAL`_cursor(), TC_0, name, typeDefIR_struct)
      -- let structTypeDeclarationIR = `StructD%%%%`_structTypeDeclarationIR(name, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}, `%%`_typeFieldIR(typeIR_field, name_field)*{name_field <- name_field*, typeIR_field <- typeIR_field*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:639.1-656.68
   rule typeDeclaration-derivedTypeDeclaration-headerTypeDeclaration: `%%|-%:%%`(cursor, TC_0, declaration, TC_2, headerTypeDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: headerTypeDeclaration
      -- let `HeaderD%%%`_headerTypeDeclaration(name, typeParameter*{typeParameter <- typeParameter*}, typeField*{typeField <- typeField*}) = declaration as headerTypeDeclaration
      -- (let tid_expl = typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(`BLOCK`_cursor(), TC_0, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- (let `%%`_typeField(type_field, name_field) = typeField)*{name_field <- name_field*, typeField <- typeField*, type_field <- type_field*}
      -- (Type_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_1, type_field as typeOrVoid, typeIR_field, tid_impl_field*{tid_impl_field <- tid_impl_field*}))*{tid_impl_field* <- tid_impl_field**, typeIR_field <- typeIR_field*, type_field <- type_field*}
      -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_field*{tid_impl_field <- tid_impl_field*}*{tid_impl_field* <- tid_impl_field**})
      -- let typeIR_struct = `HeaderT%%`_headerTypeIR(name, `%%`_fieldTypeIR(typeIR_field, name_field)*{name_field <- name_field*, typeIR_field <- typeIR_field*}) as typeIR
      -- let typeDefIR_struct = `PolyTD%%%`_polyTypeDefIR(typeIR_struct, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) as typeDefIR
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), typeDefIR_struct) holds
      -- let TC_2 = $add_type(`GLOBAL`_cursor(), TC_0, name, typeDefIR_struct)
      -- let headerTypeDeclarationIR = `HeaderD%%%%`_headerTypeDeclarationIR(name, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}, `%%`_typeFieldIR(typeIR_field, name_field)*{name_field <- name_field*, typeIR_field <- typeIR_field*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:662.1-679.73
   rule typeDeclaration-derivedTypeDeclaration-headerUnionTypeDeclaration: `%%|-%:%%`(cursor, TC_0, declaration, TC_2, headerUnionTypeDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: headerUnionTypeDeclaration
      -- let `HeaderUnionD%%%`_headerUnionTypeDeclaration(name, typeParameter*{typeParameter <- typeParameter*}, typeField*{typeField <- typeField*}) = declaration as headerUnionTypeDeclaration
      -- (let tid_expl = typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_1 = $add_types(`BLOCK`_cursor(), TC_0, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- (let `%%`_typeField(type_field, name_field) = typeField)*{name_field <- name_field*, typeField <- typeField*, type_field <- type_field*}
      -- (Type_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_1, type_field as typeOrVoid, typeIR_field, tid_impl_field*{tid_impl_field <- tid_impl_field*}))*{tid_impl_field* <- tid_impl_field**, typeIR_field <- typeIR_field*, type_field <- type_field*}
      -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_field*{tid_impl_field <- tid_impl_field*}*{tid_impl_field* <- tid_impl_field**})
      -- let typeIR_struct = `HeaderUnionT%%`_headerUnionTypeIR(name, `%%`_fieldTypeIR(typeIR_field, name_field)*{name_field <- name_field*, typeIR_field <- typeIR_field*}) as typeIR
      -- let typeDefIR_struct = `PolyTD%%%`_polyTypeDefIR(typeIR_struct, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) as typeDefIR
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), typeDefIR_struct) holds
      -- let TC_2 = $add_type(`GLOBAL`_cursor(), TC_0, name, typeDefIR_struct)
      -- let headerUnionTypeDeclarationIR = `HeaderUnionD%%%%`_headerUnionTypeDeclarationIR(name, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}, `%%`_typeFieldIR(typeIR_field, name_field)*{name_field <- name_field*, typeIR_field <- typeIR_field*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:689.1-703.61
   rule typeDeclaration-typedefDeclaration-typdefD-plainT-non-extern-package: `%%|-%:%%`(cursor, TC_0, declaration, TC_1, typedefDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `TypeDefD%%`
      -- let `TypeDefD%%`_typedefDeclaration(typedefType, name) = typedefDeclaration
      -- if typedefType matches `PlainT%`
      -- let `PlainT%`_typedefType(type) = typedefType
      -- Type_ok: `%%|-%:%%`(`GLOBAL`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), typeIR) holds
      -- if ~($is_extern_object_typeIR($canon(typeIR)) \/ $is_package_object_typeIR($canon(typeIR)))
      -- let typeIR_typedef = `DefT%%`_aliasTypeIR(name, typeIR) as typeIR
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), `MonoTD%`_monoTypeDefIR(typeIR_typedef) as typeDefIR) holds
      -- let TC_1 = $add_type(`GLOBAL`_cursor(), TC_0, name, `MonoTD%`_monoTypeDefIR(typeIR_typedef) as typeDefIR)
      -- let typedefDeclarationIR = `TypeDefD%%`_typedefDeclarationIR(`PlainT%`_typedefTypeIR(typeIR), name)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:705.1-732.61
   rule typeDeclaration-typedefDeclaration-typdefD-plainT-extern: `%%|-%:%%`(cursor, TC_0, declaration, TC_2, typedefDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `TypeDefD%%`
      -- let `TypeDefD%%`_typedefDeclaration(typedefType, name) = typedefDeclaration
      -- if typedefType matches `PlainT%`
      -- let `PlainT%`_typedefType(type) = typedefType
      -- Type_ok: `%%|-%:%%`(`GLOBAL`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), typeIR) holds
      -- let typeIR' = $canon(typeIR)
      -- if typeIR' <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(tid_alias, _map<rid, routineTypeDefIR>) = typeIR' as externObjectTypeIR
      -- let typeIR'' = typeIR
      -- if typeIR'' <: namedTypeIR
      -- let namedTypeIR = typeIR'' as namedTypeIR
      -- if namedTypeIR matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(_polyTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = namedTypeIR
      -- let typeIR_typedef = `DefT%%`_aliasTypeIR(name, typeIR) as typeIR
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), `MonoTD%`_monoTypeDefIR(typeIR_typedef) as typeDefIR) holds
      -- let TC_1 = $add_type(`GLOBAL`_cursor(), TC_0, name, `MonoTD%`_monoTypeDefIR(typeIR_typedef) as typeDefIR)
      -- let (cid, constructorTypeDefIR)*{cid <- cid*, constructorTypeDefIR <- constructorTypeDefIR*} = $find_constructors_non_overloaded(TC_0, `CURRENT%`_prefixedName(tid_alias))
      -- (let `%%`_rid(_id, pid*{pid <- pid*}) = cid)*{_id <- _id*, cid <- cid*, pid* <- pid**}
      -- (let cid_alias = `%%`_rid(name, pid*{pid <- pid*}))*{cid_alias <- cid_alias*, pid* <- pid**}
      -- (let `PolyTD%%%`_constructorTypeDefIR(`ConstructorT%%`_constructorTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, _typeIR), tid_expl*{tid_expl <- tid_expl*}, tid'*{tid' <- tid'*}) = constructorTypeDefIR)*{_typeIR <- _typeIR*, constructorTypeDefIR <- constructorTypeDefIR*, parameterTypeIR* <- parameterTypeIR**, tid'* <- tid'**, tid_expl* <- tid_expl**}
      -- (if tid'*{tid' <- tid'*} matches [])*{tid'* <- tid'**}
      -- (let theta = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid_expl, typeIR_arg)*{tid_expl <- tid_expl*, typeIR_arg <- typeIR_arg*}))*{theta <- theta*, tid_expl* <- tid_expl**}
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*, theta <- theta*}*{parameterTypeIR* <- parameterTypeIR**, parameterTypeIR_subst* <- parameterTypeIR_subst**}
      -- (let constructorTypeDefIR_alias = `PolyTD%%%`_constructorTypeDefIR(`ConstructorT%%`_constructorTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}, typeIR), [], []))*{constructorTypeDefIR_alias <- constructorTypeDefIR_alias*, parameterTypeIR_subst* <- parameterTypeIR_subst**}
      -- let TC_2 = $add_constructors(TC_1, cid_alias*{cid_alias <- cid_alias*}, constructorTypeDefIR_alias*{constructorTypeDefIR_alias <- constructorTypeDefIR_alias*})
      -- let typedefDeclarationIR = `TypeDefD%%`_typedefDeclarationIR(`PlainT%`_typedefTypeIR(typeIR), name)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:734.1-761.61
   rule typeDeclaration-typedefDeclaration-typdefD-plainT-package: `%%|-%:%%`(cursor, TC_0, declaration, TC_2, typedefDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `TypeDefD%%`
      -- let `TypeDefD%%`_typedefDeclaration(typedefType, name) = typedefDeclaration
      -- if typedefType matches `PlainT%`
      -- let `PlainT%`_typedefType(type) = typedefType
      -- Type_ok: `%%|-%:%%`(`GLOBAL`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), typeIR) holds
      -- let typeIR' = $canon(typeIR)
      -- if typeIR' <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(tid_alias, _typeIR*{_typeIR <- _typeIR*}) = typeIR' as packageObjectTypeIR
      -- let typeIR'' = typeIR
      -- if typeIR'' <: namedTypeIR
      -- let namedTypeIR = typeIR'' as namedTypeIR
      -- if namedTypeIR matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(_polyTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = namedTypeIR
      -- let typeIR_typedef = `DefT%%`_aliasTypeIR(name, typeIR) as typeIR
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), `MonoTD%`_monoTypeDefIR(typeIR_typedef) as typeDefIR) holds
      -- let TC_1 = $add_type(`GLOBAL`_cursor(), TC_0, name, `MonoTD%`_monoTypeDefIR(typeIR_typedef) as typeDefIR)
      -- let (cid, constructorTypeDefIR)*{cid <- cid*, constructorTypeDefIR <- constructorTypeDefIR*} = $find_constructors_non_overloaded(TC_0, `CURRENT%`_prefixedName(tid_alias))
      -- (let `%%`_rid(_id, pid*{pid <- pid*}) = cid)*{_id <- _id*, cid <- cid*, pid* <- pid**}
      -- (let cid_alias = `%%`_rid(name, pid*{pid <- pid*}))*{cid_alias <- cid_alias*, pid* <- pid**}
      -- (let `PolyTD%%%`_constructorTypeDefIR(`ConstructorT%%`_constructorTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, _typeIR'), tid_expl*{tid_expl <- tid_expl*}, tid'*{tid' <- tid'*}) = constructorTypeDefIR)*{_typeIR' <- _typeIR'*, constructorTypeDefIR <- constructorTypeDefIR*, parameterTypeIR* <- parameterTypeIR**, tid'* <- tid'**, tid_expl* <- tid_expl**}
      -- (if tid'*{tid' <- tid'*} matches [])*{tid'* <- tid'**}
      -- (let theta = `{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid_expl, typeIR_arg)*{tid_expl <- tid_expl*, typeIR_arg <- typeIR_arg*}))*{theta <- theta*, tid_expl* <- tid_expl**}
      -- (let parameterTypeIR_subst = $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*, theta <- theta*}*{parameterTypeIR* <- parameterTypeIR**, parameterTypeIR_subst* <- parameterTypeIR_subst**}
      -- (let constructorTypeDefIR_alias = `PolyTD%%%`_constructorTypeDefIR(`ConstructorT%%`_constructorTypeIR(parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}, typeIR), [], []))*{constructorTypeDefIR_alias <- constructorTypeDefIR_alias*, parameterTypeIR_subst* <- parameterTypeIR_subst**}
      -- let TC_2 = $add_constructors(TC_1, cid_alias*{cid_alias <- cid_alias*}, constructorTypeDefIR_alias*{constructorTypeDefIR_alias <- constructorTypeDefIR_alias*})
      -- let typedefDeclarationIR = `TypeDefD%%`_typedefDeclarationIR(`PlainT%`_typedefTypeIR(typeIR), name)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:765.1-782.58
   rule typeDeclaration-typedefDeclaration-typedefD-derivedT-mono: `%%|-%:%%`(cursor, TC_0, declaration, TC_1, typedefDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `TypeDefD%%`
      -- let `TypeDefD%%`_typedefDeclaration(typedefType, name) = typedefDeclaration
      -- if typedefType matches `DerivedT%`
      -- let `DerivedT%`_typedefType(derivedTypeDeclaration) = typedefType
      -- Decl_ok: `%%|-%:%%`(`GLOBAL`_cursor(), TC_0, derivedTypeDeclaration as declaration, TC_1, declarationIR)
      -- if declarationIR <: derivedTypeDeclarationIR
      -- let derivedTypeDeclarationIR = declarationIR as derivedTypeDeclarationIR
      -- let `{%}`_set<tid>(tid'*{tid' <- tid'*}) = $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.GLOBAL.TDENV), $dom_map<tid, typeDefIR>(TC_0.GLOBAL.TDENV))
      -- if tid'*{tid' <- tid'*} matches [ _/1 ]
      -- let [tid] = tid'*{tid' <- tid'*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(`GLOBAL`_cursor(), TC_1, `CURRENT%`_prefixedName(tid))
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: monoTypeDefIR
      -- let `MonoTD%`_monoTypeDefIR(typeIR) = typeDefIR as monoTypeDefIR
      -- let typeIR_typedef = `DefT%%`_aliasTypeIR(name, typeIR) as typeIR
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), `MonoTD%`_monoTypeDefIR(typeIR_typedef) as typeDefIR) holds
      -- let TC_2 = $add_type(`GLOBAL`_cursor(), TC_0, name, `MonoTD%`_monoTypeDefIR(typeIR_typedef) as typeDefIR)
      -- let typedefDeclarationIR = `TypeDefD%%`_typedefDeclarationIR(`DerivedT%`_typedefTypeIR(derivedTypeDeclarationIR), name)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:784.1-801.58
   rule typeDeclaration-typedefDeclaration-typedefD-derivedT-poly: `%%|-%:%%`(cursor, TC_0, declaration, TC_1, typedefDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `TypeDefD%%`
      -- let `TypeDefD%%`_typedefDeclaration(typedefType, name) = typedefDeclaration
      -- if typedefType matches `DerivedT%`
      -- let `DerivedT%`_typedefType(derivedTypeDeclaration) = typedefType
      -- Decl_ok: `%%|-%:%%`(`GLOBAL`_cursor(), TC_0, derivedTypeDeclaration as declaration, TC_1, declarationIR)
      -- if declarationIR <: derivedTypeDeclarationIR
      -- let derivedTypeDeclarationIR = declarationIR as derivedTypeDeclarationIR
      -- let `{%}`_set<tid>(tid'*{tid' <- tid'*}) = $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.GLOBAL.TDENV), $dom_map<tid, typeDefIR>(TC_0.GLOBAL.TDENV))
      -- if tid'*{tid' <- tid'*} matches [ _/1 ]
      -- let [tid] = tid'*{tid' <- tid'*}
      -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(`GLOBAL`_cursor(), TC_1, `CURRENT%`_prefixedName(tid))
      -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
      -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
      -- if typeDefIR <: polyTypeDefIR
      -- let `PolyTD%%%`_polyTypeDefIR(typeIR, tid''*{tid'' <- tid''*}, tid'''*{tid''' <- tid'''*}) = typeDefIR as polyTypeDefIR
      -- if tid''*{tid'' <- tid''*} matches []
      -- if tid'''*{tid''' <- tid'''*} matches []
      -- let typeIR_typedef = `DefT%%`_aliasTypeIR(name, `SpecT%%`_namedTypeIR(`PolyTD%%%`_polyTypeDefIR(typeIR, [], []), []) as typeIR) as typeIR
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), `MonoTD%`_monoTypeDefIR(typeIR_typedef) as typeDefIR) holds
      -- let TC_2 = $add_type(`GLOBAL`_cursor(), TC_0, name, `MonoTD%`_monoTypeDefIR(typeIR_typedef) as typeDefIR)
      -- let typedefDeclarationIR = `TypeDefD%%`_typedefDeclarationIR(`DerivedT%`_typedefTypeIR(derivedTypeDeclarationIR), name)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:805.1-816.52
   rule typeDeclaration-typedefDeclaration-newtypeD: `%%|-%:%%`(cursor, TC_0, declaration, TC_1, typedefDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: typedefDeclaration
      -- let typedefDeclaration = declaration as typedefDeclaration
      -- if typedefDeclaration matches `NewTypeD%%`
      -- let `NewTypeD%%`_typedefDeclaration(type, name) = typedefDeclaration
      -- Type_ok: `%%|-%:%%`(`GLOBAL`_cursor(), TC_0, type as typeOrVoid, typeIR, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- if Type_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), typeIR) holds
      -- let typeIR_newtype = `NewT%%`_aliasTypeIR(name, typeIR) as typeIR
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), `MonoTD%`_monoTypeDefIR(typeIR_newtype) as typeDefIR) holds
      -- let TC_1 = $add_type(`GLOBAL`_cursor(), TC_0, name, `MonoTD%`_monoTypeDefIR(typeIR_newtype) as typeDefIR)
      -- let typedefDeclarationIR = `NewTypeD%%`_typedefDeclarationIR(typeIR, name)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:821.1-839.58
   rule typeDeclaration-parserTypeDeclaration: `%%|-%:%%`(cursor, TC_0, declaration, TC_3, parserTypeDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: parserTypeDeclaration
      -- let `ParserTypeD%%%`_parserTypeDeclaration(name, typeParameter*{typeParameter <- typeParameter*}, parameter*{parameter <- parameter*}) = declaration as parserTypeDeclaration
      -- let TC_1 = TC_0[BLOCK.KIND = `PARSER`_blockKind()]
      -- (let tid_expl = typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_2 = $add_types(`BLOCK`_cursor(), TC_1, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- Parameters_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_2, parameter*{parameter <- parameter*}, parameterIR*{parameterIR <- parameterIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let typeIR_parser = `ParserT%`_parserObjectTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) as typeIR
      -- let typeDefIR_parser = `PolyTD%%%`_polyTypeDefIR(typeIR_parser, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) as typeDefIR
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), typeDefIR_parser) holds
      -- let TC_3 = $add_type(`GLOBAL`_cursor(), TC_0, name, typeDefIR_parser)
      -- let parserTypeDeclarationIR = `ParserTypeD%%%%`_parserTypeDeclarationIR(name, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}, parameterIR*{parameterIR <- parameterIR*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:844.1-862.59
   rule typeDeclaration-controlTypeDeclaration: `%%|-%:%%`(cursor, TC_0, declaration, TC_3, controlTypeDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: controlTypeDeclaration
      -- let `ControlTypeD%%%`_controlTypeDeclaration(name, typeParameter*{typeParameter <- typeParameter*}, parameter*{parameter <- parameter*}) = declaration as controlTypeDeclaration
      -- let TC_1 = TC_0[BLOCK.KIND = `CONTROL`_blockKind()]
      -- (let tid_expl = typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_2 = $add_types(`BLOCK`_cursor(), TC_1, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- Parameters_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_2, parameter*{parameter <- parameter*}, parameterIR*{parameterIR <- parameterIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let typeIR_control = `ControlT%`_controlObjectTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) as typeIR
      -- let typeDefIR_control = `PolyTD%%%`_polyTypeDefIR(typeIR_control, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) as typeDefIR
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), typeDefIR_control) holds
      -- let TC_3 = $add_type(`GLOBAL`_cursor(), TC_0, name, typeDefIR_control)
      -- let controlTypeDeclarationIR = `ControlTypeD%%%%`_controlTypeDeclarationIR(name, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}, parameterIR*{parameterIR <- parameterIR*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:867.1-898.70
   rule typeDeclaration-packageTypeDeclaration: `%%|-%:%%`(cursor, TC_0, declaration, TC_4, packageTypeDeclarationIR as declarationIR)
      -- if cursor matches `GLOBAL`
      -- if declaration <: packageTypeDeclaration
      -- let `PackageTypeD%%%`_packageTypeDeclaration(name, typeParameter*{typeParameter <- typeParameter*}, constructorParameter*{constructorParameter <- constructorParameter*}) = declaration as packageTypeDeclaration
      -- let TC_1 = TC_0[BLOCK.KIND = `PACKAGE`_blockKind()]
      -- (let tid_expl = typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_2 = $add_types(`BLOCK`_cursor(), TC_1, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- ConstructorParameters_ok: `%%|-%:%%`(`BLOCK`_cursor(), TC_2, constructorParameter*{constructorParameter <- constructorParameter*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
      -- (let `%%%%`_parameterTypeIR(_direction, typeIR_package_inner, _id, _value?{_value <- _value?}) = constructorParameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, constructorParameterTypeIR <- constructorParameterTypeIR*, typeIR_package_inner <- typeIR_package_inner*}
      -- let typeIR_package = `PackageT%%`_packageObjectTypeIR(name, typeIR_package_inner*{typeIR_package_inner <- typeIR_package_inner*}) as typeIR
      -- let polyTypeDefIR_package = `PolyTD%%%`_polyTypeDefIR(typeIR_package, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*})
      -- if TypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), polyTypeDefIR_package as typeDefIR) holds
      -- let TC_3 = $add_type(`GLOBAL`_cursor(), TC_0, name, polyTypeDefIR_package as typeDefIR)
      -- let cid = $cid(name, constructorParameter*{constructorParameter <- constructorParameter*})
      -- let typeIR_package_spec = `SpecT%%`_namedTypeIR(polyTypeDefIR_package, `NameT%`_namedTypeIR(tid_expl) as typeIR*{tid_expl <- tid_expl*} ++ `NameT%`_namedTypeIR(tid_impl) as typeIR*{tid_impl <- tid_impl*}) as typeIR
      -- let constructorTypeIR = `ConstructorT%%`_constructorTypeIR(constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*}, typeIR_package_spec)
      -- let constructorTypeDefIR = `PolyTD%%%`_constructorTypeDefIR(constructorTypeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*})
      -- if ConstructorTypeDef_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC_0), constructorTypeDefIR) holds
      -- let TC_4 = $add_constructor(TC_3, cid, constructorTypeDefIR)
      -- let packageTypeDeclarationIR = `PackageTypeD%%%%`_packageTypeDeclarationIR(name, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:266.1-268.23
relation Decls_ok: `%%|-%:%%`(cursor, typingContext, declaration*, typingContext, declarationIR*)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:904.1-905.23
   rule nil: `%%|-%:%%`(p, TC, declaration*{declaration <- declaration*}, TC, [])
      -- if declaration*{declaration <- declaration*} matches []

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:907.1-911.64
   rule cons: `%%|-%:%%`(p, TC_0, declaration*{declaration <- declaration*}, TC_2, declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*})
      -- if declaration*{declaration <- declaration*} matches _ :: _
      -- let declaration_h :: declaration_t*{declaration_t <- declaration_t*} = declaration*{declaration <- declaration*}
      -- Decl_ok: `%%|-%:%%`(p, TC_0, declaration_h, TC_1, declarationIR_h)
      -- Decls_ok: `%%|-%:%%`(p, TC_1, declaration_t*{declaration_t <- declaration_t*}, TC_2, declarationIR_t*{declarationIR_t <- declarationIR_t*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:270.1-272.17
relation Program_ok: `|-%:%%`(p4program, typingContext, p4programIR)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:917.1-920.65
   rule : `|-%:%%`(declaration*{declaration <- declaration*}, TC_1, declarationIR*{declarationIR <- declarationIR*})
      -- let TC_0 = $empty_typingContext
      -- Decls_ok: `%%|-%:%%`(`GLOBAL`_cursor(), TC_0, declaration*{declaration <- declaration*}, TC_1, declarationIR*{declarationIR <- declarationIR*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:282.18-282.35
syntax actctxt = 
   | `ACTION`()
   | `NOACTION`()

;; ../../../../spec-concrete/5.04-typing-relation.watsup:284.1-287.29
relation Call_convention_expr_ok: `%%%|-%%:%`(cursor, typingContext, actctxt, parameterTypeIR, typedExpressionIR, typedExpressionIR)

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:52.1-57.59
   rule in: `%%%|-%%:%`(p, TC, actctxt, `%%%%`_parameterTypeIR(direction, typeIR_param, _id, _value?{_value <- _value?}), typedExpressionIR_arg, typedExpressionIR_arg_cast)
      -- if direction matches `IN`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:98.1-106.51
   rule out-inout: `%%%|-%%:%`(p, TC, actctxt, `%%%%`_parameterTypeIR(direction, typeIR_param, _id, _value?{_value <- _value?}), typedExpressionIR_arg, typedExpressionIR_arg)
      -- if ((direction = `OUT`_direction()) \/ (direction = `INOUT`_direction()))
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_arg, _ctk)) = typedExpressionIR_arg
      -- if Type_alpha: `%~~%`(typeIR_param, typeIR_arg) holds
      -- if Expr_lvalue_ok: `%%|-%`(p, TC, typedExpressionIR_arg) holds

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:110.1-115.59
   rule no-action: `%%%|-%%:%`(p, TC, actctxt, `%%%%`_parameterTypeIR(direction, typeIR_param, _id, _value?{_value <- _value?}), typedExpressionIR_arg, typedExpressionIR_arg_cast)
      -- if actctxt matches `ACTION`
      -- if direction matches `NO`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:117.1-125.29
   rule no-not-action: `%%%|-%%:%`(p, TC, actctxt, `%%%%`_parameterTypeIR(direction, typeIR_param, _id, _value?{_value <- _value?}), typedExpressionIR_arg, typedExpressionIR_arg_cast)
      -- if actctxt matches `NOACTION`
      -- if direction matches `NO`
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(_typeIR, ctk_arg_cast)) = typedExpressionIR_arg_cast
      -- if (ctk_arg_cast =/= `DYN`_ctk())

;; ../../../../spec-concrete/5.04-typing-relation.watsup:289.1-292.29
relation Call_convention_argument_ok: `%%%|-%%:%`(cursor, typingContext, actctxt, parameterTypeIR, argumentIR, argumentIR)

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:131.1-136.45
   rule exprA: `%%%|-%%:%`(p, TC, actctxt, parameterTypeIR, argumentIR, `ExprA%`_argumentIR(typedExpressionIR_cast))
      -- if argumentIR matches `ExprA%`
      -- let `ExprA%`_argumentIR(typedExpressionIR) = argumentIR
      -- Call_convention_expr_ok: `%%%|-%%:%`(p, TC, actctxt, parameterTypeIR, typedExpressionIR, typedExpressionIR_cast)

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:140.1-145.45
   rule name-typedExpression: `%%%|-%%:%`(p, TC, actctxt, parameterTypeIR, argumentIR, `NameA%%`_argumentIR(name, typedExpressionIR_cast))
      -- if argumentIR matches `NameA%%`
      -- let `NameA%%`_argumentIR(name, typedExpressionIR) = argumentIR
      -- Call_convention_expr_ok: `%%%|-%%:%`(p, TC, actctxt, parameterTypeIR, typedExpressionIR, typedExpressionIR_cast)

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:149.1-152.36
   rule nameanyA: `%%%|-%%:%`(p, TC, actctxt, parameterTypeIR, argumentIR, `NameAnyA%`_argumentIR(name))
      -- if argumentIR matches `NameAnyA%`
      -- let `NameAnyA%`_argumentIR(name) = argumentIR
      -- let `%%%%`_parameterTypeIR(direction, _typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR
      -- if direction matches `OUT`

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:156.1-158.36
   rule anyA: `%%%|-%%:%`(p, TC, actctxt, parameterTypeIR, argumentIR, `AnyA`_argumentIR())
      -- if argumentIR matches `AnyA`
      -- let `%%%%`_parameterTypeIR(direction, _typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR
      -- if direction matches `OUT`

;; ../../../../spec-concrete/5.04-typing-relation.watsup:294.1-297.29
relation Call_convention_ok: `%%%|-%%:%`(cursor, typingContext, actctxt, parameterTypeIR*, argumentIR*, argumentIR*)

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:164.1-165.32
   rule nil: `%%%|-%%:%`(p, TC, actctxt, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}, [])
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:167.1-175.41
   rule cons: `%%%|-%%:%`(p, TC, actctxt, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_h_cast :: argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
      -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
      -- Call_convention_argument_ok: `%%%|-%%:%`(p, TC, actctxt, parameterTypeIR_h, argumentIR_h, argumentIR_h_cast)
      -- Call_convention_ok: `%%%|-%%:%`(p, TC, actctxt, parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, argumentIR_t*{argumentIR_t <- argumentIR_t*}, argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*})

;; ../../../../spec-concrete/5.04-typing-relation.watsup:307.1-309.23
relation RoutineTarget_ok: `%%|-%:%`(cursor, typingContext, routineTarget, routineTargetIR)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:10.1-15.74
   rule referenceExpression: `%%|-%:%`(p, TC, routineTarget, `FuncT%`_routineTargetIR(prefixedName))
      -- if routineTarget <: referenceExpression
      -- let `NameE%`_referenceExpression(prefixedName) = routineTarget as referenceExpression
      -- if (((prefixedName = `CURRENT%`_prefixedName("verify")) \/ (prefixedName = `TOP%`_prefixedName("verify"))) => (((p = `BLOCK`_cursor()) /\ $is_parser_blockKind(TC.BLOCK.KIND)) \/ ((p = `LOCAL`_cursor()) /\ $is_parser_state_localKind(TC.LOCAL.KIND))))

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:22.1-23.63
   rule typeaccE: `%%|-%:%`(p, TC, routineTarget, `TypeT%%`_routineTargetIR(prefixedName, name))
      -- if routineTarget <: memberAccessExpression
      -- let memberAccessExpression = routineTarget as memberAccessExpression
      -- if memberAccessExpression matches `TypeAccE%%`
      -- let `TypeAccE%%`_memberAccessExpression(prefixedName, name) = memberAccessExpression

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:27.1-29.63
   rule expraccE: `%%|-%:%`(p, TC, routineTarget, `MethodT%%`_routineTargetIR(typedExpressionIR_base, name))
      -- if routineTarget <: memberAccessExpression
      -- let memberAccessExpression = routineTarget as memberAccessExpression
      -- if memberAccessExpression matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpression(expression_base, name) = memberAccessExpression
      -- Expr_ok: `%%|-%:%`(p, TC, expression_base, typedExpressionIR_base)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:311.1-313.23
relation RoutineTarget_lvalue_ok: `%%|-%:%`(cursor, typingContext, lvalue, routineTargetIR)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:49.1-52.60
   rule : `%%|-%:%`(p, TC, lvalue, routineTargetIR)
      -- let expression = $lvalue_as_expression(lvalue)
      -- RoutineTarget_ok: `%%|-%:%`(p, TC, expression, routineTargetIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:315.1-318.29
relation RoutineType_ok: `%%|-%%%:%%%`(cursor, typingContext, routineTargetIR, typeArgumentIR*, argumentIR*, routineTypeIR, tid*, id*)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:62.1-72.44
   rule funcT: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, routineTypeIR, tid_impl*{tid_impl <- tid_impl*}, id_default*{id_default <- id_default*})
      -- if routineTargetIR matches `FuncT%`
      -- let `FuncT%`_routineTargetIR(prefixedName) = routineTargetIR
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_routine_overloaded(p, TC, prefixedName, argumentIR*{argumentIR <- argumentIR*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
      -- let (routineTypeIR, tid_impl*{tid_impl <- tid_impl*}) = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- let bound = $union_set<tid>($bound(p, TC), `{%}`_set<tid>(tid_impl*{tid_impl <- tid_impl*}))
      -- if RoutineType_wf: `%|-%`(bound, routineTypeIR) holds

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:76.1-83.48
   rule methodT-builtin-minmax-SizeIn-BitsBytes: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, routineTypeIR, [], [])
      -- if routineTargetIR matches `MethodT%%`
      -- let `MethodT%%`_routineTargetIR(typedExpressionIR_base, name) = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if name <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
      -- let routineTypeIR = `BuiltinMethodT%%`_routineTypeIR([], `IntT`_numberTypeIR() as typeIR)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:85.1-96.60
   rule methodT-builtin-stack-push-pop-front: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR'*{argumentIR' <- argumentIR'*}, routineTypeIR, [], [])
      -- if routineTargetIR matches `MethodT%%`
      -- let `MethodT%%`_routineTargetIR(typedExpressionIR_base, name) = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR'*{argumentIR' <- argumentIR'*} matches [ _/1 ]
      -- let [argumentIR] = argumentIR'*{argumentIR' <- argumentIR'*}
      -- if name <- ["push_front", "pop_front"]
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, _nat) = typeIR' as headerStackTypeIR
      -- let parameterTypeIR = `%%%%`_parameterTypeIR(`NO`_direction(), `IntT`_numberTypeIR() as typeIR, "count", ?())
      -- let routineTypeIR = `BuiltinMethodT%%`_routineTypeIR([parameterTypeIR], `IntT`_numberTypeIR() as typeIR)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:98.1-107.49
   rule methodT-builtin-header-isValid: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, routineTypeIR, [], [])
      -- if routineTargetIR matches `MethodT%%`
      -- let `MethodT%%`_routineTargetIR(typedExpressionIR_base, name) = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if name <- ["isValid"]
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerTypeIR
      -- let routineTypeIR = `BuiltinMethodT%%`_routineTypeIR([], `BoolT`_primitiveTypeIR() as typeIR)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:109.1-118.49
   rule methodT-builtin-union-isValid: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, routineTypeIR, [], [])
      -- if routineTargetIR matches `MethodT%%`
      -- let `MethodT%%`_routineTargetIR(typedExpressionIR_base, name) = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if name <- ["isValid"]
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerUnionTypeIR
      -- let routineTypeIR = `BuiltinMethodT%%`_routineTypeIR([], `BoolT`_primitiveTypeIR() as typeIR)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:120.1-129.49
   rule methodT-builtin-header-set-ValidInvalid: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, routineTypeIR, [], [])
      -- if routineTargetIR matches `MethodT%%`
      -- let `MethodT%%`_routineTargetIR(typedExpressionIR_base, name) = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if name <- ["setValid", "setInvalid"]
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(_tid, _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) = typeIR as headerTypeIR
      -- let routineTypeIR = `BuiltinMethodT%%`_routineTypeIR([], `VoidT`_primitiveTypeIR() as typeIR)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:131.1-149.44
   rule methodT-extern: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, routineTypeIR, tid_impl*{tid_impl <- tid_impl*}, id_default*{id_default <- id_default*})
      -- if routineTargetIR matches `MethodT%%`
      -- let `MethodT%%`_routineTargetIR(typedExpressionIR_base, name) = routineTargetIR
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(_tid, `{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(rid_f, routineTypeDefIR_f)*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*})) = typeIR as externObjectTypeIR
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>(`{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(rid_f, routineTypeDefIR_f)*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*}), name, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
      -- let (routineTypeIR, tid_impl*{tid_impl <- tid_impl*}) = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- let bound = $union_set<tid>($bound(p, TC), `{%}`_set<tid>(tid_impl*{tid_impl <- tid_impl*}))
      -- if RoutineType_wf: `%|-%`(bound, routineTypeIR) holds

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:151.1-169.22
   rule methodT-parser-apply: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, routineTypeIR, [], id_default*{id_default <- id_default*})
      -- if routineTargetIR matches `MethodT%%`
      -- let `MethodT%%`_routineTargetIR(typedExpressionIR_base, text) = routineTargetIR
      -- if (text = "apply")
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = typeIR as parserObjectTypeIR
      -- let routineTypeIR = `ParserApplyMethodT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- (let `%%%%`_parameterTypeIR(_direction, _typeIR, id_param, value_param?{value_param <- value_param?}) = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}
      -- (let pid = `%%`_pid(id_param, (value_param?{value_param <- value_param?} =/= ?())))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}
      -- let rid = `%%`_rid("apply", pid*{pid <- pid*})
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>(`{%}`_set<pair<rid, routineTypeDefIR>>([`%->%`_pair<rid, routineTypeDefIR>(rid, `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) as routineTypeDefIR)]), "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid', routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
      -- if (rid' = rid)
      -- if (routineTypeDefIR = `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) as routineTypeDefIR)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:171.1-189.22
   rule methodT-control-apply: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, routineTypeIR, [], id_default*{id_default <- id_default*})
      -- if routineTargetIR matches `MethodT%%`
      -- let `MethodT%%`_routineTargetIR(typedExpressionIR_base, text) = routineTargetIR
      -- if (text = "apply")
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = typeIR as controlObjectTypeIR
      -- let routineTypeIR = `ControlApplyMethodT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- (let `%%%%`_parameterTypeIR(_direction, _typeIR, id_param, value_param?{value_param <- value_param?}) = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}
      -- (let pid = `%%`_pid(id_param, (value_param?{value_param <- value_param?} =/= ?())))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}
      -- let rid = `%%`_rid("apply", pid*{pid <- pid*})
      -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
      -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>(`{%}`_set<pair<rid, routineTypeDefIR>>([`%->%`_pair<rid, routineTypeDefIR>(rid, `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) as routineTypeDefIR)]), "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
      -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
      -- let ?((rid', routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
      -- if (rid' = rid)
      -- if (routineTypeDefIR = `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) as routineTypeDefIR)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:191.1-198.55
   rule methodT-table-apply: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, routineTypeIR, [], [])
      -- if routineTargetIR matches `MethodT%%`
      -- let `MethodT%%`_routineTargetIR(typedExpressionIR_base, text) = routineTargetIR
      -- if (text = "apply")
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk)) = typedExpressionIR_base
      -- let typeIR = $canon(typeIR_base)
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, typeIR_table) = typeIR as tableObjectTypeIR
      -- let routineTypeIR = `TableApplyMethodT%`_routineTypeIR(typeIR_table)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:202.1-209.48
   rule typeT-builtin-minmax-SizeIn-BitsBytes: `%%|-%%%:%%%`(p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, routineTypeIR, [], [])
      -- if routineTargetIR matches `TypeT%%`
      -- let `TypeT%%`_routineTargetIR(prefixedName, name) = routineTargetIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if name <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
      -- let routineTypeIR = `BuiltinMethodT%%`_routineTypeIR([], `IntT`_numberTypeIR() as typeIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:325.1-329.35
relation Call_ok: `%%|-%%%%%:%%%`(cursor, typingContext, routineTypeIR, typeArgumentIR*, tid*, argumentIR*, id*, typeIR, typeArgumentIR*, argumentIR*)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:226.1-243.40
   rule builtin-function: `%%|-%%%%%:%%%`(p, TC, routineTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid*{tid <- tid*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_ret, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if routineTypeIR matches `BuiltinFuncT%%`
      -- let `BuiltinFuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- if $callable_builtin_function(p, TC)
      -- Call_convention_ok: `%%%|-%%:%`(p, TC, `NOACTION`_actctxt(), parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:257.1-287.40
   rule function: `%%|-%%%%%:%%%`(p, TC, routineTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_infer*{tid_infer <- tid_infer*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_ret_inferred, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if routineTypeIR matches `FuncT%%`
      -- let `FuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference'?{inference' <- inference'?} = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- if inference'?{inference' <- inference'?} matches (_)
      -- let ?(inference) = inference'?{inference' <- inference'?}
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let routineTypeIR_inferred = `FuncT%%`_routineTypeIR(parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}, typeIR_ret_inferred)
      -- if RoutineType_wf: `%|-%`($bound(p, TC), routineTypeIR_inferred) holds
      -- if $callable_function(p, TC)
      -- Call_convention_ok: `%%%|-%%:%`(p, TC, `NOACTION`_actctxt(), parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:299.1-329.40
   rule externfunction: `%%|-%%%%%:%%%`(p, TC, routineTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_infer*{tid_infer <- tid_infer*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_ret_inferred, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if routineTypeIR matches `ExternFuncT%%`
      -- let `ExternFuncT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference'?{inference' <- inference'?} = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- if inference'?{inference' <- inference'?} matches (_)
      -- let ?(inference) = inference'?{inference' <- inference'?}
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let routineTypeIR_inferred = `ExternFuncT%%`_routineTypeIR(parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}, typeIR_ret_inferred)
      -- if RoutineType_wf: `%|-%`($bound(p, TC), routineTypeIR_inferred) holds
      -- if $callable_extern_function(p, TC)
      -- Call_convention_ok: `%%%|-%%:%`(p, TC, `NOACTION`_actctxt(), parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:341.1-357.38
   rule action: `%%|-%%%%%:%%%`(p, TC, routineTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid*{tid <- tid*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, `VoidT`_primitiveTypeIR() as typeIR, [], argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if routineTypeIR matches `ActionT%`
      -- let `ActionT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- if $callable_action(p, TC)
      -- Call_convention_ok: `%%%|-%%:%`(p, TC, `ACTION`_actctxt(), parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:370.1-387.40
   rule builtin-method: `%%|-%%%%%:%%%`(p, TC, routineTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid*{tid <- tid*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_ret, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if routineTypeIR matches `BuiltinMethodT%%`
      -- let `BuiltinMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- if $callable_builtin_method(p, TC)
      -- Call_convention_ok: `%%%|-%%:%`(p, TC, `NOACTION`_actctxt(), parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:399.1-429.40
   rule extern-method: `%%|-%%%%%:%%%`(p, TC, routineTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_infer*{tid_infer <- tid_infer*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_ret_inferred, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if routineTypeIR matches `ExternMethodT%%`
      -- let `ExternMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference'?{inference' <- inference'?} = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- if inference'?{inference' <- inference'?} matches (_)
      -- let ?(inference) = inference'?{inference' <- inference'?}
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let routineTypeIR_inferred = `ExternMethodT%%`_routineTypeIR(parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}, typeIR_ret_inferred)
      -- if RoutineType_wf: `%|-%`($bound(p, TC), routineTypeIR_inferred) holds
      -- if $callable_extern_method(p, TC)
      -- Call_convention_ok: `%%%|-%%:%`(p, TC, `NOACTION`_actctxt(), parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:441.1-471.40
   rule extern-abstract-method: `%%|-%%%%%:%%%`(p, TC, routineTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_infer*{tid_infer <- tid_infer*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_ret_inferred, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if routineTypeIR matches `ExternAbstractMethodT%%`
      -- let `ExternAbstractMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference'?{inference' <- inference'?} = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- if inference'?{inference' <- inference'?} matches (_)
      -- let ?(inference) = inference'?{inference' <- inference'?}
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
      -- let routineTypeIR_inferred = `ExternAbstractMethodT%%`_routineTypeIR(parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}, typeIR_ret_inferred)
      -- if RoutineType_wf: `%|-%`($bound(p, TC), routineTypeIR_inferred) holds
      -- if $callable_extern_abstract_method(p, TC)
      -- Call_convention_ok: `%%%|-%%:%`(p, TC, `NOACTION`_actctxt(), parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:482.1-498.40
   rule parser-apply-method: `%%|-%%%%%:%%%`(p, TC, routineTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid*{tid <- tid*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, `VoidT`_primitiveTypeIR() as typeIR, [], argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if routineTypeIR matches `ParserApplyMethodT%`
      -- let `ParserApplyMethodT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- if $callable_parser_apply_method(p, TC)
      -- Call_convention_ok: `%%%|-%%:%`(p, TC, `NOACTION`_actctxt(), parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:509.1-525.40
   rule control-apply-method: `%%|-%%%%%:%%%`(p, TC, routineTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid*{tid <- tid*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, `VoidT`_primitiveTypeIR() as typeIR, [], argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if routineTypeIR matches `ControlApplyMethodT%`
      -- let `ControlApplyMethodT%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = routineTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- if $callable_control_apply_method(p, TC)
      -- Call_convention_ok: `%%%|-%%:%`(p, TC, `NOACTION`_actctxt(), parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:537.1-541.44
   rule table-apply-method: `%%|-%%%%%:%%%`(p, TC, routineTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid*{tid <- tid*}, argumentIR*{argumentIR <- argumentIR*}, id*{id <- id*}, typeIR_table, [], [])
      -- if routineTypeIR matches `TableApplyMethodT%`
      -- let `TableApplyMethodT%`_routineTypeIR(typeIR_table) = routineTypeIR
      -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
      -- if tid*{tid <- tid*} matches []
      -- if argumentIR*{argumentIR <- argumentIR*} matches []
      -- if id*{id <- id*} matches []
      -- if $callable_table_apply_method(p, TC)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:339.1-342.29
relation ConstructorType_ok: `%%|-%%%:%%%`(cursor, typingContext, prefixedName, typeArgumentIR*, argumentIR*, constructorTypeIR, tid*, id*)

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:5.1-15.52
   rule : `%%|-%%%:%%%`(p, TC, prefixedName, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}, constructorTypeIR, tid_impl*{tid_impl <- tid_impl*}, id_default*{id_default <- id_default*})
      -- let (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} = $find_constructor_overloaded(TC, prefixedName, argumentIR*{argumentIR <- argumentIR*})
      -- if (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} matches (_)
      -- let ?((cid, constructorTypeDefIR, id_default*{id_default <- id_default*})) = (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?}
      -- let (constructorTypeIR, tid_impl*{tid_impl <- tid_impl*}) = $specialize_constructorTypeDef(constructorTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
      -- let bound = $union_set<tid>($bound(p, TC), `{%}`_set<tid>(tid_impl*{tid_impl <- tid_impl*}))
      -- if ConstructorType_wf: `%|-%`(bound, constructorTypeIR) holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:349.19-349.31
syntax instctxt = 
   | `NAMED`()
   | `ANON`()

;; ../../../../spec-concrete/5.04-typing-relation.watsup:351.1-354.38
relation Inst_ok: `%%%|-%%%%%:%%%`(cursor, typingContext, instctxt, constructorTypeIR, typeArgumentIR*, tid*, argumentIR*, id*, typeIR, typeArgumentIR*, argumentIR*)

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:80.1-114.44
   rule package: `%%%|-%%%%%:%%%`(cursor, TC, instctxt, constructorTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_infer*{tid_infer <- tid_infer*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_object_inferred, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- if cursor matches `GLOBAL`
      -- let `ConstructorT%%`_constructorTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_object) = constructorTypeIR
      -- if $is_package_object_typeIR($canon(typeIR_object))
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference'?{inference' <- inference'?} = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- if inference'?{inference' <- inference'?} matches (_)
      -- let ?(inference) = inference'?{inference' <- inference'?}
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_object_inferred = $subst_type(inference, typeIR_object)
      -- let constructorTypeIR_inferred = `ConstructorT%%`_constructorTypeIR(parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}, typeIR_object_inferred)
      -- if ConstructorType_wf: `%|-%`($bound(`GLOBAL`_cursor(), TC), constructorTypeIR_inferred) holds
      -- if $instantiable(`GLOBAL`_cursor(), TC, instctxt, typeIR_object_inferred)
      -- Call_convention_ok: `%%%|-%%:%`(`BLOCK`_cursor(), TC, `NOACTION`_actctxt(), parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:118.1-152.40
   rule non-package: `%%%|-%%%%%:%%%`(p, TC, instctxt, constructorTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_infer*{tid_infer <- tid_infer*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}, typeIR_object_inferred, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
      -- let `ConstructorT%%`_constructorTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_object) = constructorTypeIR
      -- if ~$is_package_object_typeIR($canon(typeIR_object))
      -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
      -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
      -- let inference'?{inference' <- inference'?} = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
      -- if inference'?{inference' <- inference'?} matches (_)
      -- let ?(inference) = inference'?{inference' <- inference'?}
      -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
      -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
      -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
      -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
      -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
      -- let typeIR_object_inferred = $subst_type(inference, typeIR_object)
      -- let constructorTypeIR_inferred = `ConstructorT%%`_constructorTypeIR(parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}, typeIR_object_inferred)
      -- if ConstructorType_wf: `%|-%`($bound(p, TC), constructorTypeIR_inferred) holds
      -- if $instantiable(p, TC, instctxt, typeIR_object_inferred)
      -- Call_convention_ok: `%%%|-%%:%`(p, TC, `NOACTION`_actctxt(), parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}, argumentIR*{argumentIR <- argumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

;; ../../../../spec-concrete/5.05.2-subtype.watsup:338.1-342.23
def $reduce_serenum_unary(typedExpressionIR, $check(typeIR) : bool) : typedExpressionIR? =

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:345.1-348.23
   clause 0(typedExpressionIR, $check) = ?(typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, _ctk)) = typedExpressionIR
      -- if $check(typeIR)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:350.1-356.79
   clause 1(typedExpressionIR, $check) = $reduce_serenum_unary(typedExpressionIR_cast, $check)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, ctk)) = typedExpressionIR
      -- if ~$check(typeIR)
      -- let typeIR' = typeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR_underlying, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR
      -- let typedExpressionIR_cast = `%%`_typedExpressionIR(`CastE%%`_castExpressionIR(typeIR_underlying, typedExpressionIR) as expressionIR, `(%%)`_expressionNoteIR(typeIR_underlying, ctk))

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:358.1-359.15
   clause 2(typedExpressionIR, $check) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.05.2-subtype.watsup:363.1-368.44
def $reduce_serenum_binary(typedExpressionIR, typedExpressionIR, $check(typeIR, typeIR) : bool) : (typedExpressionIR, typedExpressionIR)? =

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:370.1-374.35
   clause 0(typedExpressionIR_l, typedExpressionIR_r, $check) = ?((typedExpressionIR_l, typedExpressionIR_r))
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_l, _ctk)) = typedExpressionIR_l
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_r, _ctk')) = typedExpressionIR_r
      -- if $check(typeIR_l, typeIR_r)

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:376.1-384.87
   clause 1(typedExpressionIR_l, typedExpressionIR_r, $check) = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r, $check)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_l, ctk_l)) = typedExpressionIR_l
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_r, _ctk)) = typedExpressionIR_r
      -- if ~$check(typeIR_l, typeIR_r)
      -- let typeIR = typeIR_l
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR_l_underlying, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR
      -- let typedExpressionIR_l_cast = `%%`_typedExpressionIR(`CastE%%`_castExpressionIR(typeIR_l_underlying, typedExpressionIR_l) as expressionIR, `(%%)`_expressionNoteIR(typeIR_l_underlying, ctk_l))

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:386.1-394.87
   clause 2(typedExpressionIR_l, typedExpressionIR_r, $check) = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r_cast, $check)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_l, _ctk)) = typedExpressionIR_l
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_r, ctk_r)) = typedExpressionIR_r
      -- if ~$check(typeIR_l, typeIR_r)
      -- let typeIR = typeIR_r
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR_r_underlying, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR
      -- let typedExpressionIR_r_cast = `%%`_typedExpressionIR(`CastE%%`_castExpressionIR(typeIR_r_underlying, typedExpressionIR_r) as expressionIR, `(%%)`_expressionNoteIR(typeIR_r_underlying, ctk_r))

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:396.1-397.15
   clause 3(typedExpressionIR_l, typedExpressionIR_r, $check) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.05.2-subtype.watsup:408.1-408.66
def $coerce_unary(typedExpressionIR, typeIR) : typedExpressionIR? =

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:410.1-412.37
   clause 0(typedExpressionIR, typeIR_to) = ?(typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, _ctk)) = typedExpressionIR
      -- if Type_alpha: `%~~%`(typeIR, typeIR_to) holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:414.1-419.63
   clause 1(typedExpressionIR, typeIR_to) = ?(typedExpressionIR_cast)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, ctk)) = typedExpressionIR
      -- if ~Type_alpha: `%~~%`(typeIR, typeIR_to) holds
      -- if Sub_impl: `%<:%`(typeIR, typeIR_to) holds
      -- let typedExpressionIR_cast = `%%`_typedExpressionIR(`CastE%%`_castExpressionIR(typeIR_to, typedExpressionIR) as expressionIR, `(%%)`_expressionNoteIR(typeIR_to, ctk))

;; ../../../../spec-concrete/5.05.2-subtype.watsup:423.1-424.44
def $coerce_binary(typedExpressionIR, typedExpressionIR) : (typedExpressionIR, typedExpressionIR)? =

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:426.1-430.38
   clause 0(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l, typedExpressionIR_r))
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_l, _ctk)) = typedExpressionIR_l
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_r, _ctk')) = typedExpressionIR_r
      -- if Type_alpha: `%~~%`(typeIR_l, typeIR_r) holds

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:432.1-439.65
   clause 1(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l_cast, typedExpressionIR_r))
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_l, ctk_l)) = typedExpressionIR_l
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_r, _ctk)) = typedExpressionIR_r
      -- if ~Type_alpha: `%~~%`(typeIR_l, typeIR_r) holds
      -- if Sub_impl: `%<:%`(typeIR_l, typeIR_r) holds
      -- let typedExpressionIR_l_cast = `%%`_typedExpressionIR(`CastE%%`_castExpressionIR(typeIR_r, typedExpressionIR_l) as expressionIR, `(%%)`_expressionNoteIR(typeIR_r, ctk_l))

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:441.1-449.65
   clause 2(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l, typedExpressionIR_r_cast))
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_l, _ctk)) = typedExpressionIR_l
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR_r, ctk_r)) = typedExpressionIR_r
      -- if ~Type_alpha: `%~~%`(typeIR_l, typeIR_r) holds
      -- if ~Sub_impl: `%<:%`(typeIR_l, typeIR_r) holds
      -- if Sub_impl: `%<:%`(typeIR_r, typeIR_l) holds
      -- let typedExpressionIR_r_cast = `%%`_typedExpressionIR(`CastE%%`_castExpressionIR(typeIR_l, typedExpressionIR_r) as expressionIR, `(%%)`_expressionNoteIR(typeIR_l, ctk_r))

   ;; ../../../../spec-concrete/5.05.2-subtype.watsup:451.1-452.15
   clause 3(typedExpressionIR_l, typedExpressionIR_r) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:57.1-57.32
def $compat_lnot(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:60.1-60.57
   clause 0(typeIR) = $compat'_lnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:58.1-58.33
def $compat'_lnot(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:61.1-61.32
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:62.1-63.14
   clause 1(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:79.1-79.32
def $compat_bnot(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:82.1-82.57
   clause 0(typeIR) = $compat'_bnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:80.1-80.33
def $compat'_bnot(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:83.1-83.34
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:84.1-84.34
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:85.1-86.15
   clause 2(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:102.1-102.38
def $compat_uplusminus(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:105.1-105.69
   clause 0(typeIR) = $compat'_uplusminus($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:103.1-103.39
def $compat'_uplusminus(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:106.1-106.37
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:107.1-107.40
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:108.1-108.40
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:109.1-110.15
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:131.1-131.48
def $compat_plusminusmul(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:134.1-135.62
   clause 0(typeIR_l, typeIR_r) = $compat'_plusminusmul($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:132.1-132.49
def $compat'_plusminusmul(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:136.1-136.45
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `IntT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:137.1-137.51
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:138.1-138.51
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:139.1-140.15
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:169.1-169.48
def $compat_satplusminus(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:172.1-173.62
   clause 0(typeIR_l, typeIR_r) = $compat'_satplusminus($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:170.1-170.49
def $compat'_satplusminus(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:174.1-174.51
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:175.1-175.51
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:176.1-177.15
   clause 2(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:206.1-206.42
def $compat_divmod(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:209.1-210.56
   clause 0(typeIR_l, typeIR_r) = $compat'_divmod($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:207.1-207.43
def $compat'_divmod(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:211.1-211.39
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `IntT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:212.1-213.15
   clause 1(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:275.1-275.41
def $compat_shift(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:278.1-279.55
   clause 0(typeIR_l, typeIR_r) = $compat'_shift($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:276.1-276.42
def $compat'_shift(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:280.1-280.38
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `IntT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:281.1-281.41
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:282.1-282.41
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:283.1-283.41
   clause 3(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `IntT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:284.1-284.44
   clause 4(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat') = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:285.1-285.44
   clause 5(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat') = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:286.1-286.41
   clause 6(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `IntT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:287.1-287.44
   clause 7(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat') = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:288.1-288.44
   clause 8(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat') = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:289.1-290.15
   clause 9(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:369.1-369.43
def $compat_compare(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:372.1-373.57
   clause 0(typeIR_l, typeIR_r) = $compat'_compare($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:370.1-370.44
def $compat'_compare(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:374.1-374.40
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `IntT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:375.1-375.46
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:376.1-376.46
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:377.1-378.15
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:407.1-407.43
def $compat_bitwise(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:410.1-411.57
   clause 0(typeIR_l, typeIR_r) = $compat'_bitwise($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:408.1-408.44
def $compat'_bitwise(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:412.1-412.46
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:413.1-413.46
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:414.1-415.15
   clause 2(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:444.1-444.42
def $compat_concat(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:447.1-448.56
   clause 0(typeIR_l, typeIR_r) = $compat'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:445.1-445.43
def $compat'_concat(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:449.1-449.45
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat') = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:450.1-450.45
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat') = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:451.1-451.45
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat') = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:452.1-452.45
   clause 3(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat') = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:453.1-454.15
   clause 4(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:456.1-456.45
def $result_concat(typeIR, typeIR) : typeIR? =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:459.1-460.56
   clause 0(typeIR_l, typeIR_r) = $result'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:457.1-457.46
def $result'_concat(typeIR, typeIR) : typeIR? =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:461.1-461.63
   clause 0(typeIR, typeIR') = ?(`FIntT%`_numberTypeIR((w_a + w_b)) as typeIR)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w_a) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w_b) = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:462.1-462.63
   clause 1(typeIR, typeIR') = ?(`FIntT%`_numberTypeIR((w_a + w_b)) as typeIR)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w_a) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w_b) = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:463.1-463.63
   clause 2(typeIR, typeIR') = ?(`FBitT%`_numberTypeIR((w_a + w_b)) as typeIR)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w_a) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w_b) = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:464.1-464.63
   clause 3(typeIR, typeIR') = ?(`FBitT%`_numberTypeIR((w_a + w_b)) as typeIR)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w_a) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w_b) = numberTypeIR'

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:465.1-466.15
   clause 4(typeIR_l, typeIR_r) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:495.1-495.43
def $compat_logical(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:498.1-499.57
   clause 0(typeIR_l, typeIR_r) = $compat'_logical($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:496.1-496.44
def $compat'_logical(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:500.1-500.42
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`
      -- if typeIR' <: primitiveTypeIR
      -- let primitiveTypeIR' = typeIR' as primitiveTypeIR
      -- if primitiveTypeIR' matches `BoolT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:501.1-502.15
   clause 1(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:807.1-807.39
def $compat_array_index(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:810.1-811.40
   clause 0(typeIR) = $compat'_arrayindex($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:808.1-808.39
def $compat'_arrayindex(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:812.1-812.37
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:813.1-813.40
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:814.1-814.40
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:815.1-816.15
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:899.1-899.41
def $compat_bitslice_base(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:902.1-903.43
   clause 0(typeIR) = $compat'_bitslice_base($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:900.1-900.42
def $compat'_bitslice_base(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:904.1-904.40
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:905.1-905.47
   clause 1(typeIR) = (w > 0)
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:906.1-906.43
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:907.1-908.15
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:910.1-910.42
def $compat_bitslice_index(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:913.1-914.44
   clause 0(typeIR) = $compat'_bitslice_index($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:911.1-911.43
def $compat'_bitslice_index(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:915.1-915.41
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:916.1-916.44
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:917.1-917.44
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:918.1-919.15
   clause 3(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:921.1-921.48
def $is_valid_bitslice(typeIR, nat, nat) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:924.1-925.71
   clause 0(typeIR, n_lo, n_hi) = ((n_lo <= n_hi) /\ $is_valid_bitslice'($canon(typeIR), n_lo, n_hi))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:922.1-922.49
def $is_valid_bitslice'(typeIR, nat, nat) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:926.1-926.43
   clause 0(typeIR, _nat, _nat') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:927.1-929.37
   clause 1(typeIR, n_lo, n_hi) = ((n_hi <= w) /\ (w_slice <= w))
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR
      -- let int = ((n_hi - n_lo) + 1 as int)
      -- if int <: nat
      -- let w_slice = int as nat

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:930.1-932.37
   clause 2(typeIR, n_lo, n_hi) = ((n_hi <= w) /\ (w_slice <= w))
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR
      -- let int = ((n_hi - n_lo) + 1 as int)
      -- if int <: nat
      -- let w_slice = int as nat

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:933.1-934.15
   clause 3(_typeIR, _nat, _nat') = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:992.1-992.52
def $is_static_routineTarget(routineTargetIR) : ctk =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:994.1-996.54
   clause 0(routineTargetIR) = `LCTK`_ctk()
      -- if routineTargetIR matches `MethodT%%`
      -- let `MethodT%%`_routineTargetIR(_typedExpressionIR, name) = routineTargetIR
      -- if name <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:997.1-999.54
   clause 1(routineTargetIR) = `LCTK`_ctk()
      -- if routineTargetIR matches `TypeT%%`
      -- let `TypeT%%`_routineTargetIR(_prefixedName, name) = routineTargetIR
      -- if name <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1000.1-1001.15
   clause 2(_routineTargetIR) = `DYN`_ctk()
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1033.1-1033.46
def $is_concrete_extern_object(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1038.1-1039.50
   clause 0(typeIR) = $is_concrete_extern_object'($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1034.1-1034.47
def $is_concrete_extern_object'(typeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1041.1-1042.42
   clause 0(typeIR) = true
      -- if ~$is_extern_object_typeIR(typeIR)

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1043.1-1044.58
   clause 1(typeIR) = true
      -- if typeIR <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(_tid, `{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(_rid, routineTypeDefIR)*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*})) = typeIR as externObjectTypeIR
      -- (if $is_concrete_extern_object''(routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*}

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1045.1-1046.15
   clause 2(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1035.1-1035.58
def $is_concrete_extern_object''(routineTypeDefIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1048.1-1049.49
   clause 0(routineTypeDefIR) = $is_concrete_extern_object'''(routineTypeIR)
      -- if routineTypeDefIR <: monoRoutineTypeDefIR
      -- let `MonoTD%`_monoRoutineTypeDefIR(routineTypeIR) = routineTypeDefIR as monoRoutineTypeDefIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1050.1-1051.50
   clause 1(routineTypeDefIR) = (true = $is_concrete_extern_object'''(routineTypeIR))
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, _tid*{_tid <- _tid*}, _tid'*{_tid' <- _tid'*}) = routineTypeDefIR as polyRoutineTypeDefIR

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1036.1-1036.56
def $is_concrete_extern_object'''(routineTypeIR) : bool =

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1053.1-1053.69
   clause 0(routineTypeIR) = false
      -- if routineTypeIR matches `ExternAbstractMethodT%%`
      -- let `ExternAbstractMethodT%%`_routineTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _typeIR) = routineTypeIR

   ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1054.1-1055.15
   clause 1(_routineTypeIR) = true
      -- otherwise

;; ../../../../spec-concrete/5.10-typing-statement.watsup:57.1-57.46
def $compat_direct_application(typeIR) : bool =

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:60.1-61.48
   clause 0(typeIR) = $compat'_direct_application($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:58.1-58.47
def $compat'_direct_application(typeIR) : bool =

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:62.1-62.50
   clause 0(typeIR) = true
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:63.1-63.51
   clause 1(typeIR) = true
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:64.1-65.15
   clause 2(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.10-typing-statement.watsup:158.1-160.26
relation SwitchLabel_table_ok: `%%%|-%:%`(typingContext, tid, bool, switchLabel, switchLabelIR)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:164.1-165.43
   rule defaultL: `%%%|-%:%`(TC, tid_table, bool, switchLabel, `DefaultL`_switchLabelIR())
      -- if (bool = true)
      -- if switchLabel matches `DefaultL`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:169.1-181.65
   rule exprL-nameE: `%%%|-%:%`(TC, tid_table, _bool, switchLabel, `ExprL%`_switchLabelIR(typedExpressionIR_label))
      -- if switchLabel matches `ExprL%`
      -- let `ExprL%`_switchLabel(expression) = switchLabel
      -- if expression <: referenceExpression
      -- let `NameE%`_referenceExpression(prefixedName) = expression as referenceExpression
      -- let prefixedName' = prefixedName
      -- if prefixedName' matches `CURRENT%`
      -- let `CURRENT%`_prefixedName(name_label) = prefixedName'
      -- let tid_table_enum = "action_list(" ++ tid_table ++ ")"
      -- let id_label = tid_table_enum ++ "." ++ name_label
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(`LOCAL`_cursor(), TC, `CURRENT%`_prefixedName(id_label))
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(`%%%%`_varTypeIR(_direction, typeIR_label, ctk_label, value?{value <- value?})) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if value?{value <- value?} matches (_)
      -- let ?(value_label) = value?{value <- value?}
      -- if (value_label = `TableEnumV%%`_tableValue(tid_table_enum, name_label) as value)
      -- let typedExpressionIR_label = `%%`_typedExpressionIR(`NameE%`_referenceExpression(`CURRENT%`_prefixedName(name_label)) as expressionIR, `(%%)`_expressionNoteIR(typeIR_label, ctk_label))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:185.1-187.29
relation SwitchCase_table_ok: `%%%%|-%:%%%`(typingContext, flow, tid, bool, switchCase, flow, switchCaseIR, switchLabel)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:191.1-197.43
   rule fallC: `%%%%|-%:%%%`(TC, f, tid_table, b_last, switchCase, f, switchCaseIR, switchLabel)
      -- if switchCase matches `FallC%`
      -- let `FallC%`_switchCase(switchLabel) = switchCase
      -- SwitchLabel_table_ok: `%%%|-%:%`(TC, tid_table, b_last, switchLabel, switchLabelIR)
      -- let switchCaseIR = `FallC%`_switchCaseIR(switchLabelIR)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:201.1-209.61
   rule matchC: `%%%%|-%:%%%`(TC, f, tid_table, b_last, switchCase, f_post, switchCaseIR, switchLabel)
      -- if switchCase matches `MatchC%%`
      -- let `MatchC%%`_switchCase(switchLabel, blockStatement) = switchCase
      -- SwitchLabel_table_ok: `%%%|-%:%`(TC, tid_table, b_last, switchLabel, switchLabelIR)
      -- Block_ok: `%%|-%:%%%`(TC, f, blockStatement, TC_post, f_post, blockStatementIR)
      -- let switchCaseIR = `MatchC%%`_switchCaseIR(switchLabelIR, blockStatementIR)

;; ../../../../spec-concrete/5.10-typing-statement.watsup:213.1-215.26
relation SwitchCases_table_ok: `%%%|-%:%%%`(typingContext, flow, tid, switchCase*, flow, switchCaseIR*, switchLabel*)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:217.1-218.36
   rule nil: `%%%|-%:%%%`(TC, f, tid_table, switchCase*{switchCase <- switchCase*}, f, [], [])
      -- if switchCase*{switchCase <- switchCase*} matches []

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:220.1-227.77
   rule cons: `%%%|-%:%%%`(TC, f, tid_table, switchCase*{switchCase <- switchCase*}, f_t, switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*}, switchLabel_h :: switchLabel_t*{switchLabel_t <- switchLabel_t*})
      -- if switchCase*{switchCase <- switchCase*} matches _ :: _
      -- let switchCase_h :: switchCase_t*{switchCase_t <- switchCase_t*} = switchCase*{switchCase <- switchCase*}
      -- let b_last = (switchCase_t*{switchCase_t <- switchCase_t*} = [])
      -- SwitchCase_table_ok: `%%%%|-%:%%%`(TC, f, tid_table, b_last, switchCase_h, f_h, switchCaseIR_h, switchLabel_h)
      -- SwitchCases_table_ok: `%%%|-%:%%%`(TC, f_h, tid_table, switchCase_t*{switchCase_t <- switchCase_t*}, f_t, switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*}, switchLabel_t*{switchLabel_t <- switchLabel_t*})

;; ../../../../spec-concrete/5.10-typing-statement.watsup:251.1-253.26
relation SwitchLabel_general_ok: `%%%|-%:%`(typingContext, typeIR, bool, switchLabel, switchLabelIR)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:257.1-258.35
   rule defaultL: `%%%|-%:%`(TC, _typeIR, bool, switchLabel, `DefaultL`_switchLabelIR())
      -- if (bool = true)
      -- if switchLabel matches `DefaultL`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:262.1-269.53
   rule exprL: `%%%|-%:%`(TC, typeIR_switch, _bool, switchLabel, `ExprL%`_switchLabelIR(typedExpressionIR_label_cast))
      -- if switchLabel matches `ExprL%`
      -- let `ExprL%`_switchLabel(expression_label) = switchLabel
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_label, typedExpressionIR_label)
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_label, typeIR_switch)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_label_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(_typeIR, ctk)) = typedExpressionIR_label_cast
      -- if ctk matches `LCTK`

;; ../../../../spec-concrete/5.10-typing-statement.watsup:273.1-275.29
relation SwitchCase_general_ok: `%%%%|-%:%%%`(typingContext, flow, typeIR, bool, switchCase, flow, switchCaseIR, switchLabel)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:279.1-285.43
   rule fallC: `%%%%|-%:%%%`(TC, f, typeIR_switch, b_last, switchCase, f, switchCaseIR, switchLabel)
      -- if switchCase matches `FallC%`
      -- let `FallC%`_switchCase(switchLabel) = switchCase
      -- SwitchLabel_general_ok: `%%%|-%:%`(TC, typeIR_switch, b_last, switchLabel, switchLabelIR)
      -- let switchCaseIR = `FallC%`_switchCaseIR(switchLabelIR)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:289.1-297.61
   rule matchC: `%%%%|-%:%%%`(TC, f, typeIR_switch, b_last, switchCase, f_post, switchCaseIR, switchLabel)
      -- if switchCase matches `MatchC%%`
      -- let `MatchC%%`_switchCase(switchLabel, blockStatement) = switchCase
      -- SwitchLabel_general_ok: `%%%|-%:%`(TC, typeIR_switch, b_last, switchLabel, switchLabelIR)
      -- Block_ok: `%%|-%:%%%`(TC, f, blockStatement, TC_post, f_post, blockStatementIR)
      -- let switchCaseIR = `MatchC%%`_switchCaseIR(switchLabelIR, blockStatementIR)

;; ../../../../spec-concrete/5.10-typing-statement.watsup:301.1-303.26
relation SwitchCases_general_ok: `%%%|-%:%%%`(typingContext, flow, typeIR, switchCase*, flow, switchCaseIR*, switchLabel*)

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:305.1-306.40
   rule nil: `%%%|-%:%%%`(TC, f, typeIR_switch, switchCase*{switchCase <- switchCase*}, f, [], [])
      -- if switchCase*{switchCase <- switchCase*} matches []

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:308.1-316.81
   rule cons: `%%%|-%:%%%`(TC, f, typeIR_switch, switchCase*{switchCase <- switchCase*}, f_t, switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*}, switchLabel_h :: switchLabel_t*{switchLabel_t <- switchLabel_t*})
      -- if switchCase*{switchCase <- switchCase*} matches _ :: _
      -- let switchCase_h :: switchCase_t*{switchCase_t <- switchCase_t*} = switchCase*{switchCase <- switchCase*}
      -- let b_last = (switchCase_t*{switchCase_t <- switchCase_t*} = [])
      -- SwitchCase_general_ok: `%%%%|-%:%%%`(TC, f, typeIR_switch, b_last, switchCase_h, f_h, switchCaseIR_h, switchLabel_h)
      -- SwitchCases_general_ok: `%%%|-%:%%%`(TC, f_h, typeIR_switch, switchCase_t*{switchCase_t <- switchCase_t*}, f_t, switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*}, switchLabel_t*{switchLabel_t <- switchLabel_t*})

;; ../../../../spec-concrete/5.10-typing-statement.watsup:318.1-318.34
def $compat_switch(typeIR) : bool =

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:321.1-322.36
   clause 0(typeIR) = $compat'_switch($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:319.1-319.35
def $compat'_switch(typeIR) : bool =

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:323.1-323.33
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ErrT`

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:324.1-324.36
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:325.1-325.36
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:326.1-326.38
   clause 3(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(_tid, _id*{_id <- _id*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:327.1-327.41
   clause 4(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, _typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.10-typing-statement.watsup:328.1-329.15
   clause 5(typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:73.1-76.29
relation Decl_object_ok: `%%%%|-%:%%%`(cursor, typingContext, frame, rdenv, objectDeclaration, frame, rdenv, objectDeclarationIR)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:84.1-114.60
   rule functionDeclaration: `%%%%|-%:%%%`(p, TC_0, frame, rdenv, objectDeclaration, frame, rdenv_init, functionDeclarationIR as objectDeclarationIR)
      -- if objectDeclaration <: functionDeclaration
      -- let `FuncD%%%%%`_functionDeclaration(typeOrVoid, name, typeParameter*{typeParameter <- typeParameter*}, parameter*{parameter <- parameter*}, blockStatement) = objectDeclaration as functionDeclaration
      -- let TC_1 = TC_0[BLOCK.KIND = `EXTERN`_blockKind()]
      -- let TC_2 = TC_1[BLOCK.FRAME = frame]
      -- (let tid_expl = typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
      -- let TC_3 = $add_types(`LOCAL`_cursor(), TC_2, tid_expl*{tid_expl <- tid_expl*}, `MonoTD%`_monoTypeDefIR(`NameT%`_namedTypeIR(tid_expl) as typeIR) as typeDefIR*{tid_expl <- tid_expl*})
      -- Type_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_3, typeOrVoid, typeIR_ret, tid*{tid <- tid*})
      -- if tid*{tid <- tid*} matches []
      -- Parameters_ok: `%%|-%:%%`(`LOCAL`_cursor(), TC_3, parameter*{parameter <- parameter*}, parameterIR*{parameterIR <- parameterIR*}, tid_impl*{tid_impl <- tid_impl*})
      -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
      -- let TC_4 = $add_parameters(`LOCAL`_cursor(), TC_3, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
      -- let TC_5 = TC_4[LOCAL.KIND = `EXTERNMETHOD%`_localKind(typeIR_ret)]
      -- Block_ok: `%%|-%:%%%`(TC_5, `CONT`_flow(), blockStatement, _typingContext, f, blockStatementIR)
      -- if ((f = `RET`_flow()) \/ (typeIR_ret = `VoidT`_primitiveTypeIR() as typeIR))
      -- let rid = $rid(name, parameter*{parameter <- parameter*})
      -- let routineTypeIR = `ExternMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret)
      -- let routineTypeDefIR = `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR
      -- if RoutineTypeDef_wf: `%|-%`($bound(p, TC_0), routineTypeDefIR) holds
      -- let rdenv_init = $update_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
      -- let functionDeclarationIR = `FuncD%%%%%%`_functionDeclarationIR(typeIR_ret, name, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}, parameterIR*{parameterIR <- parameterIR*}, blockStatementIR)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:118.1-127.59
   rule instantiation: `%%%%|-%:%%%`(p, TC_0, frame, rdenv, objectDeclaration, frame_init, rdenv, instantiationIR as objectDeclarationIR)
      -- if objectDeclaration <: instantiation
      -- let instantiation = objectDeclaration as instantiation
      -- Decl_ok: `%%|-%:%%`(p, TC_0, instantiation as declaration, TC_1, declarationIR)
      -- if declarationIR <: instantiationIR
      -- let instantiationIR = declarationIR as instantiationIR
      -- let `InstD%%%%%%`_instantiationIR(_typeIR, _prefixedName, _typeArgumentIR*{_typeArgumentIR <- _typeArgumentIR*}, _argumentIR*{_argumentIR <- _argumentIR*}, name, _objectInitializerIR?{_objectInitializerIR <- _objectInitializerIR?}) = instantiationIR
      -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_var(p, TC_1, `CURRENT%`_prefixedName(name))
      -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
      -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}
      -- let frame_init = $update_map<id, varTypeIR>(frame, name, varTypeIR)

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:129.1-132.29
relation Decls_object_ok: `%%%%|-%:%%%`(cursor, typingContext, frame, rdenv, objectDeclaration*, frame, rdenv, objectDeclarationIR*)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:134.1-135.44
   rule nil: `%%%%|-%:%%%`(p, TC, frame, rdenv, objectDeclaration*{objectDeclaration <- objectDeclaration*}, frame, rdenv, [])
      -- if objectDeclaration*{objectDeclaration <- objectDeclaration*} matches []

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:137.1-145.69
   rule cons: `%%%%|-%:%%%`(p, TC, frame_0, rdenv_0, objectDeclaration*{objectDeclaration <- objectDeclaration*}, frame_2, rdenv_2, objectDeclarationIR_h :: objectDeclarationIR_t*{objectDeclarationIR_t <- objectDeclarationIR_t*})
      -- if objectDeclaration*{objectDeclaration <- objectDeclaration*} matches _ :: _
      -- let objectDeclaration_h :: objectDeclaration_t*{objectDeclaration_t <- objectDeclaration_t*} = objectDeclaration*{objectDeclaration <- objectDeclaration*}
      -- Decl_object_ok: `%%%%|-%:%%%`(p, TC, frame_0, rdenv_0, objectDeclaration_h, frame_1, rdenv_1, objectDeclarationIR_h)
      -- Decls_object_ok: `%%%%|-%:%%%`(p, TC, frame_1, rdenv_1, objectDeclaration_t*{objectDeclaration_t <- objectDeclaration_t*}, frame_2, rdenv_2, objectDeclarationIR_t*{objectDeclarationIR_t <- objectDeclarationIR_t*})

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:147.1-147.46
def $subst_rdenv(theta, rdenv, rdenv) : rdenv =

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:149.1-149.63
   clause 0(theta, rdenv_extern, set<pair<rid, routineTypeDefIR>>) = rdenv_extern
      -- if (set<pair<rid, routineTypeDefIR>> = `{%}`_set<pair<rid, routineTypeDefIR>>([]))

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:150.1-167.86
   clause 1(theta, rdenv_extern, `{%}`_set<pair<rid, routineTypeDefIR>>(pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*})) = $subst_rdenv(theta, rdenv_extern_subst, `{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(rid_init_t, routineTypeDefIR_init_t)*{rid_init_t <- rid_init_t*, routineTypeDefIR_init_t <- routineTypeDefIR_init_t*}))
      -- if pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*} matches _ :: _
      -- let `%->%`_pair<rid, routineTypeDefIR>(rid_init_h, routineTypeDefIR_init_h) :: `%->%`_pair<rid, routineTypeDefIR>(rid_init_t, routineTypeDefIR_init_t)*{rid_init_t <- rid_init_t*, routineTypeDefIR_init_t <- routineTypeDefIR_init_t*} = pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*}
      -- let `%%`_rid(id_init_h, _pid*{_pid <- _pid*}) = rid_init_h
      -- let (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?} = $find_non_overloaded<routineTypeDefIR>(rdenv_extern, id_init_h)
      -- if (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?} matches (_)
      -- let ?((rid, routineTypeDefIR')) = (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?}
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if routineTypeIR matches `ExternAbstractMethodT%%`
      -- let `ExternAbstractMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret) = routineTypeIR
      -- let routineTypeDefIR = `PolyTD%%%`_polyRoutineTypeDefIR(`ExternMethodT%%`_routineTypeIR(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, typeIR_ret), tid_expl*{tid_expl <- tid_expl*}, tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR
      -- let routineTypeDefIR_subst = $subst_routineTypeDef(theta, routineTypeDefIR)
      -- if RoutineTypeDef_alpha: `%~~%`(routineTypeDefIR_subst, routineTypeDefIR_init_h) holds
      -- let rdenv_extern_subst = $update_map<rid, routineTypeDefIR>(rdenv_extern, rid, routineTypeDefIR_subst)

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:369.1-369.81
def $split_constructors(methodPrototype*) : (methodPrototype*, methodPrototype*) =

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:371.1-371.42
   clause 0(methodPrototype*{methodPrototype <- methodPrototype*}) = ([], [])
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:372.1-377.48
   clause 1(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_h :: methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- let methodPrototype' = methodPrototype_h
      -- if methodPrototype' matches `ConsM%%`
      -- let `ConsM%%`_methodPrototype(_name, _constructorParameter*{_constructorParameter <- _constructorParameter*}) = methodPrototype'
      -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:378.1-383.48
   clause 2(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- let methodPrototype' = methodPrototype_h
      -- if methodPrototype' matches `MethodM%%%%`
      -- let `MethodM%%%%`_methodPrototype(_typeOrVoid, _name, _typeParameter*{_typeParameter <- _typeParameter*}, _parameter*{_parameter <- _parameter*}) = methodPrototype'
      -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:384.1-389.48
   clause 3(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
      -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
      -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
      -- let methodPrototype' = methodPrototype_h
      -- if methodPrototype' matches `AbstractMethodM%%%%`
      -- let `AbstractMethodM%%%%`_methodPrototype(_typeOrVoid, _name, _typeParameter*{_typeParameter <- _typeParameter*}, _parameter*{_parameter <- _parameter*}) = methodPrototype'
      -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:548.1-551.26
relation Enum_serializable_field_ok: `%%%|-%:%%%`(typingContext, name, typeIR, namedExpression, typingContext, namedExpressionIR, value)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:553.1-567.68
   rule : `%%%|-%:%%%`(TC_0, name_enum, typeIR, `%%`_namedExpression(name, expression), TC_1, `%%`_namedExpressionIR(name, typedExpressionIR_cast), value)
      -- Expr_ok: `%%|-%:%`(`BLOCK`_cursor(), TC_0, expression, typedExpressionIR)
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(_typeIR, ctk)) = typedExpressionIR_cast
      -- if ctk matches `LCTK`
      -- Eval_static: `%%|-%~>%`(`BLOCK`_cursor(), TC_0, typedExpressionIR_cast, value)
      -- let typeIR_enum = `SEnumT%%%`_enumTypeIR(name_enum, typeIR, []) as typeIR
      -- let value_enum = `SEnumV%%%`_enumValue(name_enum, name, value) as value
      -- let TC_1 = $add_var(`BLOCK`_cursor(), TC_0, name, `%%%%`_varTypeIR(`NO`_direction(), typeIR_enum, `LCTK`_ctk(), ?(value_enum)))

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:569.1-572.26
relation Enum_serializable_fields_ok: `%%%|-%:%%%`(typingContext, name, typeIR, namedExpression*, typingContext, namedExpressionIR*, value*)

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:574.1-575.42
   rule nil: `%%%|-%:%%%`(TC, name_enum, typeIR, namedExpression*{namedExpression <- namedExpression*}, TC, [], [])
      -- if namedExpression*{namedExpression <- namedExpression*} matches []

   ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:577.1-587.55
   rule cons: `%%%|-%:%%%`(TC_0, name_enum, typeIR, namedExpression*{namedExpression <- namedExpression*}, TC_2, namedExpressionIR*{namedExpressionIR <- namedExpressionIR*}, value_field*{value_field <- value_field*})
      -- if namedExpression*{namedExpression <- namedExpression*} matches _ :: _
      -- let namedExpression_h :: namedExpression_t*{namedExpression_t <- namedExpression_t*} = namedExpression*{namedExpression <- namedExpression*}
      -- Enum_serializable_field_ok: `%%%|-%:%%%`(TC_0, name_enum, typeIR, namedExpression_h, TC_1, namedExpressionIR_h, value_field_h)
      -- Enum_serializable_fields_ok: `%%%|-%:%%%`(TC_1, name_enum, typeIR, namedExpression_t*{namedExpression_t <- namedExpression_t*}, TC_2, namedExpressionIR_t*{namedExpressionIR_t <- namedExpressionIR_t*}, value_field_t*{value_field_t <- value_field_t*})
      -- let namedExpressionIR*{namedExpressionIR <- namedExpressionIR*} = namedExpressionIR_h :: namedExpressionIR_t*{namedExpressionIR_t <- namedExpressionIR_t*}
      -- let value_field*{value_field <- value_field*} = value_field_h :: value_field_t*{value_field_t <- value_field_t*}

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:21.1-23.23
relation SelectCase_keyset_ok: `%%|-%:%`(typingContext, typeIR, keysetExpression, keysetExpressionIR)

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:27.1-33.38
   rule exprK-set-alpha: `%%|-%:%`(TC, typeIR_key, keysetExpression, `ExprK%`_keysetExpressionIR(typedExpressionIR))
      -- if keysetExpression matches `ExprK%`
      -- let `ExprK%`_keysetExpression(expression) = keysetExpression
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR', _ctk)) = typedExpressionIR
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR) = typeIR' as setTypeIR
      -- if Type_alpha: `%~~%`(typeIR, typeIR_key) holds

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:35.1-46.67
   rule exprK-set-subtype: `%%|-%:%`(TC, typeIR_key, keysetExpression, `ExprK%`_keysetExpressionIR(typedExpressionIR_cast))
      -- if keysetExpression matches `ExprK%`
      -- let `ExprK%`_keysetExpression(expression) = keysetExpression
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR', _ctk)) = typedExpressionIR
      -- if typeIR' <: setTypeIR
      -- let `SetT%`_setTypeIR(typeIR) = typeIR' as setTypeIR
      -- if ~Type_alpha: `%~~%`(typeIR, typeIR_key) holds
      -- if Sub_impl: `%<:%`(typeIR, typeIR_key) holds
      -- let typeIR_cast = `SetT%`_setTypeIR(typeIR_key) as typeIR
      -- let typedExpressionIR_cast = `%%`_typedExpressionIR(`CastE%%`_castExpressionIR(typeIR_cast, typedExpressionIR) as expressionIR, `(%%)`_expressionNoteIR(typeIR_cast, `DYN`_ctk()))

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:48.1-60.67
   rule exprK-non-set: `%%|-%:%`(TC, typeIR_key, keysetExpression, `ExprK%`_keysetExpressionIR(typedExpressionIR_cast))
      -- if keysetExpression matches `ExprK%`
      -- let `ExprK%`_keysetExpression(expression) = keysetExpression
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, _ctk)) = typedExpressionIR
      -- if ~$is_set_typeIR(typeIR)
      -- if Sub_impl: `%<:%`(typeIR, typeIR_key) holds
      -- let typeIR_cast = `SetT%`_setTypeIR(typeIR_key) as typeIR
      -- let typedExpressionIR_cast = `%%`_typedExpressionIR(`CastE%%`_castExpressionIR(typeIR_cast, typedExpressionIR) as expressionIR, `(%%)`_expressionNoteIR(typeIR_cast, `DYN`_ctk()))

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:75.1-97.63
   rule maskK: `%%|-%:%`(TC, typeIR_key, keysetExpression, `MaskK%%`_keysetExpressionIR(typedExpressionIR_l_coerced, typedExpressionIR_r_coerced))
      -- if keysetExpression matches `MaskK%%`
      -- let `MaskK%%`_keysetExpression(expression_l, expression_r) = keysetExpression
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_reduced, _ctk)) = typedExpressionIR_l_reduced
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_l_reduced, typeIR_key)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_l_coerced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR_r_reduced, typeIR_key)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_r_coerced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:112.1-135.63
   rule rangeK: `%%|-%:%`(TC, typeIR_key, keysetExpression, `RangeK%%`_keysetExpressionIR(typedExpressionIR_l_coerced, typedExpressionIR_r_coerced))
      -- if keysetExpression matches `RangeK%%`
      -- let `RangeK%%`_keysetExpression(expression_l, expression_r) = keysetExpression
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_reduced, _ctk)) = typedExpressionIR_l_reduced
      -- let `%%`_typedExpressionIR(_expressionIR', `(%%)`_expressionNoteIR(typeIR, _ctk')) = typedExpressionIR_r_reduced
      -- if (typeIR = typeIR_reduced)
      -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_l_reduced, typeIR_key)
      -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
      -- let ?(typedExpressionIR_l_coerced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
      -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR_r_reduced, typeIR_key)
      -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
      -- let ?(typedExpressionIR_r_coerced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:139.1-140.39
   rule defaultK: `%%|-%:%`(TC, typeIR_key, keysetExpression, `DefaultK`_keysetExpressionIR())
      -- if keysetExpression matches `DefaultK`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:144.1-145.31
   rule anyK: `%%|-%:%`(TC, typeIR_key, keysetExpression, `AnyK`_keysetExpressionIR())
      -- if keysetExpression matches `AnyK`

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:64.1-64.40
def $compat_mask(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:67.1-68.54
   clause 0(typeIR_l, typeIR_r) = $compat'_mask($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:65.1-65.41
def $compat'_mask(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:69.1-69.37
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `IntT`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:70.1-70.43
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:71.1-71.43
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:72.1-73.15
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:101.1-101.41
def $compat_range(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:104.1-105.55
   clause 0(typeIR_l, typeIR_r) = $compat'_range($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:102.1-102.42
def $compat'_range(typeIR, typeIR) : bool =

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:106.1-106.38
   clause 0(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `IntT`

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:107.1-107.44
   clause 1(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:108.1-108.44
   clause 2(typeIR, typeIR') = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w) = numberTypeIR
      -- if typeIR' <: numberTypeIR
      -- let numberTypeIR' = typeIR' as numberTypeIR
      -- if numberTypeIR' matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(w') = numberTypeIR'
      -- if (w = w')

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:109.1-110.15
   clause 3(typeIR_l, typeIR_r) = false
      -- otherwise

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:149.1-151.23
relation SelectCase_keysets_ok: `%%|-%:%`(typingContext, typeIR*, keysetExpression*, keysetExpressionIR*)

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:155.1-156.32
   rule defaultK-zero-to-one: `%%|-%:%`(TC, typeIR*{typeIR <- typeIR*}, keysetExpression*{keysetExpression <- keysetExpression*}, [`DefaultK`_keysetExpressionIR()])
      -- if typeIR*{typeIR <- typeIR*} matches []
      -- if (keysetExpression*{keysetExpression <- keysetExpression*} = [`DefaultK`_keysetExpression()])

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:158.1-162.61
   rule defaultK-many-to-one: `%%|-%:%`(TC, typeIR_key*{typeIR_key <- typeIR_key*}, keysetExpression*{keysetExpression <- keysetExpression*}, [keysetExpressionIR])
      -- if (keysetExpression*{keysetExpression <- keysetExpression*} = [`DefaultK`_keysetExpression()])
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
      -- SelectCase_keyset_ok: `%%|-%:%`(TC, `SeqT%`_sequenceTypeIR(typeIR_key*{typeIR_key <- typeIR_key*}) as typeIR, `DefaultK`_keysetExpression(), keysetExpressionIR)

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:166.1-170.57
   rule anyK-many-to-one: `%%|-%:%`(TC, typeIR_key*{typeIR_key <- typeIR_key*}, keysetExpression*{keysetExpression <- keysetExpression*}, [keysetExpressionIR])
      -- if (keysetExpression*{keysetExpression <- keysetExpression*} = [`AnyK`_keysetExpression()])
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
      -- SelectCase_keyset_ok: `%%|-%:%`(TC, `SeqT%`_sequenceTypeIR(typeIR_key*{typeIR_key <- typeIR_key*}) as typeIR, `AnyK`_keysetExpression(), keysetExpressionIR)

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:174.1-180.63
   rule list: `%%|-%:%`(TC, typeIR_key*{typeIR_key <- typeIR_key*}, keysetExpression*{keysetExpression <- keysetExpression*}, keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*})
      -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| = |keysetExpression*{keysetExpression <- keysetExpression*}|)
      -- (SelectCase_keyset_ok: `%%|-%:%`(TC, typeIR_key, keysetExpression, keysetExpressionIR))*{keysetExpression <- keysetExpression*, keysetExpressionIR <- keysetExpressionIR*, typeIR_key <- typeIR_key*}

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:184.1-186.26
relation SelectCase_ok: `%%%|-%:%`(typingContext, name*, typeIR*, selectCase, selectCaseIR)

   ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:188.1-195.28
   rule : `%%%|-%:%`(TC, name_state*{name_state <- name_state*}, typeIR_key*{typeIR_key <- typeIR_key*}, `%%`_selectCase(keysetExpression*{keysetExpression <- keysetExpression*}, name), `%%`_selectCaseIR(keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*}, name))
      -- SelectCase_keysets_ok: `%%|-%:%`(TC, typeIR_key*{typeIR_key <- typeIR_key*}, keysetExpression*{keysetExpression <- keysetExpression*}, keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*})
      -- if name <- name_state*{name_state <- name_state*}

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:7.1-7.52
def $compat_table_exact_optional_key(typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:10.1-11.54
   clause 0(typeIR) = $compat'_table_exact_optional_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:8.1-8.53
def $compat'_table_exact_optional_key(typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:12.1-12.52
   clause 0(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `BoolT`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:13.1-13.51
   clause 1(typeIR) = true
      -- if typeIR <: primitiveTypeIR
      -- let primitiveTypeIR = typeIR as primitiveTypeIR
      -- if primitiveTypeIR matches `ErrT`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:14.1-14.59
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:15.1-16.45
   clause 3(typeIR') = $compat_table_exact_optional_key(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:17.1-17.56
   clause 4(typeIR) = true
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if enumTypeIR matches `EnumT%%`
      -- let `EnumT%%`_enumTypeIR(_tid, _id*{_id <- _id*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:18.1-19.45
   clause 5(typeIR') = $compat_table_exact_optional_key(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:20.1-21.15
   clause 6(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:23.1-23.55
def $compat_table_lpm_ternary_range_key(typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:26.1-27.57
   clause 0(typeIR) = $compat'_table_lpm_ternary_range_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:24.1-24.56
def $compat'_table_lpm_ternary_range_key(typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:28.1-28.54
   clause 0(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `IntT`

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:29.1-29.57
   clause 1(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FIntT%`
      -- let `FIntT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:30.1-30.57
   clause 2(typeIR) = true
      -- if typeIR <: numberTypeIR
      -- let numberTypeIR = typeIR as numberTypeIR
      -- if numberTypeIR matches `FBitT%`
      -- let `FBitT%`_numberTypeIR(_nat) = numberTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:31.1-32.48
   clause 3(typeIR') = $compat_table_lpm_ternary_range_key(typeIR)
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR = typeIR' as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(_tid, typeIR) = aliasTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:33.1-34.48
   clause 4(typeIR') = $compat_table_lpm_ternary_range_key(typeIR)
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR = typeIR' as enumTypeIR
      -- if enumTypeIR matches `SEnumT%%%`
      -- let `SEnumT%%%`_enumTypeIR(_tid, typeIR, _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) = enumTypeIR

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:35.1-36.15
   clause 5(_typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:38.1-38.43
def $compat_table_key(name, typeIR) : bool =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:40.1-42.49
   clause 0(name, typeIR) = true
      -- if ((name = "exact") \/ (name = "optional"))
      -- if $compat_table_exact_optional_key(typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:44.1-46.52
   clause 1(name, typeIR) = true
      -- if (((name = "lpm") \/ (name = "ternary")) \/ (name = "range"))
      -- if $compat_table_lpm_ternary_range_key(typeIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:48.1-49.15
   clause 2(name, typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:90.1-91.41
def $split_dataplane_parameters(parameterTypeIR*) : (parameterTypeIR*, parameterTypeIR*) =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:93.1-93.50
   clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = ([], [])
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:94.1-98.56
   clause 1(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_h :: parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let `%%%%`_parameterTypeIR(direction, _typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR_h
      -- if direction matches `NO`
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:99.1-104.56
   clause 2(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = (parameterTypeIR_h :: parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let `%%%%`_parameterTypeIR(direction, _typeIR, _id, _value?{_value <- _value?}) = parameterTypeIR_h
      -- if (direction =/= `NO`_direction())
      -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:214.1-217.26
relation TableEntry_keyset_ok: `%%|-%%:%%`(typingContext, tableContext, matchKey, keysetExpression, tableEntryState, keysetExpressionIR)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:221.1-234.65
   rule exprK-lpm: `%%|-%%:%%`(TC, TBLC, (typeIR_key, text), keysetExpression, `LPM%`_tableEntryState(n), `ExprK%`_keysetExpressionIR(typedExpressionIR_set))
      -- if (text = "lpm")
      -- if keysetExpression matches `ExprK%`
      -- let `ExprK%`_keysetExpression(expression) = keysetExpression
      -- let matchMode = TBLC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM%`_matchMode(n) = matchMode
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, ctk)) = typedExpressionIR
      -- if Sub_impl: `%<:%`(typeIR, typeIR_key) holds
      -- let typeIR_set = `SetT%`_setTypeIR(typeIR_key) as typeIR
      -- let typedExpressionIR_set = `%%`_typedExpressionIR(`CastE%%`_castExpressionIR(typeIR_set, typedExpressionIR) as expressionIR, `(%%)`_expressionNoteIR(typeIR_set, ctk))

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:236.1-249.65
   rule exprK-non-lpm: `%%|-%%:%%`(TC, TBLC, (typeIR_key, name_matchkind), keysetExpression, `NOLPM`_tableEntryState(), `ExprK%`_keysetExpressionIR(typedExpressionIR_set))
      -- if keysetExpression matches `ExprK%`
      -- let `ExprK%`_keysetExpression(expression) = keysetExpression
      -- if (name_matchkind =/= "lpm")
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression, typedExpressionIR)
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR, ctk)) = typedExpressionIR
      -- if Sub_impl: `%<:%`(typeIR, typeIR_key) holds
      -- let typeIR_set = `SetT%`_setTypeIR(typeIR_key) as typeIR
      -- let typedExpressionIR_set = `%%`_typedExpressionIR(`CastE%%`_castExpressionIR(typeIR_set, typedExpressionIR) as expressionIR, `(%%)`_expressionNoteIR(typeIR_set, ctk))

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:253.1-280.70
   rule maskK-lpm: `%%|-%%:%%`(TC, TBLC, (typeIR_key, text), keysetExpression, `LPM%`_tableEntryState(n_prefix), `MaskK%%`_keysetExpressionIR(typedExpressionIR_l_reduced, typedExpressionIR_r_reduced))
      -- if (text = "lpm")
      -- if keysetExpression matches `MaskK%%`
      -- let `MaskK%%`_keysetExpression(expression_l, expression_r) = keysetExpression
      -- let matchMode = TBLC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM%`_matchMode(n) = matchMode
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_reduced, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- if Sub_impl: `%<:%`(typeIR_reduced, typeIR_key) holds
      -- if (ctk_r_reduced = `LCTK`_ctk())
      -- Eval_static: `%%|-%~>%`(`LOCAL`_cursor(), TC, typedExpressionIR_r_reduced, value_r)
      -- let int?{int <- int?} = $to_number(value_r)
      -- if int?{int <- int?} matches (_)
      -- let ?(i_r) = int?{int <- int?}
      -- let n_prefix = $tableEntry_lpm_prefix(`FBitV%%`_numberValue(n, $to_bitstr(n as int, i_r)) as value)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:282.1-301.44
   rule maskK-ternary: `%%|-%%:%%`(TC, TBLC, (typeIR_key, text), keysetExpression, `NOLPM`_tableEntryState(), `MaskK%%`_keysetExpressionIR(typedExpressionIR_l_reduced, typedExpressionIR_r_reduced))
      -- if (text = "ternary")
      -- if keysetExpression matches `MaskK%%`
      -- let `MaskK%%`_keysetExpression(expression_l, expression_r) = keysetExpression
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_reduced, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- if Sub_impl: `%<:%`(typeIR_reduced, typeIR_key) holds

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:305.1-324.44
   rule rangeK-range: `%%|-%%:%%`(TC, TBLC, (typeIR_key, text), keysetExpression, `NOLPM`_tableEntryState(), `RangeK%%`_keysetExpressionIR(typedExpressionIR_l_reduced, typedExpressionIR_r_reduced))
      -- if (text = "range")
      -- if keysetExpression matches `RangeK%%`
      -- let `RangeK%%`_keysetExpression(expression_l, expression_r) = keysetExpression
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_l, typedExpressionIR_l)
      -- Expr_ok: `%%|-%:%`(`LOCAL`_cursor(), TC, expression_r, typedExpressionIR_r)
      -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
      -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
      -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
      -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range)
      -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
      -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_reduced, ctk_r_reduced)) = typedExpressionIR_r_reduced
      -- if Sub_impl: `%<:%`(typeIR_reduced, typeIR_key) holds

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:328.1-331.31
   rule defaultK-lpm: `%%|-%%:%%`(TC, TBLC, (typeIR_key, text), keysetExpression, `LPM%`_tableEntryState(n), `DefaultK`_keysetExpressionIR())
      -- if (text = "lpm")
      -- if keysetExpression matches `DefaultK`
      -- let matchMode = TBLC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM%`_matchMode(n) = matchMode

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:333.1-336.35
   rule defaultK-else: `%%|-%%:%%`(TC, TBLC, (typeIR_key, name_matchkind), keysetExpression, `NOLPM`_tableEntryState(), `DefaultK`_keysetExpressionIR())
      -- if keysetExpression matches `DefaultK`
      -- if (name_matchkind =/= "exact")

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:340.1-343.31
   rule anyK-lpm: `%%|-%%:%%`(TC, TBLC, (typeIR_key, text), keysetExpression, `LPM%`_tableEntryState(0), `AnyK`_keysetExpressionIR())
      -- if (text = "lpm")
      -- if keysetExpression matches `AnyK`
      -- let matchMode = TBLC.MODE
      -- if matchMode matches `NOPRILPM%`
      -- let `NOPRILPM%`_matchMode(_nat) = matchMode

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:345.1-348.35
   rule anyK-else: `%%|-%%:%%`(TC, TBLC, (typeIR_key, name_matchkind), keysetExpression, `NOLPM`_tableEntryState(), `AnyK`_keysetExpressionIR())
      -- if keysetExpression matches `AnyK`
      -- if (name_matchkind =/= "exact")

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:356.1-359.29
relation TableEntry_keysets_ok': `%%%|-%%:%%`(typingContext, tableContext, tableEntryState, matchKey*, keysetExpression*, tableEntryState, keysetExpressionIR*)

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:361.1-362.37
   rule nil: `%%%|-%%:%%`(TC, TBLC, TBLS, matchKey*{matchKey <- matchKey*}, keysetExpression*{keysetExpression <- keysetExpression*}, TBLS, [])
      -- if matchKey*{matchKey <- matchKey*} matches []
      -- if keysetExpression*{keysetExpression <- keysetExpression*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:364.1-374.53
   rule cons: `%%%|-%%:%%`(TC, TBLC, TBLS_0, matchKey*{matchKey <- matchKey*}, keysetExpression*{keysetExpression <- keysetExpression*}, TBLS_3, keysetExpressionIR_h :: keysetExpressionIR_t*{keysetExpressionIR_t <- keysetExpressionIR_t*})
      -- if matchKey*{matchKey <- matchKey*} matches _ :: _
      -- let matchKey_h :: matchKey_t*{matchKey_t <- matchKey_t*} = matchKey*{matchKey <- matchKey*}
      -- if keysetExpression*{keysetExpression <- keysetExpression*} matches _ :: _
      -- let keysetExpression_h :: keysetExpression_t*{keysetExpression_t <- keysetExpression_t*} = keysetExpression*{keysetExpression <- keysetExpression*}
      -- TableEntry_keyset_ok: `%%|-%%:%%`(TC, TBLC, matchKey_h, keysetExpression_h, TBLS_1, keysetExpressionIR_h)
      -- let TBLS_2 = $join_tableEntryState(TBLS_0, TBLS_1)
      -- TableEntry_keysets_ok': `%%%|-%%:%%`(TC, TBLC, TBLS_2, matchKey_t*{matchKey_t <- matchKey_t*}, keysetExpression_t*{keysetExpression_t <- keysetExpression_t*}, TBLS_3, keysetExpressionIR_t*{keysetExpressionIR_t <- keysetExpressionIR_t*})

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:708.1-708.44
def $count_table_keys(tableProperty*) : nat =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:710.1-710.31
   clause 0(tableProperty*{tableProperty <- tableProperty*}) = 0
      -- if tableProperty*{tableProperty <- tableProperty*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:711.1-714.47
   clause 1(tableProperty'*{tableProperty' <- tableProperty'*}) = (1 + $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*}))
      -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
      -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
      -- if tableProperty matches `KeyP%`
      -- let `KeyP%`_tableProperty(_tableKey*{_tableKey <- _tableKey*}) = tableProperty

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:715.1-718.40
   clause 2(tableProperty'*{tableProperty' <- tableProperty'*}) = $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*})
      -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
      -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
      -- if tableProperty matches `ActionP%`
      -- let `ActionP%`_tableProperty(_tableAction*{_tableAction <- _tableAction*}) = tableProperty

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:719.1-722.40
   clause 3(tableProperty'*{tableProperty' <- tableProperty'*}) = $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*})
      -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
      -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
      -- if tableProperty matches `EntryP%%`
      -- let `EntryP%%`_tableProperty(_const?{_const <- _const?}, _tableEntry*{_tableEntry <- _tableEntry*}) = tableProperty

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:723.1-726.40
   clause 4(tableProperty'*{tableProperty' <- tableProperty'*}) = $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*})
      -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
      -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
      -- if tableProperty matches `CustomP%%%`
      -- let `CustomP%%%`_tableProperty(_const?{_const <- _const?}, _name, _initializer) = tableProperty

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:728.1-728.47
def $count_table_actions(tableProperty*) : nat =

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:730.1-730.34
   clause 0(tableProperty*{tableProperty <- tableProperty*}) = 0
      -- if tableProperty*{tableProperty <- tableProperty*} matches []

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:731.1-734.50
   clause 1(tableProperty'*{tableProperty' <- tableProperty'*}) = (1 + $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*}))
      -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
      -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
      -- if tableProperty matches `ActionP%`
      -- let `ActionP%`_tableProperty(_tableAction*{_tableAction <- _tableAction*}) = tableProperty

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:735.1-738.43
   clause 2(tableProperty'*{tableProperty' <- tableProperty'*}) = $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*})
      -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
      -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
      -- if tableProperty matches `KeyP%`
      -- let `KeyP%`_tableProperty(_tableKey*{_tableKey <- _tableKey*}) = tableProperty

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:739.1-742.43
   clause 3(tableProperty'*{tableProperty' <- tableProperty'*}) = $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*})
      -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
      -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
      -- if tableProperty matches `EntryP%%`
      -- let `EntryP%%`_tableProperty(_const?{_const <- _const?}, _tableEntry*{_tableEntry <- _tableEntry*}) = tableProperty

   ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:743.1-746.43
   clause 4(tableProperty'*{tableProperty' <- tableProperty'*}) = $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*})
      -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
      -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
      -- if tableProperty matches `CustomP%%%`
      -- let `CustomP%%%`_tableProperty(_const?{_const <- _const?}, _name, _initializer) = tableProperty

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:7.1-7.73
def $filter_default_parameters(parameterTypeIR*, id*) : parameterTypeIR* =

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:9.1-9.55
   clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = []
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:10.1-16.28
   clause 1(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let `%%%%`_parameterTypeIR(_direction, _typeIR, id_h, _value?{_value <- _value?}) = parameterTypeIR_h
      -- if id_h <- id_default*{id_default <- id_default*}

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:17.1-23.31
   clause 2(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = parameterTypeIR_h :: $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})
      -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
      -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
      -- let `%%%%`_parameterTypeIR(_direction, _typeIR, id_h, _value?{_value <- _value?}) = parameterTypeIR_h
      -- if ~id_h <- id_default*{id_default <- id_default*}

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:27.1-27.71
def $align_parameters(parameterTypeIR*, argumentIR*) : parameterTypeIR* =

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:30.1-33.90
   clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}
      -- (let `%%%%`_parameterTypeIR(_direction, _typeIR, id, _value?{_value <- _value?}) = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
      -- (let parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?} = $align_parameters'(`{%}`_set<pair<id, parameterTypeIR>>(`%->%`_pair<id, parameterTypeIR>(id, parameterTypeIR)*{id <- id*, parameterTypeIR <- parameterTypeIR*}), parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, parameterTypeIR <- parameterTypeIR*, parameterTypeIR'? <- parameterTypeIR'?*}
      -- (if parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?} matches (_))*{parameterTypeIR'? <- parameterTypeIR'?*}
      -- (let ?(parameterTypeIR_aligned) = parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?})*{parameterTypeIR'? <- parameterTypeIR'?*, parameterTypeIR_aligned <- parameterTypeIR_aligned*}

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:28.1-28.96
def $align_parameters'(map<id, parameterTypeIR>, parameterTypeIR, argumentIR) : parameterTypeIR? =

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:35.1-36.20
   clause 0(_map<id, parameterTypeIR>, parameterTypeIR, argumentIR) = ?(parameterTypeIR)
      -- if argumentIR matches `ExprA%`
      -- let `ExprA%`_argumentIR(_typedExpressionIR) = argumentIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:37.1-38.78
   clause 1(`{%}`_set<pair<id, parameterTypeIR>>(`%->%`_pair<id, parameterTypeIR>(id_param, parameterTypeIR)*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*}), _parameterTypeIR, argumentIR) = $find_map<id, parameterTypeIR>(`{%}`_set<pair<id, parameterTypeIR>>(`%->%`_pair<id, parameterTypeIR>(id_param, parameterTypeIR)*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*}), name)
      -- if argumentIR matches `NameA%%`
      -- let `NameA%%`_argumentIR(name, _typedExpressionIR) = argumentIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:39.1-40.78
   clause 2(`{%}`_set<pair<id, parameterTypeIR>>(`%->%`_pair<id, parameterTypeIR>(id_param, parameterTypeIR)*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*}), _parameterTypeIR, argumentIR) = $find_map<id, parameterTypeIR>(`{%}`_set<pair<id, parameterTypeIR>>(`%->%`_pair<id, parameterTypeIR>(id_param, parameterTypeIR)*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*}), name)
      -- if argumentIR matches `NameAnyA%`
      -- let `NameAnyA%`_argumentIR(name) = argumentIR

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:41.1-42.20
   clause 3(_map<id, parameterTypeIR>, parameterTypeIR, argumentIR) = ?(parameterTypeIR)
      -- if argumentIR matches `AnyA`

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:61.1-63.23
relation Expr_lvalue_ok: `%%|-%`(cursor, typingContext, typedExpressionIR)

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:65.1-68.45
   rule nameE: `%%|-%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)))
      -- if expressionIR <: referenceExpression
      -- let `NameE%`_referenceExpression(prefixedName) = expressionIR as referenceExpression
      -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedName)
      -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
      -- let ?(`%%%%`_varTypeIR(direction, _typeIR', ctk, _value?{_value <- _value?})) = varTypeIR?{varTypeIR <- varTypeIR?}
      -- if ctk matches `DYN`
      -- if ((direction = `OUT`_direction()) \/ (direction = `INOUT`_direction()))

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:70.1-80.68
   rule expraccE-stack: `%%|-%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)))
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessExpressionIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessExpressionIR matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, name) = memberAccessExpressionIR
      -- if Expr_lvalue_ok: `%%|-%`(p, TC, typedExpressionIR_base) holds
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk')) = typedExpressionIR_base
      -- let typeIR' = $canon(typeIR_base)
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR, _nat) = typeIR' as headerStackTypeIR
      -- if ((name = "next") \/ (name = "last"))
      -- if (((p = `BLOCK`_cursor()) /\ $is_parser_blockKind(TC.BLOCK.KIND)) \/ ((p = `LOCAL`_cursor()) /\ $is_parser_state_localKind(TC.LOCAL.KIND)))

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:82.1-87.52
   rule expraccE-non-stack: `%%|-%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)))
      -- if expressionIR <: memberAccessExpressionIR
      -- let memberAccessExpressionIR = expressionIR as memberAccessExpressionIR
      -- if memberAccessExpressionIR matches `ExprAccE%%`
      -- let `ExprAccE%%`_memberAccessExpressionIR(typedExpressionIR_base, name) = memberAccessExpressionIR
      -- if Expr_lvalue_ok: `%%|-%`(p, TC, typedExpressionIR_base) holds
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_base, _ctk')) = typedExpressionIR_base
      -- if ~$is_headerStackTypeIR($canon(typeIR_base))

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:89.1-91.52
   rule arraccE: `%%|-%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)))
      -- if expressionIR <: indexAccessExpressionIR
      -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
      -- if indexAccessExpressionIR matches `ArrAccE%%`
      -- let `ArrAccE%%`_indexAccessExpressionIR(typedExpressionIR_base, typedExpressionIR_index) = indexAccessExpressionIR
      -- if Expr_lvalue_ok: `%%|-%`(p, TC, typedExpressionIR_base) holds

   ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:93.1-96.52
   rule bitaccE: `%%|-%`(p, TC, `%%`_typedExpressionIR(expressionIR, `(%%)`_expressionNoteIR(_typeIR, _ctk)))
      -- if expressionIR <: indexAccessExpressionIR
      -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
      -- if indexAccessExpressionIR matches `BitAccE%%%`
      -- let `BitAccE%%%`_indexAccessExpressionIR(typedExpressionIR_base, typedExpressionIR_hi, typedExpressionIR_lo) = indexAccessExpressionIR
      -- if Expr_lvalue_ok: `%%|-%`(p, TC, typedExpressionIR_base) holds

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:6.1-7.12
syntax infer = 
   | `KNOWN%`(typeIR)
   | `UNKNOWN`()

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:9.21-9.36
syntax constraint = map<tid, infer>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:11.1-11.41
def $empty_constraint(tid*) : constraint =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:12.1-12.53
   clause 0(tid*{tid <- tid*}) = `{%}`_set<pair<tid, infer>>(`%->%`_pair<tid, infer>(tid, `UNKNOWN`_infer())*{tid <- tid*})

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:14.20-14.36
syntax inference = map<tid, typeIR>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:20.1-20.61
def $infer(tid*, parameterTypeIR*, argumentIR*) : inference? =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:44.1-53.62
   clause 0(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = $resolve_constraint(constraint_inferred)
      -- let constraint_init = $empty_constraint(tid_infer*{tid_infer <- tid_infer*})
      -- if (|parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}| = |argumentIR*{argumentIR <- argumentIR*}|)
      -- (let constraint?{constraint <- constraint?} = $infer'(constraint_init, parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, constraint? <- constraint?*, parameterTypeIR <- parameterTypeIR*}
      -- (if constraint?{constraint <- constraint?} matches (_))*{constraint? <- constraint?*}
      -- (let ?(constraint_pair) = constraint?{constraint <- constraint?})*{constraint? <- constraint?*, constraint_pair <- constraint_pair*}
      -- let constraint'?{constraint' <- constraint'?} = $merge_constraints(constraint_init, constraint_pair*{constraint_pair <- constraint_pair*})
      -- if constraint'?{constraint' <- constraint'?} matches (_)
      -- let ?(constraint_inferred) = constraint'?{constraint' <- constraint'?}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:55.1-57.15
   clause 1(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:21.1-21.67
def $infer'(constraint, parameterTypeIR, argumentIR) : constraint? =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:59.1-62.48
   clause 0(constraint, parameterTypeIR, argumentIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if argumentIR matches `ExprA%`
      -- let `ExprA%`_argumentIR(typedExpressionIR) = argumentIR
      -- let `%%%%`_parameterTypeIR(_direction, typeIR_param, _id, _value?{_value <- _value?}) = parameterTypeIR
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_arg, _ctk)) = typedExpressionIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:64.1-67.48
   clause 1(constraint, parameterTypeIR, argumentIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if argumentIR matches `NameA%%`
      -- let `NameA%%`_argumentIR(name, typedExpressionIR) = argumentIR
      -- let `%%%%`_parameterTypeIR(_direction, typeIR_param, _id, _value?{_value <- _value?}) = parameterTypeIR
      -- let `%%`_typedExpressionIR(_expressionIR, `(%%)`_expressionNoteIR(typeIR_arg, _ctk)) = typedExpressionIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:69.1-69.69
   clause 2(constraint, parameterTypeIR, argumentIR) = ?(constraint)
      -- if argumentIR matches `NameAnyA%`
      -- let `NameAnyA%`_argumentIR(name) = argumentIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:71.1-71.60
   clause 3(constraint, parameterTypeIR, argumentIR) = ?(constraint)
      -- if argumentIR matches `AnyA`

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:73.1-75.15
   clause 4(constraint, parameterTypeIR, argumentIR) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:23.1-23.67
def $gen_constraint_type(constraint, typeIR, typeIR) : constraint? =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:83.1-84.15
   clause 0(constraint, typeIR, typeIR') = ?(constraint)
      -- if typeIR <: baseTypeIR
      -- let baseTypeIR = typeIR as baseTypeIR
      -- if typeIR' <: baseTypeIR
      -- let baseTypeIR' = typeIR' as baseTypeIR
      -- if (baseTypeIR = baseTypeIR')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:88.1-90.66
   clause 1(constraint, typeIR, typeIR_arg) = ?($update_map<tid, infer>(constraint, tid_param, `KNOWN%`_infer(typeIR_arg)))
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `NameT%`
      -- let `NameT%`_namedTypeIR(tid_param) = namedTypeIR
      -- if $in_set<tid>(tid_param, $dom_map<tid, infer>(constraint))

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:92.1-113.26
   clause 2(constraint_0, typeIR, typeIR') = ?(constraint_2)
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(polyTypeDefIR_param, typeIR_param*{typeIR_param <- typeIR_param*}) = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(polyTypeDefIR_arg, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = namedTypeIR'
      -- let typeIR_specialized_param = $specialize_typeDef(polyTypeDefIR_param as typeDefIR, typeIR_param*{typeIR_param <- typeIR_param*})
      -- let typeIR_specialized_arg = $specialize_typeDef(polyTypeDefIR_arg as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if ($is_nominal_typeIR(typeIR_specialized_param) /\ $is_nominal_typeIR(typeIR_specialized_arg))
      -- let constraint?{constraint <- constraint?} = $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg)
      -- if constraint?{constraint <- constraint?} matches (_)
      -- let ?(constraint_1) = constraint?{constraint <- constraint?}
      -- let constraint'?{constraint' <- constraint'?} = $gen_constraint_types(constraint_1, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if constraint'?{constraint' <- constraint'?} matches (_)
      -- let ?(constraint_2) = constraint'?{constraint' <- constraint'?}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:115.1-131.26
   clause 3(constraint_0, typeIR, typeIR') = ?(constraint_1)
      -- if typeIR <: namedTypeIR
      -- let namedTypeIR = typeIR as namedTypeIR
      -- if namedTypeIR matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(polyTypeDefIR_param, typeIR_param*{typeIR_param <- typeIR_param*}) = namedTypeIR
      -- if typeIR' <: namedTypeIR
      -- let namedTypeIR' = typeIR' as namedTypeIR
      -- if namedTypeIR' matches `SpecT%%`
      -- let `SpecT%%`_namedTypeIR(polyTypeDefIR_arg, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = namedTypeIR'
      -- let typeIR_specialized_param = $specialize_typeDef(polyTypeDefIR_param as typeDefIR, typeIR_param*{typeIR_param <- typeIR_param*})
      -- let typeIR_specialized_arg = $specialize_typeDef(polyTypeDefIR_arg as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if (~$is_nominal_typeIR(typeIR_specialized_param) /\ ~$is_nominal_typeIR(typeIR_specialized_arg))
      -- let constraint?{constraint <- constraint?} = $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg)
      -- if constraint?{constraint <- constraint?} matches (_)
      -- let ?(constraint_1) = constraint?{constraint <- constraint?}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:135.1-136.63
   clause 4(constraint, typeIR, typeIR_arg) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `DefT%%`
      -- let `DefT%%`_aliasTypeIR(_tid, typeIR_param) = aliasTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:138.1-139.63
   clause 5(constraint, typeIR_param, typeIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `DefT%%`
      -- let `DefT%%`_aliasTypeIR(_tid, typeIR_arg) = aliasTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:141.1-142.63
   clause 6(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: aliasTypeIR
      -- let aliasTypeIR = typeIR as aliasTypeIR
      -- if aliasTypeIR matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(tid, typeIR_param) = aliasTypeIR
      -- if typeIR' <: aliasTypeIR
      -- let aliasTypeIR' = typeIR' as aliasTypeIR
      -- if aliasTypeIR' matches `NewT%%`
      -- let `NewT%%`_aliasTypeIR(tid', typeIR_arg) = aliasTypeIR'
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:146.1-151.63
   clause 7(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: listTypeIR
      -- let `ListT%`_listTypeIR(typeIR_param) = typeIR as listTypeIR
      -- if typeIR' <: listTypeIR
      -- let `ListT%`_listTypeIR(typeIR_arg) = typeIR' as listTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:153.1-158.66
   clause 8(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR_param*{typeIR_param <- typeIR_param*}) = typeIR as tupleTypeIR
      -- if typeIR' <: tupleTypeIR
      -- let `TupleT%`_tupleTypeIR(typeIR_arg*{typeIR_arg <- typeIR_arg*}) = typeIR' as tupleTypeIR

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:160.1-165.63
   clause 9(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
      -- if typeIR <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR_param, n_size) = typeIR as headerStackTypeIR
      -- if typeIR' <: headerStackTypeIR
      -- let `HeaderStackT%%`_headerStackTypeIR(typeIR_arg, n_size') = typeIR' as headerStackTypeIR
      -- if (n_size = n_size')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:167.1-172.66
   clause 10(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: structTypeIR
      -- let `StructT%%`_structTypeIR(tid, `%%`_fieldTypeIR(typeIR_param, id_field)*{id_field <- id_field*, typeIR_param <- typeIR_param*}) = typeIR as structTypeIR
      -- if typeIR' <: structTypeIR
      -- let `StructT%%`_structTypeIR(tid', `%%`_fieldTypeIR(typeIR_arg, id_field')*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*}) = typeIR' as structTypeIR
      -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:174.1-179.66
   clause 11(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(tid, `%%`_fieldTypeIR(typeIR_param, id_field)*{id_field <- id_field*, typeIR_param <- typeIR_param*}) = typeIR as headerTypeIR
      -- if typeIR' <: headerTypeIR
      -- let `HeaderT%%`_headerTypeIR(tid', `%%`_fieldTypeIR(typeIR_arg, id_field')*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*}) = typeIR' as headerTypeIR
      -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:181.1-186.66
   clause 12(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(tid, `%%`_fieldTypeIR(typeIR_param, id_field)*{id_field <- id_field*, typeIR_param <- typeIR_param*}) = typeIR as headerUnionTypeIR
      -- if typeIR' <: headerUnionTypeIR
      -- let `HeaderUnionT%%`_headerUnionTypeIR(tid', `%%`_fieldTypeIR(typeIR_arg, id_field')*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*}) = typeIR' as headerUnionTypeIR
      -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:188.1-191.15
   clause 13(constraint, typeIR, typeIR') = ?(constraint)
      -- if typeIR <: enumTypeIR
      -- let enumTypeIR = typeIR as enumTypeIR
      -- if typeIR' <: enumTypeIR
      -- let enumTypeIR' = typeIR' as enumTypeIR
      -- if (enumTypeIR = enumTypeIR')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:195.1-204.6
   clause 14(constraint, typeIR, typeIR') = $gen_constraint_routines(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*})
      -- if typeIR <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(tid, `{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(rid, routineTypeDefIR_param)*{rid <- rid*, routineTypeDefIR_param <- routineTypeDefIR_param*})) = typeIR as externObjectTypeIR
      -- if typeIR' <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(tid', `{%}`_set<pair<rid, routineTypeDefIR>>(`%->%`_pair<rid, routineTypeDefIR>(rid', routineTypeDefIR_arg)*{rid' <- rid'*, routineTypeDefIR_arg <- routineTypeDefIR_arg*})) = typeIR' as externObjectTypeIR
      -- (if (rid = rid'))*{rid <- rid*, rid' <- rid'*}
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:206.1-213.58
   clause 15(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*}) = typeIR as parserObjectTypeIR
      -- if typeIR' <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*}) = typeIR' as parserObjectTypeIR
      -- (let `%%%%`_parameterTypeIR(direction, typeIR_param, _id, _value?{_value <- _value?}) = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let `%%%%`_parameterTypeIR(direction', typeIR_arg, _id', _value'?{_value' <- _value'?}) = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:215.1-222.58
   clause 16(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*}) = typeIR as controlObjectTypeIR
      -- if typeIR' <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*}) = typeIR' as controlObjectTypeIR
      -- (let `%%%%`_parameterTypeIR(direction, typeIR_param, _id, _value?{_value <- _value?}) = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let `%%%%`_parameterTypeIR(direction', typeIR_arg, _id', _value'?{_value' <- _value'?}) = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:224.1-229.66
   clause 17(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if typeIR <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(tid, typeIR_param*{typeIR_param <- typeIR_param*}) = typeIR as packageObjectTypeIR
      -- if typeIR' <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(tid', typeIR_arg*{typeIR_arg <- typeIR_arg*}) = typeIR' as packageObjectTypeIR
      -- if (tid = tid')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:231.1-236.15
   clause 18(constraint, typeIR, typeIR') = ?(constraint)
      -- if typeIR <: tableObjectTypeIR
      -- let tableObjectTypeIR = typeIR as tableObjectTypeIR
      -- if typeIR' <: tableObjectTypeIR
      -- let tableObjectTypeIR' = typeIR' as tableObjectTypeIR
      -- if (tableObjectTypeIR = tableObjectTypeIR')

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:240.1-242.15
   clause 19(constraint, typeIR_param, typeIR_arg) = ?(constraint)
      -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:24.1-24.70
def $gen_constraint_types(constraint, typeIR*, typeIR*) : constraint? =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:246.1-250.69
   clause 0(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})
      -- if (|typeIR_param*{typeIR_param <- typeIR_param*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
      -- (let constraint'?{constraint' <- constraint'?} = $gen_constraint_type(constraint, typeIR_param, typeIR_arg))*{constraint'? <- constraint'?*, typeIR_arg <- typeIR_arg*, typeIR_param <- typeIR_param*}
      -- (if constraint'?{constraint' <- constraint'?} matches (_))*{constraint'? <- constraint'?*}
      -- (let ?(constraint_pair) = constraint'?{constraint' <- constraint'?})*{constraint'? <- constraint'?*, constraint_pair <- constraint_pair*}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:252.1-254.15
   clause 1(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:25.1-28.16
def $gen_constraint_routine(constraint, routineTypeDefIR, routineTypeDefIR) : constraint? =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:258.1-269.77
   clause 0(constraint_0, routineTypeDefIR, routineTypeDefIR') = ?(constraint_2)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, _tid*{_tid <- _tid*}, _tid'*{_tid' <- _tid'*}) = routineTypeDefIR as polyRoutineTypeDefIR
      -- if routineTypeIR matches `ExternMethodT%%`
      -- let `ExternMethodT%%`_routineTypeIR(parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*}, typeIR_ret_param) = routineTypeIR
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR', _tid''*{_tid'' <- _tid''*}, _tid'''*{_tid''' <- _tid'''*}) = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if routineTypeIR' matches `ExternMethodT%%`
      -- let `ExternMethodT%%`_routineTypeIR(parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*}, typeIR_ret_arg) = routineTypeIR'
      -- (let `%%%%`_parameterTypeIR(direction, typeIR_param, _id, _value?{_value <- _value?}) = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let `%%%%`_parameterTypeIR(direction', typeIR_arg, _id', _value'?{_value' <- _value'?}) = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}
      -- let constraint?{constraint <- constraint?} = $gen_constraint_types(constraint_0, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if constraint?{constraint <- constraint?} matches (_)
      -- let ?(constraint_1) = constraint?{constraint <- constraint?}
      -- let constraint'?{constraint' <- constraint'?} = $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg)
      -- if constraint'?{constraint' <- constraint'?} matches (_)
      -- let ?(constraint_2) = constraint'?{constraint' <- constraint'?}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:271.1-282.77
   clause 1(constraint_0, routineTypeDefIR, routineTypeDefIR') = ?(constraint_2)
      -- if routineTypeDefIR <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR, _tid*{_tid <- _tid*}, _tid'*{_tid' <- _tid'*}) = routineTypeDefIR as polyRoutineTypeDefIR
      -- if routineTypeIR matches `ExternAbstractMethodT%%`
      -- let `ExternAbstractMethodT%%`_routineTypeIR(parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*}, typeIR_ret_param) = routineTypeIR
      -- if routineTypeDefIR' <: polyRoutineTypeDefIR
      -- let `PolyTD%%%`_polyRoutineTypeDefIR(routineTypeIR', _tid''*{_tid'' <- _tid''*}, _tid'''*{_tid''' <- _tid'''*}) = routineTypeDefIR' as polyRoutineTypeDefIR
      -- if routineTypeIR' matches `ExternAbstractMethodT%%`
      -- let `ExternAbstractMethodT%%`_routineTypeIR(parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*}, typeIR_ret_arg) = routineTypeIR'
      -- (let `%%%%`_parameterTypeIR(direction, typeIR_param, _id, _value?{_value <- _value?}) = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
      -- (let `%%%%`_parameterTypeIR(direction', typeIR_arg, _id', _value'?{_value' <- _value'?}) = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
      -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}
      -- let constraint?{constraint <- constraint?} = $gen_constraint_types(constraint_0, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
      -- if constraint?{constraint <- constraint?} matches (_)
      -- let ?(constraint_1) = constraint?{constraint <- constraint?}
      -- let constraint'?{constraint' <- constraint'?} = $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg)
      -- if constraint'?{constraint' <- constraint'?} matches (_)
      -- let ?(constraint_2) = constraint'?{constraint' <- constraint'?}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:284.1-288.15
   clause 2(constraint, routineTypeDefIR_param, routineTypeDefIR_arg) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:29.1-32.16
def $gen_constraint_routines(constraint, routineTypeDefIR*, routineTypeDefIR*) : constraint? =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:292.1-304.12
   clause 0(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*}) = $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})
      -- if (|routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}| = |routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*}|)
      -- (let constraint'?{constraint' <- constraint'?} = $gen_constraint_routine(constraint, routineTypeDefIR_param, routineTypeDefIR_arg))*{constraint'? <- constraint'?*, routineTypeDefIR_arg <- routineTypeDefIR_arg*, routineTypeDefIR_param <- routineTypeDefIR_param*}
      -- (if constraint'?{constraint' <- constraint'?} matches (_))*{constraint'? <- constraint'?*}
      -- (let ?(constraint_pair) = constraint'?{constraint' <- constraint'?})*{constraint'? <- constraint'?*, constraint_pair <- constraint_pair*}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:306.1-312.15
   clause 1(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:34.1-34.60
def $merge_constraint(constraint, constraint) : constraint? =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:318.1-322.52
   clause 0(constraint_pre, constraint_post) = $merge_constraint'(constraint_pre, constraint_post, tid_pre*{tid_pre <- tid_pre*}, `{%}`_set<pair<tid, infer>>([]))
      -- let `{%}`_set<tid>(tid_pre*{tid_pre <- tid_pre*}) = $dom_map<tid, infer>(constraint_pre)
      -- let `{%}`_set<tid>(tid_post*{tid_post <- tid_post*}) = $dom_map<tid, infer>(constraint_post)
      -- if $eq_set<tid>(`{%}`_set<tid>(tid_pre*{tid_pre <- tid_pre*}), `{%}`_set<tid>(tid_post*{tid_post <- tid_post*}))

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:324.1-325.15
   clause 1(constraint_pre, constraint_post) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:35.1-35.79
def $merge_constraint'(constraint, constraint, tid*, constraint) : constraint? =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:327.1-330.15
   clause 0(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = ?(constraint)
      -- if tid*{tid <- tid*} matches []

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:332.1-341.60
   clause 1(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if (?(`UNKNOWN`_infer()) = $find_map<tid, infer>(constraint_pre, tid_h))
      -- if (?(`UNKNOWN`_infer()) = $find_map<tid, infer>(constraint_post, tid_h))
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `UNKNOWN`_infer())

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:343.1-352.70
   clause 2(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- if (?(`UNKNOWN`_infer()) = $find_map<tid, infer>(constraint_pre, tid_h))
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_post, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWN%`
      -- let `KNOWN%`_infer(typeIR_post) = infer
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `KNOWN%`_infer(typeIR_post))

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:354.1-363.69
   clause 3(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWN%`
      -- let `KNOWN%`_infer(typeIR_pre) = infer
      -- if (?(`UNKNOWN`_infer()) = $find_map<tid, infer>(constraint_post, tid_h))
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `KNOWN%`_infer(typeIR_pre))

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:365.1-375.70
   clause 4(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWN%`
      -- let `KNOWN%`_infer(typeIR_pre) = infer
      -- let infer'''?{infer''' <- infer'''?} = $find_map<tid, infer>(constraint_post, tid_h)
      -- if infer'''?{infer''' <- infer'''?} matches (_)
      -- let ?(infer'') = infer'''?{infer''' <- infer'''?}
      -- if infer'' matches `KNOWN%`
      -- let `KNOWN%`_infer(typeIR_post) = infer''
      -- if Sub_impl: `%<:%`(typeIR_pre, typeIR_post) holds
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `KNOWN%`_infer(typeIR_post))

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:377.1-388.69
   clause 5(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
      -- if tid*{tid <- tid*} matches _ :: _
      -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
      -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
      -- if infer'?{infer' <- infer'?} matches (_)
      -- let ?(infer) = infer'?{infer' <- infer'?}
      -- if infer matches `KNOWN%`
      -- let `KNOWN%`_infer(typeIR_pre) = infer
      -- let infer'''?{infer''' <- infer'''?} = $find_map<tid, infer>(constraint_post, tid_h)
      -- if infer'''?{infer''' <- infer'''?} matches (_)
      -- let ?(infer'') = infer'''?{infer''' <- infer'''?}
      -- if infer'' matches `KNOWN%`
      -- let `KNOWN%`_infer(typeIR_post) = infer''
      -- if ~Sub_impl: `%<:%`(typeIR_pre, typeIR_post) holds
      -- if Sub_impl: `%<:%`(typeIR_post, typeIR_pre) holds
      -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, `KNOWN%`_infer(typeIR_pre))

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:390.1-391.15
   clause 6(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:36.1-36.62
def $merge_constraints(constraint, constraint*) : constraint? =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:393.1-393.61
   clause 0(constraint_pre, constraint*{constraint <- constraint*}) = ?(constraint_pre)
      -- if constraint*{constraint <- constraint*} matches []

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:395.1-403.65
   clause 1(constraint_pre_0, constraint*{constraint <- constraint*}) = ?(constraint_pre_2)
      -- if constraint*{constraint <- constraint*} matches _ :: _
      -- let constraint_post_h :: constraint_post_t*{constraint_post_t <- constraint_post_t*} = constraint*{constraint <- constraint*}
      -- let constraint'?{constraint' <- constraint'?} = $merge_constraint(constraint_pre_0, constraint_post_h)
      -- if constraint'?{constraint' <- constraint'?} matches (_)
      -- let ?(constraint_pre_1) = constraint'?{constraint' <- constraint'?}
      -- let constraint''?{constraint'' <- constraint''?} = $merge_constraints(constraint_pre_1, constraint_post_t*{constraint_post_t <- constraint_post_t*})
      -- if constraint''?{constraint'' <- constraint''?} matches (_)
      -- let ?(constraint_pre_2) = constraint''?{constraint'' <- constraint''?}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:405.1-406.15
   clause 2(constraint_pre, constraint_post*{constraint_post <- constraint_post*}) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:38.1-38.49
def $resolve_constraint(constraint) : inference? =

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:412.1-414.32
   clause 0(`{%}`_set<pair<tid, infer>>(`%->%`_pair<tid, infer>(tid, infer)*{infer <- infer*, tid <- tid*})) = ?(`{%}`_set<pair<tid, typeIR>>(`%->%`_pair<tid, typeIR>(tid, typeIR)*{tid <- tid*, typeIR <- typeIR*}))
      -- (let infer' = infer)*{infer <- infer*, infer' <- infer'*}
      -- (if infer' matches `KNOWN%`)*{infer' <- infer'*}
      -- (let `KNOWN%`_infer(typeIR) = infer')*{infer' <- infer'*, typeIR <- typeIR*}

   ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:416.1-418.15
   clause 1(`{%}`_set<pair<tid, infer>>(`%->%`_pair<tid, infer>(tid, infer)*{infer <- infer*, tid <- tid*})) = ?()
      -- otherwise

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:21.1-21.65
def $instantiable_extern(cursor, typingContext, instctxt) : bool =

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:23.1-23.54
   clause 0(cursor, TC, instctxt) = true
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:24.1-24.53
   clause 1(cursor, TC, instctxt) = true
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:25.1-25.53
   clause 2(cursor, TC, instctxt) = true
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:27.1-27.65
def $instantiable_parser(cursor, typingContext, instctxt) : bool =

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:29.1-30.20
   clause 0(cursor, TC, instctxt) = (instctxt = `ANON`_instctxt())
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:31.1-32.40
   clause 1(cursor, TC, instctxt) = $is_parser_blockKind(TC.BLOCK.KIND)
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:33.1-34.46
   clause 2(cursor, TC, instctxt) = $is_parser_state_localKind(TC.LOCAL.KIND)
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:36.1-36.66
def $instantiable_control(cursor, typingContext, instctxt) : bool =

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:38.1-39.20
   clause 0(cursor, TC, instctxt) = (instctxt = `ANON`_instctxt())
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:40.1-41.41
   clause 1(cursor, TC, instctxt) = $is_control_blockKind(TC.BLOCK.KIND)
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:42.1-43.54
   clause 2(cursor, TC, instctxt) = $is_control_apply_method_localKind(TC.LOCAL.KIND)
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:45.1-45.66
def $instantiable_package(cursor, typingContext, instctxt) : bool =

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:47.1-47.55
   clause 0(cursor, TC, instctxt) = true
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:48.1-49.41
   clause 1(cursor, TC, instctxt) = $is_package_blockKind(TC.BLOCK.KIND)
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:50.1-50.55
   clause 2(cursor, TC, instctxt) = false
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:52.1-52.64
def $instantiable_table(cursor, typingContext, instctxt) : bool =

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:54.1-54.54
   clause 0(cursor, TC, instctxt) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:55.1-56.41
   clause 1(cursor, TC, instctxt) = $is_control_blockKind(TC.BLOCK.KIND)
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:57.1-57.53
   clause 2(cursor, TC, instctxt) = false
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:59.1-59.66
def $instantiable(cursor, typingContext, instctxt, typeIR) : bool =

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:62.1-63.52
   clause 0(p, TC, instctxt, typeIR) = $instantiable'(p, TC, instctxt, $canon(typeIR))

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:60.1-60.67
def $instantiable'(cursor, typingContext, instctxt, typeIR) : bool =

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:65.1-66.42
   clause 0(p, TC, instctxt, typeIR) = $instantiable_extern(p, TC, instctxt)
      -- if typeIR <: externObjectTypeIR
      -- let `ExternT%%`_externObjectTypeIR(_tid, _map<rid, routineTypeDefIR>) = typeIR as externObjectTypeIR

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:67.1-68.42
   clause 1(p, TC, instctxt, typeIR) = $instantiable_parser(p, TC, instctxt)
      -- if typeIR <: parserObjectTypeIR
      -- let `ParserT%`_parserObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as parserObjectTypeIR

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:69.1-70.43
   clause 2(p, TC, instctxt, typeIR) = $instantiable_control(p, TC, instctxt)
      -- if typeIR <: controlObjectTypeIR
      -- let `ControlT%`_controlObjectTypeIR(_parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) = typeIR as controlObjectTypeIR

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:71.1-72.43
   clause 3(p, TC, instctxt, typeIR) = $instantiable_package(p, TC, instctxt)
      -- if typeIR <: packageObjectTypeIR
      -- let `PackageT%%`_packageObjectTypeIR(_tid, _typeIR*{_typeIR <- _typeIR*}) = typeIR as packageObjectTypeIR

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:73.1-74.41
   clause 4(p, TC, instctxt, typeIR) = $instantiable_table(p, TC, instctxt)
      -- if typeIR <: tableObjectTypeIR
      -- let `TableT%%`_tableObjectTypeIR(_tid, _typeIR) = typeIR as tableObjectTypeIR

   ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:75.1-76.15
   clause 5(p, TC, instctxt, typeIR) = false
      -- otherwise

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:37.1-37.47
def $lvalue_as_expression(lvalue) : expression =

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:38.1-38.67
   clause 0(lvalue) = `NameE%`_referenceExpression(prefixedName) as expression
      -- if lvalue matches `NameL%`
      -- let `NameL%`_lvalue(prefixedName) = lvalue

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:39.1-41.61
   clause 1(lvalue) = `ExprAccE%%`_memberAccessExpression(expression_base, name) as expression
      -- if lvalue matches `LvalueAccL%%`
      -- let `LvalueAccL%%`_lvalue(lvalue_base, name) = lvalue
      -- let expression_base = $lvalue_as_expression(lvalue_base)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:42.1-44.61
   clause 2(lvalue) = `ArrAccE%%`_indexAccessExpression(expression_base, expression_index) as expression
      -- if lvalue matches `ArrAccL%%`
      -- let `ArrAccL%%`_lvalue(lvalue_base, expression_index) = lvalue
      -- let expression_base = $lvalue_as_expression(lvalue_base)

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:45.1-47.61
   clause 3(lvalue) = `BitAccE%%%`_indexAccessExpression(expression_base, expression_hi, expression_lo) as expression
      -- if lvalue matches `BitAccL%%%`
      -- let `BitAccL%%%`_lvalue(lvalue_base, expression_hi, expression_lo) = lvalue
      -- let expression_base = $lvalue_as_expression(lvalue_base)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:220.1-220.61
def $callable_builtin_function(cursor, typingContext) : bool =

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:222.1-222.50
   clause 0(cursor, TC) = true
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:223.1-223.49
   clause 1(cursor, TC) = true
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:224.1-224.49
   clause 2(cursor, TC) = true
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:247.1-247.53
def $callable_function(cursor, typingContext) : bool =

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:249.1-249.43
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:250.1-252.44
   clause 1(cursor, TC) = ($is_parser_blockKind(TC.BLOCK.KIND) \/ $is_control_blockKind(TC.BLOCK.KIND))
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:253.1-255.60
   clause 2(cursor, TC) = (~$is_extern_method_localKind(TC.LOCAL.KIND) /\ ~$is_extern_abstract_method_localKind(TC.LOCAL.KIND))
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:291.1-291.60
def $callable_extern_function(cursor, typingContext) : bool =

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:293.1-293.50
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:294.1-296.44
   clause 1(cursor, TC) = ($is_parser_blockKind(TC.BLOCK.KIND) \/ $is_control_blockKind(TC.BLOCK.KIND))
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:297.1-297.48
   clause 2(cursor, TC) = true
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:333.1-333.51
def $callable_action(cursor, typingContext) : bool =

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:335.1-335.41
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:336.1-336.40
   clause 1(cursor, TC) = false
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:337.1-339.57
   clause 2(cursor, TC) = ($is_action_localKind(TC.LOCAL.KIND) \/ $is_control_apply_method_localKind(TC.LOCAL.KIND))
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:364.1-364.59
def $callable_builtin_method(cursor, typingContext) : bool =

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:366.1-366.48
   clause 0(cursor, TC) = true
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:367.1-367.47
   clause 1(cursor, TC) = true
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:368.1-368.47
   clause 2(cursor, TC) = true
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:391.1-391.58
def $callable_extern_method(cursor, typingContext) : bool =

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:393.1-393.48
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:394.1-396.44
   clause 1(cursor, TC) = ($is_parser_blockKind(TC.BLOCK.KIND) \/ $is_control_blockKind(TC.BLOCK.KIND))
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:397.1-397.46
   clause 2(cursor, TC) = true
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:433.1-433.67
def $callable_extern_abstract_method(cursor, typingContext) : bool =

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:435.1-435.57
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:436.1-438.44
   clause 1(cursor, TC) = ($is_parser_blockKind(TC.BLOCK.KIND) \/ $is_control_blockKind(TC.BLOCK.KIND))
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:439.1-439.55
   clause 2(cursor, TC) = true
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:475.1-475.64
def $callable_parser_apply_method(cursor, typingContext) : bool =

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:477.1-477.54
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:478.1-478.53
   clause 1(cursor, TC) = false
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:479.1-480.46
   clause 2(cursor, TC) = $is_parser_state_localKind(TC.LOCAL.KIND)
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:502.1-502.65
def $callable_control_apply_method(cursor, typingContext) : bool =

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:504.1-504.55
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:505.1-505.54
   clause 1(cursor, TC) = false
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:506.1-507.54
   clause 2(cursor, TC) = $is_control_apply_method_localKind(TC.LOCAL.KIND)
      -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:529.1-529.63
def $callable_table_apply_method(cursor, typingContext) : bool =

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:531.1-531.53
   clause 0(cursor, TC) = false
      -- if cursor matches `GLOBAL`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:532.1-532.52
   clause 1(cursor, TC) = false
      -- if cursor matches `BLOCK`

   ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:533.1-535.55
   clause 2(cursor, TC) = ($is_control_apply_method_localKind(TC.LOCAL.KIND) \/ $is_table_apply_method_localKind(TC.LOCAL.KIND))
      -- if cursor matches `LOCAL`
