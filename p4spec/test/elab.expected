;; ../../../../spec-concrete/0-aux.watsup:18.1-18.21
def $sum(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:20.1-20.21
def $max(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:22.1-22.21
def $min(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:28.1-28.29
def $int_to_text(int) : text =

;; ../../../../spec-concrete/0-aux.watsup:30.1-30.31
def $concat_text(text*) : text =

  ;; ../../../../spec-concrete/0-aux.watsup:31.1-31.27
  clause 0(text*{text <- text*}) = ""
  -- if text*{text <- text*} matches []

  ;; ../../../../spec-concrete/0-aux.watsup:32.1-32.58
  clause 1(text*{text <- text*}) = t_h ++ $concat_text(t_t*{t_t <- t_t*})
  -- if text*{text <- text*} matches _ :: _
  -- let t_h :: t_t*{t_t <- t_t*} = text*{text <- text*}

;; ../../../../spec-concrete/0-aux.watsup:34.1-34.37
def $strip_prefix(text, text) : text =

;; ../../../../spec-concrete/0-aux.watsup:35.1-35.37
def $strip_suffix(text, text) : text =

;; ../../../../spec-concrete/0-aux.watsup:41.1-41.23
def $init_(nat) : nat* =

  ;; ../../../../spec-concrete/0-aux.watsup:42.1-42.20
  clause 0(nat) = []
  -- if (nat = 0)

  ;; ../../../../spec-concrete/0-aux.watsup:43.1-44.15
  clause 1(n) = (n - 1) :: $init_((n - 1))
  -- otherwise

;; ../../../../spec-concrete/0-aux.watsup:46.1-46.29
def $repeat_<X>(X, nat) : X* =

  ;; ../../../../spec-concrete/0-aux.watsup:47.1-47.28
  clause 0(X, nat) = []
  -- if (nat = 0)

  ;; ../../../../spec-concrete/0-aux.watsup:48.1-49.15
  clause 1(X, n) = [X] ++ $repeat_<X>(X, (n - 1))
  -- otherwise

;; ../../../../spec-concrete/0-aux.watsup:51.1-51.22
def $rev_<X>(X*) : X* =

;; ../../../../spec-concrete/0-aux.watsup:53.1-53.28
def $concat_<X>(X**) : X* =

;; ../../../../spec-concrete/0-aux.watsup:55.1-55.39
def $partition_<X>(X*, nat) : (X*, X*) =

;; ../../../../spec-concrete/0-aux.watsup:57.1-57.35
def $assoc_<X, Y>(X, (X, Y)*) : Y? =

;; ../../../../spec-concrete/0-aux.watsup:59.1-59.29
def $distinct_<K>(K*) : bool =

;; ../../../../spec-concrete/0-aux.watsup:65.17-65.24
syntax set<K> = 
   | { K* }

;; ../../../../spec-concrete/0-aux.watsup:67.1-67.27
def $empty_set<K> : set<K> =

  ;; ../../../../spec-concrete/0-aux.watsup:68.1-68.29
  clause 0 = { [] }

;; ../../../../spec-concrete/0-aux.watsup:70.1-70.33
def $in_set<K>(K, set<K>) : bool =

  ;; ../../../../spec-concrete/0-aux.watsup:71.1-71.41
  clause 0(K, { K_e*{K_e <- K_e*} }) = K <- K_e*{K_e <- K_e*}

;; ../../../../spec-concrete/0-aux.watsup:73.1-73.47
def $intersect_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:75.1-75.43
def $union_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:77.1-77.37
def $unions_set<K>(set<K>*) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:79.1-79.42
def $diff_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:81.1-81.39
def $sub_set<K>(set<K>, set<K>) : bool =

;; ../../../../spec-concrete/0-aux.watsup:83.1-83.38
def $eq_set<K>(set<K>, set<K>) : bool =

;; ../../../../spec-concrete/0-aux.watsup:89.21-89.27
syntax pair<K, V> = 
   | K : V

;; ../../../../spec-concrete/0-aux.watsup:91.20-91.35
syntax map<K, V> = set<pair<K, V>>

;; ../../../../spec-concrete/0-aux.watsup:93.1-93.33
def $empty_map<K, V> : map<K, V> =

  ;; ../../../../spec-concrete/0-aux.watsup:94.1-94.32
  clause 0 = { [] }

;; ../../../../spec-concrete/0-aux.watsup:96.1-96.39
def $dom_map<K, V>(map<K, V>) : set<K> =

  ;; ../../../../spec-concrete/0-aux.watsup:97.1-97.45
  clause 0({ K : V*{K <- K*, V <- V*} }) = { K*{K <- K*} }

;; ../../../../spec-concrete/0-aux.watsup:99.1-99.39
def $find_map<K, V>(map<K, V>, K) : V? =

;; ../../../../spec-concrete/0-aux.watsup:101.1-101.41
def $find_maps<K, V>(map<K, V>*, K) : V? =

;; ../../../../spec-concrete/0-aux.watsup:103.1-103.48
def $add_map<K, V>(map<K, V>, K, V) : map<K, V> =

;; ../../../../spec-concrete/0-aux.watsup:105.1-105.51
def $adds_map<K, V>(map<K, V>, K*, V*) : map<K, V> =

;; ../../../../spec-concrete/0-aux.watsup:107.1-107.51
def $update_map<K, V>(map<K, V>, K, V) : map<K, V> =

;; ../../../../spec-concrete/1-syntax.watsup:6.1-7.7
syntax trailingCommaOpt = 
   | 
   | ,

;; ../../../../spec-concrete/1-syntax.watsup:14.1-15.10
syntax booleanLiteral = 
   | true
   | false

;; ../../../../spec-concrete/1-syntax.watsup:22.1-24.35
syntax numberLiteral = 
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)

;; ../../../../spec-concrete/1-syntax.watsup:30.24-30.57
syntax stringLiteral = 
   | " text " hint(print "#%#")

;; ../../../../spec-concrete/1-syntax.watsup:43.21-43.29
syntax identifier = 
   | text

;; ../../../../spec-concrete/1-syntax.watsup:44.25-44.34
syntax typeIdentifier = 
   | text

;; ../../../../spec-concrete/1-syntax.watsup:51.1-53.30
syntax nonTypeName = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority

;; ../../../../spec-concrete/1-syntax.watsup:56.1-57.23
syntax prefixedNonTypeName = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName

;; ../../../../spec-concrete/1-syntax.watsup:63.19-63.33
syntax typeName = typeIdentifier

;; ../../../../spec-concrete/1-syntax.watsup:66.1-67.21
syntax prefixedTypeName = 
   | text
   | . typeName

;; ../../../../spec-concrete/1-syntax.watsup:74.1-76.36
syntax tableCustomName = 
   | text
   | text
   | apply
   | state
   | type
   | priority

;; ../../../../spec-concrete/1-syntax.watsup:83.1-85.9
syntax name = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list

;; ../../../../spec-concrete/1-syntax.watsup:88.1-89.21
syntax nameList = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list
   | nameList , name

;; ../../../../spec-concrete/1-syntax.watsup:91.1-91.40
def $flatten_nameList(nameList) : name* =

  ;; ../../../../spec-concrete/1-syntax.watsup:92.1-92.35
  clause 0(nameList) = [name]
  -- if nameList <: name
  -- let name = nameList as name

  ;; ../../../../spec-concrete/1-syntax.watsup:93.1-94.42
  clause 1(nameList') = $flatten_nameList(nameList) ++ [name]
  -- if nameList' matches `%,%`
  -- let nameList , name = nameList'

;; ../../../../spec-concrete/1-syntax.watsup:96.17-96.21
syntax member = name

;; ../../../../spec-concrete/1-syntax.watsup:102.20-102.45
syntax direction = 
   | 
   | in
   | out
   | inout

;; ../../../../spec-concrete/1-syntax.watsup:115.1-126.32
syntax baseType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>

;; ../../../../spec-concrete/1-syntax.watsup:134.26-134.64
syntax specializedType = 
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:137.1-138.20
syntax namedType = 
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:144.26-144.51
syntax headerStackType = 
   | namedType [ expression ]

;; ../../../../spec-concrete/1-syntax.watsup:152.19-152.41
syntax listType = 
   | list< typeArgument >

;; ../../../../spec-concrete/1-syntax.watsup:158.20-158.47
syntax tupleType = 
   | tuple< typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:165.1-169.14
syntax type = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:172.1-174.15
syntax typeOrVoid = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | text

;; ../../../../spec-concrete/1-syntax.watsup:180.24-180.28
syntax typeParameter = name

;; ../../../../spec-concrete/1-syntax.watsup:183.1-184.39
syntax typeParameterList = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list
   | typeParameterList , typeParameter

;; ../../../../spec-concrete/1-syntax.watsup:186.1-186.67
def $flatten_typeParameterList(typeParameterList) : typeParameter* =

  ;; ../../../../spec-concrete/1-syntax.watsup:187.1-187.62
  clause 0(typeParameterList) = [typeParameter]
  -- if typeParameterList <: typeParameter
  -- let typeParameter = typeParameterList as typeParameter

  ;; ../../../../spec-concrete/1-syntax.watsup:188.1-189.69
  clause 1(typeParameterList') = $flatten_typeParameterList(typeParameterList) ++ [typeParameter]
  -- if typeParameterList' matches `%,%`
  -- let typeParameterList , typeParameter = typeParameterList'

;; ../../../../spec-concrete/1-syntax.watsup:192.1-193.27
syntax typeParameterListOpt = 
   | 
   | < typeParameterList >

;; ../../../../spec-concrete/1-syntax.watsup:195.1-195.73
def $flatten_typeParameterListOpt(typeParameterListOpt) : typeParameter* =

  ;; ../../../../spec-concrete/1-syntax.watsup:196.1-196.48
  clause 0(typeParameterListOpt) = []
  -- if typeParameterListOpt matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:197.1-198.50
  clause 1(typeParameterListOpt) = $flatten_typeParameterList(typeParameterList)
  -- if typeParameterListOpt matches `<%>`
  -- let < typeParameterList > = typeParameterListOpt

;; ../../../../spec-concrete/1-syntax.watsup:207.3-207.52
syntax parameter = 
   | annotationList direction type name initializerOpt

;; ../../../../spec-concrete/1-syntax.watsup:210.1-211.39
syntax nonEmptyParameterList = 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList , parameter

;; ../../../../spec-concrete/1-syntax.watsup:214.1-215.26
syntax parameterList = 
   | 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList , parameter

;; ../../../../spec-concrete/1-syntax.watsup:217.1-217.55
def $flatten_parameterList(parameterList) : parameter* =

  ;; ../../../../spec-concrete/1-syntax.watsup:218.1-218.41
  clause 0(parameterList) = []
  -- if parameterList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:219.1-219.50
  clause 1(parameterList) = [parameter]
  -- if parameterList <: parameter
  -- let parameter = parameterList as parameter

  ;; ../../../../spec-concrete/1-syntax.watsup:220.1-221.67
  clause 2(parameterList) = $flatten_parameterList(nonEmptyParameterList as parameterList) ++ [parameter]
  -- if parameterList <: nonEmptyParameterList
  -- let nonEmptyParameterList' = parameterList as nonEmptyParameterList
  -- if nonEmptyParameterList' matches `%,%`
  -- let nonEmptyParameterList , parameter = nonEmptyParameterList'

;; ../../../../spec-concrete/1-syntax.watsup:227.31-227.40
syntax constructorParameter = parameter

;; ../../../../spec-concrete/1-syntax.watsup:229.35-229.48
syntax constructorParameterList = parameterList

;; ../../../../spec-concrete/1-syntax.watsup:232.1-233.23
syntax constructorParameterListOpt = 
   | 
   | ( parameterList )

;; ../../../../spec-concrete/1-syntax.watsup:235.1-236.26
def $flatten_constructorParameterListOpt(constructorParameterListOpt) : constructorParameter* =

  ;; ../../../../spec-concrete/1-syntax.watsup:238.1-238.55
  clause 0(constructorParameterListOpt) = []
  -- if constructorParameterListOpt matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:239.1-240.42
  clause 1(constructorParameterListOpt) = $flatten_parameterList(parameterList)
  -- if constructorParameterListOpt matches `(%)`
  -- let ( parameterList ) = constructorParameterListOpt

;; ../../../../spec-concrete/1-syntax.watsup:246.26-246.44
syntax namedExpression = 
   | name = expression

;; ../../../../spec-concrete/1-syntax.watsup:249.1-250.43
syntax namedExpressionList = 
   | name = expression
   | namedExpressionList , namedExpression

;; ../../../../spec-concrete/1-syntax.watsup:252.1-252.73
def $flatten_namedExpressionList(namedExpressionList) : namedExpression* =

  ;; ../../../../spec-concrete/1-syntax.watsup:253.1-253.68
  clause 0(namedExpressionList) = [namedExpression]
  -- if namedExpressionList <: namedExpression
  -- let namedExpression = namedExpressionList as namedExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:254.1-255.75
  clause 1(namedExpressionList') = $flatten_namedExpressionList(namedExpressionList) ++ [namedExpression]
  -- if namedExpressionList' matches `%,%`
  -- let namedExpressionList , namedExpression = namedExpressionList'

;; ../../../../spec-concrete/1-syntax.watsup:266.1-268.18
syntax literalExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")

;; ../../../../spec-concrete/1-syntax.watsup:275.1-276.9
syntax referenceExpression = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this

;; ../../../../spec-concrete/1-syntax.watsup:282.28-282.32
syntax defaultExpression = 
   | ...

;; ../../../../spec-concrete/1-syntax.watsup:290.15-290.32
syntax unop = 
   | !
   | ~
   | -
   | +

;; ../../../../spec-concrete/1-syntax.watsup:292.26-292.41
syntax unaryExpression = 
   | unop expression

;; ../../../../spec-concrete/1-syntax.watsup:295.1-297.35
syntax binop = 
   | *
   | /
   | %
   | +
   | -
   | |+|
   | |-|
   | <<
   | >>
   | <=
   | >=
   | <
   | >
   | !=
   | ==
   | &
   | ^
   | |
   | ++
   | &&
   | ||

;; ../../../../spec-concrete/1-syntax.watsup:299.27-299.54
syntax binaryExpression = 
   | expression binop expression

;; ../../../../spec-concrete/1-syntax.watsup:302.3-302.38
syntax binaryExpressionNonBrace = 
   | expressionNonBrace binop expression

;; ../../../../spec-concrete/1-syntax.watsup:305.3-305.41
syntax ternaryExpression = 
   | expression ? expression : expression

;; ../../../../spec-concrete/1-syntax.watsup:308.3-308.49
syntax ternaryExpressionNonBrace = 
   | expressionNonBrace ? expression : expression

;; ../../../../spec-concrete/1-syntax.watsup:314.25-314.45
syntax castExpression = 
   | ( type ) expression

;; ../../../../spec-concrete/1-syntax.watsup:323.1-324.48
syntax dataExpression = 
   | {#}
   | { dataElementExpression trailingCommaOpt }

;; ../../../../spec-concrete/1-syntax.watsup:333.3-333.18
syntax errorAccessExpression = 
   | error. member

;; ../../../../spec-concrete/1-syntax.watsup:336.3-336.29
syntax memberAccessExpression = 
   | memberAccessBase . member

;; ../../../../spec-concrete/1-syntax.watsup:339.1-340.45
syntax indexAccessExpression = 
   | expression [ expression ]
   | expression [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:343.1-345.26
syntax accessExpression = 
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:348.3-348.37
syntax memberAccessExpressionNonBrace = 
   | memberAccessBaseNonBrace . member

;; ../../../../spec-concrete/1-syntax.watsup:351.1-352.53
syntax indexAccessExpressionNonBrace = 
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:355.1-357.34
syntax accessExpressionNonBrace = 
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:371.1-372.62
syntax callExpression = 
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )

;; ../../../../spec-concrete/1-syntax.watsup:375.1-376.70
syntax callExpressionNonBrace = 
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )

;; ../../../../spec-concrete/1-syntax.watsup:382.34-382.49
syntax parenthesizedExpression = 
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:389.1-399.28
syntax expression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:403.1-405.33
syntax expressionList = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expressionList , expression

;; ../../../../spec-concrete/1-syntax.watsup:407.1-407.58
def $flatten_expressionList(expressionList) : expression* =

  ;; ../../../../spec-concrete/1-syntax.watsup:408.1-408.42
  clause 0(expressionList) = []
  -- if expressionList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:409.1-409.53
  clause 1(expressionList) = [expression]
  -- if expressionList <: expression
  -- let expression = expressionList as expression

  ;; ../../../../spec-concrete/1-syntax.watsup:410.1-411.60
  clause 2(expressionList') = $flatten_expressionList(expressionList) ++ [expression]
  -- if expressionList' matches `%,%`
  -- let expressionList , expression = expressionList'

;; ../../../../spec-concrete/1-syntax.watsup:414.1-415.15
syntax memberAccessBase = 
   | text
   | . typeName
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:417.36-417.50
syntax sequenceElementExpression = expressionList

;; ../../../../spec-concrete/1-syntax.watsup:420.1-423.54
syntax recordElementExpression = 
   | name = expression
   | name = expression ,...
   | name = expression , namedExpressionList
   | name = expression , namedExpressionList ,...

;; ../../../../spec-concrete/1-syntax.watsup:426.1-427.28
syntax dataElementExpression = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expressionList , expression
   | name = expression
   | name = expression ,...
   | name = expression , namedExpressionList
   | name = expression , namedExpressionList ,...

;; ../../../../spec-concrete/1-syntax.watsup:429.24-429.34
syntax routineTarget = expression

;; ../../../../spec-concrete/1-syntax.watsup:430.28-430.37
syntax constructorTarget = namedType

;; ../../../../spec-concrete/1-syntax.watsup:433.1-434.22
syntax callTarget = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:441.1-449.28
syntax expressionNonBrace = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:452.1-453.23
syntax memberAccessBaseNonBrace = 
   | text
   | . typeName
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:455.32-455.50
syntax routineTargetNonBrace = expressionNonBrace

;; ../../../../spec-concrete/1-syntax.watsup:458.1-459.22
syntax callTargetNonBrace = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:461.1-461.57
def $expressionNonBrace(expressionNonBrace) : expression =

  ;; ../../../../spec-concrete/1-syntax.watsup:462.1-462.63
  clause 0(expressionNonBrace) = literalExpression as expression
  -- if expressionNonBrace <: literalExpression
  -- let literalExpression = expressionNonBrace as literalExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:463.1-463.67
  clause 1(expressionNonBrace) = referenceExpression as expression
  -- if expressionNonBrace <: referenceExpression
  -- let referenceExpression = expressionNonBrace as referenceExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:464.1-464.59
  clause 2(expressionNonBrace) = unaryExpression as expression
  -- if expressionNonBrace <: unaryExpression
  -- let unaryExpression = expressionNonBrace as unaryExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:465.1-469.65
  clause 3(expressionNonBrace) = expression_l binop expression_r as expression
  -- if expressionNonBrace <: binaryExpressionNonBrace
  -- let expressionNonBrace_l binop expression_r = expressionNonBrace as binaryExpressionNonBrace
  -- let expression_l = $expressionNonBrace(expressionNonBrace_l)

  ;; ../../../../spec-concrete/1-syntax.watsup:470.1-474.71
  clause 4(expressionNonBrace) = expression_cond ? expression_true : expression_false as expression
  -- if expressionNonBrace <: ternaryExpressionNonBrace
  -- let expressionNonBrace_cond ? expression_true : expression_false = expressionNonBrace as ternaryExpressionNonBrace
  -- let expression_cond = $expressionNonBrace(expressionNonBrace_cond)

  ;; ../../../../spec-concrete/1-syntax.watsup:475.1-475.57
  clause 5(expressionNonBrace) = castExpression as expression
  -- if expressionNonBrace <: castExpression
  -- let castExpression = expressionNonBrace as castExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:476.1-476.71
  clause 6(expressionNonBrace) = errorAccessExpression as expression
  -- if expressionNonBrace <: errorAccessExpression
  -- let errorAccessExpression = expressionNonBrace as errorAccessExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:477.1-478.31
  clause 7(expressionNonBrace) = prefixedTypeName as memberAccessBase . member as expression
  -- if expressionNonBrace <: memberAccessExpressionNonBrace
  -- let memberAccessBaseNonBrace . member = expressionNonBrace as memberAccessExpressionNonBrace
  -- if memberAccessBaseNonBrace <: prefixedTypeName
  -- let prefixedTypeName = memberAccessBaseNonBrace as prefixedTypeName

  ;; ../../../../spec-concrete/1-syntax.watsup:479.1-481.71
  clause 8(expressionNonBrace) = expression_base as memberAccessBase . member as expression
  -- if expressionNonBrace <: memberAccessExpressionNonBrace
  -- let memberAccessBaseNonBrace . member = expressionNonBrace as memberAccessExpressionNonBrace
  -- if memberAccessBaseNonBrace <: expressionNonBrace
  -- let expressionNonBrace_base = memberAccessBaseNonBrace as expressionNonBrace
  -- let expression_base = $expressionNonBrace(expressionNonBrace_base)

  ;; ../../../../spec-concrete/1-syntax.watsup:482.1-486.71
  clause 9(expressionNonBrace) = expression_base [ expression_index ] as expression
  -- if expressionNonBrace <: indexAccessExpressionNonBrace
  -- let indexAccessExpressionNonBrace = expressionNonBrace as indexAccessExpressionNonBrace
  -- if indexAccessExpressionNonBrace matches `%[%]`
  -- let expressionNonBrace_base [ expression_index ] = indexAccessExpressionNonBrace
  -- let expression_base = $expressionNonBrace(expressionNonBrace_base)

  ;; ../../../../spec-concrete/1-syntax.watsup:487.1-491.71
  clause 10(expressionNonBrace) = expression_base [ expression_hi : expression_lo ] as expression
  -- if expressionNonBrace <: indexAccessExpressionNonBrace
  -- let indexAccessExpressionNonBrace = expressionNonBrace as indexAccessExpressionNonBrace
  -- if indexAccessExpressionNonBrace matches `%[%:%]`
  -- let expressionNonBrace_base [ expression_hi : expression_lo ] = indexAccessExpressionNonBrace
  -- let expression_base = $expressionNonBrace(expressionNonBrace_base)

  ;; ../../../../spec-concrete/1-syntax.watsup:492.1-496.61
  clause 11(expressionNonBrace') = expression as callTarget ( argumentList ) as expression
  -- if expressionNonBrace' <: callExpressionNonBrace
  -- let callExpressionNonBrace = expressionNonBrace' as callExpressionNonBrace
  -- if callExpressionNonBrace matches `%(%)`
  -- let callTargetNonBrace ( argumentList ) = callExpressionNonBrace
  -- if callTargetNonBrace <: expressionNonBrace
  -- let expressionNonBrace = callTargetNonBrace as expressionNonBrace
  -- let expression = $expressionNonBrace(expressionNonBrace)

  ;; ../../../../spec-concrete/1-syntax.watsup:497.1-500.40
  clause 12(expressionNonBrace) = constructorTarget as callTarget ( argumentList ) as expression
  -- if expressionNonBrace <: callExpressionNonBrace
  -- let callExpressionNonBrace = expressionNonBrace as callExpressionNonBrace
  -- if callExpressionNonBrace matches `%(%)`
  -- let callTargetNonBrace ( argumentList ) = callExpressionNonBrace
  -- if callTargetNonBrace <: constructorTarget
  -- let constructorTarget = callTargetNonBrace as constructorTarget

  ;; ../../../../spec-concrete/1-syntax.watsup:501.1-505.61
  clause 13(expressionNonBrace') = expression < realTypeArgumentList >( argumentList ) as expression
  -- if expressionNonBrace' <: callExpressionNonBrace
  -- let callExpressionNonBrace = expressionNonBrace' as callExpressionNonBrace
  -- if callExpressionNonBrace matches `%<%>(%)`
  -- let expressionNonBrace < realTypeArgumentList >( argumentList ) = callExpressionNonBrace
  -- let expression = $expressionNonBrace(expressionNonBrace)

  ;; ../../../../spec-concrete/1-syntax.watsup:506.1-506.75
  clause 14(expressionNonBrace) = parenthesizedExpression as expression
  -- if expressionNonBrace <: parenthesizedExpression
  -- let parenthesizedExpression = expressionNonBrace as parenthesizedExpression

;; ../../../../spec-concrete/1-syntax.watsup:513.1-517.7
syntax simpleKeysetExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _

;; ../../../../spec-concrete/1-syntax.watsup:520.1-521.57
syntax simpleKeysetExpressionList = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _
   | simpleKeysetExpressionList , simpleKeysetExpression

;; ../../../../spec-concrete/1-syntax.watsup:523.1-524.28
def $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList) : simpleKeysetExpression* =

  ;; ../../../../spec-concrete/1-syntax.watsup:525.1-526.27
  clause 0(simpleKeysetExpressionList) = [simpleKeysetExpression]
  -- if simpleKeysetExpressionList <: simpleKeysetExpression
  -- let simpleKeysetExpression = simpleKeysetExpressionList as simpleKeysetExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:527.1-531.34
  clause 1(simpleKeysetExpressionList') = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList) ++ [simpleKeysetExpression]
  -- if simpleKeysetExpressionList' matches `%,%`
  -- let simpleKeysetExpressionList , simpleKeysetExpression = simpleKeysetExpressionList'

;; ../../../../spec-concrete/1-syntax.watsup:534.1-538.62
syntax tupleKeysetExpression = 
   | ( expression &&& expression )
   | ( expression .. expression )
   | (default)
   | (_)
   | ( simpleKeysetExpression , simpleKeysetExpressionList )

;; ../../../../spec-concrete/1-syntax.watsup:541.1-542.26
syntax keysetExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _
   | ( expression &&& expression )
   | ( expression .. expression )
   | (default)
   | (_)
   | ( simpleKeysetExpression , simpleKeysetExpressionList )

;; ../../../../spec-concrete/1-syntax.watsup:549.1-551.7
syntax realTypeArgument = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _

;; ../../../../spec-concrete/1-syntax.watsup:554.1-555.45
syntax realTypeArgumentList = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | realTypeArgumentList , realTypeArgument

;; ../../../../spec-concrete/1-syntax.watsup:557.1-557.76
def $flatten_realTypeArgumentList(realTypeArgumentList) : realTypeArgument* =

  ;; ../../../../spec-concrete/1-syntax.watsup:558.1-558.71
  clause 0(realTypeArgumentList) = [realTypeArgument]
  -- if realTypeArgumentList <: realTypeArgument
  -- let realTypeArgument = realTypeArgumentList as realTypeArgument

  ;; ../../../../spec-concrete/1-syntax.watsup:559.1-560.78
  clause 1(realTypeArgumentList') = $flatten_realTypeArgumentList(realTypeArgumentList) ++ [realTypeArgument]
  -- if realTypeArgumentList' matches `%,%`
  -- let realTypeArgumentList , realTypeArgument = realTypeArgumentList'

;; ../../../../spec-concrete/1-syntax.watsup:563.1-564.16
syntax typeArgument = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority

;; ../../../../spec-concrete/1-syntax.watsup:568.1-570.37
syntax typeArgumentList = 
   | 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | typeArgumentList , typeArgument

;; ../../../../spec-concrete/1-syntax.watsup:572.1-572.64
def $flatten_typeArgumentList(typeArgumentList) : typeArgument* =

  ;; ../../../../spec-concrete/1-syntax.watsup:573.1-573.44
  clause 0(typeArgumentList) = []
  -- if typeArgumentList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:574.1-574.59
  clause 1(typeArgumentList) = [typeArgument]
  -- if typeArgumentList <: typeArgument
  -- let typeArgument = typeArgumentList as typeArgument

  ;; ../../../../spec-concrete/1-syntax.watsup:575.1-576.66
  clause 2(typeArgumentList') = $flatten_typeArgumentList(typeArgumentList) ++ [typeArgument]
  -- if typeArgumentList' matches `%,%`
  -- let typeArgumentList , typeArgument = typeArgumentList'

;; ../../../../spec-concrete/1-syntax.watsup:583.1-586.7
syntax argument = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _

;; ../../../../spec-concrete/1-syntax.watsup:589.1-590.37
syntax argumentListNonEmpty = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _
   | argumentListNonEmpty , argument

;; ../../../../spec-concrete/1-syntax.watsup:593.1-594.25
syntax argumentList = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _
   | argumentListNonEmpty , argument

;; ../../../../spec-concrete/1-syntax.watsup:596.1-596.52
def $flatten_argumentList(argumentList) : argument* =

  ;; ../../../../spec-concrete/1-syntax.watsup:597.1-597.40
  clause 0(argumentList) = []
  -- if argumentList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:598.1-598.47
  clause 1(argumentList) = [argument]
  -- if argumentList <: argument
  -- let argument = argumentList as argument

  ;; ../../../../spec-concrete/1-syntax.watsup:599.1-600.62
  clause 2(argumentList) = $flatten_argumentList(argumentListNonEmpty as argumentList) ++ [argument]
  -- if argumentList <: argumentListNonEmpty
  -- let argumentListNonEmpty' = argumentList as argumentListNonEmpty
  -- if argumentListNonEmpty' matches `%,%`
  -- let argumentListNonEmpty , argument = argumentListNonEmpty'

;; ../../../../spec-concrete/1-syntax.watsup:607.1-611.16
syntax lvalue = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | lvalue . member
   | lvalue [ expression ]
   | lvalue [ expression : expression ]
   | ( lvalue )

;; ../../../../spec-concrete/1-syntax.watsup:621.25-621.27
syntax emptyStatement = 
   | ;

;; ../../../../spec-concrete/1-syntax.watsup:628.1-630.34
syntax assignop = 
   | =
   | +=
   | -=
   | |+|=
   | |-|=
   | *=
   | /=
   | %=
   | <<=
   | >>=
   | &=
   | ^=
   | |=

;; ../../../../spec-concrete/1-syntax.watsup:632.30-632.59
syntax assignmentStatement = 
   | lvalue assignop expression ;

;; ../../../../spec-concrete/1-syntax.watsup:639.1-640.54
syntax callStatement = 
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );

;; ../../../../spec-concrete/1-syntax.watsup:646.37-646.76
syntax directApplicationStatement = 
   | namedType .apply( argumentList );

;; ../../../../spec-concrete/1-syntax.watsup:653.1-654.25
syntax returnStatement = 
   | return;
   | return expression ;

;; ../../../../spec-concrete/1-syntax.watsup:660.24-660.31
syntax exitStatement = 
   | exit;

;; ../../../../spec-concrete/1-syntax.watsup:668.25-668.70
syntax blockStatement = 
   | annotationList { blockElementStatementList }

;; ../../../../spec-concrete/1-syntax.watsup:677.1-678.48
syntax conditionalStatement = 
   | if( expression ) statement
   | if( expression ) statement else statement

;; ../../../../spec-concrete/1-syntax.watsup:687.1-690.31
syntax forInitStatement = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression

;; ../../../../spec-concrete/1-syntax.watsup:693.1-694.53
syntax forInitStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forInitStatementListNonEmpty , forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:697.1-698.33
syntax forInitStatementList = 
   | 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forInitStatementListNonEmpty , forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:700.29-700.45
syntax forUpdateStatement = forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:703.1-704.57
syntax forUpdateStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty , forUpdateStatement

;; ../../../../spec-concrete/1-syntax.watsup:707.1-708.35
syntax forUpdateStatementList = 
   | 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty , forUpdateStatement

;; ../../../../spec-concrete/1-syntax.watsup:711.1-712.30
syntax forCollectionExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression .. expression

;; ../../../../spec-concrete/1-syntax.watsup:715.1-720.81
syntax forStatement = 
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement

;; ../../../../spec-concrete/1-syntax.watsup:727.1-728.23
syntax switchLabel = 
   | default
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:731.1-732.19
syntax switchCase = 
   | switchLabel : blockStatement
   | switchLabel :

;; ../../../../spec-concrete/1-syntax.watsup:735.1-736.30
syntax switchCaseList = 
   | 
   | switchCaseList switchCase

;; ../../../../spec-concrete/1-syntax.watsup:738.1-738.58
def $flatten_switchCaseList(switchCaseList) : switchCase* =

  ;; ../../../../spec-concrete/1-syntax.watsup:739.1-739.42
  clause 0(switchCaseList) = []
  -- if switchCaseList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:740.1-741.62
  clause 1(switchCaseList') = $flatten_switchCaseList(switchCaseList) ++ [switchCase]
  -- if switchCaseList' matches `%%`
  -- let switchCaseList switchCase = switchCaseList'

;; ../../../../spec-concrete/1-syntax.watsup:743.26-743.68
syntax switchStatement = 
   | switch( expression ){ switchCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:749.25-749.33
syntax breakStatement = 
   | break;

;; ../../../../spec-concrete/1-syntax.watsup:751.28-751.39
syntax continueStatement = 
   | continue;

;; ../../../../spec-concrete/1-syntax.watsup:758.1-769.20
syntax statement = 
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | return;
   | return expression ;
   | exit;
   | annotationList { blockElementStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement
   | break;
   | continue;
   | switch( expression ){ switchCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:779.22-779.35
syntax initializer = 
   | = expression

;; ../../../../spec-concrete/1-syntax.watsup:782.3-782.48
syntax constantDeclaration = 
   | annotationList const type name initializer ;

;; ../../../../spec-concrete/1-syntax.watsup:785.1-786.16
syntax initializerOpt = 
   | 
   | = expression

;; ../../../../spec-concrete/1-syntax.watsup:789.3-789.45
syntax variableDeclaration = 
   | annotationList type name initializerOpt ;

;; ../../../../spec-concrete/1-syntax.watsup:792.1-794.14
syntax blockElementStatement = 
   | annotationList const type name initializer ;
   | annotationList type name initializerOpt ;
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | return;
   | return expression ;
   | exit;
   | annotationList { blockElementStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement
   | break;
   | continue;
   | switch( expression ){ switchCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:797.1-798.52
syntax blockElementStatementList = 
   | 
   | blockElementStatementList blockElementStatement

;; ../../../../spec-concrete/1-syntax.watsup:800.1-801.27
def $flatten_blockElementStatementList(blockElementStatementList) : blockElementStatement* =

  ;; ../../../../spec-concrete/1-syntax.watsup:802.1-802.53
  clause 0(blockElementStatementList) = []
  -- if blockElementStatementList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:803.1-807.30
  clause 1(blockElementStatementList') = $flatten_blockElementStatementList(blockElementStatementList) ++ [blockElementStatement]
  -- if blockElementStatementList' matches `%%`
  -- let blockElementStatementList blockElementStatement = blockElementStatementList'

;; ../../../../spec-concrete/1-syntax.watsup:814.3-814.58
syntax functionPrototype = 
   | typeOrVoid name typeParameterListOpt ( parameterList )

;; ../../../../spec-concrete/1-syntax.watsup:817.3-817.50
syntax functionDeclaration = 
   | annotationList functionPrototype blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:824.3-824.63
syntax actionDeclaration = 
   | annotationList action name ( parameterList ) blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:832.28-832.57
syntax objectInitializer = 
   | ={ objectDeclarationList }

;; ../../../../spec-concrete/1-syntax.watsup:836.1-837.68
syntax instantiation = 
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;

;; ../../../../spec-concrete/1-syntax.watsup:840.1-841.18
syntax objectDeclaration = 
   | annotationList functionPrototype blockStatement
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;

;; ../../../../spec-concrete/1-syntax.watsup:844.1-845.44
syntax objectDeclarationList = 
   | 
   | objectDeclarationList objectDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:847.1-847.79
def $flatten_objectDeclarationList(objectDeclarationList) : objectDeclaration* =

  ;; ../../../../spec-concrete/1-syntax.watsup:848.1-848.49
  clause 0(objectDeclarationList) = []
  -- if objectDeclarationList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:849.1-853.29
  clause 1(objectDeclarationList') = $flatten_objectDeclarationList(objectDeclarationList) ++ [objectDeclaration]
  -- if objectDeclarationList' matches `%%`
  -- let objectDeclarationList objectDeclaration = objectDeclarationList'

;; ../../../../spec-concrete/1-syntax.watsup:859.27-859.46
syntax errorDeclaration = 
   | error{ nameList }

;; ../../../../spec-concrete/1-syntax.watsup:865.31-865.72
syntax matchKindDeclaration = 
   | match_kind{ nameList trailingCommaOpt }

;; ../../../../spec-concrete/1-syntax.watsup:876.1-877.76
syntax enumTypeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }

;; ../../../../spec-concrete/1-syntax.watsup:883.20-883.47
syntax typeField = 
   | annotationList type name ;

;; ../../../../spec-concrete/1-syntax.watsup:886.1-887.28
syntax typeFieldList = 
   | 
   | typeFieldList typeField

;; ../../../../spec-concrete/1-syntax.watsup:889.1-889.55
def $flatten_typeFieldList(typeFieldList) : typeField* =

  ;; ../../../../spec-concrete/1-syntax.watsup:890.1-890.41
  clause 0(typeFieldList) = []
  -- if typeFieldList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:891.1-892.59
  clause 1(typeFieldList') = $flatten_typeFieldList(typeFieldList) ++ [typeField]
  -- if typeFieldList' matches `%%`
  -- let typeFieldList typeField = typeFieldList'

;; ../../../../spec-concrete/1-syntax.watsup:895.3-895.69
syntax structTypeDeclaration = 
   | annotationList struct name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:898.3-898.69
syntax headerTypeDeclaration = 
   | annotationList header name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:901.3-901.75
syntax headerUnionTypeDeclaration = 
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:904.1-907.31
syntax derivedTypeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:914.1-915.27
syntax typedefType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:918.1-919.37
syntax typedefDeclaration = 
   | annotationList typedef typedefType name ;
   | annotationList type type name ;

;; ../../../../spec-concrete/1-syntax.watsup:926.3-926.45
syntax externFunctionDeclaration = 
   | annotationList extern functionPrototype ;

;; ../../../../spec-concrete/1-syntax.watsup:929.1-931.49
syntax methodPrototype = 
   | annotationList typeIdentifier ( parameterList );
   | annotationList functionPrototype ;
   | annotationList abstract functionPrototype ;

;; ../../../../spec-concrete/1-syntax.watsup:934.1-935.40
syntax methodPrototypeList = 
   | 
   | methodPrototypeList methodPrototype

;; ../../../../spec-concrete/1-syntax.watsup:937.1-937.73
def $flatten_methodPrototypeList(methodPrototypeList) : methodPrototype* =

  ;; ../../../../spec-concrete/1-syntax.watsup:938.1-938.47
  clause 0(methodPrototypeList) = []
  -- if methodPrototypeList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:939.1-942.77
  clause 1(methodPrototypeList') = $flatten_methodPrototypeList(methodPrototypeList) ++ [methodPrototype]
  -- if methodPrototypeList' matches `%%`
  -- let methodPrototypeList methodPrototype = methodPrototypeList'

;; ../../../../spec-concrete/1-syntax.watsup:945.3-945.82
syntax externObjectDeclaration = 
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }

;; ../../../../spec-concrete/1-syntax.watsup:948.1-949.28
syntax externDeclaration = 
   | annotationList extern functionPrototype ;
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }

;; ../../../../spec-concrete/1-syntax.watsup:959.21-959.48
syntax selectCase = 
   | keysetExpression : name ;

;; ../../../../spec-concrete/1-syntax.watsup:962.1-963.30
syntax selectCaseList = 
   | 
   | selectCaseList selectCase

;; ../../../../spec-concrete/1-syntax.watsup:965.1-965.58
def $flatten_selectCaseList(selectCaseList) : selectCase* =

  ;; ../../../../spec-concrete/1-syntax.watsup:966.1-966.42
  clause 0(selectCaseList) = []
  -- if selectCaseList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:967.1-968.62
  clause 1(selectCaseList') = $flatten_selectCaseList(selectCaseList) ++ [selectCase]
  -- if selectCaseList' matches `%%`
  -- let selectCaseList selectCase = selectCaseList'

;; ../../../../spec-concrete/1-syntax.watsup:970.27-970.73
syntax selectExpression = 
   | select( expressionList ){ selectCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:977.1-978.21
syntax stateExpression = 
   | name ;
   | select( expressionList ){ selectCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:981.1-982.31
syntax transitionStatement = 
   | 
   | transition stateExpression

;; ../../../../spec-concrete/1-syntax.watsup:989.1-991.21
syntax valueSetType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | tuple< typeArgumentList >
   | text
   | . typeName

;; ../../../../spec-concrete/1-syntax.watsup:994.3-994.69
syntax valueSetDeclaration = 
   | annotationList value_set< valueSetType >( expression ) name ;

;; ../../../../spec-concrete/1-syntax.watsup:1001.3-1001.72
syntax parserTypeDeclaration = 
   | annotationList parser name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1009.31-1009.70
syntax parserBlockStatement = 
   | annotationList { parserStatementList }

;; ../../../../spec-concrete/1-syntax.watsup:1012.1-1019.25
syntax parserStatement = 
   | annotationList const type name initializer ;
   | annotationList type name initializerOpt ;
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | annotationList { parserStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement

;; ../../../../spec-concrete/1-syntax.watsup:1022.1-1023.40
syntax parserStatementList = 
   | 
   | parserStatementList parserStatement

;; ../../../../spec-concrete/1-syntax.watsup:1025.1-1025.73
def $flatten_parserStatementList(parserStatementList) : parserStatement* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1026.1-1026.47
  clause 0(parserStatementList) = []
  -- if parserStatementList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1027.1-1028.77
  clause 1(parserStatementList') = $flatten_parserStatementList(parserStatementList) ++ [parserStatement]
  -- if parserStatementList' matches `%%`
  -- let parserStatementList parserStatement = parserStatementList'

;; ../../../../spec-concrete/1-syntax.watsup:1031.3-1031.73
syntax parserState = 
   | annotationList state name { parserStatementList transitionStatement }

;; ../../../../spec-concrete/1-syntax.watsup:1034.1-1035.32
syntax parserStateList = 
   | annotationList state name { parserStatementList transitionStatement }
   | parserStateList parserState

;; ../../../../spec-concrete/1-syntax.watsup:1037.1-1037.61
def $flatten_parserStateList(parserStateList) : parserState* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1038.1-1038.56
  clause 0(parserStateList) = [parserState]
  -- if parserStateList <: parserState
  -- let parserState = parserStateList as parserState

  ;; ../../../../spec-concrete/1-syntax.watsup:1039.1-1040.65
  clause 1(parserStateList') = $flatten_parserStateList(parserStateList) ++ [parserState]
  -- if parserStateList' matches `%%`
  -- let parserStateList parserState = parserStateList'

;; ../../../../spec-concrete/1-syntax.watsup:1043.1-1046.24
syntax parserLocalDeclaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList type name initializerOpt ;
   | annotationList value_set< valueSetType >( expression ) name ;

;; ../../../../spec-concrete/1-syntax.watsup:1049.1-1050.54
syntax parserLocalDeclarationList = 
   | 
   | parserLocalDeclarationList parserLocalDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:1052.1-1053.28
def $flatten_parserLocalDeclarationList(parserLocalDeclarationList) : parserLocalDeclaration* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1054.1-1054.54
  clause 0(parserLocalDeclarationList) = []
  -- if parserLocalDeclarationList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1055.1-1059.34
  clause 1(parserLocalDeclarationList') = $flatten_parserLocalDeclarationList(parserLocalDeclarationList) ++ [parserLocalDeclaration]
  -- if parserLocalDeclarationList' matches `%%`
  -- let parserLocalDeclarationList parserLocalDeclaration = parserLocalDeclarationList'

;; ../../../../spec-concrete/1-syntax.watsup:1062.3-1064.52
syntax parserDeclaration = 
   | annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }

;; ../../../../spec-concrete/1-syntax.watsup:1074.16-1074.21
syntax const = 
   | const

;; ../../../../spec-concrete/1-syntax.watsup:1077.1-1078.10
syntax constOpt = 
   | 
   | const

;; ../../../../spec-concrete/1-syntax.watsup:1080.1-1080.41
def $flatten_constOpt(constOpt) : const? =

  ;; ../../../../spec-concrete/1-syntax.watsup:1081.1-1081.36
  clause 0(constOpt) = ?()
  -- if constOpt matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1082.1-1082.37
  clause 1(constOpt) = ?(const)
  -- if constOpt <: const
  -- let const = constOpt as const

;; ../../../../spec-concrete/1-syntax.watsup:1088.19-1088.55
syntax tableKey = 
   | expression : name annotationList ;

;; ../../../../spec-concrete/1-syntax.watsup:1091.1-1092.26
syntax tableKeyList = 
   | 
   | tableKeyList tableKey

;; ../../../../spec-concrete/1-syntax.watsup:1094.1-1094.52
def $flatten_tableKeyList(tableKeyList) : tableKey* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1095.1-1095.40
  clause 0(tableKeyList) = []
  -- if tableKeyList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1096.1-1097.56
  clause 1(tableKeyList') = $flatten_tableKeyList(tableKeyList) ++ [tableKey]
  -- if tableKeyList' matches `%%`
  -- let tableKeyList tableKey = tableKeyList'

;; ../../../../spec-concrete/1-syntax.watsup:1104.1-1105.42
syntax tableActionReference = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | prefixedNonTypeName ( argumentList )

;; ../../../../spec-concrete/1-syntax.watsup:1107.22-1107.60
syntax tableAction = 
   | annotationList tableActionReference ;

;; ../../../../spec-concrete/1-syntax.watsup:1110.1-1111.32
syntax tableActionList = 
   | 
   | tableActionList tableAction

;; ../../../../spec-concrete/1-syntax.watsup:1113.1-1113.61
def $flatten_tableActionList(tableActionList) : tableAction* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1114.1-1114.43
  clause 0(tableActionList) = []
  -- if tableActionList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1115.1-1116.63
  clause 1(tableActionList') = $flatten_tableActionList(tableActionList) ++ [tableAction]
  -- if tableActionList' matches `%%`
  -- let tableActionList tableAction = tableActionList'

;; ../../../../spec-concrete/1-syntax.watsup:1123.1-1124.35
syntax tableEntryPriority = 
   | priority= numberLiteral :
   | priority=( expression ):

;; ../../../../spec-concrete/1-syntax.watsup:1127.1-1128.72
syntax tableEntry = 
   | constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ;
   | constOpt keysetExpression : tableActionReference annotationList ;

;; ../../../../spec-concrete/1-syntax.watsup:1131.1-1132.30
syntax tableEntryList = 
   | 
   | tableEntryList tableEntry

;; ../../../../spec-concrete/1-syntax.watsup:1134.1-1134.58
def $flatten_tableEntryList(tableEntryList) : tableEntry* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1135.1-1135.42
  clause 0(tableEntryList) = []
  -- if tableEntryList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1136.1-1137.62
  clause 1(tableEntryList') = $flatten_tableEntryList(tableEntryList) ++ [tableEntry]
  -- if tableEntryList' matches `%%`
  -- let tableEntryList tableEntry = tableEntryList'

;; ../../../../spec-concrete/1-syntax.watsup:1144.1-1147.59
syntax tableProperty = 
   | key={ tableKeyList }
   | actions={ tableActionList }
   | annotationList constOpt entries={ tableEntryList }
   | annotationList constOpt tableCustomName initializer ;

;; ../../../../spec-concrete/1-syntax.watsup:1150.1-1151.36
syntax tablePropertyList = 
   | 
   | tablePropertyList tableProperty

;; ../../../../spec-concrete/1-syntax.watsup:1153.1-1153.67
def $flatten_tablePropertyList(tablePropertyList) : tableProperty* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1154.1-1154.45
  clause 0(tablePropertyList) = []
  -- if tablePropertyList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1155.1-1156.69
  clause 1(tablePropertyList') = $flatten_tablePropertyList(tablePropertyList) ++ [tableProperty]
  -- if tablePropertyList' matches `%%`
  -- let tablePropertyList tableProperty = tablePropertyList'

;; ../../../../spec-concrete/1-syntax.watsup:1159.3-1159.51
syntax tableDeclaration = 
   | annotationList table name { tablePropertyList }

;; ../../../../spec-concrete/1-syntax.watsup:1166.3-1166.73
syntax controlTypeDeclaration = 
   | annotationList control name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1172.22-1172.36
syntax controlBody = blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:1175.1-1179.21
syntax controlLocalDeclaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList type name initializerOpt ;
   | annotationList action name ( parameterList ) blockStatement
   | annotationList table name { tablePropertyList }

;; ../../../../spec-concrete/1-syntax.watsup:1182.1-1183.56
syntax controlLocalDeclarationList = 
   | 
   | controlLocalDeclarationList controlLocalDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:1185.1-1186.29
def $flatten_controlLocalDeclarationList(controlLocalDeclarationList) : controlLocalDeclaration* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1188.1-1188.55
  clause 0(controlLocalDeclarationList) = []
  -- if controlLocalDeclarationList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1189.1-1193.32
  clause 1(controlLocalDeclarationList') = $flatten_controlLocalDeclarationList(controlLocalDeclarationList) ++ [controlLocalDeclaration]
  -- if controlLocalDeclarationList' matches `%%`
  -- let controlLocalDeclarationList controlLocalDeclaration = controlLocalDeclarationList'

;; ../../../../spec-concrete/1-syntax.watsup:1196.3-1198.55
syntax controlDeclaration = 
   | annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }

;; ../../../../spec-concrete/1-syntax.watsup:1205.3-1205.73
syntax packageTypeDeclaration = 
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1212.1-1216.27
syntax typeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }
   | annotationList typedef typedefType name ;
   | annotationList type type name ;
   | annotationList parser name typeParameterListOpt ( parameterList );
   | annotationList control name typeParameterListOpt ( parameterList );
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1223.1-1232.20
syntax declaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList functionPrototype blockStatement
   | annotationList action name ( parameterList ) blockStatement
   | error{ nameList }
   | match_kind{ nameList trailingCommaOpt }
   | annotationList extern functionPrototype ;
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }
   | annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }
   | annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }
   | annotationList typedef typedefType name ;
   | annotationList type type name ;
   | annotationList parser name typeParameterListOpt ( parameterList );
   | annotationList control name typeParameterListOpt ( parameterList );
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1239.1-1256.27
syntax annotationToken = 
   | unexpected_token
   | abstract
   | action
   | actions
   | apply
   | bool
   | bit
   | break
   | const
   | continue
   | control
   | default
   | else
   | entries
   | enum
   | error
   | exit
   | extern
   | false
   | for
   | header
   | header_union
   | if
   | in
   | inout
   | int
   | key
   | match_kind
   | type
   | out
   | parser
   | package
   | pragma
   | return
   | select
   | state
   | string
   | struct
   | switch
   | table
   | this
   | transition
   | true
   | tuple
   | typedef
   | varbit
   | value_set
   | list
   | void
   | _
   | text
   | text
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | &&&
   | ..
   | <<
   | &&
   | ||
   | ==
   | !=
   | >=
   | <=
   | ++
   | +
   | |+|
   | -
   | |-|
   | *
   | /
   | %
   | |
   | &
   | ^
   | ~
   | [
   | ]
   | {
   | }
   | <
   | >
   | !
   | :
   | ,
   | ?
   | .
   | =
   | ;
   | @

;; ../../../../spec-concrete/1-syntax.watsup:1259.1-1261.35
syntax annotationBody = 
   | 
   | annotationBody ( annotationBody )
   | annotationBody annotationToken

;; ../../../../spec-concrete/1-syntax.watsup:1264.3-1264.41
syntax structuredAnnotationBody = 
   | dataElementExpression trailingCommaOpt

;; ../../../../spec-concrete/1-syntax.watsup:1267.1-1269.42
syntax annotation = 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]

;; ../../../../spec-concrete/1-syntax.watsup:1272.1-1273.38
syntax annotationListNonEmpty = 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]
   | annotationListNonEmpty annotation

;; ../../../../spec-concrete/1-syntax.watsup:1276.1-1277.27
syntax annotationList = 
   | 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]
   | annotationListNonEmpty annotation

;; ../../../../spec-concrete/1-syntax.watsup:1284.1-1286.17
syntax p4program = 
   | 
   | p4program declaration
   | p4program ;

;; ../../../../spec-concrete/1-syntax.watsup:1288.1-1288.49
def $flatten_p4program(p4program) : declaration* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1289.1-1289.37
  clause 0(p4program) = []
  -- if p4program matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1290.1-1291.53
  clause 1(p4program') = $flatten_p4program(p4program) ++ [declaration]
  -- if p4program' matches `%%`
  -- let p4program declaration = p4program'

  ;; ../../../../spec-concrete/1-syntax.watsup:1292.1-1293.34
  clause 2(p4program') = $flatten_p4program(p4program)
  -- if p4program' matches `%;`
  -- let p4program ; = p4program'

;; ../../../../spec-concrete/2.0-domain.watsup:5.17-5.21
syntax nameIR = text

;; ../../../../spec-concrete/2.0-domain.watsup:7.1-7.25
def $name(name) : nameIR =

  ;; ../../../../spec-concrete/2.0-domain.watsup:9.1-9.21
  clause 0(name) = t
  -- if name <: identifier
  -- let t = name as identifier

  ;; ../../../../spec-concrete/2.0-domain.watsup:10.1-10.22
  clause 1(name) = t
  -- if name <: typeIdentifier
  -- let t = name as typeIdentifier

  ;; ../../../../spec-concrete/2.0-domain.watsup:11.1-11.27
  clause 2(name) = "apply"
  -- if (name = apply as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:12.1-12.23
  clause 3(name) = "key"
  -- if (name = key as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:13.1-13.31
  clause 4(name) = "actions"
  -- if (name = actions as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:14.1-14.27
  clause 5(name) = "state"
  -- if (name = state as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:15.1-15.31
  clause 6(name) = "entries"
  -- if (name = entries as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:16.1-16.25
  clause 7(name) = "type"
  -- if (name = type as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:17.1-17.33
  clause 8(name) = "priority"
  -- if (name = priority as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:18.1-18.25
  clause 9(name) = "list"
  -- if name matches `LIST`

;; ../../../../spec-concrete/2.0-domain.watsup:20.1-20.47
def $tableCustomName(tableCustomName) : nameIR =

  ;; ../../../../spec-concrete/2.0-domain.watsup:22.1-22.32
  clause 0(tableCustomName) = t
  -- if tableCustomName <: identifier
  -- let t = tableCustomName as identifier

  ;; ../../../../spec-concrete/2.0-domain.watsup:23.1-23.33
  clause 1(tableCustomName) = t
  -- if tableCustomName <: typeIdentifier
  -- let t = tableCustomName as typeIdentifier

  ;; ../../../../spec-concrete/2.0-domain.watsup:24.1-24.38
  clause 2(tableCustomName) = "apply"
  -- if tableCustomName matches `APPLY`

  ;; ../../../../spec-concrete/2.0-domain.watsup:25.1-25.38
  clause 3(tableCustomName) = "state"
  -- if tableCustomName matches `STATE`

  ;; ../../../../spec-concrete/2.0-domain.watsup:26.1-26.36
  clause 4(tableCustomName) = "type"
  -- if tableCustomName matches `TYPE`

  ;; ../../../../spec-concrete/2.0-domain.watsup:27.1-27.44
  clause 5(tableCustomName) = "priority"
  -- if tableCustomName matches `PRIORITY`

;; ../../../../spec-concrete/2.0-domain.watsup:33.13-33.17
syntax id = text

;; ../../../../spec-concrete/2.0-domain.watsup:39.14-39.16
syntax tid = id

;; ../../../../spec-concrete/2.0-domain.watsup:41.1-41.23
def $fresh_tid : tid =

;; ../../../../spec-concrete/2.0-domain.watsup:42.1-42.28
def $fresh_tids(nat) : tid* =

  ;; ../../../../spec-concrete/2.0-domain.watsup:44.1-44.25
  clause 0(nat) = []
  -- if (nat = 0)

  ;; ../../../../spec-concrete/2.0-domain.watsup:45.1-46.15
  clause 1(n) = $fresh_tid :: $fresh_tids((n - 1))
  -- otherwise

;; ../../../../spec-concrete/2.0-domain.watsup:56.14-56.24
syntax pid = 
   | id # bool

;; ../../../../spec-concrete/2.0-domain.watsup:57.14-57.26
syntax rid = 
   | id ( pid* )

;; ../../../../spec-concrete/2.0-domain.watsup:59.1-59.36
def $rid(name, parameterList) : rid =

  ;; ../../../../spec-concrete/2.0-domain.watsup:63.1-64.42
  clause 0(name, parameterList) = $name(name) ( $pids(parameterList) )

;; ../../../../spec-concrete/2.0-domain.watsup:60.1-60.32
def $pids(parameterList) : pid* =

  ;; ../../../../spec-concrete/2.0-domain.watsup:66.1-66.24
  clause 0(parameterList) = []
  -- if parameterList matches ``EMPTY`

  ;; ../../../../spec-concrete/2.0-domain.watsup:67.1-67.39
  clause 1(parameterList) = [$pid(parameter)]
  -- if parameterList <: parameter
  -- let parameter = parameterList as parameter

  ;; ../../../../spec-concrete/2.0-domain.watsup:68.1-69.56
  clause 2(parameterList) = $pids(nonEmptyParameterList as parameterList) ++ [$pid(parameter)]
  -- if parameterList <: nonEmptyParameterList
  -- let nonEmptyParameterList' = parameterList as nonEmptyParameterList
  -- if nonEmptyParameterList' matches `%,%`
  -- let nonEmptyParameterList , parameter = nonEmptyParameterList'

;; ../../../../spec-concrete/2.0-domain.watsup:61.1-61.26
def $pid(parameter) : pid =

  ;; ../../../../spec-concrete/2.0-domain.watsup:71.1-71.51
  clause 0(_annotationList _direction _type name initializerOpt) = $name(name) # false
  -- if initializerOpt matches ``EMPTY`

  ;; ../../../../spec-concrete/2.0-domain.watsup:72.1-72.55
  clause 1(_annotationList _direction _type name initializerOpt) = $name(name) # true
  -- if initializerOpt <: initializer
  -- let initializer = initializerOpt as initializer

;; ../../../../spec-concrete/2.0-domain.watsup:78.14-78.17
syntax cid = rid

;; ../../../../spec-concrete/2.0-domain.watsup:80.1-80.50
def $cid(name, constructorParameterListOpt) : cid =

  ;; ../../../../spec-concrete/2.0-domain.watsup:82.1-82.46
  clause 0(name, constructorParameterListOpt) = $name(name) ( [] )
  -- if constructorParameterListOpt matches ``EMPTY`

  ;; ../../../../spec-concrete/2.0-domain.watsup:83.1-84.42
  clause 1(name, constructorParameterListOpt) = $name(name) ( $pids(parameterList) )
  -- if constructorParameterListOpt matches `(%)`
  -- let ( parameterList ) = constructorParameterListOpt

;; ../../../../spec-concrete/2.0-domain.watsup:88.1-88.48
def $expression_as_lvalue(expression) : lvalue? =

  ;; ../../../../spec-concrete/2.0-domain.watsup:90.1-90.69
  clause 0(expression) = ?(referenceExpression as lvalue)
  -- if expression <: referenceExpression
  -- let referenceExpression = expression as referenceExpression

  ;; ../../../../spec-concrete/2.0-domain.watsup:91.1-92.51
  clause 1(expression') = ?(lvalue . member)
  -- if expression' <: memberAccessExpression
  -- let memberAccessBase . member = expression' as memberAccessExpression
  -- if memberAccessBase <: expression
  -- let expression = memberAccessBase as expression
  -- let lvalue'?{lvalue' <- lvalue'?} = $expression_as_lvalue(expression)
  -- if lvalue'?{lvalue' <- lvalue'?} matches (_)
  -- let ?(lvalue) = lvalue'?{lvalue' <- lvalue'?}

  ;; ../../../../spec-concrete/2.0-domain.watsup:93.1-94.51
  clause 2(expression') = ?(( lvalue ))
  -- if expression' <: parenthesizedExpression
  -- let ( expression ) = expression' as parenthesizedExpression
  -- let lvalue'?{lvalue' <- lvalue'?} = $expression_as_lvalue(expression)
  -- if lvalue'?{lvalue' <- lvalue'?} matches (_)
  -- let ?(lvalue) = lvalue'?{lvalue' <- lvalue'?}

;; ../../../../spec-concrete/2.0-domain.watsup:99.14-99.17
syntax oid = id*

;; ../../../../spec-concrete/2.1.1-value.watsup:14.1-17.18
syntax primitiveValue = 
   | b bool
   | error. id
   | match_kind. id
   | " text " hint(print "#%#")

;; ../../../../spec-concrete/2.1.1-value.watsup:24.1-25.21
syntax numberValue = 
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat

;; ../../../../spec-concrete/2.1.1-value.watsup:27.20-27.50
syntax baseValue = 
   | b bool
   | error. id
   | match_kind. id
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat

;; ../../../../spec-concrete/2.1.1-value.watsup:35.20-35.31
syntax listValue = 
   | [ value* ]

;; ../../../../spec-concrete/2.1.1-value.watsup:36.21-36.32
syntax tupleValue = 
   | ( value* )

;; ../../../../spec-concrete/2.1.1-value.watsup:37.27-37.55
syntax headerStackValue = 
   | [ value* #( nat ; nat )]

;; ../../../../spec-concrete/2.1.1-value.watsup:39.21-39.32
syntax fieldValue = 
   | value id ;

;; ../../../../spec-concrete/2.1.1-value.watsup:41.22-41.49
syntax structValue = 
   | struct tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:42.22-42.49
syntax headerValue = 
   | header tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:43.27-43.60
syntax headerUnionValue = 
   | header_union tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:46.1-47.23
syntax enumValue = 
   | tid . id
   | tid . id # value

;; ../../../../spec-concrete/2.1.1-value.watsup:50.1-56.14
syntax dataValue = 
   | [ value* ]
   | ( value* )
   | [ value* #( nat ; nat )]
   | struct tid { fieldValue* }
   | header tid { fieldValue* }
   | header_union tid { fieldValue* }
   | tid . id
   | tid . id # value

;; ../../../../spec-concrete/2.1.1-value.watsup:62.23-62.30
syntax defaultValue = 
   | default

;; ../../../../spec-concrete/2.1.1-value.watsup:64.29-64.33
syntax invalidHeaderValue = 
   | {#}

;; ../../../../spec-concrete/2.1.1-value.watsup:67.1-68.28
syntax sequenceValue = 
   | seq( value* )
   | seq( value* ,...)

;; ../../../../spec-concrete/2.1.1-value.watsup:71.1-72.36
syntax recordValue = 
   | record{ fieldValue* }
   | record{ fieldValue* ,...}

;; ../../../../spec-concrete/2.1.1-value.watsup:75.1-77.29
syntax setValue = 
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }

;; ../../../../spec-concrete/2.1.1-value.watsup:80.1-81.38
syntax tableValue = 
   | table_enum tid . id
   | table_struct tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:84.1-89.15
syntax synthesizedValue = 
   | default
   | {#}
   | seq( value* )
   | seq( value* ,...)
   | record{ fieldValue* }
   | record{ fieldValue* ,...}
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }
   | table_enum tid . id
   | table_struct tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:95.31-95.37
syntax objectReferenceValue = 
   | ! oid

;; ../../../../spec-concrete/2.1.1-value.watsup:102.1-105.25
syntax value = 
   | b bool
   | error. id
   | match_kind. id
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat
   | [ value* ]
   | ( value* )
   | [ value* #( nat ; nat )]
   | struct tid { fieldValue* }
   | header tid { fieldValue* }
   | header_union tid { fieldValue* }
   | tid . id
   | tid . id # value
   | default
   | {#}
   | seq( value* )
   | seq( value* ,...)
   | record{ fieldValue* }
   | record{ fieldValue* ,...}
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }
   | table_enum tid . id
   | table_struct tid { fieldValue* }
   | ! oid

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:5.1-5.28
def $to_int(int, int) : int =

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:12.1-12.31
def $to_bitstr(int, int) : int =

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:18.1-18.28
def $to_number(value) : int =

  ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:20.1-20.24
  clause 0(value) = i
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i = numberLiteral

  ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:21.1-21.38
  clause 1(value) = $to_int(w as int, i)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i = numberLiteral

  ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:22.1-22.26
  clause 2(value) = i
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i = numberLiteral

  ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:23.1-23.31
  clause 3(value) = i
  -- if value <: numberValue
  -- let numberValue = value as numberValue
  -- if numberValue matches `%V%#%`
  -- let w v i # _nat = numberValue

;; ../../../../spec-concrete/2.2.1-type.watsup:14.1-18.11
syntax primitiveTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string

;; ../../../../spec-concrete/2.2.1-type.watsup:25.1-28.20
syntax numberTypeIR = 
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >

;; ../../../../spec-concrete/2.2.1-type.watsup:30.21-30.51
syntax baseTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >

;; ../../../../spec-concrete/2.2.1-type.watsup:40.1-41.31
syntax namedTypeIR = 
   | tid tid
   | polyTypeDefIR < typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:52.1-53.20
syntax aliasTypeIR = 
   | typedef tid typeIR
   | type tid typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:59.21-59.37
syntax listTypeIR = 
   | list< typeIR >

;; ../../../../spec-concrete/2.2.1-type.watsup:60.22-60.40
syntax tupleTypeIR = 
   | tuple< typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:61.28-61.43
syntax headerStackTypeIR = 
   | typeIR [ nat ]

;; ../../../../spec-concrete/2.2.1-type.watsup:63.22-63.34
syntax fieldTypeIR = 
   | typeIR id ;

;; ../../../../spec-concrete/2.2.1-type.watsup:65.23-65.51
syntax structTypeIR = 
   | struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:66.23-66.51
syntax headerTypeIR = 
   | header tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:67.28-67.62
syntax headerUnionTypeIR = 
   | header_union tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:69.23-69.37
syntax valueFieldIR = 
   | id = value ;

;; ../../../../spec-concrete/2.2.1-type.watsup:72.1-73.42
syntax enumTypeIR = 
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:76.1-82.15
syntax dataTypeIR = 
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:92.3-92.40
syntax externObjectTypeIR = 
   | extern tid map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/2.2.1-type.watsup:93.29-93.57
syntax parserObjectTypeIR = 
   | parser( parameterTypeIR* )

;; ../../../../spec-concrete/2.2.1-type.watsup:94.30-94.59
syntax controlObjectTypeIR = 
   | control( parameterTypeIR* )

;; ../../../../spec-concrete/2.2.1-type.watsup:95.30-95.50
syntax packageObjectTypeIR = 
   | package< typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:96.28-96.47
syntax tableObjectTypeIR = 
   | table tid # typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:99.1-103.22
syntax objectTypeIR = 
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:106.1-108.17
syntax definedTypeIR = 
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:114.24-114.31
syntax defaultTypeIR = 
   | default

;; ../../../../spec-concrete/2.2.1-type.watsup:116.30-116.44
syntax invalidHeaderTypeIR = 
   | header_invalid

;; ../../../../spec-concrete/2.2.1-type.watsup:119.1-120.29
syntax sequenceTypeIR = 
   | seq< typeIR* >
   | seq< typeIR* ,...>

;; ../../../../spec-concrete/2.2.1-type.watsup:123.1-124.37
syntax recordTypeIR = 
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}

;; ../../../../spec-concrete/2.2.1-type.watsup:126.20-126.36
syntax setTypeIR = 
   | set< typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:129.1-130.39
syntax tableTypeIR = 
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:133.1-138.16
syntax synthesizedTypeIR = 
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:145.1-148.22
syntax typeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:154.24-154.30
syntax monoTypeDefIR = typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:156.24-156.48
syntax polyTypeDefIR = 
   | typeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:158.20-158.49
syntax typeDefIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }
   | typeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:164.26-164.52
syntax parameterTypeIR = 
   | direction typeIR id value?

;; ../../../../spec-concrete/2.2.1-type.watsup:171.1-174.33
syntax functionTypeIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )

;; ../../../../spec-concrete/2.2.1-type.watsup:177.1-182.27
syntax methodTypeIR = 
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:185.1-186.17
syntax routineTypeIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:192.31-192.44
syntax monoRoutineTypeDefIR = routineTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:194.31-194.62
syntax polyRoutineTypeDefIR = 
   | routineTypeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:197.1-198.25
syntax routineTypeDefIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR
   | routineTypeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:204.37-204.52
syntax constructorParameterTypeIR = parameterTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:211.3-211.58
syntax constructorTypeIR = 
   | constructor( constructorParameterTypeIR* )-> typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:217.31-217.66
syntax constructorTypeDefIR = 
   | constructorTypeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:9.1-9.34
def $is_baseTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:10.1-10.38
  clause 0(typeIR) = true
  -- if typeIR <: baseTypeIR
  -- let baseTypeIR = typeIR as baseTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:11.1-12.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:16.1-16.39
def $is_primitiveTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:17.1-17.48
  clause 0(typeIR) = true
  -- if typeIR <: primitiveTypeIR
  -- let primitiveTypeIR = typeIR as primitiveTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:18.1-19.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:21.1-21.35
def $is_void_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:22.1-22.33
  clause 0(typeIR) = true
  -- if (typeIR = void as typeIR)

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:23.1-24.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:26.1-26.35
def $is_bool_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:27.1-27.33
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:28.1-29.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:31.1-31.36
def $is_error_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:32.1-32.35
  clause 0(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:33.1-34.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:36.1-36.40
def $is_matchkind_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:37.1-37.44
  clause 0(typeIR) = true
  -- if (typeIR = match_kind as typeIR)

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:38.1-39.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:41.1-41.37
def $is_string_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:42.1-42.37
  clause 0(typeIR) = true
  -- if (typeIR = string as typeIR)

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:43.1-44.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:48.1-48.36
def $is_numberTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:49.1-49.42
  clause 0(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:50.1-51.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:53.1-53.44
def $is_arbitrary_int_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:54.1-54.41
  clause 0(typeIR) = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:55.1-56.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:58.1-58.40
def $is_fixed_int_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:59.1-59.44
  clause 0(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:60.1-61.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:63.1-63.40
def $is_fixed_bit_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:64.1-64.44
  clause 0(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:65.1-66.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:76.1-76.34
def $is_dataTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:77.1-77.38
  clause 0(typeIR) = true
  -- if typeIR <: dataTypeIR
  -- let dataTypeIR = typeIR as dataTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:78.1-79.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:81.1-81.41
def $is_headerStackTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:82.1-82.52
  clause 0(typeIR) = true
  -- if typeIR <: headerStackTypeIR
  -- let headerStackTypeIR = typeIR as headerStackTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:83.1-84.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:88.1-88.36
def $is_objectTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:89.1-89.42
  clause 0(typeIR) = true
  -- if typeIR <: objectTypeIR
  -- let objectTypeIR = typeIR as objectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:90.1-91.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:93.1-93.44
def $is_extern_object_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:94.1-94.56
  clause 0(typeIR) = true
  -- if typeIR <: externObjectTypeIR
  -- let externObjectTypeIR = typeIR as externObjectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:95.1-96.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:98.1-98.44
def $is_parser_object_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:99.1-99.56
  clause 0(typeIR) = true
  -- if typeIR <: parserObjectTypeIR
  -- let parserObjectTypeIR = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:100.1-101.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:103.1-103.45
def $is_control_object_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:104.1-104.58
  clause 0(typeIR) = true
  -- if typeIR <: controlObjectTypeIR
  -- let controlObjectTypeIR = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:105.1-106.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:108.1-108.45
def $is_package_object_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:109.1-109.58
  clause 0(typeIR) = true
  -- if typeIR <: packageObjectTypeIR
  -- let packageObjectTypeIR = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:110.1-111.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:113.1-113.43
def $is_table_object_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:114.1-114.56
  clause 0(typeIR) = true
  -- if typeIR <: controlObjectTypeIR
  -- let controlObjectTypeIR = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:115.1-116.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:120.1-120.41
def $is_synthesizedTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:121.1-121.52
  clause 0(typeIR) = true
  -- if typeIR <: tableObjectTypeIR
  -- let tableObjectTypeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:122.1-123.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:125.1-125.34
def $is_set_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:126.1-126.38
  clause 0(typeIR) = true
  -- if typeIR <: setTypeIR
  -- let set< _typeIR*{_typeIR <- _typeIR*} > = typeIR as setTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:127.1-128.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:5.16-5.24
syntax bound = set<tid>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:6.16-6.32
syntax theta = map<tid, typeIR>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:8.1-8.31
def $free_type(typeIR) : bound =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:33.1-33.38
  clause 0(typeIR) = { [] }
  -- if typeIR <: baseTypeIR
  -- let baseTypeIR = typeIR as baseTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:37.1-37.35
  clause 1(typeIR) = { [tid] }
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid tid = namedTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:39.1-42.59
  clause 2(typeIR') = $union_set<tid>(bound_base, bound_args)
  -- if typeIR' <: namedTypeIR
  -- let namedTypeIR = typeIR' as namedTypeIR
  -- if namedTypeIR matches `%<%>`
  -- let polyTypeDefIR < typeIR*{typeIR <- typeIR*} > = namedTypeIR
  -- let bound_base = $free_typeDef(polyTypeDefIR as typeDefIR)
  -- let bound_args = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:46.1-46.54
  clause 3(typeIR') = $free_type(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPEDEF%%`
  -- let typedef _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:48.1-48.51
  clause 4(typeIR') = $free_type(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:52.1-52.54
  clause 5(typeIR') = $free_type(typeIR)
  -- if typeIR' <: listTypeIR
  -- let list< typeIR > = typeIR' as listTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:54.1-55.42
  clause 6(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:57.1-57.51
  clause 7(typeIR') = $free_type(typeIR)
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:59.1-60.42
  clause 8(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: headerTypeIR
  -- let header _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:62.1-63.42
  clause 9(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: headerUnionTypeIR
  -- let header_union _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:65.1-66.42
  clause 10(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: structTypeIR
  -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:68.1-68.41
  clause 11(typeIR) = { [] }
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:70.1-70.61
  clause 12(typeIR') = $free_type(typeIR)
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:74.1-75.62
  clause 13(typeIR) = $unions_set<tid>($free_routineTypeDef(routineTypeDefIR)*{routineTypeDefIR <- routineTypeDefIR*})
  -- if typeIR <: externObjectTypeIR
  -- let extern _tid { _rid : routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} } = typeIR as externObjectTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:77.1-80.64
  clause 14(typeIR) = bound_params
  -- if typeIR <: parserObjectTypeIR
  -- let parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as parserObjectTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:82.1-85.64
  clause 15(typeIR) = bound_params
  -- if typeIR <: controlObjectTypeIR
  -- let control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as controlObjectTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:87.1-88.42
  clause 16(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: packageObjectTypeIR
  -- let package< typeIR*{typeIR <- typeIR*} > = typeIR' as packageObjectTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:90.1-90.55
  clause 17(typeIR') = $free_type(typeIR)
  -- if typeIR' <: tableObjectTypeIR
  -- let table _tid # typeIR = typeIR' as tableObjectTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:94.1-94.35
  clause 18(typeIR) = { [] }
  -- if (typeIR = default as typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:96.1-96.42
  clause 19(typeIR) = { [] }
  -- if (typeIR = header_invalid as typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:98.1-99.42
  clause 20(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR' as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%>`
  -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:101.1-102.42
  clause 21(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR' as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%,...>`
  -- let seq< typeIR*{typeIR <- typeIR*} ,...> = sequenceTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:104.1-105.42
  clause 22(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: recordTypeIR
  -- let recordTypeIR = typeIR' as recordTypeIR
  -- if recordTypeIR matches `RECORD{%}`
  -- let record{ typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = recordTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:107.1-108.42
  clause 23(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: recordTypeIR
  -- let recordTypeIR = typeIR' as recordTypeIR
  -- if recordTypeIR matches `RECORD{%,...}`
  -- let record{ typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} ,...} = recordTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:110.1-111.42
  clause 24(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: setTypeIR
  -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:113.1-113.47
  clause 25(typeIR) = { [] }
  -- if typeIR <: tableTypeIR
  -- let tableTypeIR = typeIR as tableTypeIR
  -- if tableTypeIR matches `TABLE_ENUM%{%}`
  -- let table_enum _tid { _id*{_id <- _id*} } = tableTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:115.1-115.49
  clause 26(typeIR) = { [] }
  -- if typeIR <: tableTypeIR
  -- let tableTypeIR = typeIR as tableTypeIR
  -- if tableTypeIR matches `TABLE_STRUCT%{%}`
  -- let table_struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:9.1-9.37
def $free_typeDef(typeDefIR) : bound =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:121.1-121.47
  clause 0(typeDefIR) = $free_type(typeIR)
  -- if typeDefIR <: typeIR
  -- let typeIR = typeDefIR as typeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:123.1-126.49
  clause 1(typeDefIR) = $diff_set<tid>(bound_base, bound_tparams)
  -- if typeDefIR <: polyTypeDefIR
  -- let typeIR_base < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = typeDefIR as polyTypeDefIR
  -- let bound_base = $free_typeDef(typeIR_base as typeDefIR)
  -- let bound_tparams = { tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} }

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:10.1-10.49
def $free_parameterType(parameterTypeIR) : bound =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:132.1-132.59
  clause 0(_direction typeIR _id _value?{_value <- _value?}) = $free_type(typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:11.1-11.45
def $free_routineType(routineTypeIR) : bound =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:138.1-144.43
  clause 0(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
  -- let builtin_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
  -- let bound_ret = $free_type(typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:146.1-152.43
  clause 1(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `FUNCTION(%)->%`
  -- let function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
  -- let bound_ret = $free_type(typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:154.1-160.43
  clause 2(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
  -- let extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
  -- let bound_ret = $free_type(typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:162.1-167.64
  clause 3(routineTypeIR) = bound_params
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `ACTION(%)`
  -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:169.1-175.43
  clause 4(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
  -- let builtin_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
  -- let bound_ret = $free_type(typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:177.1-183.43
  clause 5(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
  -- let extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
  -- let bound_ret = $free_type(typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:185.1-191.43
  clause 6(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
  -- let bound_ret = $free_type(typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:193.1-198.64
  clause 7(routineTypeIR) = bound_params
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `PARSER_APPLY(%)`
  -- let parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:200.1-205.64
  clause 8(routineTypeIR) = bound_params
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `CONTROL_APPLY(%)`
  -- let control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:207.1-211.43
  clause 9(routineTypeIR) = bound_ret
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `TABLE_APPLY->%`
  -- let table_apply-> typeIR_ret = methodTypeIR
  -- let bound_ret = $free_type(typeIR_ret)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:12.1-12.51
def $free_routineTypeDef(routineTypeDefIR) : bound =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:217.1-218.37
  clause 0(routineTypeDefIR) = $free_routineType(routineTypeIR)
  -- if routineTypeDefIR <: routineTypeIR
  -- let routineTypeIR = routineTypeDefIR as routineTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:220.1-225.49
  clause 1(routineTypeDefIR) = $diff_set<tid>(bound_base, bound_tparams)
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- let bound_base = $free_routineTypeDef(routineTypeIR as routineTypeDefIR)
  -- let bound_tparams = { tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} }

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:14.1-14.40
def $subst_type(theta, typeIR) : typeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:231.1-231.43
  clause 0(set<pair<tid, typeIR>>, typeIR) = typeIR
  -- if (set<pair<tid, typeIR>> = { [] })

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:232.1-233.15
  clause 1(theta, typeIR) = $subst_type'(theta, typeIR)
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:15.1-15.41
def $subst_type'(theta, typeIR) : typeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:237.1-238.52
  clause 0(theta, typeIR') = typeIR
  -- if typeIR' <: namedTypeIR
  -- let namedTypeIR = typeIR' as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid tid = namedTypeIR
  -- let typeIR''?{typeIR'' <- typeIR''?} = $find_map<tid, typeIR>(theta, tid)
  -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
  -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:240.1-244.54
  clause 1(theta, typeIR') = polyTypeDefIR_subst < typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
  -- if typeIR' <: namedTypeIR
  -- let namedTypeIR = typeIR' as namedTypeIR
  -- if namedTypeIR matches `%<%>`
  -- let polyTypeDefIR < typeIR*{typeIR <- typeIR*} > = namedTypeIR
  -- let typeDefIR = $subst_typeDef'(theta, polyTypeDefIR as typeDefIR)
  -- if typeDefIR <: polyTypeDefIR
  -- let polyTypeDefIR_subst = typeDefIR as polyTypeDefIR
  -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:248.1-250.51
  clause 2(theta, typeIR') = typedef tid typeIR_subst as typeIR
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPEDEF%%`
  -- let typedef tid typeIR = aliasTypeIR
  -- let typeIR_subst = $subst_type'(theta, typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:252.1-254.51
  clause 3(theta, typeIR') = type tid typeIR_subst as typeIR
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type tid typeIR = aliasTypeIR
  -- let typeIR_subst = $subst_type'(theta, typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:258.1-260.51
  clause 4(theta, typeIR') = list< typeIR_subst > as typeIR
  -- if typeIR' <: listTypeIR
  -- let list< typeIR > = typeIR' as listTypeIR
  -- let typeIR_subst = $subst_type'(theta, typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:262.1-264.54
  clause 5(theta, typeIR') = tuple< typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
  -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:266.1-268.51
  clause 6(theta, typeIR') = typeIR_subst [ n ] as typeIR
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ n ] = typeIR' as headerStackTypeIR
  -- let typeIR_subst = $subst_type'(theta, typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:270.1-275.58
  clause 7(theta, typeIR) = struct tid { typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} } as typeIR
  -- if typeIR <: structTypeIR
  -- let struct tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as structTypeIR
  -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:277.1-282.58
  clause 8(theta, typeIR) = header tid { typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} } as typeIR
  -- if typeIR <: headerTypeIR
  -- let header tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerTypeIR
  -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:284.1-289.58
  clause 9(theta, typeIR) = header_union tid { typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} } as typeIR
  -- if typeIR <: headerUnionTypeIR
  -- let header_union tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerUnionTypeIR
  -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:291.1-296.51
  clause 10(theta, typeIR') = enum tid # typeIR_subst { valueFieldIR*{valueFieldIR <- valueFieldIR*} } as typeIR
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum tid # typeIR { valueFieldIR*{valueFieldIR <- valueFieldIR*} } = enumTypeIR
  -- let typeIR_subst = $subst_type'(theta, typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:300.1-306.60
  clause 11(theta, typeIR) = extern tid { rid : routineTypeDefIR_subst*{rid <- rid*, routineTypeDefIR_subst <- routineTypeDefIR_subst*} } as typeIR
  -- if typeIR <: externObjectTypeIR
  -- let extern tid { rid : routineTypeDefIR*{rid <- rid*, routineTypeDefIR <- routineTypeDefIR*} } = typeIR as externObjectTypeIR
  -- (let routineTypeDefIR_subst = $subst_routineTypeDef'(theta, routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*, routineTypeDefIR_subst <- routineTypeDefIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:308.1-311.58
  clause 12(theta, typeIR) = parser( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as typeIR
  -- if typeIR <: parserObjectTypeIR
  -- let parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as parserObjectTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:313.1-316.58
  clause 13(theta, typeIR) = control( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as typeIR
  -- if typeIR <: controlObjectTypeIR
  -- let control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as controlObjectTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:318.1-320.54
  clause 14(theta, typeIR') = package< typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
  -- if typeIR' <: packageObjectTypeIR
  -- let package< typeIR*{typeIR <- typeIR*} > = typeIR' as packageObjectTypeIR
  -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:322.1-324.51
  clause 15(theta, typeIR') = table tid # typeIR_subst as typeIR
  -- if typeIR' <: tableObjectTypeIR
  -- let table tid # typeIR = typeIR' as tableObjectTypeIR
  -- let typeIR_subst = $subst_type'(theta, typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:328.1-330.54
  clause 16(theta, typeIR') = seq< typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
  -- if typeIR' <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR' as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%>`
  -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR
  -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:332.1-334.54
  clause 17(theta, typeIR') = seq< typeIR_subst*{typeIR_subst <- typeIR_subst*} ,...> as typeIR
  -- if typeIR' <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR' as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%,...>`
  -- let seq< typeIR*{typeIR <- typeIR*} ,...> = sequenceTypeIR
  -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:336.1-341.58
  clause 18(theta, typeIR) = record{ typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} } as typeIR
  -- if typeIR <: recordTypeIR
  -- let recordTypeIR = typeIR as recordTypeIR
  -- if recordTypeIR matches `RECORD{%}`
  -- let record{ typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = recordTypeIR
  -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:343.1-348.58
  clause 19(theta, typeIR) = record{ typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} ,...} as typeIR
  -- if typeIR <: recordTypeIR
  -- let recordTypeIR = typeIR as recordTypeIR
  -- if recordTypeIR matches `RECORD{%,...}`
  -- let record{ typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} ,...} = recordTypeIR
  -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:350.1-352.54
  clause 20(theta, typeIR') = set< typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
  -- if typeIR' <: setTypeIR
  -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR
  -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:356.1-357.15
  clause 21(theta, typeIR) = typeIR
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:16.1-16.49
def $subst_typeDef(theta, typeDefIR) : typeDefIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:363.1-363.52
  clause 0(set<pair<tid, typeIR>>, typeDefIR) = typeDefIR
  -- if (set<pair<tid, typeIR>> = { [] })

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:364.1-366.15
  clause 1(theta, typeDefIR) = $subst_typeDef'(theta, typeDefIR)
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:17.1-17.50
def $subst_typeDef'(theta, typeDefIR) : typeDefIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:368.1-368.65
  clause 0(theta, typeDefIR) = $subst_type'(theta, typeIR) as typeDefIR
  -- if typeDefIR <: typeIR
  -- let typeIR = typeDefIR as typeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:370.1-389.62
  clause 1(theta, typeDefIR) = typeIR_base_subst < tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} , tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} > as typeDefIR
  -- if typeDefIR <: polyTypeDefIR
  -- let typeIR_base < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = typeDefIR as polyTypeDefIR
  -- let { tid_free*{tid_free <- tid_free*} } = $diff_set<tid>($free_type(typeIR_base), { tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} })
  -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}
  -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
  -- (let ?(typeIR_free) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}
  -- let bound_capture = $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*})
  -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|)
  -- (if ~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}
  -- let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} = tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|]
  -- let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} = tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|]
  -- let theta' = $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, tid tid_fresh_spec as typeIR*{tid_fresh_spec <- tid_fresh_spec*})
  -- let theta'' = $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, tid tid_fresh_hidden as typeIR*{tid_fresh_hidden <- tid_fresh_hidden*})
  -- let typeIR_base_subst = $subst_type(theta'', typeIR_base)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:18.1-18.67
def $subst_parameterType(theta, parameterTypeIR) : parameterTypeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:395.1-396.20
  clause 0(set<pair<tid, typeIR>>, parameterTypeIR) = parameterTypeIR
  -- if (set<pair<tid, typeIR>> = { [] })

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:397.1-399.15
  clause 1(theta, parameterTypeIR) = $subst_parameterType'(theta, parameterTypeIR)
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:19.1-19.68
def $subst_parameterType'(theta, parameterTypeIR) : parameterTypeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:401.1-403.51
  clause 0(theta, direction typeIR id value?{value <- value?}) = direction typeIR_subst id value?{value <- value?}
  -- let typeIR_subst = $subst_type'(theta, typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:20.1-20.61
def $subst_routineType(theta, routineTypeIR) : routineTypeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:409.1-410.18
  clause 0(set<pair<tid, typeIR>>, routineTypeIR) = routineTypeIR
  -- if (set<pair<tid, typeIR>> = { [] })

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:411.1-413.15
  clause 1(theta, routineTypeIR) = $subst_routineType'(theta, routineTypeIR)
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:21.1-21.62
def $subst_routineType'(theta, routineTypeIR) : routineTypeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:415.1-422.59
  clause 0(theta, routineTypeIR) = builtin_function( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
  -- let builtin_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:424.1-431.59
  clause 1(theta, routineTypeIR) = function( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `FUNCTION(%)->%`
  -- let function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:433.1-440.59
  clause 2(theta, routineTypeIR) = extern_function( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
  -- let extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:442.1-448.58
  clause 3(theta, routineTypeIR) = action( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as routineTypeIR
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `ACTION(%)`
  -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:450.1-457.59
  clause 4(theta, routineTypeIR) = builtin_method( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
  -- let builtin_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:459.1-466.59
  clause 5(theta, routineTypeIR) = extern_method( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
  -- let extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:468.1-475.59
  clause 6(theta, routineTypeIR) = extern_methodabstract( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:477.1-483.58
  clause 7(theta, routineTypeIR) = parser_apply( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as routineTypeIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `PARSER_APPLY(%)`
  -- let parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:485.1-491.58
  clause 8(theta, routineTypeIR) = control_apply( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as routineTypeIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `CONTROL_APPLY(%)`
  -- let control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:493.1-498.59
  clause 9(theta, routineTypeIR) = table_apply-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `TABLE_APPLY->%`
  -- let table_apply-> typeIR_ret = methodTypeIR
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:22.1-22.70
def $subst_routineTypeDef(theta, routineTypeDefIR) : routineTypeDefIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:504.1-505.21
  clause 0(set<pair<tid, typeIR>>, routineTypeDefIR) = routineTypeDefIR
  -- if (set<pair<tid, typeIR>> = { [] })

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:506.1-508.15
  clause 1(theta, routineTypeDefIR) = $subst_routineTypeDef'(theta, routineTypeDefIR)
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:23.1-23.71
def $subst_routineTypeDef'(theta, routineTypeDefIR) : routineTypeDefIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:510.1-511.46
  clause 0(theta, routineTypeDefIR) = $subst_routineType'(theta, routineTypeIR) as routineTypeDefIR
  -- if routineTypeDefIR <: routineTypeIR
  -- let routineTypeIR = routineTypeDefIR as routineTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:513.1-532.73
  clause 1(theta, routineTypeDefIR) = routineTypeIR_subst < tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} , tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} > as routineTypeDefIR
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- let { tid_free*{tid_free <- tid_free*} } = $diff_set<tid>($free_routineType(routineTypeIR), { tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} })
  -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}
  -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
  -- (let ?(typeIR_free) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}
  -- let bound_capture = $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*})
  -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|)
  -- (if ~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}
  -- let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} = tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|]
  -- let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} = tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|]
  -- let theta' = $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, tid tid_fresh_spec as typeIR*{tid_fresh_spec <- tid_fresh_spec*})
  -- let theta'' = $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, tid tid_fresh_hidden as typeIR*{tid_fresh_hidden <- tid_fresh_hidden*})
  -- let routineTypeIR_subst = $subst_routineType(theta'', routineTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:24.1-24.73
def $subst_constructorType(theta, constructorTypeIR) : constructorTypeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:538.1-539.22
  clause 0(set<pair<tid, typeIR>>, constructorTypeIR) = constructorTypeIR
  -- if (set<pair<tid, typeIR>> = { [] })

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:540.1-542.15
  clause 1(theta, constructorTypeIR) = $subst_constructorType'(theta, constructorTypeIR)
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:25.1-25.74
def $subst_constructorType'(theta, constructorTypeIR) : constructorTypeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:544.1-551.59
  clause 0(theta, constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_obj) = constructor( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_obj_subst
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_obj_subst = $subst_type'(theta, typeIR_obj)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:561.1-561.53
def $specialize_typeDef(typeDefIR, typeIR*) : typeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:563.1-563.46
  clause 0(typeDefIR, typeIR'*{typeIR' <- typeIR'*}) = typeIR
  -- if typeDefIR <: typeIR
  -- let typeIR = typeDefIR as typeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches []

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:565.1-568.49
  clause 1(typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = $subst_type(theta, typeIR_base)
  -- if typeDefIR <: polyTypeDefIR
  -- let typeIR_base < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = typeDefIR as polyTypeDefIR
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- let theta = { tid_tparam : typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} }

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:574.1-575.29
def $specialize_routineTypeDef(routineTypeDefIR, typeIR*) : (routineTypeDefIR, tid*) =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:577.1-578.25
  clause 0(routineTypeDefIR, typeIR*{typeIR <- typeIR*}) = (routineTypeIR as routineTypeDefIR, [])
  -- if routineTypeDefIR <: routineTypeIR
  -- let routineTypeIR = routineTypeDefIR as routineTypeIR
  -- if typeIR*{typeIR <- typeIR*} matches []

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:580.1-587.49
  clause 1(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR) as routineTypeDefIR, [])
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- if (|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
  -- let theta = { tid_tparam : typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} }

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:589.1-597.54
  clause 2(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*}) as (routineTypeDefIR, tid*)
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- if ((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))
  -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|)
  -- let theta = { tid_tparam : tid tid_fresh as typeIR*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*} }

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:599.1-610.53
  clause 3(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*}) as (routineTypeDefIR, tid*)
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- if (((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))
  -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|)
  -- let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} = typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ tid tid_fresh as typeIR*{tid_fresh <- tid_fresh*}
  -- let theta = { tid_tparam : typeIR_arg_new*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*} }

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:616.1-617.30
def $specialize_constructorTypeDef(constructorTypeDefIR, typeIR*) : (constructorTypeIR, tid*) =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:619.1-628.57
  clause 0(constructorTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} >, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, [])
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- if (|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
  -- let theta = { tid_tparam : typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} }
  -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:630.1-640.57
  clause 1(constructorTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} >, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, tid_fresh*{tid_fresh <- tid_fresh*})
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- if ((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))
  -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|)
  -- let theta = { tid_tparam : tid tid_fresh as typeIR*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*} }
  -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:642.1-655.57
  clause 2(constructorTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} >, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, tid_fresh*{tid_fresh <- tid_fresh*})
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- if (((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))
  -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|)
  -- let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} = typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ tid tid_fresh as typeIR*{tid_fresh <- tid_fresh*}
  -- let theta = { tid_tparam : typeIR_arg_new*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*} }
  -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:662.1-662.28
def $canon(typeIR) : typeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:664.1-665.65
  clause 0(typeIR') = $canon(typeIR)
  -- if typeIR' <: namedTypeIR
  -- let namedTypeIR = typeIR' as namedTypeIR
  -- if namedTypeIR matches `%<%>`
  -- let polyTypeDefIR < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR
  -- let typeIR = $specialize_typeDef(polyTypeDefIR as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:667.1-667.46
  clause 1(typeIR') = $canon(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPEDEF%%`
  -- let typedef _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:669.1-670.15
  clause 2(typeIR) = typeIR
  -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:7.1-7.38
def $is_nominal_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:10.1-11.40
  clause 0(typeIR) = $is_nominal_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:8.1-8.39
def $is_nominal_typeIR'(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:12.1-12.41
  clause 0(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:13.1-13.48
  clause 1(typeIR) = true
  -- if typeIR <: structTypeIR
  -- let struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:14.1-14.48
  clause 2(typeIR) = true
  -- if typeIR <: headerTypeIR
  -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:15.1-15.54
  clause 3(typeIR) = true
  -- if typeIR <: headerUnionTypeIR
  -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:16.1-16.46
  clause 4(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:17.1-17.51
  clause 5(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:18.1-18.43
  clause 6(typeIR) = true
  -- if typeIR <: externObjectTypeIR
  -- let extern _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:19.1-19.45
  clause 7(typeIR) = true
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:20.1-21.15
  clause 8(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:25.1-25.42
def $is_defaultable_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:28.1-29.44
  clause 0(typeIR) = $is_defaultable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:26.1-26.43
def $is_defaultable_typeIR'(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:30.1-30.41
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:31.1-31.42
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:32.1-32.43
  clause 2(typeIR) = true
  -- if (typeIR = string as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:33.1-33.49
  clause 3(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:34.1-35.35
  clause 4(typeIR') = $is_defaultable_typeIR(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:36.1-37.40
  clause 5(typeIR') = true
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
  -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:38.1-39.35
  clause 6(typeIR') = $is_defaultable_typeIR(typeIR)
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:40.1-41.40
  clause 7(typeIR') = true
  -- if typeIR' <: structTypeIR
  -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR
  -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:42.1-43.40
  clause 8(typeIR') = true
  -- if typeIR' <: headerTypeIR
  -- let header _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR
  -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:44.1-45.40
  clause 9(typeIR') = true
  -- if typeIR' <: headerUnionTypeIR
  -- let header_union _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR
  -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:46.1-46.50
  clause 10(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:47.1-48.35
  clause 11(typeIR') = $is_defaultable_typeIR(typeIR)
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:49.1-50.15
  clause 12(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:54.1-54.40
def $is_equalable_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:57.1-58.42
  clause 0(typeIR) = $is_equalable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:55.1-55.41
def $is_equalable_typeIR'(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:59.1-59.40
  clause 0(typeIR) = false
  -- if (typeIR = void as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:60.1-60.43
  clause 1(typeIR) = false
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid tid = namedTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:61.1-61.46
  clause 2(typeIR) = false
  -- if typeIR <: externObjectTypeIR
  -- let extern _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:62.1-62.49
  clause 3(typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:63.1-63.50
  clause 4(typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:64.1-64.50
  clause 5(typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:65.1-65.48
  clause 6(typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:66.1-66.43
  clause 7(typeIR) = false
  -- if (typeIR = default as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:67.1-67.54
  clause 8(typeIR) = false
  -- if typeIR <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%,...>`
  -- let seq< _typeIR*{_typeIR <- _typeIR*} ,...> = sequenceTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:68.1-68.57
  clause 9(typeIR) = false
  -- if typeIR <: recordTypeIR
  -- let recordTypeIR = typeIR as recordTypeIR
  -- if recordTypeIR matches `RECORD{%,...}`
  -- let record{ _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} ,...} = recordTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:69.1-69.50
  clause 10(typeIR) = false
  -- if (typeIR = header_invalid as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:70.1-70.46
  clause 11(typeIR) = false
  -- if typeIR <: setTypeIR
  -- let set< _typeIR*{_typeIR <- _typeIR*} > = typeIR as setTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:71.1-71.55
  clause 12(typeIR) = false
  -- if typeIR <: tableTypeIR
  -- let tableTypeIR = typeIR as tableTypeIR
  -- if tableTypeIR matches `TABLE_ENUM%{%}`
  -- let table_enum _tid { _id*{_id <- _id*} } = tableTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:72.1-72.57
  clause 13(typeIR) = false
  -- if typeIR <: tableTypeIR
  -- let tableTypeIR = typeIR as tableTypeIR
  -- if tableTypeIR matches `TABLE_STRUCT%{%}`
  -- let table_struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:73.1-74.15
  clause 14(typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:78.1-78.41
def $is_assignable_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:81.1-82.43
  clause 0(typeIR) = $is_assignable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:79.1-79.42
def $is_assignable_typeIR'(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:83.1-83.41
  clause 0(typeIR) = false
  -- if (typeIR = void as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:84.1-84.43
  clause 1(typeIR) = false
  -- if (typeIR = string as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:85.1-85.40
  clause 2(typeIR) = false
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:86.1-86.49
  clause 3(typeIR) = false
  -- if typeIR <: objectTypeIR
  -- let objectTypeIR = typeIR as objectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:87.1-87.54
  clause 4(typeIR) = false
  -- if typeIR <: synthesizedTypeIR
  -- let synthesizedTypeIR = typeIR as synthesizedTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:88.1-89.15
  clause 5(typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:5.1-7.20
relation Type_alpha: typeIR ~~ typeIR
  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:27.1-28.27
  rulegroup basetype
   match
    (expl-input) baseTypeIR as typeIR | baseTypeIR as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: baseTypeIR
    -- let baseTypeIR = typeIR as baseTypeIR
    -- if typeIR' <: baseTypeIR
    -- let baseTypeIR' = typeIR' as baseTypeIR
    -- if (baseTypeIR = baseTypeIR')
   paths
  {
    rulepath basetype
    (premises)
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:32.1-33.26
  rulegroup nametype
   match
    (expl-input) tid tid as typeIR | tid tid as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: namedTypeIR
    -- let namedTypeIR = typeIR as namedTypeIR
    -- if namedTypeIR matches `TID%`
    -- let tid tid = namedTypeIR
    -- if typeIR' <: namedTypeIR
    -- let namedTypeIR' = typeIR' as namedTypeIR
    -- if namedTypeIR' matches `TID%`
    -- let tid tid' = namedTypeIR'
    -- if (tid = tid')
   paths
  {
    rulepath nametype
    (premises)
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:35.1-56.2
  rulegroup spectype
   match
    (expl-input) polyTypeDefIR_a < typeIR_a*{} > as typeIR | polyTypeDefIR_b < typeIR_b*{} > as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: namedTypeIR
    -- let namedTypeIR = typeIR as namedTypeIR
    -- if namedTypeIR matches `%<%>`
    -- let polyTypeDefIR_a < typeIR_a*{typeIR_a <- typeIR_a*} > = namedTypeIR
    -- if typeIR' <: namedTypeIR
    -- let namedTypeIR' = typeIR' as namedTypeIR
    -- if namedTypeIR' matches `%<%>`
    -- let polyTypeDefIR_b < typeIR_b*{typeIR_b <- typeIR_b*} > = namedTypeIR'
   paths
  {
    rulepath nominal
    (premises)
    -- let typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a as typeDefIR, typeIR_a*{typeIR_a <- typeIR_a*})
    -- let typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b as typeDefIR, typeIR_b*{typeIR_b <- typeIR_b*})
    -- if Type_alpha: typeIR_a_spec ~~ typeIR_b_spec holds
    -- if ($is_nominal_typeIR(typeIR_a_spec) /\ $is_nominal_typeIR(typeIR_b_spec))
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 

    rulepath structural
    (premises)
    -- let typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a as typeDefIR, typeIR_a*{typeIR_a <- typeIR_a*})
    -- let typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b as typeDefIR, typeIR_b*{typeIR_b <- typeIR_b*})
    -- if Type_alpha: typeIR_a_spec ~~ typeIR_b_spec holds
    -- if (~$is_nominal_typeIR(typeIR_a_spec) /\ ~$is_nominal_typeIR(typeIR_b_spec))
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:60.1-70.2
  rulegroup typedeftype
   match
    (expl-input) typeIR | typeIR'
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
   paths
  {
    rulepath left
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: aliasTypeIR
    -- let aliasTypeIR = typeIR'' as aliasTypeIR
    -- if aliasTypeIR matches `TYPEDEF%%`
    -- let typedef _tid typeIR_a = aliasTypeIR
    -- let typeIR_b = typeIR'
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
    (output) 

    rulepath right
    (premises)
    -- let typeIR_a = typeIR
    -- let typeIR'' = typeIR'
    -- if typeIR'' <: aliasTypeIR
    -- let aliasTypeIR = typeIR'' as aliasTypeIR
    -- if aliasTypeIR matches `TYPEDEF%%`
    -- let typedef _tid typeIR_b = aliasTypeIR
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:72.1-74.38
  rulegroup newtype
   match
    (expl-input) type tid typeIR_a as typeIR | type tid typeIR_b as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: aliasTypeIR
    -- let aliasTypeIR = typeIR as aliasTypeIR
    -- if aliasTypeIR matches `TYPE%%`
    -- let type tid typeIR_a = aliasTypeIR
    -- if typeIR' <: aliasTypeIR
    -- let aliasTypeIR' = typeIR' as aliasTypeIR
    -- if aliasTypeIR' matches `TYPE%%`
    -- let type tid' typeIR_b = aliasTypeIR'
    -- if (tid = tid')
   paths
  {
    rulepath newtype
    (premises)
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:78.1-80.38
  rulegroup listtype
   match
    (expl-input) list< typeIR_a > as typeIR | list< typeIR_b > as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: listTypeIR
    -- let list< typeIR_a > = typeIR as listTypeIR
    -- if typeIR' <: listTypeIR
    -- let list< typeIR_b > = typeIR' as listTypeIR
   paths
  {
    rulepath listtype
    (premises)
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:82.1-84.41
  rulegroup tupletype
   match
    (expl-input) tuple< typeIR_a*{} > as typeIR | tuple< typeIR_b*{} > as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: tupleTypeIR
    -- let tuple< typeIR_a*{typeIR_a <- typeIR_a*} > = typeIR as tupleTypeIR
    -- if typeIR' <: tupleTypeIR
    -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as tupleTypeIR
   paths
  {
    rulepath tupletype
    (premises)
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:86.1-88.38
  rulegroup stacktype
   match
    (expl-input) typeIR_a [ n_s ] as typeIR | typeIR_b [ n_s ] as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: headerStackTypeIR
    -- let typeIR_a [ n_s ] = typeIR as headerStackTypeIR
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR_b [ n_s' ] = typeIR' as headerStackTypeIR
    -- if (n_s = n_s')
   paths
  {
    rulepath stacktype
    (premises)
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:90.1-93.45
  rulegroup structtype
   match
    (expl-input) struct tid { typeIR_f_a id_f ;*{} } as typeIR | struct tid { typeIR_f_b id_f ;*{} } as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: structTypeIR
    -- let struct tid { typeIR_f_a id_f ;*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} } = typeIR as structTypeIR
    -- if typeIR' <: structTypeIR
    -- let struct tid' { typeIR_f_b id_f' ;*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} } = typeIR' as structTypeIR
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
   paths
  {
    rulepath structtype
    (premises)
    -- (if Type_alpha: typeIR_f_a ~~ typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:95.1-98.45
  rulegroup headertype
   match
    (expl-input) header tid { typeIR_f_a id_f ;*{} } as typeIR | header tid { typeIR_f_b id_f ;*{} } as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: headerTypeIR
    -- let header tid { typeIR_f_a id_f ;*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} } = typeIR as headerTypeIR
    -- if typeIR' <: headerTypeIR
    -- let header tid' { typeIR_f_b id_f' ;*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} } = typeIR' as headerTypeIR
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
   paths
  {
    rulepath headertype
    (premises)
    -- (if Type_alpha: typeIR_f_a ~~ typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:100.1-103.45
  rulegroup headeruniontype
   match
    (expl-input) header_union tid { typeIR_f_a id_f ;*{} } as typeIR | header_union tid { typeIR_f_b id_f ;*{} } as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: headerUnionTypeIR
    -- let header_union tid { typeIR_f_a id_f ;*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} } = typeIR as headerUnionTypeIR
    -- if typeIR' <: headerUnionTypeIR
    -- let header_union tid' { typeIR_f_b id_f' ;*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} } = typeIR' as headerUnionTypeIR
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
   paths
  {
    rulepath headeruniontype
    (premises)
    -- (if Type_alpha: typeIR_f_a ~~ typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:105.1-106.49
  rulegroup enumtype
   match
    (expl-input) enum tid { id_f*{} } as typeIR | enum tid { id_f*{} } as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%{%}`
    -- let enum tid { id_f*{id_f <- id_f*} } = enumTypeIR
    -- if typeIR' <: enumTypeIR
    -- let enumTypeIR' = typeIR' as enumTypeIR
    -- if enumTypeIR' matches `ENUM%{%}`
    -- let enum tid' { id_f'*{id_f' <- id_f'*} } = enumTypeIR'
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
   paths
  {
    rulepath enumtype
    (premises)
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:108.1-111.38
  rulegroup serenumtype
   match
    (expl-input) enum tid # typeIR_a { id_f = value_f ;*{} } as typeIR | enum tid # typeIR_b { id_f = value_f ;*{} } as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum tid # typeIR_a { id_f = value_f ;*{id_f <- id_f*, value_f <- value_f*} } = enumTypeIR
    -- if typeIR' <: enumTypeIR
    -- let enumTypeIR' = typeIR' as enumTypeIR
    -- if enumTypeIR' matches `ENUM%#%{%}`
    -- let enum tid' # typeIR_b { id_f' = value_f' ;*{id_f' <- id_f'*, value_f' <- value_f'*} } = enumTypeIR'
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
    -- (if (value_f = value_f'))*{value_f <- value_f*, value_f' <- value_f'*}
   paths
  {
    rulepath serenumtype
    (premises)
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:115.1-127.73
  rulegroup externtype
   match
    (expl-input) extern tid { rid_a : routineTypeDefIR_a*{} } as typeIR | extern tid { rid_b : routineTypeDefIR_b*{} } as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: externObjectTypeIR
    -- let extern tid { rid_a : routineTypeDefIR_a*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*} } = typeIR as externObjectTypeIR
    -- if typeIR' <: externObjectTypeIR
    -- let extern tid' { rid_b : routineTypeDefIR_b*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*} } = typeIR' as externObjectTypeIR
    -- if (tid = tid')
   paths
  {
    rulepath externtype
    (premises)
    -- if $eq_set<rid>({ rid_a*{rid_a <- rid_a*} }, { rid_b*{rid_b <- rid_b*} })
    -- (let routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} = $find_map<rid, routineTypeDefIR>({ rid_a : routineTypeDefIR_a*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*} }, rid_a))*{rid_a <- rid_a*, routineTypeDefIR? <- routineTypeDefIR?*}
    -- (if routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} matches (_))*{routineTypeDefIR? <- routineTypeDefIR?*}
    -- (let ?(routineTypeDefIR_a') = routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?})*{routineTypeDefIR? <- routineTypeDefIR?*, routineTypeDefIR_a' <- routineTypeDefIR_a'*}
    -- (let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_map<rid, routineTypeDefIR>({ rid_b : routineTypeDefIR_b*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*} }, rid_a))*{rid_a <- rid_a*, routineTypeDefIR'? <- routineTypeDefIR'?*}
    -- (if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_))*{routineTypeDefIR'? <- routineTypeDefIR'?*}
    -- (let ?(routineTypeDefIR_b') = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?})*{routineTypeDefIR'? <- routineTypeDefIR'?*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}
    -- (if RoutineTypeDef_alpha: routineTypeDefIR_a' ~~ routineTypeDefIR_b' holds)*{routineTypeDefIR_a' <- routineTypeDefIR_a'*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:129.1-131.68
  rulegroup parsertype
   match
    (expl-input) parser( parameterTypeIR_a*{} ) as typeIR | parser( parameterTypeIR_b*{} ) as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: parserObjectTypeIR
    -- let parser( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = typeIR as parserObjectTypeIR
    -- if typeIR' <: parserObjectTypeIR
    -- let parser( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = typeIR' as parserObjectTypeIR
   paths
  {
    rulepath parsertype
    (premises)
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:133.1-135.68
  rulegroup controltype
   match
    (expl-input) control( parameterTypeIR_a*{} ) as typeIR | control( parameterTypeIR_b*{} ) as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: controlObjectTypeIR
    -- let control( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = typeIR as controlObjectTypeIR
    -- if typeIR' <: controlObjectTypeIR
    -- let control( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = typeIR' as controlObjectTypeIR
   paths
  {
    rulepath controltype
    (premises)
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:137.1-139.41
  rulegroup packagetype
   match
    (expl-input) package< typeIR_a*{} > as typeIR | package< typeIR_b*{} > as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: packageObjectTypeIR
    -- let package< typeIR_a*{typeIR_a <- typeIR_a*} > = typeIR as packageObjectTypeIR
    -- if typeIR' <: packageObjectTypeIR
    -- let package< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as packageObjectTypeIR
   paths
  {
    rulepath packagetype
    (premises)
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:141.1-143.38
  rulegroup tabletype
   match
    (expl-input) table tid # typeIR_a as typeIR | table tid # typeIR_b as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: tableObjectTypeIR
    -- let table tid # typeIR_a = typeIR as tableObjectTypeIR
    -- if typeIR' <: tableObjectTypeIR
    -- let table tid' # typeIR_b = typeIR' as tableObjectTypeIR
    -- if (tid = tid')
   paths
  {
    rulepath tabletype
    (premises)
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:147.1-148.21
  rulegroup defaulttype
   match
    (expl-input) default as typeIR | default as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if (typeIR = default as typeIR)
    -- if (typeIR' = default as typeIR)
   paths
  {
    rulepath defaulttype
    (premises)
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:150.1-152.41
  rulegroup sequencetype
   match
    (expl-input) seq< typeIR_a*{} > as typeIR | seq< typeIR_b*{} > as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR' matches `SEQ<%>`
    -- let seq< typeIR_b*{typeIR_b <- typeIR_b*} > = sequenceTypeIR'
   paths
  {
    rulepath sequencetype
    (premises)
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:154.1-156.41
  rulegroup sequencedefaulttype
   match
    (expl-input) seq< typeIR_a*{} ,...> as typeIR | seq< typeIR_b*{} ,...> as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR' matches `SEQ<%,...>`
    -- let seq< typeIR_b*{typeIR_b <- typeIR_b*} ,...> = sequenceTypeIR'
   paths
  {
    rulepath sequencedefaulttype
    (premises)
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:158.1-160.41
  rulegroup recordtype
   match
    (expl-input) record{ typeIR_a id ;*{} } as typeIR | record{ typeIR_b id ;*{} } as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: recordTypeIR
    -- let recordTypeIR = typeIR as recordTypeIR
    -- if recordTypeIR matches `RECORD{%}`
    -- let record{ typeIR_a id ;*{id <- id*, typeIR_a <- typeIR_a*} } = recordTypeIR
    -- if typeIR' <: recordTypeIR
    -- let recordTypeIR' = typeIR' as recordTypeIR
    -- if recordTypeIR' matches `RECORD{%}`
    -- let record{ typeIR_b id' ;*{id' <- id'*, typeIR_b <- typeIR_b*} } = recordTypeIR'
    -- (if (id = id'))*{id <- id*, id' <- id'*}
   paths
  {
    rulepath recordtype
    (premises)
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:162.1-165.41
  rulegroup recorddefaulttype
   match
    (expl-input) record{ typeIR_a id ;*{} ,...} as typeIR | record{ typeIR_b id ;*{} ,...} as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: recordTypeIR
    -- let recordTypeIR = typeIR as recordTypeIR
    -- if recordTypeIR matches `RECORD{%,...}`
    -- let record{ typeIR_a id ;*{id <- id*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
    -- if typeIR' <: recordTypeIR
    -- let recordTypeIR' = typeIR' as recordTypeIR
    -- if recordTypeIR' matches `RECORD{%,...}`
    -- let record{ typeIR_b id' ;*{id' <- id'*, typeIR_b <- typeIR_b*} ,...} = recordTypeIR'
    -- (if (id = id'))*{id <- id*, id' <- id'*}
   paths
  {
    rulepath recorddefaulttype
    (premises)
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:167.1-168.35
  rulegroup invalidtype
   match
    (expl-input) header_invalid as typeIR | header_invalid as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if (typeIR = header_invalid as typeIR)
    -- if (typeIR' = header_invalid as typeIR)
   paths
  {
    rulepath invalidtype
    (premises)
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:170.1-172.38
  rulegroup settype
   match
    (expl-input) set< [typeIR_a] > as typeIR | set< [typeIR_b] > as typeIR
    (impl-input) typeIR' | typeIR'''
    (impl-input-premises)
    -- if typeIR' <: setTypeIR
    -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_a] = typeIR*{typeIR <- typeIR*}
    -- if typeIR''' <: setTypeIR
    -- let set< typeIR''*{typeIR'' <- typeIR''*} > = typeIR''' as setTypeIR
    -- if typeIR''*{typeIR'' <- typeIR''*} matches [ _/1 ]
    -- let [typeIR_b] = typeIR''*{typeIR'' <- typeIR''*}
   paths
  {
    rulepath settype
    (premises)
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:174.1-175.61
  rulegroup tableenumtype
   match
    (expl-input) table_enum tid { id_f*{} } as typeIR | table_enum tid { id_f*{} } as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: tableTypeIR
    -- let tableTypeIR = typeIR as tableTypeIR
    -- if tableTypeIR matches `TABLE_ENUM%{%}`
    -- let table_enum tid { id_f*{id_f <- id_f*} } = tableTypeIR
    -- if typeIR' <: tableTypeIR
    -- let tableTypeIR' = typeIR' as tableTypeIR
    -- if tableTypeIR' matches `TABLE_ENUM%{%}`
    -- let table_enum tid' { id_f'*{id_f' <- id_f'*} } = tableTypeIR'
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
   paths
  {
    rulepath tableenumtype
    (premises)
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:177.1-180.45
  rulegroup tablestructtype
   match
    (expl-input) table_struct tid { typeIR_f_a id_f ;*{} } as typeIR | table_struct tid { typeIR_f_b id_f ;*{} } as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: tableTypeIR
    -- let tableTypeIR = typeIR as tableTypeIR
    -- if tableTypeIR matches `TABLE_STRUCT%{%}`
    -- let table_struct tid { typeIR_f_a id_f ;*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} } = tableTypeIR
    -- if typeIR' <: tableTypeIR
    -- let tableTypeIR' = typeIR' as tableTypeIR
    -- if tableTypeIR' matches `TABLE_STRUCT%{%}`
    -- let table_struct tid' { typeIR_f_b id_f' ;*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} } = tableTypeIR'
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
   paths
  {
    rulepath tablestructtype
    (premises)
    -- (if Type_alpha: typeIR_f_a ~~ typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}
    (output) 
  }

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:9.1-11.20
relation ParameterType_alpha: parameterTypeIR ~~ parameterTypeIR
  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:186.1-188.38
  rulegroup 
   match
    (expl-input) _direction typeIR_a _id _value?{} | _direction' typeIR_b _id' _value'?{}
    (impl-input) _direction typeIR_a _id _value?{_value <- _value?} | _direction' typeIR_b _id' _value'?{_value' <- _value'?}
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
    (output) 
  }

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:13.1-15.20
relation RoutineType_alpha: routineTypeIR ~~ routineTypeIR
  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:194.1-198.46
  rulegroup builtinfunction
   match
    (expl-input) builtin_function( parameterTypeIR_a*{} )-> typeIR_ret_a as routineTypeIR | builtin_function( parameterTypeIR_b*{} )-> typeIR_ret_b as routineTypeIR
    (impl-input) routineTypeIR | routineTypeIR'
    (impl-input-premises)
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
    -- let builtin_function( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = functionTypeIR
    -- if routineTypeIR' <: functionTypeIR
    -- let functionTypeIR' = routineTypeIR' as functionTypeIR
    -- if functionTypeIR' matches `BUILTIN_FUNCTION(%)->%`
    -- let builtin_function( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = functionTypeIR'
   paths
  {
    rulepath builtinfunction
    (premises)
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:200.1-204.46
  rulegroup function
   match
    (expl-input) function( parameterTypeIR_a*{} )-> typeIR_ret_a as routineTypeIR | function( parameterTypeIR_b*{} )-> typeIR_ret_b as routineTypeIR
    (impl-input) routineTypeIR | routineTypeIR'
    (impl-input-premises)
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `FUNCTION(%)->%`
    -- let function( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = functionTypeIR
    -- if routineTypeIR' <: functionTypeIR
    -- let functionTypeIR' = routineTypeIR' as functionTypeIR
    -- if functionTypeIR' matches `FUNCTION(%)->%`
    -- let function( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = functionTypeIR'
   paths
  {
    rulepath function
    (premises)
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:206.1-208.68
  rulegroup action
   match
    (expl-input) action( parameterTypeIR_a*{} ) as routineTypeIR | action( parameterTypeIR_b*{} ) as routineTypeIR
    (impl-input) routineTypeIR | routineTypeIR'
    (impl-input-premises)
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `ACTION(%)`
    -- let action( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = functionTypeIR
    -- if routineTypeIR' <: functionTypeIR
    -- let functionTypeIR' = routineTypeIR' as functionTypeIR
    -- if functionTypeIR' matches `ACTION(%)`
    -- let action( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = functionTypeIR'
   paths
  {
    rulepath action
    (premises)
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:210.1-214.46
  rulegroup externfunction
   match
    (expl-input) extern_function( parameterTypeIR_a*{} )-> typeIR_ret_a as routineTypeIR | extern_function( parameterTypeIR_b*{} )-> typeIR_ret_b as routineTypeIR
    (impl-input) routineTypeIR | routineTypeIR'
    (impl-input-premises)
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
    -- let extern_function( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = functionTypeIR
    -- if routineTypeIR' <: functionTypeIR
    -- let functionTypeIR' = routineTypeIR' as functionTypeIR
    -- if functionTypeIR' matches `EXTERN_FUNCTION(%)->%`
    -- let extern_function( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = functionTypeIR'
   paths
  {
    rulepath externfunction
    (premises)
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:216.1-220.46
  rulegroup builtinmethod
   match
    (expl-input) builtin_method( parameterTypeIR_a*{} )-> typeIR_ret_a as routineTypeIR | builtin_method( parameterTypeIR_b*{} )-> typeIR_ret_b as routineTypeIR
    (impl-input) routineTypeIR | routineTypeIR'
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
    -- let builtin_method( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = methodTypeIR
    -- if routineTypeIR' <: methodTypeIR
    -- let methodTypeIR' = routineTypeIR' as methodTypeIR
    -- if methodTypeIR' matches `BUILTIN_METHOD(%)->%`
    -- let builtin_method( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = methodTypeIR'
   paths
  {
    rulepath builtinmethod
    (premises)
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:222.1-226.46
  rulegroup externmethod
   match
    (expl-input) extern_method( parameterTypeIR_a*{} )-> typeIR_ret_a as routineTypeIR | extern_method( parameterTypeIR_b*{} )-> typeIR_ret_b as routineTypeIR
    (impl-input) routineTypeIR | routineTypeIR'
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
    -- let extern_method( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = methodTypeIR
    -- if routineTypeIR' <: methodTypeIR
    -- let methodTypeIR' = routineTypeIR' as methodTypeIR
    -- if methodTypeIR' matches `EXTERN_METHOD(%)->%`
    -- let extern_method( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = methodTypeIR'
   paths
  {
    rulepath externmethod
    (premises)
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:228.1-232.46
  rulegroup externmethod-abstract
   match
    (expl-input) extern_methodabstract( parameterTypeIR_a*{} )-> typeIR_ret_a as routineTypeIR | extern_methodabstract( parameterTypeIR_b*{} )-> typeIR_ret_b as routineTypeIR
    (impl-input) routineTypeIR | routineTypeIR'
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
    -- let extern_methodabstract( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = methodTypeIR
    -- if routineTypeIR' <: methodTypeIR
    -- let methodTypeIR' = routineTypeIR' as methodTypeIR
    -- if methodTypeIR' matches `EXTERN_METHODABSTRACT(%)->%`
    -- let extern_methodabstract( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = methodTypeIR'
   paths
  {
    rulepath externmethod-abstract
    (premises)
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:234.1-237.68
  rulegroup parserapply
   match
    (expl-input) parser_apply( parameterTypeIR_a*{} ) as routineTypeIR | parser_apply( parameterTypeIR_b*{} ) as routineTypeIR
    (impl-input) routineTypeIR | routineTypeIR'
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `PARSER_APPLY(%)`
    -- let parser_apply( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = methodTypeIR
    -- if routineTypeIR' <: methodTypeIR
    -- let methodTypeIR' = routineTypeIR' as methodTypeIR
    -- if methodTypeIR' matches `PARSER_APPLY(%)`
    -- let parser_apply( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = methodTypeIR'
   paths
  {
    rulepath parserapply
    (premises)
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:239.1-242.68
  rulegroup controlapply
   match
    (expl-input) control_apply( parameterTypeIR_a*{} ) as routineTypeIR | control_apply( parameterTypeIR_b*{} ) as routineTypeIR
    (impl-input) routineTypeIR | routineTypeIR'
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `CONTROL_APPLY(%)`
    -- let control_apply( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = methodTypeIR
    -- if routineTypeIR' <: methodTypeIR
    -- let methodTypeIR' = routineTypeIR' as methodTypeIR
    -- if methodTypeIR' matches `CONTROL_APPLY(%)`
    -- let control_apply( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = methodTypeIR'
   paths
  {
    rulepath controlapply
    (premises)
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:244.1-247.46
  rulegroup tableapply
   match
    (expl-input) table_apply-> typeIR_ret_a as routineTypeIR | table_apply-> typeIR_ret_b as routineTypeIR
    (impl-input) routineTypeIR | routineTypeIR'
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `TABLE_APPLY->%`
    -- let table_apply-> typeIR_ret_a = methodTypeIR
    -- if routineTypeIR' <: methodTypeIR
    -- let methodTypeIR' = routineTypeIR' as methodTypeIR
    -- if methodTypeIR' matches `TABLE_APPLY->%`
    -- let table_apply-> typeIR_ret_b = methodTypeIR'
   paths
  {
    rulepath tableapply
    (premises)
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
    (output) 
  }

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:17.1-19.20
relation RoutineTypeDef_alpha: routineTypeDefIR ~~ routineTypeDefIR
  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:253.1-255.59
  rulegroup mono
   match
    (expl-input) routineTypeIR_a as routineTypeDefIR | routineTypeIR_b as routineTypeDefIR
    (impl-input) routineTypeDefIR | routineTypeDefIR'
    (impl-input-premises)
    -- if routineTypeDefIR <: routineTypeIR
    -- let routineTypeIR_a = routineTypeDefIR as routineTypeIR
    -- if routineTypeDefIR' <: routineTypeIR
    -- let routineTypeIR_b = routineTypeDefIR' as routineTypeIR
   paths
  {
    rulepath mono
    (premises)
    -- if RoutineType_alpha: routineTypeIR_a ~~ routineTypeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:257.1-276.71
  rulegroup poly
   match
    (expl-input) routineTypeIR_a < tid_a*{} , tid_hidden_a*{} > as routineTypeDefIR | routineTypeIR_b < tid_b*{} , tid_hidden_b*{} > as routineTypeDefIR
    (impl-input) routineTypeDefIR | routineTypeDefIR'
    (impl-input-premises)
    -- if routineTypeDefIR <: polyRoutineTypeDefIR
    -- let routineTypeIR_a < tid_a*{tid_a <- tid_a*} , tid_hidden_a*{tid_hidden_a <- tid_hidden_a*} > = routineTypeDefIR as polyRoutineTypeDefIR
    -- if routineTypeDefIR' <: polyRoutineTypeDefIR
    -- let routineTypeIR_b < tid_b*{tid_b <- tid_b*} , tid_hidden_b*{tid_hidden_b <- tid_hidden_b*} > = routineTypeDefIR' as polyRoutineTypeDefIR
   paths
  {
    rulepath poly
    (premises)
    -- if (|tid_a*{tid_a <- tid_a*}| = |tid_b*{tid_b <- tid_b*}|)
    -- if (|tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}| = |tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}|)
    -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids((|tid_a*{tid_a <- tid_a*}| + |tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}|))
    -- let tid_a'*{tid_a' <- tid_a'*} = tid_a*{tid_a <- tid_a*} ++ tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}
    -- let theta_a = { tid_a' : tid tid_fresh as typeIR*{tid_a' <- tid_a'*, tid_fresh <- tid_fresh*} }
    -- let routineTypeIR_a_subst = $subst_routineType(theta_a, routineTypeIR_a)
    -- let tid_b'*{tid_b' <- tid_b'*} = tid_b*{tid_b <- tid_b*} ++ tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}
    -- let theta_b = { tid_b' : tid tid_fresh as typeIR*{tid_b' <- tid_b'*, tid_fresh <- tid_fresh*} }
    -- let routineTypeIR_b_subst = $subst_routineType(theta_b, routineTypeIR_b)
    -- if RoutineType_alpha: routineTypeIR_a_subst ~~ routineTypeIR_b_subst holds
    (output) 
  }

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:5.14-5.30
syntax ctk = 
   | lctk
   | ctk
   | dyn

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:7.1-7.30
def $join_ctk(ctk, ctk) : ctk =

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:9.1-9.33
  clause 0(ctk, ctk') = lctk
  -- if ctk matches `LCTK`
  -- if ctk' matches `LCTK`

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:10.1-10.31
  clause 1(ctk, ctk') = ctk
  -- if ctk matches `LCTK`
  -- if ctk' matches `CTK`

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:11.1-11.31
  clause 2(ctk, ctk') = ctk
  -- if ctk matches `CTK`
  -- if ctk' matches `LCTK`

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:12.1-12.30
  clause 3(ctk, ctk') = ctk
  -- if ctk matches `CTK`
  -- if ctk' matches `CTK`

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:13.1-14.15
  clause 4(ctk_a, ctk_b) = dyn
  -- otherwise

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:16.1-16.27
def $joins_ctk(ctk*) : ctk =

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:18.1-18.26
  clause 0(ctk*{ctk <- ctk*}) = dyn
  -- if ctk*{ctk <- ctk*} matches []

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:19.1-19.26
  clause 1(ctk'*{ctk' <- ctk'*}) = ctk
  -- if ctk'*{ctk' <- ctk'*} matches [ _/1 ]
  -- let [ctk] = ctk'*{ctk' <- ctk'*}

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:20.1-20.57
  clause 2(ctk'*{ctk' <- ctk'*}) = $join_ctk(ctk_a, ctk_b)
  -- if ctk'*{ctk' <- ctk'*} matches _ :: _
  -- let ctk_a :: ctk*{ctk <- ctk*} = ctk'*{ctk' <- ctk'*}
  -- if ctk*{ctk <- ctk*} matches [ _/1 ]
  -- let [ctk_b] = ctk*{ctk <- ctk*}

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:21.1-22.40
  clause 3(ctk'*{ctk' <- ctk'*}) = $joins_ctk(ctk_d :: ctk_c*{ctk_c <- ctk_c*})
  -- if ctk'*{ctk' <- ctk'*} matches _ :: _
  -- let ctk_a :: ctk*{ctk <- ctk*} = ctk'*{ctk' <- ctk'*}
  -- if ctk*{ctk <- ctk*} matches _ :: _
  -- let ctk_b :: ctk_c*{ctk_c <- ctk_c*} = ctk*{ctk <- ctk*}
  -- let ctk_d = $join_ctk(ctk_a, ctk_b)

;; ../../../../spec-concrete/3-numerics.watsup:5.1-5.21
def $pow2(nat) : int =

;; ../../../../spec-concrete/3-numerics.watsup:7.1-7.25
def $shl(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:8.1-8.25
def $shr(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:9.1-9.36
def $shr_arith(int, int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:11.1-11.21
def $bneg(int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:12.1-12.26
def $band(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:13.1-13.26
def $bxor(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:14.1-14.25
def $bor(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:16.1-16.33
def $bitacc(int, int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:24.1-24.28
def $un_bnot(value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:26.1-27.22
  clause 0(value) = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i = numberLiteral
  -- let i' = $bneg(i)

;; ../../../../spec-concrete/3-numerics.watsup:31.1-31.28
def $un_lnot(value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:33.1-33.27
  clause 0(value) = b ~b as value
  -- if value <: primitiveValue
  -- let primitiveValue = value as primitiveValue
  -- if primitiveValue matches `B%`
  -- let b b = primitiveValue

;; ../../../../spec-concrete/3-numerics.watsup:37.1-37.28
def $un_plus(value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:39.1-39.24
  clause 0(value) = d i as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i = numberLiteral

  ;; ../../../../spec-concrete/3-numerics.watsup:40.1-40.28
  clause 1(value) = w w i as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i = numberLiteral

  ;; ../../../../spec-concrete/3-numerics.watsup:41.1-41.28
  clause 2(value) = w s i as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i = numberLiteral

;; ../../../../spec-concrete/3-numerics.watsup:45.1-45.29
def $un_minus(value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:47.1-47.29
  clause 0(value) = d -i as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i = numberLiteral

  ;; ../../../../spec-concrete/3-numerics.watsup:48.1-49.29
  clause 1(value) = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i = numberLiteral
  -- let i' = ($pow2(w) - i)

  ;; ../../../../spec-concrete/3-numerics.watsup:50.1-51.46
  clause 2(value) = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i = numberLiteral
  -- let i' = $to_bitstr(w as int, $to_int(w as int, -i))

;; ../../../../spec-concrete/3-numerics.watsup:59.1-59.36
def $bin_plus(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:61.1-61.45
  clause 0(value, value') = d (i_l + i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:62.1-65.43
  clause 1(value, value') = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, (i_l' + i_r'))

  ;; ../../../../spec-concrete/3-numerics.watsup:66.1-69.43
  clause 2(value, value') = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, (i_l' + i_r'))

  ;; ../../../../spec-concrete/3-numerics.watsup:84.1-87.43
  clause 3(value, value') = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, (i_l' - i_r'))

  ;; ../../../../spec-concrete/3-numerics.watsup:102.1-105.43
  clause 4(value, value') = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, (i_l' * i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:73.1-73.39
def $bin_satplus(value, value) : value =

;; ../../../../spec-concrete/3-numerics.watsup:77.1-77.37
def $bin_minus(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:79.1-79.46
  clause 0(value, value') = d (i_l - i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:80.1-83.43
  clause 1(value, value') = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, (i_l' - i_r'))

  ;; ../../../../spec-concrete/3-numerics.watsup:98.1-101.43
  clause 2(value, value') = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, (i_l' * i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:91.1-91.40
def $bin_satminus(value, value) : value =

;; ../../../../spec-concrete/3-numerics.watsup:95.1-95.35
def $bin_mul(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:97.1-97.44
  clause 0(value, value') = d (i_l * i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

;; ../../../../spec-concrete/3-numerics.watsup:109.1-109.35
def $bin_div(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:111.1-111.44
  clause 0(value, value') = d (i_l / i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

;; ../../../../spec-concrete/3-numerics.watsup:115.1-115.35
def $bin_mod(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:117.1-117.44
  clause 0(value, value') = d (i_l \ i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

;; ../../../../spec-concrete/3-numerics.watsup:121.1-121.35
def $bin_shl(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:123.1-123.46
  clause 0(value, value') = d $shl(i_l, i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:124.1-124.50
  clause 1(value, value') = d $shl(i_l, i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:125.1-126.33
  clause 2(value, value') = d $shl(i_l, i_r') as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_r' = $to_int(w_r as int, i_r)

  ;; ../../../../spec-concrete/3-numerics.watsup:128.1-129.49
  clause 3(value, value') = $bin_shl(w_l w i_l as value, w_l w $to_int(w_l as int, i_r) as value)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:130.1-131.45
  clause 4(value, value') = w_l w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i' = $to_bitstr(w_l as int, $shl(i_l, i_r))

  ;; ../../../../spec-concrete/3-numerics.watsup:132.1-134.46
  clause 5(value, value') = w_l w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_r' = $to_int(w_r as int, i_r)
  -- let i' = $to_bitstr(w_l as int, $shl(i_l, i_r'))

  ;; ../../../../spec-concrete/3-numerics.watsup:136.1-137.49
  clause 6(value, value') = $bin_shl(w_l s i_l as value, w_l s $to_int(w_l as int, i_r) as value)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:138.1-140.46
  clause 7(value, value') = w_l s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- let i' = $to_bitstr(w_l as int, $shl(i_l', i_r))

  ;; ../../../../spec-concrete/3-numerics.watsup:141.1-144.47
  clause 8(value, value') = w_l s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- let i_r' = $to_int(w_r as int, i_r)
  -- let i' = $to_bitstr(w_l as int, $shl(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:148.1-148.35
def $bin_shr(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:150.1-150.46
  clause 0(value, value') = d $shr(i_l, i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:151.1-151.50
  clause 1(value, value') = d $shr(i_l, i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:152.1-153.33
  clause 2(value, value') = d $shr(i_l, i_r') as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_r' = $to_int(w_r as int, i_r)

  ;; ../../../../spec-concrete/3-numerics.watsup:155.1-156.49
  clause 3(value, value') = $bin_shr(w_l w i_l as value, w_l w $to_int(w_l as int, i_r) as value)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:157.1-158.45
  clause 4(value, value') = w_l w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i' = $to_bitstr(w_l as int, $shr(i_l, i_r))

  ;; ../../../../spec-concrete/3-numerics.watsup:159.1-161.46
  clause 5(value, value') = w_l w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_r' = $to_int(w_r as int, i_r)
  -- let i' = $to_bitstr(w_l as int, $shr(i_l, i_r'))

  ;; ../../../../spec-concrete/3-numerics.watsup:163.1-167.34
  clause 6(value, value') = w_l s i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- if (i_l' < 0 as int)
  -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
  -- let i'' = $to_bitstr(w_l as int, i')

  ;; ../../../../spec-concrete/3-numerics.watsup:168.1-172.34
  clause 7(value, value') = w_l s i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- if (i_l' >= 0 as int)
  -- let i' = $shr(i_l, i_r)
  -- let i'' = $to_bitstr(w_l as int, i')

  ;; ../../../../spec-concrete/3-numerics.watsup:173.1-177.34
  clause 8(value, value') = w_l s i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- if (i_l' < 0 as int)
  -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
  -- let i'' = $to_bitstr(w_l as int, i')

  ;; ../../../../spec-concrete/3-numerics.watsup:178.1-182.34
  clause 9(value, value') = w_l s i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- if (i_l' >= 0 as int)
  -- let i' = $shr(i_l, i_r)
  -- let i'' = $to_bitstr(w_l as int, i')

  ;; ../../../../spec-concrete/3-numerics.watsup:183.1-188.34
  clause 10(value, value') = w_l s i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- let i_r' = $to_int(w_r as int, i_r)
  -- if (i_l' < 0 as int)
  -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
  -- let i'' = $to_bitstr(w_l as int, i')

  ;; ../../../../spec-concrete/3-numerics.watsup:189.1-194.34
  clause 11(value, value') = w_l s i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- let i_r' = $to_int(w_r as int, i_r)
  -- if (i_l' >= 0 as int)
  -- let i' = $shr(i_l, i_r)
  -- let i'' = $to_bitstr(w_l as int, i')

;; ../../../../spec-concrete/3-numerics.watsup:198.1-198.33
def $bin_le(value, value) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:200.1-200.42
  clause 0(value, value') = (i_l <= i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:201.1-201.46
  clause 1(value, value') = (i_l <= i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')

  ;; ../../../../spec-concrete/3-numerics.watsup:202.1-204.31
  clause 2(value, value') = (i_l' <= i_r')
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:208.1-208.33
def $bin_ge(value, value) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:210.1-210.42
  clause 0(value, value') = (i_l >= i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:211.1-211.46
  clause 1(value, value') = (i_l >= i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')

  ;; ../../../../spec-concrete/3-numerics.watsup:212.1-214.31
  clause 2(value, value') = (i_l' >= i_r')
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:218.1-218.33
def $bin_lt(value, value) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:220.1-220.41
  clause 0(value, value') = (i_l < i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:221.1-221.45
  clause 1(value, value') = (i_l < i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')

  ;; ../../../../spec-concrete/3-numerics.watsup:222.1-224.31
  clause 2(value, value') = (i_l' < i_r')
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:228.1-228.33
def $bin_gt(value, value) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:230.1-230.41
  clause 0(value, value') = (i_l > i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:231.1-231.45
  clause 1(value, value') = (i_l > i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')

  ;; ../../../../spec-concrete/3-numerics.watsup:232.1-234.31
  clause 2(value, value') = (i_l' > i_r')
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:238.1-238.33
def $bin_eq(value, value) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:242.1-243.42
  clause 0(value, value') = (primitiveValue_a = primitiveValue_b)
  -- if value <: primitiveValue
  -- let primitiveValue_a = value as primitiveValue
  -- if value' <: primitiveValue
  -- let primitiveValue_b = value' as primitiveValue

  ;; ../../../../spec-concrete/3-numerics.watsup:245.1-245.40
  clause 1(value, value') = (i_a = i_b)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_a = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_b = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:246.1-246.63
  clause 2(value, value') = ((w_a = w_b) /\ (i_a = i_b))
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_a w i_a = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_b w i_b = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:247.1-247.63
  clause 3(value, value') = ((w_a = w_b) /\ (i_a = i_b))
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_a s i_a = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_b s i_b = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:248.1-248.73
  clause 4(value, value') = ((w_a = w_b) /\ (i_a = i_b))
  -- if value <: numberValue
  -- let numberValue = value as numberValue
  -- if numberValue matches `%V%#%`
  -- let w_a v i_a # _nat = numberValue
  -- if value' <: numberValue
  -- let numberValue' = value' as numberValue
  -- if numberValue' matches `%V%#%`
  -- let w_b v i_b # _nat' = numberValue'

  ;; ../../../../spec-concrete/3-numerics.watsup:250.1-251.33
  clause 5(value, value') = $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})
  -- if value <: listValue
  -- let [ value_a*{value_a <- value_a*} ] = value as listValue
  -- if value' <: listValue
  -- let [ value_b*{value_b <- value_b*} ] = value' as listValue

  ;; ../../../../spec-concrete/3-numerics.watsup:252.1-253.33
  clause 6(value, value') = $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})
  -- if value <: tupleValue
  -- let ( value_a*{value_a <- value_a*} ) = value as tupleValue
  -- if value' <: tupleValue
  -- let ( value_b*{value_b <- value_b*} ) = value' as tupleValue

  ;; ../../../../spec-concrete/3-numerics.watsup:254.1-255.52
  clause 7(value, value') = ($bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*}) /\ (n_s_a = n_s_b))
  -- if value <: headerStackValue
  -- let [ value_a*{value_a <- value_a*} #( _nat ; n_s_a )] = value as headerStackValue
  -- if value' <: headerStackValue
  -- let [ value_b*{value_b <- value_b*} #( _nat' ; n_s_b )] = value' as headerStackValue

  ;; ../../../../spec-concrete/3-numerics.watsup:256.1-261.67
  clause 8(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
  -- if value <: structValue
  -- let struct tid_a { value_f_a id_f_a ;*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} } = value as structValue
  -- if value' <: structValue
  -- let struct tid_b { value_f_b id_f_b ;*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} } = value' as structValue

  ;; ../../../../spec-concrete/3-numerics.watsup:262.1-267.67
  clause 9(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
  -- if value <: headerValue
  -- let header tid_a { value_f_a id_f_a ;*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} } = value as headerValue
  -- if value' <: headerValue
  -- let header tid_b { value_f_b id_f_b ;*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} } = value' as headerValue

  ;; ../../../../spec-concrete/3-numerics.watsup:268.1-273.67
  clause 10(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
  -- if value <: headerUnionValue
  -- let header_union tid_a { value_f_a id_f_a ;*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} } = value as headerUnionValue
  -- if value' <: headerUnionValue
  -- let header_union tid_b { value_f_b id_f_b ;*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} } = value' as headerUnionValue

  ;; ../../../../spec-concrete/3-numerics.watsup:274.1-275.41
  clause 11(value, value') = ((tid_a = tid_b) /\ (id_f_a = id_f_b))
  -- if value <: enumValue
  -- let enumValue = value as enumValue
  -- if enumValue matches `%.%`
  -- let tid_a . id_f_a = enumValue
  -- if value' <: enumValue
  -- let enumValue' = value' as enumValue
  -- if enumValue' matches `%.%`
  -- let tid_b . id_f_b = enumValue'

  ;; ../../../../spec-concrete/3-numerics.watsup:276.1-277.74
  clause 12(value, value') = (((tid_a = tid_b) /\ (id_f_a = id_f_b)) /\ $bin_eq(value_f_a, value_f_b))
  -- if value <: enumValue
  -- let enumValue = value as enumValue
  -- if enumValue matches `%.%#%`
  -- let tid_a . id_f_a # value_f_a = enumValue
  -- if value' <: enumValue
  -- let enumValue' = value' as enumValue
  -- if enumValue' matches `%.%#%`
  -- let tid_b . id_f_b # value_f_b = enumValue'

  ;; ../../../../spec-concrete/3-numerics.watsup:278.1-278.31
  clause 13(value, value') = true
  -- if (value = {#} as value)
  -- if (value' = {#} as value)

;; ../../../../spec-concrete/3-numerics.watsup:239.1-239.36
def $bin_eqs(value*, value*) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:280.1-280.30
  clause 0(value*{value <- value*}, value'*{value' <- value'*}) = true
  -- if value*{value <- value*} matches []
  -- if value'*{value' <- value'*} matches []

  ;; ../../../../spec-concrete/3-numerics.watsup:281.1-281.34
  clause 1(value*{value <- value*}, value'*{value' <- value'*}) = false
  -- if value*{value <- value*} matches []
  -- if value'*{value' <- value'*} matches _ :: _
  -- let _value :: _value'*{_value' <- _value'*} = value'*{value' <- value'*}

  ;; ../../../../spec-concrete/3-numerics.watsup:282.1-282.34
  clause 2(value*{value <- value*}, value'*{value' <- value'*}) = false
  -- if value*{value <- value*} matches _ :: _
  -- let _value :: _value'*{_value' <- _value'*} = value*{value <- value*}
  -- if value'*{value' <- value'*} matches []

  ;; ../../../../spec-concrete/3-numerics.watsup:283.1-284.70
  clause 3(value*{value <- value*}, value'*{value' <- value'*}) = ($bin_eq(value_a_h, value_b_h) /\ $bin_eqs(value_a_t*{value_a_t <- value_a_t*}, value_b_t*{value_b_t <- value_b_t*}))
  -- if value*{value <- value*} matches _ :: _
  -- let value_a_h :: value_a_t*{value_a_t <- value_a_t*} = value*{value <- value*}
  -- if value'*{value' <- value'*} matches _ :: _
  -- let value_b_h :: value_b_t*{value_b_t <- value_b_t*} = value'*{value' <- value'*}

;; ../../../../spec-concrete/3-numerics.watsup:240.1-240.55
def $bin_eqs_fields((value, id)*, (value, id)*) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:286.1-286.37
  clause 0((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = true
  -- if (value, id)*{(value, id) <- (value, id)*} matches []
  -- if (value, id)'*{(value, id)' <- (value, id)'*} matches []

  ;; ../../../../spec-concrete/3-numerics.watsup:287.1-287.41
  clause 1((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = false
  -- if (value, id)*{(value, id) <- (value, id)*} matches []
  -- if (value, id)'*{(value, id)' <- (value, id)'*} matches _ :: _
  -- let _(value, id) :: _(value, id)'*{_(value, id)' <- _(value, id)'*} = (value, id)'*{(value, id)' <- (value, id)'*}

  ;; ../../../../spec-concrete/3-numerics.watsup:288.1-288.41
  clause 2((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = false
  -- if (value, id)*{(value, id) <- (value, id)*} matches _ :: _
  -- let _(value, id) :: _(value, id)'*{_(value, id)' <- _(value, id)'*} = (value, id)*{(value, id) <- (value, id)*}
  -- if (value, id)'*{(value, id)' <- (value, id)'*} matches []

  ;; ../../../../spec-concrete/3-numerics.watsup:289.1-293.67
  clause 3((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = (((id_a_h = id_b_h) /\ $bin_eq(value_a_h, value_b_h)) /\ $bin_eqs_fields((value_a_t, id_a_t)*{id_a_t <- id_a_t*, value_a_t <- value_a_t*}, (value_b_t, id_b_t)*{id_b_t <- id_b_t*, value_b_t <- value_b_t*}))
  -- if (value, id)*{(value, id) <- (value, id)*} matches _ :: _
  -- let (value_a_h, id_a_h) :: (value_a_t, id_a_t)*{id_a_t <- id_a_t*, value_a_t <- value_a_t*} = (value, id)*{(value, id) <- (value, id)*}
  -- if (value, id)'*{(value, id)' <- (value, id)'*} matches _ :: _
  -- let (value_b_h, id_b_h) :: (value_b_t, id_b_t)*{id_b_t <- id_b_t*, value_b_t <- value_b_t*} = (value, id)'*{(value, id)' <- (value, id)'*}

;; ../../../../spec-concrete/3-numerics.watsup:297.1-297.33
def $bin_ne(value, value) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:299.1-299.59
  clause 0(value_l, value_r) = ~$bin_eq(value_l, value_r)

;; ../../../../spec-concrete/3-numerics.watsup:303.1-303.36
def $bin_band(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:305.1-306.44
  clause 0(value, value') = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')
  -- let i' = $to_bitstr(w as int, $band(i_l, i_r))

  ;; ../../../../spec-concrete/3-numerics.watsup:308.1-311.46
  clause 1(value, value') = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, $band(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:315.1-315.36
def $bin_bxor(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:317.1-318.44
  clause 0(value, value') = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')
  -- let i' = $to_bitstr(w as int, $bxor(i_l, i_r))

  ;; ../../../../spec-concrete/3-numerics.watsup:320.1-323.46
  clause 1(value, value') = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, $bxor(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:327.1-327.35
def $bin_bor(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:329.1-330.43
  clause 0(value, value') = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')
  -- let i' = $to_bitstr(w as int, $bor(i_l, i_r))

  ;; ../../../../spec-concrete/3-numerics.watsup:332.1-335.45
  clause 1(value, value') = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, $bor(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:339.1-339.38
def $bin_concat(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:341.1-345.35
  clause 0(value, value') = w w i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i_l' = $shl(i_l, w_r as int)
  -- let i_l'' = (i_l' + i_r)
  -- let w = (w_l + w_r)
  -- let i'' = $to_bitstr(w as int, i_l'')

  ;; ../../../../spec-concrete/3-numerics.watsup:346.1-350.35
  clause 1(value, value') = w w i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_l' = $shl(i_l, w_r as int)
  -- let i_l'' = (i_l' + i_r)
  -- let w = (w_l + w_r)
  -- let i'' = $to_bitstr(w as int, i_l'')

  ;; ../../../../spec-concrete/3-numerics.watsup:352.1-357.37
  clause 2(value, value') = w s i''' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- let i_l'' = $shl(i_l', w_r as int)
  -- let i_l''' = (i_l'' + i_r)
  -- let w = (w_l + w_r)
  -- let i''' = $to_bitstr(w as int, i_l''')

  ;; ../../../../spec-concrete/3-numerics.watsup:358.1-363.37
  clause 3(value, value') = w s i''' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- let i_l'' = $shl(i_l', w_r as int)
  -- let i_l''' = (i_l'' + i_r)
  -- let w = (w_l + w_r)
  -- let i''' = $to_bitstr(w as int, i_l''')

;; ../../../../spec-concrete/3-numerics.watsup:367.1-367.36
def $bin_land(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:369.1-369.45
  clause 0(value, value') = b (b_l /\ b_r) as value
  -- if value <: primitiveValue
  -- let primitiveValue = value as primitiveValue
  -- if primitiveValue matches `B%`
  -- let b b_l = primitiveValue
  -- if value' <: primitiveValue
  -- let primitiveValue' = value' as primitiveValue
  -- if primitiveValue' matches `B%`
  -- let b b_r = primitiveValue'

;; ../../../../spec-concrete/3-numerics.watsup:373.1-373.35
def $bin_lor(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:375.1-375.44
  clause 0(value, value') = b (b_l \/ b_r) as value
  -- if value <: primitiveValue
  -- let primitiveValue = value as primitiveValue
  -- if primitiveValue matches `B%`
  -- let b b_l = primitiveValue
  -- if value' <: primitiveValue
  -- let primitiveValue' = value' as primitiveValue
  -- if primitiveValue' matches `B%`
  -- let b b_r = primitiveValue'

;; ../../../../spec-concrete/3-numerics.watsup:381.1-381.36
def $cast_op(typeIR, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:398.1-398.50
  clause 0(typeIR, value) = $cast_bool(typeIR, b)
  -- if value <: primitiveValue
  -- let primitiveValue = value as primitiveValue
  -- if primitiveValue matches `B%`
  -- let b b = primitiveValue

  ;; ../../../../spec-concrete/3-numerics.watsup:414.1-414.52
  clause 1(typeIR, value) = $cast_arbint(typeIR, i)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i = numberLiteral

  ;; ../../../../spec-concrete/3-numerics.watsup:432.1-432.57
  clause 2(typeIR, value) = $cast_fixbit(typeIR, w, i)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i = numberLiteral

  ;; ../../../../spec-concrete/3-numerics.watsup:449.1-449.57
  clause 3(typeIR, value) = $cast_fixint(typeIR, w, i)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i = numberLiteral

  ;; ../../../../spec-concrete/3-numerics.watsup:462.1-463.48
  clause 4(typeIR, value) = $cast_struct(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
  -- if value <: structValue
  -- let struct tid { value_f id_f ;*{id_f <- id_f*, value_f <- value_f*} } = value as structValue

  ;; ../../../../spec-concrete/3-numerics.watsup:476.1-477.48
  clause 5(typeIR, value) = $cast_header(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
  -- if value <: headerValue
  -- let header tid { value_f id_f ;*{id_f <- id_f*, value_f <- value_f*} } = value as headerValue

  ;; ../../../../spec-concrete/3-numerics.watsup:481.1-481.64
  clause 6(typeIR, value') = $cast_op(typeIR, value)
  -- if value' <: enumValue
  -- let enumValue = value' as enumValue
  -- if enumValue matches `%.%#%`
  -- let _tid . _id # value = enumValue

  ;; ../../../../spec-concrete/3-numerics.watsup:510.1-510.71
  clause 7(typeIR, value') = $cast_sequence(typeIR, value*{value <- value*})
  -- if value' <: sequenceValue
  -- let sequenceValue = value' as sequenceValue
  -- if sequenceValue matches `SEQ(%)`
  -- let seq( value*{value <- value*} ) = sequenceValue

  ;; ../../../../spec-concrete/3-numerics.watsup:538.1-539.39
  clause 8(typeIR, value') = $cast_record(typeIR, (value, id)*{id <- id*, value <- value*})
  -- if value' <: recordValue
  -- let recordValue = value' as recordValue
  -- if recordValue matches `RECORD{%}`
  -- let record{ value id ;*{id <- id*, value <- value*} } = recordValue

  ;; ../../../../spec-concrete/3-numerics.watsup:545.1-545.49
  clause 9(typeIR, value) = $default(typeIR)
  -- if (value = default as value)

  ;; ../../../../spec-concrete/3-numerics.watsup:582.1-583.39
  clause 10(typeIR, value') = $cast_set_singleton(typeIR, value)
  -- if value' <: setValue
  -- let setValue = value' as setValue
  -- if setValue matches `SET{%}`
  -- let set{ value } = setValue

  ;; ../../../../spec-concrete/3-numerics.watsup:584.1-585.45
  clause 11(typeIR, value) = $cast_set_mask(typeIR, value_b, value_m)
  -- if value <: setValue
  -- let setValue = value as setValue
  -- if setValue matches `SET{%&&&%}`
  -- let set{ value_b &&& value_m } = setValue

  ;; ../../../../spec-concrete/3-numerics.watsup:586.1-587.46
  clause 12(typeIR, value) = $cast_set_range(typeIR, value_l, value_u)
  -- if value <: setValue
  -- let setValue = value as setValue
  -- if setValue matches `SET{%..%}`
  -- let set{ value_l .. value_u } = setValue

;; ../../../../spec-concrete/3-numerics.watsup:383.1-383.29
def $default(typeIR) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:594.1-594.49
  clause 0(typeIR) = $default'($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:384.1-384.30
def $default'(typeIR) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:596.1-596.30
  clause 0(typeIR) = b false as value
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:597.1-597.42
  clause 1(typeIR) = error. "NoError" as value
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:598.1-599.24
  clause 2(typeIR) = " text_empty " as value
  -- if (typeIR = string as typeIR)
  -- let text_empty = ""

  ;; ../../../../spec-concrete/3-numerics.watsup:601.1-601.25
  clause 3(typeIR) = d 0 as int as value
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:602.1-602.34
  clause 4(typeIR) = w w 0 as int as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:603.1-603.34
  clause 5(typeIR) = w s 0 as int as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:604.1-604.42
  clause 6(typeIR) = w v 0 as int # 0 as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:606.1-606.59
  clause 7(typeIR') = [ $default(typeIR)*{typeIR <- typeIR*} ] as value
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:608.1-609.56
  clause 8(typeIR') = [ value*{value <- value*} #( 0 ; n_s )] as value
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ n_s ] = typeIR' as headerStackTypeIR
  -- let value*{value <- value*} = $repeat_<value>($default(typeIR), n_s)

  ;; ../../../../spec-concrete/3-numerics.watsup:611.1-612.50
  clause 9(typeIR) = struct tid { $default(typeIR_f) id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } as value
  -- if typeIR <: structTypeIR
  -- let struct tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as structTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:614.1-615.50
  clause 10(typeIR) = header tid { $default(typeIR_f) id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } as value
  -- if typeIR <: headerTypeIR
  -- let header tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:617.1-618.56
  clause 11(typeIR) = header_union tid { $default(typeIR_f) id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } as value
  -- if typeIR <: headerUnionTypeIR
  -- let header_union tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerUnionTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:620.1-620.57
  clause 12(typeIR) = tid . id_f_h as value
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum tid { id*{id <- id*} } = enumTypeIR
  -- if id*{id <- id*} matches _ :: _
  -- let id_f_h :: _id*{_id <- _id*} = id*{id <- id*}

  ;; ../../../../spec-concrete/3-numerics.watsup:622.1-625.67
  clause 13(typeIR') = tid . id_zero # value_zero as value
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum tid # typeIR { id_f = value_f ;*{id_f <- id_f*, value_f <- value_f*} } = enumTypeIR
  -- let value_zero = $cast_arbint(typeIR, 0 as int)
  -- let id?{id <- id?} = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
  -- if id?{id <- id?} matches (_)
  -- let ?(id_zero) = id?{id <- id?}

  ;; ../../../../spec-concrete/3-numerics.watsup:627.1-631.34
  clause 14(typeIR') = tid . id_zero # value_zero as value
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum tid # typeIR { id_f = value_f ;*{id_f <- id_f*, value_f <- value_f*} } = enumTypeIR
  -- let value_zero = $cast_arbint(typeIR, 0 as int)
  -- if (?() = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}))
  -- let id_zero = "__UNSPECIFIED"

;; ../../../../spec-concrete/3-numerics.watsup:388.1-388.37
def $cast_bool(typeIR, bool) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:391.1-391.59
  clause 0(typeIR, b) = $cast_bool'($canon(typeIR), b)

;; ../../../../spec-concrete/3-numerics.watsup:389.1-389.38
def $cast_bool'(typeIR, bool) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:393.1-393.31
  clause 0(typeIR, b) = b b as value
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:394.1-394.42
  clause 1(typeIR, bool) = w w 1 as int as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if (bool = true)

  ;; ../../../../spec-concrete/3-numerics.watsup:395.1-395.43
  clause 2(typeIR, bool) = w w 0 as int as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if (bool = false)

  ;; ../../../../spec-concrete/3-numerics.watsup:396.1-396.58
  clause 3(typeIR', b) = $cast_bool(typeIR, b)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:402.1-402.38
def $cast_arbint(typeIR, int) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:405.1-405.63
  clause 0(typeIR, i) = $cast_arbint'($canon(typeIR), i)

;; ../../../../spec-concrete/3-numerics.watsup:403.1-403.39
def $cast_arbint'(typeIR, int) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:407.1-407.39
  clause 0(typeIR, i) = b (i = 0 as int) as value
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:408.1-408.32
  clause 1(typeIR, i) = d i as value
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:409.1-409.58
  clause 2(typeIR, i) = w w $to_bitstr(w as int, i) as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:410.1-410.58
  clause 3(typeIR, i) = w s $to_bitstr(w as int, i) as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:411.1-411.62
  clause 4(typeIR', i) = $cast_arbint(typeIR, i)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:412.1-412.73
  clause 5(typeIR'', i) = set{ $cast_arbint(typeIR, i) } as value
  -- if typeIR'' <: setTypeIR
  -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
  -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:418.1-418.43
def $cast_fixbit(typeIR, nat, int) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:421.1-421.69
  clause 0(typeIR, w, i) = $cast_fixbit'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:419.1-419.44
def $cast_fixbit'(typeIR, nat, int) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:423.1-423.42
  clause 0(typeIR, w, i) = b (i = 1 as int) as value
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:424.1-424.35
  clause 1(typeIR, _nat, i) = d i as value
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:425.1-426.33
  clause 2(typeIR, _nat, i) = w_to w i' as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w_to > = numberTypeIR
  -- let i' = $to_bitstr(w_to as int, i)

  ;; ../../../../spec-concrete/3-numerics.watsup:427.1-428.33
  clause 3(typeIR, _nat, i) = w_to s i' as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w_to > = numberTypeIR
  -- let i' = $to_bitstr(w_to as int, i)

  ;; ../../../../spec-concrete/3-numerics.watsup:429.1-429.68
  clause 4(typeIR', w, i) = $cast_fixbit(typeIR, w, i)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:430.1-430.79
  clause 5(typeIR'', w, i) = set{ $cast_fixbit(typeIR, w, i) } as value
  -- if typeIR'' <: setTypeIR
  -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
  -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:436.1-436.43
def $cast_fixint(typeIR, nat, int) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:439.1-439.69
  clause 0(typeIR, w, i) = $cast_fixint'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:437.1-437.44
def $cast_fixint'(typeIR, nat, int) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:441.1-441.47
  clause 0(typeIR, w, i) = d $to_int(w as int, i) as value
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:442.1-443.50
  clause 1(typeIR, w_from, i) = w_to w i' as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w_to > = numberTypeIR
  -- let i' = $to_bitstr(w_to as int, $to_int(w_from as int, i))

  ;; ../../../../spec-concrete/3-numerics.watsup:444.1-445.50
  clause 2(typeIR, w_from, i) = w_to s i' as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w_to > = numberTypeIR
  -- let i' = $to_bitstr(w_to as int, $to_int(w_from as int, i))

  ;; ../../../../spec-concrete/3-numerics.watsup:446.1-446.68
  clause 3(typeIR', w, i) = $cast_fixint(typeIR, w, i)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:447.1-447.79
  clause 4(typeIR'', w, i) = set{ $cast_fixint(typeIR, w, i) } as value
  -- if typeIR'' <: setTypeIR
  -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
  -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:453.1-453.52
def $cast_struct(typeIR, tid, (value, id)*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:456.1-457.57
  clause 0(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = $cast_struct'($canon(typeIR), tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../spec-concrete/3-numerics.watsup:454.1-454.53
def $cast_struct'(typeIR, tid, (value, id)*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:459.1-460.39
  clause 0(typeIR, tid', (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = struct tid { value_f id_f ;*{id_f <- id_f*, value_f <- value_f*} } as value
  -- if typeIR <: structTypeIR
  -- let struct tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR
  -- if (tid = tid')

;; ../../../../spec-concrete/3-numerics.watsup:467.1-467.52
def $cast_header(typeIR, tid, (value, id)*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:470.1-471.57
  clause 0(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = $cast_header'($canon(typeIR), tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../spec-concrete/3-numerics.watsup:468.1-468.53
def $cast_header'(typeIR, tid, (value, id)*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:473.1-474.39
  clause 0(typeIR, tid', (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = header tid { value_f id_f ;*{id_f <- id_f*, value_f <- value_f*} } as value
  -- if typeIR <: headerTypeIR
  -- let header tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR
  -- if (tid = tid')

;; ../../../../spec-concrete/3-numerics.watsup:485.1-485.43
def $cast_sequence(typeIR, value*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:488.1-489.44
  clause 0(typeIR, value*{value <- value*}) = $cast_sequence'($canon(typeIR), value*{value <- value*})

;; ../../../../spec-concrete/3-numerics.watsup:486.1-486.44
def $cast_sequence'(typeIR, value*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:491.1-492.34
  clause 0(typeIR', value*{value <- value*}) = [ $cast_op(typeIR, value)*{value <- value*} ] as value
  -- if typeIR' <: listTypeIR
  -- let list< typeIR > = typeIR' as listTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:494.1-495.34
  clause 1(typeIR', value*{value <- value*}) = ( $cast_op(typeIR, value)*{typeIR <- typeIR*, value <- value*} ) as value
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:497.1-500.25
  clause 2(typeIR', value*{value <- value*}) = [ value_cast*{value_cast <- value_cast*} #( n_idx ; n_s )] as value
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ n_s ] = typeIR' as headerStackTypeIR
  -- (let value_cast = $cast_op(typeIR, value))*{value <- value*, value_cast <- value_cast*}
  -- let n_idx = |value*{value <- value*}|

  ;; ../../../../spec-concrete/3-numerics.watsup:502.1-504.50
  clause 3(typeIR, value*{value <- value*}) = struct tid { value_cast id_f ;*{id_f <- id_f*, value_cast <- value_cast*} } as value
  -- if typeIR <: structTypeIR
  -- let struct tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as structTypeIR
  -- (let value_cast = $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

  ;; ../../../../spec-concrete/3-numerics.watsup:506.1-508.50
  clause 4(typeIR, value*{value <- value*}) = header tid { value_cast id_f ;*{id_f <- id_f*, value_cast <- value_cast*} } as value
  -- if typeIR <: headerTypeIR
  -- let header tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerTypeIR
  -- (let value_cast = $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

;; ../../../../spec-concrete/3-numerics.watsup:516.1-516.47
def $cast_record(typeIR, (value, id)*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:519.1-520.48
  clause 0(typeIR, (value, id)*{id <- id*, value <- value*}) = $cast_record'($canon(typeIR), (value, id)*{id <- id*, value <- value*})

;; ../../../../spec-concrete/3-numerics.watsup:517.1-517.48
def $cast_record'(typeIR, (value, id)*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:522.1-528.57
  clause 0(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = struct tid { value_f_cast id_f ;*{id_f <- id_f*, value_f_cast <- value_f_cast*} } as value
  -- if typeIR <: structTypeIR
  -- let struct tid { typeIR_t_f id_t_f ;*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*} } = typeIR as structTypeIR
  -- (let value?{value <- value?} = $find_map<id, value>({ id_f : value_f*{id_f <- id_f*, value_f <- value_f*} }, id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}
  -- (if value?{value <- value?} matches (_))*{value? <- value?*}
  -- (let ?(value_f') = value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}
  -- (let value_f_cast = $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

  ;; ../../../../spec-concrete/3-numerics.watsup:530.1-536.57
  clause 1(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = header tid { value_f_cast id_f ;*{id_f <- id_f*, value_f_cast <- value_f_cast*} } as value
  -- if typeIR <: headerTypeIR
  -- let header tid { typeIR_t_f id_t_f ;*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*} } = typeIR as headerTypeIR
  -- (let value?{value <- value?} = $find_map<id, value>({ id_f : value_f*{id_f <- id_f*, value_f <- value_f*} }, id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}
  -- (if value?{value <- value?} matches (_))*{value? <- value?*}
  -- (let ?(value_f') = value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}
  -- (let value_f_cast = $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

;; ../../../../spec-concrete/3-numerics.watsup:551.1-551.47
def $cast_set_singleton(typeIR, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:554.1-555.48
  clause 0(typeIR, value) = $cast_set_singleton'($canon(typeIR), value)

;; ../../../../spec-concrete/3-numerics.watsup:552.1-552.48
def $cast_set_singleton'(typeIR, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:557.1-558.37
  clause 0(typeIR'', value) = set{ $cast_op(typeIR, value) } as value
  -- if typeIR'' <: setTypeIR
  -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
  -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:560.1-560.49
def $cast_set_mask(typeIR, value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:563.1-564.54
  clause 0(typeIR, value_b, value_m) = $cast_set_mask'($canon(typeIR), value_b, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:561.1-561.50
def $cast_set_mask'(typeIR, value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:566.1-569.49
  clause 0(typeIR'', value_b, value_m) = set{ value_b_cast &&& value_m_cast } as value
  -- if typeIR'' <: setTypeIR
  -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
  -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
  -- let value_b_cast = $cast_op(typeIR, value_b)
  -- let value_m_cast = $cast_op(typeIR, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:571.1-571.50
def $cast_set_range(typeIR, value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:574.1-575.55
  clause 0(typeIR, value_l, value_u) = $cast_set_range'($canon(typeIR), value_l, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:572.1-572.51
def $cast_set_range'(typeIR, value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:577.1-580.49
  clause 0(typeIR'', value_l, value_u) = set{ value_l_cast .. value_u_cast } as value
  -- if typeIR'' <: setTypeIR
  -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
  -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
  -- let value_l_cast = $cast_op(typeIR, value_l)
  -- let value_u_cast = $cast_op(typeIR, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:637.1-637.44
def $bitacc_op(value, value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:639.1-644.35
  clause 0(value_b, value_h, value_l) = w w i as value
  -- let i_b = $to_number(value_b)
  -- let i_h = $to_number(value_h)
  -- let i_l = $to_number(value_l)
  -- let int = ((i_h + 1 as int) - i_l)
  -- if int <: nat
  -- let w = int as nat
  -- let i = $bitacc(i_b, i_h, i_l)

;; ../../../../spec-concrete/3-numerics.watsup:650.1-650.32
def $sizeof(typeIR, id) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:681.1-681.69
  clause 0(typeIR, text) = $sizeof_minSizeInBits(typeIR)
  -- if (text = "minSizeInBits")

  ;; ../../../../spec-concrete/3-numerics.watsup:688.1-688.71
  clause 1(typeIR, text) = $sizeof_minSizeInBytes(typeIR)
  -- if (text = "minSizeInBytes")

  ;; ../../../../spec-concrete/3-numerics.watsup:707.1-707.69
  clause 2(typeIR, text) = $sizeof_maxSizeInBits(typeIR)
  -- if (text = "maxSizeInBits")

  ;; ../../../../spec-concrete/3-numerics.watsup:714.1-714.71
  clause 3(typeIR, text) = $sizeof_maxSizeInBytes(typeIR)
  -- if (text = "maxSizeInBytes")

;; ../../../../spec-concrete/3-numerics.watsup:652.1-652.42
def $sizeof_minSizeInBits(typeIR) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:666.1-666.69
  clause 0(typeIR) = d $sizeof_minSizeInBits'(typeIR) as int as value

;; ../../../../spec-concrete/3-numerics.watsup:653.1-653.41
def $sizeof_minSizeInBits'(typeIR) : nat =

  ;; ../../../../spec-concrete/3-numerics.watsup:667.1-667.77
  clause 0(typeIR) = $sizeof_minSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:654.1-654.42
def $sizeof_minSizeInBits''(typeIR) : nat =

  ;; ../../../../spec-concrete/3-numerics.watsup:669.1-669.38
  clause 0(typeIR) = 1
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:670.1-670.44
  clause 1(typeIR) = w
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:671.1-671.44
  clause 2(typeIR) = w
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:672.1-672.47
  clause 3(typeIR) = 0
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:673.1-673.76
  clause 4(typeIR') = $sizeof_minSizeInBits'(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:674.1-674.86
  clause 5(typeIR') = $sizeof_minSizeInBits'(typeIR)
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:675.1-675.88
  clause 6(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:676.1-676.93
  clause 7(typeIR') = ($sizeof_minSizeInBits'(typeIR) * n_size)
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:677.1-677.98
  clause 8(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: structTypeIR
  -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:678.1-678.98
  clause 9(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: headerTypeIR
  -- let header _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:679.1-679.104
  clause 10(typeIR') = $min($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: headerUnionTypeIR
  -- let header_union _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:656.1-656.43
def $sizeof_minSizeInBytes(typeIR) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:685.1-686.48
  clause 0(typeIR) = d (n_size / 8) as int as value
  -- let n_size = $sizeof_minSizeInBits'(typeIR)

;; ../../../../spec-concrete/3-numerics.watsup:658.1-658.42
def $sizeof_maxSizeInBits(typeIR) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:692.1-692.69
  clause 0(typeIR) = d $sizeof_maxSizeInBits'(typeIR) as int as value

;; ../../../../spec-concrete/3-numerics.watsup:659.1-659.41
def $sizeof_maxSizeInBits'(typeIR) : nat =

  ;; ../../../../spec-concrete/3-numerics.watsup:693.1-693.77
  clause 0(typeIR) = $sizeof_maxSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:660.1-660.42
def $sizeof_maxSizeInBits''(typeIR) : nat =

  ;; ../../../../spec-concrete/3-numerics.watsup:695.1-695.38
  clause 0(typeIR) = 1
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:696.1-696.44
  clause 1(typeIR) = w
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:697.1-697.44
  clause 2(typeIR) = w
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:698.1-698.47
  clause 3(typeIR) = w
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:699.1-699.76
  clause 4(typeIR') = $sizeof_maxSizeInBits'(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:700.1-700.86
  clause 5(typeIR') = $sizeof_maxSizeInBits'(typeIR)
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:701.1-701.88
  clause 6(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:702.1-702.93
  clause 7(typeIR') = ($sizeof_maxSizeInBits'(typeIR) * n_size)
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:703.1-703.98
  clause 8(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: structTypeIR
  -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:704.1-704.98
  clause 9(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: headerTypeIR
  -- let header _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:705.1-705.104
  clause 10(typeIR') = $max($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: headerUnionTypeIR
  -- let header_union _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:662.1-662.43
def $sizeof_maxSizeInBytes(typeIR) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:711.1-712.48
  clause 0(typeIR) = d (n_size / 8) as int as value
  -- let n_size = $sizeof_maxSizeInBits'(typeIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:6.1-7.14
syntax prefixedNameIR = 
   | ` nameIR
   | . nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:9.1-9.63
def $prefixedNonTypeName(prefixedNonTypeName) : prefixedNameIR =

  ;; ../../../../spec-concrete/4-ir-syntax.watsup:10.1-10.62
  clause 0(prefixedNonTypeName) = ` $name(nonTypeName as name)
  -- if prefixedNonTypeName <: nonTypeName
  -- let nonTypeName = prefixedNonTypeName as nonTypeName

  ;; ../../../../spec-concrete/4-ir-syntax.watsup:11.1-11.69
  clause 1(prefixedNonTypeName) = . $name(nonTypeName as name)
  -- if prefixedNonTypeName matches ``ID.%`
  -- let . nonTypeName = prefixedNonTypeName

;; ../../../../spec-concrete/4-ir-syntax.watsup:13.1-13.57
def $prefixedTypeName(prefixedTypeName) : prefixedNameIR =

  ;; ../../../../spec-concrete/4-ir-syntax.watsup:14.1-14.53
  clause 0(prefixedTypeName) = ` $name(typeName as name)
  -- if prefixedTypeName <: typeName
  -- let typeName = prefixedTypeName as typeName

  ;; ../../../../spec-concrete/4-ir-syntax.watsup:15.1-15.61
  clause 1(prefixedTypeName) = . $name(typeName as name)
  -- if prefixedTypeName matches ``TID.%`
  -- let . typeName = prefixedTypeName

;; ../../../../spec-concrete/4-ir-syntax.watsup:17.1-17.53
def $flatten_prefixedNameIR(prefixedNameIR) : nameIR =

  ;; ../../../../spec-concrete/4-ir-syntax.watsup:18.1-18.48
  clause 0(prefixedNameIR) = nameIR
  -- if prefixedNameIR matches ``%`
  -- let ` nameIR = prefixedNameIR

  ;; ../../../../spec-concrete/4-ir-syntax.watsup:19.1-19.55
  clause 1(prefixedNameIR) = "." ++ nameIR
  -- if prefixedNameIR matches `.%`
  -- let . nameIR = prefixedNameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:21.21-21.28
syntax nameListIR = nameIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:27.26-27.29
syntax typeParameterIR = tid

;; ../../../../spec-concrete/4-ir-syntax.watsup:29.30-29.46
syntax typeParameterListIR = typeParameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:38.3-38.66
syntax parameterIR = 
   | annotationList direction typeIR nameIR constantInitializerOptIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:40.26-40.38
syntax parameterListIR = parameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:46.33-46.44
syntax constructorParameterIR = parameterIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:48.37-48.49
syntax constructorParameterListIR = parameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:56.28-56.55
syntax namedExpressionIR = 
   | nameIR = typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:58.32-58.50
syntax namedExpressionListIR = namedExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:68.30-68.47
syntax literalExpressionIR = literalExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:74.32-74.46
syntax referenceExpressionIR = prefixedNameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:80.30-80.47
syntax defaultExpressionIR = defaultExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:86.28-86.50
syntax unaryExpressionIR = 
   | unop typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:89.3-89.44
syntax binaryExpressionIR = 
   | typedExpressionIR binop typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:92.3-92.62
syntax ternaryExpressionIR = 
   | typedExpressionIR ? typedExpressionIR : typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:98.27-98.56
syntax castExpressionIR = 
   | ( typeIR ) typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:107.1-111.46
syntax dataExpressionIR = 
   | {#}
   | seq{ typedExpressionListIR }
   | seq{ typedExpressionListIR ,...}
   | record{ namedExpressionListIR }
   | record{ namedExpressionListIR ,...}

;; ../../../../spec-concrete/4-ir-syntax.watsup:120.3-120.18
syntax errorAccessExpressionIR = 
   | error. nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:123.3-123.31
syntax memberAccessExpressionIR = 
   | memberAccessBaseIR . nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:126.1-127.66
syntax indexAccessExpressionIR = 
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]

;; ../../../../spec-concrete/4-ir-syntax.watsup:130.1-132.28
syntax accessExpressionIR = 
   | error. nameIR
   | memberAccessBaseIR . nameIR
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]

;; ../../../../spec-concrete/4-ir-syntax.watsup:143.1-146.25
syntax routineTargetIR = 
   | ` nameIR
   | . nameIR
   | typedExpressionIR . nameIR
   | type prefixedNameIR . nameIR
   | ( routineTargetIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:148.30-148.68
syntax constructorTargetIR = 
   | prefixedNameIR < typeArgumentListIR >

;; ../../../../spec-concrete/4-ir-syntax.watsup:151.1-152.64
syntax callExpressionIR = 
   | constructorTargetIR ( argumentListIR )
   | routineTargetIR < typeArgumentListIR >( argumentListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:158.36-158.58
syntax parenthesizedExpressionIR = 
   | ( typedExpressionIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:165.1-175.30
syntax expressionIR = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | ` nameIR
   | . nameIR
   | ...
   | unop typedExpressionIR
   | typedExpressionIR binop typedExpressionIR
   | typedExpressionIR ? typedExpressionIR : typedExpressionIR
   | ( typeIR ) typedExpressionIR
   | {#}
   | seq{ typedExpressionListIR }
   | seq{ typedExpressionListIR ,...}
   | record{ namedExpressionListIR }
   | record{ namedExpressionListIR ,...}
   | error. nameIR
   | memberAccessBaseIR . nameIR
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]
   | constructorTargetIR ( argumentListIR )
   | routineTargetIR < typeArgumentListIR >( argumentListIR )
   | ( typedExpressionIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:177.27-177.42
syntax expressionNoteIR = 
   | ( typeIR ctk )

;; ../../../../spec-concrete/4-ir-syntax.watsup:180.3-180.35
syntax typedExpressionIR = 
   | expressionIR # expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:182.32-182.50
syntax typedExpressionListIR = typedExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:185.1-186.22
syntax memberAccessBaseIR = 
   | type prefixedNameIR
   | expressionIR # expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:193.1-197.7
syntax simpleKeysetExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR &&& typedExpressionIR
   | typedExpressionIR .. typedExpressionIR
   | default
   | _

;; ../../../../spec-concrete/4-ir-syntax.watsup:199.39-199.64
syntax simpleKeysetExpressionListIR = simpleKeysetExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:201.34-201.67
syntax tupleKeysetExpressionIR = 
   | ( simpleKeysetExpressionListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:204.1-205.28
syntax keysetExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR &&& typedExpressionIR
   | typedExpressionIR .. typedExpressionIR
   | default
   | _
   | ( simpleKeysetExpressionListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:211.25-211.31
syntax typeArgumentIR = typeIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:213.29-213.44
syntax typeArgumentListIR = typeArgumentIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:220.1-223.7
syntax argumentIR = 
   | expressionIR # expressionNoteIR
   | nameIR = typedExpressionIR
   | nameIR =_
   | _

;; ../../../../spec-concrete/4-ir-syntax.watsup:225.25-225.36
syntax argumentListIR = argumentIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:232.1-236.23
syntax lvalueIR = 
   | ` nameIR
   | . nameIR
   | typedLvalueIR . nameIR
   | typedLvalueIR [ typedExpressionIR ]
   | typedLvalueIR [ typedExpressionIR : typedExpressionIR ]
   | ( typedLvalueIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:238.24-238.47
syntax typedLvalueIR = 
   | lvalueIR #( typeIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:248.27-248.41
syntax emptyStatementIR = emptyStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:255.3-255.46
syntax assignmentStatementIR = 
   | typedLvalueIR assignop typedExpressionIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:262.3-262.65
syntax callStatementIR = 
   | routineTargetIR < typeArgumentListIR >( argumentListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:269.3-269.49
syntax directApplicationStatementIR = 
   | prefixedNameIR .apply( argumentListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:276.1-277.32
syntax returnStatementIR = 
   | return;
   | return typedExpressionIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:283.26-283.39
syntax exitStatementIR = exitStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:292.3-292.50
syntax blockStatementIR = 
   | annotationList { blockElementStatementListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:301.1-302.59
syntax conditionalStatementIR = 
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:311.1-314.35
syntax forInitStatementIR = 
   | annotationList typeIR nameIR initializerOptIR
   | lvalueIR ( argumentListIR )
   | lvalueIR < typeArgumentListIR >( argumentListIR )
   | lvalueIR assignop expressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:316.33-316.52
syntax forInitStatementListIR = forInitStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:318.31-318.49
syntax forUpdateStatementIR = forInitStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:320.35-320.56
syntax forUpdateStatementListIR = forUpdateStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:323.1-324.44
syntax forCollectionExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR .. typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:327.1-335.18
syntax forStatementIR = 
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:342.1-343.22
syntax switchLabelIR = 
   | default
   | expressionIR # expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:346.1-347.21
syntax switchCaseIR = 
   | switchLabelIR : blockStatementIR
   | switchLabelIR :

;; ../../../../spec-concrete/4-ir-syntax.watsup:349.27-349.40
syntax switchCaseListIR = switchCaseIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:352.3-352.54
syntax switchStatementIR = 
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:358.27-358.41
syntax breakStatementIR = breakStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:360.30-360.47
syntax continueStatementIR = continueStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:367.1-378.22
syntax statementIR = 
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | return;
   | return typedExpressionIR ;
   | exit;
   | annotationList { blockElementStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR
   | break;
   | continue;
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:388.32-388.40
syntax constantInitializerIR = 
   | = value

;; ../../../../spec-concrete/4-ir-syntax.watsup:390.35-390.57
syntax constantInitializerOptIR = constantInitializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:393.3-393.62
syntax constantDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:395.24-395.44
syntax initializerIR = 
   | = typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:397.27-397.41
syntax initializerOptIR = initializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:400.3-400.51
syntax variableDeclarationIR = 
   | annotationList typeIR nameIR initializerOptIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:403.1-405.16
syntax blockElementStatementIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | return;
   | return typedExpressionIR ;
   | exit;
   | annotationList { blockElementStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR
   | break;
   | continue;
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:407.38-407.62
syntax blockElementStatementListIR = blockElementStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:414.3-415.73
syntax functionPrototypeIR = 
   | typeIR nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:418.3-418.54
syntax functionDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:425.3-425.69
syntax actionDeclarationIR = 
   | annotationList action nameIR ( parameterListIR ) blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:433.30-433.61
syntax objectInitializerIR = 
   | ={ objectDeclarationListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:435.33-435.53
syntax objectInitializerOptIR = objectInitializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:438.3-440.30
syntax instantiationIR = 
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:443.1-444.20
syntax objectDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:446.34-446.54
syntax objectDeclarationListIR = objectDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:452.29-452.50
syntax errorDeclarationIR = 
   | error{ nameListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:458.33-458.59
syntax matchKindDeclarationIR = 
   | match_kind{ nameListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:469.1-470.65
syntax enumTypeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:476.22-476.53
syntax typeFieldIR = 
   | annotationList typeIR nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:478.26-478.38
syntax typeFieldListIR = typeFieldIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:481.3-482.73
syntax structTypeDeclarationIR = 
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:485.3-486.73
syntax headerTypeDeclarationIR = 
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:489.3-490.73
syntax headerUnionTypeDeclarationIR = 
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:493.1-496.33
syntax derivedTypeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:503.1-504.29
syntax typedefTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:507.1-508.41
syntax typedefDeclarationIR = 
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:515.3-515.47
syntax externFunctionDeclarationIR = 
   | annotationList extern functionPrototypeIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:518.1-520.51
syntax methodPrototypeIR = 
   | annotationList nameIR <, typeParameterListIR >( parameterListIR );
   | annotationList functionPrototypeIR ;
   | annotationList abstract functionPrototypeIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:522.32-522.50
syntax methodPrototypeListIR = methodPrototypeIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:525.3-527.31
syntax externObjectDeclarationIR = 
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:530.1-531.30
syntax externDeclarationIR = 
   | annotationList extern functionPrototypeIR ;
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:541.23-541.54
syntax selectCaseIR = 
   | keysetExpressionIR : nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:543.27-543.40
syntax selectCaseListIR = selectCaseIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:546.3-546.58
syntax selectExpressionIR = 
   | select( typedExpressionListIR ){ selectCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:553.1-554.23
syntax stateExpressionIR = 
   | nameIR ;
   | select( typedExpressionListIR ){ selectCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:556.32-556.60
syntax transitionStatementIR = 
   | transition stateExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:563.3-563.72
syntax valueSetDeclarationIR = 
   | annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:570.3-571.76
syntax parserTypeDeclarationIR = 
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:580.3-580.44
syntax parserBlockStatementIR = 
   | annotationList { parserStatementListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:583.1-590.27
syntax parserStatementIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | annotationList { parserStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:592.32-592.50
syntax parserStatementListIR = parserStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:595.3-596.53
syntax parserStateIR = 
   | annotationList state nameIR { parserStatementListIR transitionStatementIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:598.28-598.42
syntax parserStateListIR = parserStateIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:601.1-604.26
syntax parserLocalDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:607.3-607.28
syntax parserLocalDeclarationListIR = parserLocalDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:610.3-613.56
syntax parserDeclarationIR = 
   | annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:623.18-623.23
syntax constIR = const

;; ../../../../spec-concrete/4-ir-syntax.watsup:625.21-625.29
syntax constOptIR = constIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:631.21-631.66
syntax tableKeyIR = 
   | typedExpressionIR : nameIR annotationList ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:633.25-633.36
syntax tableKeyListIR = tableKeyIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:639.33-639.67
syntax tableActionReferenceIR = 
   | prefixedNameIR ( argumentListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:641.24-641.64
syntax tableActionIR = 
   | annotationList tableActionReferenceIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:643.28-643.42
syntax tableActionListIR = tableActionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:650.1-651.42
syntax tableEntryPriorityIR = 
   | priority= numberLiteral :
   | priority=( typedExpressionIR ):

;; ../../../../spec-concrete/4-ir-syntax.watsup:653.34-653.55
syntax tableEntryPriorityOptIR = tableEntryPriorityIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:656.3-657.67
syntax tableEntryIR = 
   | constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:659.27-659.40
syntax tableEntryListIR = tableEntryIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:666.1-672.75
syntax tablePropertyIR = 
   | key={ tableKeyListIR }
   | actions={ tableActionListIR }
   | annotationList constOptIR entries={ tableEntryListIR }
   | annotationList constOptIR default_action= tableActionReferenceIR ;
   | annotationList constOptIR custom nameIR initializerIR ;
   | annotationList constOptIR custom_const nameIR constantInitializerIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:674.30-674.46
syntax tablePropertyListIR = tablePropertyIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:677.3-677.62
syntax tableDeclarationIR = 
   | annotationList table typeIR nameIR { tablePropertyListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:684.3-686.28
syntax controlTypeDeclarationIR = 
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:692.24-692.40
syntax controlBodyIR = blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:695.1-699.23
syntax controlLocalDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | annotationList action nameIR ( parameterListIR ) blockStatementIR
   | annotationList table typeIR nameIR { tablePropertyListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:702.3-702.29
syntax controlLocalDeclarationListIR = controlLocalDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:705.3-708.59
syntax controlDeclarationIR = 
   | annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:715.3-717.28
syntax packageTypeDeclarationIR = 
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:724.1-728.29
syntax typeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:735.1-744.22
syntax declarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList action nameIR ( parameterListIR ) blockStatementIR
   | error{ nameListIR }
   | match_kind{ nameListIR }
   | annotationList extern functionPrototypeIR ;
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }
   | annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
   | annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:750.22-750.39
syntax p4programIR = 
   | declarationIR* ;

;; ../../../../spec-concrete/5.0-flow.watsup:5.15-5.25
syntax flow = 
   | cont
   | ret

;; ../../../../spec-concrete/5.0-flow.watsup:9.1-9.34
def $join_flow(flow, flow) : flow =

  ;; ../../../../spec-concrete/5.0-flow.watsup:10.1-10.31
  clause 0(flow, flow') = ret
  -- if flow matches `RET`
  -- if flow' matches `RET`

  ;; ../../../../spec-concrete/5.0-flow.watsup:11.1-12.15
  clause 1(f_a, f_b) = cont
  -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:5.20-5.47
syntax varTypeIR = 
   | direction typeIR ctk value?

;; ../../../../spec-concrete/5.01-env.watsup:12.16-12.34
syntax frame = map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:14.1-14.27
def $empty_frame : frame =

  ;; ../../../../spec-concrete/5.01-env.watsup:15.1-15.47
  clause 0 = $empty_map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:18.16-18.35
syntax tdenv = map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:20.1-20.27
def $empty_tdenv : tdenv =

  ;; ../../../../spec-concrete/5.01-env.watsup:21.1-21.48
  clause 0 = $empty_map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:24.16-24.42
syntax rdenv = map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:26.1-26.27
def $empty_rdenv : rdenv =

  ;; ../../../../spec-concrete/5.01-env.watsup:27.1-27.55
  clause 0 = $empty_map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:30.16-30.46
syntax cdenv = map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:32.1-32.27
def $empty_cdenv : cdenv =

  ;; ../../../../spec-concrete/5.01-env.watsup:33.1-33.59
  clause 0 = $empty_map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:39.1-39.39
def $check_routine_name(id, id) : bool =

  ;; ../../../../spec-concrete/5.01-env.watsup:40.1-40.50
  clause 0(id_l, id_r) = (id_l = id_r)

;; ../../../../spec-concrete/5.01-env.watsup:42.1-42.37
def $check_arity(id?*, id*) : bool =

  ;; ../../../../spec-concrete/5.01-env.watsup:43.1-43.72
  clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| = |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:45.1-45.42
def $check_arity_more(id?*, id*) : bool =

  ;; ../../../../spec-concrete/5.01-env.watsup:46.1-46.77
  clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:48.1-48.42
def $check_arity_less(id?*, id*) : bool =

  ;; ../../../../spec-concrete/5.01-env.watsup:49.1-49.77
  clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| < |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:51.1-51.44
def $get_missing_parameters(id*, id*) : id* =

  ;; ../../../../spec-concrete/5.01-env.watsup:53.1-53.48
  clause 0(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = []
  -- if id*{id <- id*} matches []

  ;; ../../../../spec-concrete/5.01-env.watsup:54.1-59.47
  clause 1(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = id_param_h :: $get_missing_parameters(id_param_t*{id_param_t <- id_param_t*}, id_arg*{id_arg <- id_arg*})
  -- if id*{id <- id*} matches _ :: _
  -- let id_param_h :: id_param_t*{id_param_t <- id_param_t*} = id*{id <- id*}
  -- if ~$in_set<id>(id_param_h, { id_arg*{id_arg <- id_arg*} })

  ;; ../../../../spec-concrete/5.01-env.watsup:60.1-65.15
  clause 2(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = $get_missing_parameters(id_param_t*{id_param_t <- id_param_t*}, id_arg*{id_arg <- id_arg*})
  -- if id*{id <- id*} matches _ :: _
  -- let id_param_h :: id_param_t*{id_param_t <- id_param_t*} = id*{id <- id*}
  -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:68.1-68.61
def $find_match_named<V>(rid, V, id*, pid*) : (rid, V, id*)? =

  ;; ../../../../spec-concrete/5.01-env.watsup:70.1-72.50
  clause 0(rid, V, id_arg*{id_arg <- id_arg*}, id_param # bool_param*{bool_param <- bool_param*, id_param <- id_param*}) = ?((rid, V, []))
  -- if $eq_set<id>({ id_arg*{id_arg <- id_arg*} }, { id_param*{id_param <- id_param*} })

  ;; ../../../../spec-concrete/5.01-env.watsup:73.1-74.15
  clause 1(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:77.1-77.69
def $find_match_named_default<V>(rid, V, id*, pid*) : (rid, V, id*)? =

  ;; ../../../../spec-concrete/5.01-env.watsup:79.1-86.18
  clause 0(rid, V, id_arg*{id_arg <- id_arg*}, id_param # bool_param*{bool_param <- bool_param*, id_param <- id_param*}) = ?((rid, V, id_default*{id_default <- id_default*}))
  -- let id_default*{id_default <- id_default*} = $get_missing_parameters(id_param*{id_param <- id_param*}, id_arg*{id_arg <- id_arg*})
  -- if ($find_match_named<V>(rid, V, id_arg*{id_arg <- id_arg*} ++ id_default*{id_default <- id_default*}, id_param # bool_param*{bool_param <- bool_param*, id_param <- id_param*}) =/= ?())

  ;; ../../../../spec-concrete/5.01-env.watsup:87.1-88.15
  clause 1(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:91.1-91.74
def $find_match_unnamed_default<V>(rid, V, id?*, pid*) : (rid, V, id*)? =

  ;; ../../../../spec-concrete/5.01-env.watsup:93.1-95.74
  clause 0(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*}) = ?((rid, V, id_default*{id_default <- id_default*}))
  -- let (_pid*{_pid <- _pid*}, id_default # bool*{bool <- bool*, id_default <- id_default*}) = $partition_<pid>(pid*{pid <- pid*}, |id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}|)
  -- (if (bool = true))*{bool <- bool*}

  ;; ../../../../spec-concrete/5.01-env.watsup:96.1-97.15
  clause 1(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*}) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:100.1-100.64
def $find_matching<V>(id, id?*, id*, rid, V) : (rid, V, id*)? =

  ;; ../../../../spec-concrete/5.01-env.watsup:103.1-105.42
  clause 0(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' ( pid_r'*{pid_r' <- pid_r'*} ), V) = ?()
  -- if ~$check_routine_name(id_r, id_r')

  ;; ../../../../spec-concrete/5.01-env.watsup:107.1-113.50
  clause 1(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = ?()
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity_more(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

  ;; ../../../../spec-concrete/5.01-env.watsup:115.1-125.45
  clause 2(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = $find_match_named<V>(id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V, id_arg'*{id_arg' <- id_arg'*}, id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
  -- if (|id_arg'*{id_arg' <- id_arg'*}| > 0)
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

  ;; ../../../../spec-concrete/5.01-env.watsup:127.1-133.45
  clause 3(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id*{id <- id*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = ?((id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V, []))
  -- if id*{id <- id*} matches []
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

  ;; ../../../../spec-concrete/5.01-env.watsup:135.1-145.50
  clause 4(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = $find_match_named_default<V>(id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V, id_arg'*{id_arg' <- id_arg'*}, id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
  -- if (|id_arg'*{id_arg' <- id_arg'*}| > 0)
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

  ;; ../../../../spec-concrete/5.01-env.watsup:147.1-156.50
  clause 5(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id*{id <- id*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = $find_match_unnamed_default<V>(id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
  -- if id*{id <- id*} matches []
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

;; ../../../../spec-concrete/5.01-env.watsup:159.1-159.67
def $find_matchings<V>(id, id?*, id*, rid*, V*) : (rid, V, id*)* =

  ;; ../../../../spec-concrete/5.01-env.watsup:161.1-165.8
  clause 0(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = []
  -- if rid*{rid <- rid*} matches []
  -- if V*{V <- V*} matches []

  ;; ../../../../spec-concrete/5.01-env.watsup:166.1-171.72
  clause 1(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})
  -- if rid*{rid <- rid*} matches _ :: _
  -- let rid_h :: rid_t*{rid_t <- rid_t*} = rid*{rid <- rid*}
  -- if V*{V <- V*} matches _ :: _
  -- let V_h :: V_t*{V_t <- V_t*} = V*{V <- V*}
  -- if ($find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h) = ?())

  ;; ../../../../spec-concrete/5.01-env.watsup:172.1-178.66
  clause 2(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid'*{rid' <- rid'*}, V'*{V' <- V'*}) = (rid, V, id_default*{id_default <- id_default*}) :: $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})
  -- if rid'*{rid' <- rid'*} matches _ :: _
  -- let rid_h :: rid_t*{rid_t <- rid_t*} = rid'*{rid' <- rid'*}
  -- if V'*{V' <- V'*} matches _ :: _
  -- let V_h :: V_t*{V_t <- V_t*} = V'*{V' <- V'*}
  -- let (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} = $find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h)
  -- if (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} matches (_)
  -- let ?((rid, V, id_default*{id_default <- id_default*})) = (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?}

;; ../../../../spec-concrete/5.01-env.watsup:181.1-181.66
def $find_overloaded<V>(map<rid, V>, id, id?*) : (rid, V, id*)? =

  ;; ../../../../spec-concrete/5.01-env.watsup:184.1-190.71
  clause 0({ rid : V*{V <- V*, rid <- rid*} }, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
  -- if (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)
  -- (let id?{id <- id?} = id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}
  -- (if id?{id <- id?} matches (_))*{id? <- id?*}
  -- (let ?(id_arg') = id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}
  -- if ($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = [])

  ;; ../../../../spec-concrete/5.01-env.watsup:191.1-198.65
  clause 1({ rid : V*{V <- V*, rid <- rid*} }, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?((rid', V', id_default*{id_default <- id_default*}))
  -- if (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)
  -- (let id?{id <- id?} = id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}
  -- (if id?{id <- id?} matches (_))*{id? <- id?*}
  -- (let ?(id_arg') = id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}
  -- let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*})
  -- if (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches [ _/1 ]
  -- let [(rid', V', id_default*{id_default <- id_default*})] = (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*}

  ;; ../../../../spec-concrete/5.01-env.watsup:200.1-205.66
  clause 2({ rid : V*{V <- V*, rid <- rid*} }, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
  -- (if (id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}
  -- if ($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*}) = [])

  ;; ../../../../spec-concrete/5.01-env.watsup:206.1-212.60
  clause 3({ rid : V*{V <- V*, rid <- rid*} }, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?((rid', V', id_default*{id_default <- id_default*}))
  -- (if (id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}
  -- let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*})
  -- if (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches [ _/1 ]
  -- let [(rid', V', id_default*{id_default <- id_default*})] = (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*}

;; ../../../../spec-concrete/5.01-env.watsup:218.1-218.50
def $find_non_overloaded<V>(map<rid, V>, id) : V? =

  ;; ../../../../spec-concrete/5.01-env.watsup:221.1-222.60
  clause 0({ rid : V*{V <- V*, rid <- rid*} }, id) = ?(V')
  -- let V''*{V'' <- V''*} = $find_non_overloaded'<V>({ rid : V*{V <- V*, rid <- rid*} }, id)
  -- if V''*{V'' <- V''*} matches [ _/1 ]
  -- let [V'] = V''*{V'' <- V''*}

  ;; ../../../../spec-concrete/5.01-env.watsup:223.1-224.15
  clause 1({ rid : V*{V <- V*, rid <- rid*} }, id) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:219.1-219.51
def $find_non_overloaded'<V>(map<rid, V>, id) : V* =

  ;; ../../../../spec-concrete/5.01-env.watsup:226.1-226.49
  clause 0(set<pair<rid, V>>, id) = []
  -- if (set<pair<rid, V>> = { [] })

  ;; ../../../../spec-concrete/5.01-env.watsup:227.1-233.59
  clause 1({ pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} }, id) = V_h :: V_t_found*{V_t_found <- V_t_found*}
  -- if pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches _ :: _
  -- let rid_h : V_h :: rid_t : V_t*{V_t <- V_t*, rid_t <- rid_t*} = pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}
  -- let id' ( _pid*{_pid <- _pid*} ) = rid_h
  -- if (id' = id)
  -- let V_t_found*{V_t_found <- V_t_found*} = $find_non_overloaded'<V>({ rid_t : V_t*{V_t <- V_t*, rid_t <- rid_t*} }, id)

  ;; ../../../../spec-concrete/5.01-env.watsup:234.1-241.59
  clause 2({ pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} }, id) = V_t_found*{V_t_found <- V_t_found*}
  -- if pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches _ :: _
  -- let rid_h : V_h :: rid_t : V_t*{V_t <- V_t*, rid_t <- rid_t*} = pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}
  -- let id_h ( _pid*{_pid <- _pid*} ) = rid_h
  -- if (id =/= id_h)
  -- let V_t_found*{V_t_found <- V_t_found*} = $find_non_overloaded'<V>({ rid_t : V_t*{V_t <- V_t*, rid_t <- rid_t*} }, id)

;; ../../../../spec-concrete/5.02-context.watsup:5.17-5.39
syntax cursor = 
   | global
   | block
   | local

;; ../../../../spec-concrete/5.02-context.watsup:16.3-19.18
syntax globalTypingLayer = {cdenv cdenv, tdenv tdenv, rdenv rdenv, frame frame}

;; ../../../../spec-concrete/5.02-context.watsup:24.1-28.12
syntax blockKind = 
   | 
   | extern
   | parser
   | control
   | package

;; ../../../../spec-concrete/5.02-context.watsup:30.1-30.43
def $is_extern_blockKind(blockKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:31.1-31.57
  clause 0(blockKind) = (blockKind = extern)

;; ../../../../spec-concrete/5.02-context.watsup:33.1-33.43
def $is_parser_blockKind(blockKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:34.1-34.57
  clause 0(blockKind) = (blockKind = parser)

;; ../../../../spec-concrete/5.02-context.watsup:36.1-36.44
def $is_control_blockKind(blockKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:37.1-37.59
  clause 0(blockKind) = (blockKind = control)

;; ../../../../spec-concrete/5.02-context.watsup:39.1-39.44
def $is_package_blockKind(blockKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:40.1-40.59
  clause 0(blockKind) = (blockKind = package)

;; ../../../../spec-concrete/5.02-context.watsup:43.3-47.18
syntax blockTypingLayer = {id id, kind blockKind, tdenv tdenv, rdenv rdenv, frame frame}

;; ../../../../spec-concrete/5.02-context.watsup:52.1-60.23
syntax localKind = 
   | 
   | function-> typeIR
   | extern_function-> typeIR
   | action
   | extern_method-> typeIR
   | extern_methodabstract-> typeIR
   | parser_state
   | control_apply_method
   | table_apply_method

;; ../../../../spec-concrete/5.02-context.watsup:62.1-62.45
def $is_function_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:63.1-63.50
  clause 0(localKind) = true
  -- if localKind matches `FUNCTION->%`
  -- let function-> _typeIR = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:64.1-65.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:67.1-67.52
def $is_extern_function_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:68.1-70.11
  clause 0(localKind) = true
  -- if localKind matches `EXTERN_FUNCTION->%`
  -- let extern_function-> _typeIR = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:71.1-72.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:74.1-74.43
def $is_action_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:75.1-75.40
  clause 0(localKind) = true
  -- if localKind matches `ACTION`

  ;; ../../../../spec-concrete/5.02-context.watsup:76.1-77.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:79.1-79.50
def $is_extern_method_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:80.1-82.11
  clause 0(localKind) = true
  -- if localKind matches `EXTERN_METHOD->%`
  -- let extern_method-> _typeIR = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:83.1-84.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:86.1-86.59
def $is_extern_abstract_method_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:87.1-89.11
  clause 0(localKind) = true
  -- if localKind matches `EXTERN_METHODABSTRACT->%`
  -- let extern_methodabstract-> _typeIR = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:90.1-91.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:93.1-93.49
def $is_parser_state_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:94.1-94.52
  clause 0(localKind) = true
  -- if localKind matches `PARSER_STATE`

  ;; ../../../../spec-concrete/5.02-context.watsup:95.1-96.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:98.1-98.57
def $is_control_apply_method_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:99.1-101.11
  clause 0(localKind) = true
  -- if localKind matches `CONTROL_APPLY_METHOD`

  ;; ../../../../spec-concrete/5.02-context.watsup:102.1-103.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:105.1-105.55
def $is_table_apply_method_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:106.1-108.11
  clause 0(localKind) = true
  -- if localKind matches `TABLE_APPLY_METHOD`

  ;; ../../../../spec-concrete/5.02-context.watsup:109.1-110.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:113.3-116.20
syntax localTypingLayer = {id id, kind localKind, tdenv tdenv, frames frame*}

;; ../../../../spec-concrete/5.02-context.watsup:123.3-125.29
syntax typingContext = {global globalTypingLayer, block blockTypingLayer, local localTypingLayer}

;; ../../../../spec-concrete/5.02-context.watsup:133.1-133.41
def $empty_typingContext : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:135.1-155.35
  clause 0 = TC
  -- let globalTypingLayer = {cdenv $empty_cdenv, tdenv $empty_tdenv, rdenv $empty_rdenv, frame $empty_frame}
  -- let blockTypingLayer = {id "", kind , tdenv $empty_tdenv, rdenv $empty_rdenv, frame $empty_frame}
  -- let localTypingLayer = {id "", kind , tdenv $empty_tdenv, frames [$empty_frame]}
  -- let TC = {global globalTypingLayer, block blockTypingLayer, local localTypingLayer}

;; ../../../../spec-concrete/5.02-context.watsup:161.1-161.42
def $bound(cursor, typingContext) : bound =

  ;; ../../../../spec-concrete/5.02-context.watsup:163.1-163.34
  clause 0(cursor, TC) = { [] }
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.02-context.watsup:164.1-164.65
  clause 1(cursor, TC) = $dom_map<tid, typeDefIR>(TC.block.tdenv)
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.02-context.watsup:165.1-167.63
  clause 2(cursor, TC) = $union_set<tid>(bound_block, bound_local)
  -- if cursor matches `LOCAL`
  -- let bound_block = $bound(block, TC)
  -- let bound_local = $dom_map<tid, typeDefIR>(TC.local.tdenv)

;; ../../../../spec-concrete/5.02-context.watsup:173.1-173.42
def $enter(typingContext) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:175.1-175.72
  clause 0(TC) = TC[local.frames = $empty_frame :: TC.local.frames]

;; ../../../../spec-concrete/5.02-context.watsup:177.1-177.41
def $exit(typingContext) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:179.1-180.46
  clause 0(TC) = TC[local.frames = frame_t*{frame_t <- frame_t*}]
  -- let frame*{frame <- frame*} = TC.local.frames
  -- if frame*{frame <- frame*} matches _ :: _
  -- let frame_h :: frame_t*{frame_t <- frame_t*} = frame*{frame <- frame*}

;; ../../../../spec-concrete/5.02-context.watsup:188.1-188.67
def $add_var(cursor, typingContext, id, varTypeIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:191.1-197.50
  clause 0(cursor, TC, id, varTypeIR) = TC'
  -- if cursor matches `GLOBAL`
  -- let frame = TC.global.frame
  -- if ~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))
  -- let _direction typeIR _ctk _value?{_value <- _value?} = varTypeIR
  -- if ((id = "main") => $is_package_object_typeIR($canon(typeIR)))
  -- let frame_update = $add_map<id, varTypeIR>(frame, id, varTypeIR)
  -- let TC' = TC[global.frame = frame_update]

  ;; ../../../../spec-concrete/5.02-context.watsup:198.1-203.49
  clause 1(cursor, TC, id, varTypeIR) = TC'
  -- if cursor matches `BLOCK`
  -- let frame = TC.block.frame
  -- if ~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))
  -- if (id =/= "main")
  -- let frame_update = $add_map<id, varTypeIR>(TC.block.frame, id, varTypeIR)
  -- let TC' = TC[block.frame = frame_update]

  ;; ../../../../spec-concrete/5.02-context.watsup:204.1-210.44
  clause 2(cursor, TC, id, varTypeIR) = TC'
  -- if cursor matches `LOCAL`
  -- let frame'*{frame' <- frame'*} = TC.local.frames
  -- if frame'*{frame' <- frame'*} matches _ :: _
  -- let frame_h :: frame_t*{frame_t <- frame_t*} = frame'*{frame' <- frame'*}
  -- if ~$in_set<id>(id, $dom_map<id, varTypeIR>(frame_h))
  -- if (id =/= "main")
  -- let frame_h_update = $add_map<id, varTypeIR>(frame_h, id, varTypeIR)
  -- let frame*{frame <- frame*} = frame_h_update :: frame_t*{frame_t <- frame_t*}
  -- let TC' = TC[local.frames = frame*{frame <- frame*}]

;; ../../../../spec-concrete/5.02-context.watsup:189.1-189.70
def $add_vars(cursor, typingContext, id*, varTypeIR*) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:212.1-212.36
  clause 0(p, TC, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*}) = TC
  -- if id*{id <- id*} matches []
  -- if varTypeIR*{varTypeIR <- varTypeIR*} matches []

  ;; ../../../../spec-concrete/5.02-context.watsup:213.1-215.54
  clause 1(p, TC, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*}) = TC''
  -- if id*{id <- id*} matches _ :: _
  -- let id_h :: id_t*{id_t <- id_t*} = id*{id <- id*}
  -- if varTypeIR*{varTypeIR <- varTypeIR*} matches _ :: _
  -- let varTypeIR_h :: varTypeIR_t*{varTypeIR_t <- varTypeIR_t*} = varTypeIR*{varTypeIR <- varTypeIR*}
  -- let TC' = $add_var(p, TC, id_h, varTypeIR_h)
  -- let TC'' = $add_vars(p, TC', id_t*{id_t <- id_t*}, varTypeIR_t*{varTypeIR_t <- varTypeIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:219.1-219.75
def $add_parameter(cursor, typingContext, parameterTypeIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:222.1-224.50
  clause 0(cursor, TC, direction typeIR id value?{value <- value?}) = TC'
  -- if direction matches ``EMPTY`
  -- let varTypeIR = typeIR ctk value?{value <- value?}
  -- let TC' = $add_var(cursor, TC, id, varTypeIR)

  ;; ../../../../spec-concrete/5.02-context.watsup:225.1-228.50
  clause 1(cursor, TC, direction typeIR id value?{value <- value?}) = TC'
  -- if (((direction = in) \/ (direction = out)) \/ (direction = inout))
  -- let varTypeIR = direction typeIR dyn value?{value <- value?}
  -- let TC' = $add_var(cursor, TC, id, varTypeIR)

;; ../../../../spec-concrete/5.02-context.watsup:220.1-220.77
def $add_parameters(cursor, typingContext, parameterTypeIR*) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:230.1-230.42
  clause 0(cursor, TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

  ;; ../../../../spec-concrete/5.02-context.watsup:231.1-233.64
  clause 1(cursor, TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC''
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
  -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
  -- let TC' = $add_parameter(cursor, TC, parameterTypeIR_h)
  -- let TC'' = $add_parameters(cursor, TC', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:237.1-237.78
def $add_constructorParameter(typingContext, parameterTypeIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:240.1-242.49
  clause 0(TC, direction typeIR id value?{value <- value?}) = TC'
  -- if value?{value <- value?} matches ()
  -- let varTypeIR = direction typeIR ctk ?()
  -- let TC' = $add_var(block, TC, id, varTypeIR)

  ;; ../../../../spec-concrete/5.02-context.watsup:243.1-245.49
  clause 1(TC, direction typeIR id value'?{value' <- value'?}) = TC'
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}
  -- let varTypeIR = direction typeIR ctk ?(value)
  -- let TC' = $add_var(block, TC, id, varTypeIR)

;; ../../../../spec-concrete/5.02-context.watsup:238.1-238.80
def $add_constructorParameters(typingContext, parameterTypeIR*) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:247.1-247.45
  clause 0(TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

  ;; ../../../../spec-concrete/5.02-context.watsup:248.1-250.67
  clause 1(TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC''
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
  -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
  -- let TC' = $add_constructorParameter(TC, parameterTypeIR_h)
  -- let TC'' = $add_constructorParameters(TC', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:254.1-254.69
def $add_type(cursor, typingContext, tid, typeDefIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:255.1-260.50
  clause 0(cursor, TC, tid, typeDefIR) = TC'
  -- if cursor matches `GLOBAL`
  -- let tdenv = TC.global.tdenv
  -- if ~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))
  -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
  -- let TC' = TC[global.tdenv = tdenv_update]

  ;; ../../../../spec-concrete/5.02-context.watsup:261.1-266.49
  clause 1(cursor, TC, tid, typeDefIR) = TC'
  -- if cursor matches `BLOCK`
  -- let tdenv = TC.block.tdenv
  -- if ~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))
  -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
  -- let TC' = TC[block.tdenv = tdenv_update]

  ;; ../../../../spec-concrete/5.02-context.watsup:267.1-272.49
  clause 2(cursor, TC, tid, typeDefIR) = TC'
  -- if cursor matches `LOCAL`
  -- let tdenv = TC.local.tdenv
  -- if ~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))
  -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
  -- let TC' = TC[local.tdenv = tdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:274.1-274.72
def $add_types(cursor, typingContext, tid*, typeDefIR*) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:275.1-275.37
  clause 0(p, TC, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*}) = TC
  -- if tid*{tid <- tid*} matches []
  -- if typeDefIR*{typeDefIR <- typeDefIR*} matches []

  ;; ../../../../spec-concrete/5.02-context.watsup:276.1-278.56
  clause 1(p, TC, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*}) = TC''
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- if typeDefIR*{typeDefIR <- typeDefIR*} matches _ :: _
  -- let typeDefIR_h :: typeDefIR_t*{typeDefIR_t <- typeDefIR_t*} = typeDefIR*{typeDefIR <- typeDefIR*}
  -- let TC' = $add_type(p, TC, tid_h, typeDefIR_h)
  -- let TC'' = $add_types(p, TC', tid_t*{tid_t <- tid_t*}, typeDefIR_t*{typeDefIR_t <- typeDefIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:282.1-282.88
def $add_routine_overload(cursor, typingContext, rid, routineTypeDefIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:284.1-289.50
  clause 0(cursor, TC, rid, routineTypeDefIR) = TC'
  -- if cursor matches `GLOBAL`
  -- let rdenv = TC.global.rdenv
  -- if ~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))
  -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
  -- let TC' = TC[global.rdenv = rdenv_update]

  ;; ../../../../spec-concrete/5.02-context.watsup:290.1-295.49
  clause 1(cursor, TC, rid, routineTypeDefIR) = TC'
  -- if cursor matches `BLOCK`
  -- let rdenv = TC.block.rdenv
  -- if ~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))
  -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
  -- let TC' = TC[block.rdenv = rdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:297.1-297.92
def $add_routine_non_overload(cursor, typingContext, rid, routineTypeDefIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:299.1-306.50
  clause 0(cursor, TC, rid, routineTypeDefIR) = TC'
  -- if cursor matches `GLOBAL`
  -- let rdenv = TC.global.rdenv
  -- let id ( _pid*{_pid <- _pid*} ) = rid
  -- let { id_k ( _pid'*{_pid' <- _pid'*} )*{_pid'* <- _pid'**, id_k <- id_k*} } = $dom_map<rid, routineTypeDefIR>(rdenv)
  -- if ~$in_set<id>(id, { id_k*{id_k <- id_k*} })
  -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
  -- let TC' = TC[global.rdenv = rdenv_update]

  ;; ../../../../spec-concrete/5.02-context.watsup:307.1-314.49
  clause 1(cursor, TC, rid, routineTypeDefIR) = TC'
  -- if cursor matches `BLOCK`
  -- let rdenv = TC.block.rdenv
  -- let id ( _pid*{_pid <- _pid*} ) = rid
  -- let { id_k ( _pid'*{_pid' <- _pid'*} )*{_pid'* <- _pid'**, id_k <- id_k*} } = $dom_map<rid, routineTypeDefIR>(rdenv)
  -- if ~$in_set<id>(id, { id_k*{id_k <- id_k*} })
  -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
  -- let TC' = TC[block.rdenv = rdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:318.1-318.79
def $add_constructor(typingContext, cid, constructorTypeDefIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:320.1-325.50
  clause 0(TC, cid, constructorTypeDefIR) = TC'
  -- let cdenv = TC.global.cdenv
  -- if ~$in_set<cid>(cid, $dom_map<cid, constructorTypeDefIR>(cdenv))
  -- let cdenv_update = $add_map<cid, constructorTypeDefIR>(cdenv, cid, constructorTypeDefIR)
  -- let TC' = TC[global.cdenv = cdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:333.1-333.66
def $find_var(cursor, typingContext, prefixedNameIR) : varTypeIR? =

  ;; ../../../../spec-concrete/5.02-context.watsup:335.1-336.32
  clause 0(p, TC, prefixedNameIR) = $find_map<id, varTypeIR>(frame, id)
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR
  -- let frame = TC.global.frame

  ;; ../../../../spec-concrete/5.02-context.watsup:337.1-338.32
  clause 1(cursor, TC, prefixedNameIR) = $find_map<id, varTypeIR>(frame, id)
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame = TC.global.frame

  ;; ../../../../spec-concrete/5.02-context.watsup:339.1-341.56
  clause 2(cursor, TC, prefixedNameIR) = ?(varTypeIR)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame = TC.block.frame
  -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_map<id, varTypeIR>(frame, id)
  -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
  -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:342.1-344.50
  clause 3(cursor, TC, prefixedNameIR) = $find_var(global, TC, ` id)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame = TC.block.frame
  -- if (?() = $find_map<id, varTypeIR>(frame, id))

  ;; ../../../../spec-concrete/5.02-context.watsup:345.1-347.58
  clause 4(cursor, TC, prefixedNameIR) = ?(varTypeIR)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame*{frame <- frame*} = TC.local.frames
  -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id)
  -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
  -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:348.1-350.52
  clause 5(cursor, TC, prefixedNameIR) = $find_var(block, TC, ` id)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame*{frame <- frame*} = TC.local.frames
  -- if (?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

;; ../../../../spec-concrete/5.02-context.watsup:354.1-354.63
def $find_value(cursor, typingContext, prefixedNameIR) : value =

  ;; ../../../../spec-concrete/5.02-context.watsup:356.1-358.58
  clause 0(p, TC, prefixedNameIR) = value
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR
  -- let frame = TC.global.frame
  -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
  -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
  -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:359.1-361.58
  clause 1(cursor, TC, prefixedNameIR) = value
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame = TC.global.frame
  -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
  -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
  -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:362.1-364.58
  clause 2(cursor, TC, prefixedNameIR) = value
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame = TC.block.frame
  -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
  -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
  -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:365.1-367.50
  clause 3(cursor, TC, prefixedNameIR) = $find_value(global, TC, ` id)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame = TC.block.frame
  -- if (?() = $find_map<id, varTypeIR>(frame, id))

  ;; ../../../../spec-concrete/5.02-context.watsup:368.1-370.60
  clause 4(cursor, TC, prefixedNameIR) = value
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame*{frame <- frame*} = TC.local.frames
  -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id)
  -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
  -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:371.1-373.52
  clause 5(cursor, TC, prefixedNameIR) = $find_value(block, TC, ` id)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame*{frame <- frame*} = TC.local.frames
  -- if (?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

;; ../../../../spec-concrete/5.02-context.watsup:377.1-377.67
def $find_type(cursor, typingContext, prefixedNameIR) : typeDefIR? =

  ;; ../../../../spec-concrete/5.02-context.watsup:379.1-381.32
  clause 0(p, TC, prefixedNameIR) = $find_map<tid, typeDefIR>(tdenv, tid)
  -- if prefixedNameIR matches `.%`
  -- let . tid = prefixedNameIR
  -- let tdenv = TC.global.tdenv

  ;; ../../../../spec-concrete/5.02-context.watsup:382.1-384.32
  clause 1(cursor, TC, prefixedNameIR) = $find_map<tid, typeDefIR>(tdenv, tid)
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches ``%`
  -- let ` tid = prefixedNameIR
  -- let tdenv = TC.global.tdenv

  ;; ../../../../spec-concrete/5.02-context.watsup:385.1-387.58
  clause 2(cursor, TC, prefixedNameIR) = ?(typeDefIR)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` tid = prefixedNameIR
  -- let tdenv = TC.block.tdenv
  -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_map<tid, typeDefIR>(tdenv, tid)
  -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
  -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:388.1-390.52
  clause 3(cursor, TC, prefixedNameIR) = $find_type(global, TC, ` tid)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` tid = prefixedNameIR
  -- let tdenv = TC.block.tdenv
  -- if (?() = $find_map<tid, typeDefIR>(tdenv, tid))

  ;; ../../../../spec-concrete/5.02-context.watsup:391.1-393.60
  clause 4(cursor, TC, prefixedNameIR) = ?(typeDefIR)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` tid = prefixedNameIR
  -- let tdenv*{tdenv <- tdenv*} = [TC.local.tdenv]
  -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid)
  -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
  -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:394.1-396.54
  clause 5(cursor, TC, prefixedNameIR) = $find_type(block, TC, ` tid)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` tid = prefixedNameIR
  -- let tdenv*{tdenv <- tdenv*} = [TC.local.tdenv]
  -- if (?() = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid))

;; ../../../../spec-concrete/5.02-context.watsup:400.1-400.41
def $ids_arguments(argumentIR*) : id?* =

  ;; ../../../../spec-concrete/5.02-context.watsup:403.1-403.62
  clause 0(argumentIR*{argumentIR <- argumentIR*}) = $id_argument(argumentIR)*{argumentIR <- argumentIR*}

;; ../../../../spec-concrete/5.02-context.watsup:401.1-401.35
def $id_argument(argumentIR) : id? =

  ;; ../../../../spec-concrete/5.02-context.watsup:404.1-404.42
  clause 0(argumentIR) = ?()
  -- if argumentIR <: typedExpressionIR
  -- let typedExpressionIR = argumentIR as typedExpressionIR

  ;; ../../../../spec-concrete/5.02-context.watsup:405.1-405.39
  clause 1(argumentIR) = ?(nameIR)
  -- if argumentIR matches `%=%`
  -- let nameIR = _typedExpressionIR = argumentIR

  ;; ../../../../spec-concrete/5.02-context.watsup:406.1-406.40
  clause 2(argumentIR) = ?(nameIR)
  -- if argumentIR matches `%=_`
  -- let nameIR =_ = argumentIR

  ;; ../../../../spec-concrete/5.02-context.watsup:407.1-407.27
  clause 3(argumentIR) = ?()
  -- if argumentIR matches `_`

;; ../../../../spec-concrete/5.02-context.watsup:409.1-410.34
def $find_routine_overloaded(cursor, typingContext, prefixedNameIR, argumentIR*) : (rid, routineTypeDefIR, id*)? =

  ;; ../../../../spec-concrete/5.02-context.watsup:412.1-415.49
  clause 0(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR
  -- let rdenv = TC.global.rdenv
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

  ;; ../../../../spec-concrete/5.02-context.watsup:416.1-419.49
  clause 1(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let rdenv = TC.global.rdenv
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

  ;; ../../../../spec-concrete/5.02-context.watsup:420.1-425.66
  clause 2(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*}))
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let rdenv = TC.block.rdenv
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
  -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
  -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}

  ;; ../../../../spec-concrete/5.02-context.watsup:426.1-431.66
  clause 3(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_routine_overloaded(global, TC, ` id, argumentIR*{argumentIR <- argumentIR*})
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let rdenv = TC.block.rdenv
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
  -- if (?() = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}))

  ;; ../../../../spec-concrete/5.02-context.watsup:432.1-433.60
  clause 4(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_routine_overloaded(block, TC, ` id, argumentIR*{argumentIR <- argumentIR*})
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR

;; ../../../../spec-concrete/5.02-context.watsup:435.1-436.22
def $find_routine_non_overloaded(cursor, typingContext, prefixedNameIR) : routineTypeDefIR? =

  ;; ../../../../spec-concrete/5.02-context.watsup:438.1-439.64
  clause 0(p, TC, prefixedNameIR) = $find_non_overloaded<routineTypeDefIR>(TC.global.rdenv, id)
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR

  ;; ../../../../spec-concrete/5.02-context.watsup:440.1-441.64
  clause 1(cursor, TC, prefixedNameIR) = $find_non_overloaded<routineTypeDefIR>(TC.global.rdenv, id)
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR

  ;; ../../../../spec-concrete/5.02-context.watsup:442.1-444.67
  clause 2(cursor, TC, prefixedNameIR) = ?(routineTypeDefIR)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_non_overloaded<routineTypeDefIR>(TC.block.rdenv, id)
  -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
  -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:445.1-448.67
  clause 3(cursor, TC, prefixedNameIR) = $find_routine_non_overloaded(global, TC, ` id)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- if (?() = $find_non_overloaded<routineTypeDefIR>(TC.block.rdenv, id))

  ;; ../../../../spec-concrete/5.02-context.watsup:449.1-450.51
  clause 4(cursor, TC, prefixedNameIR) = $find_routine_non_overloaded(block, TC, ` id)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR

;; ../../../../spec-concrete/5.02-context.watsup:454.1-455.38
def $find_constructor_overloaded(typingContext, prefixedNameIR, argumentIR*) : (rid, constructorTypeDefIR, id*)? =

  ;; ../../../../spec-concrete/5.02-context.watsup:457.1-460.49
  clause 0(TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR
  -- let cdenv = TC.global.cdenv
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

  ;; ../../../../spec-concrete/5.02-context.watsup:461.1-464.49
  clause 1(TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let cdenv = TC.global.cdenv
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

;; ../../../../spec-concrete/5.02-context.watsup:468.1-468.47
def $find_return_type(typingContext) : typeIR? =

  ;; ../../../../spec-concrete/5.02-context.watsup:470.1-471.48
  clause 0(TC) = ?(typeIR_ret)
  -- let localKind = TC.local.kind
  -- if localKind matches `FUNCTION->%`
  -- let function-> typeIR_ret = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:472.1-473.55
  clause 1(TC) = ?(typeIR_ret)
  -- let localKind = TC.local.kind
  -- if localKind matches `EXTERN_FUNCTION->%`
  -- let extern_function-> typeIR_ret = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:474.1-475.31
  clause 2(TC) = ?(void as typeIR)
  -- if (action = TC.local.kind)

  ;; ../../../../spec-concrete/5.02-context.watsup:476.1-477.53
  clause 3(TC) = ?(typeIR_ret)
  -- let localKind = TC.local.kind
  -- if localKind matches `EXTERN_METHOD->%`
  -- let extern_method-> typeIR_ret = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:478.1-480.22
  clause 4(TC) = ?(typeIR_ret)
  -- let localKind = TC.local.kind
  -- if localKind matches `EXTERN_METHODABSTRACT->%`
  -- let extern_methodabstract-> typeIR_ret = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:481.1-482.45
  clause 5(TC) = ?(void as typeIR)
  -- if (control_apply_method = TC.local.kind)

  ;; ../../../../spec-concrete/5.02-context.watsup:483.1-484.15
  clause 6(TC) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.03-table-context.watsup:5.19-5.31
syntax matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.03-table-context.watsup:7.22-7.72
syntax matchAction = (prefixedNameIR, parameterTypeIR*, argumentListIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:10.3-13.24
syntax matchPriority = {values nat*, init bool, delta nat, largest_wins bool}

;; ../../../../spec-concrete/5.03-table-context.watsup:16.3-17.17
syntax matchEntry = {size nat, const bool}

;; ../../../../spec-concrete/5.03-table-context.watsup:21.1-27.11
syntax matchMode = 
   | nopri
   | noprilpm nat
   | pri
   | prilpm

;; ../../../../spec-concrete/5.03-table-context.watsup:30.3-34.21
syntax tableContext = {keys matchKey*, actions matchAction*, priorities matchPriority, entries matchEntry, mode matchMode}

;; ../../../../spec-concrete/5.03-table-context.watsup:44.1-46.10
syntax tableEntryState = 
   | lpm nat
   | nolpm

;; ../../../../spec-concrete/5.03-table-context.watsup:54.1-54.38
def $empty_tableContext : tableContext =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:55.1-68.25
  clause 0 = {keys [], actions [], priorities matchPriority, entries matchEntry, mode nopri}
  -- let matchPriority = {values [], init false, delta 1, largest_wins true}
  -- let matchEntry = {size 0, const true}

;; ../../../../spec-concrete/5.03-table-context.watsup:76.1-76.54
def $add_key(tableContext, id, typeIR) : tableContext =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:78.1-80.32
  clause 0(TBLC, id, typeIR) = TBLC[keys = TBLC.keys ++ [matchKey]]
  -- let matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.03-table-context.watsup:84.1-84.95
def $add_action(tableContext, prefixedNameIR, parameterTypeIR*, argumentListIR) : tableContext =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:86.1-88.73
  clause 0(TBLC, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR) = TBLC[actions = TBLC.actions ++ [matchAction]]
  -- let matchAction = (prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:92.1-92.58
def $add_table_priority(tableContext, nat) : tableContext =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:94.1-95.65
  clause 0(TBLC, n) = TBLC[priorities.values = TBLC.priorities.values ++ [n]]

;; ../../../../spec-concrete/5.03-table-context.watsup:103.1-103.58
def $update_mode(tableContext, id, typeIR) : tableContext =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:106.1-106.77
  clause 0(TBLC, id, typeIR) = $update_mode'(TBLC, id, $canon(typeIR))

;; ../../../../spec-concrete/5.03-table-context.watsup:104.1-104.59
def $update_mode'(tableContext, id, typeIR) : tableContext =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:107.1-108.26
  clause 0(TBLC, text, typeIR) = TBLC[mode = noprilpm n]
  -- if (text = "lpm")
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< n > = numberTypeIR
  -- if (TBLC.mode = nopri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:109.1-110.26
  clause 1(TBLC, text, typeIR) = TBLC[mode = noprilpm n]
  -- if (text = "lpm")
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< n > = numberTypeIR
  -- if (TBLC.mode = nopri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:111.1-112.26
  clause 2(TBLC, text, typeIR) = TBLC[mode = noprilpm n]
  -- if (text = "lpm")
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< n > = numberTypeIR
  -- if (TBLC.mode = nopri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:113.1-114.38
  clause 3(TBLC, text, typeIR') = $update_mode(TBLC, "lpm", typeIR)
  -- if (text = "lpm")
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-table-context.watsup:115.1-116.24
  clause 4(TBLC, text, _typeIR) = TBLC[mode = prilpm]
  -- if (text = "lpm")
  -- if (TBLC.mode = pri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:117.1-118.26
  clause 5(TBLC, text, _typeIR) = TBLC[mode = pri]
  -- if (text = "range")
  -- if (TBLC.mode = nopri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:119.1-120.26
  clause 6(TBLC, text, _typeIR) = TBLC[mode = pri]
  -- if (text = "ternary")
  -- if (TBLC.mode = nopri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:121.1-122.26
  clause 7(TBLC, text, _typeIR) = TBLC[mode = pri]
  -- if (text = "optional")
  -- if (TBLC.mode = nopri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:123.1-124.31
  clause 8(TBLC, text, _typeIR) = TBLC[mode = prilpm]
  -- if (text = "range")
  -- let matchMode = TBLC.mode
  -- if matchMode matches `NOPRILPM%`
  -- let noprilpm _nat = matchMode

  ;; ../../../../spec-concrete/5.03-table-context.watsup:125.1-126.31
  clause 9(TBLC, text, _typeIR) = TBLC[mode = prilpm]
  -- if (text = "ternary")
  -- let matchMode = TBLC.mode
  -- if matchMode matches `NOPRILPM%`
  -- let noprilpm _nat = matchMode

  ;; ../../../../spec-concrete/5.03-table-context.watsup:127.1-128.31
  clause 10(TBLC, text, _typeIR) = TBLC[mode = prilpm]
  -- if (text = "optional")
  -- let matchMode = TBLC.mode
  -- if matchMode matches `NOPRILPM%`
  -- let noprilpm _nat = matchMode

  ;; ../../../../spec-concrete/5.03-table-context.watsup:129.1-130.15
  clause 11(TBLC, _id, _typeIR) = TBLC
  -- otherwise

;; ../../../../spec-concrete/5.03-table-context.watsup:138.1-138.85
def $find_action(tableContext, prefixedNameIR) : (parameterTypeIR*, argumentListIR)? =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:141.1-141.85
  clause 0(TBLC, prefixedNameIR) = $find_action'(TBLC.actions, prefixedNameIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:139.1-139.86
def $find_action'(matchAction*, prefixedNameIR) : (parameterTypeIR*, argumentListIR)? =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:143.1-143.45
  clause 0(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = ?()
  -- if matchAction*{matchAction <- matchAction*} matches []

  ;; ../../../../spec-concrete/5.03-table-context.watsup:145.1-147.75
  clause 1(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = ?((parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR))
  -- if matchAction*{matchAction <- matchAction*} matches _ :: _
  -- let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} = matchAction*{matchAction <- matchAction*}
  -- let (prefixedNameIR', parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR) = matchAction_h
  -- if (prefixedNameIR' = prefixedNameIR)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:149.1-152.44
  clause 2(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = $find_action'(matchAction_t*{matchAction_t <- matchAction_t*}, prefixedNameIR)
  -- if matchAction*{matchAction <- matchAction*} matches _ :: _
  -- let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} = matchAction*{matchAction <- matchAction*}
  -- let (prefixedNameIR_h, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentListIR) = matchAction_h
  -- if (prefixedNameIR_h =/= prefixedNameIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:156.1-156.50
def $find_table_priority_last(tableContext) : nat =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:158.1-159.36
  clause 0(TBLC) = n*{n <- n*}[(|n*{n <- n*}| - 1)]
  -- let n*{n <- n*} = TBLC.priorities.values

;; ../../../../spec-concrete/5.03-table-context.watsup:165.1-165.78
def $join_tableEntryState(tableEntryState, tableEntryState) : tableEntryState =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:167.1-167.48
  clause 0(tableEntryState, tableEntryState') = lpm n
  -- if tableEntryState matches `NOLPM`
  -- if tableEntryState' matches `LPM%`
  -- let lpm n = tableEntryState'

  ;; ../../../../spec-concrete/5.03-table-context.watsup:168.1-168.48
  clause 1(tableEntryState, tableEntryState') = lpm n
  -- if tableEntryState matches `LPM%`
  -- let lpm n = tableEntryState
  -- if tableEntryState' matches `NOLPM`

  ;; ../../../../spec-concrete/5.03-table-context.watsup:169.1-169.48
  clause 2(tableEntryState, tableEntryState') = nolpm
  -- if tableEntryState matches `NOLPM`
  -- if tableEntryState' matches `NOLPM`

;; ../../../../spec-concrete/5.03-table-context.watsup:171.1-171.40
def $tableEntry_lpm_prefix(value) : nat =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:174.1-174.70
  clause 0(value) = $tableEntry_lpm_prefix'(value, 0)

;; ../../../../spec-concrete/5.03-table-context.watsup:172.1-172.46
def $tableEntry_lpm_prefix'(value, nat) : nat =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:175.1-175.56
  clause 0(value, n_prefix) = n_prefix
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let nat w _int = numberLiteral
  -- if (nat = 0)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:176.1-180.43
  clause 1(value, n_prefix) = $tableEntry_lpm_prefix'(value', (n_prefix + 1))
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w int = numberLiteral
  -- if int <: nat
  -- let n = int as nat
  -- if (w > 0)
  -- if ((n \ 2) =/= 0)
  -- let value' = (w - 1) w ((n - 1) / 2) as int as value

  ;; ../../../../spec-concrete/5.03-table-context.watsup:181.1-185.37
  clause 2(value, nat) = $tableEntry_lpm_prefix'(value', 0)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w int = numberLiteral
  -- if int <: nat
  -- let n = int as nat
  -- if (nat = 0)
  -- if (w > 0)
  -- if ((n \ 2) = 0)
  -- let value' = (w - 1) w (n / 2) as int as value

;; ../../../../spec-concrete/5.03-wellformed.watsup:5.1-7.20
relation Type_wf: bound |- typeIR
  ;; ../../../../spec-concrete/5.03-wellformed.watsup:82.1-83.22
  rulegroup basetype
   match
    (expl-input) bound | baseTypeIR as typeIR
    (impl-input) bound | typeIR
    (impl-input-premises)
    -- if typeIR <: baseTypeIR
    -- let baseTypeIR = typeIR as baseTypeIR
   paths
  {
    rulepath basetype
    (premises)
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:87.1-89.33
  rulegroup tid
   match
    (expl-input) bound | tid tid as typeIR
    (impl-input) bound | typeIR
    (impl-input-premises)
    -- if typeIR <: namedTypeIR
    -- let namedTypeIR = typeIR as namedTypeIR
    -- if namedTypeIR matches `TID%`
    -- let tid tid = namedTypeIR
   paths
  {
    rulepath tid
    (premises)
    -- if $in_set<tid>(tid, bound)
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:91.1-94.30
  rulegroup spectype
   match
    (expl-input) bound | polyTypeDefIR < typeIR_arg*{} > as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: namedTypeIR
    -- let namedTypeIR = typeIR' as namedTypeIR
    -- if namedTypeIR matches `%<%>`
    -- let polyTypeDefIR < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR
   paths
  {
    rulepath spectype
    (premises)
    -- let typeIR = $specialize_typeDef(polyTypeDefIR as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
    -- if Type_wf: bound |- typeIR holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:112.1-115.30
  rulegroup typedeftype
   match
    (expl-input) bound | typedef _tid typeIR as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: aliasTypeIR
    -- let aliasTypeIR = typeIR' as aliasTypeIR
    -- if aliasTypeIR matches `TYPEDEF%%`
    -- let typedef _tid typeIR = aliasTypeIR
   paths
  {
    rulepath typedeftype
    (premises)
    -- if $nestable_typedef(typeIR)
    -- if Type_wf: bound |- typeIR holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:129.1-132.30
  rulegroup newtype
   match
    (expl-input) bound | type _tid typeIR as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: aliasTypeIR
    -- let aliasTypeIR = typeIR' as aliasTypeIR
    -- if aliasTypeIR matches `TYPE%%`
    -- let type _tid typeIR = aliasTypeIR
   paths
  {
    rulepath newtype
    (premises)
    -- if $nestable_new(typeIR)
    -- if Type_wf: bound |- typeIR holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:151.1-154.30
  rulegroup listttype
   match
    (expl-input) bound | list< typeIR > as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: listTypeIR
    -- let list< typeIR > = typeIR' as listTypeIR
   paths
  {
    rulepath listttype
    (premises)
    -- if $nestable_list(typeIR)
    -- if Type_wf: bound |- typeIR holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:177.1-180.33
  rulegroup tupletype
   match
    (expl-input) bound | tuple< typeIR*{} > as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: tupleTypeIR
    -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
   paths
  {
    rulepath tupletype
    (premises)
    -- (if $nestable_tuple(typeIR))*{typeIR <- typeIR*}
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:192.1-195.30
  rulegroup stacktype
   match
    (expl-input) bound | typeIR [ _nat ] as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR
   paths
  {
    rulepath stacktype
    (premises)
    -- if $nestable_stack(typeIR)
    -- if Type_wf: bound |- typeIR holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:218.1-222.33
  rulegroup structtype
   match
    (expl-input) bound | struct _tid { typeIR id ;*{} } as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR id ;*{id <- id*, typeIR <- typeIR*} } = typeIR' as structTypeIR
   paths
  {
    rulepath structtype
    (premises)
    -- if $distinct_<id>(id*{id <- id*})
    -- (if $nestable_struct(typeIR))*{typeIR <- typeIR*}
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:255.1-259.33
  rulegroup headertype
   match
    (expl-input) bound | header _tid { typeIR id ;*{} } as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR id ;*{id <- id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR
   paths
  {
    rulepath headertype
    (premises)
    -- if $distinct_<id>(id*{id <- id*})
    -- (if $nestable_header(typeIR))*{typeIR <- typeIR*}
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:272.1-276.33
  rulegroup headeruniontype
   match
    (expl-input) bound | header_union _tid { typeIR id ;*{} } as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: headerUnionTypeIR
    -- let header_union _tid { typeIR id ;*{id <- id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR
   paths
  {
    rulepath headeruniontype
    (premises)
    -- if $distinct_<id>(id*{id <- id*})
    -- (if $nestable_headerunion(typeIR))*{typeIR <- typeIR*}
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:278.1-280.28
  rulegroup enumtype
   match
    (expl-input) bound | enum _tid { id*{} } as typeIR
    (impl-input) bound | typeIR
    (impl-input-premises)
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%{%}`
    -- let enum _tid { id*{id <- id*} } = enumTypeIR
   paths
  {
    rulepath enumtype
    (premises)
    -- if $distinct_<id>(id*{id <- id*})
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:306.1-310.30
  rulegroup serenumtype
   match
    (expl-input) bound | enum _tid # typeIR { id = _value ;*{} } as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: enumTypeIR
    -- let enumTypeIR = typeIR' as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum _tid # typeIR { id = _value ;*{_value <- _value*, id <- id*} } = enumTypeIR
   paths
  {
    rulepath serenumtype
    (premises)
    -- if $distinct_<id>(id*{id <- id*})
    -- if $nestable_serenum(typeIR)
    -- if Type_wf: bound |- typeIR holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:314.1-316.53
  rulegroup externtype
   match
    (expl-input) bound | extern _tid { _rid : routineTypeDefIR*{} } as typeIR
    (impl-input) bound | typeIR
    (impl-input-premises)
    -- if typeIR <: externObjectTypeIR
    -- let extern _tid { _rid : routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} } = typeIR as externObjectTypeIR
   paths
  {
    rulepath externtype
    (premises)
    -- (if RoutineTypeDef_wf: bound |- routineTypeDefIR holds)*{routineTypeDefIR <- routineTypeDefIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:318.1-320.50
  rulegroup parsertype
   match
    (expl-input) bound | parser( parameterTypeIR*{} ) as typeIR
    (impl-input) bound | typeIR
    (impl-input-premises)
    -- if typeIR <: parserObjectTypeIR
    -- let parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as parserObjectTypeIR
   paths
  {
    rulepath parsertype
    (premises)
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:322.1-324.50
  rulegroup controltype
   match
    (expl-input) bound | control( parameterTypeIR*{} ) as typeIR
    (impl-input) bound | typeIR
    (impl-input-premises)
    -- if typeIR <: controlObjectTypeIR
    -- let control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as controlObjectTypeIR
   paths
  {
    rulepath controltype
    (premises)
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:326.1-328.33
  rulegroup packagetype
   match
    (expl-input) bound | package< typeIR*{} > as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: packageObjectTypeIR
    -- let package< typeIR*{typeIR <- typeIR*} > = typeIR' as packageObjectTypeIR
   paths
  {
    rulepath packagetype
    (premises)
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:330.1-333.30
  rulegroup tabletype
   match
    (expl-input) bound | table _tid # typeIR as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: tableObjectTypeIR
    -- let table _tid # typeIR = typeIR' as tableObjectTypeIR
   paths
  {
    rulepath tabletype
    (premises)
    -- let typeIR'' = $canon(typeIR)
    -- if typeIR'' <: tableTypeIR
    -- let tableTypeIR = typeIR'' as tableTypeIR
    -- if tableTypeIR matches `TABLE_STRUCT%{%}`
    -- let table_struct _tid' { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR
    -- if Type_wf: bound |- typeIR holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:337.1-338.19
  rulegroup defaulttype
   match
    (expl-input) bound | default as typeIR
    (impl-input) bound | typeIR
    (impl-input-premises)
    -- if (typeIR = default as typeIR)
   paths
  {
    rulepath defaulttype
    (premises)
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:340.1-342.33
  rulegroup sequencetype
   match
    (expl-input) bound | seq< typeIR*{} > as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR
   paths
  {
    rulepath sequencetype
    (premises)
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:344.1-346.33
  rulegroup sequencedefaulttype
   match
    (expl-input) bound | seq< typeIR*{} ,...> as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR*{typeIR <- typeIR*} ,...> = sequenceTypeIR
   paths
  {
    rulepath sequencedefaulttype
    (premises)
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:348.1-351.33
  rulegroup recordtype
   match
    (expl-input) bound | record{ typeIR id ;*{} } as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: recordTypeIR
    -- let recordTypeIR = typeIR' as recordTypeIR
    -- if recordTypeIR matches `RECORD{%}`
    -- let record{ typeIR id ;*{id <- id*, typeIR <- typeIR*} } = recordTypeIR
   paths
  {
    rulepath recordtype
    (premises)
    -- if $distinct_<id>(id*{id <- id*})
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:353.1-356.33
  rulegroup recorddefaulttype
   match
    (expl-input) bound | record{ typeIR id ;*{} ,...} as typeIR
    (impl-input) bound | typeIR'
    (impl-input-premises)
    -- if typeIR' <: recordTypeIR
    -- let recordTypeIR = typeIR' as recordTypeIR
    -- if recordTypeIR matches `RECORD{%,...}`
    -- let record{ typeIR id ;*{id <- id*, typeIR <- typeIR*} ,...} = recordTypeIR
   paths
  {
    rulepath recorddefaulttype
    (premises)
    -- if $distinct_<id>(id*{id <- id*})
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:358.1-359.26
  rulegroup invalidtype
   match
    (expl-input) bound | header_invalid as typeIR
    (impl-input) bound | typeIR
    (impl-input-premises)
    -- if (typeIR = header_invalid as typeIR)
   paths
  {
    rulepath invalidtype
    (premises)
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:414.1-417.30
  rulegroup settype
   match
    (expl-input) bound | set< [typeIR] > as typeIR
    (impl-input) bound | typeIR''
    (impl-input-premises)
    -- if typeIR'' <: setTypeIR
    -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
    -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
    -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
   paths
  {
    rulepath settype
    (premises)
    -- if $nestable_set(typeIR)
    -- if Type_wf: bound |- typeIR holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:419.1-421.28
  rulegroup tableenumtype
   match
    (expl-input) bound | table_enum _tid { id*{} } as typeIR
    (impl-input) bound | typeIR
    (impl-input-premises)
    -- if typeIR <: tableTypeIR
    -- let tableTypeIR = typeIR as tableTypeIR
    -- if tableTypeIR matches `TABLE_ENUM%{%}`
    -- let table_enum _tid { id*{id <- id*} } = tableTypeIR
   paths
  {
    rulepath tableenumtype
    (premises)
    -- if $distinct_<id>(id*{id <- id*})
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:423.1-424.33
  rulegroup tablestructtype
   match
    (expl-input) bound | table_struct _tid { _fieldTypeIR*{} } as typeIR
    (impl-input) bound | typeIR
    (impl-input-premises)
    -- if typeIR <: tableTypeIR
    -- let tableTypeIR = typeIR as tableTypeIR
    -- if tableTypeIR matches `TABLE_STRUCT%{%}`
    -- let table_struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR
   paths
  {
    rulepath tablestructtype
    (premises)
    (output) 
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:9.1-11.20
relation TypeDef_wf: bound |- typeDefIR
  ;; ../../../../spec-concrete/5.03-wellformed.watsup:440.1-443.30
  rulegroup mono
   match
    (expl-input) bound | typeIR as typeDefIR
    (impl-input) bound | typeDefIR
    (impl-input-premises)
    -- if typeDefIR <: typeIR
    -- let typeIR = typeDefIR as typeIR
   paths
  {
    rulepath mono
    (premises)
    -- if $definable_type_mono(typeIR)
    -- if Type_wf: bound |- typeIR holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:459.1-465.36
  rulegroup poly
   match
    (expl-input) bound | typeIR < tid_expl*{} , tid_impl*{} > as typeDefIR
    (impl-input) bound | typeDefIR
    (impl-input-premises)
    -- if typeDefIR <: polyTypeDefIR
    -- let typeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > = typeDefIR as polyTypeDefIR
   paths
  {
    rulepath poly
    (premises)
    -- if $definable_type_poly(typeIR)
    -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
    -- let bound_inner = $union_set<tid>(bound, { tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} })
    -- if Type_wf: bound_inner |- typeIR holds
    (output) 
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:13.1-15.20
relation ParameterType_wf: bound |- parameterTypeIR
  ;; ../../../../spec-concrete/5.03-wellformed.watsup:49.1-52.49
  rulegroup default-empty-extern
   match
    (expl-input) bound | typeIR _id ?()
    (impl-input) bound | direction typeIR _id value?{value <- value?}
    (impl-input-premises)
    -- if direction matches ``EMPTY`
    -- if value?{value <- value?} matches ()
   paths
  {
    rulepath default-empty-extern
    (premises)
    -- if Type_wf: bound |- typeIR holds
    -- if $is_extern_object_typeIR($canon(typeIR))
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:54.1-57.50
  rulegroup default-none-not-extern
   match
    (expl-input) bound | direction typeIR _id ?()
    (impl-input) bound | direction typeIR _id value?{value <- value?}
    (impl-input-premises)
    -- if value?{value <- value?} matches ()
   paths
  {
    rulepath default-none-not-extern
    (premises)
    -- if Type_wf: bound |- typeIR holds
    -- if ~$is_extern_object_typeIR($canon(typeIR))
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:59.1-62.49
  rulegroup default-some-extern
   match
    (expl-input) bound | typeIR _id ?(value)
    (impl-input) bound | direction typeIR _id value'?{value' <- value'?}
    (impl-input-premises)
    -- if direction matches ``EMPTY`
    -- if value'?{value' <- value'?} matches (_)
    -- let ?(value) = value'?{value' <- value'?}
   paths
  {
    rulepath default-some-extern
    (premises)
    -- if Type_wf: bound |- typeIR holds
    -- if $is_extern_object_typeIR($canon(typeIR))
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:64.1-68.45
  rulegroup default-some-not-extern
   match
    (expl-input) bound | direction typeIR _id ?(value)
    (impl-input) bound | direction typeIR _id value'?{value' <- value'?}
    (impl-input-premises)
    -- if value'?{value' <- value'?} matches (_)
    -- let ?(value) = value'?{value' <- value'?}
   paths
  {
    rulepath default-some-not-extern
    (premises)
    -- if Type_wf: bound |- typeIR holds
    -- if ~$is_extern_object_typeIR($canon(typeIR))
    -- if ((direction = in) \/ (direction = ))
    (output) 
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:17.1-19.20
relation ParameterTypes_wf: bound |- parameterTypeIR*
  ;; ../../../../spec-concrete/5.03-wellformed.watsup:70.1-74.51
  rulegroup 
   match
    (expl-input) bound | parameterTypeIR*{}
    (impl-input) bound | parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
    -- if $distinct_<id>(id*{id <- id*})
    -- (if ParameterType_wf: bound |- parameterTypeIR holds)*{parameterTypeIR <- parameterTypeIR*}
    (output) 
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:21.1-23.20
relation RoutineType_wf: bound |- routineTypeIR
  ;; ../../../../spec-concrete/5.03-wellformed.watsup:473.1-476.34
  rulegroup builtinfunction
   match
    (expl-input) bound | builtin_function( parameterTypeIR*{} )-> typeIR_ret as routineTypeIR
    (impl-input) bound | routineTypeIR
    (impl-input-premises)
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
    -- let builtin_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
   paths
  {
    rulepath builtinfunction
    (premises)
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- if Type_wf: bound |- typeIR_ret holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:491.1-496.34
  rulegroup functiontype
   match
    (expl-input) bound | function( parameterTypeIR*{} )-> typeIR_ret as routineTypeIR
    (impl-input) bound | routineTypeIR
    (impl-input-premises)
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `FUNCTION(%)->%`
    -- let function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
   paths
  {
    rulepath functiontype
    (premises)
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_function(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
    -- if Type_wf: bound |- typeIR_ret holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:524.1-529.45
  rulegroup actiontype
   match
    (expl-input) bound | action( parameterTypeIR*{} ) as routineTypeIR
    (impl-input) bound | routineTypeIR
    (impl-input-premises)
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `ACTION(%)`
    -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
   paths
  {
    rulepath actiontype
    (premises)
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- if $directionless_trailing(direction*{direction <- direction*})
    -- (if $nestable_action(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:547.1-552.34
  rulegroup externfunctiontype
   match
    (expl-input) bound | extern_function( parameterTypeIR*{} )-> typeIR_ret as routineTypeIR
    (impl-input) bound | routineTypeIR
    (impl-input-premises)
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
    -- let extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
   paths
  {
    rulepath externfunctiontype
    (premises)
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_externfunction(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
    -- if Type_wf: bound |- typeIR_ret holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:556.1-559.34
  rulegroup builtinmethod
   match
    (expl-input) bound | builtin_method( parameterTypeIR*{} )-> typeIR_ret as routineTypeIR
    (impl-input) bound | routineTypeIR
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
    -- let builtin_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
   paths
  {
    rulepath builtinmethod
    (premises)
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- if Type_wf: bound |- typeIR_ret holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:577.1-582.34
  rulegroup externmethod
   match
    (expl-input) bound | extern_method( parameterTypeIR*{} )-> typeIR_ret as routineTypeIR
    (impl-input) bound | routineTypeIR
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
    -- let extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
   paths
  {
    rulepath externmethod
    (premises)
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_externmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
    -- if Type_wf: bound |- typeIR_ret holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:600.1-605.34
  rulegroup externabstractmethod
   match
    (expl-input) bound | extern_methodabstract( parameterTypeIR*{} )-> typeIR_ret as routineTypeIR
    (impl-input) bound | routineTypeIR
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
    -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
   paths
  {
    rulepath externabstractmethod
    (premises)
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_externabstractmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
    -- if Type_wf: bound |- typeIR_ret holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:623.1-627.56
  rulegroup parserapplymethod
   match
    (expl-input) bound | parser_apply( parameterTypeIR*{} ) as routineTypeIR
    (impl-input) bound | routineTypeIR
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `PARSER_APPLY(%)`
    -- let parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
   paths
  {
    rulepath parserapplymethod
    (premises)
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_parserapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:644.1-648.57
  rulegroup controlapplymethod
   match
    (expl-input) bound | control_apply( parameterTypeIR*{} ) as routineTypeIR
    (impl-input) bound | routineTypeIR
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `CONTROL_APPLY(%)`
    -- let control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
   paths
  {
    rulepath controlapplymethod
    (premises)
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_controlapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:650.1-651.51
  rulegroup tableapplymethod
   match
    (expl-input) bound | table_apply-> table_struct _tid { _fieldTypeIR*{} } as typeIR as routineTypeIR
    (impl-input) bound | routineTypeIR
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `TABLE_APPLY->%`
    -- let table_apply-> typeIR = methodTypeIR
    -- if typeIR <: tableTypeIR
    -- let tableTypeIR = typeIR as tableTypeIR
    -- if tableTypeIR matches `TABLE_STRUCT%{%}`
    -- let table_struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR
   paths
  {
    rulepath tableapplymethod
    (premises)
    (output) 
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:25.1-27.20
relation RoutineTypeDef_wf: bound |- routineTypeDefIR
  ;; ../../../../spec-concrete/5.03-wellformed.watsup:668.1-671.44
  rulegroup mono
   match
    (expl-input) bound | routineTypeIR as routineTypeDefIR
    (impl-input) bound | routineTypeDefIR
    (impl-input-premises)
    -- if routineTypeDefIR <: routineTypeIR
    -- let routineTypeIR = routineTypeDefIR as routineTypeIR
   paths
  {
    rulepath mono
    (premises)
    -- if $definable_routine_mono(routineTypeIR)
    -- if RoutineType_wf: bound |- routineTypeIR holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:682.1-688.50
  rulegroup poly
   match
    (expl-input) bound | routineTypeIR < tid_expl*{} , tid_impl*{} > as routineTypeDefIR
    (impl-input) bound | routineTypeDefIR
    (impl-input-premises)
    -- if routineTypeDefIR <: polyRoutineTypeDefIR
    -- let routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > = routineTypeDefIR as polyRoutineTypeDefIR
   paths
  {
    rulepath poly
    (premises)
    -- if $definable_routine_poly(routineTypeIR)
    -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
    -- let bound_inner = $union_set<tid>(bound, { tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} })
    -- if RoutineType_wf: bound_inner |- routineTypeIR holds
    (output) 
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:29.1-31.20
relation ConstructorParameterType_wf: bound |- parameterTypeIR
  ;; ../../../../spec-concrete/5.03-wellformed.watsup:694.1-696.30
  rulegroup 
   match
    (expl-input) bound | typeIR _id _value?{}
    (impl-input) bound | direction typeIR _id _value?{_value <- _value?}
    (impl-input-premises)
    -- if direction matches ``EMPTY`
   paths
  {
    rulepath 
    (premises)
    -- if Type_wf: bound |- typeIR holds
    (output) 
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:33.1-35.20
relation ConstructorParameterTypes_wf: bound |- parameterTypeIR*
  ;; ../../../../spec-concrete/5.03-wellformed.watsup:698.1-702.62
  rulegroup 
   match
    (expl-input) bound | parameterTypeIR*{}
    (impl-input) bound | parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
    -- if $distinct_<id>(id*{id <- id*})
    -- (if ConstructorParameterType_wf: bound |- parameterTypeIR holds)*{parameterTypeIR <- parameterTypeIR*}
    (output) 
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:37.1-39.20
relation ConstructorType_wf: bound |- constructorTypeIR
  ;; ../../../../spec-concrete/5.03-wellformed.watsup:720.1-726.46
  rulegroup externtype
   match
    (expl-input) bound | constructor( parameterTypeIR*{} )-> typeIR_object
    (impl-input) bound | constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object
    (impl-input-premises)
   paths
  {
    rulepath externtype
    (premises)
    -- if ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- if Type_wf: bound |- typeIR_object holds
    -- let typeIR' = $canon(typeIR_object)
    -- if typeIR' <: externObjectTypeIR
    -- let extern _tid _map<rid, routineTypeDefIR> = typeIR' as externObjectTypeIR
    -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_constructor_extern(typeIR))*{typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:739.1-745.46
  rulegroup parsertype
   match
    (expl-input) bound | constructor( parameterTypeIR*{} )-> typeIR_object
    (impl-input) bound | constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object
    (impl-input-premises)
   paths
  {
    rulepath parsertype
    (premises)
    -- if ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- if Type_wf: bound |- typeIR_object holds
    -- let typeIR' = $canon(typeIR_object)
    -- if typeIR' <: parserObjectTypeIR
    -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR' as parserObjectTypeIR
    -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_constructor_parser(typeIR))*{typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:758.1-764.47
  rulegroup controltype
   match
    (expl-input) bound | constructor( parameterTypeIR*{} )-> typeIR_object
    (impl-input) bound | constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object
    (impl-input-premises)
   paths
  {
    rulepath controltype
    (premises)
    -- if ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- if Type_wf: bound |- typeIR_object holds
    -- let typeIR' = $canon(typeIR_object)
    -- if typeIR' <: controlObjectTypeIR
    -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR' as controlObjectTypeIR
    -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_constructor_control(typeIR))*{typeIR <- typeIR*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:775.1-781.47
  rulegroup packagetype
   match
    (expl-input) bound | constructor( parameterTypeIR*{} )-> typeIR_object
    (impl-input) bound | constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object
    (impl-input-premises)
   paths
  {
    rulepath packagetype
    (premises)
    -- if ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- if Type_wf: bound |- typeIR_object holds
    -- let typeIR' = $canon(typeIR_object)
    -- if typeIR' <: packageObjectTypeIR
    -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR' as packageObjectTypeIR
    -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_constructor_package(typeIR))*{typeIR <- typeIR*}
    (output) 
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:41.1-43.20
relation ConstructorTypeDef_wf: bound |- constructorTypeDefIR
  ;; ../../../../spec-concrete/5.03-wellformed.watsup:799.1-806.58
  rulegroup 
   match
    (expl-input) bound | constructorTypeIR < tid_expl*{} , tid_impl*{} >
    (impl-input) bound | constructorTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let constructor( _constructorParameterTypeIR*{_constructorParameterTypeIR <- _constructorParameterTypeIR*} )-> typeIR_object = constructorTypeIR
    -- if $definable_constructor(typeIR_object)
    -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
    -- let bound_inner = $union_set<tid>(bound, { tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} })
    -- if ConstructorType_wf: bound_inner |- constructorTypeIR holds
    (output) 
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:98.1-98.37
def $nestable_typedef(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:101.1-101.67
  clause 0(typeIR) = $nestable'_typedef($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:99.1-99.38
def $nestable'_typedef(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:102.1-102.36
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:103.1-103.37
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:104.1-104.38
  clause 2(typeIR) = true
  -- if (typeIR = string as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:105.1-105.44
  clause 3(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:106.1-106.37
  clause 4(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:107.1-107.40
  clause 5(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:108.1-108.42
  clause 6(typeIR) = true
  -- if typeIR <: dataTypeIR
  -- let dataTypeIR = typeIR as dataTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:109.1-110.15
  clause 7(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:117.1-117.33
def $nestable_new(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:120.1-120.59
  clause 0(typeIR) = $nestable'_new($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:118.1-118.34
def $nestable'_new(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:121.1-121.32
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:122.1-122.38
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:123.1-123.38
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:124.1-124.33
  clause 3(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:125.1-125.36
  clause 4(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:126.1-127.15
  clause 5(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:136.1-136.34
def $nestable_list(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:139.1-139.61
  clause 0(typeIR) = $nestable'_list($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:137.1-137.35
def $nestable'_list(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:140.1-140.33
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:141.1-141.34
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:142.1-142.39
  clause 2(typeIR) = true
  -- if (typeIR = match_kind as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:143.1-143.35
  clause 3(typeIR) = true
  -- if (typeIR = string as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:144.1-144.41
  clause 4(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:145.1-145.34
  clause 5(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:146.1-146.37
  clause 6(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:147.1-147.39
  clause 7(typeIR) = true
  -- if typeIR <: dataTypeIR
  -- let dataTypeIR = typeIR as dataTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:148.1-149.15
  clause 8(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:156.1-156.35
def $nestable_tuple(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:159.1-159.63
  clause 0(typeIR) = $nestable'_tuple($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:157.1-157.36
def $nestable'_tuple(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:160.1-160.34
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:161.1-161.35
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:162.1-162.40
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:163.1-163.40
  clause 3(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:164.1-164.43
  clause 4(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:165.1-165.35
  clause 5(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:166.1-166.38
  clause 6(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:167.1-167.42
  clause 7(typeIR) = true
  -- if typeIR <: tupleTypeIR
  -- let tuple< _typeIR*{_typeIR <- _typeIR*} > = typeIR as tupleTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:168.1-168.43
  clause 8(typeIR') = true
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:169.1-169.45
  clause 9(typeIR) = true
  -- if typeIR <: headerTypeIR
  -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:170.1-170.51
  clause 10(typeIR) = true
  -- if typeIR <: headerUnionTypeIR
  -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:171.1-171.45
  clause 11(typeIR) = true
  -- if typeIR <: structTypeIR
  -- let struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:172.1-172.43
  clause 12(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:173.1-173.48
  clause 13(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:174.1-175.15
  clause 14(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:182.1-182.35
def $nestable_stack(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:185.1-185.63
  clause 0(typeIR) = $nestable'_stack($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:183.1-183.36
def $nestable'_stack(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:186.1-186.35
  clause 0(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:187.1-187.45
  clause 1(typeIR) = true
  -- if typeIR <: headerTypeIR
  -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:188.1-188.51
  clause 2(typeIR) = true
  -- if typeIR <: headerUnionTypeIR
  -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:189.1-190.15
  clause 3(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:197.1-197.36
def $nestable_struct(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:200.1-200.65
  clause 0(typeIR) = $nestable'_struct($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:198.1-198.37
def $nestable'_struct(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:201.1-201.35
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:202.1-202.36
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:203.1-203.41
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:204.1-204.41
  clause 3(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:205.1-205.44
  clause 4(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:206.1-206.36
  clause 5(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:207.1-207.39
  clause 6(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:208.1-208.43
  clause 7(typeIR) = true
  -- if typeIR <: tupleTypeIR
  -- let tuple< _typeIR*{_typeIR <- _typeIR*} > = typeIR as tupleTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:209.1-209.44
  clause 8(typeIR') = true
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:210.1-210.46
  clause 9(typeIR) = true
  -- if typeIR <: structTypeIR
  -- let struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:211.1-211.46
  clause 10(typeIR) = true
  -- if typeIR <: headerTypeIR
  -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:212.1-212.52
  clause 11(typeIR) = true
  -- if typeIR <: headerUnionTypeIR
  -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:213.1-213.44
  clause 12(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:214.1-214.49
  clause 13(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:215.1-216.15
  clause 14(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:224.1-224.36
def $nestable_header(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:229.1-229.65
  clause 0(typeIR) = $nestable'_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:225.1-225.37
def $nestable'_header(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:230.1-230.35
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:231.1-231.41
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:232.1-232.41
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:233.1-233.44
  clause 3(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:234.1-234.36
  clause 4(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:235.1-235.39
  clause 5(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:236.1-236.49
  clause 6(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:237.1-238.44
  clause 7(typeIR') = true
  -- if typeIR' <: structTypeIR
  -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR
  -- (if $nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:239.1-240.15
  clause 8(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:226.1-226.46
def $nestable_struct_in_header(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:242.1-243.48
  clause 0(typeIR) = $nestable'_struct_in_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:227.1-227.47
def $nestable'_struct_in_header(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:244.1-244.45
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:245.1-245.51
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:246.1-246.51
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:247.1-247.46
  clause 3(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:248.1-248.49
  clause 4(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:249.1-249.59
  clause 5(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:250.1-251.44
  clause 6(typeIR') = true
  -- if typeIR' <: structTypeIR
  -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR
  -- (if $nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:252.1-253.15
  clause 7(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:261.1-261.41
def $nestable_headerunion(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:264.1-265.43
  clause 0(typeIR) = $nestable'_headerunion($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:262.1-262.42
def $nestable'_headerunion(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:266.1-266.41
  clause 0(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:267.1-267.44
  clause 1(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:268.1-268.51
  clause 2(typeIR) = true
  -- if typeIR <: headerTypeIR
  -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:269.1-270.15
  clause 3(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:282.1-282.37
def $nestable_serenum(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:287.1-288.39
  clause 0(typeIR) = $nestable'_serenum($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:283.1-283.38
def $nestable'_serenum(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:289.1-289.42
  clause 0(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:290.1-290.42
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:291.1-291.37
  clause 2(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:292.1-293.37
  clause 3(typeIR') = $nestable_new_in_serenum(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:294.1-295.15
  clause 4(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:284.1-284.44
def $nestable_new_in_serenum(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:297.1-298.46
  clause 0(typeIR) = $nestable_new_in_serenum'($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:285.1-285.45
def $nestable_new_in_serenum'(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:299.1-299.49
  clause 0(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:300.1-300.49
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:301.1-301.44
  clause 2(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:302.1-302.47
  clause 3(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:303.1-304.15
  clause 4(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:361.1-361.33
def $nestable_set(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:368.1-368.59
  clause 0(typeIR) = $nestable'_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:362.1-362.34
def $nestable'_set(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:369.1-369.32
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:370.1-370.33
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:371.1-371.38
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:372.1-372.38
  clause 3(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:373.1-373.33
  clause 4(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:374.1-374.36
  clause 5(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:375.1-376.40
  clause 6(typeIR') = true
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
  -- (if $nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:377.1-377.41
  clause 7(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:378.1-378.46
  clause 8(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:379.1-380.43
  clause 9(typeIR') = true
  -- if typeIR' <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR' as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%>`
  -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR
  -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:381.1-382.15
  clause 10(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:363.1-363.42
def $nestable_tuple_in_set(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:384.1-385.44
  clause 0(typeIR) = $nestable'_tuple_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:364.1-364.43
def $nestable'_tuple_in_set(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:386.1-386.41
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:387.1-387.47
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:388.1-388.47
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:389.1-389.42
  clause 3(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:390.1-390.45
  clause 4(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:391.1-392.40
  clause 5(typeIR') = true
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
  -- (if $nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:393.1-393.50
  clause 6(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:394.1-394.55
  clause 7(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:395.1-396.15
  clause 8(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:365.1-365.45
def $nestable_sequence_in_set(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:398.1-399.47
  clause 0(typeIR) = $nestable'_sequence_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:366.1-366.46
def $nestable'_sequence_in_set(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:400.1-400.44
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:401.1-401.50
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:402.1-402.50
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:403.1-403.45
  clause 3(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:404.1-404.48
  clause 4(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:405.1-406.43
  clause 5(typeIR') = true
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
  -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:407.1-407.53
  clause 6(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:408.1-408.58
  clause 7(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:409.1-410.43
  clause 8(typeIR') = true
  -- if typeIR' <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR' as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%>`
  -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR
  -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:411.1-412.15
  clause 9(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:430.1-430.40
def $definable_type_mono(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:432.1-432.39
  clause 0(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:433.1-433.45
  clause 1(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:434.1-434.47
  clause 2(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:435.1-435.52
  clause 3(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:436.1-436.46
  clause 4(typeIR) = true
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:437.1-438.15
  clause 5(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:445.1-445.40
def $definable_type_poly(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:447.1-447.46
  clause 0(typeIR) = true
  -- if typeIR <: tupleTypeIR
  -- let tuple< _typeIR*{_typeIR <- _typeIR*} > = typeIR as tupleTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:448.1-448.42
  clause 1(typeIR) = true
  -- if typeIR <: headerStackTypeIR
  -- let _typeIR [ _nat ] = typeIR as headerStackTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:449.1-449.49
  clause 2(typeIR) = true
  -- if typeIR <: headerTypeIR
  -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:450.1-450.55
  clause 3(typeIR) = true
  -- if typeIR <: headerUnionTypeIR
  -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:451.1-451.49
  clause 4(typeIR) = true
  -- if typeIR <: structTypeIR
  -- let struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:452.1-452.44
  clause 5(typeIR) = true
  -- if typeIR <: externObjectTypeIR
  -- let extern _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:453.1-453.47
  clause 6(typeIR) = true
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:454.1-454.48
  clause 7(typeIR) = true
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:455.1-455.48
  clause 8(typeIR) = true
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:456.1-457.15
  clause 9(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:478.1-478.49
def $nestable_function(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:481.1-482.51
  clause 0(direction, typeIR) = $nestable_function'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:479.1-479.50
def $nestable_function'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:483.1-484.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:485.1-486.29
  clause 1(direction, typeIR) = false
  -- if (typeIR = int as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:487.1-487.57
  clause 2(direction, typeIR) = false
  -- if typeIR <: objectTypeIR
  -- let objectTypeIR = typeIR as objectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:488.1-489.15
  clause 3(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:498.1-498.47
def $directionless_trailing(direction*) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:501.1-502.65
  clause 0(direction*{direction <- direction*}) = $directionless_trailing'(true, $rev_<direction>(direction*{direction <- direction*}))

;; ../../../../spec-concrete/5.03-wellformed.watsup:499.1-499.54
def $directionless_trailing'(bool, direction*) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:504.1-504.44
  clause 0(_bool, direction*{direction <- direction*}) = true
  -- if direction*{direction <- direction*} matches []

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:505.1-506.49
  clause 1(bool, direction'*{direction' <- direction'*}) = $directionless_trailing'(true, direction_t*{direction_t <- direction_t*})
  -- if (bool = true)
  -- if direction'*{direction' <- direction'*} matches _ :: _
  -- let direction :: direction_t*{direction_t <- direction_t*} = direction'*{direction' <- direction'*}
  -- if direction matches ``EMPTY`

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:507.1-507.68
  clause 2(bool, direction'*{direction' <- direction'*}) = false
  -- if (bool = false)
  -- if direction'*{direction' <- direction'*} matches _ :: _
  -- let direction :: direction_t*{direction_t <- direction_t*} = direction'*{direction' <- direction'*}
  -- if direction matches ``EMPTY`

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:508.1-510.31
  clause 3(_bool, direction*{direction <- direction*}) = $directionless_trailing'(false, direction_t*{direction_t <- direction_t*})
  -- if direction*{direction <- direction*} matches _ :: _
  -- let direction_h :: direction_t*{direction_t <- direction_t*} = direction*{direction <- direction*}
  -- if (direction_h =/= )

;; ../../../../spec-concrete/5.03-wellformed.watsup:512.1-512.47
def $nestable_action(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:515.1-516.49
  clause 0(direction, typeIR) = $nestable_action'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:513.1-513.48
def $nestable_action'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:517.1-518.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:519.1-519.38
  clause 1(_direction, typeIR) = false
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:520.1-520.47
  clause 2(_direction, typeIR) = false
  -- if typeIR <: objectTypeIR
  -- let objectTypeIR = typeIR as objectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:521.1-522.15
  clause 3(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:531.1-531.55
def $nestable_externfunction(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:534.1-535.57
  clause 0(direction, typeIR) = $nestable_externfunction'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:532.1-532.56
def $nestable_externfunction'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:536.1-537.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:538.1-539.29
  clause 1(direction, typeIR) = false
  -- if (typeIR = int as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:540.1-540.64
  clause 2(direction, typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:541.1-541.65
  clause 3(direction, typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:542.1-542.65
  clause 4(direction, typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:543.1-543.63
  clause 5(direction, typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:544.1-545.15
  clause 6(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:561.1-561.53
def $nestable_externmethod(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:564.1-565.55
  clause 0(direction, typeIR) = $nestable_externmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:562.1-562.54
def $nestable_externmethod'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:566.1-567.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:568.1-569.29
  clause 1(direction, typeIR) = false
  -- if (typeIR = int as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:570.1-570.62
  clause 2(direction, typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:571.1-571.63
  clause 3(direction, typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:572.1-572.63
  clause 4(direction, typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:573.1-573.61
  clause 5(direction, typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:574.1-575.15
  clause 6(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:584.1-584.61
def $nestable_externabstractmethod(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:587.1-588.63
  clause 0(direction, typeIR) = $nestable_externabstractmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:585.1-585.62
def $nestable_externabstractmethod'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:589.1-590.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:591.1-592.29
  clause 1(direction, typeIR) = false
  -- if (typeIR = int as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:593.1-593.70
  clause 2(direction, typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:594.1-594.71
  clause 3(direction, typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:595.1-595.71
  clause 4(direction, typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:596.1-596.69
  clause 5(direction, typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:597.1-598.15
  clause 6(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:607.1-607.58
def $nestable_parserapplymethod(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:610.1-611.60
  clause 0(direction, typeIR) = $nestable_parserapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:608.1-608.59
def $nestable_parserapplymethod'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:612.1-613.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:614.1-615.29
  clause 1(direction, typeIR) = false
  -- if (typeIR = int as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:616.1-616.67
  clause 2(direction, typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:617.1-617.68
  clause 3(direction, typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:618.1-618.68
  clause 4(direction, typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:619.1-619.66
  clause 5(direction, typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:620.1-621.15
  clause 6(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:629.1-629.59
def $nestable_controlapplymethod(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:632.1-633.61
  clause 0(direction, typeIR) = $nestable_controlapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:630.1-630.60
def $nestable_controlapplymethod'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:634.1-635.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:636.1-637.29
  clause 1(direction, typeIR) = false
  -- if (typeIR = int as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:638.1-638.68
  clause 2(direction, typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:639.1-639.69
  clause 3(direction, typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:640.1-640.67
  clause 4(direction, typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:641.1-642.15
  clause 5(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:657.1-657.50
def $definable_routine_mono(routineTypeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:659.1-659.66
  clause 0(routineTypeIR) = true
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
  -- let builtin_function( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = functionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:660.1-660.50
  clause 1(routineTypeIR) = true
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `ACTION(%)`
  -- let action( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = functionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:661.1-661.64
  clause 2(routineTypeIR) = true
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
  -- let builtin_method( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = methodTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:662.1-662.56
  clause 3(routineTypeIR) = true
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `PARSER_APPLY(%)`
  -- let parser_apply( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = methodTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:663.1-663.57
  clause 4(routineTypeIR) = true
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `CONTROL_APPLY(%)`
  -- let control_apply( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = methodTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:664.1-664.54
  clause 5(routineTypeIR) = true
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `TABLE_APPLY->%`
  -- let table_apply-> _typeIR = methodTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:665.1-666.15
  clause 6(_routineTypeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:673.1-673.50
def $definable_routine_poly(routineTypeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:675.1-675.58
  clause 0(routineTypeIR) = true
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `FUNCTION(%)->%`
  -- let function( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = functionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:676.1-676.65
  clause 1(routineTypeIR) = true
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
  -- let extern_function( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = functionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:677.1-677.63
  clause 2(routineTypeIR) = true
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
  -- let extern_method( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = methodTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:678.1-678.72
  clause 3(routineTypeIR) = true
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = methodTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:679.1-680.15
  clause 4(_routineTypeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:708.1-708.48
def $nestable_constructor_extern(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:711.1-712.50
  clause 0(typeIR) = $nestable'_constructor_extern($canon(typeIR))

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:713.1-713.56
  clause 1(typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

;; ../../../../spec-concrete/5.03-wellformed.watsup:709.1-709.49
def $nestable'_constructor_extern(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:714.1-714.58
  clause 0(typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:715.1-715.58
  clause 1(typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:716.1-716.56
  clause 2(typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:717.1-718.15
  clause 3(_typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:728.1-728.48
def $nestable_constructor_parser(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:731.1-732.50
  clause 0(typeIR) = $nestable'_constructor_parser($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:729.1-729.49
def $nestable'_constructor_parser(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:733.1-733.58
  clause 0(typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:734.1-734.58
  clause 1(typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:735.1-735.56
  clause 2(typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:736.1-737.15
  clause 3(_typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:747.1-747.49
def $nestable_constructor_control(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:750.1-751.51
  clause 0(typeIR) = $nestable'_constructor_control($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:748.1-748.50
def $nestable'_constructor_control(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:752.1-752.58
  clause 0(typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:753.1-753.59
  clause 1(typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:754.1-754.57
  clause 2(typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:755.1-756.15
  clause 3(_typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:766.1-766.49
def $nestable_constructor_package(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:769.1-770.51
  clause 0(typeIR) = $nestable'_constructor_package($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:767.1-767.50
def $nestable'_constructor_package(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:771.1-771.57
  clause 0(typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:772.1-773.15
  clause 1(_typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:787.1-787.42
def $definable_constructor(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:790.1-791.44
  clause 0(typeIR) = $definable'_constructor($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:788.1-788.43
def $definable'_constructor(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:792.1-792.47
  clause 0(typeIR) = true
  -- if typeIR <: externObjectTypeIR
  -- let extern _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:793.1-793.50
  clause 1(typeIR) = true
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:794.1-794.51
  clause 2(typeIR) = true
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:795.1-795.51
  clause 3(typeIR) = true
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:796.1-797.15
  clause 4(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.04-typing-relation.watsup:6.1-8.23
relation Eval_static: cursor typingContext |- typedExpressionIR ~> value
  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:16.1-24.2
  rulegroup literalExpressionIR-boolean
   match
    (expl-input) p | TC | booleanLiteral as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: booleanLiteral
    -- let booleanLiteral = expressionIR as booleanLiteral
   paths
  {
    rulepath true
    (premises)
    -- if (true = booleanLiteral)
    (output) b true as value

    rulepath false
    (premises)
    -- if (false = booleanLiteral)
    (output) b false as value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:28.1-39.2
  rulegroup literalExpressionIR-number
   match
    (expl-input) p | TC | numberLiteral as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: numberLiteral
    -- let numberLiteral = expressionIR as numberLiteral
   paths
  {
    rulepath arbint
    (premises)
    -- let numberLiteral' = numberLiteral
    -- if numberLiteral' matches `D%`
    -- let d i = numberLiteral'
    (output) d i as value

    rulepath fixbit
    (premises)
    -- let numberLiteral' = numberLiteral
    -- if numberLiteral' matches `%W%`
    -- let n w i = numberLiteral'
    (output) n w i as value

    rulepath fixint
    (premises)
    -- let numberLiteral' = numberLiteral
    -- if numberLiteral' matches `%S%`
    -- let n s i = numberLiteral'
    (output) n s i as value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:43.1-44.49
  rulegroup literalExpressionIR-stringliteral
   match
    (expl-input) p | TC | " text " as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: stringLiteral
    -- let " text " = expressionIR as stringLiteral
   paths
  {
    rulepath literalExpressionIR-stringliteral
    (premises)
    (output) " text " as value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:49.1-51.51
  rulegroup referenceExpression
   match
    (expl-input) p | TC | prefixedNameIR as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: prefixedNameIR
    -- let prefixedNameIR = expressionIR as prefixedNameIR
   paths
  {
    rulepath referenceExpression
    (premises)
    -- let value = $find_value(p, TC, prefixedNameIR)
    (output) value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:56.1-57.38
  rulegroup defaultExpressionIR
   match
    (expl-input) p | TC | ... as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if (expressionIR = ... as expressionIR)
   paths
  {
    rulepath defaultExpressionIR
    (premises)
    (output) default as value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:62.1-80.2
  rulegroup unaryExpressionIR
   match
    (expl-input) p | TC | unop typedExpressionIR as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
   paths
  {
    rulepath bnot
    (premises)
    -- if (~ = unop)
    -- Eval_static: p TC |- typedExpressionIR ~> value
    (output) $un_bnot(value)

    rulepath lnot
    (premises)
    -- if (! = unop)
    -- Eval_static: p TC |- typedExpressionIR ~> value
    (output) $un_lnot(value)

    rulepath plus
    (premises)
    -- if (+ = unop)
    -- Eval_static: p TC |- typedExpressionIR ~> value
    (output) $un_plus(value)

    rulepath minus
    (premises)
    -- if (- = unop)
    -- Eval_static: p TC |- typedExpressionIR ~> value
    (output) $un_minus(value)
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:86.1-208.2
  rulegroup binaryExpressionIR
   match
    (expl-input) p | TC | typedExpressionIR_l binop typedExpressionIR_r as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
   paths
  {
    rulepath plus
    (premises)
    -- if (+ = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_plus(value_l, value_r)

    rulepath satplus
    (premises)
    -- if (|+| = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_satplus(value_l, value_r)

    rulepath minus
    (premises)
    -- if (- = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_minus(value_l, value_r)

    rulepath satminus
    (premises)
    -- if (|-| = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_satminus(value_l, value_r)

    rulepath mul
    (premises)
    -- if (* = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_mul(value_l, value_r)

    rulepath div
    (premises)
    -- if (/ = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_div(value_l, value_r)

    rulepath shl
    (premises)
    -- if (<< = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_shl(value_l, value_r)

    rulepath shr
    (premises)
    -- if (>> = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_shr(value_l, value_r)

    rulepath le
    (premises)
    -- if (<= = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) b $bin_le(value_l, value_r) as value

    rulepath ge
    (premises)
    -- if (>= = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) b $bin_ge(value_l, value_r) as value

    rulepath lt
    (premises)
    -- if (< = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) b $bin_lt(value_l, value_r) as value

    rulepath gt
    (premises)
    -- if (> = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) b $bin_gt(value_l, value_r) as value

    rulepath eq
    (premises)
    -- if (== = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) b $bin_eq(value_l, value_r) as value

    rulepath ne
    (premises)
    -- if (!= = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) b $bin_ne(value_l, value_r) as value

    rulepath band
    (premises)
    -- if (& = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_band(value_l, value_r)

    rulepath bxor
    (premises)
    -- if (^ = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_bxor(value_l, value_r)

    rulepath bor
    (premises)
    -- if (| = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_bor(value_l, value_r)

    rulepath concat
    (premises)
    -- if (++ = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_concat(value_l, value_r)

    rulepath land
    (premises)
    -- if (&& = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_land(value_l, value_r)

    rulepath lor
    (premises)
    -- if (|| = binop)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
    (output) $bin_lor(value_l, value_r)
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:214.1-230.2
  rulegroup ternaryExpressionIR
   match
    (expl-input) p | TC | typedExpressionIR_cond ? typedExpressionIR_true : typedExpressionIR_false as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: ternaryExpressionIR
    -- let typedExpressionIR_cond ? typedExpressionIR_true : typedExpressionIR_false = expressionIR as ternaryExpressionIR
   paths
  {
    rulepath true
    (premises)
    -- Eval_static: p TC |- typedExpressionIR_cond ~> value
    -- if (value = b true as value)
    -- Eval_static: p TC |- typedExpressionIR_true ~> value_true
    (output) value_true

    rulepath false
    (premises)
    -- Eval_static: p TC |- typedExpressionIR_cond ~> value
    -- if (value = b false as value)
    -- Eval_static: p TC |- typedExpressionIR_false ~> value_false
    (output) value_false
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:235.1-238.45
  rulegroup castExpression
   match
    (expl-input) p | TC | ( typeIR ) typedExpressionIR as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: castExpressionIR
    -- let ( typeIR ) typedExpressionIR = expressionIR as castExpressionIR
   paths
  {
    rulepath castExpression
    (premises)
    -- Eval_static: p TC |- typedExpressionIR ~> value
    -- let value_cast = $cast_op(typeIR, value)
    (output) value_cast
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:245.1-246.35
  rulegroup dataExpressionIR-invalid
   match
    (expl-input) p | TC | {#} as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if (expressionIR = {#} as expressionIR)
   paths
  {
    rulepath dataExpressionIR-invalid
    (premises)
    (output) {#} as value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:251.1-261.2
  rulegroup dataExpressionIR-sequence
   match
    (expl-input) p | TC | dataExpressionIR as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
   paths
  {
    rulepath non-default
    (premises)
    -- let dataExpressionIR' = dataExpressionIR
    -- if dataExpressionIR' matches `SEQ{%}`
    -- let seq{ typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} } = dataExpressionIR'
    -- (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}
    (output) seq( value*{value <- value*} ) as value

    rulepath default
    (premises)
    -- let dataExpressionIR' = dataExpressionIR
    -- if dataExpressionIR' matches `SEQ{%,...}`
    -- let seq{ typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ,...} = dataExpressionIR'
    -- (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}
    (output) seq( value*{value <- value*} ,...) as value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:266.1-278.2
  rulegroup dataExpressionIR-record
   match
    (expl-input) p | TC | dataExpressionIR as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
   paths
  {
    rulepath non-default
    (premises)
    -- let dataExpressionIR' = dataExpressionIR
    -- if dataExpressionIR' matches `RECORD{%}`
    -- let record{ nameIR = typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} } = dataExpressionIR'
    -- (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}
    (output) record{ value nameIR ;*{nameIR <- nameIR*, value <- value*} } as value

    rulepath default
    (premises)
    -- let dataExpressionIR' = dataExpressionIR
    -- if dataExpressionIR' matches `RECORD{%,...}`
    -- let record{ nameIR = typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} ,...} = dataExpressionIR'
    -- (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}
    (output) record{ value nameIR ;*{nameIR <- nameIR*, value <- value*} ,...} as value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:286.1-289.58
  rulegroup errorAccessExpressionIR
   match
    (expl-input) p | TC | error. nameIR as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: errorAccessExpressionIR
    -- let error. nameIR = expressionIR as errorAccessExpressionIR
   paths
  {
    rulepath errorAccessExpressionIR
    (premises)
    -- let nameIR_error = "error." ++ nameIR
    -- let value_error = $find_value(p, TC, ` nameIR_error)
    (output) value_error
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:297.1-313.2
  rulegroup memberAccessExpressionIR-type
   match
    (expl-input) p | TC | type prefixedNameIR . nameIR as expressionIR # ( typeIR_base _ctk )
    (impl-input) p | TC | expressionIR # ( typeIR_base _ctk )
    (impl-input-premises)
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR matches `TYPE%`
    -- let type prefixedNameIR = memberAccessBaseIR
   paths
  {
    rulepath enum
    (premises)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: enumTypeIR
    -- let enumTypeIR = typeDefIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%{%}`
    -- let enum tid { id_member*{id_member <- id_member*} } = enumTypeIR
    -- if nameIR <- id_member*{id_member <- id_member*}
    (output) tid . nameIR as value

    rulepath serenum
    (premises)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: enumTypeIR
    -- let enumTypeIR = typeDefIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum tid # typeIR { id_member = value_member ;*{id_member <- id_member*, value_member <- value_member*} } = enumTypeIR
    -- let value'?{value' <- value'?} = $assoc_<id, value>(nameIR, (id_member, value_member)*{id_member <- id_member*, value_member <- value_member*})
    -- if value'?{value' <- value'?} matches (_)
    -- let ?(value) = value'?{value' <- value'?}
    (output) tid . nameIR # value as value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:318.1-321.36
  rulegroup memberAccessExpressionIR-typedExpressionIR-stack-size
   match
    (expl-input) p | TC | typedExpressionIR_base as memberAccessBaseIR . "size" as expressionIR # ( typeIR_base _ctk )
    (impl-input) p | TC | expressionIR # ( typeIR_base _ctk )
    (impl-input-premises)
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . text = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR <: typedExpressionIR
    -- let typedExpressionIR_base = memberAccessBaseIR as typedExpressionIR
    -- if (text = "size")
   paths
  {
    rulepath memberAccessExpressionIR-typedExpressionIR-stack-size
    (premises)
    -- let typeIR = typeIR_base
    -- if typeIR <: headerStackTypeIR
    -- let _typeIR [ n_size ] = typeIR as headerStackTypeIR
    (output) d n_size as int as value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:331.1-337.59
  rulegroup indexAccessExpressionIR-bitslice
   match
    (expl-input) p | TC | typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ] as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: indexAccessExpressionIR
    -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
    -- if indexAccessExpressionIR matches `%[%:%]`
    -- let typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ] = indexAccessExpressionIR
   paths
  {
    rulepath indexAccessExpressionIR-bitslice
    (premises)
    -- Eval_static: p TC |- typedExpressionIR_base ~> value_base
    -- Eval_static: p TC |- typedExpressionIR_hi ~> value_hi
    -- Eval_static: p TC |- typedExpressionIR_lo ~> value_lo
    (output) $bitacc_op(value_base, value_hi, value_lo)
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:353.1-357.91
  rulegroup callExpressionIR-typedLvalueIR-size
   match
    (expl-input) p | TC | typedExpressionIR_base . nameIR < [] >( [] ) as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%<%>(%)`
    -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
   paths
  {
    rulepath callExpressionIR-typedLvalueIR-size
    (premises)
    -- let _expressionIR # ( typeIR_base _ctk' ) = typedExpressionIR_base
    -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
    (output) $sizeof(typeIR_base, nameIR)
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:361.1-375.2
  rulegroup callExpressionIR-type
   match
    (expl-input) p | TC | type prefixedNameIR . nameIR < [] >( [] ) as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%<%>(%)`
    -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if routineTargetIR matches `TYPE%.%`
    -- let type prefixedNameIR . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
   paths
  {
    rulepath size-mono
    (premises)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR_base = typeDefIR as typeIR
    -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
    (output) $sizeof(typeIR_base, nameIR)

    rulepath size-poly
    (premises)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: polyTypeDefIR
    -- let typeIR_base < tid*{tid <- tid*} , tid'*{tid' <- tid'*} > = typeDefIR as polyTypeDefIR
    -- if tid*{tid <- tid*} matches []
    -- if tid'*{tid' <- tid'*} matches []
    -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
    (output) $sizeof(typeIR_base, nameIR)
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:379.1-386.21
  rulegroup callExpressionIR-parenthesized
   match
    (expl-input) p | TC | ( routineTargetIR ) < typeArgumentIR*{} >( argumentIR*{} ) as expressionIR # ( typeIR ctk )
    (impl-input) p | TC | expressionIR # ( typeIR ctk )
    (impl-input-premises)
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%<%>(%)`
    -- let routineTargetIR' < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if routineTargetIR' matches `(%)`
    -- let ( routineTargetIR ) = routineTargetIR'
   paths
  {
    rulepath callExpressionIR-parenthesized
    (premises)
    -- Eval_static: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) as expressionIR # ( typeIR ctk ) ~> value
    (output) value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:391.1-393.53
  rulegroup parenthesizedExpressionIR
   match
    (expl-input) p | TC | ( typedExpressionIR ) as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: parenthesizedExpressionIR
    -- let ( typedExpressionIR ) = expressionIR as parenthesizedExpressionIR
   paths
  {
    rulepath parenthesizedExpressionIR
    (premises)
    -- Eval_static: p TC |- typedExpressionIR ~> value
    (output) value
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:15.1-17.23
relation Type_ok: cursor typingContext |- typeOrVoid : typeIR # tid*
  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:11.1-12.29
  rulegroup boolean
   match
    (expl-input) p | TC | bool as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if (typeOrVoid = bool as typeOrVoid)
   paths
  {
    rulepath boolean
    (premises)
    (output) bool as typeIR | []
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:16.1-17.31
  rulegroup error
   match
    (expl-input) p | TC | error as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if (typeOrVoid = error as typeOrVoid)
   paths
  {
    rulepath error
    (premises)
    (output) error as typeIR | []
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:21.1-22.41
  rulegroup matchkind
   match
    (expl-input) p | TC | match_kind as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if (typeOrVoid = match_kind as typeOrVoid)
   paths
  {
    rulepath matchkind
    (premises)
    (output) match_kind as typeIR | []
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:26.1-27.33
  rulegroup string
   match
    (expl-input) p | TC | string as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if (typeOrVoid = string as typeOrVoid)
   paths
  {
    rulepath string
    (premises)
    (output) string as typeIR | []
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:31.1-32.27
  rulegroup arbint
   match
    (expl-input) p | TC | int as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if (typeOrVoid = int as typeOrVoid)
   paths
  {
    rulepath arbint
    (premises)
    (output) int as typeIR | []
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:37.1-48.2
  rulegroup fixint
   match
    (expl-input) p | TC | baseType as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if typeOrVoid <: baseType
    -- let baseType = typeOrVoid as baseType
   paths
  {
    rulepath integer
    (premises)
    -- let baseType' = baseType
    -- if baseType' matches `INT<%>`
    -- let int< int > = baseType'
    -- if int <: nat
    -- let n = int as nat
    (output) int< n > as typeIR | []

    rulepath expr
    (premises)
    -- let baseType' = baseType
    -- if baseType' matches `INT<(%)>`
    -- let int<( expression )> = baseType'
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- Eval_static: p TC |- typedExpressionIR ~> value
    -- let int = $to_number(value)
    -- if int <: nat
    -- let n = int as nat
    (output) int< n > as typeIR | []
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:54.1-68.2
  rulegroup fixbit
   match
    (expl-input) p | TC | baseType as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if typeOrVoid <: baseType
    -- let baseType = typeOrVoid as baseType
   paths
  {
    rulepath none
    (premises)
    -- if (bit = baseType)
    (output) bit< 1 > as typeIR | []

    rulepath integer
    (premises)
    -- let baseType' = baseType
    -- if baseType' matches `BIT<%>`
    -- let bit< int > = baseType'
    -- if int <: nat
    -- let n = int as nat
    (output) bit< n > as typeIR | []

    rulepath expr
    (premises)
    -- let baseType' = baseType
    -- if baseType' matches `BIT<(%)>`
    -- let bit<( expression )> = baseType'
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- Eval_static: p TC |- typedExpressionIR ~> value
    -- let int = $to_number(value)
    -- if int <: nat
    -- let n = int as nat
    (output) bit< n > as typeIR | []
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:73.1-84.2
  rulegroup varbit
   match
    (expl-input) p | TC | baseType as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if typeOrVoid <: baseType
    -- let baseType = typeOrVoid as baseType
   paths
  {
    rulepath integer
    (premises)
    -- let baseType' = baseType
    -- if baseType' matches `VARBIT<%>`
    -- let varbit< int > = baseType'
    -- if int <: nat
    -- let n = int as nat
    (output) varbit< n > as typeIR | []

    rulepath expr
    (premises)
    -- let baseType' = baseType
    -- if baseType' matches `VARBIT<(%)>`
    -- let varbit<( expression )> = baseType'
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- Eval_static: p TC |- typedExpressionIR ~> value
    -- let int = $to_number(value)
    -- if int <: nat
    -- let n = int as nat
    (output) varbit< n > as typeIR | []
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:91.1-103.2
  rulegroup prefixedTypeName
   match
    (expl-input) p | TC | prefixedTypeName as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if typeOrVoid <: prefixedTypeName
    -- let prefixedTypeName = typeOrVoid as prefixedTypeName
   paths
  {
    rulepath mono
    (premises)
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR = typeDefIR as typeIR
    (output) typeIR | []

    rulepath poly
    (premises)
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: polyTypeDefIR
    -- let polyTypeDefIR = typeDefIR as polyTypeDefIR
    (output) polyTypeDefIR < [] > as typeIR | []
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:108.1-124.2
  rulegroup specializedType
   match
    (expl-input) p | TC | prefixedTypeName < typeArgumentList' > as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if typeOrVoid <: specializedType
    -- let prefixedTypeName < typeArgumentList' > = typeOrVoid as specializedType
   paths
  {
    rulepath mono
    (premises)
    -- if ( = typeArgumentList')
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR = typeDefIR as typeIR
    (output) typeIR | []

    rulepath poly
    (premises)
    -- let typeArgumentList = typeArgumentList'
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: polyTypeDefIR
    -- let polyTypeDefIR = typeDefIR as polyTypeDefIR
    -- let typeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > = polyTypeDefIR
    -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
    -- TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeIR_arg*{typeIR_arg <- typeIR_arg*} # tid_fresh*{tid_fresh <- tid_fresh*}
    (output) polyTypeDefIR < typeIR_arg*{typeIR_arg <- typeIR_arg*} > as typeIR | tid_fresh*{tid_fresh <- tid_fresh*}
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:129.1-157.2
  rulegroup headerStackType
   match
    (expl-input) p | TC | namedType [ expression_size ] as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if typeOrVoid <: headerStackType
    -- let namedType [ expression_size ] = typeOrVoid as headerStackType
   paths
  {
    rulepath prefixedTypeName
    (premises)
    -- let namedType' = namedType
    -- if namedType' <: prefixedTypeName
    -- let prefixedTypeName = namedType' as prefixedTypeName
    -- Type_ok: p TC |- prefixedTypeName as typeOrVoid : typeIR_base # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- Expr_ok: p TC |- expression_size : typedExpressionIR_size
    -- Eval_static: p TC |- typedExpressionIR_size ~> value_size
    -- let int = $to_number(value_size)
    -- if int <: nat
    -- let n_size = int as nat
    -- let typeIR_stack = tid "T" as typeIR [ n_size ] as typeIR
    -- let polyTypeDefIR_stack = typeIR_stack < ["T"] , [] >
    (output) polyTypeDefIR_stack < [typeIR_base] > as typeIR | []

    rulepath specializedType
    (premises)
    -- let namedType' = namedType
    -- if namedType' <: specializedType
    -- let specializedType = namedType' as specializedType
    -- Type_ok: p TC |- specializedType as typeOrVoid : typeIR_base # tid_fresh*{tid_fresh <- tid_fresh*}
    -- Expr_ok: p TC |- expression_size : typedExpressionIR_size
    -- Eval_static: p TC |- typedExpressionIR_size ~> value_size
    -- let int = $to_number(value_size)
    -- if int <: nat
    -- let n_size = int as nat
    -- let typeIR_stack = tid "T" as typeIR [ n_size ] as typeIR
    -- let polyTypeDefIR_stack = typeIR_stack < ["T"] , [] >
    (output) polyTypeDefIR_stack < [typeIR_base] > as typeIR | tid_fresh*{tid_fresh <- tid_fresh*}
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:162.1-169.57
  rulegroup listType
   match
    (expl-input) p | TC | list< typeArgument > as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if typeOrVoid <: listType
    -- let list< typeArgument > = typeOrVoid as listType
   paths
  {
    rulepath listType
    (premises)
    -- TypeArgument_ok: p TC |- typeArgument : typeIR_arg # tid_fresh*{tid_fresh <- tid_fresh*}
    -- let typeIR_list = list< tid "T" as typeIR > as typeIR
    -- let polyTypeDefIR_list = typeIR_list < ["T"] , [] >
    (output) polyTypeDefIR_list < [typeIR_arg] > as typeIR | tid_fresh*{tid_fresh <- tid_fresh*}
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:174.1-184.67
  rulegroup tupleType
   match
    (expl-input) p | TC | tuple< typeArgumentList > as typeOrVoid
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if typeOrVoid <: tupleType
    -- let tuple< typeArgumentList > = typeOrVoid as tupleType
   paths
  {
    rulepath tupleType
    (premises)
    -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
    -- TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeIR_arg*{typeIR_arg <- typeIR_arg*} # tid_fresh*{tid_fresh <- tid_fresh*}
    -- let i_idx*{i_idx <- i_idx*} = $init_(|typeIR_arg*{typeIR_arg <- typeIR_arg*}|) as int*
    -- (let tid_tparam = "T" ++ $int_to_text(i_idx))*{i_idx <- i_idx*, tid_tparam <- tid_tparam*}
    -- let typeIR_tuple = tuple< tid tid_tparam as typeIR*{tid_tparam <- tid_tparam*} > as typeIR
    -- let polyTypeDefIR_tuple = typeIR_tuple < tid_tparam*{tid_tparam <- tid_tparam*} , [] >
    (output) polyTypeDefIR_tuple < typeIR_arg*{typeIR_arg <- typeIR_arg*} > as typeIR | tid_fresh*{tid_fresh <- tid_fresh*}
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:188.1-189.29
  rulegroup void
   match
    (expl-input) p | TC | void
    (impl-input) p | TC | typeOrVoid
    (impl-input-premises)
    -- if typeOrVoid matches `VOID`
   paths
  {
    rulepath void
    (premises)
    (output) void as typeIR | []
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:19.1-21.23
relation TypeArgument_ok: cursor typingContext |- typeArgument : typeArgumentIR # tid*
  ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:12.1-14.49
  rulegroup type
   match
    (expl-input) p | TC | type as typeArgument
    (impl-input) p | TC | typeArgument
    (impl-input-premises)
    -- if typeArgument <: type
    -- let type = typeArgument as type
   paths
  {
    rulepath type
    (premises)
    -- Type_ok: p TC |- type as typeOrVoid : typeIR # tid_impl*{tid_impl <- tid_impl*}
    (output) typeIR | tid_impl*{tid_impl <- tid_impl*}
  }

  ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:18.1-19.29
  rulegroup void
   match
    (expl-input) p | TC | void as typeArgument
    (impl-input) p | TC | typeArgument
    (impl-input-premises)
    -- if (typeArgument = void as typeArgument)
   paths
  {
    rulepath void
    (premises)
    (output) void as typeArgumentIR | []
  }

  ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:23.1-25.32
  rulegroup dontcare
   match
    (expl-input) p | TC | _ as typeArgument
    (impl-input) p | TC | typeArgument
    (impl-input-premises)
    -- if (typeArgument = _ as typeArgument)
   paths
  {
    rulepath dontcare
    (premises)
    -- let tid_impl = $fresh_tid
    (output) tid tid_impl as typeArgumentIR | [tid_impl]
  }

  ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:29.1-31.33
  rulegroup nonTypeName
   match
    (expl-input) p | TC | nonTypeName as typeArgument
    (impl-input) p | TC | typeArgument
    (impl-input-premises)
    -- if typeArgument <: nonTypeName
    -- let nonTypeName = typeArgument as nonTypeName
   paths
  {
    rulepath nonTypeName
    (premises)
    -- let tid = $name(nonTypeName as name)
    (output) tid tid as typeArgumentIR | []
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:23.1-25.23
relation TypeArguments_ok: cursor typingContext |- typeArgument* : typeArgumentListIR # tid*
  ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:39.1-40.27
  rulegroup nil
   match
    (expl-input) p | TC | []
    (impl-input) p | TC | typeArgument*{typeArgument <- typeArgument*}
    (impl-input-premises)
    -- if typeArgument*{typeArgument <- typeArgument*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) [] | []
  }

  ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:42.1-49.47
  rulegroup cons
   match
    (expl-input) p | TC | typeArgument_h :: typeArgument_t*{}
    (impl-input) p | TC | typeArgument*{typeArgument <- typeArgument*}
    (impl-input-premises)
    -- if typeArgument*{typeArgument <- typeArgument*} matches _ :: _
    -- let typeArgument_h :: typeArgument_t*{typeArgument_t <- typeArgument_t*} = typeArgument*{typeArgument <- typeArgument*}
   paths
  {
    rulepath cons
    (premises)
    -- TypeArgument_ok: p TC |- typeArgument_h : typeArgumentIR_h # tid_impl_h*{tid_impl_h <- tid_impl_h*}
    -- TypeArguments_ok: p TC |- typeArgument_t*{typeArgument_t <- typeArgument_t*} : typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*} # tid_impl_t*{tid_impl_t <- tid_impl_t*}
    -- let tid_impl*{tid_impl <- tid_impl*} = tid_impl_h*{tid_impl_h <- tid_impl_h*} ++ tid_impl_t*{tid_impl_t <- tid_impl_t*}
    (output) typeArgumentIR_h :: typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*} | tid_impl*{tid_impl <- tid_impl*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:31.1-31.54
relation Sub_expl: typeIR <: typeIR
  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:5.1-9.54
  rulegroup 
   match
    (expl-input) typeIR_a | typeIR_b
    (impl-input) typeIR_a | typeIR_b
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let typeIR_a_canon = $canon(typeIR_a)
    -- let typeIR_b_canon = $canon(typeIR_b)
    -- if Sub_expl_canon: typeIR_a_canon <: typeIR_b_canon holds
    (output) 
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:32.1-32.60
relation Sub_expl_canon: typeIR <: typeIR
  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:11.1-13.38
  rulegroup equals
   match
    (expl-input) typeIR_a | typeIR_b
    (impl-input) typeIR_a | typeIR_b
    (impl-input-premises)
   paths
  {
    rulepath equals
    (premises)
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:15.1-18.46
  rulegroup not-equals
   match
    (expl-input) typeIR_a | typeIR_b
    (impl-input) typeIR_a | typeIR_b
    (impl-input-premises)
   paths
  {
    rulepath not-equals
    (premises)
    -- if ~Type_alpha: typeIR_a ~~ typeIR_b holds
    -- if Sub_expl_canon_neq: typeIR_a <: typeIR_b holds
    (output) 
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:33.1-33.64
relation Sub_expl_canon_neq: typeIR <: typeIR
  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:24.1-25.21
  rulegroup boolean-fixbit
   match
    (expl-input) bool as typeIR | bit< 1 > as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if (typeIR = bool as typeIR)
    -- if (typeIR' = bit< 1 > as typeIR)
   paths
  {
    rulepath boolean-fixbit
    (premises)
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:27.1-38.2
  rulegroup arbint
   match
    (expl-input) int as typeIR | typeIR
    (impl-input) typeIR' | typeIR
    (impl-input-premises)
    -- if (typeIR' = int as typeIR)
   paths
  {
    rulepath boolean
    (premises)
    -- if (bool as typeIR = typeIR)
    (output) 

    rulepath fixint
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: numberTypeIR
    -- let numberTypeIR = typeIR'' as numberTypeIR
    -- if numberTypeIR matches `INT<%>`
    -- let int< _nat > = numberTypeIR
    (output) 

    rulepath fixbit
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: numberTypeIR
    -- let numberTypeIR = typeIR'' as numberTypeIR
    -- if numberTypeIR matches `BIT<%>`
    -- let bit< _nat > = numberTypeIR
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:40.1-51.2
  rulegroup fixint
   match
    (expl-input) int< nat > as typeIR | numberTypeIR as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if typeIR <: numberTypeIR
    -- let numberTypeIR' = typeIR as numberTypeIR
    -- if numberTypeIR' matches `INT<%>`
    -- let int< nat > = numberTypeIR'
    -- if typeIR' <: numberTypeIR
    -- let numberTypeIR = typeIR' as numberTypeIR
   paths
  {
    rulepath arbint
    (premises)
    -- let _nat = nat
    -- if (int = numberTypeIR)
    (output) 

    rulepath fixint
    (premises)
    -- let w_a = nat
    -- let numberTypeIR'' = numberTypeIR
    -- if numberTypeIR'' matches `INT<%>`
    -- let int< w_b > = numberTypeIR''
    (output) 

    rulepath fixbit
    (premises)
    -- let w = nat
    -- if (bit< w > = numberTypeIR)
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:53.1-67.2
  rulegroup fixbit
   match
    (expl-input) bit< nat > as typeIR | typeIR
    (impl-input) typeIR' | typeIR
    (impl-input-premises)
    -- if typeIR' <: numberTypeIR
    -- let numberTypeIR = typeIR' as numberTypeIR
    -- if numberTypeIR matches `BIT<%>`
    -- let bit< nat > = numberTypeIR
   paths
  {
    rulepath boolean
    (premises)
    -- if (1 = nat)
    -- if (bool as typeIR = typeIR)
    (output) 

    rulepath arbint
    (premises)
    -- let _nat = nat
    -- if (int as typeIR = typeIR)
    (output) 

    rulepath fixint
    (premises)
    -- let w = nat
    -- if (int< w > as typeIR = typeIR)
    (output) 

    rulepath fixbit
    (premises)
    -- let w_a = nat
    -- let typeIR'' = typeIR
    -- if typeIR'' <: numberTypeIR
    -- let numberTypeIR' = typeIR'' as numberTypeIR
    -- if numberTypeIR' matches `BIT<%>`
    -- let bit< w_b > = numberTypeIR'
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:69.1-79.2
  rulegroup newtype
   match
    (expl-input) typeIR | typeIR'
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
   paths
  {
    rulepath left
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: aliasTypeIR
    -- let aliasTypeIR = typeIR'' as aliasTypeIR
    -- if aliasTypeIR matches `TYPE%%`
    -- let type _tid typeIR_a = aliasTypeIR
    -- let typeIR_b = typeIR'
    -- if Sub_impl: typeIR_a <: typeIR_b holds
    (output) 

    rulepath right
    (premises)
    -- let typeIR_a = typeIR
    -- let typeIR'' = typeIR'
    -- if typeIR'' <: aliasTypeIR
    -- let aliasTypeIR = typeIR'' as aliasTypeIR
    -- if aliasTypeIR matches `TYPE%%`
    -- let type _tid typeIR_b = aliasTypeIR
    -- if Sub_impl: typeIR_a <: typeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:81.1-91.2
  rulegroup serenum
   match
    (expl-input) typeIR | typeIR'
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
   paths
  {
    rulepath left
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: enumTypeIR
    -- let enumTypeIR = typeIR'' as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum _tid # typeIR_a { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
    -- let typeIR_b = typeIR'
    -- if Sub_impl: typeIR_a <: typeIR_b holds
    (output) 

    rulepath right
    (premises)
    -- let typeIR_a = typeIR
    -- let typeIR'' = typeIR'
    -- if typeIR'' <: enumTypeIR
    -- let enumTypeIR = typeIR'' as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum _tid # typeIR_b { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
    -- if Sub_impl: typeIR_a <: typeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:93.1-95.41
  rulegroup default
   match
    (expl-input) default as typeIR | typeIR_b
    (impl-input) typeIR | typeIR_b
    (impl-input-premises)
    -- if (typeIR = default as typeIR)
   paths
  {
    rulepath default
    (premises)
    -- if $is_defaultable_typeIR(typeIR_b)
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:97.1-104.2
  rulegroup invalidheader
   match
    (expl-input) header_invalid as typeIR | typeIR
    (impl-input) typeIR' | typeIR
    (impl-input-premises)
    -- if (typeIR' = header_invalid as typeIR)
   paths
  {
    rulepath header
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerTypeIR
    -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR'' as headerTypeIR
    (output) 

    rulepath headerunion
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerUnionTypeIR
    -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR'' as headerUnionTypeIR
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:106.1-129.2
  rulegroup seq
   match
    (expl-input) seq< typeIR_a*{} > as typeIR | typeIR
    (impl-input) typeIR' | typeIR
    (impl-input-premises)
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
   paths
  {
    rulepath list
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: listTypeIR
    -- let list< typeIR_b > = typeIR'' as listTypeIR
    -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}
    (output) 

    rulepath tuple
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: tupleTypeIR
    -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR'' as tupleTypeIR
    -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 

    rulepath headerstack
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerStackTypeIR
    -- let typeIR_b [ n_size ] = typeIR'' as headerStackTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)
    -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}
    (output) 

    rulepath struct
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: structTypeIR
    -- let struct _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR'' as structTypeIR
    -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 

    rulepath header
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerTypeIR
    -- let header _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR'' as headerTypeIR
    -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:131.1-163.2
  rulegroup seqdefault
   match
    (expl-input) seq< typeIR_a*{} ,...> as typeIR | typeIR
    (impl-input) typeIR' | typeIR
    (impl-input-premises)
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
   paths
  {
    rulepath tuple
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: tupleTypeIR
    -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR'' as tupleTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
    -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
    -- (if Sub_expl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
    (output) 

    rulepath headerstack
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerStackTypeIR
    -- let typeIR_b [ n_size ] = typeIR'' as headerStackTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)
    -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}
    -- if $is_defaultable_typeIR(typeIR_b)
    (output) 

    rulepath struct
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: structTypeIR
    -- let struct _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR'' as structTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
    -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
    -- (if Sub_expl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
    (output) 

    rulepath header
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerTypeIR
    -- let header _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR'' as headerTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
    -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
    -- (if Sub_expl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:165.1-185.2
  rulegroup record
   match
    (expl-input) record{ typeIR_a id_a ;*{} } as typeIR | typeIR
    (impl-input) typeIR' | typeIR
    (impl-input-premises)
    -- if typeIR' <: recordTypeIR
    -- let recordTypeIR = typeIR' as recordTypeIR
    -- if recordTypeIR matches `RECORD{%}`
    -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} } = recordTypeIR
   paths
  {
    rulepath struct
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: structTypeIR
    -- let struct _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR'' as structTypeIR
    -- if $eq_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_a_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR''''? <- typeIR''''?*}
    -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
    -- (let ?(typeIR_b_aligned) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_aligned <- typeIR_b_aligned*}
    -- (if Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}
    (output) 

    rulepath header
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerTypeIR
    -- let header _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR'' as headerTypeIR
    -- if $eq_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_a_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR''''? <- typeIR''''?*}
    -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
    -- (let ?(typeIR_b_aligned) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_aligned <- typeIR_b_aligned*}
    -- (if Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:187.1-219.2
  rulegroup recorddefault
   match
    (expl-input) record{ typeIR_a id_a ;*{} ,...} as typeIR | typeIR
    (impl-input) typeIR' | typeIR
    (impl-input-premises)
    -- if typeIR' <: recordTypeIR
    -- let recordTypeIR = typeIR' as recordTypeIR
    -- if recordTypeIR matches `RECORD{%,...}`
    -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
   paths
  {
    rulepath struct
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: structTypeIR
    -- let struct _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR'' as structTypeIR
    -- if $sub_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_a_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR''''? <- typeIR''''?*}
    -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
    -- (let ?(typeIR_b_non_default_aligned) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- (if Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- let { id_default*{id_default <- id_default*} } = $diff_set<id>({ id_b*{id_b <- id_b*} }, { id_a*{id_a <- id_a*} })
    -- (let typeIR'''''?{typeIR''''' <- typeIR'''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_default))*{id_default <- id_default*, typeIR'''''? <- typeIR'''''?*}
    -- (if typeIR'''''?{typeIR''''' <- typeIR'''''?} matches (_))*{typeIR'''''? <- typeIR'''''?*}
    -- (let ?(typeIR_b_default) = typeIR'''''?{typeIR''''' <- typeIR'''''?})*{typeIR'''''? <- typeIR'''''?*, typeIR_b_default <- typeIR_b_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
    (output) 

    rulepath header
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerTypeIR
    -- let header _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR'' as headerTypeIR
    -- if $sub_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_a_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR''''? <- typeIR''''?*}
    -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
    -- (let ?(typeIR_b_non_default_aligned) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- (if Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- let { id_default*{id_default <- id_default*} } = $diff_set<id>({ id_b*{id_b <- id_b*} }, { id_a*{id_a <- id_a*} })
    -- (let typeIR'''''?{typeIR''''' <- typeIR'''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_default))*{id_default <- id_default*, typeIR'''''? <- typeIR'''''?*}
    -- (if typeIR'''''?{typeIR''''' <- typeIR'''''?} matches (_))*{typeIR'''''? <- typeIR'''''?*}
    -- (let ?(typeIR_b_default) = typeIR'''''?{typeIR''''' <- typeIR'''''?})*{typeIR'''''? <- typeIR'''''?*, typeIR_b_default <- typeIR_b_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:221.1-232.2
  rulegroup set
   match
    (expl-input) typeIR | set< [typeIR_b] > as typeIR
    (impl-input) typeIR | typeIR''
    (impl-input-premises)
    -- if typeIR'' <: setTypeIR
    -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
    -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
    -- let [typeIR_b] = typeIR'*{typeIR' <- typeIR'*}
   paths
  {
    rulepath set
    (premises)
    -- let typeIR'''' = typeIR
    -- if typeIR'''' <: setTypeIR
    -- let set< typeIR'''*{typeIR''' <- typeIR'''*} > = typeIR'''' as setTypeIR
    -- if typeIR'''*{typeIR''' <- typeIR'''*} matches [ _/1 ]
    -- let [typeIR_a] = typeIR'''*{typeIR''' <- typeIR'''*}
    -- if Sub_expl: typeIR_a <: typeIR_b holds
    (output) 

    rulepath non-set
    (premises)
    -- let typeIR_a = typeIR
    -- if ~$is_set_typeIR(typeIR_a)
    -- if Sub_expl: typeIR_a <: typeIR_b holds
    (output) 
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:35.1-35.54
relation Sub_impl: typeIR <: typeIR
  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:238.1-242.54
  rulegroup 
   match
    (expl-input) typeIR_a | typeIR_b
    (impl-input) typeIR_a | typeIR_b
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let typeIR_a_canon = $canon(typeIR_a)
    -- let typeIR_b_canon = $canon(typeIR_b)
    -- if Sub_impl_canon: typeIR_a_canon <: typeIR_b_canon holds
    (output) 
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:36.1-36.60
relation Sub_impl_canon: typeIR <: typeIR
  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:244.1-246.38
  rulegroup equals
   match
    (expl-input) typeIR_a | typeIR_b
    (impl-input) typeIR_a | typeIR_b
    (impl-input-premises)
   paths
  {
    rulepath equals
    (premises)
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:248.1-251.46
  rulegroup not-equals
   match
    (expl-input) typeIR_a | typeIR_b
    (impl-input) typeIR_a | typeIR_b
    (impl-input-premises)
   paths
  {
    rulepath not-equals
    (premises)
    -- if ~Type_alpha: typeIR_a ~~ typeIR_b holds
    -- if Sub_impl_canon_neq: typeIR_a <: typeIR_b holds
    (output) 
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:37.1-37.64
relation Sub_impl_canon_neq: typeIR <: typeIR
  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:257.1-265.2
  rulegroup arbint
   match
    (expl-input) int as typeIR | numberTypeIR as typeIR
    (impl-input) typeIR | typeIR'
    (impl-input-premises)
    -- if (typeIR = int as typeIR)
    -- if typeIR' <: numberTypeIR
    -- let numberTypeIR = typeIR' as numberTypeIR
   paths
  {
    rulepath fixint
    (premises)
    -- let numberTypeIR' = numberTypeIR
    -- if numberTypeIR' matches `INT<%>`
    -- let int< _nat > = numberTypeIR'
    (output) 

    rulepath fixbit
    (premises)
    -- let numberTypeIR' = numberTypeIR
    -- if numberTypeIR' matches `BIT<%>`
    -- let bit< _nat > = numberTypeIR'
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:267.1-269.36
  rulegroup serenum-left
   match
    (expl-input) enum _tid # typeIR_a { _valueFieldIR*{} } as typeIR | typeIR_b
    (impl-input) typeIR | typeIR_b
    (impl-input-premises)
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum _tid # typeIR_a { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
   paths
  {
    rulepath serenum-left
    (premises)
    -- if Sub_impl: typeIR_a <: typeIR_b holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:271.1-273.41
  rulegroup default
   match
    (expl-input) default as typeIR | typeIR_b
    (impl-input) typeIR | typeIR_b
    (impl-input-premises)
    -- if (typeIR = default as typeIR)
   paths
  {
    rulepath default
    (premises)
    -- if $is_defaultable_typeIR(typeIR_b)
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:275.1-282.2
  rulegroup invalidheader
   match
    (expl-input) header_invalid as typeIR | typeIR
    (impl-input) typeIR' | typeIR
    (impl-input-premises)
    -- if (typeIR' = header_invalid as typeIR)
   paths
  {
    rulepath header
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerTypeIR
    -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR'' as headerTypeIR
    (output) 

    rulepath headerunion
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerUnionTypeIR
    -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR'' as headerUnionTypeIR
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:284.1-311.2
  rulegroup seq
   match
    (expl-input) seq< typeIR_a*{} > as typeIR | typeIR
    (impl-input) typeIR' | typeIR
    (impl-input-premises)
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
   paths
  {
    rulepath list
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: listTypeIR
    -- let list< typeIR_b > = typeIR'' as listTypeIR
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}
    (output) 

    rulepath tuple
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: tupleTypeIR
    -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR'' as tupleTypeIR
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 

    rulepath headerstack
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerStackTypeIR
    -- let typeIR_b [ n_size ] = typeIR'' as headerStackTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}
    (output) 

    rulepath struct
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: structTypeIR
    -- let struct _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR'' as structTypeIR
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 

    rulepath header
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerTypeIR
    -- let header _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR'' as headerTypeIR
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 

    rulepath seq
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: sequenceTypeIR
    -- let sequenceTypeIR' = typeIR'' as sequenceTypeIR
    -- if sequenceTypeIR' matches `SEQ<%>`
    -- let seq< typeIR_b*{typeIR_b <- typeIR_b*} > = sequenceTypeIR'
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:313.1-345.2
  rulegroup seqdefault
   match
    (expl-input) seq< typeIR_a*{} ,...> as typeIR | typeIR
    (impl-input) typeIR' | typeIR
    (impl-input-premises)
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
   paths
  {
    rulepath tuple
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: tupleTypeIR
    -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR'' as tupleTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
    -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
    -- (if Sub_impl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
    (output) 

    rulepath stack
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerStackTypeIR
    -- let typeIR_b [ n_size ] = typeIR'' as headerStackTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}
    -- if $is_defaultable_typeIR(typeIR_b)
    (output) 

    rulepath struct
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: structTypeIR
    -- let struct _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR'' as structTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
    -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
    -- (if Sub_impl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
    (output) 

    rulepath header
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerTypeIR
    -- let header _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR'' as headerTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
    -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
    -- (if Sub_impl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:347.1-367.2
  rulegroup record
   match
    (expl-input) record{ typeIR_a id_a ;*{} } as typeIR | typeIR
    (impl-input) typeIR' | typeIR
    (impl-input-premises)
    -- if typeIR' <: recordTypeIR
    -- let recordTypeIR = typeIR' as recordTypeIR
    -- if recordTypeIR matches `RECORD{%}`
    -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} } = recordTypeIR
   paths
  {
    rulepath struct
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: structTypeIR
    -- let struct _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR'' as structTypeIR
    -- if $eq_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_a_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR''''? <- typeIR''''?*}
    -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
    -- (let ?(typeIR_b_aligned) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_aligned <- typeIR_b_aligned*}
    -- (if Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}
    (output) 

    rulepath header
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerTypeIR
    -- let header _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR'' as headerTypeIR
    -- if $eq_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_a_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR''''? <- typeIR''''?*}
    -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
    -- (let ?(typeIR_b_aligned) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_aligned <- typeIR_b_aligned*}
    -- (if Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}
    (output) 
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:369.1-401.2
  rulegroup recorddefault
   match
    (expl-input) record{ typeIR_a id_a ;*{} ,...} as typeIR | typeIR
    (impl-input) typeIR' | typeIR
    (impl-input-premises)
    -- if typeIR' <: recordTypeIR
    -- let recordTypeIR = typeIR' as recordTypeIR
    -- if recordTypeIR matches `RECORD{%,...}`
    -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
   paths
  {
    rulepath struct
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: structTypeIR
    -- let struct _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR'' as structTypeIR
    -- if $sub_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_a_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR''''? <- typeIR''''?*}
    -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
    -- (let ?(typeIR_b_non_default_aligned) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- (if Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- let { id_default*{id_default <- id_default*} } = $diff_set<id>({ id_b*{id_b <- id_b*} }, { id_a*{id_a <- id_a*} })
    -- (let typeIR'''''?{typeIR''''' <- typeIR'''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_default))*{id_default <- id_default*, typeIR'''''? <- typeIR'''''?*}
    -- (if typeIR'''''?{typeIR''''' <- typeIR'''''?} matches (_))*{typeIR'''''? <- typeIR'''''?*}
    -- (let ?(typeIR_b_default) = typeIR'''''?{typeIR''''' <- typeIR'''''?})*{typeIR'''''? <- typeIR'''''?*, typeIR_b_default <- typeIR_b_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
    (output) 

    rulepath header
    (premises)
    -- let typeIR'' = typeIR
    -- if typeIR'' <: headerTypeIR
    -- let header _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR'' as headerTypeIR
    -- if $sub_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_a_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR''''? <- typeIR''''?*}
    -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
    -- (let ?(typeIR_b_non_default_aligned) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- (if Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- let { id_default*{id_default <- id_default*} } = $diff_set<id>({ id_b*{id_b <- id_b*} }, { id_a*{id_a <- id_a*} })
    -- (let typeIR'''''?{typeIR''''' <- typeIR'''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_default))*{id_default <- id_default*, typeIR'''''? <- typeIR'''''?*}
    -- (if typeIR'''''?{typeIR''''' <- typeIR'''''?} matches (_))*{typeIR'''''? <- typeIR'''''?*}
    -- (let ?(typeIR_b_default) = typeIR'''''?{typeIR''''' <- typeIR'''''?})*{typeIR'''''? <- typeIR'''''?*, typeIR_b_default <- typeIR_b_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
    (output) 
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:43.1-45.23
relation Expr_ok: cursor typingContext |- expression : typedExpressionIR
  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:12.1-22.2
  rulegroup literalExpression-boolean
   match
    (expl-input) p | TC | booleanLiteral as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: booleanLiteral
    -- let booleanLiteral = expression as booleanLiteral
   paths
  {
    rulepath true
    (premises)
    -- if (true = booleanLiteral)
    -- let expressionNoteIR = ( bool as typeIR lctk )
    (output) true as expressionIR # expressionNoteIR

    rulepath false
    (premises)
    -- if (false = booleanLiteral)
    -- let expressionNoteIR = ( bool as typeIR lctk )
    (output) false as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:26.1-40.2
  rulegroup literalExpression-number
   match
    (expl-input) p | TC | numberLiteral as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: numberLiteral
    -- let numberLiteral = expression as numberLiteral
   paths
  {
    rulepath literalExpression-number-arbint
    (premises)
    -- let numberLiteral' = numberLiteral
    -- if numberLiteral' matches `D%`
    -- let d i = numberLiteral'
    -- let expressionNoteIR = ( int as typeIR lctk )
    (output) d i as expressionIR # expressionNoteIR

    rulepath literalExpression-number-fixint
    (premises)
    -- let numberLiteral' = numberLiteral
    -- if numberLiteral' matches `%S%`
    -- let n s i = numberLiteral'
    -- let expressionNoteIR = ( int< n > as typeIR lctk )
    (output) n s i as expressionIR # expressionNoteIR

    rulepath literalExpression-number-fixbit
    (premises)
    -- let numberLiteral' = numberLiteral
    -- if numberLiteral' matches `%W%`
    -- let n w i = numberLiteral'
    -- let expressionNoteIR = ( bit< n > as typeIR lctk )
    (output) n w i as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:44.1-46.44
  rulegroup literalExpression-stringliteral
   match
    (expl-input) p | TC | " text " as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: stringLiteral
    -- let " text " = expression as stringLiteral
   paths
  {
    rulepath literalExpression-stringliteral
    (premises)
    -- let expressionNoteIR = ( string as typeIR lctk )
    (output) " text " as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:54.1-68.2
  rulegroup referenceExpression
   match
    (expl-input) p | TC | expression
    (impl-input) p | TC | expression
    (impl-input-premises)
   paths
  {
    rulepath prefixedNonTypeName
    (premises)
    -- let expression' = expression
    -- if expression' <: prefixedNonTypeName
    -- let prefixedNonTypeName = expression' as prefixedNonTypeName
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedNameIR)
    -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
    -- let ?(_direction typeIR ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
    -- let expressionNoteIR = ( typeIR ctk )
    (output) prefixedNameIR as expressionIR # expressionNoteIR

    rulepath this
    (premises)
    -- if (this as expression = expression)
    -- let prefixedNameIR = ` "this"
    -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedNameIR)
    -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
    -- let ?(_direction typeIR ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
    -- let expressionNoteIR = ( typeIR ctk )
    (output) prefixedNameIR as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:72.1-74.45
  rulegroup defaultExpression
   match
    (expl-input) p | TC | ... as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if (expression = ... as expression)
   paths
  {
    rulepath defaultExpression
    (premises)
    -- let expressionNoteIR = ( default as typeIR lctk )
    (output) ... as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:88.1-97.58
  rulegroup unaryExpression-lnot
   match
    (expl-input) p | TC | ! expression as expression
    (impl-input) p | TC | expression'
    (impl-input-premises)
    -- if expression' <: unaryExpression
    -- let unop expression = expression' as unaryExpression
    -- if unop matches `!`
   paths
  {
    rulepath unaryExpression-lnot
    (premises)
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_lnot)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    -- let _expressionIR # expressionNoteIR = typedExpressionIR_reduced
    (output) ! typedExpressionIR_reduced as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:110.1-119.58
  rulegroup unaryExpression-bnot
   match
    (expl-input) p | TC | ~ expression as expression
    (impl-input) p | TC | expression'
    (impl-input-premises)
    -- if expression' <: unaryExpression
    -- let unop expression = expression' as unaryExpression
    -- if unop matches `~`
   paths
  {
    rulepath unaryExpression-bnot
    (premises)
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_bnot)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    -- let _expressionIR # expressionNoteIR = typedExpressionIR_reduced
    (output) ~ typedExpressionIR_reduced as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:133.1-143.58
  rulegroup unaryExpression-uplusminus
   match
    (expl-input) p | TC | unop expression as expression
    (impl-input) p | TC | expression'
    (impl-input-premises)
    -- if expression' <: unaryExpression
    -- let unop expression = expression' as unaryExpression
   paths
  {
    rulepath unaryExpression-uplusminus
    (premises)
    -- if ((unop = +) \/ (unop = -))
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_uplusminus)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    -- let _expressionIR # expressionNoteIR = typedExpressionIR_reduced
    (output) unop typedExpressionIR_reduced as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:160.1-182.59
  rulegroup binaryExpression-plusminusmult
   match
    (expl-input) p | TC | expression_l binop expression_r as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
   paths
  {
    rulepath binaryExpression-plusminusmult
    (premises)
    -- if binop <- [+, -, *]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_plusminusmult)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
    (output) typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:196.1-218.59
  rulegroup binaryExpression-satplusminus
   match
    (expl-input) p | TC | expression_l binop expression_r as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
   paths
  {
    rulepath binaryExpression-satplusminus
    (premises)
    -- if binop <- [|+|, |-|]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_satplusminus)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
    (output) typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:231.1-289.2
  rulegroup binaryExpression-divmod
   match
    (expl-input) p | TC | expression_l binop expression_r as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
   paths
  {
    rulepath rhs-lctk
    (premises)
    -- if binop <- [/, %]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if (ctk_r_reduced = lctk)
    -- Eval_static: p TC |- typedExpressionIR_r_reduced ~> value_r
    -- let int = $to_number(value_r)
    -- if int <: nat
    -- let n_r = int as nat
    -- if (n_r > 0)
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
    (output) typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR

    rulepath rhs-non-lctk
    (premises)
    -- if binop <- [/, %]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if (ctk_r_reduced =/= lctk)
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
    (output) typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:310.1-362.2
  rulegroup binaryExpression-shift
   match
    (expl-input) p | TC | expression_l binop expression_r as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
   paths
  {
    rulepath rhs-fixbit
    (premises)
    -- if binop <- [<<, >>]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let _expressionIR # ( typeIR_l_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( typeIR_r_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if $is_fixed_bit_typeIR(typeIR_r_reduced)
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_l_reduced ctk_reduced )
    (output) typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR

    rulepath rhs-non-fixbit
    (premises)
    -- if binop <- [<<, >>]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let _expressionIR # ( typeIR_l_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( typeIR_r_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if (ctk_r_reduced = lctk)
    -- if ($is_arbitrary_int_typeIR(typeIR_r_reduced) \/ $is_fixed_int_typeIR(typeIR_r_reduced))
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_l_reduced ctk_reduced )
    (output) typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:366.1-384.46
  rulegroup binaryExpression-eq
   match
    (expl-input) p | TC | expression_l binop expression_r as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
   paths
  {
    rulepath binaryExpression-eq
    (premises)
    -- if binop <- [==, !=]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let _expressionIR # ( typeIR_cast ctk_l_cast ) = typedExpressionIR_l_cast
    -- let _expressionIR' # ( _typeIR ctk_r_cast ) = typedExpressionIR_r_cast
    -- if $is_equalable_typeIR(typeIR_cast)
    -- let ctk_cast = $join_ctk(ctk_l_cast, ctk_r_cast)
    -- let expressionNoteIR = ( bool as typeIR ctk_cast )
    (output) typedExpressionIR_l_cast binop typedExpressionIR_r_cast as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:399.1-421.49
  rulegroup binaryExpression-compare
   match
    (expl-input) p | TC | expression_l binop expression_r as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
   paths
  {
    rulepath binaryExpression-compare
    (premises)
    -- if binop <- [<=, >=, <, >]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_compare)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( bool as typeIR ctk_reduced )
    (output) typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:435.1-457.59
  rulegroup binaryExpression-bitwise
   match
    (expl-input) p | TC | expression_l binop expression_r as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
   paths
  {
    rulepath binaryExpression-bitwise
    (premises)
    -- if binop <- [&, ^, |]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_bitwise)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
    (output) typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:485.1-507.59
  rulegroup binaryExpression-concat
   match
    (expl-input) p | TC | expression_l ++ expression_r as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
    -- if binop matches `++`
   paths
  {
    rulepath binaryExpression-concat
    (premises)
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_concat)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let _expressionIR # ( typeIR_l_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( typeIR_r_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- let typeIR?{typeIR <- typeIR?} = $result_concat(typeIR_l_reduced, typeIR_r_reduced)
    -- if typeIR?{typeIR <- typeIR?} matches (_)
    -- let ?(typeIR_reduced) = typeIR?{typeIR <- typeIR?}
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
    (output) typedExpressionIR_l_reduced ++ typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:520.1-542.59
  rulegroup binaryExpression-logical
   match
    (expl-input) p | TC | expression_l binop expression_r as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
   paths
  {
    rulepath binaryExpression-logical
    (premises)
    -- if binop <- [&&, ||]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_logical)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
    (output) typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:548.1-569.48
  rulegroup ternaryExpression
   match
    (expl-input) p | TC | expression_cond ? expression_true : expression_false as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: ternaryExpression
    -- let expression_cond ? expression_true : expression_false = expression as ternaryExpression
   paths
  {
    rulepath ternaryExpression
    (premises)
    -- Expr_ok: p TC |- expression_cond : typedExpressionIR_cond
    -- let _expressionIR # ( typeIR ctk_cond ) = typedExpressionIR_cond
    -- if (typeIR = bool as typeIR)
    -- Expr_ok: p TC |- expression_true : typedExpressionIR_true
    -- Expr_ok: p TC |- expression_false : typedExpressionIR_false
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_true, typedExpressionIR_false)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_true_cast, typedExpressionIR_false_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let _expressionIR' # ( typeIR_cast ctk_true_cast ) = typedExpressionIR_true_cast
    -- let _expressionIR'' # ( _typeIR ctk_false_cast ) = typedExpressionIR_false_cast
    -- if ($is_arbitrary_int_typeIR(typeIR_cast) => (ctk_cond =/= dyn))
    -- let ctk = $joins_ctk([ctk_cond, ctk_true_cast, ctk_false_cast])
    -- let expressionNoteIR = ( typeIR_cast ctk )
    (output) typedExpressionIR_cond ? typedExpressionIR_true_cast : typedExpressionIR_false_cast as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:574.1-587.45
  rulegroup castExpression
   match
    (expl-input) p | TC | ( type_t ) expression as expression
    (impl-input) p | TC | expression'
    (impl-input-premises)
    -- if expression' <: castExpression
    -- let ( type_t ) expression = expression' as castExpression
   paths
  {
    rulepath castExpression
    (premises)
    -- Type_ok: p TC |- type_t as typeOrVoid : typeIR_t # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(p, TC) |- typeIR_t holds
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
    -- if Sub_expl: typeIR <: typeIR_t holds
    -- let expressionNoteIR = ( typeIR_t ctk )
    (output) ( typeIR_t ) typedExpressionIR as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:594.1-596.52
  rulegroup dataExpression-invalid
   match
    (expl-input) p | TC | {#} as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if (expression = {#} as expression)
   paths
  {
    rulepath dataExpression-invalid
    (premises)
    -- let expressionNoteIR = ( header_invalid as typeIR lctk )
    (output) {#} as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:604.1-640.2
  rulegroup dataExpression-sequenceElementExpression
   match
    (expl-input) p | TC | { expressionList as dataElementExpression _trailingCommaOpt } as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: dataExpression
    -- let dataExpression = expression as dataExpression
    -- if dataExpression matches `{%%}`
    -- let { dataElementExpression _trailingCommaOpt } = dataExpression
    -- if dataElementExpression <: expressionList
    -- let expressionList = dataElementExpression as expressionList
   paths
  {
    rulepath non-default
    (premises)
    -- let expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList)
    -- if ~... as expression <- expression_e*{expression_e <- expression_e*}
    -- if (expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList))
    -- (Expr_ok: p TC |- expression_e : typedExpressionIR_e)*{expression_e <- expression_e*, typedExpressionIR_e <- typedExpressionIR_e*}
    -- (let _expressionIR # ( typeIR_e ctk_e ) = typedExpressionIR_e)*{_expressionIR <- _expressionIR*, ctk_e <- ctk_e*, typeIR_e <- typeIR_e*, typedExpressionIR_e <- typedExpressionIR_e*}
    -- let typeIR = seq< typeIR_e*{typeIR_e <- typeIR_e*} > as typeIR
    -- let ctk = $joins_ctk(ctk_e*{ctk_e <- ctk_e*})
    -- let expressionNoteIR = ( typeIR ctk )
    (output) seq{ typedExpressionIR_e*{typedExpressionIR_e <- typedExpressionIR_e*} } as expressionIR # expressionNoteIR

    rulepath default
    (premises)
    -- let expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList)
    -- if ... as expression <- expression_e*{expression_e <- expression_e*}
    -- let expression''*{expression'' <- expression''*} = $rev_<expression>(expression_e*{expression_e <- expression_e*})
    -- if expression''*{expression'' <- expression''*} matches _ :: _
    -- let expression' :: expression_e_h_rev*{expression_e_h_rev <- expression_e_h_rev*} = expression''*{expression'' <- expression''*}
    -- if (expression' = ... as expression)
    -- let expression_e_h*{expression_e_h <- expression_e_h*} = $rev_<expression>(expression_e_h_rev*{expression_e_h_rev <- expression_e_h_rev*})
    -- if ~... as expression <- expression_e_h*{expression_e_h <- expression_e_h*}
    -- (Expr_ok: p TC |- expression_e_h : typedExpressionIR_e_h)*{expression_e_h <- expression_e_h*, typedExpressionIR_e_h <- typedExpressionIR_e_h*}
    -- (let _expressionIR # ( typeIR_e_h ctk_e_h ) = typedExpressionIR_e_h)*{_expressionIR <- _expressionIR*, ctk_e_h <- ctk_e_h*, typeIR_e_h <- typeIR_e_h*, typedExpressionIR_e_h <- typedExpressionIR_e_h*}
    -- let typeIR = seq< typeIR_e_h*{typeIR_e_h <- typeIR_e_h*} ,...> as typeIR
    -- let ctk = $joins_ctk(ctk_e_h*{ctk_e_h <- ctk_e_h*})
    -- let expressionNoteIR = ( typeIR ctk )
    (output) seq{ typedExpressionIR_e_h*{typedExpressionIR_e_h <- typedExpressionIR_e_h*} ,...} as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:650.1-714.2
  rulegroup dataExpression-recordElementExpression
   match
    (expl-input) p | TC | { recordElementExpression as dataElementExpression _trailingCommaOpt } as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: dataExpression
    -- let dataExpression = expression as dataExpression
    -- if dataExpression matches `{%%}`
    -- let { dataElementExpression _trailingCommaOpt } = dataExpression
    -- if dataElementExpression <: recordElementExpression
    -- let recordElementExpression = dataElementExpression as recordElementExpression
   paths
  {
    rulepath single-non-default
    (premises)
    -- let recordElementExpression' = recordElementExpression
    -- if recordElementExpression' matches `%=%`
    -- let name_f = expression_f = recordElementExpression'
    -- let nameIR_f = $name(name_f)
    -- Expr_ok: p TC |- expression_f : typedExpressionIR_f
    -- let _expressionIR # ( typeIR_f ctk_f ) = typedExpressionIR_f
    -- let typeIR = record{ [typeIR_f nameIR_f ;] } as typeIR
    -- let expressionNoteIR = ( typeIR ctk_f )
    (output) record{ [nameIR_f = typedExpressionIR_f] } as expressionIR # expressionNoteIR

    rulepath single-default
    (premises)
    -- let recordElementExpression' = recordElementExpression
    -- if recordElementExpression' matches `%=%,...`
    -- let name_f = expression_f ,... = recordElementExpression'
    -- let nameIR_f = $name(name_f)
    -- Expr_ok: p TC |- expression_f : typedExpressionIR_f
    -- let _expressionIR # ( typeIR_f ctk_f ) = typedExpressionIR_f
    -- let typeIR = record{ [typeIR_f nameIR_f ;] ,...} as typeIR
    -- let expressionNoteIR = ( typeIR ctk_f )
    (output) record{ [nameIR_f = typedExpressionIR_f] ,...} as expressionIR # expressionNoteIR

    rulepath multiple-non-default
    (premises)
    -- let recordElementExpression' = recordElementExpression
    -- if recordElementExpression' matches `%=%,%`
    -- let name_f_h = expression_f_h , namedExpressionList_t = recordElementExpression'
    -- let name_f_t = expression_f_t*{expression_f_t <- expression_f_t*, name_f_t <- name_f_t*} = $flatten_namedExpressionList(namedExpressionList_t)
    -- let name_f*{name_f <- name_f*} = name_f_h :: name_f_t*{name_f_t <- name_f_t*}
    -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
    -- let expression_f*{expression_f <- expression_f*} = expression_f_h :: expression_f_t*{expression_f_t <- expression_f_t*}
    -- (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}
    -- (let _expressionIR # ( typeIR_f ctk_f ) = typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}
    -- let typeIR = record{ typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } as typeIR
    -- let ctk = $joins_ctk(ctk_f*{ctk_f <- ctk_f*})
    -- let expressionNoteIR = ( typeIR ctk )
    (output) record{ nameIR_f = typedExpressionIR_f*{nameIR_f <- nameIR_f*, typedExpressionIR_f <- typedExpressionIR_f*} } as expressionIR # expressionNoteIR

    rulepath multiple-default
    (premises)
    -- let recordElementExpression' = recordElementExpression
    -- if recordElementExpression' matches `%=%,%,...`
    -- let name_f_h = expression_f_h , namedExpressionList_t ,... = recordElementExpression'
    -- let name_f_t = expression_f_t*{expression_f_t <- expression_f_t*, name_f_t <- name_f_t*} = $flatten_namedExpressionList(namedExpressionList_t)
    -- let name_f*{name_f <- name_f*} = name_f_h :: name_f_t*{name_f_t <- name_f_t*}
    -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
    -- let expression_f*{expression_f <- expression_f*} = expression_f_h :: expression_f_t*{expression_f_t <- expression_f_t*}
    -- (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}
    -- (let _expressionIR # ( typeIR_f ctk_f ) = typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}
    -- let typeIR = record{ typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} ,...} as typeIR
    -- let ctk = $joins_ctk(ctk_f*{ctk_f <- ctk_f*})
    -- let expressionNoteIR = ( typeIR ctk )
    (output) record{ nameIR_f = typedExpressionIR_f*{nameIR_f <- nameIR_f*, typedExpressionIR_f <- typedExpressionIR_f*} ,...} as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:722.1-729.43
  rulegroup accessExpression-errorAccessExpression
   match
    (expl-input) p | TC | error. member as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: errorAccessExpression
    -- let error. member = expression as errorAccessExpression
   paths
  {
    rulepath accessExpression-errorAccessExpression
    (premises)
    -- let nameIR = $name(member)
    -- let nameIR_error = "error." ++ nameIR
    -- if (error. nameIR as value = $find_value(p, TC, ` nameIR_error))
    -- let expressionNoteIR = ( error as typeIR lctk )
    (output) error. nameIR as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:737.1-767.2
  rulegroup accessExpression-memberAccessExpression-prefixedTypeName
   match
    (expl-input) p | TC | prefixedTypeName_base as memberAccessBase . member as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: memberAccessExpression
    -- let memberAccessBase . member = expression as memberAccessExpression
    -- if memberAccessBase <: prefixedTypeName
    -- let prefixedTypeName_base = memberAccessBase as prefixedTypeName
   paths
  {
    rulepath enum
    (premises)
    -- let prefixedNameIR_base = $prefixedTypeName(prefixedTypeName_base)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR_base)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR_base = typeDefIR as typeIR
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%{%}`
    -- let enum _tid { nameIR_f*{nameIR_f <- nameIR_f*} } = enumTypeIR
    -- let nameIR = $name(member)
    -- if nameIR <- nameIR_f*{nameIR_f <- nameIR_f*}
    -- let expressionNoteIR = ( typeIR_base lctk )
    (output) type prefixedNameIR_base . nameIR as expressionIR # expressionNoteIR

    rulepath serenum
    (premises)
    -- let prefixedNameIR_base = $prefixedTypeName(prefixedTypeName_base)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR_base)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR_base = typeDefIR as typeIR
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum _tid # _typeIR { nameIR_f = _value ;*{_value <- _value*, nameIR_f <- nameIR_f*} } = enumTypeIR
    -- let nameIR = $name(member)
    -- if nameIR <- nameIR_f*{nameIR_f <- nameIR_f*}
    -- let expressionNoteIR = ( typeIR_base lctk )
    (output) type prefixedNameIR_base . nameIR as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:771.1-898.2
  rulegroup accessExpression-memberAccessExpression-expression
   match
    (expl-input) p | TC | expression_base as memberAccessBase . member as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: memberAccessExpression
    -- let memberAccessBase . member = expression as memberAccessExpression
    -- if memberAccessBase <: expression
    -- let expression_base = memberAccessBase as expression
   paths
  {
    rulepath headerstack-size
    (premises)
    -- if ("size" = $name(member))
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- let expressionNoteIR = ( bit< 32 > as typeIR lctk )
    (output) typedExpressionIR_base as memberAccessBaseIR . "size" as expressionIR # expressionNoteIR

    rulepath headerstack-lastIndex
    (premises)
    -- if ("lastIndex" = $name(member))
    -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- let expressionNoteIR = ( bit< 32 > as typeIR dyn )
    (output) typedExpressionIR_base as memberAccessBaseIR . "lastIndex" as expressionIR # expressionNoteIR

    rulepath headerstack-last
    (premises)
    -- if ("last" = $name(member))
    -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- let expressionNoteIR = ( typeIR dyn )
    (output) typedExpressionIR_base as memberAccessBaseIR . "last" as expressionIR # expressionNoteIR

    rulepath headerstack-next
    (premises)
    -- if ("next" = $name(member))
    -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- let expressionNoteIR = ( typeIR dyn )
    (output) typedExpressionIR_base as memberAccessBaseIR . "next" as expressionIR # expressionNoteIR

    rulepath struct
    (premises)
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as structTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let expressionNoteIR = ( typeIR dyn )
    (output) typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # expressionNoteIR

    rulepath header
    (premises)
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as headerTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let expressionNoteIR = ( typeIR dyn )
    (output) typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # expressionNoteIR

    rulepath headerunion
    (premises)
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerUnionTypeIR
    -- let header_union _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as headerUnionTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let expressionNoteIR = ( typeIR dyn )
    (output) typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # expressionNoteIR

    rulepath tablestruct
    (premises)
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: tableTypeIR
    -- let tableTypeIR = typeIR' as tableTypeIR
    -- if tableTypeIR matches `TABLE_STRUCT%{%}`
    -- let table_struct _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = tableTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let expressionNoteIR = ( typeIR dyn )
    (output) typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:916.1-996.2
  rulegroup indexAccessExpression-index
   match
    (expl-input) p | TC | expression_base [ expression_index ] as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: indexAccessExpression
    -- let indexAccessExpression = expression as indexAccessExpression
    -- if indexAccessExpression matches `%[%]`
    -- let expression_base [ expression_index ] = indexAccessExpression
   paths
  {
    rulepath tuple
    (premises)
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
    -- let _expressionIR # ( typeIR_base ctk_base ) = typedExpressionIR_base
    -- let _expressionIR' # ( typeIR_index ctk_index ) = typedExpressionIR_index
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: tupleTypeIR
    -- let tuple< typeIR_e*{typeIR_e <- typeIR_e*} > = typeIR' as tupleTypeIR
    -- if (ctk_index = lctk)
    -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
    -- let int = $to_number(value_index)
    -- if int <: nat
    -- let n_index = int as nat
    -- if (n_index < |typeIR_e*{typeIR_e <- typeIR_e*}|)
    -- let expressionNoteIR = ( typeIR_e*{typeIR_e <- typeIR_e*}[n_index] dyn )
    (output) typedExpressionIR_base [ typedExpressionIR_index_reduced ] as expressionIR # expressionNoteIR

    rulepath headerstack-lctk
    (premises)
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
    -- let _expressionIR # ( typeIR_base ctk_base ) = typedExpressionIR_base
    -- let _expressionIR' # ( typeIR_index ctk_index ) = typedExpressionIR_index
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- if (ctk_index = lctk)
    -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
    -- let int = $to_number(value_index)
    -- if int <: nat
    -- let n_index = int as nat
    -- if (n_index < n_size)
    -- let expressionNoteIR = ( typeIR dyn )
    (output) typedExpressionIR_base [ typedExpressionIR_index_reduced ] as expressionIR # expressionNoteIR

    rulepath headerstack-non-lctk
    (premises)
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
    -- let _expressionIR # ( typeIR_base ctk_base ) = typedExpressionIR_base
    -- let _expressionIR' # ( typeIR_index ctk_index ) = typedExpressionIR_index
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- if (ctk_index =/= lctk)
    -- let expressionNoteIR = ( typeIR dyn )
    (output) typedExpressionIR_base [ typedExpressionIR_index_reduced ] as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1037.1-1084.56
  rulegroup indexAccessExpression-bitslice
   match
    (expl-input) p | TC | expression_base [ expression_hi : expression_lo ] as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: indexAccessExpression
    -- let indexAccessExpression = expression as indexAccessExpression
    -- if indexAccessExpression matches `%[%:%]`
    -- let expression_base [ expression_hi : expression_lo ] = indexAccessExpression
   paths
  {
    rulepath indexAccessExpression-bitslice
    (premises)
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- Expr_ok: p TC |- expression_hi : typedExpressionIR_hi
    -- Expr_ok: p TC |- expression_lo : typedExpressionIR_lo
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_base, $compat_bitslice_base)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_base_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let _expressionIR # ( typeIR_base_reduced ctk_base_reduced ) = typedExpressionIR_base_reduced
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_hi_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    -- let typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} = $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index)
    -- if typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} matches (_)
    -- let ?(typedExpressionIR_lo_reduced) = typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?}
    -- let _expressionIR' # ( typeIR_hi_reduced ctk_hi_reduced ) = typedExpressionIR_hi_reduced
    -- let _expressionIR'' # ( typeIR_lo_reduced ctk_lo_reduced ) = typedExpressionIR_lo_reduced
    -- if (ctk_hi_reduced = lctk)
    -- Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi
    -- let int = $to_number(value_hi)
    -- if int <: nat
    -- let n_hi = int as nat
    -- if (ctk_lo_reduced = lctk)
    -- Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo
    -- let int' = $to_number(value_lo)
    -- if int' <: nat
    -- let n_lo = int' as nat
    -- if $is_valid_bitslice(typeIR_base_reduced, n_lo, n_hi)
    -- let typeIR = bit< ((n_hi - n_lo) + 1) > as typeIR
    -- let expressionNoteIR = ( typeIR ctk_base_reduced )
    (output) typedExpressionIR_base [ typedExpressionIR_hi_reduced : typedExpressionIR_lo_reduced ] as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1092.1-1148.2
  rulegroup callExpression-routineTarget
   match
    (expl-input) p | TC | callExpression as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: callExpression
    -- let callExpression = expression as callExpression
   paths
  {
    rulepath non-typeArgumentList
    (premises)
    -- let callExpression' = callExpression
    -- if callExpression' matches `%(%)`
    -- let callTarget ( argumentList ) = callExpression'
    -- if callTarget <: routineTarget
    -- let routineTarget = callTarget as routineTarget
    -- RoutineTarget_ok: p TC |- routineTarget : routineTargetIR
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- RoutineType_ok: p TC |- routineTargetIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- let tid_infer*{tid_infer <- tid_infer*} = tid_inserted*{tid_inserted <- tid_inserted*}
    -- Call_ok: p TC |- routineTypeIR < [] # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if (typeIR_ret =/= void as typeIR)
    -- let ctk = $is_static_routineTarget(routineTargetIR)
    -- let callExpressionIR = routineTargetIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let expressionNoteIR = ( typeIR_ret ctk )
    (output) callExpressionIR as expressionIR # expressionNoteIR

    rulepath typeArgumentList
    (premises)
    -- let callExpression' = callExpression
    -- if callExpression' matches `%<%>(%)`
    -- let routineTarget < realTypeArgumentList >( argumentList ) = callExpression'
    -- RoutineTarget_ok: p TC |- routineTarget : routineTargetIR
    -- let realTypeArgument*{realTypeArgument <- realTypeArgument*} = $flatten_realTypeArgumentList(realTypeArgumentList)
    -- TypeArguments_ok: p TC |- realTypeArgument*{realTypeArgument <- realTypeArgument*} as typeArgument* : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
    -- Call_ok: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if (typeIR_ret =/= void as typeIR)
    -- let ctk = $is_static_routineTarget(routineTargetIR)
    -- let callExpressionIR = routineTargetIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let expressionNoteIR = ( typeIR_ret ctk )
    (output) callExpressionIR as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1181.1-1230.2
  rulegroup callExpression-constructorTarget
   match
    (expl-input) p | TC | callTarget ( argumentList ) as expression
    (impl-input) p | TC | expression
    (impl-input-premises)
    -- if expression <: callExpression
    -- let callExpression = expression as callExpression
    -- if callExpression matches `%(%)`
    -- let callTarget ( argumentList ) = callExpression
   paths
  {
    rulepath prefixedTypeName
    (premises)
    -- let callTarget' = callTarget
    -- if callTarget' <: prefixedTypeName
    -- let prefixedTypeName = callTarget' as prefixedTypeName
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- ConstructorType_ok: p TC |- prefixedNameIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
    -- Inst_ok: p TC anon |- constructorTypeIR < [] # tid_impl*{tid_impl <- tid_impl*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if $is_concrete_extern_object(typeIR_object)
    -- let callExpressionIR = prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} > ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let expressionNoteIR = ( typeIR_object ctk )
    (output) callExpressionIR as expressionIR # expressionNoteIR

    rulepath specializedType
    (premises)
    -- let callTarget' = callTarget
    -- if callTarget' <: specializedType
    -- let prefixedTypeName < typeArgumentList > = callTarget' as specializedType
    -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
    -- TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- ConstructorType_ok: p TC |- prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
    -- Inst_ok: p TC anon |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if $is_concrete_extern_object(typeIR_object)
    -- let callExpressionIR = prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} > ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let expressionNoteIR = ( typeIR_object ctk )
    (output) callExpressionIR as expressionIR # expressionNoteIR
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1235.1-1238.50
  rulegroup parenthesizedExpression
   match
    (expl-input) p | TC | ( expression ) as expression
    (impl-input) p | TC | expression'
    (impl-input-premises)
    -- if expression' <: parenthesizedExpression
    -- let ( expression ) = expression' as parenthesizedExpression
   paths
  {
    rulepath parenthesizedExpression
    (premises)
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- let _expressionIR # expressionNoteIR = typedExpressionIR
    (output) ( typedExpressionIR ) as expressionIR # expressionNoteIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:51.1-53.23
relation Argument_ok: cursor typingContext |- argument : argumentIR
  ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:9.1-11.53
  rulegroup expression
   match
    (expl-input) p | TC | expression as argument
    (impl-input) p | TC | argument
    (impl-input-premises)
    -- if argument <: expression
    -- let expression = argument as expression
   paths
  {
    rulepath expression
    (premises)
    -- Expr_ok: p TC |- expression : typedExpressionIR
    (output) typedExpressionIR as argumentIR
  }

  ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:15.1-18.53
  rulegroup name-expression
   match
    (expl-input) p | TC | name = expression
    (impl-input) p | TC | argument
    (impl-input-premises)
    -- if argument matches `%=%`
    -- let name = expression = argument
   paths
  {
    rulepath name-expression
    (premises)
    -- let nameIR = $name(name)
    -- Expr_ok: p TC |- expression : typedExpressionIR
    (output) nameIR = typedExpressionIR
  }

  ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:22.1-24.29
  rulegroup name-dontcare
   match
    (expl-input) p | TC | name =_
    (impl-input) p | TC | argument
    (impl-input-premises)
    -- if argument matches `%=_`
    -- let name =_ = argument
   paths
  {
    rulepath name-dontcare
    (premises)
    -- let nameIR = $name(name)
    (output) nameIR =_
  }

  ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:28.1-29.18
  rulegroup dontcare
   match
    (expl-input) p | TC | _
    (impl-input) p | TC | argument
    (impl-input-premises)
    -- if argument matches `_`
   paths
  {
    rulepath dontcare
    (premises)
    (output) _
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:59.1-61.23
relation Lvalue_ok: cursor typingContext |- lvalue : typedLvalueIR
  ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:12.1-16.45
  rulegroup referenceExpression-prefixedNonTypeName
   match
    (expl-input) p | TC | prefixedNonTypeName as lvalue
    (impl-input) p | TC | lvalue
    (impl-input-premises)
    -- if lvalue <: prefixedNonTypeName
    -- let prefixedNonTypeName = lvalue as prefixedNonTypeName
   paths
  {
    rulepath referenceExpression-prefixedNonTypeName
    (premises)
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedNameIR)
    -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
    -- let ?(direction typeIR ctk value?{value <- value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
    -- if ctk matches `DYN`
    -- if value?{value <- value?} matches ()
    -- if ((direction = out) \/ (direction = inout))
    (output) prefixedNameIR as lvalueIR #( typeIR )
  }

  ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:23.1-84.2
  rulegroup lvalue-member
   match
    (expl-input) p | TC | lvalue_base . member
    (impl-input) p | TC | lvalue
    (impl-input-premises)
    -- if lvalue matches `%.%`
    -- let lvalue_base . member = lvalue
   paths
  {
    rulepath headerstack-next-last
    (premises)
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR
    -- let nameIR = $name(member)
    -- if ((nameIR = "next") \/ (nameIR = "last"))
    -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
    -- let typedLvalueIR = typedLvalueIR_base . nameIR #( typeIR )
    (output) typedLvalueIR

    rulepath struct
    (premises)
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as structTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let typedLvalueIR = typedLvalueIR_base . nameIR #( typeIR )
    (output) typedLvalueIR

    rulepath header
    (premises)
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as headerTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let typedLvalueIR = typedLvalueIR_base . nameIR #( typeIR )
    (output) typedLvalueIR

    rulepath headerunion
    (premises)
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerUnionTypeIR
    -- let header_union _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as headerUnionTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let typedLvalueIR = typedLvalueIR_base . nameIR #( typeIR )
    (output) typedLvalueIR
  }

  ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:88.1-141.2
  rulegroup lvalue-expression
   match
    (expl-input) p | TC | lvalue_base [ expression_index ]
    (impl-input) p | TC | lvalue
    (impl-input-premises)
    -- if lvalue matches `%[%]`
    -- let lvalue_base [ expression_index ] = lvalue
   paths
  {
    rulepath index-lctk
    (premises)
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
    -- let _expressionIR # ( typeIR_index ctk_index ) = typedExpressionIR_index
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- if (ctk_index = lctk)
    -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
    -- let int = $to_number(value_index)
    -- if int <: nat
    -- let n_index = int as nat
    -- if (n_index < n_size)
    -- let typedLvalueIR = typedLvalueIR_base [ typedExpressionIR_index_reduced ] #( typeIR )
    (output) typedLvalueIR

    rulepath index-non-lctk
    (premises)
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
    -- let _expressionIR # ( typeIR_index ctk_index ) = typedExpressionIR_index
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- if (ctk_index =/= lctk)
    -- let typedLvalueIR = typedLvalueIR_base [ typedExpressionIR_index_reduced ] #( typeIR )
    (output) typedLvalueIR
  }

  ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:145.1-186.25
  rulegroup lvalue-expression-expression
   match
    (expl-input) p | TC | lvalue_base [ expression_hi : expression_lo ]
    (impl-input) p | TC | lvalue
    (impl-input-premises)
    -- if lvalue matches `%[%:%]`
    -- let lvalue_base [ expression_hi : expression_lo ] = lvalue
   paths
  {
    rulepath lvalue-expression-expression
    (premises)
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- if $compat_bitslice_base(typeIR_base)
    -- Expr_ok: p TC |- expression_hi : typedExpressionIR_hi
    -- Expr_ok: p TC |- expression_lo : typedExpressionIR_lo
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_hi_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_lo_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    -- let _expressionIR # ( typeIR_hi_reduced ctk_hi_reduced ) = typedExpressionIR_hi_reduced
    -- let _expressionIR' # ( typeIR_lo_reduced ctk_lo_reduced ) = typedExpressionIR_lo_reduced
    -- if (ctk_hi_reduced = lctk)
    -- Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi
    -- let int = $to_number(value_hi)
    -- if int <: nat
    -- let n_hi = int as nat
    -- if (ctk_lo_reduced = lctk)
    -- Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo
    -- let int' = $to_number(value_lo)
    -- if int' <: nat
    -- let n_lo = int' as nat
    -- if $is_valid_bitslice(typeIR_base, n_lo, n_hi)
    -- let typeIR = bit< ((n_hi - n_lo) + 1) > as typeIR
    -- let typedLvalueIR = typedLvalueIR_base [ typedExpressionIR_hi_reduced : typedExpressionIR_lo_reduced ] #( typeIR )
    (output) typedLvalueIR
  }

  ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:190.1-197.54
  rulegroup parenthesized
   match
    (expl-input) p | TC | ( lvalue_base )
    (impl-input) p | TC | lvalue
    (impl-input-premises)
    -- if lvalue matches `(%)`
    -- let ( lvalue_base ) = lvalue
   paths
  {
    rulepath parenthesized
    (premises)
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typedLvalueIR = ( typedLvalueIR_base ) #( typeIR_base )
    (output) typedLvalueIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:67.1-69.26
relation Stmt_ok: cursor typingContext flow |- statement : typingContext flow statementIR
  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:10.1-11.25
  rulegroup emptyStatement
   match
    (expl-input) p | TC | f | ; as statement
    (impl-input) p | TC | f | statement
    (impl-input-premises)
    -- if (statement = ; as statement)
   paths
  {
    rulepath emptyStatement
    (premises)
    (output) TC | f | ; as statementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:19.1-31.76
  rulegroup assignmentStatement-eq
   match
    (expl-input) p | TC | f | lvalue = expression ; as statement
    (impl-input) p | TC | f | statement
    (impl-input-premises)
    -- if statement <: assignmentStatement
    -- let lvalue assignop expression ; = statement as assignmentStatement
    -- if assignop matches `=`
   paths
  {
    rulepath assignmentStatement-eq
    (premises)
    -- Lvalue_ok: p TC |- lvalue : typedLvalueIR
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- let _lvalueIR #( typeIR_l ) = typedLvalueIR
    -- let _expressionIR # ( typeIR_r _ctk ) = typedExpressionIR
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR_l)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    (output) TC | f | typedLvalueIR = typedExpressionIR ; as statementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:42.1-86.2
  rulegroup callStatement
   match
    (expl-input) p | TC | f | callStatement as statement
    (impl-input) p | TC | f | statement
    (impl-input-premises)
    -- if statement <: callStatement
    -- let callStatement = statement as callStatement
   paths
  {
    rulepath callStatement-no-typeArgumentList
    (premises)
    -- let callStatement' = callStatement
    -- if callStatement' matches `%(%);`
    -- let lvalue_routine ( argumentList ); = callStatement'
    -- RoutineTarget_lvalue_ok: p TC |- lvalue_routine : routineTargetIR
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- RoutineType_ok: p TC |- routineTargetIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
    -- Call_ok: p TC |- routineTypeIR < [] # tid_impl*{tid_impl <- tid_impl*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let callStatementIR = routineTargetIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} );
    (output) TC | f | callStatementIR as statementIR

    rulepath callStatement-typeArgumentList
    (premises)
    -- let callStatement' = callStatement
    -- if callStatement' matches `%<%>(%);`
    -- let lvalue_routine < typeArgumentList >( argumentList ); = callStatement'
    -- RoutineTarget_lvalue_ok: p TC |- lvalue_routine : routineTargetIR
    -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
    -- TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
    -- Call_ok: p TC |- routineTypeIR < [] # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let callStatementIR = routineTargetIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} );
    (output) TC | f | callStatementIR as statementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:101.1-121.57
  rulegroup directApplicationStatement-prefixedTypeName
   match
    (expl-input) p | TC_0 | f | namedType .apply( argumentList ); as statement
    (impl-input) p | TC_0 | f | statement
    (impl-input-premises)
    -- if statement <: directApplicationStatement
    -- let namedType .apply( argumentList ); = statement as directApplicationStatement
   paths
  {
    rulepath directApplicationStatement-prefixedTypeName
    (premises)
    -- Expr_ok: p TC_0 |- namedType as callTarget ( ) as expression : expressionIR # ( typeIR_object _ctk )
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%(%)`
    -- let prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} > ( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- if $compat_direct_application(typeIR_object)
    -- let nameIR_object = "__direct_application"
    -- let TC_1 = $add_var(p, TC_0, nameIR_object, typeIR_object ctk ?())
    -- let lvalue = nameIR_object as lvalue . "apply" as member
    -- Stmt_ok: p TC_1 f |- lvalue ( argumentList ); as statement : _typingContext _flow statementIR
    -- if statementIR <: callStatementIR
    -- let callStatementIR = statementIR as callStatementIR
    -- let routineTargetIR < typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} ); = callStatementIR
    -- if (routineTargetIR = ` nameIR_object as expressionIR # ( typeIR_object ctk ) . "apply")
    -- if typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} matches []
    -- let directApplicationStatementIR = prefixedNameIR .apply( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} );
    (output) TC_0 | f | directApplicationStatementIR as statementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:129.1-150.2
  rulegroup returnStatement
   match
    (expl-input) local | TC | f | returnStatement as statement
    (impl-input) cursor | TC | f | statement
    (impl-input-premises)
    -- if cursor matches `LOCAL`
    -- if statement <: returnStatement
    -- let returnStatement = statement as returnStatement
   paths
  {
    rulepath non-expression
    (premises)
    -- if (return; = returnStatement)
    -- if (?(void as typeIR) = $find_return_type(TC))
    (output) TC | ret | return; as statementIR

    rulepath expression
    (premises)
    -- let returnStatement' = returnStatement
    -- if returnStatement' matches `RETURN%;`
    -- let return expression ; = returnStatement'
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
    -- let typeIR'?{typeIR' <- typeIR'?} = $find_return_type(TC)
    -- if typeIR'?{typeIR' <- typeIR'?} matches (_)
    -- let ?(typeIR_ret) = typeIR'?{typeIR' <- typeIR'?}
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR_ret)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    (output) TC | ret | return typedExpressionIR_cast ; as statementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:155.1-156.37
  rulegroup exitStatement
   match
    (expl-input) p | TC | f | exit; as statement
    (impl-input) p | TC | f | statement
    (impl-input-premises)
    -- if (statement = exit; as statement)
   paths
  {
    rulepath exitStatement
    (premises)
    (output) TC | f | exit; as statementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:160.1-163.53
  rulegroup blockStatement
   match
    (expl-input) local | TC_0 | f_0 | blockStatement as statement
    (impl-input) cursor | TC_0 | f_0 | statement
    (impl-input-premises)
    -- if cursor matches `LOCAL`
    -- if statement <: blockStatement
    -- let blockStatement = statement as blockStatement
   paths
  {
    rulepath blockStatement
    (premises)
    -- Block_ok: TC_0 f_0 |- blockStatement : TC_1 f_1 blockStatementIR
    (output) TC_1 | f_1 | blockStatementIR as statementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:171.1-198.2
  rulegroup conditionalStatement
   match
    (expl-input) p | TC | f | conditionalStatement as statement
    (impl-input) p | TC | f | statement
    (impl-input-premises)
    -- if statement <: conditionalStatement
    -- let conditionalStatement = statement as conditionalStatement
   paths
  {
    rulepath non-else
    (premises)
    -- let conditionalStatement' = conditionalStatement
    -- if conditionalStatement' matches `IF(%)%`
    -- let if( expression_cond ) statement_then = conditionalStatement'
    -- Expr_ok: p TC |- expression_cond : typedExpressionIR_cond
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR_cond
    -- if (typeIR = bool as typeIR)
    -- Stmt_ok: p TC f |- statement_then : TC_then f_then statementIR_then
    (output) TC | f | if( typedExpressionIR_cond ) statementIR_then as statementIR

    rulepath else
    (premises)
    -- let conditionalStatement' = conditionalStatement
    -- if conditionalStatement' matches `IF(%)%ELSE%`
    -- let if( expression_cond ) statement_then else statement_else = conditionalStatement'
    -- Expr_ok: p TC |- expression_cond : typedExpressionIR_cond
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR_cond
    -- if (typeIR = bool as typeIR)
    -- Stmt_ok: p TC f |- statement_then : TC_then f_then statementIR_then
    -- Stmt_ok: p TC f |- statement_else : TC_else f_else statementIR_else
    -- let f_post = $join_flow(f_then, f_else)
    (output) TC | f_post | if( typedExpressionIR_cond ) statementIR_then else statementIR_else as statementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:286.1-303.64
  rulegroup switch-table-apply
   match
    (expl-input) local | TC | f | switch( expression_switch ){ switchCaseList } as statement
    (impl-input) cursor | TC | f | statement
    (impl-input-premises)
    -- if cursor matches `LOCAL`
    -- if statement <: switchStatement
    -- let switch( expression_switch ){ switchCaseList } = statement as switchStatement
   paths
  {
    rulepath switch-table-apply
    (premises)
    -- Expr_ok: local TC |- expression_switch : typedExpressionIR_switch
    -- let _expressionIR # ( typeIR_switch _ctk ) = typedExpressionIR_switch
    -- let typeIR = $canon(typeIR_switch)
    -- if typeIR <: tableTypeIR
    -- let tableTypeIR = typeIR as tableTypeIR
    -- if tableTypeIR matches `TABLE_ENUM%{%}`
    -- let table_enum tid_table_enum { _id*{_id <- _id*} } = tableTypeIR
    -- let tid_table = $strip_prefix($strip_suffix(tid_table_enum, ")"), "action_list(")
    -- let switchCase*{switchCase <- switchCase*} = $flatten_switchCaseList(switchCaseList)
    -- SwitchCases_table_ok: TC f tid_table |- switchCase*{switchCase <- switchCase*} : f_post switchCaseIR*{switchCaseIR <- switchCaseIR*} # switchLabel*{switchLabel <- switchLabel*}
    -- if $distinct_<switchLabel>(switchLabel*{switchLabel <- switchLabel*})
    -- let switchStatementIR = switch( typedExpressionIR_switch ){ switchCaseIR*{switchCaseIR <- switchCaseIR*} }
    (output) TC | f_post | switchStatementIR as statementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:390.1-406.64
  rulegroup switch-general
   match
    (expl-input) local | TC | f | switch( expression_switch ){ switchCaseList } as statement
    (impl-input) cursor | TC | f | statement
    (impl-input-premises)
    -- if cursor matches `LOCAL`
    -- if statement <: switchStatement
    -- let switch( expression_switch ){ switchCaseList } = statement as switchStatement
   paths
  {
    rulepath switch-general
    (premises)
    -- Expr_ok: local TC |- expression_switch : typedExpressionIR_switch
    -- let _expressionIR # ( typeIR_switch _ctk ) = typedExpressionIR_switch
    -- if $compat_switch(typeIR_switch)
    -- let switchCase*{switchCase <- switchCase*} = $flatten_switchCaseList(switchCaseList)
    -- SwitchCases_general_ok: TC f typeIR_switch |- switchCase*{switchCase <- switchCase*} : f_post switchCaseIR*{switchCaseIR <- switchCaseIR*} # switchLabel*{switchLabel <- switchLabel*}
    -- if $distinct_<switchLabel>(switchLabel*{switchLabel <- switchLabel*})
    -- let switchStatementIR = switch( typedExpressionIR_switch ){ switchCaseIR*{switchCaseIR <- switchCaseIR*} }
    (output) TC | f_post | switchStatementIR as statementIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:71.1-73.26
relation Stmts_ok: cursor typingContext flow |- statement* : typingContext flow statementIR*


;; ../../../../spec-concrete/5.04-typing-relation.watsup:75.1-78.23
relation BlockElementStmt_ok: typingContext flow |- blockElementStatement : typingContext flow blockElementStatementIR
  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:414.1-416.77
  rulegroup constantDeclaration
   match
    (expl-input) TC_0 | f | constantDeclaration as blockElementStatement
    (impl-input) TC_0 | f | blockElementStatement
    (impl-input-premises)
    -- if blockElementStatement <: constantDeclaration
    -- let constantDeclaration = blockElementStatement as constantDeclaration
   paths
  {
    rulepath constantDeclaration
    (premises)
    -- Decl_ok: local TC_0 |- constantDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: constantDeclarationIR
    -- let constantDeclarationIR = declarationIR as constantDeclarationIR
    (output) TC_1 | f | constantDeclarationIR as blockElementStatementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:422.1-460.2
  rulegroup variableDeclaration
   match
    (expl-input) TC_0 | f | annotationList type name initializerOpt ; as blockElementStatement
    (impl-input) TC_0 | f | blockElementStatement
    (impl-input-premises)
    -- if blockElementStatement <: variableDeclaration
    -- let annotationList type name initializerOpt ; = blockElementStatement as variableDeclaration
   paths
  {
    rulepath empty
    (premises)
    -- if ( = initializerOpt)
    -- Type_ok: local TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(local, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(local, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?() ;
    (output) TC_1 | f | variableDeclarationIR as blockElementStatementIR

    rulepath initializer
    (premises)
    -- let initializerOpt' = initializerOpt
    -- if initializerOpt' <: initializer
    -- let = expression_init = initializerOpt' as initializer
    -- Type_ok: local TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(local, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- Expr_ok: local TC_0 |- expression_init : typedExpressionIR_init
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(local, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?(= typedExpressionIR_init_cast) ;
    (output) TC_1 | f | variableDeclarationIR as blockElementStatementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:464.1-466.66
  rulegroup statement
   match
    (expl-input) TC_0 | f | statement as blockElementStatement
    (impl-input) TC_0 | f | blockElementStatement
    (impl-input-premises)
    -- if blockElementStatement <: statement
    -- let statement = blockElementStatement as statement
   paths
  {
    rulepath statement
    (premises)
    -- Stmt_ok: local TC_0 f |- statement : TC_1 f_post statementIR
    (output) TC_1 | f_post | statementIR as blockElementStatementIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:80.1-83.23
relation BlockElementStmts_ok: typingContext flow |- blockElementStatement* : typingContext flow blockElementStatementIR*
  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:472.1-473.25
  rulegroup nil
   match
    (expl-input) TC | f | []
    (impl-input) TC | f | blockElementStatement*{blockElementStatement <- blockElementStatement*}
    (impl-input-premises)
    -- if blockElementStatement*{blockElementStatement <- blockElementStatement*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TC | f | []
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:475.1-481.75
  rulegroup cons
   match
    (expl-input) TC_0 | f_0 | blockElementStatement_h :: blockElementStatement_t*{}
    (impl-input) TC_0 | f_0 | blockElementStatement*{blockElementStatement <- blockElementStatement*}
    (impl-input-premises)
    -- if blockElementStatement*{blockElementStatement <- blockElementStatement*} matches _ :: _
    -- let blockElementStatement_h :: blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} = blockElementStatement*{blockElementStatement <- blockElementStatement*}
   paths
  {
    rulepath cons
    (premises)
    -- BlockElementStmt_ok: TC_0 f_0 |- blockElementStatement_h : TC_1 f_1 blockElementStatementIR_h
    -- BlockElementStmts_ok: TC_1 f_1 |- blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} : TC_2 f_2 blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*}
    (output) TC_2 | f_2 | blockElementStatementIR_h :: blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:85.1-88.23
relation Block_ok: typingContext flow |- blockStatement : typingContext flow blockStatementIR
  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:489.1-500.72
  rulegroup 
   match
    (expl-input) TC_0 | f | annotationList { blockElementStatementList }
    (impl-input) TC_0 | f | annotationList { blockElementStatementList }
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let blockElementStatement*{blockElementStatement <- blockElementStatement*} = $flatten_blockElementStatementList(blockElementStatementList)
    -- let TC_1 = $enter(TC_0)
    -- BlockElementStmts_ok: TC_1 f |- blockElementStatement*{blockElementStatement <- blockElementStatement*} : TC_2 f_post blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*}
    -- let TC_3 = $exit(TC_2)
    -- let blockStatementIR = annotationList { blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} }
    (output) TC_3 | f_post | blockStatementIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:95.1-97.23
relation Parameter_ok: cursor typingContext |- parameter : parameterIR # tid*
  ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:12.1-19.29
  rulegroup empty
   match
    (expl-input) p | TC | annotationList direction type name
    (impl-input) p | TC | annotationList direction type name initializerOpt
    (impl-input-premises)
    -- if initializerOpt matches ``EMPTY`
   paths
  {
    rulepath empty
    (premises)
    -- Type_ok: p TC |- type as typeOrVoid : typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
    -- let bound = $union_set<tid>($bound(p, TC), { tid_fresh*{tid_fresh <- tid_fresh*} })
    -- if Type_wf: bound |- typeIR holds
    -- let nameIR = $name(name)
    (output) annotationList direction typeIR nameIR ?() | tid_fresh*{tid_fresh <- tid_fresh*}
  }

  ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:23.1-41.68
  rulegroup initializer
   match
    (expl-input) p | TC | annotationList direction type name = expression_init as initializerOpt
    (impl-input) p | TC | annotationList direction type name initializerOpt
    (impl-input-premises)
    -- if initializerOpt <: initializer
    -- let = expression_init = initializerOpt as initializer
   paths
  {
    rulepath initializer
    (premises)
    -- Type_ok: p TC |- type as typeOrVoid : typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
    -- let bound = $union_set<tid>($bound(p, TC), { tid_fresh*{tid_fresh <- tid_fresh*} })
    -- if Type_wf: bound |- typeIR holds
    -- Expr_ok: p TC |- expression_init : typedExpressionIR_init
    -- let _expressionIR # ( typeIR_init ctk ) = typedExpressionIR_init
    -- if ctk matches `LCTK`
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let nameIR = $name(name)
    -- Eval_static: p TC |- typedExpressionIR_init_cast ~> value_init
    (output) annotationList direction typeIR nameIR ?(= value_init) | tid_fresh*{tid_fresh <- tid_fresh*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:99.1-101.23
relation Parameters_ok: cursor typingContext |- parameter* : parameterListIR # tid*
  ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:49.1-50.27
  rulegroup nil
   match
    (expl-input) p | TC | []
    (impl-input) p | TC | parameter*{parameter <- parameter*}
    (impl-input-premises)
    -- if parameter*{parameter <- parameter*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) [] | []
  }

  ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:52.1-56.74
  rulegroup cons
   match
    (expl-input) p | TC | parameter_h :: parameter_t*{}
    (impl-input) p | TC | parameter*{parameter <- parameter*}
    (impl-input-premises)
    -- if parameter*{parameter <- parameter*} matches _ :: _
    -- let parameter_h :: parameter_t*{parameter_t <- parameter_t*} = parameter*{parameter <- parameter*}
   paths
  {
    rulepath cons
    (premises)
    -- Parameter_ok: p TC |- parameter_h : parameterIR_h # tid_fresh_h*{tid_fresh_h <- tid_fresh_h*}
    -- Parameters_ok: p TC |- parameter_t*{parameter_t <- parameter_t*} : parameterIR_t*{parameterIR_t <- parameterIR_t*} # tid_fresh_t*{tid_fresh_t <- tid_fresh_t*}
    (output) parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} | tid_fresh_h*{tid_fresh_h <- tid_fresh_h*} ++ tid_fresh_t*{tid_fresh_t <- tid_fresh_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:103.1-103.48
def $parameterIR(parameterIR) : parameterTypeIR =

  ;; ../../../../spec-concrete/5.04-typing-relation.watsup:104.1-105.32
  clause 0(_annotationList direction typeIR nameIR constantInitializerIR?{constantInitializerIR <- constantInitializerIR?}) = direction typeIR nameIR ?()
  -- if constantInitializerIR?{constantInitializerIR <- constantInitializerIR?} matches ()

  ;; ../../../../spec-concrete/5.04-typing-relation.watsup:106.1-107.34
  clause 1(_annotationList direction typeIR nameIR constantInitializerOptIR) = direction typeIR nameIR ?(value)
  -- if constantInitializerOptIR matches (_)
  -- let ?(= value) = constantInitializerOptIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:109.1-112.23
relation ConstructorParameter_ok: cursor typingContext |- constructorParameter : constructorParameterIR # tid*
  ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:64.1-67.64
  rulegroup 
   match
    (expl-input) p | TC | constructorParameter
    (impl-input) p | TC | constructorParameter
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- Parameter_ok: p TC |- constructorParameter : constructorParameterIR # tid_fresh*{tid_fresh <- tid_fresh*}
    (output) constructorParameterIR | tid_fresh*{tid_fresh <- tid_fresh*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:114.1-117.23
relation ConstructorParameters_ok: cursor typingContext |- constructorParameter* : constructorParameterListIR # tid*
  ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:75.1-78.66
  rulegroup 
   match
    (expl-input) p | TC | constructorParameter*{}
    (impl-input) p | TC | constructorParameter*{constructorParameter <- constructorParameter*}
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- Parameters_ok: p TC |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid_fresh*{tid_fresh <- tid_fresh*}
    (output) constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} | tid_fresh*{tid_fresh <- tid_fresh*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:119.1-119.81
def $constructorParameterIR(constructorParameterIR) : constructorParameterTypeIR =

  ;; ../../../../spec-concrete/5.04-typing-relation.watsup:120.1-121.41
  clause 0(constructorParameterIR) = $parameterIR(constructorParameterIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:127.1-129.23
relation ExternMethod_ok: typingContext tid |- methodPrototype : typingContext methodPrototypeIR
  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:9.1-39.79
  rulegroup non-abstract
   match
    (expl-input) TC_0 | tid_extern | annotationList typeOrVoid name typeParameterListOpt ( parameterList ) ;
    (impl-input) TC_0 | tid_extern | methodPrototype
    (impl-input-premises)
    -- if methodPrototype matches `%%;`
    -- let annotationList typeOrVoid name typeParameterListOpt ( parameterList ) ; = methodPrototype
   paths
  {
    rulepath non-abstract
    (premises)
    -- let nameIR = $name(name)
    -- if (nameIR =/= tid_extern)
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(local, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- Type_ok: local TC_1 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- let TC_2 = TC_1[local.kind = extern_method-> typeIR_ret]
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: local TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_3 = $add_parameters(local, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let rid = $rid(name, parameterList)
    -- let methodTypeIR = extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
    -- let routineTypeDefIR = methodTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
    -- if RoutineTypeDef_wf: $bound(block, TC_0) |- routineTypeDefIR holds
    -- let TC_4 = $add_routine_overload(block, TC_0, rid, routineTypeDefIR)
    -- let methodPrototypeIR = annotationList typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) ;
    (output) TC_4 | methodPrototypeIR
  }

  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:43.1-73.79
  rulegroup abstract
   match
    (expl-input) TC_0 | tid_extern | annotationList abstract typeOrVoid name typeParameterListOpt ( parameterList ) ;
    (impl-input) TC_0 | tid_extern | methodPrototype
    (impl-input-premises)
    -- if methodPrototype matches `%ABSTRACT%;`
    -- let annotationList abstract typeOrVoid name typeParameterListOpt ( parameterList ) ; = methodPrototype
   paths
  {
    rulepath abstract
    (premises)
    -- let nameIR = $name(name)
    -- if (nameIR =/= tid_extern)
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(local, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- Type_ok: local TC_1 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- let TC_2 = TC_1[local.kind = extern_methodabstract-> typeIR_ret]
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: local TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_3 = $add_parameters(local, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let rid = $rid(name, parameterList)
    -- let methodTypeIR = extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
    -- let routineTypeDefIR = methodTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
    -- if RoutineTypeDef_wf: $bound(block, TC_0) |- routineTypeDefIR holds
    -- let TC_4 = $add_routine_overload(block, TC_0, rid, routineTypeDefIR)
    -- let methodPrototypeIR = annotationList abstract typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) ;
    (output) TC_4 | methodPrototypeIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:131.1-133.23
relation ExternMethods_ok: typingContext tid |- methodPrototype* : typingContext methodPrototypeIR*
  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:81.1-82.32
  rulegroup nil
   match
    (expl-input) TC | tid_extern | []
    (impl-input) TC | tid_extern | methodPrototype*{methodPrototype <- methodPrototype*}
    (impl-input-premises)
    -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TC | []
  }

  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:84.1-90.68
  rulegroup cons
   match
    (expl-input) TC_0 | tid_extern | methodPrototype_h :: methodPrototype_t*{}
    (impl-input) TC_0 | tid_extern | methodPrototype*{methodPrototype <- methodPrototype*}
    (impl-input-premises)
    -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
    -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
   paths
  {
    rulepath cons
    (premises)
    -- ExternMethod_ok: TC_0 tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h
    -- ExternMethods_ok: TC_1 tid_extern |- methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} : TC_2 methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
    (output) TC_2 | methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:135.1-137.23
relation ExternConstructor_ok: typingContext tid |- methodPrototype : typingContext methodPrototypeIR
  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:100.1-126.80
  rulegroup 
   match
    (expl-input) TC_0 | tid_extern | annotationList typeIdentifier ( parameterList );
    (impl-input) TC_0 | tid_extern | methodPrototype
    (impl-input-premises)
    -- if methodPrototype matches `%%(%);`
    -- let annotationList typeIdentifier ( parameterList ); = methodPrototype
   paths
  {
    rulepath 
    (premises)
    -- let nameIR = $name(typeIdentifier as name)
    -- if (nameIR = tid_extern)
    -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_parameterList(parameterList)
    -- ConstructorParameters_ok: block TC_0 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(global, TC_0, ` nameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: polyTypeDefIR
    -- let typeIR_extern < tid_expl*{tid_expl <- tid_expl*} , tid*{tid <- tid*} > = typeDefIR as polyTypeDefIR
    -- if tid*{tid <- tid*} matches []
    -- let cid = $cid(typeIdentifier as name, ( parameterList ))
    -- let typeIR_extern_spec = typeIR_extern < tid_expl*{tid_expl <- tid_expl*} , [] > < tid tid_expl as typeIR*{tid_expl <- tid_expl*} > as typeIR
    -- let constructorTypeIR = constructor( constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} )-> typeIR_extern_spec
    -- let constructorTypeDefIR = constructorTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >
    -- if ConstructorTypeDef_wf: $bound(block, TC_0) |- constructorTypeDefIR holds
    -- let TC_1 = $add_constructor(TC_0, cid, constructorTypeDefIR)
    -- let methodPrototypeIR = annotationList nameIR <, tid_impl*{tid_impl <- tid_impl*} >( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} );
    (output) TC_1 | methodPrototypeIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:139.1-141.23
relation ExternConstructors_ok: typingContext tid |- methodPrototype* : typingContext methodPrototypeIR*
  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:134.1-135.32
  rulegroup nil
   match
    (expl-input) TC | tid_extern | []
    (impl-input) TC | tid_extern | methodPrototype*{methodPrototype <- methodPrototype*}
    (impl-input-premises)
    -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TC | []
  }

  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:137.1-143.73
  rulegroup cons
   match
    (expl-input) TC_0 | tid_extern | methodPrototype_h :: methodPrototype_t*{}
    (impl-input) TC_0 | tid_extern | methodPrototype*{methodPrototype <- methodPrototype*}
    (impl-input-premises)
    -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
    -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
   paths
  {
    rulepath cons
    (premises)
    -- ExternConstructor_ok: TC_0 tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h
    -- ExternConstructors_ok: TC_1 tid_extern |- methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} : TC_2 methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
    (output) TC_2 | methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:147.1-149.23
relation ParserTransition_ok: typingContext nameIR* |- transitionStatement : transitionStatementIR
  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:11.1-15.7
  rulegroup empty
   match
    (expl-input) TC_0 | nameIR_state*{} | 
    (impl-input) TC_0 | nameIR_state*{nameIR_state <- nameIR_state*} | transitionStatement
    (impl-input-premises)
    -- if transitionStatement matches ``EMPTY`
   paths
  {
    rulepath empty
    (premises)
    (output) transition "reject" ;
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:19.1-26.55
  rulegroup name
   match
    (expl-input) TC_0 | nameIR_state*{} | transition name ;
    (impl-input) TC_0 | nameIR_state*{nameIR_state <- nameIR_state*} | transitionStatement
    (impl-input-premises)
    -- if transitionStatement matches `TRANSITION%`
    -- let transition stateExpression = transitionStatement
    -- if stateExpression matches `%;`
    -- let name ; = stateExpression
   paths
  {
    rulepath name
    (premises)
    -- let nameIR = $name(name)
    -- if nameIR <- nameIR_state*{nameIR_state <- nameIR_state*}
    -- let transitionStatementIR = transition nameIR ;
    (output) transitionStatementIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:308.1-322.75
  rulegroup switch
   match
    (expl-input) TC_0 | nameIR_state*{} | transition select( expressionList_key ){ selectCaseList } as stateExpression
    (impl-input) TC_0 | nameIR_state*{nameIR_state <- nameIR_state*} | transitionStatement
    (impl-input-premises)
    -- if transitionStatement matches `TRANSITION%`
    -- let transition stateExpression = transitionStatement
    -- if stateExpression <: selectExpression
    -- let select( expressionList_key ){ selectCaseList } = stateExpression as selectExpression
   paths
  {
    rulepath switch
    (premises)
    -- let expression_key*{expression_key <- expression_key*} = $flatten_expressionList(expressionList_key)
    -- (Expr_ok: local TC_0 |- expression_key : typedExpressionIR_key)*{expression_key <- expression_key*, typedExpressionIR_key <- typedExpressionIR_key*}
    -- (let _expressionIR # ( typeIR_key _ctk ) = typedExpressionIR_key)*{_ctk <- _ctk*, _expressionIR <- _expressionIR*, typeIR_key <- typeIR_key*, typedExpressionIR_key <- typedExpressionIR_key*}
    -- (if Type_wf: $bound(local, TC_0) |- set< [typeIR_key] > as typeIR holds)*{typeIR_key <- typeIR_key*}
    -- let selectCase*{selectCase <- selectCase*} = $flatten_selectCaseList(selectCaseList)
    -- (SelectCase_ok: TC_0 nameIR_state*{nameIR_state <- nameIR_state*} typeIR_key*{typeIR_key <- typeIR_key*} |- selectCase : selectCaseIR)*{selectCase <- selectCase*, selectCaseIR <- selectCaseIR*}
    -- let transitionStatementIR = transition select( typedExpressionIR_key*{typedExpressionIR_key <- typedExpressionIR_key*} ){ selectCaseIR*{selectCaseIR <- selectCaseIR*} } as stateExpressionIR
    (output) transitionStatementIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:151.1-153.20
relation ParserStmt_ok: typingContext |- parserStatement : typingContext parserStatementIR
  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:332.1-336.55
  rulegroup constantDeclaration
   match
    (expl-input) TC_0 | constantDeclaration as parserStatement
    (impl-input) TC_0 | parserStatement
    (impl-input-premises)
    -- if parserStatement <: constantDeclaration
    -- let constantDeclaration = parserStatement as constantDeclaration
   paths
  {
    rulepath constantDeclaration
    (premises)
    -- Decl_ok: local TC_0 |- constantDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: constantDeclarationIR
    -- let constantDeclarationIR = declarationIR as constantDeclarationIR
    (output) TC_1 | constantDeclarationIR as parserStatementIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:342.1-380.2
  rulegroup variableDeclaration
   match
    (expl-input) TC_0 | annotationList type name initializerOpt ; as parserStatement
    (impl-input) TC_0 | parserStatement
    (impl-input-premises)
    -- if parserStatement <: variableDeclaration
    -- let annotationList type name initializerOpt ; = parserStatement as variableDeclaration
   paths
  {
    rulepath empty
    (premises)
    -- if ( = initializerOpt)
    -- Type_ok: local TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(local, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(local, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?() ;
    (output) TC_1 | variableDeclarationIR as parserStatementIR

    rulepath initializer
    (premises)
    -- let initializerOpt' = initializerOpt
    -- if initializerOpt' <: initializer
    -- let = expression_init = initializerOpt' as initializer
    -- Type_ok: local TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(local, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- Expr_ok: local TC_0 |- expression_init : typedExpressionIR_init
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(local, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?(= typedExpressionIR_init_cast) ;
    (output) TC_1 | variableDeclarationIR as parserStatementIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:384.1-388.57
  rulegroup emptyStatement
   match
    (expl-input) TC | emptyStatement as parserStatement
    (impl-input) TC | parserStatement
    (impl-input-premises)
    -- if parserStatement <: emptyStatement
    -- let emptyStatement = parserStatement as emptyStatement
   paths
  {
    rulepath emptyStatement
    (premises)
    -- Stmt_ok: local TC cont |- emptyStatement as statement : typingContext flow statementIR
    -- if (typingContext = TC)
    -- if flow matches `CONT`
    -- if statementIR <: emptyStatementIR
    -- let emptyStatementIR = statementIR as emptyStatementIR
    (output) TC | emptyStatementIR as parserStatementIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:392.1-396.65
  rulegroup assignmentStatement
   match
    (expl-input) TC_0 | assignmentStatement as parserStatement
    (impl-input) TC_0 | parserStatement
    (impl-input-premises)
    -- if parserStatement <: assignmentStatement
    -- let assignmentStatement = parserStatement as assignmentStatement
   paths
  {
    rulepath assignmentStatement
    (premises)
    -- Stmt_ok: local TC_0 cont |- assignmentStatement as statement : TC_1 flow statementIR
    -- if flow matches `CONT`
    -- if statementIR <: assignmentStatementIR
    -- let assignmentStatementIR = statementIR as assignmentStatementIR
    (output) TC_1 | assignmentStatementIR as parserStatementIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:400.1-404.59
  rulegroup callStatement
   match
    (expl-input) TC_0 | callStatement as parserStatement
    (impl-input) TC_0 | parserStatement
    (impl-input-premises)
    -- if parserStatement <: callStatement
    -- let callStatement = parserStatement as callStatement
   paths
  {
    rulepath callStatement
    (premises)
    -- Stmt_ok: local TC_0 cont |- callStatement as statement : TC_1 flow statementIR
    -- if flow matches `CONT`
    -- if statementIR <: callStatementIR
    -- let callStatementIR = statementIR as callStatementIR
    (output) TC_1 | callStatementIR as parserStatementIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:408.1-412.72
  rulegroup directApplicationStatement
   match
    (expl-input) TC_0 | directApplicationStatement as parserStatement
    (impl-input) TC_0 | parserStatement
    (impl-input-premises)
    -- if parserStatement <: directApplicationStatement
    -- let directApplicationStatement = parserStatement as directApplicationStatement
   paths
  {
    rulepath directApplicationStatement
    (premises)
    -- Stmt_ok: local TC_0 cont |- directApplicationStatement as statement : TC_1 flow statementIR
    -- if flow matches `CONT`
    -- if statementIR <: directApplicationStatementIR
    -- let directApplicationStatementIR = statementIR as directApplicationStatementIR
    (output) TC_1 | directApplicationStatementIR as parserStatementIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:417.1-427.72
  rulegroup parserBlockStatement
   match
    (expl-input) TC_0 | annotationList { parserStatementList } as parserStatement
    (impl-input) TC_0 | parserStatement'
    (impl-input-premises)
    -- if parserStatement' <: parserBlockStatement
    -- let annotationList { parserStatementList } = parserStatement' as parserBlockStatement
   paths
  {
    rulepath parserBlockStatement
    (premises)
    -- let parserStatement*{parserStatement <- parserStatement*} = $flatten_parserStatementList(parserStatementList)
    -- let TC_1 = $enter(TC_0)
    -- ParserStmts_ok: TC_1 |- parserStatement*{parserStatement <- parserStatement*} : TC_2 parserStatementIR*{parserStatementIR <- parserStatementIR*}
    -- let TC_3 = $exit(TC_2)
    -- let parserBlockStatementIR = annotationList { parserStatementIR*{parserStatementIR <- parserStatementIR*} }
    (output) TC_1 | parserBlockStatementIR as parserStatementIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:431.1-435.66
  rulegroup conditionalStatement
   match
    (expl-input) TC_0 | conditionalStatement as parserStatement
    (impl-input) TC_0 | parserStatement
    (impl-input-premises)
    -- if parserStatement <: conditionalStatement
    -- let conditionalStatement = parserStatement as conditionalStatement
   paths
  {
    rulepath conditionalStatement
    (premises)
    -- Stmt_ok: local TC_0 cont |- conditionalStatement as statement : TC_1 flow statementIR
    -- if flow matches `CONT`
    -- if statementIR <: conditionalStatementIR
    -- let conditionalStatementIR = statementIR as conditionalStatementIR
    (output) TC_1 | conditionalStatementIR as parserStatementIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:155.1-157.20
relation ParserStmts_ok: typingContext |- parserStatement* : typingContext parserStatementIR*
  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:443.1-444.21
  rulegroup nil
   match
    (expl-input) TC | []
    (impl-input) TC | parserStatement*{parserStatement <- parserStatement*}
    (impl-input-premises)
    -- if parserStatement*{parserStatement <- parserStatement*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TC | []
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:446.1-452.55
  rulegroup cons
   match
    (expl-input) TC_0 | parserStatement_h :: parserStatement_t*{}
    (impl-input) TC_0 | parserStatement*{parserStatement <- parserStatement*}
    (impl-input-premises)
    -- if parserStatement*{parserStatement <- parserStatement*} matches _ :: _
    -- let parserStatement_h :: parserStatement_t*{parserStatement_t <- parserStatement_t*} = parserStatement*{parserStatement <- parserStatement*}
   paths
  {
    rulepath cons
    (premises)
    -- ParserStmt_ok: TC_0 |- parserStatement_h : TC_1 parserStatementIR_h
    -- ParserStmts_ok: TC_1 |- parserStatement_t*{parserStatement_t <- parserStatement_t*} : TC_2 parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*}
    (output) TC_2 | parserStatementIR_h :: parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:159.1-161.23
relation ParserState_ok: typingContext nameIR* |- parserState : parserStateIR
  ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:8.1-26.82
  rulegroup 
   match
    (expl-input) TC_0 | nameIR_state*{} | annotationList state name { parserStatementList transitionStatement }
    (impl-input) TC_0 | nameIR_state*{nameIR_state <- nameIR_state*} | annotationList state name { parserStatementList transitionStatement }
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let nameIR = $name(name)
    -- let TC_1 = $enter(TC_0)
    -- let parserStatement*{parserStatement <- parserStatement*} = $flatten_parserStatementList(parserStatementList)
    -- ParserStmts_ok: TC_1 |- parserStatement*{parserStatement <- parserStatement*} : TC_2 parserStatementIR*{parserStatementIR <- parserStatementIR*}
    -- ParserTransition_ok: TC_2 nameIR_state*{nameIR_state <- nameIR_state*} |- transitionStatement : transitionStatementIR
    -- let TC_3 = $exit(TC_2)
    -- let parserStateIR = annotationList state nameIR { parserStatementIR*{parserStatementIR <- parserStatementIR*} transitionStatementIR }
    (output) parserStateIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:163.1-165.20
relation ParserStates_ok: typingContext |- parserState* : parserStateIR*
  ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:34.1-46.77
  rulegroup 
   match
    (expl-input) TC | parserState*{}
    (impl-input) TC | parserState*{parserState <- parserState*}
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- (let _annotationList state name_state { _parserStatementList _transitionStatement } = parserState)*{_annotationList <- _annotationList*, _parserStatementList <- _parserStatementList*, _transitionStatement <- _transitionStatement*, name_state <- name_state*, parserState <- parserState*}
    -- (let nameIR_state = $name(name_state))*{nameIR_state <- nameIR_state*, name_state <- name_state*}
    -- if $distinct_<nameIR>(nameIR_state*{nameIR_state <- nameIR_state*})
    -- if "start" <- nameIR_state*{nameIR_state <- nameIR_state*}
    -- if (~"accept" <- nameIR_state*{nameIR_state <- nameIR_state*} /\ ~"reject" <- nameIR_state*{nameIR_state <- nameIR_state*})
    -- let nameIR_state_impl*{nameIR_state_impl <- nameIR_state_impl*} = "accept" :: "reject" :: nameIR_state*{nameIR_state <- nameIR_state*}
    -- (ParserState_ok: TC nameIR_state_impl*{nameIR_state_impl <- nameIR_state_impl*} |- parserState : parserStateIR)*{parserState <- parserState*, parserStateIR <- parserStateIR*}
    (output) parserStateIR*{parserStateIR <- parserStateIR*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:167.1-170.20
relation ParserLocalDecl_ok: typingContext |- parserLocalDeclaration : typingContext parserLocalDeclarationIR
  ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:9.1-13.55
  rulegroup constantDeclaration
   match
    (expl-input) TC_0 | constantDeclaration as parserLocalDeclaration
    (impl-input) TC_0 | parserLocalDeclaration
    (impl-input-premises)
    -- if parserLocalDeclaration <: constantDeclaration
    -- let constantDeclaration = parserLocalDeclaration as constantDeclaration
   paths
  {
    rulepath constantDeclaration
    (premises)
    -- Decl_ok: block TC_0 |- constantDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: constantDeclarationIR
    -- let constantDeclarationIR = declarationIR as constantDeclarationIR
    (output) TC_1 | constantDeclarationIR as parserLocalDeclarationIR
  }

  ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:17.1-21.49
  rulegroup instantiation
   match
    (expl-input) TC_0 | instantiation as parserLocalDeclaration
    (impl-input) TC_0 | parserLocalDeclaration
    (impl-input-premises)
    -- if parserLocalDeclaration <: instantiation
    -- let instantiation = parserLocalDeclaration as instantiation
   paths
  {
    rulepath instantiation
    (premises)
    -- Decl_ok: block TC_0 |- instantiation as declaration : TC_1 declarationIR
    -- if declarationIR <: instantiationIR
    -- let instantiationIR = declarationIR as instantiationIR
    (output) TC_1 | instantiationIR as parserLocalDeclarationIR
  }

  ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:27.1-65.2
  rulegroup variableDeclaration
   match
    (expl-input) TC_0 | annotationList type name initializerOpt ; as parserLocalDeclaration
    (impl-input) TC_0 | parserLocalDeclaration
    (impl-input-premises)
    -- if parserLocalDeclaration <: variableDeclaration
    -- let annotationList type name initializerOpt ; = parserLocalDeclaration as variableDeclaration
   paths
  {
    rulepath empty
    (premises)
    -- if ( = initializerOpt)
    -- Type_ok: block TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(block, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(block, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?() ;
    (output) TC_1 | variableDeclarationIR as parserLocalDeclarationIR

    rulepath initializer
    (premises)
    -- let initializerOpt' = initializerOpt
    -- if initializerOpt' <: initializer
    -- let = expression_init = initializerOpt' as initializer
    -- Type_ok: block TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(block, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- Expr_ok: block TC_0 |- expression_init : typedExpressionIR_init
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(block, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?(= typedExpressionIR_init_cast) ;
    (output) TC_1 | variableDeclarationIR as parserLocalDeclarationIR
  }

  ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:71.1-88.78
  rulegroup valueSetDeclaration
   match
    (expl-input) TC_0 | annotationList value_set< valueSetType >( expression ) name ; as parserLocalDeclaration
    (impl-input) TC_0 | parserLocalDeclaration
    (impl-input-premises)
    -- if parserLocalDeclaration <: valueSetDeclaration
    -- let annotationList value_set< valueSetType >( expression ) name ; = parserLocalDeclaration as valueSetDeclaration
   paths
  {
    rulepath valueSetDeclaration
    (premises)
    -- Type_ok: block TC_0 |- valueSetType as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(block, TC_0) |- set< [typeIR] > as typeIR holds
    -- Expr_ok: block TC_0 |- expression : typedExpressionIR
    -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR
    -- if (ctk =/= dyn)
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(block, TC_0, nameIR, set< [typeIR] > as typeIR ctk ?())
    -- let valueSetDeclarationIR = annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;
    (output) TC_1 | valueSetDeclarationIR as parserLocalDeclarationIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:172.1-175.20
relation ParserLocalDecls_ok: typingContext |- parserLocalDeclaration* : typingContext parserLocalDeclarationIR*
  ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:96.1-97.21
  rulegroup nil
   match
    (expl-input) TC | []
    (impl-input) TC | parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}
    (impl-input-premises)
    -- if parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TC | []
  }

  ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:99.1-105.67
  rulegroup cons
   match
    (expl-input) TC_0 | parserLocalDeclaration_h :: parserLocalDeclaration_t*{}
    (impl-input) TC_0 | parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}
    (impl-input-premises)
    -- if parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} matches _ :: _
    -- let parserLocalDeclaration_h :: parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} = parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}
   paths
  {
    rulepath cons
    (premises)
    -- ParserLocalDecl_ok: TC_0 |- parserLocalDeclaration_h : TC_1 parserLocalDeclarationIR_h
    -- ParserLocalDecls_ok: TC_1 |- parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} : TC_2 parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*}
    (output) TC_2 | parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:181.1-183.23
relation TableKey_ok: typingContext tableContext |- tableKey : tableContext tableKeyIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:45.1-62.77
  rulegroup 
   match
    (expl-input) TC | TBLC_0 | expression : name_matchkind annotationList ;
    (impl-input) TC | TBLC_0 | expression : name_matchkind annotationList ;
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
    -- if Type_wf: $bound(local, TC) |- set< [typeIR] > as typeIR holds
    -- let nameIR_matchkind = $name(name_matchkind)
    -- if (match_kind. nameIR_matchkind as value = $find_value(local, TC, ` nameIR_matchkind))
    -- if $compat_table_key(nameIR_matchkind, typeIR)
    -- let TBLC_1 = $update_mode(TBLC_0, nameIR_matchkind, typeIR)
    -- let TBLC_2 = $add_key(TBLC_1, nameIR_matchkind, typeIR)
    -- let tableKeyIR = typedExpressionIR : nameIR_matchkind annotationList ;
    (output) TBLC_2 | tableKeyIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:185.1-187.23
relation TableKeys_ok: typingContext tableContext |- tableKey* : tableContext tableKeyListIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:70.1-71.28
  rulegroup nil
   match
    (expl-input) TC | TBLC | []
    (impl-input) TC | TBLC | tableKey*{tableKey <- tableKey*}
    (impl-input-premises)
    -- if tableKey*{tableKey <- tableKey*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TBLC | []
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:73.1-77.67
  rulegroup cons
   match
    (expl-input) TC | TBLC_0 | tableKey_h :: tableKey_t*{}
    (impl-input) TC | TBLC_0 | tableKey*{tableKey <- tableKey*}
    (impl-input-premises)
    -- if tableKey*{tableKey <- tableKey*} matches _ :: _
    -- let tableKey_h :: tableKey_t*{tableKey_t <- tableKey_t*} = tableKey*{tableKey <- tableKey*}
   paths
  {
    rulepath cons
    (premises)
    -- TableKey_ok: TC TBLC_0 |- tableKey_h : TBLC_1 tableKeyIR_h
    -- TableKeys_ok: TC TBLC_1 |- tableKey_t*{tableKey_t <- tableKey_t*} : TBLC_2 tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*}
    (output) TBLC_2 | tableKeyIR_h :: tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:189.1-192.23
relation Call_action_partial_ok: typingContext |- parameterTypeIR* @ argumentListIR : parameterTypeIR* , parameterTypeIR* @ argumentListIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:101.1-113.42
  rulegroup 
   match
    (expl-input) TC | parameterTypeIR*{} | argumentIR*{}
    (impl-input) TC | parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- if (|parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- Call_convention_ok: local TC action |- parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} | parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:194.1-196.23
relation TableAction_ok: typingContext tableContext |- tableAction : tableContext tableActionIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:120.1-134.68
  rulegroup prefixedNonTypeName
   match
    (expl-input) TC | TBLC_0 | annotationList prefixedNonTypeName as tableActionReference ;
    (impl-input) TC | TBLC_0 | annotationList tableActionReference ;
    (impl-input-premises)
    -- if tableActionReference <: prefixedNonTypeName
    -- let prefixedNonTypeName = tableActionReference as prefixedNonTypeName
   paths
  {
    rulepath prefixedNonTypeName
    (premises)
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_routine_non_overloaded(local, TC, prefixedNameIR)
    -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
    -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}
    -- if routineTypeDefIR <: functionTypeIR
    -- let functionTypeIR = routineTypeDefIR as functionTypeIR
    -- if functionTypeIR matches `ACTION(%)`
    -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
    -- Call_action_partial_ok: TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ [] : parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} , parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} @ argumentIR*{argumentIR <- argumentIR*}
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- let TBLC_1 = $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, [])
    -- let tableActionIR = annotationList prefixedNameIR ( [] ) ;
    (output) TBLC_1 | tableActionIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:138.1-155.81
  rulegroup prefixedNonTypeName-argumentList
   match
    (expl-input) TC | TBLC_0 | annotationList prefixedNonTypeName ( argumentList ) ;
    (impl-input) TC | TBLC_0 | annotationList tableActionReference ;
    (impl-input-premises)
    -- if tableActionReference matches `%(%)`
    -- let prefixedNonTypeName ( argumentList ) = tableActionReference
   paths
  {
    rulepath prefixedNonTypeName-argumentList
    (premises)
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_routine_non_overloaded(local, TC, prefixedNameIR)
    -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
    -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}
    -- if routineTypeDefIR <: functionTypeIR
    -- let functionTypeIR = routineTypeDefIR as functionTypeIR
    -- if functionTypeIR matches `ACTION(%)`
    -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: local TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- Call_action_partial_ok: TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} , parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    -- let TBLC_1 = $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
    -- let tableActionIR = annotationList prefixedNameIR ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} ) ;
    (output) TBLC_1 | tableActionIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:198.1-200.23
relation TableActions_ok: typingContext tableContext |- tableAction* : tableContext tableActionListIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:163.1-164.28
  rulegroup nil
   match
    (expl-input) TC | TBLC | []
    (impl-input) TC | TBLC | tableAction*{tableAction <- tableAction*}
    (impl-input-premises)
    -- if tableAction*{tableAction <- tableAction*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TBLC | []
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:166.1-170.76
  rulegroup cons
   match
    (expl-input) TC | TBLC_0 | tableAction_h :: tableAction_t*{}
    (impl-input) TC | TBLC_0 | tableAction*{tableAction <- tableAction*}
    (impl-input-premises)
    -- if tableAction*{tableAction <- tableAction*} matches _ :: _
    -- let tableAction_h :: tableAction_t*{tableAction_t <- tableAction_t*} = tableAction*{tableAction <- tableAction*}
   paths
  {
    rulepath cons
    (premises)
    -- TableAction_ok: TC TBLC_0 |- tableAction_h : TBLC_1 tableActionIR_h
    -- TableActions_ok: TC TBLC_1 |- tableAction_t*{tableAction_t <- tableAction_t*} : TBLC_2 tableActionIR_t*{tableActionIR_t <- tableActionIR_t*}
    (output) TBLC_2 | tableActionIR_h :: tableActionIR_t*{tableActionIR_t <- tableActionIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:202.1-205.23
relation Call_action_default_ok: typingContext |- parameterTypeIR* @ argumentListIR : parameterTypeIR* , parameterTypeIR* @ argumentListIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:178.1-188.42
  rulegroup 
   match
    (expl-input) TC | parameterTypeIR*{} | argumentIR*{}
    (impl-input) TC | parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- Call_convention_ok: local TC action |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} | parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:207.1-209.23
relation TableDefaultAction_ok: typingContext tableContext |- initializer : tableActionReferenceIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:192.1-197.56
  rulegroup prefixedNonTypeName
   match
    (expl-input) TC | TBLC | = prefixedNonTypeName as expression
    (impl-input) TC | TBLC | = expression
    (impl-input-premises)
    -- if expression <: prefixedNonTypeName
    -- let prefixedNonTypeName = expression as prefixedNonTypeName
   paths
  {
    rulepath prefixedNonTypeName
    (premises)
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- if (?(([], [])) = $find_action(TBLC, prefixedNameIR))
    (output) prefixedNameIR ( [] )
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:201.1-222.57
  rulegroup prefixedNonTypeName-argumentList
   match
    (expl-input) TC | TBLC | = prefixedNonTypeName as callTarget ( argumentList ) as expression
    (impl-input) TC | TBLC | = expression
    (impl-input-premises)
    -- if expression <: callExpression
    -- let callExpression = expression as callExpression
    -- if callExpression matches `%(%)`
    -- let callTarget ( argumentList ) = callExpression
    -- if callTarget <: prefixedNonTypeName
    -- let prefixedNonTypeName = callTarget as prefixedNonTypeName
   paths
  {
    rulepath prefixedNonTypeName-argumentList
    (premises)
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- let (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} = $find_action(TBLC, prefixedNameIR)
    -- if (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} matches (_)
    -- let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) = (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: local TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- Call_action_default_ok: TC |- parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*} , parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    -- let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} = argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
    -- let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} = argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
    -- (if (argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}
    (output) prefixedNameIR ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:211.1-213.23
relation TableEntry_keyset_ok: typingContext tableContext |- keysetExpression : tableEntryState keysetExpressionIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:427.1-434.53
  rulegroup simpleKeysetExpression-expression
   match
    (expl-input) TC | TBLC | expression as keysetExpression
    (impl-input) TC | TBLC | keysetExpression
    (impl-input-premises)
    -- if keysetExpression <: expression
    -- let expression = keysetExpression as expression
   paths
  {
    rulepath simpleKeysetExpression-expression
    (premises)
    -- if (|TBLC.keys| = 1)
    -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression as simpleKeysetExpression] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
    -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    (output) TBLS | simpleKeysetExpressionIR as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:438.1-445.53
  rulegroup simpleKeysetExpression-mask
   match
    (expl-input) TC | TBLC | expression_l &&& expression_r as keysetExpression
    (impl-input) TC | TBLC | keysetExpression
    (impl-input-premises)
    -- if keysetExpression <: simpleKeysetExpression
    -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
    -- if simpleKeysetExpression matches `%&&&%`
    -- let expression_l &&& expression_r = simpleKeysetExpression
   paths
  {
    rulepath simpleKeysetExpression-mask
    (premises)
    -- if (|TBLC.keys| = 1)
    -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression_l &&& expression_r] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
    -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    (output) TBLS | simpleKeysetExpressionIR as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:449.1-456.53
  rulegroup simpleKeysetExpression-range
   match
    (expl-input) TC | TBLC | expression_l .. expression_r as keysetExpression
    (impl-input) TC | TBLC | keysetExpression
    (impl-input-premises)
    -- if keysetExpression <: simpleKeysetExpression
    -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
    -- if simpleKeysetExpression matches `%..%`
    -- let expression_l .. expression_r = simpleKeysetExpression
   paths
  {
    rulepath simpleKeysetExpression-range
    (premises)
    -- if (|TBLC.keys| = 1)
    -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression_l .. expression_r] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
    -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    (output) TBLS | simpleKeysetExpressionIR as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:460.1-472.2
  rulegroup simpleKeysetExpression-default
   match
    (expl-input) TC | TBLC | default as keysetExpression
    (impl-input) TC | TBLC | keysetExpression
    (impl-input-premises)
    -- if (keysetExpression = default as keysetExpression)
   paths
  {
    rulepath noprilpm
    (premises)
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- let TBLS = lpm n
    (output) TBLS | default as keysetExpressionIR

    rulepath non-noprilpm
    (premises)
    -- if (((TBLC.mode = nopri) \/ (TBLC.mode = pri)) \/ (TBLC.mode = prilpm))
    -- let TBLS = nolpm
    (output) TBLS | default as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:476.1-488.2
  rulegroup simpleKeysetExpression-dontcare
   match
    (expl-input) TC | TBLC | _ as keysetExpression
    (impl-input) TC | TBLC | keysetExpression
    (impl-input-premises)
    -- if (keysetExpression = _ as keysetExpression)
   paths
  {
    rulepath noprilpm
    (premises)
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- let TBLS = lpm 0
    (output) TBLS | _ as keysetExpressionIR

    rulepath non-noprilpm
    (premises)
    -- if (((TBLC.mode = nopri) \/ (TBLC.mode = pri)) \/ (TBLC.mode = prilpm))
    -- let TBLS = nolpm
    (output) TBLS | _ as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:495.1-503.53
  rulegroup tupleKeysetExpression-mask
   match
    (expl-input) TC | TBLC | ( expression_l &&& expression_r ) as keysetExpression
    (impl-input) TC | TBLC | keysetExpression
    (impl-input-premises)
    -- if keysetExpression <: tupleKeysetExpression
    -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
    -- if tupleKeysetExpression matches `(%&&&%)`
    -- let ( expression_l &&& expression_r ) = tupleKeysetExpression
   paths
  {
    rulepath tupleKeysetExpression-mask
    (premises)
    -- if (|TBLC.keys| = 1)
    -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression_l &&& expression_r] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
    -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    (output) TBLS | ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:507.1-515.53
  rulegroup tupleKeysetExpression-range
   match
    (expl-input) TC | TBLC | ( expression_l .. expression_r ) as keysetExpression
    (impl-input) TC | TBLC | keysetExpression
    (impl-input-premises)
    -- if keysetExpression <: tupleKeysetExpression
    -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
    -- if tupleKeysetExpression matches `(%..%)`
    -- let ( expression_l .. expression_r ) = tupleKeysetExpression
   paths
  {
    rulepath tupleKeysetExpression-range
    (premises)
    -- if (|TBLC.keys| = 1)
    -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression_l .. expression_r] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
    -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    (output) TBLS | ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:519.1-531.2
  rulegroup tupleKeysetExpression-default
   match
    (expl-input) TC | TBLC | (default) as keysetExpression
    (impl-input) TC | TBLC | keysetExpression
    (impl-input-premises)
    -- if (keysetExpression = (default) as keysetExpression)
   paths
  {
    rulepath noprilpm
    (premises)
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- let TBLS = lpm n
    (output) TBLS | ( [default] ) as keysetExpressionIR

    rulepath non-noprilpm
    (premises)
    -- if (((TBLC.mode = nopri) \/ (TBLC.mode = pri)) \/ (TBLC.mode = prilpm))
    -- let TBLS = nolpm
    (output) TBLS | ( [default] ) as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:535.1-547.2
  rulegroup tupleKeysetExpression-dontcare
   match
    (expl-input) TC | TBLC | (_) as keysetExpression
    (impl-input) TC | TBLC | keysetExpression
    (impl-input-premises)
    -- if (keysetExpression = (_) as keysetExpression)
   paths
  {
    rulepath noprilpm
    (premises)
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- let TBLS = lpm 0
    (output) TBLS | ( [_] ) as keysetExpressionIR

    rulepath non-noprilpm
    (premises)
    -- if (((TBLC.mode = nopri) \/ (TBLC.mode = pri)) \/ (TBLC.mode = prilpm))
    -- let TBLS = nolpm
    (output) TBLS | ( [_] ) as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:551.1-563.54
  rulegroup tupleKeysetExpression-list
   match
    (expl-input) TC | TBLC | ( simpleKeysetExpression_h , simpleKeysetExpressionList_t ) as keysetExpression
    (impl-input) TC | TBLC | keysetExpression
    (impl-input-premises)
    -- if keysetExpression <: tupleKeysetExpression
    -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
    -- if tupleKeysetExpression matches `(%,%)`
    -- let ( simpleKeysetExpression_h , simpleKeysetExpressionList_t ) = tupleKeysetExpression
   paths
  {
    rulepath tupleKeysetExpression-list
    (premises)
    -- let simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t)
    -- let simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} = simpleKeysetExpression_h :: simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*}
    -- if (|TBLC.keys| = |simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}|)
    -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} : TBLS simpleKeysetExpressionIR*{simpleKeysetExpressionIR <- simpleKeysetExpressionIR*}
    (output) TBLS | ( simpleKeysetExpressionIR*{simpleKeysetExpressionIR <- simpleKeysetExpressionIR*} ) as keysetExpressionIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:215.1-217.23
relation TableEntry_action_ok: typingContext tableContext |- tableActionReference : tableActionReferenceIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:573.1-577.56
  rulegroup prefixedNonTypeName
   match
    (expl-input) TC | TBLC | prefixedNonTypeName as tableActionReference
    (impl-input) TC | TBLC | tableActionReference
    (impl-input-premises)
    -- if tableActionReference <: prefixedNonTypeName
    -- let prefixedNonTypeName = tableActionReference as prefixedNonTypeName
   paths
  {
    rulepath prefixedNonTypeName
    (premises)
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- if (?(([], [])) = $find_action(TBLC, prefixedNameIR))
    (output) prefixedNameIR ( [] )
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:581.1-602.57
  rulegroup prefixedNonTypeName-argumentList
   match
    (expl-input) TC | TBLC | prefixedNonTypeName ( argumentList )
    (impl-input) TC | TBLC | tableActionReference
    (impl-input-premises)
    -- if tableActionReference matches `%(%)`
    -- let prefixedNonTypeName ( argumentList ) = tableActionReference
   paths
  {
    rulepath prefixedNonTypeName-argumentList
    (premises)
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- let (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} = $find_action(TBLC, prefixedNameIR)
    -- if (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} matches (_)
    -- let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) = (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: local TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- Call_action_default_ok: TC |- parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*} , parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    -- let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} = argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
    -- let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} = argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
    -- (if (argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}
    (output) prefixedNameIR ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:219.1-222.26
relation TableEntry_priority_ok: typingContext tableContext tableEntryState |- tableEntryPriority? : tableContext tableEntryPriorityOptIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:612.1-676.2
  rulegroup non-specified
   match
    (expl-input) TC | tableContext | TBLS | ?()
    (impl-input) TC | tableContext | TBLS | tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}
    (impl-input-premises)
    -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
   paths
  {
    rulepath nopri
    (premises)
    -- let TBLC = tableContext
    -- if (TBLC.mode = nopri)
    (output) TBLC | ?()

    rulepath noprilpm
    (premises)
    -- let TBLC = tableContext
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- let tableEntryState = TBLS
    -- if tableEntryState matches `LPM%`
    -- let lpm n_prefix = tableEntryState
    (output) TBLC | ?()

    rulepath pri-prilpm-number-init-largest-wins
    (premises)
    -- let TBLC_0 = tableContext
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if (TBLC_0.priorities.values = [])
    -- if TBLC_0.priorities.largest_wins
    -- let n_size = TBLC_0.entries.size
    -- let n_delta = TBLC_0.priorities.delta
    -- let n = (((n_size - 1) * n_delta) + 1)
    -- let TBLC_1 = $add_table_priority(TBLC_0, n)
    (output) TBLC_1 | ?(priority= d n as int :)

    rulepath pri-prilpm-number-init-non-largest-wins
    (premises)
    -- let TBLC_0 = tableContext
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if (TBLC_0.priorities.values = [])
    -- if ~TBLC_0.priorities.largest_wins
    -- let TBLC_1 = $add_table_priority(TBLC_0, 1)
    (output) TBLC_1 | ?(priority= d 1 as int :)

    rulepath pri-prilpm-number-non-init-largest-wins
    (premises)
    -- let TBLC_0 = tableContext
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if (TBLC_0.priorities.values =/= [])
    -- if TBLC_0.priorities.largest_wins
    -- let n_last = $find_table_priority_last(TBLC_0)
    -- let n_delta = TBLC_0.priorities.delta
    -- let n = (n_last - n_delta)
    -- let TBLC_1 = $add_table_priority(TBLC_0, n)
    (output) TBLC_1 | ?(priority= d n as int :)

    rulepath pri-prilpm-number-non-init-non-largest-wins
    (premises)
    -- let TBLC_0 = tableContext
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if (TBLC_0.priorities.values =/= [])
    -- if ~TBLC_0.priorities.largest_wins
    -- let n_last = $find_table_priority_last(TBLC_0)
    -- let n_delta = TBLC_0.priorities.delta
    -- let n = (n_last + n_delta)
    -- let TBLC_1 = $add_table_priority(TBLC_0, n)
    (output) TBLC_1 | ?(priority= d n as int :)
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:680.1-708.2
  rulegroup specified-number
   match
    (expl-input) TC | TBLC_0 | TBLS | ?(priority= numberLiteral :)
    (impl-input) TC | TBLC_0 | TBLS | tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
    (impl-input-premises)
    -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
    -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
    -- if tableEntryPriority matches `PRIORITY=%:`
    -- let priority= numberLiteral : = tableEntryPriority
   paths
  {
    rulepath pri-prilpm-number-init
    (premises)
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if ~TBLC_0.entries.const
    -- if (TBLC_0.priorities.values = [])
    -- let int = $to_number(numberLiteral as value)
    -- if int <: nat
    -- let n = int as nat
    -- let TBLC_1 = TBLC_0[priorities.init = true]
    -- let TBLC_2 = $add_table_priority(TBLC_1, n)
    (output) TBLC_2 | ?(priority= numberLiteral :)

    rulepath pri-prilpm-number-non-init
    (premises)
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if ~TBLC_0.entries.const
    -- if (TBLC_0.priorities.values =/= [])
    -- if TBLC_0.priorities.init
    -- let int = $to_number(numberLiteral as value)
    -- if int <: nat
    -- let n = int as nat
    -- let TBLC_1 = $add_table_priority(TBLC_0, n)
    (output) TBLC_1 | ?(priority= numberLiteral :)
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:712.1-746.2
  rulegroup specified-expression
   match
    (expl-input) TC | TBLC_0 | TBLS | ?(priority=( expression ):)
    (impl-input) TC | TBLC_0 | TBLS | tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
    (impl-input-premises)
    -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
    -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
    -- if tableEntryPriority matches `PRIORITY=(%):`
    -- let priority=( expression ): = tableEntryPriority
   paths
  {
    rulepath pri-prilpm-expression-init
    (premises)
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if ~TBLC_0.entries.const
    -- if (TBLC_0.priorities.values = [])
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR
    -- if ctk matches `LCTK`
    -- Eval_static: local TC |- typedExpressionIR ~> value
    -- let int = $to_number(value)
    -- if int <: nat
    -- let n = int as nat
    -- let TBLC_1 = TBLC_0[priorities.init = true]
    -- let TBLC_2 = $add_table_priority(TBLC_1, n)
    (output) TBLC_2 | ?(priority=( typedExpressionIR ):)

    rulepath pri-prilpm-expression-non-init
    (premises)
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if ~TBLC_0.entries.const
    -- if (TBLC_0.priorities.values =/= [])
    -- if TBLC_0.priorities.init
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR
    -- if ctk matches `LCTK`
    -- Eval_static: local TC |- typedExpressionIR ~> value
    -- let int = $to_number(value)
    -- if int <: nat
    -- let n = int as nat
    -- let TBLC_1 = $add_table_priority(TBLC_0, n)
    (output) TBLC_1 | ?(priority=( typedExpressionIR ):)
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:224.1-226.23
relation TableEntry_ok: typingContext tableContext |- tableEntry : tableContext tableEntryIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:751.1-766.73
  rulegroup priority
   match
    (expl-input) TC | TBLC_0 | constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ;
    (impl-input) TC | TBLC_0 | tableEntry
    (impl-input-premises)
    -- if tableEntry matches `%%%:%%;`
    -- let constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ; = tableEntry
   paths
  {
    rulepath priority
    (premises)
    -- TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR
    -- TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR
    -- TableEntry_priority_ok: TC TBLC_0 TBLS |- ?(tableEntryPriority) : TBLC_1 tableEntryPriorityOptIR
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tableEntryIR = constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;
    (output) TBLC_1 | tableEntryIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:770.1-784.73
  rulegroup non-priority
   match
    (expl-input) TC | TBLC_0 | constOpt keysetExpression : tableActionReference annotationList ;
    (impl-input) TC | TBLC_0 | tableEntry
    (impl-input-premises)
    -- if tableEntry matches `%%:%%;`
    -- let constOpt keysetExpression : tableActionReference annotationList ; = tableEntry
   paths
  {
    rulepath non-priority
    (premises)
    -- TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR
    -- TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR
    -- TableEntry_priority_ok: TC TBLC_0 TBLS |- ?() : TBLC_1 tableEntryPriorityOptIR
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tableEntryIR = constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;
    (output) TBLC_1 | tableEntryIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:228.1-230.23
relation TableEntries_ok: typingContext tableContext |- tableEntry* : tableContext tableEntryListIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:792.1-793.28
  rulegroup nil
   match
    (expl-input) TC | TBLC | []
    (impl-input) TC | TBLC | tableEntry*{tableEntry <- tableEntry*}
    (impl-input-premises)
    -- if tableEntry*{tableEntry <- tableEntry*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TBLC | []
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:795.1-799.74
  rulegroup cons
   match
    (expl-input) TC | TBLC_0 | tableEntry_h :: tableEntry_t*{}
    (impl-input) TC | TBLC_0 | tableEntry*{tableEntry <- tableEntry*}
    (impl-input-premises)
    -- if tableEntry*{tableEntry <- tableEntry*} matches _ :: _
    -- let tableEntry_h :: tableEntry_t*{tableEntry_t <- tableEntry_t*} = tableEntry*{tableEntry <- tableEntry*}
   paths
  {
    rulepath cons
    (premises)
    -- TableEntry_ok: TC TBLC_0 |- tableEntry_h : TBLC_1 tableEntryIR_h
    -- TableEntries_ok: TC TBLC_1 |- tableEntry_t*{tableEntry_t <- tableEntry_t*} : TBLC_2 tableEntryIR_t*{tableEntryIR_t <- tableEntryIR_t*}
    (output) TBLC_2 | tableEntryIR_h :: tableEntryIR_t*{tableEntryIR_t <- tableEntryIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:232.1-234.23
relation TableProperty_ok: typingContext tableContext |- tableProperty : tableContext tablePropertyIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:809.1-813.63
  rulegroup key
   match
    (expl-input) TC | TBLC_0 | key={ tableKeyList }
    (impl-input) TC | TBLC_0 | tableProperty
    (impl-input-premises)
    -- if tableProperty matches `KEY={%}`
    -- let key={ tableKeyList } = tableProperty
   paths
  {
    rulepath key
    (premises)
    -- let tableKey*{tableKey <- tableKey*} = $flatten_tableKeyList(tableKeyList)
    -- TableKeys_ok: TC TBLC_0 |- tableKey*{tableKey <- tableKey*} : TBLC_1 tableKeyIR*{tableKeyIR <- tableKeyIR*}
    (output) TBLC_1 | key={ tableKeyIR*{tableKeyIR <- tableKeyIR*} }
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:817.1-821.72
  rulegroup actions
   match
    (expl-input) TC | TBLC_0 | actions={ tableActionList }
    (impl-input) TC | TBLC_0 | tableProperty
    (impl-input-premises)
    -- if tableProperty matches `ACTIONS={%}`
    -- let actions={ tableActionList } = tableProperty
   paths
  {
    rulepath actions
    (premises)
    -- let tableAction*{tableAction <- tableAction*} = $flatten_tableActionList(tableActionList)
    -- TableActions_ok: TC TBLC_0 |- tableAction*{tableAction <- tableAction*} : TBLC_1 tableActionIR*{tableActionIR <- tableActionIR*}
    (output) TBLC_1 | actions={ tableActionIR*{tableActionIR <- tableActionIR*} }
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:825.1-837.70
  rulegroup entries
   match
    (expl-input) TC | TBLC_0 | annotationList constOpt entries={ tableEntryList }
    (impl-input) TC | TBLC_0 | tableProperty
    (impl-input-premises)
    -- if tableProperty matches `%%ENTRIES={%}`
    -- let annotationList constOpt entries={ tableEntryList } = tableProperty
   paths
  {
    rulepath entries
    (premises)
    -- let tableEntry*{tableEntry <- tableEntry*} = $flatten_tableEntryList(tableEntryList)
    -- if ((|TBLC_0.keys| = 0) => (|tableEntry*{tableEntry <- tableEntry*}| = 0))
    -- let TBLC_1 = TBLC_0[entries.size = |tableEntry*{tableEntry <- tableEntry*}|]
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let TBLC_2 = TBLC_1[entries.const = (constOptIR = ?(const))]
    -- TableEntries_ok: TC TBLC_2 |- tableEntry*{tableEntry <- tableEntry*} : TBLC_3 tableEntryIR*{tableEntryIR <- tableEntryIR*}
    (output) TBLC_3 | annotationList constOptIR entries={ tableEntryIR*{tableEntryIR <- tableEntryIR*} }
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:841.1-851.78
  rulegroup default-action
   match
    (expl-input) TC | TBLC | annotationList constOpt tableCustomName initializer ;
    (impl-input) TC | TBLC | tableProperty
    (impl-input-premises)
    -- if tableProperty matches `%%%%;`
    -- let annotationList constOpt tableCustomName initializer ; = tableProperty
   paths
  {
    rulepath default-action
    (premises)
    -- if ("default_action" = $tableCustomName(tableCustomName))
    -- TableDefaultAction_ok: TC TBLC |- initializer : tableActionReferenceIR
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tablePropertyIR = annotationList constOptIR default_action= tableActionReferenceIR ;
    (output) TBLC | tablePropertyIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:853.1-925.2
  rulegroup custom
   match
    (expl-input) TC | tableContext | annotationList constOpt tableCustomName = expression ;
    (impl-input) TC | tableContext | tableProperty
    (impl-input-premises)
    -- if tableProperty matches `%%%%;`
    -- let annotationList constOpt tableCustomName = expression ; = tableProperty
   paths
  {
    rulepath size
    (premises)
    -- let TBLC = tableContext
    -- if ("size" = $tableCustomName(tableCustomName))
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
    -- if (($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tablePropertyIR = annotationList constOptIR custom "size" = typedExpressionIR ;
    (output) TBLC | tablePropertyIR

    rulepath largest-priority-wins
    (premises)
    -- let TBLC_0 = tableContext
    -- if ("largest_priority_wins" = $tableCustomName(tableCustomName))
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR' _ctk ) = typedExpressionIR
    -- if (typeIR' = bool as typeIR)
    -- Eval_static: local TC |- typedExpressionIR ~> value'
    -- if value' <: primitiveValue
    -- let primitiveValue = value' as primitiveValue
    -- if primitiveValue matches `B%`
    -- let b b_largest_priority_wins = primitiveValue
    -- let TBLC_1 = TBLC_0[priorities.largest_wins = b_largest_priority_wins]
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tablePropertyIR = annotationList constOptIR custom_const "largest_priority_wins" = b b_largest_priority_wins as value ;
    (output) TBLC_1 | tablePropertyIR

    rulepath priority-delta
    (premises)
    -- let TBLC_0 = tableContext
    -- if ("priority_delta" = $tableCustomName(tableCustomName))
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
    -- if (($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))
    -- Eval_static: local TC |- typedExpressionIR ~> value
    -- let int = $to_number(value)
    -- if int <: nat
    -- let n_delta = int as nat
    -- if (n_delta > 0)
    -- let TBLC_1 = TBLC_0[priorities.delta = n_delta]
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tablePropertyIR = annotationList constOptIR custom_const "priority_delta" = d n_delta as int as value ;
    (output) TBLC_1 | tablePropertyIR

    rulepath unknown
    (premises)
    -- let TBLC = tableContext
    -- let nameIR = $tableCustomName(tableCustomName)
    -- if (((nameIR =/= "size") /\ (nameIR =/= "largest_priority_wins")) /\ (nameIR =/= "priority_delta"))
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tablePropertyIR = annotationList constOptIR custom nameIR = typedExpressionIR ;
    (output) TBLC | tablePropertyIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:236.1-238.23
relation TableProperties_ok: typingContext tableContext |- tableProperty* : tableContext tablePropertyListIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:933.1-934.28
  rulegroup nil
   match
    (expl-input) TC | TBLC | []
    (impl-input) TC | TBLC | tableProperty*{tableProperty <- tableProperty*}
    (impl-input-premises)
    -- if tableProperty*{tableProperty <- tableProperty*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TBLC | []
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:936.1-940.83
  rulegroup cons
   match
    (expl-input) TC | TBLC_0 | tableProperty_h :: tableProperty_t*{}
    (impl-input) TC | TBLC_0 | tableProperty*{tableProperty <- tableProperty*}
    (impl-input-premises)
    -- if tableProperty*{tableProperty <- tableProperty*} matches _ :: _
    -- let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty*{tableProperty <- tableProperty*}
   paths
  {
    rulepath cons
    (premises)
    -- TableProperty_ok: TC TBLC_0 |- tableProperty_h : TBLC_1 tablePropertyIR_h
    -- TableProperties_ok: TC TBLC_1 |- tableProperty_t*{tableProperty_t <- tableProperty_t*} : TBLC_2 tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*}
    (output) TBLC_2 | tablePropertyIR_h :: tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:240.1-242.20
relation Table_ok: typingContext |- tableProperty* : tableContext tablePropertyListIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:974.1-982.79
  rulegroup 
   match
    (expl-input) TC | tableProperty*{}
    (impl-input) TC | tableProperty*{tableProperty <- tableProperty*}
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- if ($count_table_keys(tableProperty*{tableProperty <- tableProperty*}) <= 1)
    -- if ($count_table_actions(tableProperty*{tableProperty <- tableProperty*}) = 1)
    -- let TBLC_0 = $empty_tableContext
    -- TableProperties_ok: TC TBLC_0 |- tableProperty*{tableProperty <- tableProperty*} : TBLC_1 tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
    (output) TBLC_1 | tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:244.1-246.23
relation TableType_ok: typingContext tableContext |- name : typingContext typeIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:984.1-1010.59
  rulegroup 
   match
    (expl-input) TC_0 | TBLC | name
    (impl-input) TC_0 | TBLC | name
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let nameIR = $name(name)
    -- let tid_enum = "action_list(" ++ nameIR ++ ")"
    -- let (prefixedNameIR_action, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentListIR)*{_argumentListIR <- _argumentListIR*, _parameterTypeIR* <- _parameterTypeIR**, prefixedNameIR_action <- prefixedNameIR_action*} = TBLC.actions
    -- (let id_enum_field = $flatten_prefixedNameIR(prefixedNameIR_action))*{id_enum_field <- id_enum_field*, prefixedNameIR_action <- prefixedNameIR_action*}
    -- let typeIR_table_enum = table_enum tid_enum { id_enum_field*{id_enum_field <- id_enum_field*} } as typeIR
    -- (let value_enum_field = table_enum tid_enum . id_enum_field as value)*{id_enum_field <- id_enum_field*, value_enum_field <- value_enum_field*}
    -- (let varTypeIR_enum_field = typeIR_table_enum lctk ?(value_enum_field))*{value_enum_field <- value_enum_field*, varTypeIR_enum_field <- varTypeIR_enum_field*}
    -- let TC_1 = $add_vars(block, TC_0, tid_enum ++ "." ++ id_enum_field*{id_enum_field <- id_enum_field*}, varTypeIR_enum_field*{varTypeIR_enum_field <- varTypeIR_enum_field*})
    -- let tid_struct = "apply_result(" ++ nameIR ++ ")"
    -- let typeIR_table_struct = table_struct tid_struct { [bool as typeIR "hit" ;, bool as typeIR "miss" ;, typeIR_table_enum "action_run" ;] } as typeIR
    -- let typeIR_table = table nameIR # typeIR_table_struct as typeIR
    (output) TC_1 | typeIR_table
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:248.1-251.20
relation ControlLocalDecl_ok: typingContext |- controlLocalDeclaration : typingContext controlLocalDeclarationIR
  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:9.1-11.77
  rulegroup constantDeclaration
   match
    (expl-input) TC_0 | constantDeclaration as controlLocalDeclaration
    (impl-input) TC_0 | controlLocalDeclaration
    (impl-input-premises)
    -- if controlLocalDeclaration <: constantDeclaration
    -- let constantDeclaration = controlLocalDeclaration as constantDeclaration
   paths
  {
    rulepath constantDeclaration
    (premises)
    -- Decl_ok: block TC_0 |- constantDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: constantDeclarationIR
    -- let constantDeclarationIR = declarationIR as constantDeclarationIR
    (output) TC_1 | constantDeclarationIR as controlLocalDeclarationIR
  }

  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:15.1-17.65
  rulegroup instantiation
   match
    (expl-input) TC_0 | instantiation as controlLocalDeclaration
    (impl-input) TC_0 | controlLocalDeclaration
    (impl-input-premises)
    -- if controlLocalDeclaration <: instantiation
    -- let instantiation = controlLocalDeclaration as instantiation
   paths
  {
    rulepath instantiation
    (premises)
    -- Decl_ok: block TC_0 |- instantiation as declaration : TC_1 declarationIR
    -- if declarationIR <: instantiationIR
    -- let instantiationIR = declarationIR as instantiationIR
    (output) TC_1 | instantiationIR as controlLocalDeclarationIR
  }

  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:23.1-61.2
  rulegroup variableDeclaration
   match
    (expl-input) TC_0 | annotationList type name initializerOpt ; as controlLocalDeclaration
    (impl-input) TC_0 | controlLocalDeclaration
    (impl-input-premises)
    -- if controlLocalDeclaration <: variableDeclaration
    -- let annotationList type name initializerOpt ; = controlLocalDeclaration as variableDeclaration
   paths
  {
    rulepath empty
    (premises)
    -- if ( = initializerOpt)
    -- Type_ok: block TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(block, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(block, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?() ;
    (output) TC_1 | variableDeclarationIR as controlLocalDeclarationIR

    rulepath initializer
    (premises)
    -- let initializerOpt' = initializerOpt
    -- if initializerOpt' <: initializer
    -- let = expression_init = initializerOpt' as initializer
    -- Type_ok: block TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(block, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- Expr_ok: block TC_0 |- expression_init : typedExpressionIR_init
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(block, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?(= typedExpressionIR_init_cast) ;
    (output) TC_1 | variableDeclarationIR as controlLocalDeclarationIR
  }

  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:65.1-67.73
  rulegroup actionDeclaration
   match
    (expl-input) TC_0 | actionDeclaration as controlLocalDeclaration
    (impl-input) TC_0 | controlLocalDeclaration
    (impl-input-premises)
    -- if controlLocalDeclaration <: actionDeclaration
    -- let actionDeclaration = controlLocalDeclaration as actionDeclaration
   paths
  {
    rulepath actionDeclaration
    (premises)
    -- Decl_ok: block TC_0 |- actionDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: actionDeclarationIR
    -- let actionDeclarationIR = declarationIR as actionDeclarationIR
    (output) TC_1 | actionDeclarationIR as controlLocalDeclarationIR
  }

  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:73.1-87.71
  rulegroup tableDeclaration
   match
    (expl-input) TC_0 | annotationList table name { tablePropertyList } as controlLocalDeclaration
    (impl-input) TC_0 | controlLocalDeclaration
    (impl-input-premises)
    -- if controlLocalDeclaration <: tableDeclaration
    -- let annotationList table name { tablePropertyList } = controlLocalDeclaration as tableDeclaration
   paths
  {
    rulepath tableDeclaration
    (premises)
    -- let TC_1 = TC_0[local.kind = table_apply_method]
    -- let tableProperty*{tableProperty <- tableProperty*} = $flatten_tablePropertyList(tablePropertyList)
    -- Table_ok: TC_1 |- tableProperty*{tableProperty <- tableProperty*} : TBLC tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
    -- let nameIR = $name(name)
    -- TableType_ok: TC_1 TBLC |- name : TC_2 typeIR_table
    -- let TC_3 = $add_var(block, TC_2, nameIR, typeIR_table dyn ?())
    -- let tableDeclarationIR = annotationList table typeIR_table nameIR { tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} }
    (output) TC_3 | tableDeclarationIR as controlLocalDeclarationIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:253.1-256.20
relation ControlLocalDecls_ok: typingContext |- controlLocalDeclaration* : typingContext controlLocalDeclarationIR*
  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:95.1-96.21
  rulegroup nil
   match
    (expl-input) TC | []
    (impl-input) TC | controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}
    (impl-input-premises)
    -- if controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TC | []
  }

  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:98.1-104.69
  rulegroup cons
   match
    (expl-input) TC_0 | controlLocalDeclaration_h :: controlLocalDeclaration_t*{}
    (impl-input) TC_0 | controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}
    (impl-input-premises)
    -- if controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} matches _ :: _
    -- let controlLocalDeclaration_h :: controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} = controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}
   paths
  {
    rulepath cons
    (premises)
    -- ControlLocalDecl_ok: TC_0 |- controlLocalDeclaration_h : TC_1 controlLocalDeclarationIR_h
    -- ControlLocalDecls_ok: TC_1 |- controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} : TC_2 controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*}
    (output) TC_2 | controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:262.1-264.23
relation Decl_ok: cursor typingContext |- declaration : typingContext declarationIR
  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:9.1-29.57
  rulegroup constantDeclaration
   match
    (expl-input) p | TC_0 | annotationList const type name = expression_value ; as declaration
    (impl-input) p | TC_0 | declaration
    (impl-input-premises)
    -- if declaration <: constantDeclaration
    -- let annotationList const type name = expression_value ; = declaration as constantDeclaration
   paths
  {
    rulepath constantDeclaration
    (premises)
    -- Type_ok: p TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(p, TC_0) |- typeIR holds
    -- Expr_ok: p TC_0 |- expression_value : typedExpressionIR_value
    -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR_value
    -- if ctk matches `LCTK`
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_value, typeIR)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_value_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- Eval_static: p TC_0 |- typedExpressionIR_value_cast ~> value
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(p, TC_0, nameIR, typeIR lctk ?(value))
    -- let constantDeclarationIR = annotationList const typeIR nameIR = value ;
    (output) TC_1 | constantDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:36.1-88.2
  rulegroup instantiation-non-objectInitializer
   match
    (expl-input) p | TC_0 | annotationList type ( argumentList ) name ; as declaration
    (impl-input) p | TC_0 | declaration
    (impl-input-premises)
    -- if declaration <: instantiation
    -- let instantiation = declaration as instantiation
    -- if instantiation matches `%%(%)%;`
    -- let annotationList type ( argumentList ) name ; = instantiation
   paths
  {
    rulepath prefixedTypeName
    (premises)
    -- let type' = type
    -- if type' <: prefixedTypeName
    -- let prefixedTypeName = type' as prefixedTypeName
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- ConstructorType_ok: p TC_0 |- prefixedNameIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
    -- Inst_ok: p TC_0 named |- constructorTypeIR < [] # tid_impl*{tid_impl <- tid_impl*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(p, TC_0, nameIR, typeIR_object ctk ?())
    -- let instantiationIR = annotationList typeIR_object prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR*{argumentIR <- argumentIR*} ) nameIR ?() ;
    (output) TC_1 | instantiationIR as declarationIR

    rulepath specializedType
    (premises)
    -- let type' = type
    -- if type' <: specializedType
    -- let prefixedTypeName < typeArgumentList > = type' as specializedType
    -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
    -- TypeArguments_ok: p TC_0 |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- ConstructorType_ok: p TC_0 |- prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
    -- Inst_ok: p TC_0 named |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(p, TC_0, nameIR, typeIR_object ctk ?())
    -- let instantiationIR = annotationList typeIR_object prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR*{argumentIR <- argumentIR*} ) nameIR ?() ;
    (output) TC_1 | instantiationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:194.1-289.2
  rulegroup instantiation-objectInitializer
   match
    (expl-input) p | TC_0 | annotationList type ( argumentList ) name ={ objectDeclarationList } ; as declaration
    (impl-input) p | TC_0 | declaration
    (impl-input-premises)
    -- if declaration <: instantiation
    -- let instantiation = declaration as instantiation
    -- if instantiation matches `%%(%)%%;`
    -- let annotationList type ( argumentList ) name ={ objectDeclarationList } ; = instantiation
   paths
  {
    rulepath prefixedTypeName
    (premises)
    -- let type' = type
    -- if type' <: prefixedTypeName
    -- let prefixedTypeName = type' as prefixedTypeName
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- ConstructorType_ok: p TC_0 |- prefixedNameIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
    -- Inst_ok: p TC_0 named |- constructorTypeIR < [] # tid_impl*{tid_impl <- tid_impl*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if $is_extern_object_typeIR($canon(typeIR_object))
    -- let typeIR' = typeIR_object
    -- if typeIR' <: namedTypeIR
    -- let namedTypeIR = typeIR' as namedTypeIR
    -- if namedTypeIR matches `%<%>`
    -- let typeIR < tid_expl*{tid_expl <- tid_expl*} , tid'*{tid' <- tid'*} > < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR
    -- if typeIR <: externObjectTypeIR
    -- let extern tid_extern rdenv_extern = typeIR as externObjectTypeIR
    -- if (tid'*{tid' <- tid'*} = tid_impl*{tid_impl <- tid_impl*})
    -- let TC_1 = $add_var(local, TC_0, "this", typeIR_object ctk ?())
    -- let objectDeclaration*{objectDeclaration <- objectDeclaration*} = $flatten_objectDeclarationList(objectDeclarationList)
    -- Decls_object_ok: p TC_1 { [] } { [] } |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : frame_init rdenv_init objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*}
    -- let tid*{tid <- tid*} = tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}
    -- let theta = { tid : typeIR_arg*{tid <- tid*, typeIR_arg <- typeIR_arg*} }
    -- let rdenv_init_subst = $subst_rdenv(theta, rdenv_extern, rdenv_init)
    -- let typeIR_object_init = extern tid_extern rdenv_init_subst as typeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > < typeIR_arg*{typeIR_arg <- typeIR_arg*} > as typeIR
    -- if $is_concrete_extern_object(typeIR_object_init)
    -- let nameIR = $name(name)
    -- let TC_2 = $add_var(p, TC_0, nameIR, typeIR_object_init ctk ?())
    -- let instantiationIR = annotationList typeIR_object_init prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR*{argumentIR <- argumentIR*} ) nameIR ?(={ objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*} }) ;
    (output) TC_2 | instantiationIR as declarationIR

    rulepath specializedType
    (premises)
    -- let type' = type
    -- if type' <: specializedType
    -- let prefixedTypeName < typeArgumentList > = type' as specializedType
    -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
    -- TypeArguments_ok: p TC_0 |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- ConstructorType_ok: p TC_0 |- prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
    -- Inst_ok: p TC_0 named |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if $is_extern_object_typeIR($canon(typeIR_object))
    -- let typeIR' = typeIR_object
    -- if typeIR' <: namedTypeIR
    -- let namedTypeIR = typeIR' as namedTypeIR
    -- if namedTypeIR matches `%<%>`
    -- let typeIR < tid_expl*{tid_expl <- tid_expl*} , tid'*{tid' <- tid'*} > < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR
    -- if typeIR <: externObjectTypeIR
    -- let extern tid_extern rdenv_extern = typeIR as externObjectTypeIR
    -- if (tid'*{tid' <- tid'*} = tid_impl*{tid_impl <- tid_impl*})
    -- let TC_1 = $add_var(local, TC_0, "this", typeIR_object ctk ?())
    -- let objectDeclaration*{objectDeclaration <- objectDeclaration*} = $flatten_objectDeclarationList(objectDeclarationList)
    -- Decls_object_ok: p TC_1 { [] } { [] } |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : frame_init rdenv_init objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*}
    -- let tid*{tid <- tid*} = tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}
    -- let theta = { tid : typeIR_arg*{tid <- tid*, typeIR_arg <- typeIR_arg*} }
    -- let rdenv_init_subst = $subst_rdenv(theta, rdenv_extern, rdenv_init)
    -- let typeIR_object_init = extern tid_extern rdenv_init_subst as typeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > < typeIR_arg*{typeIR_arg <- typeIR_arg*} > as typeIR
    -- if $is_concrete_extern_object(typeIR_object_init)
    -- let nameIR = $name(name)
    -- let TC_2 = $add_var(p, TC_0, nameIR, typeIR_object_init ctk ?())
    -- let instantiationIR = annotationList typeIR_object_init prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR*{argumentIR <- argumentIR*} ) nameIR ?(={ objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*} }) ;
    (output) TC_2 | instantiationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:297.1-328.27
  rulegroup functionDeclaration
   match
    (expl-input) p | TC_0 | annotationList typeOrVoid name typeParameterListOpt ( parameterList ) blockStatement as declaration
    (impl-input) p | TC_0 | declaration
    (impl-input-premises)
    -- if declaration <: functionDeclaration
    -- let annotationList typeOrVoid name typeParameterListOpt ( parameterList ) blockStatement = declaration as functionDeclaration
   paths
  {
    rulepath functionDeclaration
    (premises)
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(local, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- Type_ok: local TC_1 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: local TC_1 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_2 = $add_parameters(local, TC_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let TC_3 = TC_2[local.kind = function-> typeIR_ret]
    -- Block_ok: TC_3 cont |- blockStatement : _typingContext f blockStatementIR
    -- if ((f = ret) \/ (typeIR_ret = void as typeIR))
    -- let rid = $rid(name, parameterList)
    -- let functionTypeIR = function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
    -- let routineTypeDefIR = functionTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
    -- if RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds
    -- let TC_4 = $add_routine_overload(p, TC_0, rid, routineTypeDefIR)
    -- let nameIR = $name(name)
    -- let functionDeclarationIR = annotationList typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) blockStatementIR
    (output) TC_4 | functionDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:334.1-355.72
  rulegroup actionDeclaration
   match
    (expl-input) p | TC_0 | annotationList action name ( parameterList ) blockStatement as declaration
    (impl-input) p | TC_0 | declaration
    (impl-input-premises)
    -- if declaration <: actionDeclaration
    -- let annotationList action name ( parameterList ) blockStatement = declaration as actionDeclaration
   paths
  {
    rulepath actionDeclaration
    (premises)
    -- let TC_1 = TC_0[local.kind = action]
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: local TC_1 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_2 = $add_parameters(local, TC_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- Block_ok: TC_2 cont |- blockStatement : _typingContext _flow blockStatementIR
    -- let rid = $rid(name, parameterList)
    -- let functionTypeIR = action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
    -- if RoutineTypeDef_wf: $bound(p, TC_0) |- functionTypeIR as routineTypeDefIR holds
    -- let TC_3 = $add_routine_non_overload(p, TC_0, rid, functionTypeIR as routineTypeDefIR)
    -- let nameIR = $name(name)
    -- let actionDeclarationIR = annotationList action nameIR ( parameterIR*{parameterIR <- parameterIR*} ) blockStatementIR
    (output) TC_3 | actionDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:360.1-370.88
  rulegroup errorDeclaration
   match
    (expl-input) global | TC_0 | error{ nameList } as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: errorDeclaration
    -- let error{ nameList } = declaration as errorDeclaration
   paths
  {
    rulepath errorDeclaration
    (premises)
    -- let name*{name <- name*} = $flatten_nameList(nameList)
    -- (let nameIR = $name(name))*{name <- name*, nameIR <- nameIR*}
    -- if $distinct_<nameIR>(nameIR*{nameIR <- nameIR*})
    -- (let nameIR_error = "error." ++ nameIR)*{nameIR <- nameIR*, nameIR_error <- nameIR_error*}
    -- (let value_error = error. nameIR as value)*{nameIR <- nameIR*, value_error <- value_error*}
    -- let TC_1 = $add_vars(global, TC_0, nameIR_error*{nameIR_error <- nameIR_error*}, error as typeIR lctk ?(value_error)*{value_error <- value_error*})
    (output) TC_1 | error{ nameIR*{nameIR <- nameIR*} } as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:375.1-384.92
  rulegroup matchKindDeclaration
   match
    (expl-input) global | TC_0 | match_kind{ nameList _trailingCommaOpt } as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: matchKindDeclaration
    -- let match_kind{ nameList _trailingCommaOpt } = declaration as matchKindDeclaration
   paths
  {
    rulepath matchKindDeclaration
    (premises)
    -- let name*{name <- name*} = $flatten_nameList(nameList)
    -- (let nameIR = $name(name))*{name <- name*, nameIR <- nameIR*}
    -- if $distinct_<nameIR>(nameIR*{nameIR <- nameIR*})
    -- (let value_match_kind = match_kind. nameIR as value)*{nameIR <- nameIR*, value_match_kind <- value_match_kind*}
    -- let TC_1 = $add_vars(global, TC_0, nameIR*{nameIR <- nameIR*}, match_kind as typeIR lctk ?(value_match_kind)*{value_match_kind <- value_match_kind*})
    (output) TC_1 | match_kind{ nameIR*{nameIR <- nameIR*} } as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:393.1-420.79
  rulegroup externDeclaration-externFunctionDeclaration
   match
    (expl-input) global | TC_0 | annotationList extern typeOrVoid name typeParameterListOpt ( parameterList ) ; as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: externFunctionDeclaration
    -- let annotationList extern typeOrVoid name typeParameterListOpt ( parameterList ) ; = declaration as externFunctionDeclaration
   paths
  {
    rulepath externDeclaration-externFunctionDeclaration
    (premises)
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(local, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- Type_ok: local TC_1 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- let TC_2 = TC_1[local.kind = extern_function-> typeIR_ret]
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: local TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_3 = $add_parameters(local, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let rid = $rid(name, parameterList)
    -- let functionTypeIR = extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
    -- let routineTypeDefIR = functionTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
    -- if RoutineTypeDef_wf: $bound(global, TC_0) |- routineTypeDefIR holds
    -- let TC_4 = $add_routine_overload(global, TC_0, rid, routineTypeDefIR)
    -- let nameIR = $name(name)
    -- let externFunctionDeclarationIR = annotationList extern typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) ;
    (output) TC_4 | externFunctionDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:448.1-481.73
  rulegroup externDeclaration-externObjectDeclaration
   match
    (expl-input) global | TC_0 | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList } as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: externObjectDeclaration
    -- let annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList } = declaration as externObjectDeclaration
   paths
  {
    rulepath externDeclaration-externObjectDeclaration
    (premises)
    -- let methodPrototype*{methodPrototype <- methodPrototype*} = $flatten_methodPrototypeList(methodPrototypeList)
    -- let (methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*}, methodPrototype_method*{methodPrototype_method <- methodPrototype_method*}) = $split_constructors(methodPrototype*{methodPrototype <- methodPrototype*})
    -- let TC_1 = TC_0[block.kind = extern]
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_2 = $add_types(block, TC_1, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let nameIR = $name(nonTypeName as name)
    -- ExternMethods_ok: TC_2 nameIR |- methodPrototype_method*{methodPrototype_method <- methodPrototype_method*} : TC_3 methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*}
    -- let typeIR_extern = extern nameIR TC_3.block.rdenv as typeIR
    -- let typeDefIR_extern = typeIR_extern < tid_expl*{tid_expl <- tid_expl*} , [] > as typeDefIR
    -- let TC_4 = $add_type(global, TC_0, nameIR, typeDefIR_extern)
    -- let TC_5 = TC_4[block.kind = extern]
    -- let TC_6 = $add_types(block, TC_5, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- ExternConstructors_ok: TC_6 nameIR |- methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*} : TC_7 methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*}
    -- let TC_8 = TC_4[global.cdenv = TC_7.global.cdenv]
    -- let externObjectDeclarationIR = annotationList extern nameIR < tid_expl*{tid_expl <- tid_expl*} , [] >{ methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*} ++ methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} }
    (output) TC_8 | externObjectDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:489.1-536.56
  rulegroup parserDeclaration
   match
    (expl-input) global | TC_0 | annotationList parser name ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList } as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: parserDeclaration
    -- let annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList } = declaration as parserDeclaration
    -- if typeParameterListOpt matches ``EMPTY`
   paths
  {
    rulepath parserDeclaration
    (premises)
    -- let TC_1 = TC_0[block.kind = parser]
    -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_constructorParameterListOpt(constructorParameterListOpt)
    -- ConstructorParameters_ok: block TC_1 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
    -- let TC_2 = $add_parameters(block, TC_1, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*})
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: block TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid'*{tid' <- tid'*}
    -- if tid'*{tid' <- tid'*} matches []
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_3 = $add_parameters(block, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} = $flatten_parserLocalDeclarationList(parserLocalDeclarationList)
    -- ParserLocalDecls_ok: TC_3 |- parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} : TC_4 parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}
    -- let TC_5 = TC_4[local.kind = parser_state]
    -- let parserState*{parserState <- parserState*} = $flatten_parserStateList(parserStateList)
    -- ParserStates_ok: TC_5 |- parserState*{parserState <- parserState*} : parserStateIR*{parserStateIR <- parserStateIR*}
    -- let methodTypeIR = parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
    -- if RoutineTypeDef_wf: $bound(global, TC_0) |- methodTypeIR as routineTypeDefIR holds
    -- let cid = $cid(name, constructorParameterListOpt)
    -- let typeIR_parser = parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
    -- let typeIR_parser_spec = typeIR_parser < [] , [] > < [] > as typeIR
    -- let constructorTypeIR = constructor( constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} )-> typeIR_parser_spec
    -- let constructorTypeDefIR = constructorTypeIR < [] , [] >
    -- if ConstructorTypeDef_wf: $bound(global, TC_0) |- constructorTypeDefIR holds
    -- let TC_6 = $add_constructor(TC_0, cid, constructorTypeDefIR)
    -- let nameIR = $name(name)
    -- let parserDeclarationIR = annotationList parser nameIR < [] >( parameterIR*{parameterIR <- parameterIR*} )( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} parserStateIR*{parserStateIR <- parserStateIR*} }
    (output) TC_6 | parserDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:544.1-590.60
  rulegroup controlDeclaration
   match
    (expl-input) global | TC_0 | annotationList control name ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody } as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: controlDeclaration
    -- let annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody } = declaration as controlDeclaration
    -- if typeParameterListOpt matches ``EMPTY`
   paths
  {
    rulepath controlDeclaration
    (premises)
    -- let TC_1 = TC_0[block.kind = control]
    -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_constructorParameterListOpt(constructorParameterListOpt)
    -- ConstructorParameters_ok: block TC_1 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
    -- let TC_2 = $add_parameters(block, TC_1, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*})
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: block TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid'*{tid' <- tid'*}
    -- if tid'*{tid' <- tid'*} matches []
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_3 = $add_parameters(block, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} = $flatten_controlLocalDeclarationList(controlLocalDeclarationList)
    -- ControlLocalDecls_ok: TC_3 |- controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} : TC_4 controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
    -- let TC_5 = TC_4[local.kind = control_apply_method]
    -- Block_ok: TC_5 cont |- controlBody : _typingContext _flow controlBodyIR
    -- let methodTypeIR = control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
    -- if RoutineTypeDef_wf: $bound(global, TC_0) |- methodTypeIR as routineTypeDefIR holds
    -- let cid = $cid(name, constructorParameterListOpt)
    -- let typeIR_control = control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
    -- let typeIR_control_spec = typeIR_control < [] , [] > < [] > as typeIR
    -- let constructorTypeIR = constructor( constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} )-> typeIR_control_spec
    -- let constructorTypeDefIR = constructorTypeIR < [] , [] >
    -- if ConstructorTypeDef_wf: $bound(global, TC_0) |- constructorTypeDefIR holds
    -- let TC_6 = $add_constructor(TC_0, cid, constructorTypeDefIR)
    -- let nameIR = $name(name)
    -- let controlDeclarationIR = annotationList control nameIR < [] >( parameterIR*{parameterIR <- parameterIR*} )( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} apply controlBodyIR }
    (output) TC_6 | controlDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:603.1-620.54
  rulegroup typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration
   match
    (expl-input) global | TC_0 | annotationList enum name { nameList_field _trailingCommaOpt } as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: enumTypeDeclaration
    -- let enumTypeDeclaration = declaration as enumTypeDeclaration
    -- if enumTypeDeclaration matches `%ENUM%{%%}`
    -- let annotationList enum name { nameList_field _trailingCommaOpt } = enumTypeDeclaration
   paths
  {
    rulepath typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration
    (premises)
    -- let nameIR = $name(name)
    -- let name_field*{name_field <- name_field*} = $flatten_nameList(nameList_field)
    -- (let nameIR_field = $name(name_field))*{nameIR_field <- nameIR_field*, name_field <- name_field*}
    -- let typeIR_enum = enum nameIR { nameIR_field*{nameIR_field <- nameIR_field*} } as typeIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_enum as typeDefIR holds
    -- let TC_1 = $add_type(global, TC_0, nameIR, typeIR_enum as typeDefIR)
    -- (let id_field = nameIR ++ "." ++ nameIR_field)*{id_field <- id_field*, nameIR_field <- nameIR_field*}
    -- (let value_field = nameIR . nameIR_field as value)*{nameIR_field <- nameIR_field*, value_field <- value_field*}
    -- let TC_2 = $add_vars(global, TC_1, id_field*{id_field <- id_field*}, typeIR_enum lctk ?(value_field)*{value_field <- value_field*})
    -- let enumTypeDeclarationIR = annotationList enum nameIR { nameIR_field*{nameIR_field <- nameIR_field*} }
    (output) TC_2 | enumTypeDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:666.1-689.72
  rulegroup typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration-serializable
   match
    (expl-input) global | TC_0 | annotationList enum type name { namedExpressionList_field _trailingCommaOpt } as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: enumTypeDeclaration
    -- let enumTypeDeclaration = declaration as enumTypeDeclaration
    -- if enumTypeDeclaration matches `%ENUM%%{%%}`
    -- let annotationList enum type name { namedExpressionList_field _trailingCommaOpt } = enumTypeDeclaration
   paths
  {
    rulepath typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration-serializable
    (premises)
    -- Type_ok: global TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(global, TC_0) |- typeIR holds
    -- let nameIR = $name(name)
    -- let namedExpression_field*{namedExpression_field <- namedExpression_field*} = $flatten_namedExpressionList(namedExpressionList_field)
    -- Enum_serializable_fields_ok: TC_0 nameIR typeIR |- namedExpression_field*{namedExpression_field <- namedExpression_field*} : TC_1 namedExpressionIR_field*{namedExpressionIR_field <- namedExpressionIR_field*} # value_field*{value_field <- value_field*}
    -- (let nameIR_field = _typedExpressionIR = namedExpressionIR_field)*{_typedExpressionIR <- _typedExpressionIR*, nameIR_field <- nameIR_field*, namedExpressionIR_field <- namedExpressionIR_field*}
    -- (let id_field = nameIR ++ "." ++ nameIR_field)*{id_field <- id_field*, nameIR_field <- nameIR_field*}
    -- let typeIR_enum = enum nameIR # typeIR { nameIR_field = value_field ;*{nameIR_field <- nameIR_field*, value_field <- value_field*} } as typeIR
    -- let TC_2 = $add_vars(global, TC_0, id_field*{id_field <- id_field*}, typeIR_enum lctk ?(value_field)*{value_field <- value_field*})
    -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_enum as typeDefIR holds
    -- let TC_3 = $add_type(global, TC_2, nameIR, typeIR_enum as typeDefIR)
    -- let enumTypeDeclarationIR = annotationList enum typeIR nameIR { namedExpressionIR_field*{namedExpressionIR_field <- namedExpressionIR_field*} }
    (output) TC_3 | enumTypeDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:695.1-717.66
  rulegroup typeDeclaration-derivedTypeDeclaration-structTypeDeclaration
   match
    (expl-input) global | TC_0 | annotationList struct name typeParameterListOpt { typeFieldList } as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: structTypeDeclaration
    -- let annotationList struct name typeParameterListOpt { typeFieldList } = declaration as structTypeDeclaration
   paths
  {
    rulepath typeDeclaration-derivedTypeDeclaration-structTypeDeclaration
    (premises)
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(block, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let annotationList_field type_field name_field ;*{annotationList_field <- annotationList_field*, name_field <- name_field*, type_field <- type_field*} = $flatten_typeFieldList(typeFieldList)
    -- (Type_ok: block TC_1 |- type_field as typeOrVoid : typeIR_field # tid_impl_field*{tid_impl_field <- tid_impl_field*})*{tid_impl_field* <- tid_impl_field**, typeIR_field <- typeIR_field*, type_field <- type_field*}
    -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_field*{tid_impl_field <- tid_impl_field*}*{tid_impl_field* <- tid_impl_field**})
    -- let nameIR = $name(name)
    -- (let nameIR_field = $name(name_field))*{nameIR_field <- nameIR_field*, name_field <- name_field*}
    -- let typeIR_struct = struct nameIR { typeIR_field nameIR_field ;*{nameIR_field <- nameIR_field*, typeIR_field <- typeIR_field*} } as typeIR
    -- let typeDefIR_struct = typeIR_struct < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_struct holds
    -- let TC_2 = $add_type(global, TC_0, nameIR, typeDefIR_struct)
    -- let structTypeDeclarationIR = annotationList struct nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >{ annotationList_field typeIR_field nameIR_field ;*{annotationList_field <- annotationList_field*, nameIR_field <- nameIR_field*, typeIR_field <- typeIR_field*} }
    (output) TC_2 | structTypeDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:723.1-745.54
  rulegroup typeDeclaration-derivedTypeDeclaration-headerTypeDeclaration
   match
    (expl-input) global | TC_0 | annotationList header name typeParameterListOpt { typeFieldList } as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: headerTypeDeclaration
    -- let annotationList header name typeParameterListOpt { typeFieldList } = declaration as headerTypeDeclaration
   paths
  {
    rulepath typeDeclaration-derivedTypeDeclaration-headerTypeDeclaration
    (premises)
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(block, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let annotationList_f type_f name_f ;*{annotationList_f <- annotationList_f*, name_f <- name_f*, type_f <- type_f*} = $flatten_typeFieldList(typeFieldList)
    -- (Type_ok: block TC_1 |- type_f as typeOrVoid : typeIR_f # tid_impl_f*{tid_impl_f <- tid_impl_f*})*{tid_impl_f* <- tid_impl_f**, typeIR_f <- typeIR_f*, type_f <- type_f*}
    -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_f*{tid_impl_f <- tid_impl_f*}*{tid_impl_f* <- tid_impl_f**})
    -- let nameIR = $name(name)
    -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
    -- let typeIR_header = header nameIR { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } as typeIR
    -- let typeDefIR_header = typeIR_header < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_header holds
    -- let TC_2 = $add_type(global, TC_0, nameIR, typeDefIR_header)
    -- let headerTypeDeclarationIR = annotationList header nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >{ annotationList_f typeIR_f nameIR_f ;*{annotationList_f <- annotationList_f*, nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} }
    (output) TC_2 | headerTypeDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:751.1-773.54
  rulegroup typeDeclaration-derivedTypeDeclaration-headerUnionTypeDeclaration
   match
    (expl-input) global | TC_0 | annotationList header_union name typeParameterListOpt { typeFieldList } as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: headerUnionTypeDeclaration
    -- let annotationList header_union name typeParameterListOpt { typeFieldList } = declaration as headerUnionTypeDeclaration
   paths
  {
    rulepath typeDeclaration-derivedTypeDeclaration-headerUnionTypeDeclaration
    (premises)
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(block, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let annotationList_f type_f name_f ;*{annotationList_f <- annotationList_f*, name_f <- name_f*, type_f <- type_f*} = $flatten_typeFieldList(typeFieldList)
    -- (Type_ok: block TC_1 |- type_f as typeOrVoid : typeIR_f # tid_impl_f*{tid_impl_f <- tid_impl_f*})*{tid_impl_f* <- tid_impl_f**, typeIR_f <- typeIR_f*, type_f <- type_f*}
    -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_f*{tid_impl_f <- tid_impl_f*}*{tid_impl_f* <- tid_impl_f**})
    -- let nameIR = $name(name)
    -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
    -- let typeIR_union = header_union nameIR { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } as typeIR
    -- let typeDefIR_union = typeIR_union < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_union holds
    -- let TC_2 = $add_type(global, TC_0, nameIR, typeDefIR_union)
    -- let headerUnionTypeDeclarationIR = annotationList header_union nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >{ annotationList_f typeIR_f nameIR_f ;*{annotationList_f <- annotationList_f*, nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} }
    (output) TC_2 | headerUnionTypeDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:784.1-841.2
  rulegroup typeDeclaration-typedefDeclaration-typedef
   match
    (expl-input) global | TC_0 | annotationList typedef typedefType name ; as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: typedefDeclaration
    -- let typedefDeclaration = declaration as typedefDeclaration
    -- if typedefDeclaration matches `%TYPEDEF%%;`
    -- let annotationList typedef typedefType name ; = typedefDeclaration
   paths
  {
    rulepath type
    (premises)
    -- let typedefType' = typedefType
    -- if typedefType' <: type
    -- let type = typedefType' as type
    -- Type_ok: global TC_0 |- type as typeOrVoid : typeIR # tid'*{tid' <- tid'*}
    -- if tid'*{tid' <- tid'*} matches []
    -- if Type_wf: $bound(global, TC_0) |- typeIR holds
    -- let nameIR = $name(name)
    -- let typeIR_typedef = typedef nameIR typeIR as typeIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_typedef as typeDefIR holds
    -- let TC_1 = $add_type(global, TC_0, nameIR, typeIR_typedef as typeDefIR)
    -- let typedefDeclarationIR = annotationList typedef typeIR as typedefTypeIR nameIR ;
    (output) TC_1 | typedefDeclarationIR as declarationIR

    rulepath derivedTypeDeclaration-mono
    (premises)
    -- let typedefType' = typedefType
    -- if typedefType' <: derivedTypeDeclaration
    -- let derivedTypeDeclaration = typedefType' as derivedTypeDeclaration
    -- Decl_ok: global TC_0 |- derivedTypeDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: derivedTypeDeclarationIR
    -- let derivedTypeDeclarationIR = declarationIR as derivedTypeDeclarationIR
    -- let { tid'*{tid' <- tid'*} } = $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.global.tdenv), $dom_map<tid, typeDefIR>(TC_0.global.tdenv))
    -- if tid'*{tid' <- tid'*} matches [ _/1 ]
    -- let [tid] = tid'*{tid' <- tid'*}
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(global, TC_1, ` tid)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR = typeDefIR as typeIR
    -- let nameIR = $name(name)
    -- let typeIR_typedef = typedef nameIR typeIR as typeIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_typedef as typeDefIR holds
    -- let TC_2 = $add_type(global, TC_0, nameIR, typeIR_typedef as typeDefIR)
    -- let typedefDeclarationIR = annotationList typedef derivedTypeDeclarationIR as typedefTypeIR nameIR ;
    (output) TC_1 | typedefDeclarationIR as declarationIR

    rulepath derivedTypeDeclaration-poly
    (premises)
    -- let typedefType' = typedefType
    -- if typedefType' <: derivedTypeDeclaration
    -- let derivedTypeDeclaration = typedefType' as derivedTypeDeclaration
    -- Decl_ok: global TC_0 |- derivedTypeDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: derivedTypeDeclarationIR
    -- let derivedTypeDeclarationIR = declarationIR as derivedTypeDeclarationIR
    -- let { tid'*{tid' <- tid'*} } = $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.global.tdenv), $dom_map<tid, typeDefIR>(TC_0.global.tdenv))
    -- if tid'*{tid' <- tid'*} matches [ _/1 ]
    -- let [tid] = tid'*{tid' <- tid'*}
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(global, TC_1, ` tid)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: polyTypeDefIR
    -- let typeIR < tid''*{tid'' <- tid''*} , tid'''*{tid''' <- tid'''*} > = typeDefIR as polyTypeDefIR
    -- if tid''*{tid'' <- tid''*} matches []
    -- if tid'''*{tid''' <- tid'''*} matches []
    -- let nameIR = $name(name)
    -- let typeIR_typedef = typedef nameIR typeIR < [] , [] > < [] > as typeIR as typeIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_typedef as typeDefIR holds
    -- let TC_2 = $add_type(global, TC_0, nameIR, typeIR_typedef as typeDefIR)
    -- let typedefDeclarationIR = annotationList typedef derivedTypeDeclarationIR as typedefTypeIR nameIR ;
    (output) TC_1 | typedefDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:845.1-858.45
  rulegroup typeDeclaration-typedefDeclaration-newtype
   match
    (expl-input) global | TC_0 | annotationList type type name ; as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: typedefDeclaration
    -- let typedefDeclaration = declaration as typedefDeclaration
    -- if typedefDeclaration matches `%TYPE%%;`
    -- let annotationList type type name ; = typedefDeclaration
   paths
  {
    rulepath typeDeclaration-typedefDeclaration-newtype
    (premises)
    -- Type_ok: global TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(global, TC_0) |- typeIR holds
    -- let nameIR = $name(name)
    -- let typeIR_newtype = type nameIR typeIR as typeIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_newtype as typeDefIR holds
    -- let TC_1 = $add_type(global, TC_0, nameIR, typeIR_newtype as typeDefIR)
    -- let typedefDeclarationIR = annotationList type typeIR nameIR ;
    (output) TC_1 | typedefDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:864.1-885.86
  rulegroup typeDeclaration-parserTypeDeclaration
   match
    (expl-input) global | TC_0 | annotationList parser name typeParameterListOpt ( parameterList ); as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: parserTypeDeclaration
    -- let annotationList parser name typeParameterListOpt ( parameterList ); = declaration as parserTypeDeclaration
   paths
  {
    rulepath typeDeclaration-parserTypeDeclaration
    (premises)
    -- let TC_1 = TC_0[block.kind = parser]
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_2 = $add_types(block, TC_1, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: block TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let nameIR = $name(name)
    -- let typeIR_parser = parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
    -- let typeDefIR_parser = typeIR_parser < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_parser holds
    -- let TC_3 = $add_type(global, TC_0, nameIR, typeDefIR_parser)
    -- let parserTypeDeclarationIR = annotationList parser nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} );
    (output) TC_3 | parserTypeDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:891.1-912.87
  rulegroup typeDeclaration-controlTypeDeclaration
   match
    (expl-input) global | TC_0 | annotationList control name typeParameterListOpt ( parameterList ); as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: controlTypeDeclaration
    -- let annotationList control name typeParameterListOpt ( parameterList ); = declaration as controlTypeDeclaration
   paths
  {
    rulepath typeDeclaration-controlTypeDeclaration
    (premises)
    -- let TC_1 = TC_0[block.kind = control]
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_2 = $add_types(block, TC_1, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: block TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let nameIR = $name(name)
    -- let typeIR_control = control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
    -- let typeDefIR_control = typeIR_control < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_control holds
    -- let TC_3 = $add_type(global, TC_0, nameIR, typeDefIR_control)
    -- let controlTypeDeclarationIR = annotationList control nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} );
    (output) TC_3 | controlTypeDeclarationIR as declarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:918.1-952.40
  rulegroup typeDeclaration-packageTypeDeclaration
   match
    (expl-input) global | TC_0 | annotationList package name typeParameterListOpt ( parameterList ); as declaration
    (impl-input) cursor | TC_0 | declaration
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declaration <: packageTypeDeclaration
    -- let annotationList package name typeParameterListOpt ( parameterList ); = declaration as packageTypeDeclaration
   paths
  {
    rulepath typeDeclaration-packageTypeDeclaration
    (premises)
    -- let TC_1 = TC_0[block.kind = package]
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_2 = $add_types(block, TC_1, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_parameterList(parameterList)
    -- ConstructorParameters_ok: block TC_2 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
    -- let nameIR = $name(name)
    -- (let _direction typeIR_package_inner _id _value?{_value <- _value?} = constructorParameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, constructorParameterTypeIR <- constructorParameterTypeIR*, typeIR_package_inner <- typeIR_package_inner*}
    -- let typeIR_package = package< typeIR_package_inner*{typeIR_package_inner <- typeIR_package_inner*} > as typeIR
    -- let polyTypeDefIR_package = typeIR_package < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >
    -- if TypeDef_wf: $bound(global, TC_0) |- polyTypeDefIR_package as typeDefIR holds
    -- let TC_3 = $add_type(global, TC_0, nameIR, polyTypeDefIR_package as typeDefIR)
    -- let cid = $cid(name, ( parameterList ))
    -- let typeIR_package_spec = polyTypeDefIR_package < tid tid_expl as typeIR*{tid_expl <- tid_expl*} ++ tid tid_impl as typeIR*{tid_impl <- tid_impl*} > as typeIR
    -- let constructorTypeIR = constructor( constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} )-> typeIR_package_spec
    -- let constructorTypeDefIR = constructorTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >
    -- if ConstructorTypeDef_wf: $bound(global, TC_0) |- constructorTypeDefIR holds
    -- let TC_4 = $add_constructor(TC_3, cid, constructorTypeDefIR)
    -- let packageTypeDeclarationIR = annotationList package nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} );
    (output) TC_4 | packageTypeDeclarationIR as declarationIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:266.1-268.23
relation Decls_ok: cursor typingContext |- declaration* : typingContext declarationIR*
  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:958.1-959.23
  rulegroup nil
   match
    (expl-input) p | TC | []
    (impl-input) p | TC | declaration*{declaration <- declaration*}
    (impl-input-premises)
    -- if declaration*{declaration <- declaration*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TC | []
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:961.1-965.64
  rulegroup cons
   match
    (expl-input) p | TC_0 | declaration_h :: declaration_t*{}
    (impl-input) p | TC_0 | declaration*{declaration <- declaration*}
    (impl-input-premises)
    -- if declaration*{declaration <- declaration*} matches _ :: _
    -- let declaration_h :: declaration_t*{declaration_t <- declaration_t*} = declaration*{declaration <- declaration*}
   paths
  {
    rulepath cons
    (premises)
    -- Decl_ok: p TC_0 |- declaration_h : TC_1 declarationIR_h
    -- Decls_ok: p TC_1 |- declaration_t*{declaration_t <- declaration_t*} : TC_2 declarationIR_t*{declarationIR_t <- declarationIR_t*}
    (output) TC_2 | declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:270.1-272.17
relation Program_ok: |- p4program : typingContext p4programIR
  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:971.1-975.65
  rulegroup 
   match
    (expl-input) p4program
    (impl-input) p4program
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let declaration*{declaration <- declaration*} = $flatten_p4program(p4program)
    -- let TC_0 = $empty_typingContext
    -- Decls_ok: global TC_0 |- declaration*{declaration <- declaration*} : TC_1 declarationIR*{declarationIR <- declarationIR*}
    (output) TC_1 | declarationIR*{declarationIR <- declarationIR*} ;
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:282.18-282.35
syntax actctxt = 
   | action
   | noaction

;; ../../../../spec-concrete/5.04-typing-relation.watsup:284.1-287.29
relation Call_convention_expr_ok: cursor typingContext actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR
  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:51.1-56.59
  rulegroup in
   match
    (expl-input) p | TC | actctxt | in typeIR_param _id _value?{} | typedExpressionIR_arg
    (impl-input) p | TC | actctxt | direction typeIR_param _id _value?{_value <- _value?} | typedExpressionIR_arg
    (impl-input-premises)
    -- if direction matches `IN`
   paths
  {
    rulepath in
    (premises)
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    (output) typedExpressionIR_arg_cast
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:101.1-109.51
  rulegroup out-inout
   match
    (expl-input) p | TC | actctxt | direction typeIR_param _id _value?{} | typedExpressionIR_arg
    (impl-input) p | TC | actctxt | direction typeIR_param _id _value?{_value <- _value?} | typedExpressionIR_arg
    (impl-input-premises)
   paths
  {
    rulepath out-inout
    (premises)
    -- if ((direction = out) \/ (direction = inout))
    -- let _expressionIR # ( typeIR_arg _ctk ) = typedExpressionIR_arg
    -- if Type_alpha: typeIR_param ~~ typeIR_arg holds
    -- if Expr_lvalue_ok: p TC |- typedExpressionIR_arg holds
    (output) typedExpressionIR_arg
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:113.1-131.2
  rulegroup empty
   match
    (expl-input) p | TC | actctxt | typeIR_param _id _value?{} | typedExpressionIR_arg
    (impl-input) p | TC | actctxt | direction typeIR_param _id _value?{_value <- _value?} | typedExpressionIR_arg
    (impl-input-premises)
    -- if direction matches ``EMPTY`
   paths
  {
    rulepath action
    (premises)
    -- if (action = actctxt)
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    (output) typedExpressionIR_arg_cast

    rulepath non-action
    (premises)
    -- if (noaction = actctxt)
    -- let _expressionIR # ( typeIR_arg ctk_arg ) = typedExpressionIR_arg
    -- if Type_alpha: typeIR_param ~~ typeIR_arg holds
    -- if (ctk_arg =/= dyn)
    (output) typedExpressionIR_arg
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:289.1-292.29
relation Call_convention_argument_ok: cursor typingContext actctxt |- parameterTypeIR @ argumentIR : argumentIR
  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:137.1-142.45
  rulegroup typedExpression
   match
    (expl-input) p | TC | actctxt | parameterTypeIR | typedExpressionIR as argumentIR
    (impl-input) p | TC | actctxt | parameterTypeIR | argumentIR
    (impl-input-premises)
    -- if argumentIR <: typedExpressionIR
    -- let typedExpressionIR = argumentIR as typedExpressionIR
   paths
  {
    rulepath typedExpression
    (premises)
    -- Call_convention_expr_ok: p TC actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR_cast
    (output) typedExpressionIR_cast as argumentIR
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:146.1-151.45
  rulegroup nameIR-typedExpression
   match
    (expl-input) p | TC | actctxt | parameterTypeIR | nameIR = typedExpressionIR
    (impl-input) p | TC | actctxt | parameterTypeIR | argumentIR
    (impl-input-premises)
    -- if argumentIR matches `%=%`
    -- let nameIR = typedExpressionIR = argumentIR
   paths
  {
    rulepath nameIR-typedExpression
    (premises)
    -- Call_convention_expr_ok: p TC actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR_cast
    (output) nameIR = typedExpressionIR_cast
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:155.1-158.36
  rulegroup nameIR-dontcare
   match
    (expl-input) p | TC | actctxt | parameterTypeIR | nameIR =_
    (impl-input) p | TC | actctxt | parameterTypeIR | argumentIR
    (impl-input-premises)
    -- if argumentIR matches `%=_`
    -- let nameIR =_ = argumentIR
   paths
  {
    rulepath nameIR-dontcare
    (premises)
    -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR
    -- if direction matches `OUT`
    (output) nameIR =_
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:162.1-164.36
  rulegroup dontcare
   match
    (expl-input) p | TC | actctxt | parameterTypeIR | _
    (impl-input) p | TC | actctxt | parameterTypeIR | argumentIR
    (impl-input-premises)
    -- if argumentIR matches `_`
   paths
  {
    rulepath dontcare
    (premises)
    -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR
    -- if direction matches `OUT`
    (output) _
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:294.1-297.29
relation Call_convention_ok: cursor typingContext actctxt |- parameterTypeIR* @ argumentListIR : argumentListIR
  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:170.1-171.35
  rulegroup nil
   match
    (expl-input) p | TC | actctxt | [] | []
    (impl-input) p | TC | actctxt | parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) []
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:173.1-182.41
  rulegroup cons
   match
    (expl-input) p | TC | actctxt | parameterTypeIR_h :: parameterTypeIR_t*{} | argumentIR_h :: argumentIR_t*{}
    (impl-input) p | TC | actctxt | parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
    -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
    -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
    -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
   paths
  {
    rulepath cons
    (premises)
    -- Call_convention_argument_ok: p TC actctxt |- parameterTypeIR_h @ argumentIR_h : argumentIR_h_cast
    -- Call_convention_ok: p TC actctxt |- parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} @ argumentIR_t*{argumentIR_t <- argumentIR_t*} : argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*}
    (output) argumentIR_h_cast :: argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:307.1-307.52
def $is_static_routineTarget(routineTargetIR) : ctk =

  ;; ../../../../spec-concrete/5.04-typing-relation.watsup:309.1-311.56
  clause 0(routineTargetIR) = lctk
  -- if routineTargetIR matches `%.%`
  -- let _typedExpressionIR . nameIR = routineTargetIR
  -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

  ;; ../../../../spec-concrete/5.04-typing-relation.watsup:312.1-314.56
  clause 1(routineTargetIR) = lctk
  -- if routineTargetIR matches `TYPE%.%`
  -- let type _prefixedNameIR . nameIR = routineTargetIR
  -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

  ;; ../../../../spec-concrete/5.04-typing-relation.watsup:315.1-316.15
  clause 2(_routineTargetIR) = dyn
  -- otherwise

;; ../../../../spec-concrete/5.04-typing-relation.watsup:318.1-320.23
relation RoutineTarget_ok: cursor typingContext |- routineTarget : routineTargetIR
  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:12.1-18.74
  rulegroup prefixedNonTypeName
   match
    (expl-input) p | TC | prefixedNonTypeName as routineTarget
    (impl-input) p | TC | routineTarget
    (impl-input-premises)
    -- if routineTarget <: prefixedNonTypeName
    -- let prefixedNonTypeName = routineTarget as prefixedNonTypeName
   paths
  {
    rulepath prefixedNonTypeName
    (premises)
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- if (((prefixedNameIR = ` "verify") \/ (prefixedNameIR = . "verify")) => (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind))))
    (output) prefixedNameIR as routineTargetIR
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:22.1-23.29
  rulegroup this
   match
    (expl-input) p | TC | this as routineTarget
    (impl-input) p | TC | routineTarget
    (impl-input-premises)
    -- if (routineTarget = this as routineTarget)
   paths
  {
    rulepath this
    (premises)
    (output) ` "this" as routineTargetIR
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:31.1-34.31
  rulegroup memberAccessExpression-prefixedTypeName
   match
    (expl-input) p | TC | prefixedTypeName as memberAccessBase . member as routineTarget
    (impl-input) p | TC | routineTarget
    (impl-input-premises)
    -- if routineTarget <: memberAccessExpression
    -- let memberAccessBase . member = routineTarget as memberAccessExpression
    -- if memberAccessBase <: prefixedTypeName
    -- let prefixedTypeName = memberAccessBase as prefixedTypeName
   paths
  {
    rulepath memberAccessExpression-prefixedTypeName
    (premises)
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- let nameIR = $name(member)
    (output) type prefixedNameIR . nameIR
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:38.1-41.63
  rulegroup memberAccessExpression-expression
   match
    (expl-input) p | TC | expression_base as memberAccessBase . member as routineTarget
    (impl-input) p | TC | routineTarget
    (impl-input-premises)
    -- if routineTarget <: memberAccessExpression
    -- let memberAccessBase . member = routineTarget as memberAccessExpression
    -- if memberAccessBase <: expression
    -- let expression_base = memberAccessBase as expression
   paths
  {
    rulepath memberAccessExpression-expression
    (premises)
    -- let nameIR = $name(member)
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    (output) typedExpressionIR_base . nameIR
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:45.1-47.60
  rulegroup parenthesizedExpression
   match
    (expl-input) p | TC | ( expression ) as routineTarget
    (impl-input) p | TC | routineTarget
    (impl-input-premises)
    -- if routineTarget <: parenthesizedExpression
    -- let ( expression ) = routineTarget as parenthesizedExpression
   paths
  {
    rulepath parenthesizedExpression
    (premises)
    -- RoutineTarget_ok: p TC |- expression : routineTargetIR
    (output) ( routineTargetIR )
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:322.1-324.23
relation RoutineTarget_lvalue_ok: cursor typingContext |- lvalue : routineTargetIR
  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:69.1-72.60
  rulegroup 
   match
    (expl-input) p | TC | lvalue
    (impl-input) p | TC | lvalue
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let expression = $lvalue(lvalue)
    -- RoutineTarget_ok: p TC |- expression : routineTargetIR
    (output) routineTargetIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:326.1-329.29
relation RoutineType_ok: cursor typingContext |- routineTargetIR < typeArgumentListIR >( argumentIR* ): routineTypeIR <# tid* >(# id* )
  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:83.1-93.45
  rulegroup referenceExpressionIR
   match
    (expl-input) p | TC | prefixedNameIR as routineTargetIR | typeArgumentIR*{} | argumentIR*{}
    (impl-input) p | TC | routineTargetIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if routineTargetIR <: prefixedNameIR
    -- let prefixedNameIR = routineTargetIR as prefixedNameIR
   paths
  {
    rulepath referenceExpressionIR
    (premises)
    -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_routine_overloaded(p, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*})
    -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
    -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
    -- let (routineTypeDefIR, tid*) = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- if (routineTypeDefIR, tid*) <: (functionTypeIR, tid*)
    -- let (functionTypeIR, tid_impl*{tid_impl <- tid_impl*}) = (routineTypeDefIR, tid*) as (functionTypeIR, tid*)
    -- let bound = $union_set<tid>($bound(p, TC), { tid_impl*{tid_impl <- tid_impl*} })
    -- if RoutineType_wf: bound |- functionTypeIR as routineTypeIR holds
    (output) functionTypeIR as routineTypeIR | tid_impl*{tid_impl <- tid_impl*} | id_default*{id_default <- id_default*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:97.1-103.55
  rulegroup typedExpressionIR-nameIR-builtin-method-minmax-SizeIn-BitsBytes
   match
    (expl-input) p | TC | typedExpressionIR_base . nameIR | [] | []
    (impl-input) p | TC | routineTargetIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
   paths
  {
    rulepath typedExpressionIR-nameIR-builtin-method-minmax-SizeIn-BitsBytes
    (premises)
    -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
    -- let methodTypeIR = builtin_method( [] )-> int as typeIR
    (output) methodTypeIR as routineTypeIR | [] | []
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:105.1-116.67
  rulegroup typedExpressionIR-nameIR-builtin-method-stack-push-pop-front
   match
    (expl-input) p | TC | typedExpressionIR_base . nameIR | [] | [argumentIR]
    (impl-input) p | TC | routineTargetIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR'*{argumentIR' <- argumentIR'*}
    (impl-input-premises)
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR'*{argumentIR' <- argumentIR'*} matches [ _/1 ]
    -- let [argumentIR] = argumentIR'*{argumentIR' <- argumentIR'*}
   paths
  {
    rulepath typedExpressionIR-nameIR-builtin-method-stack-push-pop-front
    (premises)
    -- if nameIR <- ["push_front", "pop_front"]
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR
    -- let parameterTypeIR = int as typeIR "count" ?()
    -- let methodTypeIR = builtin_method( [parameterTypeIR] )-> int as typeIR
    (output) methodTypeIR as routineTypeIR | [] | []
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:118.1-127.56
  rulegroup typedExpressionIR-nameIR-builtin-method-header-isValid
   match
    (expl-input) p | TC | typedExpressionIR_base . nameIR | [] | []
    (impl-input) p | TC | routineTargetIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
   paths
  {
    rulepath typedExpressionIR-nameIR-builtin-method-header-isValid
    (premises)
    -- if nameIR <- ["isValid"]
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: headerTypeIR
    -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR
    -- let methodTypeIR = builtin_method( [] )-> bool as typeIR
    (output) methodTypeIR as routineTypeIR | [] | []
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:129.1-138.56
  rulegroup typedExpressionIR-nameIR-builtin-method-union-isValid
   match
    (expl-input) p | TC | typedExpressionIR_base . nameIR | [] | []
    (impl-input) p | TC | routineTargetIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
   paths
  {
    rulepath typedExpressionIR-nameIR-builtin-method-union-isValid
    (premises)
    -- if nameIR <- ["isValid"]
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: headerUnionTypeIR
    -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR
    -- let methodTypeIR = builtin_method( [] )-> bool as typeIR
    (output) methodTypeIR as routineTypeIR | [] | []
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:140.1-149.56
  rulegroup typedExpressionIR-nameIR-builtin-method-header-set-ValidInvalid
   match
    (expl-input) p | TC | typedExpressionIR_base . nameIR | [] | []
    (impl-input) p | TC | routineTargetIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
   paths
  {
    rulepath typedExpressionIR-nameIR-builtin-method-header-set-ValidInvalid
    (premises)
    -- if nameIR <- ["setValid", "setInvalid"]
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: headerTypeIR
    -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR
    -- let methodTypeIR = builtin_method( [] )-> void as typeIR
    (output) methodTypeIR as routineTypeIR | [] | []
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:151.1-169.44
  rulegroup typedExpressionIR-nameIR-extern-method
   match
    (expl-input) p | TC | typedExpressionIR_base . nameIR | typeArgumentIR*{} | argumentIR*{}
    (impl-input) p | TC | routineTargetIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
   paths
  {
    rulepath typedExpressionIR-nameIR-extern-method
    (premises)
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: externObjectTypeIR
    -- let extern _tid { rid_f : routineTypeDefIR_f*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*} } = typeIR as externObjectTypeIR
    -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
    -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>({ rid_f : routineTypeDefIR_f*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*} }, nameIR, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
    -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
    -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
    -- let (routineTypeDefIR, tid*) = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- if (routineTypeDefIR, tid*) <: (routineTypeIR, tid*)
    -- let (routineTypeIR, tid_impl*{tid_impl <- tid_impl*}) = (routineTypeDefIR, tid*) as (routineTypeIR, tid*)
    -- let bound = $union_set<tid>($bound(p, TC), { tid_impl*{tid_impl <- tid_impl*} })
    -- if RoutineType_wf: bound |- routineTypeIR holds
    (output) routineTypeIR | tid_impl*{tid_impl <- tid_impl*} | id_default*{id_default <- id_default*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:171.1-189.22
  rulegroup typedExpressionIR-nameIR-parser-apply-method
   match
    (expl-input) p | TC | typedExpressionIR_base . "apply" | [] | argumentIR*{}
    (impl-input) p | TC | routineTargetIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . text = routineTargetIR
    -- if (text = "apply")
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
   paths
  {
    rulepath typedExpressionIR-nameIR-parser-apply-method
    (premises)
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: parserObjectTypeIR
    -- let parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as parserObjectTypeIR
    -- let methodTypeIR = parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
    -- (let _direction _typeIR id_param value_param?{value_param <- value_param?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}
    -- (let pid = id_param # (value_param?{value_param <- value_param?} =/= ?()))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}
    -- let rid = "apply" ( pid*{pid <- pid*} )
    -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
    -- let (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} = $find_overloaded<routineTypeDefIR>({ [rid : methodTypeIR as routineTypeDefIR] }, "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
    -- if (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} matches (_)
    -- let ?((rid, routineTypeDefIR, id*)) = (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?}
    -- if (rid, routineTypeDefIR, id*) <: (rid, methodTypeIR, id*)
    -- let (rid', methodTypeIR', id_default*{id_default <- id_default*}) = (rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)
    -- if (rid' = rid)
    -- if (methodTypeIR' = methodTypeIR)
    (output) methodTypeIR as routineTypeIR | [] | id_default*{id_default <- id_default*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:191.1-209.22
  rulegroup typedExpressionIR-nameIR-control-apply-method
   match
    (expl-input) p | TC | typedExpressionIR_base . "apply" | [] | argumentIR*{}
    (impl-input) p | TC | routineTargetIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . text = routineTargetIR
    -- if (text = "apply")
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
   paths
  {
    rulepath typedExpressionIR-nameIR-control-apply-method
    (premises)
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: controlObjectTypeIR
    -- let control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as controlObjectTypeIR
    -- let methodTypeIR = control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
    -- (let _direction _typeIR id_param value_param?{value_param <- value_param?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}
    -- (let pid = id_param # (value_param?{value_param <- value_param?} =/= ?()))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}
    -- let rid = "apply" ( pid*{pid <- pid*} )
    -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
    -- let (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} = $find_overloaded<routineTypeDefIR>({ [rid : methodTypeIR as routineTypeDefIR] }, "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
    -- if (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} matches (_)
    -- let ?((rid, routineTypeDefIR, id*)) = (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?}
    -- if (rid, routineTypeDefIR, id*) <: (rid, methodTypeIR, id*)
    -- let (rid', methodTypeIR', id_default*{id_default <- id_default*}) = (rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)
    -- if (rid' = rid)
    -- if (methodTypeIR' = methodTypeIR)
    (output) methodTypeIR as routineTypeIR | [] | id_default*{id_default <- id_default*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:211.1-218.52
  rulegroup typedExpressionIR-nameIR-table-apply-method
   match
    (expl-input) p | TC | typedExpressionIR_base . "apply" | [] | []
    (impl-input) p | TC | routineTargetIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . text = routineTargetIR
    -- if (text = "apply")
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
   paths
  {
    rulepath typedExpressionIR-nameIR-table-apply-method
    (premises)
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: tableObjectTypeIR
    -- let table _tid # typeIR_table = typeIR as tableObjectTypeIR
    -- let methodTypeIR = table_apply-> typeIR_table
    (output) methodTypeIR as routineTypeIR | [] | []
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:224.1-228.85
  rulegroup parenthesized
   match
    (expl-input) p | TC | ( routineTargetIR ) | typeArgumentIR*{} | argumentIR*{}
    (impl-input) p | TC | routineTargetIR' | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if routineTargetIR' matches `(%)`
    -- let ( routineTargetIR ) = routineTargetIR'
   paths
  {
    rulepath parenthesized
    (premises)
    -- RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    (output) routineTypeIR | tid_inserted*{tid_inserted <- tid_inserted*} | id_default*{id_default <- id_default*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:336.1-340.35
relation Call_ok: cursor typingContext |- routineTypeIR < typeArgumentListIR # tid* >( argumentListIR # id* ): typeIR < typeArgumentListIR >( argumentListIR )
  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:245.1-262.40
  rulegroup builtin-function
   match
    (expl-input) p | TC | builtin_function( parameterTypeIR*{} )-> typeIR_ret as routineTypeIR | typeArgumentIR*{} | [] | argumentIR*{} | id_default*{}
    (impl-input) p | TC | routineTypeIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | tid*{tid <- tid*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
    -- let builtin_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
    -- if tid*{tid <- tid*} matches []
   paths
  {
    rulepath builtin-function
    (premises)
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- if $callable_builtin_function(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) typeIR_ret | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:276.1-306.40
  rulegroup function
   match
    (expl-input) p | TC | function( parameterTypeIR*{} )-> typeIR_ret as routineTypeIR | typeArgumentIR*{} | tid_infer*{} | argumentIR*{} | id_default*{}
    (impl-input) p | TC | routineTypeIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | tid_infer*{tid_infer <- tid_infer*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `FUNCTION(%)->%`
    -- let function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
   paths
  {
    rulepath function
    (premises)
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
    -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
    -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
    -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
    -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
    -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
    -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
    -- let functionTypeIR_inferred = function( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_ret_inferred
    -- if RoutineType_wf: $bound(p, TC) |- functionTypeIR_inferred as routineTypeIR holds
    -- if $callable_function(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) typeIR_ret_inferred | typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:318.1-348.40
  rulegroup externfunction
   match
    (expl-input) p | TC | extern_function( parameterTypeIR*{} )-> typeIR_ret as routineTypeIR | typeArgumentIR*{} | tid_infer*{} | argumentIR*{} | id_default*{}
    (impl-input) p | TC | routineTypeIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | tid_infer*{tid_infer <- tid_infer*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
    -- let extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
   paths
  {
    rulepath externfunction
    (premises)
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
    -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
    -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
    -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
    -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
    -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
    -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
    -- let functionTypeIR_inferred = extern_function( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_ret_inferred
    -- if RoutineType_wf: $bound(p, TC) |- functionTypeIR_inferred as routineTypeIR holds
    -- if $callable_extern_function(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) typeIR_ret_inferred | typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:360.1-376.38
  rulegroup action
   match
    (expl-input) p | TC | action( parameterTypeIR*{} ) as routineTypeIR | [] | [] | argumentIR*{} | id_default*{}
    (impl-input) p | TC | routineTypeIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | tid*{tid <- tid*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `ACTION(%)`
    -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if tid*{tid <- tid*} matches []
   paths
  {
    rulepath action
    (premises)
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- if $callable_action(p, TC)
    -- Call_convention_ok: p TC action |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) void as typeIR | [] | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:389.1-406.40
  rulegroup builtin-method
   match
    (expl-input) p | TC | builtin_method( parameterTypeIR*{} )-> typeIR_ret as routineTypeIR | typeArgumentIR*{} | [] | argumentIR*{} | id_default*{}
    (impl-input) p | TC | routineTypeIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | tid*{tid <- tid*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
    -- let builtin_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
    -- if tid*{tid <- tid*} matches []
   paths
  {
    rulepath builtin-method
    (premises)
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- if $callable_builtin_method(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) typeIR_ret | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:418.1-448.40
  rulegroup extern-method
   match
    (expl-input) p | TC | extern_method( parameterTypeIR*{} )-> typeIR_ret as routineTypeIR | typeArgumentIR*{} | tid_infer*{} | argumentIR*{} | id_default*{}
    (impl-input) p | TC | routineTypeIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | tid_infer*{tid_infer <- tid_infer*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
    -- let extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
   paths
  {
    rulepath extern-method
    (premises)
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
    -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
    -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
    -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
    -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
    -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
    -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
    -- let methodTypeIR_inferred = extern_method( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_ret_inferred
    -- if RoutineType_wf: $bound(p, TC) |- methodTypeIR_inferred as routineTypeIR holds
    -- if $callable_extern_method(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) typeIR_ret_inferred | typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:460.1-490.40
  rulegroup extern-abstract-method
   match
    (expl-input) p | TC | extern_methodabstract( parameterTypeIR*{} )-> typeIR_ret as routineTypeIR | typeArgumentIR*{} | tid_infer*{} | argumentIR*{} | id_default*{}
    (impl-input) p | TC | routineTypeIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | tid_infer*{tid_infer <- tid_infer*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
    -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
   paths
  {
    rulepath extern-abstract-method
    (premises)
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
    -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
    -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
    -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
    -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
    -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
    -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
    -- let methodTypeIR_inferred = extern_methodabstract( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_ret_inferred
    -- if RoutineType_wf: $bound(p, TC) |- methodTypeIR_inferred as routineTypeIR holds
    -- if $callable_extern_abstract_method(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) typeIR_ret_inferred | typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:501.1-518.40
  rulegroup parser-apply-method
   match
    (expl-input) p | TC | parser_apply( parameterTypeIR*{} ) as routineTypeIR | [] | [] | argumentIR*{} | id_default*{}
    (impl-input) p | TC | routineTypeIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | tid*{tid <- tid*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `PARSER_APPLY(%)`
    -- let parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if tid*{tid <- tid*} matches []
   paths
  {
    rulepath parser-apply-method
    (premises)
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- if $callable_parser_apply_method(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) void as typeIR | [] | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:529.1-546.40
  rulegroup control-apply-method
   match
    (expl-input) p | TC | control_apply( parameterTypeIR*{} ) as routineTypeIR | [] | [] | argumentIR*{} | id_default*{}
    (impl-input) p | TC | routineTypeIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | tid*{tid <- tid*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `CONTROL_APPLY(%)`
    -- let control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if tid*{tid <- tid*} matches []
   paths
  {
    rulepath control-apply-method
    (premises)
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- if $callable_control_apply_method(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) void as typeIR | [] | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:558.1-562.44
  rulegroup table-apply-method
   match
    (expl-input) p | TC | table_apply-> typeIR_table as routineTypeIR | [] | [] | [] | []
    (impl-input) p | TC | routineTypeIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | tid*{tid <- tid*} | argumentIR*{argumentIR <- argumentIR*} | id*{id <- id*}
    (impl-input-premises)
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `TABLE_APPLY->%`
    -- let table_apply-> typeIR_table = methodTypeIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if tid*{tid <- tid*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- if id*{id <- id*} matches []
   paths
  {
    rulepath table-apply-method
    (premises)
    -- if $callable_table_apply_method(p, TC)
    (output) typeIR_table | [] | []
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:350.1-353.29
relation ConstructorType_ok: cursor typingContext |- prefixedNameIR < typeArgumentListIR >( argumentIR* ): constructorTypeIR <# tid* >(# id* )
  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:5.1-15.52
  rulegroup 
   match
    (expl-input) p | TC | prefixedNameIR | typeArgumentIR*{} | argumentIR*{}
    (impl-input) p | TC | prefixedNameIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} = $find_constructor_overloaded(TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*})
    -- if (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} matches (_)
    -- let ?((cid, constructorTypeDefIR, id_default*{id_default <- id_default*})) = (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?}
    -- let (constructorTypeIR, tid_impl*{tid_impl <- tid_impl*}) = $specialize_constructorTypeDef(constructorTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- let bound = $union_set<tid>($bound(p, TC), { tid_impl*{tid_impl <- tid_impl*} })
    -- if ConstructorType_wf: bound |- constructorTypeIR holds
    (output) constructorTypeIR | tid_impl*{tid_impl <- tid_impl*} | id_default*{id_default <- id_default*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:360.19-360.31
syntax instctxt = 
   | named
   | anon

;; ../../../../spec-concrete/5.04-typing-relation.watsup:362.1-369.38
relation Inst_ok: cursor typingContext instctxt |- constructorTypeIR < typeArgumentListIR # tid* >( argumentListIR # id* ): typeIR < typeArgumentListIR >( argumentListIR )
  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:79.1-113.44
  rulegroup package
   match
    (expl-input) global | TC | instctxt | constructorTypeIR | typeArgumentIR*{} | tid_infer*{} | argumentIR*{} | id_default*{}
    (impl-input) cursor | TC | instctxt | constructorTypeIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | tid_infer*{tid_infer <- tid_infer*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
   paths
  {
    rulepath package
    (premises)
    -- let constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object = constructorTypeIR
    -- let typeIR = $canon(typeIR_object)
    -- if typeIR <: packageObjectTypeIR
    -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
    -- (let typeIR'?{typeIR' <- typeIR'?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR'? <- typeIR'?*}
    -- (if typeIR'?{typeIR' <- typeIR'?} matches (_))*{typeIR'? <- typeIR'?*}
    -- (let ?(typeIR_inferred) = typeIR'?{typeIR' <- typeIR'?})*{typeIR'? <- typeIR'?*, typeIR_inferred <- typeIR_inferred*}
    -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
    -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
    -- let typeIR_object_inferred = $subst_type(inference, typeIR_object)
    -- let constructorTypeIR_inferred = constructor( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_object_inferred
    -- if ConstructorType_wf: $bound(global, TC) |- constructorTypeIR_inferred holds
    -- if $instantiable(global, TC, instctxt, typeIR_object_inferred)
    -- Call_convention_ok: block TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) typeIR_object_inferred | typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:117.1-151.40
  rulegroup non-package
   match
    (expl-input) p | TC | instctxt | constructorTypeIR | typeArgumentIR*{} | tid_infer*{} | argumentIR*{} | id_default*{}
    (impl-input) p | TC | instctxt | constructorTypeIR | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | tid_infer*{tid_infer <- tid_infer*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
   paths
  {
    rulepath non-package
    (premises)
    -- let constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object = constructorTypeIR
    -- if ~$is_package_object_typeIR($canon(typeIR_object))
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
    -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
    -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
    -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
    -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
    -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
    -- let typeIR_object_inferred = $subst_type(inference, typeIR_object)
    -- let constructorTypeIR_inferred = constructor( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_object_inferred
    -- if ConstructorType_wf: $bound(p, TC) |- constructorTypeIR_inferred holds
    -- if $instantiable(p, TC, instctxt, typeIR_object_inferred)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    (output) typeIR_object_inferred | typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} | argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

;; ../../../../spec-concrete/5.05.2-subtype.watsup:412.1-416.23
def $reduce_serenum_unary(typedExpressionIR, $check(typeIR) : bool) : typedExpressionIR? =

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:419.1-422.23
  clause 0(typedExpressionIR, $check) = ?(typedExpressionIR)
  -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
  -- if $check(typeIR)

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:424.1-430.79
  clause 1(typedExpressionIR, $check) = $reduce_serenum_unary(typedExpressionIR_cast, $check)
  -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
  -- if ~$check(typeIR)
  -- let typeIR' = typeIR
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR_underlying { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
  -- let typedExpressionIR_cast = ( typeIR_underlying ) typedExpressionIR as expressionIR # ( typeIR_underlying ctk )

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:432.1-433.15
  clause 2(typedExpressionIR, $check) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.05.2-subtype.watsup:437.1-442.44
def $reduce_serenum_binary(typedExpressionIR, typedExpressionIR, $check(typeIR, typeIR) : bool) : (typedExpressionIR, typedExpressionIR)? =

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:444.1-448.35
  clause 0(typedExpressionIR_l, typedExpressionIR_r, $check) = ?((typedExpressionIR_l, typedExpressionIR_r))
  -- let _expressionIR # ( typeIR_l _ctk ) = typedExpressionIR_l
  -- let _expressionIR' # ( typeIR_r _ctk' ) = typedExpressionIR_r
  -- if $check(typeIR_l, typeIR_r)

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:450.1-458.87
  clause 1(typedExpressionIR_l, typedExpressionIR_r, $check) = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r, $check)
  -- let _expressionIR # ( typeIR_l ctk_l ) = typedExpressionIR_l
  -- let _expressionIR' # ( typeIR_r _ctk ) = typedExpressionIR_r
  -- if ~$check(typeIR_l, typeIR_r)
  -- let typeIR = typeIR_l
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR_l_underlying { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
  -- let typedExpressionIR_l_cast = ( typeIR_l_underlying ) typedExpressionIR_l as expressionIR # ( typeIR_l_underlying ctk_l )

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:460.1-468.87
  clause 2(typedExpressionIR_l, typedExpressionIR_r, $check) = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r_cast, $check)
  -- let _expressionIR # ( typeIR_l _ctk ) = typedExpressionIR_l
  -- let _expressionIR' # ( typeIR_r ctk_r ) = typedExpressionIR_r
  -- if ~$check(typeIR_l, typeIR_r)
  -- let typeIR = typeIR_r
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR_r_underlying { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
  -- let typedExpressionIR_r_cast = ( typeIR_r_underlying ) typedExpressionIR_r as expressionIR # ( typeIR_r_underlying ctk_r )

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:470.1-471.15
  clause 3(typedExpressionIR_l, typedExpressionIR_r, $check) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.05.2-subtype.watsup:482.1-482.66
def $coerce_unary(typedExpressionIR, typeIR) : typedExpressionIR? =

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:484.1-486.37
  clause 0(typedExpressionIR, typeIR_to) = ?(typedExpressionIR)
  -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
  -- if Type_alpha: typeIR ~~ typeIR_to holds

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:488.1-493.63
  clause 1(typedExpressionIR, typeIR_to) = ?(typedExpressionIR_cast)
  -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
  -- if ~Type_alpha: typeIR ~~ typeIR_to holds
  -- if Sub_impl: typeIR <: typeIR_to holds
  -- let typedExpressionIR_cast = ( typeIR_to ) typedExpressionIR as expressionIR # ( typeIR_to ctk )

;; ../../../../spec-concrete/5.05.2-subtype.watsup:497.1-498.44
def $coerce_binary(typedExpressionIR, typedExpressionIR) : (typedExpressionIR, typedExpressionIR)? =

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:500.1-504.38
  clause 0(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l, typedExpressionIR_r))
  -- let _expressionIR # ( typeIR_l _ctk ) = typedExpressionIR_l
  -- let _expressionIR' # ( typeIR_r _ctk' ) = typedExpressionIR_r
  -- if Type_alpha: typeIR_l ~~ typeIR_r holds

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:506.1-513.65
  clause 1(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l_cast, typedExpressionIR_r))
  -- let _expressionIR # ( typeIR_l ctk_l ) = typedExpressionIR_l
  -- let _expressionIR' # ( typeIR_r _ctk ) = typedExpressionIR_r
  -- if ~Type_alpha: typeIR_l ~~ typeIR_r holds
  -- if Sub_impl: typeIR_l <: typeIR_r holds
  -- let typedExpressionIR_l_cast = ( typeIR_r ) typedExpressionIR_l as expressionIR # ( typeIR_r ctk_l )

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:515.1-523.65
  clause 2(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l, typedExpressionIR_r_cast))
  -- let _expressionIR # ( typeIR_l _ctk ) = typedExpressionIR_l
  -- let _expressionIR' # ( typeIR_r ctk_r ) = typedExpressionIR_r
  -- if ~Type_alpha: typeIR_l ~~ typeIR_r holds
  -- if ~Sub_impl: typeIR_l <: typeIR_r holds
  -- if Sub_impl: typeIR_r <: typeIR_l holds
  -- let typedExpressionIR_r_cast = ( typeIR_l ) typedExpressionIR_r as expressionIR # ( typeIR_l ctk_r )

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:525.1-526.15
  clause 3(typedExpressionIR_l, typedExpressionIR_r) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:80.1-80.32
def $compat_lnot(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:83.1-83.57
  clause 0(typeIR) = $compat'_lnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:81.1-81.33
def $compat'_lnot(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:84.1-84.31
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:85.1-86.14
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:101.1-101.32
def $compat_bnot(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:104.1-104.57
  clause 0(typeIR) = $compat'_bnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:102.1-102.33
def $compat'_bnot(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:105.1-105.37
  clause 0(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:106.1-106.37
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:107.1-108.15
  clause 2(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:123.1-123.38
def $compat_uplusminus(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:126.1-126.69
  clause 0(typeIR) = $compat'_uplusminus($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:124.1-124.39
def $compat'_uplusminus(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:127.1-127.36
  clause 0(typeIR) = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:128.1-128.43
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:129.1-129.43
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:130.1-131.15
  clause 3(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:149.1-149.49
def $compat_plusminusmult(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:152.1-153.63
  clause 0(typeIR_l, typeIR_r) = $compat'_plusminusmult($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:150.1-150.50
def $compat'_plusminusmult(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:154.1-154.44
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:155.1-155.58
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:156.1-156.58
  clause 2(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:157.1-158.15
  clause 3(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:186.1-186.48
def $compat_satplusminus(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:189.1-190.62
  clause 0(typeIR_l, typeIR_r) = $compat'_satplusminus($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:187.1-187.49
def $compat'_satplusminus(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:191.1-191.57
  clause 0(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:192.1-192.57
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:193.1-194.15
  clause 2(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:222.1-222.42
def $compat_divmod(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:225.1-226.56
  clause 0(typeIR_l, typeIR_r) = $compat'_divmod($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:223.1-223.43
def $compat'_divmod(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:227.1-227.37
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:228.1-229.15
  clause 1(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:293.1-293.41
def $compat_shift(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:296.1-297.55
  clause 0(typeIR_l, typeIR_r) = $compat'_shift($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:294.1-294.42
def $compat'_shift(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:298.1-298.36
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:299.1-299.43
  clause 1(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR = typeIR' as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:300.1-300.43
  clause 2(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR = typeIR' as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:301.1-301.43
  clause 3(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:302.1-302.50
  clause 4(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:303.1-303.50
  clause 5(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:304.1-304.43
  clause 6(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:305.1-305.50
  clause 7(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:306.1-306.50
  clause 8(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:307.1-308.15
  clause 9(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:388.1-388.43
def $compat_compare(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:391.1-392.57
  clause 0(typeIR_l, typeIR_r) = $compat'_compare($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:389.1-389.44
def $compat'_compare(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:393.1-393.38
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:394.1-394.52
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:395.1-395.52
  clause 2(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:396.1-397.15
  clause 3(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:425.1-425.43
def $compat_bitwise(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:428.1-429.57
  clause 0(typeIR_l, typeIR_r) = $compat'_bitwise($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:426.1-426.44
def $compat'_bitwise(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:430.1-430.52
  clause 0(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:431.1-431.52
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:432.1-433.15
  clause 2(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:461.1-461.42
def $compat_concat(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:464.1-465.56
  clause 0(typeIR_l, typeIR_r) = $compat'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:462.1-462.43
def $compat'_concat(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:466.1-466.51
  clause 0(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:467.1-467.51
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:468.1-468.51
  clause 2(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:469.1-469.51
  clause 3(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:470.1-471.15
  clause 4(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:473.1-473.45
def $result_concat(typeIR, typeIR) : typeIR? =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:476.1-477.56
  clause 0(typeIR_l, typeIR_r) = $result'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:474.1-474.46
def $result'_concat(typeIR, typeIR) : typeIR? =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:478.1-478.72
  clause 0(typeIR, typeIR') = ?(int< (w_a + w_b) > as typeIR)
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w_a > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w_b > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:479.1-479.72
  clause 1(typeIR, typeIR') = ?(int< (w_a + w_b) > as typeIR)
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w_a > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w_b > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:480.1-480.72
  clause 2(typeIR, typeIR') = ?(bit< (w_a + w_b) > as typeIR)
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w_a > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w_b > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:481.1-481.72
  clause 3(typeIR, typeIR') = ?(bit< (w_a + w_b) > as typeIR)
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w_a > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w_b > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:482.1-483.15
  clause 4(typeIR_l, typeIR_r) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:511.1-511.43
def $compat_logical(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:514.1-515.57
  clause 0(typeIR_l, typeIR_r) = $compat'_logical($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:512.1-512.44
def $compat'_logical(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:516.1-516.40
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = bool as typeIR)
  -- if (typeIR' = bool as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:517.1-518.15
  clause 1(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:905.1-905.39
def $compat_array_index(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:908.1-909.40
  clause 0(typeIR) = $compat'_arrayindex($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:906.1-906.39
def $compat'_arrayindex(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:910.1-910.36
  clause 0(typeIR) = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:911.1-911.43
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:912.1-912.43
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:913.1-914.15
  clause 3(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1000.1-1000.41
def $compat_bitslice_base(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1003.1-1004.43
  clause 0(typeIR) = $compat'_bitslice_base($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1001.1-1001.42
def $compat'_bitslice_base(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1005.1-1005.39
  clause 0(typeIR) = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1006.1-1006.50
  clause 1(typeIR) = (w > 0)
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1007.1-1007.46
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1008.1-1009.15
  clause 3(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1011.1-1011.42
def $compat_bitslice_index(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1014.1-1015.44
  clause 0(typeIR) = $compat'_bitslice_index($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1012.1-1012.43
def $compat'_bitslice_index(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1016.1-1016.40
  clause 0(typeIR) = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1017.1-1017.47
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1018.1-1018.47
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1019.1-1020.15
  clause 3(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1022.1-1022.48
def $is_valid_bitslice(typeIR, nat, nat) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1025.1-1026.71
  clause 0(typeIR, n_lo, n_hi) = ((n_lo <= n_hi) /\ $is_valid_bitslice'($canon(typeIR), n_lo, n_hi))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1023.1-1023.49
def $is_valid_bitslice'(typeIR, nat, nat) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1027.1-1027.42
  clause 0(typeIR, _nat, _nat') = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1028.1-1030.37
  clause 1(typeIR, n_lo, n_hi) = ((n_hi <= w) /\ (w_slice <= w))
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- let w_slice = ((n_hi - n_lo) + 1)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1031.1-1033.37
  clause 2(typeIR, n_lo, n_hi) = ((n_hi <= w) /\ (w_slice <= w))
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- let w_slice = ((n_hi - n_lo) + 1)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1034.1-1035.15
  clause 3(_typeIR, _nat, _nat') = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1154.1-1154.46
def $is_concrete_extern_object(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1159.1-1160.50
  clause 0(typeIR) = $is_concrete_extern_object'($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1155.1-1155.47
def $is_concrete_extern_object'(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1162.1-1163.42
  clause 0(typeIR) = true
  -- if ~$is_extern_object_typeIR(typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1164.1-1165.58
  clause 1(typeIR) = true
  -- if typeIR <: externObjectTypeIR
  -- let extern _tid { _rid : routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} } = typeIR as externObjectTypeIR
  -- (if $is_concrete_extern_object''(routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*}

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1166.1-1167.15
  clause 2(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1156.1-1156.58
def $is_concrete_extern_object''(routineTypeDefIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1169.1-1170.49
  clause 0(routineTypeDefIR) = $is_concrete_extern_object'''(routineTypeIR)
  -- if routineTypeDefIR <: routineTypeIR
  -- let routineTypeIR = routineTypeDefIR as routineTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1171.1-1172.50
  clause 1(routineTypeDefIR) = (true = $is_concrete_extern_object'''(routineTypeIR))
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < _tid*{_tid <- _tid*} , _tid'*{_tid' <- _tid'*} > = routineTypeDefIR as polyRoutineTypeDefIR

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1157.1-1157.56
def $is_concrete_extern_object'''(routineTypeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1174.1-1174.79
  clause 0(routineTypeIR) = false
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = methodTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1175.1-1176.15
  clause 1(_routineTypeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.10-typing-statement.watsup:91.1-91.46
def $compat_direct_application(typeIR) : bool =

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:94.1-95.48
  clause 0(typeIR) = $compat'_direct_application($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:92.1-92.47
def $compat'_direct_application(typeIR) : bool =

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:96.1-96.54
  clause 0(typeIR) = true
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:97.1-97.55
  clause 1(typeIR) = true
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:98.1-99.15
  clause 2(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.10-typing-statement.watsup:213.1-215.26
relation SwitchLabel_table_ok: typingContext tid bool |- switchLabel : switchLabelIR
  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:219.1-220.41
  rulegroup default
   match
    (expl-input) TC | tid_table | true | default
    (impl-input) TC | tid_table | bool | switchLabel
    (impl-input-premises)
    -- if (bool = true)
    -- if switchLabel matches `DEFAULT`
   paths
  {
    rulepath default
    (premises)
    (output) default
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:224.1-236.57
  rulegroup expressionNonBrace-prefixedNonTypeName
   match
    (expl-input) TC | tid_table | _bool | prefixedNonTypeName as switchLabel
    (impl-input) TC | tid_table | _bool | switchLabel
    (impl-input-premises)
    -- if switchLabel <: prefixedNonTypeName
    -- let prefixedNonTypeName = switchLabel as prefixedNonTypeName
   paths
  {
    rulepath expressionNonBrace-prefixedNonTypeName
    (premises)
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- if prefixedNameIR matches ``%`
    -- let ` nameIR_label = prefixedNameIR
    -- let tid_table_enum = "action_list(" ++ tid_table ++ ")"
    -- let id_label = tid_table_enum ++ "." ++ nameIR_label
    -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(local, TC, ` id_label)
    -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
    -- let ?(_direction typeIR_label ctk_label value?{value <- value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
    -- if value?{value <- value?} matches (_)
    -- let ?(value_label) = value?{value <- value?}
    -- if (value_label = table_enum tid_table_enum . nameIR_label as value)
    -- let typedExpressionIR_label = ` nameIR_label as expressionIR # ( typeIR_label ctk_label )
    (output) typedExpressionIR_label as switchLabelIR
  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:242.1-244.29
relation SwitchCase_table_ok: typingContext flow tid bool |- switchCase : flow switchCaseIR # switchLabel
  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:248.1-256.57
  rulegroup switchLabel-blockStatement
   match
    (expl-input) TC | f | tid_table | b_last | switchLabel : blockStatement
    (impl-input) TC | f | tid_table | b_last | switchCase
    (impl-input-premises)
    -- if switchCase matches `%:%`
    -- let switchLabel : blockStatement = switchCase
   paths
  {
    rulepath switchLabel-blockStatement
    (premises)
    -- SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR
    -- Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR
    -- let switchCaseIR = switchLabelIR : blockStatementIR
    (output) f_post | switchCaseIR | switchLabel
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:260.1-266.40
  rulegroup switchLabel
   match
    (expl-input) TC | f | tid_table | b_last | switchLabel :
    (impl-input) TC | f | tid_table | b_last | switchCase
    (impl-input-premises)
    -- if switchCase matches `%:`
    -- let switchLabel : = switchCase
   paths
  {
    rulepath switchLabel
    (premises)
    -- SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR
    -- let switchCaseIR = switchLabelIR :
    (output) f | switchCaseIR | switchLabel
  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:270.1-272.26
relation SwitchCases_table_ok: typingContext flow tid |- switchCase* : flow switchCaseListIR # switchLabel*
  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:274.1-275.39
  rulegroup nil
   match
    (expl-input) TC | f | tid_table | []
    (impl-input) TC | f | tid_table | switchCase*{switchCase <- switchCase*}
    (impl-input-premises)
    -- if switchCase*{switchCase <- switchCase*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) f | [] | []
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:277.1-284.80
  rulegroup cons
   match
    (expl-input) TC | f | tid_table | switchCase_h :: switchCase_t*{}
    (impl-input) TC | f | tid_table | switchCase*{switchCase <- switchCase*}
    (impl-input-premises)
    -- if switchCase*{switchCase <- switchCase*} matches _ :: _
    -- let switchCase_h :: switchCase_t*{switchCase_t <- switchCase_t*} = switchCase*{switchCase <- switchCase*}
   paths
  {
    rulepath cons
    (premises)
    -- let b_last = (switchCase_t*{switchCase_t <- switchCase_t*} = [])
    -- SwitchCase_table_ok: TC f tid_table b_last |- switchCase_h : f_h switchCaseIR_h # switchLabel_h
    -- SwitchCases_table_ok: TC f_h tid_table |- switchCase_t*{switchCase_t <- switchCase_t*} : f_t switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} # switchLabel_t*{switchLabel_t <- switchLabel_t*}
    (output) f_t | switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} | switchLabel_h :: switchLabel_t*{switchLabel_t <- switchLabel_t*}
  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:309.1-311.26
relation SwitchLabel_general_ok: typingContext typeIR bool |- switchLabel : switchLabelIR
  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:315.1-316.33
  rulegroup default
   match
    (expl-input) TC | _typeIR | true | default
    (impl-input) TC | _typeIR | bool | switchLabel
    (impl-input-premises)
    -- if (bool = true)
    -- if switchLabel matches `DEFAULT`
   paths
  {
    rulepath default
    (premises)
    (output) default
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:320.1-328.56
  rulegroup expressionNonBrace
   match
    (expl-input) TC | typeIR_switch | _bool | expressionNonBrace_label as switchLabel
    (impl-input) TC | typeIR_switch | _bool | switchLabel
    (impl-input-premises)
    -- if switchLabel <: expressionNonBrace
    -- let expressionNonBrace_label = switchLabel as expressionNonBrace
   paths
  {
    rulepath expressionNonBrace
    (premises)
    -- let expression_label = $expressionNonBrace(expressionNonBrace_label)
    -- Expr_ok: local TC |- expression_label : typedExpressionIR_label
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_label, typeIR_switch)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_label_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR_label_cast
    -- if ctk matches `LCTK`
    (output) typedExpressionIR_label_cast as switchLabelIR
  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:332.1-334.29
relation SwitchCase_general_ok: typingContext flow typeIR bool |- switchCase : flow switchCaseIR # switchLabel
  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:338.1-346.57
  rulegroup switchLabel-blockStatement
   match
    (expl-input) TC | f | typeIR_switch | b_last | switchLabel : blockStatement
    (impl-input) TC | f | typeIR_switch | b_last | switchCase
    (impl-input-premises)
    -- if switchCase matches `%:%`
    -- let switchLabel : blockStatement = switchCase
   paths
  {
    rulepath switchLabel-blockStatement
    (premises)
    -- SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR
    -- Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR
    -- let switchCaseIR = switchLabelIR : blockStatementIR
    (output) f_post | switchCaseIR | switchLabel
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:350.1-356.40
  rulegroup switchLabel
   match
    (expl-input) TC | f | typeIR_switch | b_last | switchLabel :
    (impl-input) TC | f | typeIR_switch | b_last | switchCase
    (impl-input-premises)
    -- if switchCase matches `%:`
    -- let switchLabel : = switchCase
   paths
  {
    rulepath switchLabel
    (premises)
    -- SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR
    -- let switchCaseIR = switchLabelIR :
    (output) f | switchCaseIR | switchLabel
  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:360.1-362.26
relation SwitchCases_general_ok: typingContext flow typeIR |- switchCase* : flow switchCaseListIR # switchLabel*
  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:364.1-365.43
  rulegroup nil
   match
    (expl-input) TC | f | typeIR_switch | []
    (impl-input) TC | f | typeIR_switch | switchCase*{switchCase <- switchCase*}
    (impl-input-premises)
    -- if switchCase*{switchCase <- switchCase*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) f | [] | []
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:367.1-375.84
  rulegroup cons
   match
    (expl-input) TC | f | typeIR_switch | switchCase_h :: switchCase_t*{}
    (impl-input) TC | f | typeIR_switch | switchCase*{switchCase <- switchCase*}
    (impl-input-premises)
    -- if switchCase*{switchCase <- switchCase*} matches _ :: _
    -- let switchCase_h :: switchCase_t*{switchCase_t <- switchCase_t*} = switchCase*{switchCase <- switchCase*}
   paths
  {
    rulepath cons
    (premises)
    -- let b_last = (switchCase_t*{switchCase_t <- switchCase_t*} = [])
    -- SwitchCase_general_ok: TC f typeIR_switch b_last |- switchCase_h : f_h switchCaseIR_h # switchLabel_h
    -- SwitchCases_general_ok: TC f_h typeIR_switch |- switchCase_t*{switchCase_t <- switchCase_t*} : f_t switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} # switchLabel_t*{switchLabel_t <- switchLabel_t*}
    (output) f_t | switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} | switchLabel_h :: switchLabel_t*{switchLabel_t <- switchLabel_t*}
  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:377.1-377.34
def $compat_switch(typeIR) : bool =

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:380.1-381.36
  clause 0(typeIR) = $compat'_switch($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:378.1-378.35
def $compat'_switch(typeIR) : bool =

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:382.1-382.34
  clause 0(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:383.1-383.39
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:384.1-384.39
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:385.1-385.42
  clause 3(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:386.1-386.47
  clause 4(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:387.1-388.15
  clause 5(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:92.1-95.29
relation Decl_object_ok: cursor typingContext frame rdenv |- objectDeclaration : frame rdenv objectDeclarationIR
  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:105.1-140.27
  rulegroup functionDeclaration
   match
    (expl-input) p | TC_0 | frame | rdenv | annotationList typeOrVoid name typeParameterListOpt ( parameterList ) blockStatement as objectDeclaration
    (impl-input) p | TC_0 | frame | rdenv | objectDeclaration
    (impl-input-premises)
    -- if objectDeclaration <: functionDeclaration
    -- let annotationList typeOrVoid name typeParameterListOpt ( parameterList ) blockStatement = objectDeclaration as functionDeclaration
   paths
  {
    rulepath functionDeclaration
    (premises)
    -- let TC_1 = TC_0[block.kind = extern]
    -- let TC_2 = TC_1[block.frame = frame]
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_3 = $add_types(local, TC_2, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- Type_ok: local TC_3 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: local TC_3 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_4 = $add_parameters(local, TC_3, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let TC_5 = TC_4[local.kind = extern_method-> typeIR_ret]
    -- Block_ok: TC_5 cont |- blockStatement : _typingContext f blockStatementIR
    -- if ((f = ret) \/ (typeIR_ret = void as typeIR))
    -- let rid = $rid(name, parameterList)
    -- let methodTypeIR = extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
    -- let routineTypeDefIR = methodTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
    -- if RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds
    -- let rdenv_init = $update_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
    -- let nameIR = $name(name)
    -- let functionDeclarationIR = annotationList typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) blockStatementIR
    (output) frame | rdenv_init | functionDeclarationIR as objectDeclarationIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:144.1-153.61
  rulegroup instantiation
   match
    (expl-input) p | TC_0 | frame | rdenv | instantiation as objectDeclaration
    (impl-input) p | TC_0 | frame | rdenv | objectDeclaration
    (impl-input-premises)
    -- if objectDeclaration <: instantiation
    -- let instantiation = objectDeclaration as instantiation
   paths
  {
    rulepath instantiation
    (premises)
    -- Decl_ok: p TC_0 |- instantiation as declaration : TC_1 declarationIR
    -- if declarationIR <: instantiationIR
    -- let instantiationIR = declarationIR as instantiationIR
    -- let _annotationList _typeIR _prefixedNameIR < _typeArgumentListIR >( _argumentListIR ) nameIR _objectInitializerOptIR ; = instantiationIR
    -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_var(p, TC_1, ` nameIR)
    -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
    -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}
    -- let frame_init = $update_map<id, varTypeIR>(frame, nameIR, varTypeIR)
    (output) frame_init | rdenv | instantiationIR as objectDeclarationIR
  }

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:155.1-158.29
relation Decls_object_ok: cursor typingContext frame rdenv |- objectDeclaration* : frame rdenv objectDeclarationListIR
  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:160.1-161.44
  rulegroup nil
   match
    (expl-input) p | TC | frame | rdenv | []
    (impl-input) p | TC | frame | rdenv | objectDeclaration*{objectDeclaration <- objectDeclaration*}
    (impl-input-premises)
    -- if objectDeclaration*{objectDeclaration <- objectDeclaration*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) frame | rdenv | []
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:163.1-171.69
  rulegroup cons
   match
    (expl-input) p | TC | frame_0 | rdenv_0 | objectDeclaration_h :: objectDeclaration_t*{}
    (impl-input) p | TC | frame_0 | rdenv_0 | objectDeclaration*{objectDeclaration <- objectDeclaration*}
    (impl-input-premises)
    -- if objectDeclaration*{objectDeclaration <- objectDeclaration*} matches _ :: _
    -- let objectDeclaration_h :: objectDeclaration_t*{objectDeclaration_t <- objectDeclaration_t*} = objectDeclaration*{objectDeclaration <- objectDeclaration*}
   paths
  {
    rulepath cons
    (premises)
    -- Decl_object_ok: p TC frame_0 rdenv_0 |- objectDeclaration_h : frame_1 rdenv_1 objectDeclarationIR_h
    -- Decls_object_ok: p TC frame_1 rdenv_1 |- objectDeclaration_t*{objectDeclaration_t <- objectDeclaration_t*} : frame_2 rdenv_2 objectDeclarationIR_t*{objectDeclarationIR_t <- objectDeclarationIR_t*}
    (output) frame_2 | rdenv_2 | objectDeclarationIR_h :: objectDeclarationIR_t*{objectDeclarationIR_t <- objectDeclarationIR_t*}
  }

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:173.1-173.46
def $subst_rdenv(theta, rdenv, rdenv) : rdenv =

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:175.1-175.63
  clause 0(theta, rdenv_extern, set<pair<rid, routineTypeDefIR>>) = rdenv_extern
  -- if (set<pair<rid, routineTypeDefIR>> = { [] })

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:176.1-192.93
  clause 1(theta, rdenv_extern, { pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*} }) = $subst_rdenv(theta, rdenv_extern_subst, { rid_init_t : routineTypeDefIR_init_t*{rid_init_t <- rid_init_t*, routineTypeDefIR_init_t <- routineTypeDefIR_init_t*} })
  -- if pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*} matches _ :: _
  -- let rid_init_h : routineTypeDefIR_init_h :: rid_init_t : routineTypeDefIR_init_t*{rid_init_t <- rid_init_t*, routineTypeDefIR_init_t <- routineTypeDefIR_init_t*} = pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*}
  -- let routineTypeDefIR''?{routineTypeDefIR'' <- routineTypeDefIR''?} = $find_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h)
  -- if routineTypeDefIR''?{routineTypeDefIR'' <- routineTypeDefIR''?} matches (_)
  -- let ?(routineTypeDefIR') = routineTypeDefIR''?{routineTypeDefIR'' <- routineTypeDefIR''?}
  -- if routineTypeDefIR' <: polyRoutineTypeDefIR
  -- let routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > = routineTypeDefIR' as polyRoutineTypeDefIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- let routineTypeDefIR = extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
  -- let routineTypeDefIR_subst = $subst_routineTypeDef(theta, routineTypeDefIR)
  -- if RoutineTypeDef_alpha: routineTypeDefIR_subst ~~ routineTypeDefIR_init_h holds
  -- let rdenv_extern_subst = $update_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h, routineTypeDefIR_subst)

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:426.1-426.81
def $split_constructors(methodPrototype*) : (methodPrototype*, methodPrototype*) =

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:428.1-428.42
  clause 0(methodPrototype*{methodPrototype <- methodPrototype*}) = ([], [])
  -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:429.1-434.48
  clause 1(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_h :: methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
  -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
  -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
  -- let methodPrototype' = methodPrototype_h
  -- if methodPrototype' matches `%%(%);`
  -- let _annotationList _typeIdentifier ( _parameterList ); = methodPrototype'
  -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:435.1-440.48
  clause 2(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
  -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
  -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
  -- let methodPrototype' = methodPrototype_h
  -- if methodPrototype' matches `%%;`
  -- let _annotationList _functionPrototype ; = methodPrototype'
  -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:441.1-446.48
  clause 3(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
  -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
  -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
  -- let methodPrototype' = methodPrototype_h
  -- if methodPrototype' matches `%ABSTRACT%;`
  -- let _annotationList abstract _functionPrototype ; = methodPrototype'
  -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:624.1-627.26
relation Enum_serializable_field_ok: typingContext nameIR typeIR |- namedExpression : typingContext namedExpressionIR # value
  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:629.1-644.74
  rulegroup 
   match
    (expl-input) TC_0 | nameIR_enum | typeIR | name = expression
    (impl-input) TC_0 | nameIR_enum | typeIR | name = expression
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- Expr_ok: block TC_0 |- expression : typedExpressionIR
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR_cast
    -- if ctk matches `LCTK`
    -- Eval_static: block TC_0 |- typedExpressionIR_cast ~> value
    -- let nameIR = $name(name)
    -- let typeIR_enum = enum nameIR_enum # typeIR { [] } as typeIR
    -- let value_enum = nameIR_enum . nameIR # value as value
    -- let TC_1 = $add_var(block, TC_0, nameIR, typeIR_enum lctk ?(value_enum))
    (output) TC_1 | nameIR = typedExpressionIR_cast | value
  }

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:646.1-649.26
relation Enum_serializable_fields_ok: typingContext nameIR typeIR |- namedExpression* : typingContext namedExpressionIR* # value*
  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:651.1-652.47
  rulegroup nil
   match
    (expl-input) TC | nameIR_enum | typeIR | []
    (impl-input) TC | nameIR_enum | typeIR | namedExpression*{namedExpression <- namedExpression*}
    (impl-input-premises)
    -- if namedExpression*{namedExpression <- namedExpression*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TC | [] | []
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:654.1-664.55
  rulegroup cons
   match
    (expl-input) TC_0 | nameIR_enum | typeIR | namedExpression_h :: namedExpression_t*{}
    (impl-input) TC_0 | nameIR_enum | typeIR | namedExpression*{namedExpression <- namedExpression*}
    (impl-input-premises)
    -- if namedExpression*{namedExpression <- namedExpression*} matches _ :: _
    -- let namedExpression_h :: namedExpression_t*{namedExpression_t <- namedExpression_t*} = namedExpression*{namedExpression <- namedExpression*}
   paths
  {
    rulepath cons
    (premises)
    -- Enum_serializable_field_ok: TC_0 nameIR_enum typeIR |- namedExpression_h : TC_1 namedExpressionIR_h # value_field_h
    -- Enum_serializable_fields_ok: TC_1 nameIR_enum typeIR |- namedExpression_t*{namedExpression_t <- namedExpression_t*} : TC_2 namedExpressionIR_t*{namedExpressionIR_t <- namedExpressionIR_t*} # value_field_t*{value_field_t <- value_field_t*}
    -- let namedExpressionIR*{namedExpressionIR <- namedExpressionIR*} = namedExpressionIR_h :: namedExpressionIR_t*{namedExpressionIR_t <- namedExpressionIR_t*}
    -- let value_field*{value_field <- value_field*} = value_field_h :: value_field_t*{value_field_t <- value_field_t*}
    (output) TC_2 | namedExpressionIR*{namedExpressionIR <- namedExpressionIR*} | value_field*{value_field <- value_field*}
  }

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:33.1-35.23
relation SelectCase_keyset_simple_ok: typingContext typeIR |- simpleKeysetExpression : simpleKeysetExpressionIR
  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:39.1-45.38
  rulegroup expression-set-alpha
   match
    (expl-input) TC | typeIR_key | expression as simpleKeysetExpression
    (impl-input) TC | typeIR_key | simpleKeysetExpression
    (impl-input-premises)
    -- if simpleKeysetExpression <: expression
    -- let expression = simpleKeysetExpression as expression
   paths
  {
    rulepath expression-set-alpha
    (premises)
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR'' _ctk ) = typedExpressionIR
    -- if typeIR'' <: setTypeIR
    -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
    -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
    -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
    -- if Type_alpha: typeIR ~~ typeIR_key holds
    (output) typedExpressionIR as simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:47.1-58.69
  rulegroup expression-set-subtype
   match
    (expl-input) TC | typeIR_key | expression as simpleKeysetExpression
    (impl-input) TC | typeIR_key | simpleKeysetExpression
    (impl-input-premises)
    -- if simpleKeysetExpression <: expression
    -- let expression = simpleKeysetExpression as expression
   paths
  {
    rulepath expression-set-subtype
    (premises)
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR'' _ctk ) = typedExpressionIR
    -- if typeIR'' <: setTypeIR
    -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
    -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
    -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
    -- if ~Type_alpha: typeIR ~~ typeIR_key holds
    -- if Sub_impl: typeIR <: typeIR_key holds
    -- let typeIR_cast = set< [typeIR_key] > as typeIR
    -- let typedExpressionIR_cast = ( typeIR_cast ) typedExpressionIR as expressionIR # ( typeIR_cast dyn )
    (output) typedExpressionIR_cast as simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:60.1-72.69
  rulegroup expression-non-set
   match
    (expl-input) TC | typeIR_key | expression as simpleKeysetExpression
    (impl-input) TC | typeIR_key | simpleKeysetExpression
    (impl-input-premises)
    -- if simpleKeysetExpression <: expression
    -- let expression = simpleKeysetExpression as expression
   paths
  {
    rulepath expression-non-set
    (premises)
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
    -- if ~$is_set_typeIR(typeIR)
    -- if Sub_impl: typeIR <: typeIR_key holds
    -- let typeIR_cast = set< [typeIR_key] > as typeIR
    -- let typedExpressionIR_cast = ( typeIR_cast ) typedExpressionIR as expressionIR # ( typeIR_cast dyn )
    (output) typedExpressionIR_cast as simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:87.1-109.63
  rulegroup mask
   match
    (expl-input) TC | typeIR_key | expression_l &&& expression_r
    (impl-input) TC | typeIR_key | simpleKeysetExpression
    (impl-input-premises)
    -- if simpleKeysetExpression matches `%&&&%`
    -- let expression_l &&& expression_r = simpleKeysetExpression
   paths
  {
    rulepath mask
    (premises)
    -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced _ctk ) = typedExpressionIR_l_reduced
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_l_reduced, typeIR_key)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_l_coerced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR_r_reduced, typeIR_key)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_r_coerced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    (output) typedExpressionIR_l_coerced &&& typedExpressionIR_r_coerced
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:124.1-147.63
  rulegroup range
   match
    (expl-input) TC | typeIR_key | expression_l .. expression_r
    (impl-input) TC | typeIR_key | simpleKeysetExpression
    (impl-input-premises)
    -- if simpleKeysetExpression matches `%..%`
    -- let expression_l .. expression_r = simpleKeysetExpression
   paths
  {
    rulepath range
    (premises)
    -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced _ctk ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( typeIR _ctk' ) = typedExpressionIR_r_reduced
    -- if (typeIR = typeIR_reduced)
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_l_reduced, typeIR_key)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_l_coerced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR_r_reduced, typeIR_key)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_r_coerced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    (output) typedExpressionIR_l_coerced .. typedExpressionIR_r_coerced
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:151.1-152.37
  rulegroup default
   match
    (expl-input) TC | typeIR_key | default
    (impl-input) TC | typeIR_key | simpleKeysetExpression
    (impl-input-premises)
    -- if simpleKeysetExpression matches `DEFAULT`
   paths
  {
    rulepath default
    (premises)
    (output) default
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:156.1-157.27
  rulegroup dontcare
   match
    (expl-input) TC | typeIR_key | _
    (impl-input) TC | typeIR_key | simpleKeysetExpression
    (impl-input-premises)
    -- if simpleKeysetExpression matches `_`
   paths
  {
    rulepath dontcare
    (premises)
    (output) _
  }

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:76.1-76.40
def $compat_mask(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:79.1-80.54
  clause 0(typeIR_l, typeIR_r) = $compat'_mask($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:77.1-77.41
def $compat'_mask(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:81.1-81.35
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:82.1-82.49
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:83.1-83.49
  clause 2(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:84.1-85.15
  clause 3(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:113.1-113.41
def $compat_range(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:116.1-117.55
  clause 0(typeIR_l, typeIR_r) = $compat'_range($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:114.1-114.42
def $compat'_range(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:118.1-118.36
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:119.1-119.50
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:120.1-120.50
  clause 2(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:121.1-122.15
  clause 3(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:161.1-163.23
relation SelectCase_keyset_ok: typingContext typeIR* |- keysetExpression : keysetExpressionIR
  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:170.1-173.61
  rulegroup simpleKeysetExpression-expression
   match
    (expl-input) TC | [typeIR_key] | expression as keysetExpression
    (impl-input) TC | typeIR*{typeIR <- typeIR*} | keysetExpression
    (impl-input-premises)
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if keysetExpression <: expression
    -- let expression = keysetExpression as expression
   paths
  {
    rulepath simpleKeysetExpression-expression
    (premises)
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression as simpleKeysetExpression : simpleKeysetExpressionIR
    (output) simpleKeysetExpressionIR as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:177.1-180.81
  rulegroup simpleKeysetExpression-mask
   match
    (expl-input) TC | [typeIR_key] | expression_l &&& expression_r as keysetExpression
    (impl-input) TC | typeIR*{typeIR <- typeIR*} | keysetExpression
    (impl-input-premises)
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if keysetExpression <: simpleKeysetExpression
    -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
    -- if simpleKeysetExpression matches `%&&&%`
    -- let expression_l &&& expression_r = simpleKeysetExpression
   paths
  {
    rulepath simpleKeysetExpression-mask
    (premises)
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression_l &&& expression_r : simpleKeysetExpressionIR
    (output) simpleKeysetExpressionIR as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:184.1-187.80
  rulegroup simpleKeysetExpression-range
   match
    (expl-input) TC | [typeIR_key] | expression_l .. expression_r as keysetExpression
    (impl-input) TC | typeIR*{typeIR <- typeIR*} | keysetExpression
    (impl-input-premises)
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if keysetExpression <: simpleKeysetExpression
    -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
    -- if simpleKeysetExpression matches `%..%`
    -- let expression_l .. expression_r = simpleKeysetExpression
   paths
  {
    rulepath simpleKeysetExpression-range
    (premises)
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression_l .. expression_r : simpleKeysetExpressionIR
    (output) simpleKeysetExpressionIR as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:191.1-207.2
  rulegroup simpleKeysetExpression-default
   match
    (expl-input) TC | typeIR'*{} | default as keysetExpression
    (impl-input) TC | typeIR'*{typeIR' <- typeIR'*} | keysetExpression
    (impl-input-premises)
    -- if (keysetExpression = default as keysetExpression)
   paths
  {
    rulepath zero-to-one
    (premises)
    -- if ([] = typeIR'*{typeIR' <- typeIR'*})
    (output) default as keysetExpressionIR

    rulepath one-to-one
    (premises)
    -- let typeIR''*{typeIR'' <- typeIR''*} = typeIR'*{typeIR' <- typeIR'*}
    -- if typeIR''*{typeIR'' <- typeIR''*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR''*{typeIR'' <- typeIR''*}
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- default : simpleKeysetExpressionIR
    (output) simpleKeysetExpressionIR as keysetExpressionIR

    rulepath many-to-one
    (premises)
    -- let typeIR_key*{typeIR_key <- typeIR_key*} = typeIR'*{typeIR' <- typeIR'*}
    -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
    -- SelectCase_keyset_simple_ok: TC seq< typeIR_key*{typeIR_key <- typeIR_key*} > as typeIR |- default : simpleKeysetExpressionIR
    (output) simpleKeysetExpressionIR as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:211.1-224.2
  rulegroup simpleKeysetExpression-dontcare
   match
    (expl-input) TC | typeIR*{} | _ as keysetExpression
    (impl-input) TC | typeIR*{typeIR <- typeIR*} | keysetExpression
    (impl-input-premises)
    -- if (keysetExpression = _ as keysetExpression)
   paths
  {
    rulepath one-to-one
    (premises)
    -- let typeIR'*{typeIR' <- typeIR'*} = typeIR*{typeIR <- typeIR*}
    -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR'*{typeIR' <- typeIR'*}
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- _ : simpleKeysetExpressionIR
    (output) simpleKeysetExpressionIR as keysetExpressionIR

    rulepath many-to-one
    (premises)
    -- let typeIR_key*{typeIR_key <- typeIR_key*} = typeIR*{typeIR <- typeIR*}
    -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
    -- SelectCase_keyset_simple_ok: TC seq< typeIR_key*{typeIR_key <- typeIR_key*} > as typeIR |- _ : simpleKeysetExpressionIR
    (output) simpleKeysetExpressionIR as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:231.1-234.81
  rulegroup tupleKeysetExpression-mask
   match
    (expl-input) TC | [typeIR_key] | ( expression_l &&& expression_r ) as keysetExpression
    (impl-input) TC | typeIR*{typeIR <- typeIR*} | keysetExpression
    (impl-input-premises)
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if keysetExpression <: tupleKeysetExpression
    -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
    -- if tupleKeysetExpression matches `(%&&&%)`
    -- let ( expression_l &&& expression_r ) = tupleKeysetExpression
   paths
  {
    rulepath tupleKeysetExpression-mask
    (premises)
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression_l &&& expression_r : simpleKeysetExpressionIR
    (output) ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:238.1-241.80
  rulegroup tupleKeysetExpression-range
   match
    (expl-input) TC | [typeIR_key] | ( expression_l .. expression_r ) as keysetExpression
    (impl-input) TC | typeIR*{typeIR <- typeIR*} | keysetExpression
    (impl-input-premises)
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if keysetExpression <: tupleKeysetExpression
    -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
    -- if tupleKeysetExpression matches `(%..%)`
    -- let ( expression_l .. expression_r ) = tupleKeysetExpression
   paths
  {
    rulepath tupleKeysetExpression-range
    (premises)
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression_l .. expression_r : simpleKeysetExpressionIR
    (output) ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:245.1-258.2
  rulegroup tupleKeysetExpression-default
   match
    (expl-input) TC | typeIR*{} | (default) as keysetExpression
    (impl-input) TC | typeIR*{typeIR <- typeIR*} | keysetExpression
    (impl-input-premises)
    -- if (keysetExpression = (default) as keysetExpression)
   paths
  {
    rulepath one-to-one
    (premises)
    -- let typeIR'*{typeIR' <- typeIR'*} = typeIR*{typeIR <- typeIR*}
    -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR'*{typeIR' <- typeIR'*}
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- default : simpleKeysetExpressionIR
    (output) ( [simpleKeysetExpressionIR] ) as keysetExpressionIR

    rulepath many-to-one
    (premises)
    -- let typeIR_key*{typeIR_key <- typeIR_key*} = typeIR*{typeIR <- typeIR*}
    -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
    -- SelectCase_keyset_simple_ok: TC seq< typeIR_key*{typeIR_key <- typeIR_key*} > as typeIR |- default : simpleKeysetExpressionIR
    (output) ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:262.1-275.2
  rulegroup tupleKeysetExpression-dontcare
   match
    (expl-input) TC | typeIR*{} | (_) as keysetExpression
    (impl-input) TC | typeIR*{typeIR <- typeIR*} | keysetExpression
    (impl-input-premises)
    -- if (keysetExpression = (_) as keysetExpression)
   paths
  {
    rulepath one-to-one
    (premises)
    -- let typeIR'*{typeIR' <- typeIR'*} = typeIR*{typeIR <- typeIR*}
    -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR'*{typeIR' <- typeIR'*}
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- _ : simpleKeysetExpressionIR
    (output) ( [simpleKeysetExpressionIR] ) as keysetExpressionIR

    rulepath many-to-one
    (premises)
    -- let typeIR_key*{typeIR_key <- typeIR_key*} = typeIR*{typeIR <- typeIR*}
    -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
    -- SelectCase_keyset_simple_ok: TC seq< typeIR_key*{typeIR_key <- typeIR_key*} > as typeIR |- _ : simpleKeysetExpressionIR
    (output) ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:279.1-290.75
  rulegroup tupleKeysetExpression-list
   match
    (expl-input) TC | typeIR_key*{} | ( simpleKeysetExpression_h , simpleKeysetExpressionList_t ) as keysetExpression
    (impl-input) TC | typeIR_key*{typeIR_key <- typeIR_key*} | keysetExpression
    (impl-input-premises)
    -- if keysetExpression <: tupleKeysetExpression
    -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
    -- if tupleKeysetExpression matches `(%,%)`
    -- let ( simpleKeysetExpression_h , simpleKeysetExpressionList_t ) = tupleKeysetExpression
   paths
  {
    rulepath tupleKeysetExpression-list
    (premises)
    -- let simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t)
    -- let simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} = simpleKeysetExpression_h :: simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*}
    -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| = |simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}|)
    -- (SelectCase_keyset_simple_ok: TC typeIR_key |- simpleKeysetExpression : simpleKeysetExpressionIR)*{simpleKeysetExpression <- simpleKeysetExpression*, simpleKeysetExpressionIR <- simpleKeysetExpressionIR*, typeIR_key <- typeIR_key*}
    (output) ( simpleKeysetExpressionIR*{simpleKeysetExpressionIR <- simpleKeysetExpressionIR*} ) as keysetExpressionIR
  }

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:294.1-296.26
relation SelectCase_ok: typingContext nameIR* typeIR* |- selectCase : selectCaseIR
  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:298.1-306.32
  rulegroup 
   match
    (expl-input) TC | nameIR_state*{} | typeIR_key*{} | keysetExpression : name ;
    (impl-input) TC | nameIR_state*{nameIR_state <- nameIR_state*} | typeIR_key*{typeIR_key <- typeIR_key*} | keysetExpression : name ;
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- SelectCase_keyset_ok: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : keysetExpressionIR
    -- let nameIR = $name(name)
    -- if nameIR <- nameIR_state*{nameIR_state <- nameIR_state*}
    (output) keysetExpressionIR : nameIR ;
  }

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:7.1-7.52
def $compat_table_exact_optional_key(typeIR) : bool =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:10.1-11.54
  clause 0(typeIR) = $compat'_table_exact_optional_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:8.1-8.53
def $compat'_table_exact_optional_key(typeIR) : bool =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:12.1-12.51
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:13.1-13.52
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:14.1-14.59
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:15.1-16.45
  clause 3(typeIR') = $compat_table_exact_optional_key(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:17.1-17.60
  clause 4(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:18.1-19.45
  clause 5(typeIR') = $compat_table_exact_optional_key(typeIR)
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:21.1-21.55
def $compat_table_lpm_ternary_range_key(typeIR) : bool =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:24.1-25.57
  clause 0(typeIR) = $compat'_table_lpm_ternary_range_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:22.1-22.56
def $compat'_table_lpm_ternary_range_key(typeIR) : bool =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:26.1-26.53
  clause 0(typeIR) = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:27.1-27.60
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:28.1-28.60
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:29.1-30.48
  clause 3(typeIR') = $compat_table_lpm_ternary_range_key(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:31.1-32.48
  clause 4(typeIR') = $compat_table_lpm_ternary_range_key(typeIR)
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:34.1-34.45
def $compat_table_key(nameIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:36.1-38.49
  clause 0(nameIR, typeIR) = true
  -- if ((nameIR = "exact") \/ (nameIR = "optional"))
  -- if $compat_table_exact_optional_key(typeIR)

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:39.1-41.52
  clause 1(nameIR, typeIR) = true
  -- if (((nameIR = "lpm") \/ (nameIR = "ternary")) \/ (nameIR = "range"))
  -- if $compat_table_lpm_ternary_range_key(typeIR)

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:42.1-43.15
  clause 2(nameIR, typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:85.1-86.41
def $split_dataplane_parameters(parameterTypeIR*) : (parameterTypeIR*, parameterTypeIR*) =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:88.1-88.50
  clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = ([], [])
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:89.1-93.56
  clause 1(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_h :: parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
  -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
  -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR_h
  -- if direction matches ``EMPTY`
  -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:94.1-99.56
  clause 2(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = (parameterTypeIR_h :: parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
  -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
  -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR_h
  -- if (direction =/= )
  -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:236.1-239.26
relation TableEntry_keyset_simple_ok: typingContext tableContext |- matchKey @ simpleKeysetExpression : tableEntryState simpleKeysetExpressionIR
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:243.1-275.2
  rulegroup expression
   match
    (expl-input) TC | TBLC | (typeIR_key, text) | expression as simpleKeysetExpression
    (impl-input) TC | TBLC | (typeIR_key, text) | simpleKeysetExpression
    (impl-input-premises)
    -- if simpleKeysetExpression <: expression
    -- let expression = simpleKeysetExpression as expression
   paths
  {
    rulepath lpm
    (premises)
    -- if ("lpm" = text)
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
    -- if Sub_impl: typeIR <: typeIR_key holds
    -- let typeIR_set = set< [typeIR_key] > as typeIR
    -- let typedExpressionIR_set = ( typeIR_set ) typedExpressionIR as expressionIR # ( typeIR_set ctk )
    (output) lpm n | typedExpressionIR_set as simpleKeysetExpressionIR

    rulepath non-lpm
    (premises)
    -- let nameIR_matchkind = text
    -- if (nameIR_matchkind =/= "lpm")
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
    -- if Sub_impl: typeIR <: typeIR_key holds
    -- let typeIR_set = set< [typeIR_key] > as typeIR
    -- let typedExpressionIR_set = ( typeIR_set ) typedExpressionIR as expressionIR # ( typeIR_set ctk )
    (output) nolpm | typedExpressionIR_set as simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:279.1-331.2
  rulegroup mask
   match
    (expl-input) TC | TBLC | (typeIR_key, text) | expression_l &&& expression_r
    (impl-input) TC | TBLC | (typeIR_key, text) | simpleKeysetExpression
    (impl-input-premises)
    -- if simpleKeysetExpression matches `%&&&%`
    -- let expression_l &&& expression_r = simpleKeysetExpression
   paths
  {
    rulepath lpm
    (premises)
    -- if ("lpm" = text)
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if Sub_impl: typeIR_reduced <: typeIR_key holds
    -- if (ctk_r_reduced = lctk)
    -- Eval_static: local TC |- typedExpressionIR_r_reduced ~> value_r
    -- let i_r = $to_number(value_r)
    -- let n_prefix = $tableEntry_lpm_prefix(n w $to_bitstr(n as int, i_r) as value)
    (output) lpm n_prefix | typedExpressionIR_l_reduced &&& typedExpressionIR_r_reduced

    rulepath ternary
    (premises)
    -- if ("ternary" = text)
    -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if Sub_impl: typeIR_reduced <: typeIR_key holds
    (output) nolpm | typedExpressionIR_l_reduced &&& typedExpressionIR_r_reduced
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:335.1-354.44
  rulegroup range-range
   match
    (expl-input) TC | TBLC | (typeIR_key, "range") | expression_l .. expression_r
    (impl-input) TC | TBLC | (typeIR_key, text) | simpleKeysetExpression
    (impl-input-premises)
    -- if (text = "range")
    -- if simpleKeysetExpression matches `%..%`
    -- let expression_l .. expression_r = simpleKeysetExpression
   paths
  {
    rulepath range-range
    (premises)
    -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if Sub_impl: typeIR_reduced <: typeIR_key holds
    (output) nolpm | typedExpressionIR_l_reduced .. typedExpressionIR_r_reduced
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:358.1-371.2
  rulegroup default
   match
    (expl-input) TC | TBLC | (typeIR_key, text) | default
    (impl-input) TC | TBLC | (typeIR_key, text) | simpleKeysetExpression
    (impl-input-premises)
    -- if simpleKeysetExpression matches `DEFAULT`
   paths
  {
    rulepath lpm
    (premises)
    -- if ("lpm" = text)
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    (output) lpm n | default

    rulepath non-lpm
    (premises)
    -- let nameIR_matchkind = text
    -- if (nameIR_matchkind =/= "lpm")
    -- if (nameIR_matchkind =/= "exact")
    (output) nolpm | default
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:375.1-388.2
  rulegroup dontcare
   match
    (expl-input) TC | TBLC | (typeIR_key, text) | _
    (impl-input) TC | TBLC | (typeIR_key, text) | simpleKeysetExpression
    (impl-input-premises)
    -- if simpleKeysetExpression matches `_`
   paths
  {
    rulepath lpm
    (premises)
    -- if ("lpm" = text)
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm _nat = matchMode
    (output) lpm 0 | _

    rulepath non-lpm
    (premises)
    -- let nameIR_matchkind = text
    -- if (nameIR_matchkind =/= "lpm")
    -- if (nameIR_matchkind =/= "exact")
    (output) nolpm | _
  }

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:396.1-399.29
relation TableEntry_keysets_simple_ok: typingContext tableContext tableEntryState |- matchKey* @ simpleKeysetExpression* : tableEntryState simpleKeysetExpressionIR*
  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:401.1-402.40
  rulegroup nil
   match
    (expl-input) TC | TBLC | TBLS | [] | []
    (impl-input) TC | TBLC | TBLS | matchKey*{matchKey <- matchKey*} | simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}
    (impl-input-premises)
    -- if matchKey*{matchKey <- matchKey*} matches []
    -- if simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) TBLS | []
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:404.1-414.59
  rulegroup cons
   match
    (expl-input) TC | TBLC | TBLS_0 | matchKey_h :: matchKey_t*{} | simpleKeysetExpression_h :: simpleKeysetExpression_t*{}
    (impl-input) TC | TBLC | TBLS_0 | matchKey*{matchKey <- matchKey*} | simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}
    (impl-input-premises)
    -- if matchKey*{matchKey <- matchKey*} matches _ :: _
    -- let matchKey_h :: matchKey_t*{matchKey_t <- matchKey_t*} = matchKey*{matchKey <- matchKey*}
    -- if simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} matches _ :: _
    -- let simpleKeysetExpression_h :: simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} = simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}
   paths
  {
    rulepath cons
    (premises)
    -- TableEntry_keyset_simple_ok: TC TBLC |- matchKey_h @ simpleKeysetExpression_h : TBLS_1 simpleKeysetExpressionIR_h
    -- let TBLS_2 = $join_tableEntryState(TBLS_0, TBLS_1)
    -- TableEntry_keysets_simple_ok: TC TBLC TBLS_2 |- matchKey_t*{matchKey_t <- matchKey_t*} @ simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} : TBLS_3 simpleKeysetExpressionIR_t*{simpleKeysetExpressionIR_t <- simpleKeysetExpressionIR_t*}
    (output) TBLS_3 | simpleKeysetExpressionIR_h :: simpleKeysetExpressionIR_t*{simpleKeysetExpressionIR_t <- simpleKeysetExpressionIR_t*}
  }

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:948.1-948.44
def $count_table_keys(tableProperty*) : nat =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:950.1-950.31
  clause 0(tableProperty*{tableProperty <- tableProperty*}) = 0
  -- if tableProperty*{tableProperty <- tableProperty*} matches []

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:951.1-954.47
  clause 1(tableProperty'*{tableProperty' <- tableProperty'*}) = (1 + $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*}))
  -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
  -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
  -- if tableProperty matches `KEY={%}`
  -- let key={ _tableKeyList } = tableProperty

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:955.1-959.15
  clause 2(tableProperty*{tableProperty <- tableProperty*}) = $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*})
  -- if tableProperty*{tableProperty <- tableProperty*} matches _ :: _
  -- let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty*{tableProperty <- tableProperty*}
  -- otherwise

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:961.1-961.47
def $count_table_actions(tableProperty*) : nat =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:963.1-963.34
  clause 0(tableProperty*{tableProperty <- tableProperty*}) = 0
  -- if tableProperty*{tableProperty <- tableProperty*} matches []

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:964.1-967.50
  clause 1(tableProperty'*{tableProperty' <- tableProperty'*}) = (1 + $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*}))
  -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
  -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
  -- if tableProperty matches `ACTIONS={%}`
  -- let actions={ _tableActionList } = tableProperty

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:968.1-972.15
  clause 2(tableProperty*{tableProperty <- tableProperty*}) = $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*})
  -- if tableProperty*{tableProperty <- tableProperty*} matches _ :: _
  -- let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty*{tableProperty <- tableProperty*}
  -- otherwise

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:7.1-7.73
def $filter_default_parameters(parameterTypeIR*, id*) : parameterTypeIR* =

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:9.1-9.55
  clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = []
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:10.1-16.28
  clause 1(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
  -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
  -- let _direction _typeIR id_h _value?{_value <- _value?} = parameterTypeIR_h
  -- if id_h <- id_default*{id_default <- id_default*}

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:17.1-22.15
  clause 2(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = parameterTypeIR_h :: $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
  -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
  -- otherwise

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:26.1-26.71
def $align_parameters(parameterTypeIR*, argumentIR*) : parameterTypeIR* =

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:29.1-32.90
  clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}
  -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
  -- (let parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?} = $align_parameters'({ id : parameterTypeIR*{id <- id*, parameterTypeIR <- parameterTypeIR*} }, parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, parameterTypeIR <- parameterTypeIR*, parameterTypeIR'? <- parameterTypeIR'?*}
  -- (if parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?} matches (_))*{parameterTypeIR'? <- parameterTypeIR'?*}
  -- (let ?(parameterTypeIR_aligned) = parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?})*{parameterTypeIR'? <- parameterTypeIR'?*, parameterTypeIR_aligned <- parameterTypeIR_aligned*}

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:27.1-27.96
def $align_parameters'(map<id, parameterTypeIR>, parameterTypeIR, argumentIR) : parameterTypeIR? =

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:34.1-35.20
  clause 0(_map<id, parameterTypeIR>, parameterTypeIR, argumentIR) = ?(parameterTypeIR)
  -- if argumentIR <: typedExpressionIR
  -- let typedExpressionIR = argumentIR as typedExpressionIR

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:36.1-37.80
  clause 1({ id_param : parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }, _parameterTypeIR, argumentIR) = $find_map<id, parameterTypeIR>({ id_param : parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }, nameIR)
  -- if argumentIR matches `%=%`
  -- let nameIR = _typedExpressionIR = argumentIR

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:38.1-39.80
  clause 2({ id_param : parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }, _parameterTypeIR, argumentIR) = $find_map<id, parameterTypeIR>({ id_param : parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }, nameIR)
  -- if argumentIR matches `%=_`
  -- let nameIR =_ = argumentIR

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:40.1-41.20
  clause 3(_map<id, parameterTypeIR>, parameterTypeIR, argumentIR) = ?(parameterTypeIR)
  -- if argumentIR matches `_`

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:60.1-62.23
relation Expr_lvalue_ok: cursor typingContext |- typedExpressionIR
  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:64.1-67.45
  rulegroup referenceExpressionIR
   match
    (expl-input) p | TC | prefixedNameIR as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: prefixedNameIR
    -- let prefixedNameIR = expressionIR as prefixedNameIR
   paths
  {
    rulepath referenceExpressionIR
    (premises)
    -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedNameIR)
    -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
    -- let ?(direction _typeIR' ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
    -- if ctk matches `DYN`
    -- if ((direction = out) \/ (direction = inout))
    (output) 
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:69.1-90.2
  rulegroup accessExpressionIR-memberAccessExpressionIR
   match
    (expl-input) p | TC | typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR <: typedExpressionIR
    -- let typedExpressionIR_base = memberAccessBaseIR as typedExpressionIR
   paths
  {
    rulepath headerstack-next-last
    (premises)
    -- if Expr_lvalue_ok: p TC |- typedExpressionIR_base holds
    -- let _expressionIR # ( typeIR_base _ctk' ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR
    -- if ((nameIR = "next") \/ (nameIR = "last"))
    -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
    (output) 

    rulepath non-headerstack
    (premises)
    -- if Expr_lvalue_ok: p TC |- typedExpressionIR_base holds
    -- let _expressionIR # ( typeIR_base _ctk' ) = typedExpressionIR_base
    -- if ~$is_headerStackTypeIR($canon(typeIR_base))
    (output) 
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:92.1-94.52
  rulegroup accessExpressionIR-indexAccessExpressionIR
   match
    (expl-input) p | TC | typedExpressionIR_base [ typedExpressionIR_index ] as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: indexAccessExpressionIR
    -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
    -- if indexAccessExpressionIR matches `%[%]`
    -- let typedExpressionIR_base [ typedExpressionIR_index ] = indexAccessExpressionIR
   paths
  {
    rulepath accessExpressionIR-indexAccessExpressionIR
    (premises)
    -- if Expr_lvalue_ok: p TC |- typedExpressionIR_base holds
    (output) 
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:96.1-99.52
  rulegroup accessExpressionIR-indexAccessExpressionIR-bitslice
   match
    (expl-input) p | TC | typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ] as expressionIR # ( _typeIR _ctk )
    (impl-input) p | TC | expressionIR # ( _typeIR _ctk )
    (impl-input-premises)
    -- if expressionIR <: indexAccessExpressionIR
    -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
    -- if indexAccessExpressionIR matches `%[%:%]`
    -- let typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ] = indexAccessExpressionIR
   paths
  {
    rulepath accessExpressionIR-indexAccessExpressionIR-bitslice
    (premises)
    -- if Expr_lvalue_ok: p TC |- typedExpressionIR_base holds
    (output) 
  }

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:6.1-7.12
syntax infer = 
   | knownas typeIR
   | unknown

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:9.21-9.36
syntax constraint = map<tid, infer>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:11.1-11.41
def $empty_constraint(tid*) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:12.1-12.53
  clause 0(tid*{tid <- tid*}) = { tid : unknown*{tid <- tid*} }

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:14.20-14.36
syntax inference = map<tid, typeIR>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:20.1-20.60
def $infer(tid*, parameterTypeIR*, argumentIR*) : inference =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:44.1-52.61
  clause 0(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = inference
  -- let constraint_init = $empty_constraint(tid_infer*{tid_infer <- tid_infer*})
  -- (let constraint_pair = $infer'(constraint_init, parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, constraint_pair <- constraint_pair*, parameterTypeIR <- parameterTypeIR*}
  -- let constraint_inferred = $merge_constraints(constraint_init, constraint_pair*{constraint_pair <- constraint_pair*})
  -- let inference = $resolve_constraint(constraint_inferred)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:21.1-21.66
def $infer'(constraint, parameterTypeIR, argumentIR) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:54.1-57.51
  clause 0(constraint, parameterTypeIR, argumentIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if argumentIR <: typedExpressionIR
  -- let typedExpressionIR = argumentIR as typedExpressionIR
  -- let _direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR
  -- let _expressionIR # ( typeIR_arg _ctk ) = typedExpressionIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:59.1-62.51
  clause 1(constraint, parameterTypeIR, argumentIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if argumentIR matches `%=%`
  -- let nameIR = typedExpressionIR = argumentIR
  -- let _direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR
  -- let _expressionIR # ( typeIR_arg _ctk ) = typedExpressionIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:64.1-64.68
  clause 2(constraint, parameterTypeIR, argumentIR) = constraint
  -- if argumentIR matches `%=_`
  -- let nameIR =_ = argumentIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:66.1-66.58
  clause 3(constraint, parameterTypeIR, argumentIR) = constraint
  -- if argumentIR matches `_`

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:23.1-23.66
def $gen_constraint_type(constraint, typeIR, typeIR) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:74.1-76.66
  clause 0(constraint, typeIR, typeIR_arg) = $update_map<tid, infer>(constraint, tid_param, knownas typeIR_arg)
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid tid_param = namedTypeIR
  -- if $in_set<tid>(tid_param, $dom_map<tid, infer>(constraint))

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:78.1-99.26
  clause 1(constraint_0, typeIR, typeIR') = constraint_2
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `%<%>`
  -- let polyTypeDefIR_param < typeIR_param*{typeIR_param <- typeIR_param*} > = namedTypeIR
  -- if typeIR' <: namedTypeIR
  -- let namedTypeIR' = typeIR' as namedTypeIR
  -- if namedTypeIR' matches `%<%>`
  -- let polyTypeDefIR_arg < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR'
  -- let typeIR_specialized_param = $specialize_typeDef(polyTypeDefIR_param as typeDefIR, typeIR_param*{typeIR_param <- typeIR_param*})
  -- let typeIR_specialized_arg = $specialize_typeDef(polyTypeDefIR_arg as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if ($is_nominal_typeIR(typeIR_specialized_param) /\ $is_nominal_typeIR(typeIR_specialized_arg))
  -- let constraint_1 = $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg)
  -- let constraint_2 = $gen_constraint_types(constraint_1, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:101.1-117.26
  clause 2(constraint_0, typeIR, typeIR') = constraint_1
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `%<%>`
  -- let polyTypeDefIR_param < typeIR_param*{typeIR_param <- typeIR_param*} > = namedTypeIR
  -- if typeIR' <: namedTypeIR
  -- let namedTypeIR' = typeIR' as namedTypeIR
  -- if namedTypeIR' matches `%<%>`
  -- let polyTypeDefIR_arg < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR'
  -- let typeIR_specialized_param = $specialize_typeDef(polyTypeDefIR_param as typeDefIR, typeIR_param*{typeIR_param <- typeIR_param*})
  -- let typeIR_specialized_arg = $specialize_typeDef(polyTypeDefIR_arg as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if (~$is_nominal_typeIR(typeIR_specialized_param) /\ ~$is_nominal_typeIR(typeIR_specialized_arg))
  -- let constraint_1 = $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg)

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:121.1-122.63
  clause 3(constraint, typeIR, typeIR_arg) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPEDEF%%`
  -- let typedef _tid typeIR_param = aliasTypeIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:124.1-125.63
  clause 4(constraint, typeIR_param, typeIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPEDEF%%`
  -- let typedef _tid typeIR_arg = aliasTypeIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:127.1-128.63
  clause 5(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type tid typeIR_param = aliasTypeIR
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR' = typeIR' as aliasTypeIR
  -- if aliasTypeIR' matches `TYPE%%`
  -- let type tid' typeIR_arg = aliasTypeIR'
  -- if (tid = tid')

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:132.1-137.63
  clause 6(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if typeIR <: listTypeIR
  -- let list< typeIR_param > = typeIR as listTypeIR
  -- if typeIR' <: listTypeIR
  -- let list< typeIR_arg > = typeIR' as listTypeIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:139.1-144.66
  clause 7(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: tupleTypeIR
  -- let tuple< typeIR_param*{typeIR_param <- typeIR_param*} > = typeIR as tupleTypeIR
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR_arg*{typeIR_arg <- typeIR_arg*} > = typeIR' as tupleTypeIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:146.1-151.63
  clause 8(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if typeIR <: headerStackTypeIR
  -- let typeIR_param [ n_size ] = typeIR as headerStackTypeIR
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR_arg [ n_size' ] = typeIR' as headerStackTypeIR
  -- if (n_size = n_size')

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:153.1-158.66
  clause 9(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: structTypeIR
  -- let struct tid { typeIR_param id_field ;*{id_field <- id_field*, typeIR_param <- typeIR_param*} } = typeIR as structTypeIR
  -- if typeIR' <: structTypeIR
  -- let struct tid' { typeIR_arg id_field' ;*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} } = typeIR' as structTypeIR
  -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
  -- if (tid = tid')

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:160.1-165.66
  clause 10(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: headerTypeIR
  -- let header tid { typeIR_param id_field ;*{id_field <- id_field*, typeIR_param <- typeIR_param*} } = typeIR as headerTypeIR
  -- if typeIR' <: headerTypeIR
  -- let header tid' { typeIR_arg id_field' ;*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} } = typeIR' as headerTypeIR
  -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
  -- if (tid = tid')

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:167.1-172.66
  clause 11(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: headerUnionTypeIR
  -- let header_union tid { typeIR_param id_field ;*{id_field <- id_field*, typeIR_param <- typeIR_param*} } = typeIR as headerUnionTypeIR
  -- if typeIR' <: headerUnionTypeIR
  -- let header_union tid' { typeIR_arg id_field' ;*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} } = typeIR' as headerUnionTypeIR
  -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
  -- if (tid = tid')

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:176.1-185.6
  clause 12(constraint, typeIR, typeIR') = $gen_constraint_routines(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*})
  -- if typeIR <: externObjectTypeIR
  -- let extern tid { rid : routineTypeDefIR_param*{rid <- rid*, routineTypeDefIR_param <- routineTypeDefIR_param*} } = typeIR as externObjectTypeIR
  -- if typeIR' <: externObjectTypeIR
  -- let extern tid' { rid' : routineTypeDefIR_arg*{rid' <- rid'*, routineTypeDefIR_arg <- routineTypeDefIR_arg*} } = typeIR' as externObjectTypeIR
  -- (if (rid = rid'))*{rid <- rid*, rid' <- rid'*}
  -- if (tid = tid')

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:187.1-194.58
  clause 13(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: parserObjectTypeIR
  -- let parser( parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} ) = typeIR as parserObjectTypeIR
  -- if typeIR' <: parserObjectTypeIR
  -- let parser( parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} ) = typeIR' as parserObjectTypeIR
  -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
  -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
  -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:196.1-203.58
  clause 14(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: controlObjectTypeIR
  -- let control( parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} ) = typeIR as controlObjectTypeIR
  -- if typeIR' <: controlObjectTypeIR
  -- let control( parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} ) = typeIR' as controlObjectTypeIR
  -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
  -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
  -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:205.1-210.66
  clause 15(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: packageObjectTypeIR
  -- let package< typeIR_param*{typeIR_param <- typeIR_param*} > = typeIR as packageObjectTypeIR
  -- if typeIR' <: packageObjectTypeIR
  -- let package< typeIR_arg*{typeIR_arg <- typeIR_arg*} > = typeIR' as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:214.1-216.15
  clause 16(constraint, typeIR_param, typeIR_arg) = constraint
  -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:24.1-24.69
def $gen_constraint_types(constraint, typeIR*, typeIR*) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:220.1-223.69
  clause 0(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})
  -- (let constraint_pair = $gen_constraint_type(constraint, typeIR_param, typeIR_arg))*{constraint_pair <- constraint_pair*, typeIR_arg <- typeIR_arg*, typeIR_param <- typeIR_param*}

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:25.1-28.15
def $gen_constraint_routine(constraint, routineTypeDefIR, routineTypeDefIR) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:227.1-238.77
  clause 0(constraint_0, routineTypeDefIR, routineTypeDefIR') = constraint_2
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < _tid*{_tid <- _tid*} , _tid'*{_tid' <- _tid'*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
  -- let extern_method( parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} )-> typeIR_ret_param = methodTypeIR
  -- if routineTypeDefIR' <: polyRoutineTypeDefIR
  -- let routineTypeIR' < _tid''*{_tid'' <- _tid''*} , _tid'''*{_tid''' <- _tid'''*} > = routineTypeDefIR' as polyRoutineTypeDefIR
  -- if routineTypeIR' <: methodTypeIR
  -- let methodTypeIR' = routineTypeIR' as methodTypeIR
  -- if methodTypeIR' matches `EXTERN_METHOD(%)->%`
  -- let extern_method( parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} )-> typeIR_ret_arg = methodTypeIR'
  -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
  -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
  -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}
  -- let constraint_1 = $gen_constraint_types(constraint_0, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- let constraint_2 = $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg)

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:240.1-251.77
  clause 1(constraint_0, routineTypeDefIR, routineTypeDefIR') = constraint_2
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < _tid*{_tid <- _tid*} , _tid'*{_tid' <- _tid'*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} )-> typeIR_ret_param = methodTypeIR
  -- if routineTypeDefIR' <: polyRoutineTypeDefIR
  -- let routineTypeIR' < _tid''*{_tid'' <- _tid''*} , _tid'''*{_tid''' <- _tid'''*} > = routineTypeDefIR' as polyRoutineTypeDefIR
  -- if routineTypeIR' <: methodTypeIR
  -- let methodTypeIR' = routineTypeIR' as methodTypeIR
  -- if methodTypeIR' matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} )-> typeIR_ret_arg = methodTypeIR'
  -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
  -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
  -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}
  -- let constraint_1 = $gen_constraint_types(constraint_0, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- let constraint_2 = $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:29.1-32.15
def $gen_constraint_routines(constraint, routineTypeDefIR*, routineTypeDefIR*) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:255.1-266.12
  clause 0(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*}) = $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})
  -- (let constraint_pair = $gen_constraint_routine(constraint, routineTypeDefIR_param, routineTypeDefIR_arg))*{constraint_pair <- constraint_pair*, routineTypeDefIR_arg <- routineTypeDefIR_arg*, routineTypeDefIR_param <- routineTypeDefIR_param*}

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:34.1-34.59
def $merge_constraint(constraint, constraint) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:272.1-276.52
  clause 0(constraint_pre, constraint_post) = $merge_constraint'(constraint_pre, constraint_post, tid_pre*{tid_pre <- tid_pre*}, { [] })
  -- let { tid_pre*{tid_pre <- tid_pre*} } = $dom_map<tid, infer>(constraint_pre)
  -- let { tid_post*{tid_post <- tid_post*} } = $dom_map<tid, infer>(constraint_post)
  -- if $eq_set<tid>({ tid_pre*{tid_pre <- tid_pre*} }, { tid_post*{tid_post <- tid_post*} })

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:35.1-35.78
def $merge_constraint'(constraint, constraint, tid*, constraint) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:278.1-281.15
  clause 0(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = constraint
  -- if tid*{tid <- tid*} matches []

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:283.1-292.60
  clause 1(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- if (?(unknown) = $find_map<tid, infer>(constraint_pre, tid_h))
  -- if (?(unknown) = $find_map<tid, infer>(constraint_post, tid_h))
  -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, unknown)

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:294.1-303.73
  clause 2(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- if (?(unknown) = $find_map<tid, infer>(constraint_pre, tid_h))
  -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_post, tid_h)
  -- if infer'?{infer' <- infer'?} matches (_)
  -- let ?(infer) = infer'?{infer' <- infer'?}
  -- if infer matches `KNOWNAS%`
  -- let knownas typeIR_post = infer
  -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, knownas typeIR_post)

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:305.1-314.72
  clause 3(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
  -- if infer'?{infer' <- infer'?} matches (_)
  -- let ?(infer) = infer'?{infer' <- infer'?}
  -- if infer matches `KNOWNAS%`
  -- let knownas typeIR_pre = infer
  -- if (?(unknown) = $find_map<tid, infer>(constraint_post, tid_h))
  -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, knownas typeIR_pre)

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:316.1-326.73
  clause 4(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
  -- if infer'?{infer' <- infer'?} matches (_)
  -- let ?(infer) = infer'?{infer' <- infer'?}
  -- if infer matches `KNOWNAS%`
  -- let knownas typeIR_pre = infer
  -- let infer'''?{infer''' <- infer'''?} = $find_map<tid, infer>(constraint_post, tid_h)
  -- if infer'''?{infer''' <- infer'''?} matches (_)
  -- let ?(infer'') = infer'''?{infer''' <- infer'''?}
  -- if infer'' matches `KNOWNAS%`
  -- let knownas typeIR_post = infer''
  -- if Sub_impl: typeIR_pre <: typeIR_post holds
  -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, knownas typeIR_post)

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:328.1-339.72
  clause 5(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
  -- if infer'?{infer' <- infer'?} matches (_)
  -- let ?(infer) = infer'?{infer' <- infer'?}
  -- if infer matches `KNOWNAS%`
  -- let knownas typeIR_pre = infer
  -- let infer'''?{infer''' <- infer'''?} = $find_map<tid, infer>(constraint_post, tid_h)
  -- if infer'''?{infer''' <- infer'''?} matches (_)
  -- let ?(infer'') = infer'''?{infer''' <- infer'''?}
  -- if infer'' matches `KNOWNAS%`
  -- let knownas typeIR_post = infer''
  -- if ~Sub_impl: typeIR_pre <: typeIR_post holds
  -- if Sub_impl: typeIR_post <: typeIR_pre holds
  -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, knownas typeIR_pre)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:36.1-36.61
def $merge_constraints(constraint, constraint*) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:341.1-341.61
  clause 0(constraint_pre, constraint*{constraint <- constraint*}) = constraint_pre
  -- if constraint*{constraint <- constraint*} matches []

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:343.1-351.65
  clause 1(constraint_pre_0, constraint*{constraint <- constraint*}) = constraint_pre_2
  -- if constraint*{constraint <- constraint*} matches _ :: _
  -- let constraint_post_h :: constraint_post_t*{constraint_post_t <- constraint_post_t*} = constraint*{constraint <- constraint*}
  -- let constraint_pre_1 = $merge_constraint(constraint_pre_0, constraint_post_h)
  -- let constraint_pre_2 = $merge_constraints(constraint_pre_1, constraint_post_t*{constraint_post_t <- constraint_post_t*})

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:38.1-38.48
def $resolve_constraint(constraint) : inference =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:357.1-359.35
  clause 0({ tid : infer*{infer <- infer*, tid <- tid*} }) = { tid : typeIR*{tid <- tid*, typeIR <- typeIR*} }
  -- (let infer' = infer)*{infer <- infer*, infer' <- infer'*}
  -- (if infer' matches `KNOWNAS%`)*{infer' <- infer'*}
  -- (let knownas typeIR = infer')*{infer' <- infer'*, typeIR <- typeIR*}

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:21.1-21.65
def $instantiable_extern(cursor, typingContext, instctxt) : bool =

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:23.1-23.54
  clause 0(cursor, TC, instctxt) = true
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:24.1-24.53
  clause 1(cursor, TC, instctxt) = true
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:25.1-25.53
  clause 2(cursor, TC, instctxt) = true
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:27.1-27.65
def $instantiable_parser(cursor, typingContext, instctxt) : bool =

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:29.1-30.20
  clause 0(cursor, TC, instctxt) = (instctxt = anon)
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:31.1-32.40
  clause 1(cursor, TC, instctxt) = $is_parser_blockKind(TC.block.kind)
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:33.1-34.46
  clause 2(cursor, TC, instctxt) = $is_parser_state_localKind(TC.local.kind)
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:36.1-36.66
def $instantiable_control(cursor, typingContext, instctxt) : bool =

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:38.1-39.20
  clause 0(cursor, TC, instctxt) = (instctxt = anon)
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:40.1-41.41
  clause 1(cursor, TC, instctxt) = $is_control_blockKind(TC.block.kind)
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:42.1-43.54
  clause 2(cursor, TC, instctxt) = $is_control_apply_method_localKind(TC.local.kind)
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:45.1-45.66
def $instantiable_package(cursor, typingContext, instctxt) : bool =

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:47.1-47.55
  clause 0(cursor, TC, instctxt) = true
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:48.1-49.41
  clause 1(cursor, TC, instctxt) = $is_package_blockKind(TC.block.kind)
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:50.1-50.55
  clause 2(cursor, TC, instctxt) = false
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:52.1-52.64
def $instantiable_table(cursor, typingContext, instctxt) : bool =

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:54.1-54.54
  clause 0(cursor, TC, instctxt) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:55.1-56.41
  clause 1(cursor, TC, instctxt) = $is_control_blockKind(TC.block.kind)
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:57.1-57.53
  clause 2(cursor, TC, instctxt) = false
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:59.1-59.66
def $instantiable(cursor, typingContext, instctxt, typeIR) : bool =

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:61.1-63.49
  clause 0(p, TC, instctxt, typeIR) = $instantiable_extern(p, TC, instctxt)
  -- if $is_extern_object_typeIR($canon(typeIR))

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:64.1-66.49
  clause 1(p, TC, instctxt, typeIR) = $instantiable_parser(p, TC, instctxt)
  -- if $is_parser_object_typeIR($canon(typeIR))

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:67.1-69.50
  clause 2(p, TC, instctxt, typeIR) = $instantiable_control(p, TC, instctxt)
  -- if $is_control_object_typeIR($canon(typeIR))

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:70.1-72.50
  clause 3(p, TC, instctxt, typeIR) = $instantiable_package(p, TC, instctxt)
  -- if $is_package_object_typeIR($canon(typeIR))

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:73.1-75.48
  clause 4(p, TC, instctxt, typeIR) = $instantiable_table(p, TC, instctxt)
  -- if $is_table_object_typeIR($canon(typeIR))

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:55.1-55.33
def $lvalue(lvalue) : expression =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:56.1-56.55
  clause 0(lvalue) = referenceExpression as expression
  -- if lvalue <: referenceExpression
  -- let referenceExpression = lvalue as referenceExpression

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:57.1-59.47
  clause 1(lvalue) = expression_base as memberAccessBase . member as expression
  -- if lvalue matches `%.%`
  -- let lvalue_base . member = lvalue
  -- let expression_base = $lvalue(lvalue_base)

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:60.1-62.47
  clause 2(lvalue) = expression_base [ expression_index ] as expression
  -- if lvalue matches `%[%]`
  -- let lvalue_base [ expression_index ] = lvalue
  -- let expression_base = $lvalue(lvalue_base)

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:63.1-65.47
  clause 3(lvalue) = expression_base [ expression_hi : expression_lo ] as expression
  -- if lvalue matches `%[%:%]`
  -- let lvalue_base [ expression_hi : expression_lo ] = lvalue
  -- let expression_base = $lvalue(lvalue_base)

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:66.1-67.37
  clause 4(lvalue') = ( expression ) as expression
  -- if lvalue' matches `(%)`
  -- let ( lvalue ) = lvalue'
  -- let expression = $lvalue(lvalue)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:239.1-239.61
def $callable_builtin_function(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:241.1-241.50
  clause 0(cursor, TC) = true
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:242.1-242.49
  clause 1(cursor, TC) = true
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:243.1-243.49
  clause 2(cursor, TC) = true
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:266.1-266.53
def $callable_function(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:268.1-268.43
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:269.1-271.44
  clause 1(cursor, TC) = ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:272.1-274.60
  clause 2(cursor, TC) = (~$is_extern_method_localKind(TC.local.kind) /\ ~$is_extern_abstract_method_localKind(TC.local.kind))
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:310.1-310.60
def $callable_extern_function(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:312.1-312.50
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:313.1-315.44
  clause 1(cursor, TC) = ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:316.1-316.48
  clause 2(cursor, TC) = true
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:352.1-352.51
def $callable_action(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:354.1-354.41
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:355.1-355.40
  clause 1(cursor, TC) = false
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:356.1-358.57
  clause 2(cursor, TC) = ($is_action_localKind(TC.local.kind) \/ $is_control_apply_method_localKind(TC.local.kind))
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:383.1-383.59
def $callable_builtin_method(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:385.1-385.48
  clause 0(cursor, TC) = true
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:386.1-386.47
  clause 1(cursor, TC) = true
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:387.1-387.47
  clause 2(cursor, TC) = true
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:410.1-410.58
def $callable_extern_method(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:412.1-412.48
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:413.1-415.44
  clause 1(cursor, TC) = ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:416.1-416.46
  clause 2(cursor, TC) = true
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:452.1-452.67
def $callable_extern_abstract_method(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:454.1-454.57
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:455.1-457.44
  clause 1(cursor, TC) = ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:458.1-458.55
  clause 2(cursor, TC) = true
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:494.1-494.64
def $callable_parser_apply_method(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:496.1-496.54
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:497.1-497.53
  clause 1(cursor, TC) = false
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:498.1-499.46
  clause 2(cursor, TC) = $is_parser_state_localKind(TC.local.kind)
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:522.1-522.65
def $callable_control_apply_method(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:524.1-524.55
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:525.1-525.54
  clause 1(cursor, TC) = false
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:526.1-527.54
  clause 2(cursor, TC) = $is_control_apply_method_localKind(TC.local.kind)
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:550.1-550.63
def $callable_table_apply_method(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:552.1-552.53
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:553.1-553.52
  clause 1(cursor, TC) = false
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:554.1-556.55
  clause 2(cursor, TC) = ($is_control_apply_method_localKind(TC.local.kind) \/ $is_table_apply_method_localKind(TC.local.kind))
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:5.1-5.27
def $empty_theta : theta =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:6.1-6.47
  clause 0 = $empty_map<tid, typeIR>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:9.15-9.29
syntax venv = map<id, value>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:11.1-11.25
def $empty_venv : venv =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:12.1-12.42
  clause 0 = $empty_map<id, value>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:15.19-15.41
syntax stateDyn = parserBlockStatementIR

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:18.15-18.36
syntax senv = map<nameIR, stateDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:20.1-20.25
def $empty_senv : senv =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:21.1-21.49
  clause 0 = $empty_map<nameIR, stateDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:28.1-31.34
syntax lvalueDyn = 
   | ` nameIR
   | . nameIR
   | lvalueDyn . nameIR
   | lvalueDyn [ value ]
   | lvalueDyn [ value : value ]

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:40.1-43.96
syntax funcDyn = 
   | builtin_function< typeParameterListIR >( parameterListIR ){ blockElementStatementListIR }
   | function< typeParameterListIR >( parameterListIR ) blockStatementIR
   | action( parameterListIR ){ blockStatementIR }
   | extern_function< typeParameterListIR >( parameterListIR ){ blockElementStatementIR? }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:46.1-51.41
syntax methodDyn = 
   | builtin_method( parameterListIR )# lvalueDyn
   | extern_method< typeParameterListIR >( parameterListIR ) blockStatementIR?
   | extern_methodabstract< typeParameterListIR >( parameterListIR )
   | parser_apply( parameterListIR ){ parserLocalDeclarationListIR ; senv }
   | control_apply( parameterListIR ){ controlLocalDeclarationListIR ; renv ; blockElementStatementListIR }
   | table_apply{ tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:54.1-55.14
syntax routineDyn = 
   | builtin_function< typeParameterListIR >( parameterListIR ){ blockElementStatementListIR }
   | function< typeParameterListIR >( parameterListIR ) blockStatementIR
   | action( parameterListIR ){ blockStatementIR }
   | extern_function< typeParameterListIR >( parameterListIR ){ blockElementStatementIR? }
   | builtin_method( parameterListIR )# lvalueDyn
   | extern_method< typeParameterListIR >( parameterListIR ) blockStatementIR?
   | extern_methodabstract< typeParameterListIR >( parameterListIR )
   | parser_apply( parameterListIR ){ parserLocalDeclarationListIR ; senv }
   | control_apply( parameterListIR ){ controlLocalDeclarationListIR ; renv ; blockElementStatementListIR }
   | table_apply{ tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:58.15-58.35
syntax renv = map<rid, routineDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:60.1-60.25
def $empty_renv : renv =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:61.1-61.48
  clause 0 = $empty_map<rid, routineDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:68.1-72.42
syntax consDyn = 
   | extern nameIR < typeParameterListIR >( constructorParameterListIR ){ methodPrototypeListIR }
   | parser< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
   | control< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
   | package< typeParameterListIR >( constructorParameterListIR )
   | table nameIR { tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:75.15-75.32
syntax cenv = map<cid, consDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:77.1-77.25
def $empty_cenv : cenv =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:78.1-78.45
  clause 0 = $empty_map<cid, consDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:85.1-89.44
syntax objDyn = 
   | extern{ tid theta venv renv }
   | parser{ venv parameterListIR parserLocalDeclarationListIR senv }
   | control{ venv parameterListIR controlLocalDeclarationListIR renv controlBodyIR }
   | package{ theta venv }
   | table{ tid venv tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:92.14-92.30
syntax sto = map<oid, objDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:94.1-94.23
def $empty_sto : sto =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:96.1-96.43
  clause 0 = $empty_map<oid, objDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:98.1-98.37
def $add_sto(sto, oid, objDyn) : sto =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:100.1-101.44
  clause 0(sto, oid, objDyn) = $add_map<oid, objDyn>(sto, oid, objDyn)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:8.3-11.16
syntax globalInstantiationLayer = {cenv cenv, tdenv tdenv, renv renv, venv venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:16.3-19.16
syntax blockInstantiationLayer = {theta theta, renv renv, senv senv, venv venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:24.3-25.18
syntax localInstantiationLayer = {theta theta, venvs venv*}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:32.3-35.36
syntax contextInst = {path oid, global globalInstantiationLayer, block blockInstantiationLayer, local localInstantiationLayer}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:43.1-43.45
def $empty_block : blockInstantiationLayer =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:45.1-49.23
  clause 0 = {theta $empty_theta, renv $empty_renv, senv $empty_senv, venv $empty_venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:51.1-51.45
def $empty_local : localInstantiationLayer =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:53.1-55.17
  clause 0 = {theta $empty_theta, venvs []}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:57.1-57.40
def $empty_context_inst : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:59.1-71.11
  clause 0 = Ci
  -- let globalInstantiationLayer = {cenv $empty_cenv, tdenv $empty_tdenv, renv $empty_renv, venv $empty_venv}
  -- let blockInstantiationLayer = $empty_block
  -- let localInstantiationLayer = $empty_local
  -- let Ci = {path [], global globalInstantiationLayer, block blockInstantiationLayer, local localInstantiationLayer}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:78.1-78.43
def $enter_inst(contextInst) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:80.1-80.73
  clause 0(Ci) = Ci[local.venvs = $empty_venv :: Ci.local.venvs]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:82.1-82.42
def $exit_inst(contextInst) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:84.1-85.43
  clause 0(Ci) = Ci[local.venvs = venv_t*{venv_t <- venv_t*}]
  -- let venv*{venv <- venv*} = Ci.local.venvs
  -- if venv*{venv <- venv*} matches _ :: _
  -- let venv_h :: venv_t*{venv_t <- venv_t*} = venv*{venv <- venv*}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:91.1-91.47
def $enter_path(contextInst, id) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:93.1-93.54
  clause 0(Ci, id) = Ci[path = Ci.path ++ [id]]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:99.1-99.58
def $copy_context_inst(cursor, contextInst) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:101.1-101.90
  clause 0(cursor, Ci) = Ci[block = $empty_block][local = $empty_local]
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:102.1-102.64
  clause 1(cursor, Ci) = Ci[local = $empty_local]
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:103.1-103.39
  clause 2(cursor, Ci) = Ci
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:111.1-111.65
def $add_value_inst(cursor, contextInst, id, value) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:114.1-116.62
  clause 0(cursor, Ci, id, value) = Ci[global.venv = venv]
  -- if cursor matches `GLOBAL`
  -- if ~$in_set<id>(id, $dom_map<id, value>(Ci.global.venv))
  -- let venv = $add_map<id, value>(Ci.global.venv, id, value)

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:117.1-119.61
  clause 1(cursor, Ci, id, value) = Ci[block.venv = venv]
  -- if cursor matches `BLOCK`
  -- if ~$in_set<id>(id, $dom_map<id, value>(Ci.block.venv))
  -- let venv = $add_map<id, value>(Ci.block.venv, id, value)

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:120.1-123.57
  clause 2(cursor, Ci, id, value) = Ci[local.venvs = venv_h' :: venv_t*{venv_t <- venv_t*}]
  -- if cursor matches `LOCAL`
  -- let venv*{venv <- venv*} = Ci.local.venvs
  -- if venv*{venv <- venv*} matches _ :: _
  -- let venv_h :: venv_t*{venv_t <- venv_t*} = venv*{venv <- venv*}
  -- if ~$in_set<id>(id, $dom_map<id, value>(venv_h))
  -- let venv_h' = $add_map<id, value>(venv_h, id, value)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:112.1-112.68
def $add_values_inst(cursor, contextInst, id*, value*) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:125.1-125.43
  clause 0(p, Ci, id*{id <- id*}, value*{value <- value*}) = Ci
  -- if id*{id <- id*} matches []
  -- if value*{value <- value*} matches []

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:126.1-128.57
  clause 1(p, Ci, id*{id <- id*}, value*{value <- value*}) = Ci''
  -- if id*{id <- id*} matches _ :: _
  -- let id_h :: id_t*{id_t <- id_t*} = id*{id <- id*}
  -- if value*{value <- value*} matches _ :: _
  -- let value_h :: value_t*{value_t <- value_t*} = value*{value <- value*}
  -- let Ci' = $add_value_inst(p, Ci, id_h, value_h)
  -- let Ci'' = $add_values_inst(p, Ci', id_t*{id_t <- id_t*}, value_t*{value_t <- value_t*})

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:132.1-132.73
def $add_typedef_inst(cursor, contextInst, tid, typeDefIR) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:134.1-135.74
  clause 0(cursor, Ci, tid, typeDefIR) = Ci[global.tdenv = tdenv]
  -- if cursor matches `GLOBAL`
  -- let tdenv = $add_map<tid, typeDefIR>(Ci.global.tdenv, tid, typeDefIR)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:139.1-139.73
def $add_state_inst(cursor, contextInst, nameIR, stateDyn) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:141.1-143.75
  clause 0(cursor, Ci, nameIR, stateDyn) = Ci[block.senv = senv]
  -- if cursor matches `BLOCK`
  -- if ~$in_set<nameIR>(nameIR, $dom_map<nameIR, stateDyn>(Ci.block.senv))
  -- let senv = $add_map<nameIR, stateDyn>(Ci.block.senv, nameIR, stateDyn)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:147.1-147.70
def $add_types_inst(cursor, contextInst, tid*, typeIR*) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:150.1-150.42
  clause 0(p, Ci, tid*{tid <- tid*}, typeIR*{typeIR <- typeIR*}) = Ci
  -- if tid*{tid <- tid*} matches []
  -- if typeIR*{typeIR <- typeIR*} matches []

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:151.1-153.53
  clause 1(p, Ci, tid*{tid <- tid*}, typeIR*{typeIR <- typeIR*}) = $add_types_inst(p, Ci', tid_t*{tid_t <- tid_t*}, typeIR_t*{typeIR_t <- typeIR_t*})
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- if typeIR*{typeIR <- typeIR*} matches _ :: _
  -- let typeIR_h :: typeIR_t*{typeIR_t <- typeIR_t*} = typeIR*{typeIR <- typeIR*}
  -- let Ci' = $add_type_inst(p, Ci, tid_h, typeIR_h)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:148.1-148.67
def $add_type_inst(cursor, contextInst, tid, typeIR) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:155.1-156.67
  clause 0(cursor, Ci, tid, typeIR) = Ci[block.theta = theta]
  -- if cursor matches `BLOCK`
  -- let theta = $add_map<tid, typeIR>(Ci.block.theta, tid, typeIR)

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:157.1-158.67
  clause 1(cursor, Ci, tid, typeIR) = Ci[local.theta = theta]
  -- if cursor matches `LOCAL`
  -- let theta = $add_map<tid, typeIR>(Ci.local.theta, tid, typeIR)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:162.1-162.83
def $add_routine_overload_inst(cursor, contextInst, rid, routineDyn) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:164.1-166.74
  clause 0(cursor, Ci, rid, routineDyn) = Ci[global.renv = renv]
  -- if cursor matches `GLOBAL`
  -- if ~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.global.renv))
  -- let renv = $add_map<rid, routineDyn>(Ci.global.renv, rid, routineDyn)

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:167.1-169.73
  clause 1(cursor, Ci, rid, routineDyn) = Ci[block.renv = renv]
  -- if cursor matches `BLOCK`
  -- if ~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.block.renv))
  -- let renv = $add_map<rid, routineDyn>(Ci.block.renv, rid, routineDyn)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:171.1-171.87
def $add_routine_non_overload_inst(cursor, contextInst, rid, routineDyn) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:173.1-177.74
  clause 0(cursor, Ci, rid, routineDyn) = Ci[global.renv = renv]
  -- if cursor matches `GLOBAL`
  -- let id ( _pid*{_pid <- _pid*} ) = rid
  -- let { id_k ( _pid'*{_pid' <- _pid'*} )*{_pid'* <- _pid'**, id_k <- id_k*} } = $dom_map<rid, routineDyn>(Ci.global.renv)
  -- if ~$in_set<id>(id, { id_k*{id_k <- id_k*} })
  -- let renv = $add_map<rid, routineDyn>(Ci.global.renv, rid, routineDyn)

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:178.1-182.73
  clause 1(cursor, Ci, rid, routineDyn) = Ci[block.renv = renv]
  -- if cursor matches `BLOCK`
  -- let id ( _pid*{_pid <- _pid*} ) = rid
  -- let { id_k ( _pid'*{_pid' <- _pid'*} )*{_pid'* <- _pid'**, id_k <- id_k*} } = $dom_map<rid, routineDyn>(Ci.block.renv)
  -- if ~$in_set<id>(id, { id_k*{id_k <- id_k*} })
  -- let renv = $add_map<rid, routineDyn>(Ci.block.renv, rid, routineDyn)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:186.1-186.75
def $add_constructor_inst(cursor, contextInst, cid, consDyn) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:188.1-189.68
  clause 0(cursor, Ci, cid, consDyn) = Ci[global.cenv = cenv]
  -- if cursor matches `GLOBAL`
  -- let cenv = $add_map<cid, consDyn>(Ci.global.cenv, cid, consDyn)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:197.1-197.66
def $find_value_inst(cursor, contextInst, prefixedNameIR) : value =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:199.1-200.57
  clause 0(p, Ci, prefixedNameIR) = value
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR
  -- let value'?{value' <- value'?} = $find_map<id, value>(Ci.global.venv, id)
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:201.1-202.57
  clause 1(cursor, Ci, prefixedNameIR) = value
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let value'?{value' <- value'?} = $find_map<id, value>(Ci.global.venv, id)
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:203.1-204.56
  clause 2(cursor, Ci, prefixedNameIR) = value
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let value'?{value' <- value'?} = $find_map<id, value>(Ci.block.venv, id)
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:205.1-208.54
  clause 3(cursor, Ci, prefixedNameIR) = $find_value_inst(global, Ci, ` id)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- if ($find_map<id, value>(Ci.block.venv, id) = ?())

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:209.1-211.49
  clause 4(cursor, Ci, prefixedNameIR) = value
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let venv*{venv <- venv*} = Ci.local.venvs
  -- let value'?{value' <- value'?} = $find_maps<id, value>(venv*{venv <- venv*}, id)
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:212.1-215.56
  clause 5(cursor, Ci, prefixedNameIR) = $find_value_inst(block, Ci, ` id)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- if ($find_maps<id, value>(Ci.local.venvs, id) = ?())

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:219.1-219.73
def $find_typedef_inst(cursor, contextInst, prefixedNameIR) : typeDefIR? =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:221.1-222.55
  clause 0(_cursor, Ci, prefixedNameIR) = $find_map<tid, typeDefIR>(Ci.global.tdenv, nameIR)
  -- if prefixedNameIR matches ``%`
  -- let ` nameIR = prefixedNameIR

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:223.1-224.55
  clause 1(_cursor, Ci, prefixedNameIR) = $find_map<tid, typeDefIR>(Ci.global.tdenv, nameIR)
  -- if prefixedNameIR matches `.%`
  -- let . nameIR = prefixedNameIR

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:228.1-228.44
def $ids_arguments_IR(argumentIR*) : id?* =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:231.1-231.68
  clause 0(argumentIR*{argumentIR <- argumentIR*}) = $id_argument_IR(argumentIR)*{argumentIR <- argumentIR*}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:229.1-229.38
def $id_argument_IR(argumentIR) : id? =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:232.1-232.45
  clause 0(argumentIR) = ?()
  -- if argumentIR <: typedExpressionIR
  -- let typedExpressionIR = argumentIR as typedExpressionIR

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:233.1-233.42
  clause 1(argumentIR) = ?(nameIR)
  -- if argumentIR matches `%=%`
  -- let nameIR = _typedExpressionIR = argumentIR

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:234.1-234.43
  clause 2(argumentIR) = ?(nameIR)
  -- if argumentIR matches `%=_`
  -- let nameIR =_ = argumentIR

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:235.1-235.30
  clause 3(argumentIR) = ?()
  -- if argumentIR matches `_`

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:237.1-237.103
def $find_constructor_overloaded_inst(contextInst, prefixedNameIR, argumentIR*) : (cid, consDyn, id*)? =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:239.1-241.52
  clause 0(Ci, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<consDyn>(Ci.global.cenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments_IR(argumentIR*{argumentIR <- argumentIR*})

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:242.1-244.52
  clause 1(Ci, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<consDyn>(Ci.global.cenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments_IR(argumentIR*{argumentIR <- argumentIR*})

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:6.1-8.35
relation Constructor_inst: cursor contextInst sto |- consDyn < typeArgumentListIR >( argumentListIR # id* )==> sto objDyn
  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:89.1-110.15
  rulegroup extern
   match
    (expl-input) p | Ci | sto_0 | extern nameIR < typeParameterIR*{} >( constructorParameterIR*{} ){ methodPrototypeIR*{} } | typeArgumentIR*{} | argumentIR*{} | id_default*{}
    (impl-input) p | Ci | sto_0 | consDyn | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if consDyn matches `EXTERN%<%>(%){%}`
    -- let extern nameIR < typeParameterIR*{typeParameterIR <- typeParameterIR*} >( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} } = consDyn
   paths
  {
    rulepath extern
    (premises)
    -- let p_callee = block
    -- let Ci_callee_0 = $copy_context_inst(global, Ci)
    -- let Ci_callee_1 = $add_types_inst(p_callee, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
    -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
    -- Bind_args: p Ci ; p_callee Ci_callee_1 sto_0 |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto_1
    -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
    -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
    -- ExternMethods_inst: Ci_callee_3 |- methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} ==> Ci_callee_4
    -- let objDyn = extern{ nameIR Ci_callee_4.block.theta Ci_callee_4.block.venv Ci_callee_4.block.renv }
    (output) sto_1 | objDyn
  }

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:114.1-141.15
  rulegroup parser
   match
    (expl-input) p | Ci | sto_0 | parser< typeParameterIR*{} >( parameterIR*{} )( constructorParameterIR*{} ){ parserLocalDeclarationIR*{} parserStateIR*{} } | typeArgumentIR*{} | argumentIR*{} | id_default*{}
    (impl-input) p | Ci | sto_0 | consDyn | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if consDyn matches `PARSER<%>(%)(%){%%}`
    -- let parser< typeParameterIR*{typeParameterIR <- typeParameterIR*} >( parameterIR*{parameterIR <- parameterIR*} )( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} parserStateIR*{parserStateIR <- parserStateIR*} } = consDyn
   paths
  {
    rulepath parser
    (premises)
    -- let p_callee = block
    -- let Ci_callee_0 = $copy_context_inst(global, Ci)
    -- let Ci_callee_1 = $add_types_inst(p_callee, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
    -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
    -- Bind_args: p Ci ; p_callee Ci_callee_1 sto_0 |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto_1
    -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
    -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
    -- ParserLocalDecls_inst: Ci_callee_3 sto_1 |- parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} ==> Ci_local sto_2 parserLocalDeclarationIR_inst*{parserLocalDeclarationIR_inst <- parserLocalDeclarationIR_inst*}
    -- let stateDyn_empty = { [] }
    -- let Ci_local_1 = $add_state_inst(block, Ci_local, "accept", stateDyn_empty)
    -- let Ci_local_2 = $add_state_inst(block, Ci_local_1, "reject", stateDyn_empty)
    -- ParserStates_inst: Ci_local_2 sto_2 |- parserStateIR*{parserStateIR <- parserStateIR*} ==> Ci_state sto_3
    -- let objDyn = parser{ Ci_callee_3.block.venv parameterIR*{parameterIR <- parameterIR*} parserLocalDeclarationIR_inst*{parserLocalDeclarationIR_inst <- parserLocalDeclarationIR_inst*} Ci_state.block.senv }
    (output) sto_3 | objDyn
  }

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:145.1-170.15
  rulegroup control
   match
    (expl-input) p | Ci | sto_0 | control< typeParameterIR*{} >( parameterIR*{} )( constructorParameterIR*{} ){ controlLocalDeclarationIR*{} apply controlBodyIR } | typeArgumentIR*{} | argumentIR*{} | id_default*{}
    (impl-input) p | Ci | sto_0 | consDyn | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if consDyn matches `CONTROL<%>(%)(%){%APPLY%}`
    -- let control< typeParameterIR*{typeParameterIR <- typeParameterIR*} >( parameterIR*{parameterIR <- parameterIR*} )( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} apply controlBodyIR } = consDyn
   paths
  {
    rulepath control
    (premises)
    -- let p_callee = block
    -- let Ci_callee_0 = $copy_context_inst(global, Ci)
    -- let Ci_callee_1 = $add_types_inst(p_callee, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
    -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
    -- Bind_args: p Ci ; p_callee Ci_callee_1 sto_0 |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto_1
    -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
    -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
    -- ControlLocalDecls_inst: Ci_callee_3 sto_1 |- controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} ==> Ci_local sto_2 controlLocalDeclarationIR'*{controlLocalDeclarationIR' <- controlLocalDeclarationIR'*}
    -- Block_inst: local Ci_local sto_2 |- controlBodyIR ==> _contextInst sto_3 controlBodyIR'
    -- let objDyn = control{ Ci_callee_3.block.venv parameterIR*{parameterIR <- parameterIR*} controlLocalDeclarationIR'*{controlLocalDeclarationIR' <- controlLocalDeclarationIR'*} Ci_local.block.renv controlBodyIR' }
    (output) sto_3 | objDyn
  }

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:174.1-193.15
  rulegroup package
   match
    (expl-input) p | Ci | sto_0 | package< typeParameterIR*{} >( constructorParameterIR*{} ) | typeArgumentIR*{} | argumentIR*{} | id_default*{}
    (impl-input) p | Ci | sto_0 | consDyn | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if consDyn matches `PACKAGE<%>(%)`
    -- let package< typeParameterIR*{typeParameterIR <- typeParameterIR*} >( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ) = consDyn
   paths
  {
    rulepath package
    (premises)
    -- let p_callee = block
    -- let Ci_callee_0 = $copy_context_inst(global, Ci)
    -- let Ci_callee_1 = $add_types_inst(p_callee, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
    -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
    -- Bind_args: p Ci ; p_callee Ci_callee_1 sto_0 |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto_1
    -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
    -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
    -- let objDyn = package{ Ci_callee_3.block.theta Ci_callee_3.block.venv }
    (output) sto_1 | objDyn
  }

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:202.1-227.15
  rulegroup table
   match
    (expl-input) p | Ci | sto | table nameIR { tablePropertyListIR } | typeArgumentIR*{} | argumentIR*{} | id_default*{}
    (impl-input) p | Ci | sto | consDyn | typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} | argumentIR*{argumentIR <- argumentIR*} | id_default*{id_default <- id_default*}
    (impl-input-premises)
    -- if consDyn matches `TABLE%{%}`
    -- let table nameIR { tablePropertyListIR } = consDyn
   paths
  {
    rulepath table
    (premises)
    -- let p_callee = local
    -- let Ci_callee_0 = $copy_context_inst(block, Ci)
    -- let Ci_callee_1 = $add_types_inst(p_callee, Ci_callee_0, [], typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args([], argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
    -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
    -- Bind_args: p Ci ; p_callee Ci_callee_1 sto |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto_1
    -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
    -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
    -- let Ci_frame = $enter_inst(Ci_callee_3)
    -- TableProperties_inst: Ci_frame sto_1 |- tablePropertyListIR ==> Ci_table sto_2 tablePropertyListIR_inst
    -- let tablePropertyListIR_dynamic = $init_table(tablePropertyListIR_inst)
    -- let venv'*{venv' <- venv'*} = Ci_table.local.venvs
    -- if venv'*{venv' <- venv'*} matches _ :: _
    -- let venv :: _venv*{_venv <- _venv*} = venv'*{venv' <- venv'*}
    -- let objDyn = table{ nameIR venv tablePropertyListIR_dynamic }
    (output) sto_2 | objDyn
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:16.1-18.35
relation Bind_args: cursor contextInst ; cursor contextInst sto |- id* argumentIR* ==> contextInst sto
  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:76.1-77.75
  rulegroup nil
   match
    (expl-input) p_caller | Ci_caller | p_callee | Ci_callee | sto | [] | []
    (impl-input) p_caller | Ci_caller | p_callee | Ci_callee | sto | id*{id <- id*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if id*{id <- id*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) Ci_callee | sto
  }

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:79.1-83.109
  rulegroup cons
   match
    (expl-input) p_caller | Ci_caller | p_callee | Ci_callee_0 | sto_0 | id_h :: id_t*{} | argumentIR_h :: argumentIR_t*{}
    (impl-input) p_caller | Ci_caller | p_callee | Ci_callee_0 | sto_0 | id*{id <- id*} | argumentIR*{argumentIR <- argumentIR*}
    (impl-input-premises)
    -- if id*{id <- id*} matches _ :: _
    -- let id_h :: id_t*{id_t <- id_t*} = id*{id <- id*}
    -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
    -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
   paths
  {
    rulepath cons
    (premises)
    -- Bind_arg: p_caller Ci_caller ; p_callee Ci_callee_0 sto_0 |- id_h argumentIR_h ==> Ci_callee_1 sto_1
    -- Bind_args: p_caller Ci_caller ; p_callee Ci_callee_1 sto_1 |- id_t*{id_t <- id_t*} argumentIR_t*{argumentIR_t <- argumentIR_t*} ==> Ci_callee_2 sto_2
    (output) Ci_callee_2 | sto_2
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:20.1-22.35
relation Bind_arg: cursor contextInst ; cursor contextInst sto |- id argumentIR ==> contextInst sto
  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:70.1-74.72
  rulegroup 
   match
    (expl-input) p_caller | Ci_caller | p_callee | Ci_callee_0 | sto_0 | id | argumentIR
    (impl-input) p_caller | Ci_caller | p_callee | Ci_callee_0 | sto_0 | id | argumentIR
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let Ci_caller_inner = $enter_path(Ci_caller, id)
    -- Argument_inst: p_caller Ci_caller_inner sto_0 |- argumentIR ==> sto_1 value
    -- let Ci_callee_1 = $add_value_inst(p_callee, Ci_callee_0, id, value)
    (output) Ci_callee_1 | sto_1
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:32.1-34.26
relation Expr_inst: cursor contextInst sto |- typedExpressionIR ==> sto value
  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:16.1-17.41
  rulegroup literalExpressionIR-true
   match
    (expl-input) p | Ci | sto | true as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if (expressionIR = true as expressionIR)
   paths
  {
    rulepath literalExpressionIR-true
    (premises)
    (output) sto | b true as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:19.1-20.43
  rulegroup literalExpressionIR-false
   match
    (expl-input) p | Ci | sto | false as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if (expressionIR = false as expressionIR)
   paths
  {
    rulepath literalExpressionIR-false
    (premises)
    (output) sto | b false as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:24.1-25.39
  rulegroup literalExpressionIR-number-arbint
   match
    (expl-input) p | Ci | sto | d i as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: numberLiteral
    -- let numberLiteral = expressionIR as numberLiteral
    -- if numberLiteral matches `D%`
    -- let d i = numberLiteral
   paths
  {
    rulepath literalExpressionIR-number-arbint
    (premises)
    (output) sto | d i as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:27.1-28.43
  rulegroup literalExpressionIR-number-fixint
   match
    (expl-input) p | Ci | sto | n s i as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: numberLiteral
    -- let numberLiteral = expressionIR as numberLiteral
    -- if numberLiteral matches `%S%`
    -- let n s i = numberLiteral
   paths
  {
    rulepath literalExpressionIR-number-fixint
    (premises)
    (output) sto | n s i as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:30.1-31.43
  rulegroup literalExpressionIR-number-fixbit
   match
    (expl-input) p | Ci | sto | n w i as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: numberLiteral
    -- let numberLiteral = expressionIR as numberLiteral
    -- if numberLiteral matches `%W%`
    -- let n w i = numberLiteral
   paths
  {
    rulepath literalExpressionIR-number-fixbit
    (premises)
    (output) sto | n w i as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:35.1-36.53
  rulegroup literalExpressionIR-stringLiteral
   match
    (expl-input) p | Ci | sto | " text " as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: stringLiteral
    -- let " text " = expressionIR as stringLiteral
   paths
  {
    rulepath literalExpressionIR-stringLiteral
    (premises)
    (output) sto | " text " as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:41.1-43.56
  rulegroup referenceExpressionIR-id
   match
    (expl-input) p | Ci | sto | prefixedNameIR as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: prefixedNameIR
    -- let prefixedNameIR = expressionIR as prefixedNameIR
   paths
  {
    rulepath referenceExpressionIR-id
    (premises)
    -- let value = $find_value_inst(p, Ci, prefixedNameIR)
    (output) sto | value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:47.1-48.40
  rulegroup defaultExpressionIR
   match
    (expl-input) p | Ci | sto | ... as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if (expressionIR = ... as expressionIR)
   paths
  {
    rulepath defaultExpressionIR
    (premises)
    (output) sto | default as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:53.1-55.62
  rulegroup unaryExpressionIR-bnot
   match
    (expl-input) p | Ci | sto | ~ typedExpressionIR as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
    -- if unop matches `~`
   paths
  {
    rulepath unaryExpressionIR-bnot
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value
    (output) sto_1 | $un_bnot(value)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:57.1-59.62
  rulegroup unaryExpressionIR-lnot
   match
    (expl-input) p | Ci | sto | ! typedExpressionIR as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
    -- if unop matches `!`
   paths
  {
    rulepath unaryExpressionIR-lnot
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value
    (output) sto_1 | $un_lnot(value)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:61.1-63.62
  rulegroup unaryExpressionIR-plus
   match
    (expl-input) p | Ci | sto | + typedExpressionIR as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
    -- if unop matches `+`
   paths
  {
    rulepath unaryExpressionIR-plus
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value
    (output) sto_1 | $un_plus(value)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:65.1-67.62
  rulegroup unaryExpressionIR-minus
   match
    (expl-input) p | Ci | sto | - typedExpressionIR as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
    -- if unop matches `-`
   paths
  {
    rulepath unaryExpressionIR-minus
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value
    (output) sto_1 | $un_minus(value)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:73.1-77.68
  rulegroup binaryExpressionIR-mul
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l * typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `*`
   paths
  {
    rulepath binaryExpressionIR-mul
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_mul(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:79.1-83.68
  rulegroup binaryExpressionIR-div
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l / typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `/`
   paths
  {
    rulepath binaryExpressionIR-div
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_div(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:85.1-89.68
  rulegroup binaryExpressionIR-mod
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l % typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `%`
   paths
  {
    rulepath binaryExpressionIR-mod
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_mod(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:91.1-95.68
  rulegroup binaryExpressionIR-plus
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l + typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `+`
   paths
  {
    rulepath binaryExpressionIR-plus
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_plus(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:97.1-101.68
  rulegroup binaryExpressionIR-minus
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l - typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `-`
   paths
  {
    rulepath binaryExpressionIR-minus
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_minus(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:103.1-107.68
  rulegroup binaryExpressionIR-satplus
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l |+| typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `|+|`
   paths
  {
    rulepath binaryExpressionIR-satplus
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_satplus(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:109.1-113.68
  rulegroup binaryExpressionIR-satminus
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l |-| typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `|-|`
   paths
  {
    rulepath binaryExpressionIR-satminus
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_satminus(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:115.1-119.68
  rulegroup binaryExpressionIR-shl
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l << typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `<<`
   paths
  {
    rulepath binaryExpressionIR-shl
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_shl(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:121.1-125.68
  rulegroup binaryExpressionIR-shr
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l >> typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `>>`
   paths
  {
    rulepath binaryExpressionIR-shr
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_shr(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:127.1-131.68
  rulegroup binaryExpressionIR-le
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l <= typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `<=`
   paths
  {
    rulepath binaryExpressionIR-le
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | b $bin_le(value_l, value_r) as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:133.1-137.68
  rulegroup binaryExpressionIR-ge
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l >= typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `>=`
   paths
  {
    rulepath binaryExpressionIR-ge
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | b $bin_ge(value_l, value_r) as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:139.1-143.68
  rulegroup binaryExpressionIR-lt
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l < typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `<`
   paths
  {
    rulepath binaryExpressionIR-lt
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | b $bin_lt(value_l, value_r) as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:145.1-149.68
  rulegroup binaryExpressionIR-gt
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l > typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `>`
   paths
  {
    rulepath binaryExpressionIR-gt
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | b $bin_gt(value_l, value_r) as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:151.1-155.68
  rulegroup binaryExpressionIR-ne
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l != typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `!=`
   paths
  {
    rulepath binaryExpressionIR-ne
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | b $bin_ne(value_l, value_r) as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:157.1-161.68
  rulegroup binaryExpressionIR-eq
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l == typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `==`
   paths
  {
    rulepath binaryExpressionIR-eq
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | b $bin_eq(value_l, value_r) as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:163.1-167.68
  rulegroup binaryExpressionIR-band
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l & typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `&`
   paths
  {
    rulepath binaryExpressionIR-band
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_band(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:169.1-173.68
  rulegroup binaryExpressionIR-bxor
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l ^ typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `^`
   paths
  {
    rulepath binaryExpressionIR-bxor
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_bxor(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:175.1-179.68
  rulegroup binaryExpressionIR-bor
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l | typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `|`
   paths
  {
    rulepath binaryExpressionIR-bor
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_bor(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:181.1-185.68
  rulegroup binaryExpressionIR-concat
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l ++ typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `++`
   paths
  {
    rulepath binaryExpressionIR-concat
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_concat(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:187.1-191.68
  rulegroup binaryExpressionIR-land
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l && typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `&&`
   paths
  {
    rulepath binaryExpressionIR-land
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_land(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:193.1-197.68
  rulegroup binaryExpressionIR-lor
   match
    (expl-input) p | Ci | sto | typedExpressionIR_l || typedExpressionIR_r as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `||`
   paths
  {
    rulepath binaryExpressionIR-lor
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r
    (output) sto_2 | $bin_lor(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:203.1-207.71
  rulegroup ternaryExpressionIR-then
   match
    (expl-input) p | Ci | sto | typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: ternaryExpressionIR
    -- let typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e = expressionIR as ternaryExpressionIR
   paths
  {
    rulepath ternaryExpressionIR-then
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_c ==> sto_1 value
    -- if (value = b true as value)
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_t ==> sto_2 value_true
    (output) sto_2 | value_true
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:209.1-213.72
  rulegroup ternaryExpressionIR-else
   match
    (expl-input) p | Ci | sto | typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: ternaryExpressionIR
    -- let typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e = expressionIR as ternaryExpressionIR
   paths
  {
    rulepath ternaryExpressionIR-else
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_c ==> sto_1 value
    -- if (value = b false as value)
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_e ==> sto_2 value_false
    (output) sto_2 | value_false
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:218.1-221.45
  rulegroup castExpressionIR
   match
    (expl-input) p | Ci | sto | ( typeIR ) typedExpressionIR as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: castExpressionIR
    -- let ( typeIR ) typedExpressionIR = expressionIR as castExpressionIR
   paths
  {
    rulepath castExpressionIR
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value
    -- let value_cast = $cast_op(typeIR, value)
    (output) sto_1 | value_cast
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:228.1-229.37
  rulegroup dataExpressionIR-invalid
   match
    (expl-input) p | Ci | sto | {#} as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if (expressionIR = {#} as expressionIR)
   paths
  {
    rulepath dataExpressionIR-invalid
    (premises)
    (output) sto | {#} as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:233.1-236.68
  rulegroup dataExpressionIR-sequence
   match
    (expl-input) p | Ci | sto | seq{ typedExpressionListIR } as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
    -- if dataExpressionIR matches `SEQ{%}`
    -- let seq{ typedExpressionListIR } = dataExpressionIR
   paths
  {
    rulepath dataExpressionIR-sequence
    (premises)
    -- Exprs_inst: p Ci sto |- typedExpressionListIR ==> sto_1 value*{value <- value*}
    (output) sto_1 | seq( value*{value <- value*} ) as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:240.1-243.68
  rulegroup dataExpressionIR-sequence-default
   match
    (expl-input) p | Ci | sto | seq{ typedExpressionListIR ,...} as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
    -- if dataExpressionIR matches `SEQ{%,...}`
    -- let seq{ typedExpressionListIR ,...} = dataExpressionIR
   paths
  {
    rulepath dataExpressionIR-sequence-default
    (premises)
    -- Exprs_inst: p Ci sto |- typedExpressionListIR ==> sto_1 value*{value <- value*}
    (output) sto_1 | seq( value*{value <- value*} ,...) as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:247.1-250.65
  rulegroup dataExpressionIR-record
   match
    (expl-input) p | Ci | sto | record{ nameIR = typedExpressionIR*{} } as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
    -- if dataExpressionIR matches `RECORD{%}`
    -- let record{ nameIR = typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} } = dataExpressionIR
   paths
  {
    rulepath dataExpressionIR-record
    (premises)
    -- Exprs_inst: p Ci sto |- typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ==> sto_1 value*{value <- value*}
    (output) sto_1 | record{ value nameIR ;*{nameIR <- nameIR*, value <- value*} } as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:254.1-257.65
  rulegroup dataExpressionIR-record-default
   match
    (expl-input) p | Ci | sto | record{ nameIR = typedExpressionIR*{} ,...} as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
    -- if dataExpressionIR matches `RECORD{%,...}`
    -- let record{ nameIR = typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} ,...} = dataExpressionIR
   paths
  {
    rulepath dataExpressionIR-record-default
    (premises)
    -- Exprs_inst: p Ci sto |- typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ==> sto_1 value*{value <- value*}
    (output) sto_1 | record{ value nameIR ;*{nameIR <- nameIR*, value <- value*} ,...} as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:265.1-268.63
  rulegroup accessExpressionIR-errorAccessExpressionIR
   match
    (expl-input) p | Ci | sto | error. nameIR as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: errorAccessExpressionIR
    -- let error. nameIR = expressionIR as errorAccessExpressionIR
   paths
  {
    rulepath accessExpressionIR-errorAccessExpressionIR
    (premises)
    -- let nameIR_error = "error." ++ nameIR
    -- let value_error = $find_value_inst(p, Ci, ` nameIR_error)
    (output) sto | value_error
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:276.1-279.68
  rulegroup accessExpressionIR-memberAccessExpressionIR-typeaccess-enum
   match
    (expl-input) p | Ci | sto | type prefixedNameIR . nameIR as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR matches `TYPE%`
    -- let type prefixedNameIR = memberAccessBaseIR
   paths
  {
    rulepath accessExpressionIR-memberAccessExpressionIR-typeaccess-enum
    (premises)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(p, Ci, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: enumTypeIR
    -- let enumTypeIR = typeDefIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%{%}`
    -- let enum tid { _id*{_id <- _id*} } = enumTypeIR
    (output) sto | tid . nameIR as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:281.1-286.75
  rulegroup accessExpressionIR-memberAccessExpressionIR-typeaccess-senum
   match
    (expl-input) p | Ci | sto | type prefixedNameIR . nameIR as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR matches `TYPE%`
    -- let type prefixedNameIR = memberAccessBaseIR
   paths
  {
    rulepath accessExpressionIR-memberAccessExpressionIR-typeaccess-senum
    (premises)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(p, Ci, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: enumTypeIR
    -- let enumTypeIR = typeDefIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum tid # _typeIR { id_member = value_member ;*{id_member <- id_member*, value_member <- value_member*} } = enumTypeIR
    -- let value'?{value' <- value'?} = $assoc_<nameIR, value>(nameIR, (id_member, value_member)*{id_member <- id_member*, value_member <- value_member*})
    -- if value'?{value' <- value'?} matches (_)
    -- let ?(value) = value'?{value' <- value'?}
    (output) sto | tid . nameIR # value as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:290.1-294.40
  rulegroup accessExpressionIR-memberAccessExpressionIR-typedExpressionIR
   match
    (expl-input) p | Ci | sto | typedExpressionIR as memberAccessBaseIR . "size" as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . text = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR <: typedExpressionIR
    -- let typedExpressionIR = memberAccessBaseIR as typedExpressionIR
    -- if (text = "size")
   paths
  {
    rulepath accessExpressionIR-memberAccessExpressionIR-typedExpressionIR
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value
    -- let value' = value
    -- if value' <: headerStackValue
    -- let [ _value*{_value <- _value*} #( _nat ; n_size )] = value' as headerStackValue
    (output) sto_1 | d n_size as int as value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:304.1-309.68
  rulegroup indexAccessExpressionIR-bitslice
   match
    (expl-input) p | Ci | sto | typedExpressionIR_b [ typedExpressionIR_l : typedExpressionIR_h ] as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: indexAccessExpressionIR
    -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
    -- if indexAccessExpressionIR matches `%[%:%]`
    -- let typedExpressionIR_b [ typedExpressionIR_l : typedExpressionIR_h ] = indexAccessExpressionIR
   paths
  {
    rulepath indexAccessExpressionIR-bitslice
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR_b ==> sto_1 value_b
    -- Expr_inst: p Ci sto_1 |- typedExpressionIR_l ==> sto_2 value_l
    -- Expr_inst: p Ci sto_2 |- typedExpressionIR_h ==> sto_3 value_h
    (output) sto_3 | $bitacc_op(value_b, value_l, value_h)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:316.1-326.25
  rulegroup callExpressionIR-instantiation
   match
    (expl-input) p | Ci | sto | prefixedNameIR < typeArgumentListIR > ( argumentListIR ) as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%(%)`
    -- let prefixedNameIR < typeArgumentListIR > ( argumentListIR ) = callExpressionIR
   paths
  {
    rulepath callExpressionIR-instantiation
    (premises)
    -- let (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci, prefixedNameIR, argumentListIR)
    -- if (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} matches (_)
    -- let ?((_cid, consDyn, id_default*{id_default <- id_default*})) = (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?}
    -- Constructor_inst: p Ci sto |- consDyn < typeArgumentListIR >( argumentListIR # id_default*{id_default <- id_default*} )==> sto_1 objDyn
    -- let oid = Ci.path
    -- let sto_2 = $add_sto(sto_1, oid, objDyn)
    -- let value = ! oid as value
    (output) sto_2 | value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:337.1-341.91
  rulegroup callExpressionIR-methodTarget-generic
   match
    (expl-input) p | Ci | sto | typedExpressionIR . nameIR < [] >( [] ) as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%<%>(%)`
    -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
   paths
  {
    rulepath callExpressionIR-methodTarget-generic
    (premises)
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR
    -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
    (output) sto | $sizeof(typeIR_base, nameIR)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:345.1-349.64
  rulegroup callExpressionIR-methodTarget-non-generic
   match
    (expl-input) p | Ci | sto | type prefixedNameIR . nameIR < [] >( [] ) as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%<%>(%)`
    -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if routineTargetIR matches `TYPE%.%`
    -- let type prefixedNameIR . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
   paths
  {
    rulepath callExpressionIR-methodTarget-non-generic
    (premises)
    -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(p, Ci, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR_base = typeDefIR as typeIR
    (output) sto | $sizeof(typeIR_base, nameIR)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:353.1-360.32
  rulegroup callExpressionIR-methodTarget-routine
   match
    (expl-input) p | Ci | sto | ( routineTargetIR ) < typeArgumentListIR >( argumentListIR ) as expressionIR # expressionNoteIR
    (impl-input) p | Ci | sto | expressionIR # expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%<%>(%)`
    -- let routineTargetIR' < typeArgumentListIR >( argumentListIR ) = callExpressionIR
    -- if routineTargetIR' matches `(%)`
    -- let ( routineTargetIR ) = routineTargetIR'
   paths
  {
    rulepath callExpressionIR-methodTarget-routine
    (premises)
    -- Expr_inst: p Ci sto |- routineTargetIR < typeArgumentListIR >( argumentListIR ) as expressionIR # expressionNoteIR ==> sto_1 value
    (output) sto_1 | value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:365.1-367.64
  rulegroup parenthesizedExpressionIR
   match
    (expl-input) p | Ci | sto_0 | ( typedExpressionIR ) as expressionIR # _expressionNoteIR
    (impl-input) p | Ci | sto_0 | expressionIR # _expressionNoteIR
    (impl-input-premises)
    -- if expressionIR <: parenthesizedExpressionIR
    -- let ( typedExpressionIR ) = expressionIR as parenthesizedExpressionIR
   paths
  {
    rulepath parenthesizedExpressionIR
    (premises)
    -- Expr_inst: p Ci sto_0 |- typedExpressionIR ==> sto_1 value
    (output) sto_1 | value
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:36.1-38.26
relation Exprs_inst: cursor contextInst sto |- typedExpressionIR* ==> sto value*
  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:375.1-376.30
  rulegroup nil
   match
    (expl-input) p | Ci | sto | []
    (impl-input) p | Ci | sto | typedExpressionIR*{typedExpressionIR <- typedExpressionIR*}
    (impl-input-premises)
    -- if typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) sto | []
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:378.1-382.71
  rulegroup cons
   match
    (expl-input) p | Ci | sto_0 | typedExpressionIR_h :: typedExpressionIR_t*{}
    (impl-input) p | Ci | sto_0 | typedExpressionIR*{typedExpressionIR <- typedExpressionIR*}
    (impl-input-premises)
    -- if typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} matches _ :: _
    -- let typedExpressionIR_h :: typedExpressionIR_t*{typedExpressionIR_t <- typedExpressionIR_t*} = typedExpressionIR*{typedExpressionIR <- typedExpressionIR*}
   paths
  {
    rulepath cons
    (premises)
    -- Expr_inst: p Ci sto_0 |- typedExpressionIR_h ==> sto_1 value_h
    -- Exprs_inst: p Ci sto_1 |- typedExpressionIR_t*{typedExpressionIR_t <- typedExpressionIR_t*} ==> sto_2 value_t*{value_t <- value_t*}
    (output) sto_2 | value_h :: value_t*{value_t <- value_t*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:44.1-46.26
relation Argument_inst: cursor contextInst sto |- argumentIR ==> sto value
  ;; ../../../../spec-concrete/6.06-instantiation-argument.watsup:9.1-11.62
  rulegroup expression
   match
    (expl-input) p | Ci | sto | typedExpressionIR as argumentIR
    (impl-input) p | Ci | sto | argumentIR
    (impl-input-premises)
    -- if argumentIR <: typedExpressionIR
    -- let typedExpressionIR = argumentIR as typedExpressionIR
   paths
  {
    rulepath expression
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value
    (output) sto_1 | value
  }

  ;; ../../../../spec-concrete/6.06-instantiation-argument.watsup:15.1-17.62
  rulegroup namedexpression
   match
    (expl-input) p | Ci | sto | nameIR = typedExpressionIR
    (impl-input) p | Ci | sto | argumentIR
    (impl-input-premises)
    -- if argumentIR matches `%=%`
    -- let nameIR = typedExpressionIR = argumentIR
   paths
  {
    rulepath namedexpression
    (premises)
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value
    (output) sto_1 | value
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:52.1-54.26
relation Stmt_inst: cursor contextInst sto |- statementIR ==> contextInst sto statementIR
  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:9.1-10.59
  rulegroup emptyStatementIR
   match
    (expl-input) p | Ci | sto | emptyStatementIR as statementIR
    (impl-input) p | Ci | sto | statementIR
    (impl-input-premises)
    -- if statementIR <: emptyStatementIR
    -- let emptyStatementIR = statementIR as emptyStatementIR
   paths
  {
    rulepath emptyStatementIR
    (premises)
    (output) Ci | sto | emptyStatementIR as statementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:14.1-15.69
  rulegroup assignmentStatementIR
   match
    (expl-input) p | Ci | sto | assignmentStatementIR as statementIR
    (impl-input) p | Ci | sto | statementIR
    (impl-input-premises)
    -- if statementIR <: assignmentStatementIR
    -- let assignmentStatementIR = statementIR as assignmentStatementIR
   paths
  {
    rulepath assignmentStatementIR
    (premises)
    (output) Ci | sto | assignmentStatementIR as statementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:21.1-22.57
  rulegroup callStatementIR
   match
    (expl-input) p | Ci | sto | callStatementIR as statementIR
    (impl-input) p | Ci | sto | statementIR
    (impl-input-premises)
    -- if statementIR <: callStatementIR
    -- let callStatementIR = statementIR as callStatementIR
   paths
  {
    rulepath callStatementIR
    (premises)
    (output) Ci | sto | callStatementIR as statementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:28.1-46.82
  rulegroup directApplicationStatementIR
   match
    (expl-input) p | Ci | sto_0 | prefixedNameIR .apply( argumentListIR ); as statementIR
    (impl-input) p | Ci | sto_0 | statementIR
    (impl-input-premises)
    -- if statementIR <: directApplicationStatementIR
    -- let prefixedNameIR .apply( argumentListIR ); = statementIR as directApplicationStatementIR
   paths
  {
    rulepath directApplicationStatementIR
    (premises)
    -- let (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci, prefixedNameIR, [])
    -- if (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} matches (_)
    -- let ?((_cid, consDyn, _id*{_id <- _id*})) = (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?}
    -- Constructor_inst: p Ci sto_0 |- consDyn < [] >( [] # [] )==> sto_1 objDyn
    -- let tid_fresh = $fresh_tid
    -- let tid = $flatten_prefixedNameIR(prefixedNameIR)
    -- let typeIR = tid tid as typeIR
    -- let nameIR = $concat_text([tid, "_", tid_fresh])
    -- let oid = Ci.path ++ [nameIR]
    -- let sto_2 = $add_sto(sto_1, oid, objDyn)
    -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;
    -- let routineTargetIR = ` tid as expressionIR # ( typeIR ctk ) . "apply"
    -- let callStatementIR = routineTargetIR < [] >( argumentListIR );
    -- let blockStatementIR = { [constantDeclarationIR as blockElementStatementIR, callStatementIR as blockElementStatementIR] }
    (output) Ci | sto_2 | blockStatementIR as statementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:50.1-51.61
  rulegroup returnStatementIR
   match
    (expl-input) p | Ci | sto | returnStatementIR as statementIR
    (impl-input) p | Ci | sto | statementIR
    (impl-input-premises)
    -- if statementIR <: returnStatementIR
    -- let returnStatementIR = statementIR as returnStatementIR
   paths
  {
    rulepath returnStatementIR
    (premises)
    (output) Ci | sto | returnStatementIR as statementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:55.1-56.57
  rulegroup exitStatementIR
   match
    (expl-input) p | Ci | sto | exitStatementIR as statementIR
    (impl-input) p | Ci | sto | statementIR
    (impl-input-premises)
    -- if statementIR <: exitStatementIR
    -- let exitStatementIR = statementIR as exitStatementIR
   paths
  {
    rulepath exitStatementIR
    (premises)
    (output) Ci | sto | exitStatementIR as statementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:61.1-64.130
  rulegroup blockStatementIR
   match
    (expl-input) p | Ci | sto | annotationList { blockElementStatementListIR } as statementIR
    (impl-input) p | Ci | sto | statementIR
    (impl-input-premises)
    -- if statementIR <: blockStatementIR
    -- let annotationList { blockElementStatementListIR } = statementIR as blockStatementIR
   paths
  {
    rulepath blockStatementIR
    (premises)
    -- Block_inst: p Ci sto |- annotationList { blockElementStatementListIR } ==> Ci_1 sto_1 _annotationList { blockElementStatementListIR' }
    (output) Ci_1 | sto_1 | annotationList { blockElementStatementListIR' } as statementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:71.1-74.68
  rulegroup conditionalStatementIR-non-else
   match
    (expl-input) p | Ci | sto | if( typedExpressionIR ) statementIR as statementIR
    (impl-input) p | Ci | sto | statementIR''
    (impl-input-premises)
    -- if statementIR'' <: conditionalStatementIR
    -- let conditionalStatementIR = statementIR'' as conditionalStatementIR
    -- if conditionalStatementIR matches `IF(%)%`
    -- let if( typedExpressionIR ) statementIR = conditionalStatementIR
   paths
  {
    rulepath conditionalStatementIR-non-else
    (premises)
    -- Stmt_inst: p Ci sto |- statementIR ==> Ci_1 sto_1 statementIR'
    (output) Ci_1 | sto_1 | if( typedExpressionIR ) statementIR' as statementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:78.1-84.82
  rulegroup conditionalStatementIR-else
   match
    (expl-input) p | Ci | sto | if( typedExpressionIR ) statementIR_then else statementIR_else as statementIR
    (impl-input) p | Ci | sto | statementIR
    (impl-input-premises)
    -- if statementIR <: conditionalStatementIR
    -- let conditionalStatementIR = statementIR as conditionalStatementIR
    -- if conditionalStatementIR matches `IF(%)%ELSE%`
    -- let if( typedExpressionIR ) statementIR_then else statementIR_else = conditionalStatementIR
   paths
  {
    rulepath conditionalStatementIR-else
    (premises)
    -- Stmt_inst: p Ci sto |- statementIR_then ==> Ci_1 sto_1 statementIR_then'
    -- Stmt_inst: p Ci_1 sto_1 |- statementIR_else ==> Ci_2 sto_2 statementIR_else'
    (output) Ci_2 | sto_2 | if( typedExpressionIR ) statementIR_then' else statementIR_else' as statementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:90.1-91.59
  rulegroup breakStatementIR
   match
    (expl-input) p | Ci | sto | breakStatementIR as statementIR
    (impl-input) p | Ci | sto | statementIR
    (impl-input-premises)
    -- if statementIR <: breakStatementIR
    -- let breakStatementIR = statementIR as breakStatementIR
   paths
  {
    rulepath breakStatementIR
    (premises)
    (output) Ci | sto | breakStatementIR as statementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:95.1-96.65
  rulegroup continueStatementIR
   match
    (expl-input) p | Ci | sto | continueStatementIR as statementIR
    (impl-input) p | Ci | sto | statementIR
    (impl-input-premises)
    -- if statementIR <: continueStatementIR
    -- let continueStatementIR = statementIR as continueStatementIR
   paths
  {
    rulepath continueStatementIR
    (premises)
    (output) Ci | sto | continueStatementIR as statementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:101.1-105.85
  rulegroup switchStatementIR
   match
    (expl-input) p | Ci | sto | switch( typedExpressionIR ){ switchCaseListIR } as statementIR
    (impl-input) p | Ci | sto | statementIR
    (impl-input-premises)
    -- if statementIR <: switchStatementIR
    -- let switch( typedExpressionIR ){ switchCaseListIR } = statementIR as switchStatementIR
   paths
  {
    rulepath switchStatementIR
    (premises)
    -- SwitchCases_inst: p Ci sto |- switchCaseListIR ==> Ci_1 sto_1 switchCaseListIR'
    (output) Ci_1 | sto_1 | switch( typedExpressionIR ){ switchCaseListIR' } as statementIR
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:56.1-58.26
relation Stmts_inst: cursor contextInst sto |- statementIR* ==> contextInst sto statementIR*


;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:60.1-62.26
relation SwitchCases_inst: cursor contextInst sto |- switchCaseIR* ==> contextInst sto switchCaseIR*
  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:124.1-125.33
  rulegroup nil
   match
    (expl-input) p | Ci | sto | []
    (impl-input) p | Ci | sto | switchCaseIR*{switchCaseIR <- switchCaseIR*}
    (impl-input-premises)
    -- if switchCaseIR*{switchCaseIR <- switchCaseIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) Ci | sto | []
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:127.1-131.87
  rulegroup cons
   match
    (expl-input) p | Ci_0 | sto_0 | switchCaseIR_h :: switchCaseIR_t*{}
    (impl-input) p | Ci_0 | sto_0 | switchCaseIR*{switchCaseIR <- switchCaseIR*}
    (impl-input-premises)
    -- if switchCaseIR*{switchCaseIR <- switchCaseIR*} matches _ :: _
    -- let switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} = switchCaseIR*{switchCaseIR <- switchCaseIR*}
   paths
  {
    rulepath cons
    (premises)
    -- SwitchCase_inst: p Ci_0 sto_0 |- switchCaseIR_h ==> Ci_1 sto_1 switchCaseIR_h'
    -- SwitchCases_inst: p Ci_1 sto_1 |- switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} ==> Ci_2 sto_2 switchCaseIR_t'*{switchCaseIR_t' <- switchCaseIR_t'*}
    (output) Ci_2 | sto_2 | switchCaseIR_h' :: switchCaseIR_t'*{switchCaseIR_t' <- switchCaseIR_t'*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:64.1-66.26
relation SwitchCase_inst: cursor contextInst sto |- switchCaseIR ==> contextInst sto switchCaseIR
  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:115.1-117.78
  rulegroup match
   match
    (expl-input) p | Ci | sto | switchLabelIR : blockStatementIR
    (impl-input) p | Ci | sto | switchCaseIR
    (impl-input-premises)
    -- if switchCaseIR matches `%:%`
    -- let switchLabelIR : blockStatementIR = switchCaseIR
   paths
  {
    rulepath match
    (premises)
    -- Stmt_inst: p Ci sto |- blockStatementIR as statementIR ==> Ci_1 sto_1 statementIR
    -- if statementIR <: blockStatementIR
    -- let blockStatementIR' = statementIR as blockStatementIR
    (output) Ci_1 | sto_1 | switchLabelIR : blockStatementIR'
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:121.1-122.61
  rulegroup fallthrough
   match
    (expl-input) p | Ci | sto | switchLabelIR :
    (impl-input) p | Ci | sto | switchCaseIR
    (impl-input-premises)
    -- if switchCaseIR matches `%:`
    -- let switchLabelIR : = switchCaseIR
   paths
  {
    rulepath fallthrough
    (premises)
    (output) Ci | sto | switchLabelIR :
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:68.1-70.26
relation BlockElementStmt_inst: cursor contextInst sto |- blockElementStatementIR ==> contextInst sto blockElementStatementIR?
  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:139.1-141.88
  rulegroup constantDeclarationIR
   match
    (expl-input) p | Ci | sto | constantDeclarationIR as blockElementStatementIR
    (impl-input) p | Ci | sto | blockElementStatementIR
    (impl-input-premises)
    -- if blockElementStatementIR <: constantDeclarationIR
    -- let constantDeclarationIR = blockElementStatementIR as constantDeclarationIR
   paths
  {
    rulepath constantDeclarationIR
    (premises)
    -- Decl_inst: p Ci sto |- constantDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR'?{declarationIR' <- declarationIR'?}
    -- if declarationIR'?{declarationIR' <- declarationIR'?} matches (_)
    -- let ?(declarationIR) = declarationIR'?{declarationIR' <- declarationIR'?}
    -- if declarationIR <: constantDeclarationIR
    -- let constantDeclarationIR' = declarationIR as constantDeclarationIR
    (output) Ci_1 | sto_1 | ?(constantDeclarationIR' as blockElementStatementIR)
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:145.1-146.56
  rulegroup variableDeclarationIR-global
   match
    (expl-input) global | Ci | sto | variableDeclarationIR as blockElementStatementIR
    (impl-input) cursor | Ci | sto | blockElementStatementIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if blockElementStatementIR <: variableDeclarationIR
    -- let variableDeclarationIR = blockElementStatementIR as variableDeclarationIR
   paths
  {
    rulepath variableDeclarationIR-global
    (premises)
    (output) Ci | sto | ?()
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:148.1-150.21
  rulegroup variableDeclarationIR-non-global
   match
    (expl-input) p | Ci | sto | variableDeclarationIR as blockElementStatementIR
    (impl-input) p | Ci | sto | blockElementStatementIR
    (impl-input-premises)
    -- if blockElementStatementIR <: variableDeclarationIR
    -- let variableDeclarationIR = blockElementStatementIR as variableDeclarationIR
   paths
  {
    rulepath variableDeclarationIR-non-global
    (premises)
    -- if (p =/= global)
    (output) Ci | sto | ?(variableDeclarationIR as blockElementStatementIR)
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:154.1-156.76
  rulegroup statementIR
   match
    (expl-input) p | Ci | sto | statementIR as blockElementStatementIR
    (impl-input) p | Ci | sto | blockElementStatementIR
    (impl-input-premises)
    -- if blockElementStatementIR <: statementIR
    -- let statementIR = blockElementStatementIR as statementIR
   paths
  {
    rulepath statementIR
    (premises)
    -- Stmt_inst: local Ci sto |- statementIR ==> Ci_1 sto_1 statementIR_inst
    (output) Ci_1 | sto_1 | ?(statementIR_inst as blockElementStatementIR)
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:72.1-74.26
relation BlockElementStmts_inst: cursor contextInst sto |- blockElementStatementIR* ==> contextInst sto blockElementStatementIR*
  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:158.1-159.33
  rulegroup nil
   match
    (expl-input) p | Ci | sto | []
    (impl-input) p | Ci | sto | blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*}
    (impl-input-premises)
    -- if blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) Ci | sto | []
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:161.1-165.115
  rulegroup cons
   match
    (expl-input) p | Ci_0 | sto_0 | blockElementStatementIR_h :: blockElementStatementIR_t*{}
    (impl-input) p | Ci_0 | sto_0 | blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*}
    (impl-input-premises)
    -- if blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} matches _ :: _
    -- let blockElementStatementIR_h :: blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*} = blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*}
   paths
  {
    rulepath cons
    (premises)
    -- BlockElementStmt_inst: p Ci_0 sto_0 |- blockElementStatementIR_h ==> Ci_1 sto_1 blockElementStatementIR'?{blockElementStatementIR' <- blockElementStatementIR'?}
    -- if blockElementStatementIR'?{blockElementStatementIR' <- blockElementStatementIR'?} matches (_)
    -- let ?(blockElementStatementIR_h') = blockElementStatementIR'?{blockElementStatementIR' <- blockElementStatementIR'?}
    -- BlockElementStmts_inst: p Ci_1 sto_1 |- blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*} ==> Ci_2 sto_2 blockElementStatementIR_t'*{blockElementStatementIR_t' <- blockElementStatementIR_t'*}
    (output) Ci_2 | sto_2 | blockElementStatementIR_h' :: blockElementStatementIR_t'*{blockElementStatementIR_t' <- blockElementStatementIR_t'*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:76.1-78.26
relation Block_inst: cursor contextInst sto |- blockStatementIR ==> contextInst sto blockStatementIR
  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:174.1-179.32
  rulegroup 
   match
    (expl-input) p | Ci_0 | sto_0 | annotationList { blockElementStatementListIR }
    (impl-input) p | Ci_0 | sto_0 | annotationList { blockElementStatementListIR }
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let Ci_1 = $enter_inst(Ci_0)
    -- BlockElementStmts_inst: p Ci_1 sto_0 |- blockElementStatementListIR ==> Ci_2 sto_1 blockElementStatementListIR_inst
    -- let Ci_3 = $exit_inst(Ci_2)
    (output) Ci_2 | sto_1 | annotationList { blockElementStatementListIR_inst }
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:84.1-86.20
relation Bind_method: rdenv |- methodPrototypeIR ==> rdenv
  ;; ../../../../spec-concrete/6.09-instantiation-extern-method.watsup:9.1-22.18
  rulegroup non-abstract
   match
    (expl-input) rdenv_0 | _annotationList typeIR_ret nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{} ) ;
    (impl-input) rdenv_0 | methodPrototypeIR
    (impl-input-premises)
    -- if methodPrototypeIR matches `%%;`
    -- let _annotationList typeIR_ret nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ) ; = methodPrototypeIR
   paths
  {
    rulepath non-abstract
    (premises)
    -- let rid = $rid_IR(nameIR, parameterIR*{parameterIR <- parameterIR*})
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let methodTypeIR = extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
    -- let routineTypeDefIR = methodTypeIR as routineTypeIR < typeParameterListIR , typeParameterListIR_inferred > as routineTypeDefIR
    -- let rdenv_1 = $add_map<rid, routineTypeDefIR>(rdenv_0, rid, routineTypeDefIR)
    (output) rdenv_1
  }

  ;; ../../../../spec-concrete/6.09-instantiation-extern-method.watsup:24.1-37.18
  rulegroup abstract
   match
    (expl-input) rdenv_0 | _annotationList abstract typeIR_ret nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{} ) ;
    (impl-input) rdenv_0 | methodPrototypeIR
    (impl-input-premises)
    -- if methodPrototypeIR matches `%ABSTRACT%;`
    -- let _annotationList abstract typeIR_ret nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ) ; = methodPrototypeIR
   paths
  {
    rulepath abstract
    (premises)
    -- let rid = $rid_IR(nameIR, parameterIR*{parameterIR <- parameterIR*})
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let methodTypeIR = extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
    -- let routineTypeDefIR = methodTypeIR as routineTypeIR < typeParameterListIR , typeParameterListIR_inferred > as routineTypeDefIR
    -- let rdenv_1 = $add_map<rid, routineTypeDefIR>(rdenv_0, rid, routineTypeDefIR)
    (output) rdenv_1
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:88.1-90.20
relation Bind_methods: rdenv |- methodPrototypeIR* ==> rdenv
  ;; ../../../../spec-concrete/6.09-instantiation-extern-method.watsup:39.1-40.25
  rulegroup nil
   match
    (expl-input) rdenv | []
    (impl-input) rdenv | methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
    (impl-input-premises)
    -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) rdenv
  }

  ;; ../../../../spec-concrete/6.09-instantiation-extern-method.watsup:42.1-45.63
  rulegroup cons
   match
    (expl-input) rdenv_0 | methodPrototypeIR_h :: methodPrototypeIR_t*{}
    (impl-input) rdenv_0 | methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
    (impl-input-premises)
    -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches _ :: _
    -- let methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} = methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
   paths
  {
    rulepath cons
    (premises)
    -- Bind_method: rdenv_0 |- methodPrototypeIR_h ==> rdenv_1
    -- Bind_methods: rdenv_1 |- methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} ==> rdenv_2
    (output) rdenv_2
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:92.1-94.29
relation Bind_constructor: cursor contextInst typeParameterListIR methodPrototypeListIR |- methodPrototypeIR ==> contextInst
  ;; ../../../../spec-concrete/6.09-instantiation-extern-method.watsup:47.1-56.60
  rulegroup constructor
   match
    (expl-input) p | Ci_0 | typeParameterListIR | methodPrototypeListIR | annotationList nameIR <, typeParameterListIR_inferred >( parameterListIR );
    (impl-input) p | Ci_0 | typeParameterListIR | methodPrototypeListIR | methodPrototypeIR
    (impl-input-premises)
    -- if methodPrototypeIR matches `%%<,%>(%);`
    -- let annotationList nameIR <, typeParameterListIR_inferred >( parameterListIR ); = methodPrototypeIR
   paths
  {
    rulepath constructor
    (premises)
    -- let cid = $cid_IR(nameIR, parameterListIR)
    -- let consDyn = extern nameIR < typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ){ methodPrototypeListIR }
    -- let Ci_1 = $add_constructor_inst(p, Ci_0, cid, consDyn)
    (output) Ci_1
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:96.1-98.29
relation Bind_constructors: cursor contextInst typeParameterListIR methodPrototypeListIR |- methodPrototypeIR* ==> contextInst
  ;; ../../../../spec-concrete/6.09-instantiation-extern-method.watsup:58.1-59.63
  rulegroup nil
   match
    (expl-input) p | Ci | typeParameterListIR | methodPrototypeListIR | []
    (impl-input) p | Ci | typeParameterListIR | methodPrototypeListIR | methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
    (impl-input-premises)
    -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) Ci
  }

  ;; ../../../../spec-concrete/6.09-instantiation-extern-method.watsup:61.1-65.106
  rulegroup cons
   match
    (expl-input) p | Ci_0 | typeParameterListIR | methodPrototypeListIR | methodPrototypeIR_h :: methodPrototypeIR_t*{}
    (impl-input) p | Ci_0 | typeParameterListIR | methodPrototypeListIR | methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
    (impl-input-premises)
    -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches _ :: _
    -- let methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} = methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
   paths
  {
    rulepath cons
    (premises)
    -- Bind_constructor: p Ci_0 typeParameterListIR methodPrototypeListIR |- methodPrototypeIR_h ==> Ci_1
    -- Bind_constructors: p Ci_1 typeParameterListIR methodPrototypeListIR |- methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} ==> Ci_2
    (output) Ci_2
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:100.1-102.20
relation ExternMethod_inst: contextInst |- methodPrototypeIR ==> contextInst
  ;; ../../../../spec-concrete/6.09-instantiation-extern-method.watsup:67.1-77.73
  rulegroup non-abstract
   match
    (expl-input) Ci_0 | _annotationList _typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) ;
    (impl-input) Ci_0 | methodPrototypeIR
    (impl-input-premises)
    -- if methodPrototypeIR matches `%%;`
    -- let _annotationList _typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) ; = methodPrototypeIR
   paths
  {
    rulepath non-abstract
    (premises)
    -- let rid = $rid_IR(nameIR, parameterListIR)
    -- let methodDyn = extern_method< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ) ?()
    -- let Ci_1 = $add_routine_overload_inst(block, Ci_0, rid, methodDyn as routineDyn)
    (output) Ci_1
  }

  ;; ../../../../spec-concrete/6.09-instantiation-extern-method.watsup:79.1-90.73
  rulegroup abstract
   match
    (expl-input) Ci_0 | _annotationList abstract _typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) ;
    (impl-input) Ci_0 | methodPrototypeIR
    (impl-input-premises)
    -- if methodPrototypeIR matches `%ABSTRACT%;`
    -- let _annotationList abstract _typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) ; = methodPrototypeIR
   paths
  {
    rulepath abstract
    (premises)
    -- let rid = $rid_IR(nameIR, parameterListIR)
    -- let methodDyn = extern_methodabstract< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR )
    -- let Ci_1 = $add_routine_overload_inst(block, Ci_0, rid, methodDyn as routineDyn)
    (output) Ci_1
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:104.1-106.20
relation ExternMethods_inst: contextInst |- methodPrototypeIR* ==> contextInst
  ;; ../../../../spec-concrete/6.09-instantiation-extern-method.watsup:92.1-93.19
  rulegroup nil
   match
    (expl-input) Ci | []
    (impl-input) Ci | methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
    (impl-input-premises)
    -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) Ci
  }

  ;; ../../../../spec-concrete/6.09-instantiation-extern-method.watsup:95.1-98.63
  rulegroup cons
   match
    (expl-input) Ci_0 | methodPrototypeIR_h :: methodPrototypeIR_t*{}
    (impl-input) Ci_0 | methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
    (impl-input-premises)
    -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches _ :: _
    -- let methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} = methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
   paths
  {
    rulepath cons
    (premises)
    -- ExternMethod_inst: Ci_0 |- methodPrototypeIR_h ==> Ci_1
    -- ExternMethods_inst: Ci_1 |- methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} ==> Ci_2
    (output) Ci_2
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:112.1-114.23
relation ParserStmt_inst: contextInst sto |- parserStatementIR ==> contextInst sto parserStatementIR?
  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:9.1-11.101
  rulegroup constantDeclarationIR
   match
    (expl-input) Ci_0 | sto_0 | constantDeclarationIR as parserStatementIR
    (impl-input) Ci_0 | sto_0 | parserStatementIR
    (impl-input-premises)
    -- if parserStatementIR <: constantDeclarationIR
    -- let constantDeclarationIR = parserStatementIR as constantDeclarationIR
   paths
  {
    rulepath constantDeclarationIR
    (premises)
    -- Decl_inst: block Ci_0 sto_0 |- constantDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
    -- if declarationIR?{declarationIR <- declarationIR?} <: constantDeclarationIR?
    -- let constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as constantDeclarationIR?
    (output) Ci_1 | sto_1 | constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} as parserStatementIR?
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:15.1-17.113
  rulegroup variableDeclarationIR
   match
    (expl-input) Ci_0 | sto_0 | variableDeclarationIR as parserStatementIR
    (impl-input) Ci_0 | sto_0 | parserStatementIR
    (impl-input-premises)
    -- if parserStatementIR <: variableDeclarationIR
    -- let variableDeclarationIR = parserStatementIR as variableDeclarationIR
   paths
  {
    rulepath variableDeclarationIR
    (premises)
    -- BlockElementStmt_inst: block Ci_0 sto_0 |- variableDeclarationIR as blockElementStatementIR ==> Ci_1 sto_1 blockElementStatementIR?{blockElementStatementIR <- blockElementStatementIR?}
    -- if blockElementStatementIR?{blockElementStatementIR <- blockElementStatementIR?} <: variableDeclarationIR?
    -- let variableDeclarationIR_inst?{variableDeclarationIR_inst <- variableDeclarationIR_inst?} = blockElementStatementIR?{blockElementStatementIR <- blockElementStatementIR?} as variableDeclarationIR?
    (output) Ci_1 | sto_1 | variableDeclarationIR_inst?{variableDeclarationIR_inst <- variableDeclarationIR_inst?} as parserStatementIR?
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:21.1-23.90
  rulegroup emptyStatementIR
   match
    (expl-input) Ci_0 | sto_0 | emptyStatementIR as parserStatementIR
    (impl-input) Ci_0 | sto_0 | parserStatementIR
    (impl-input-premises)
    -- if parserStatementIR <: emptyStatementIR
    -- let emptyStatementIR = parserStatementIR as emptyStatementIR
   paths
  {
    rulepath emptyStatementIR
    (premises)
    -- Stmt_inst: block Ci_0 sto_0 |- emptyStatementIR as statementIR ==> Ci_1 sto_1 statementIR
    -- if statementIR <: emptyStatementIR
    -- let emptyStatementIR_inst = statementIR as emptyStatementIR
    (output) Ci_1 | sto_1 | ?(emptyStatementIR_inst as parserStatementIR)
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:27.1-29.100
  rulegroup assignmentStatementIR
   match
    (expl-input) Ci_0 | sto_0 | assignmentStatementIR as parserStatementIR
    (impl-input) Ci_0 | sto_0 | parserStatementIR
    (impl-input-premises)
    -- if parserStatementIR <: assignmentStatementIR
    -- let assignmentStatementIR = parserStatementIR as assignmentStatementIR
   paths
  {
    rulepath assignmentStatementIR
    (premises)
    -- Stmt_inst: block Ci_0 sto_0 |- assignmentStatementIR as statementIR ==> Ci_1 sto_1 statementIR
    -- if statementIR <: assignmentStatementIR
    -- let assignmentStatementIR_inst = statementIR as assignmentStatementIR
    (output) Ci_1 | sto_1 | ?(assignmentStatementIR_inst as parserStatementIR)
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:33.1-35.88
  rulegroup callStatementIR
   match
    (expl-input) Ci_0 | sto_0 | callStatementIR as parserStatementIR
    (impl-input) Ci_0 | sto_0 | parserStatementIR
    (impl-input-premises)
    -- if parserStatementIR <: callStatementIR
    -- let callStatementIR = parserStatementIR as callStatementIR
   paths
  {
    rulepath callStatementIR
    (premises)
    -- Stmt_inst: block Ci_0 sto_0 |- callStatementIR as statementIR ==> Ci_1 sto_1 statementIR
    -- if statementIR <: callStatementIR
    -- let callStatementIR_inst = statementIR as callStatementIR
    (output) Ci_1 | sto_1 | ?(callStatementIR_inst as parserStatementIR)
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:39.1-58.88
  rulegroup directApplicationStatementIR
   match
    (expl-input) Ci | sto_0 | prefixedNameIR .apply( argumentListIR ); as parserStatementIR
    (impl-input) Ci | sto_0 | parserStatementIR
    (impl-input-premises)
    -- if parserStatementIR <: directApplicationStatementIR
    -- let prefixedNameIR .apply( argumentListIR ); = parserStatementIR as directApplicationStatementIR
   paths
  {
    rulepath directApplicationStatementIR
    (premises)
    -- let (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci, prefixedNameIR, [])
    -- if (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} matches (_)
    -- let ?((_cid, consDyn, _id*{_id <- _id*})) = (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?}
    -- Constructor_inst: block Ci sto_0 |- consDyn < [] >( [] # [] )==> sto_1 objDyn
    -- let tid = $flatten_prefixedNameIR(prefixedNameIR)
    -- let tid_fresh = $fresh_tid
    -- let nameIR = $concat_text([tid, "_", tid_fresh])
    -- let oid = Ci.path ++ [nameIR]
    -- let sto_2 = $add_sto(sto_1, oid, objDyn)
    -- let typeIR = tid tid as typeIR
    -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;
    -- let routineTargetIR = ` tid as expressionIR # ( typeIR ctk ) . "apply"
    -- let callStatementIR = routineTargetIR < [] >( argumentListIR );
    -- let parserBlockStatementIR = { [constantDeclarationIR as parserStatementIR, callStatementIR as parserStatementIR] }
    (output) Ci | sto_2 | ?(parserBlockStatementIR as parserStatementIR)
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:62.1-68.36
  rulegroup parserBlockStatementIR
   match
    (expl-input) Ci_0 | sto_0 | annotationList { parserStatementListIR } as parserStatementIR
    (impl-input) Ci_0 | sto_0 | parserStatementIR
    (impl-input-premises)
    -- if parserStatementIR <: parserBlockStatementIR
    -- let annotationList { parserStatementListIR } = parserStatementIR as parserBlockStatementIR
   paths
  {
    rulepath parserBlockStatementIR
    (premises)
    -- ParserStmts_inst: Ci_0 sto_0 |- parserStatementListIR ==> Ci_1 sto_1 parserStatementListIR_inst
    -- let parserBlockStatementIR_inst = annotationList { parserStatementListIR_inst }
    (output) Ci_1 | sto_1 | ?(parserBlockStatementIR_inst as parserStatementIR)
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:72.1-74.102
  rulegroup conditionalStatementIR
   match
    (expl-input) Ci_0 | sto_0 | conditionalStatementIR as parserStatementIR
    (impl-input) Ci_0 | sto_0 | parserStatementIR
    (impl-input-premises)
    -- if parserStatementIR <: conditionalStatementIR
    -- let conditionalStatementIR = parserStatementIR as conditionalStatementIR
   paths
  {
    rulepath conditionalStatementIR
    (premises)
    -- Stmt_inst: block Ci_0 sto_0 |- conditionalStatementIR as statementIR ==> Ci_1 sto_1 statementIR
    -- if statementIR <: conditionalStatementIR
    -- let conditionalStatementIR_inst = statementIR as conditionalStatementIR
    (output) Ci_1 | sto_1 | ?(conditionalStatementIR_inst as parserStatementIR)
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:116.1-118.23
relation ParserStmts_inst: contextInst sto |- parserStatementIR* ==> contextInst sto parserStatementIR*
  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:82.1-83.31
  rulegroup nil
   match
    (expl-input) Ci | sto | []
    (impl-input) Ci | sto | parserStatementIR*{parserStatementIR <- parserStatementIR*}
    (impl-input-premises)
    -- if parserStatementIR*{parserStatementIR <- parserStatementIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) Ci | sto | []
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:85.1-89.95
  rulegroup cons-none
   match
    (expl-input) Ci_0 | sto_0 | parserStatementIR_h :: parserStatementIR_t*{}
    (impl-input) Ci_0 | sto_0 | parserStatementIR*{parserStatementIR <- parserStatementIR*}
    (impl-input-premises)
    -- if parserStatementIR*{parserStatementIR <- parserStatementIR*} matches _ :: _
    -- let parserStatementIR_h :: parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*} = parserStatementIR*{parserStatementIR <- parserStatementIR*}
   paths
  {
    rulepath cons-none
    (premises)
    -- ParserStmt_inst: Ci_0 sto_0 |- parserStatementIR_h ==> Ci_1 sto_1 parserStatementIR'?{parserStatementIR' <- parserStatementIR'?}
    -- if parserStatementIR'?{parserStatementIR' <- parserStatementIR'?} matches ()
    -- ParserStmts_inst: Ci_1 sto_1 |- parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*} ==> Ci_2 sto_2 parserStatementIR_t'*{parserStatementIR_t' <- parserStatementIR_t'*}
    (output) Ci_2 | sto_2 | parserStatementIR_t'*{parserStatementIR_t' <- parserStatementIR_t'*}
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:91.1-95.95
  rulegroup cons-some
   match
    (expl-input) Ci_0 | sto_0 | parserStatementIR_h :: parserStatementIR_t*{}
    (impl-input) Ci_0 | sto_0 | parserStatementIR*{parserStatementIR <- parserStatementIR*}
    (impl-input-premises)
    -- if parserStatementIR*{parserStatementIR <- parserStatementIR*} matches _ :: _
    -- let parserStatementIR_h :: parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*} = parserStatementIR*{parserStatementIR <- parserStatementIR*}
   paths
  {
    rulepath cons-some
    (premises)
    -- ParserStmt_inst: Ci_0 sto_0 |- parserStatementIR_h ==> Ci_1 sto_1 parserStatementIR'?{parserStatementIR' <- parserStatementIR'?}
    -- if parserStatementIR'?{parserStatementIR' <- parserStatementIR'?} matches (_)
    -- let ?(parserStatementIR_h') = parserStatementIR'?{parserStatementIR' <- parserStatementIR'?}
    -- ParserStmts_inst: Ci_1 sto_1 |- parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*} ==> Ci_2 sto_2 parserStatementIR_t'*{parserStatementIR_t' <- parserStatementIR_t'*}
    (output) Ci_2 | sto_2 | parserStatementIR_h' :: parserStatementIR_t'*{parserStatementIR_t' <- parserStatementIR_t'*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:120.1-122.23
relation ParserState_inst: contextInst sto |- parserStateIR ==> contextInst sto
  ;; ../../../../spec-concrete/6.10.2-instantiation-parser-state.watsup:9.1-18.62
  rulegroup 
   match
    (expl-input) Ci_0 | sto_0 | annotationList state nameIR { parserStatementListIR transitionStatementIR }
    (impl-input) Ci_0 | sto_0 | annotationList state nameIR { parserStatementListIR transitionStatementIR }
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- ParserStmts_inst: Ci_0 sto_0 |- parserStatementListIR ==> Ci_1 sto_1 parserStatementListIR_inst
    -- let stateDyn = annotationList { parserStatementListIR_inst }
    -- let Ci_2 = $add_state_inst(block, Ci_1, nameIR, stateDyn)
    (output) Ci_2 | sto_1
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:124.1-126.23
relation ParserStates_inst: contextInst sto |- parserStateIR* ==> contextInst sto
  ;; ../../../../spec-concrete/6.10.2-instantiation-parser-state.watsup:20.1-21.27
  rulegroup nil
   match
    (expl-input) Ci | sto | []
    (impl-input) Ci | sto | parserStateIR*{parserStateIR <- parserStateIR*}
    (impl-input-premises)
    -- if parserStateIR*{parserStateIR <- parserStateIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) Ci | sto
  }

  ;; ../../../../spec-concrete/6.10.2-instantiation-parser-state.watsup:23.1-27.70
  rulegroup cons
   match
    (expl-input) Ci_0 | sto_0 | parserStateIR_h :: parserStateIR_t*{}
    (impl-input) Ci_0 | sto_0 | parserStateIR*{parserStateIR <- parserStateIR*}
    (impl-input-premises)
    -- if parserStateIR*{parserStateIR <- parserStateIR*} matches _ :: _
    -- let parserStateIR_h :: parserStateIR_t*{parserStateIR_t <- parserStateIR_t*} = parserStateIR*{parserStateIR <- parserStateIR*}
   paths
  {
    rulepath cons
    (premises)
    -- ParserState_inst: Ci_0 sto_0 |- parserStateIR_h ==> Ci_1 sto_1
    -- ParserStates_inst: Ci_1 sto_1 |- parserStateIR_t*{parserStateIR_t <- parserStateIR_t*} ==> Ci_2 sto_2
    (output) Ci_2 | sto_2
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:128.1-130.23
relation ParserLocalDecl_inst: contextInst sto |- parserLocalDeclarationIR ==> contextInst sto parserLocalDeclarationIR?
  ;; ../../../../spec-concrete/6.10.3-instantiation-parser-declaration.watsup:9.1-11.101
  rulegroup constantDeclarationIR
   match
    (expl-input) Ci_0 | sto_0 | constantDeclarationIR as parserLocalDeclarationIR
    (impl-input) Ci_0 | sto_0 | parserLocalDeclarationIR
    (impl-input-premises)
    -- if parserLocalDeclarationIR <: constantDeclarationIR
    -- let constantDeclarationIR = parserLocalDeclarationIR as constantDeclarationIR
   paths
  {
    rulepath constantDeclarationIR
    (premises)
    -- Decl_inst: block Ci_0 sto_0 |- constantDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
    -- if declarationIR?{declarationIR <- declarationIR?} <: constantDeclarationIR?
    -- let constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as constantDeclarationIR?
    (output) Ci_1 | sto_1 | constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} as parserLocalDeclarationIR?
  }

  ;; ../../../../spec-concrete/6.10.3-instantiation-parser-declaration.watsup:15.1-17.89
  rulegroup instantiationIR
   match
    (expl-input) Ci_0 | sto_0 | instantiationIR as parserLocalDeclarationIR
    (impl-input) Ci_0 | sto_0 | parserLocalDeclarationIR
    (impl-input-premises)
    -- if parserLocalDeclarationIR <: instantiationIR
    -- let instantiationIR = parserLocalDeclarationIR as instantiationIR
   paths
  {
    rulepath instantiationIR
    (premises)
    -- Decl_inst: block Ci_0 sto_0 |- instantiationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
    -- if declarationIR?{declarationIR <- declarationIR?} <: instantiationIR?
    -- let instantiationIR_inst?{instantiationIR_inst <- instantiationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as instantiationIR?
    (output) Ci_1 | sto_1 | instantiationIR_inst?{instantiationIR_inst <- instantiationIR_inst?} as parserLocalDeclarationIR?
  }

  ;; ../../../../spec-concrete/6.10.3-instantiation-parser-declaration.watsup:21.1-22.67
  rulegroup variableDeclarationIR
   match
    (expl-input) Ci | sto | variableDeclarationIR as parserLocalDeclarationIR
    (impl-input) Ci | sto | parserLocalDeclarationIR
    (impl-input-premises)
    -- if parserLocalDeclarationIR <: variableDeclarationIR
    -- let variableDeclarationIR = parserLocalDeclarationIR as variableDeclarationIR
   paths
  {
    rulepath variableDeclarationIR
    (premises)
    (output) Ci | sto | ?(variableDeclarationIR as parserLocalDeclarationIR)
  }

  ;; ../../../../spec-concrete/6.10.3-instantiation-parser-declaration.watsup:28.1-29.67
  rulegroup valueSetDeclarationIR
   match
    (expl-input) Ci | sto | valueSetDeclarationIR as parserLocalDeclarationIR
    (impl-input) Ci | sto | parserLocalDeclarationIR
    (impl-input-premises)
    -- if parserLocalDeclarationIR <: valueSetDeclarationIR
    -- let valueSetDeclarationIR = parserLocalDeclarationIR as valueSetDeclarationIR
   paths
  {
    rulepath valueSetDeclarationIR
    (premises)
    (output) Ci | sto | ?(valueSetDeclarationIR as parserLocalDeclarationIR)
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:132.1-134.23
relation ParserLocalDecls_inst: contextInst sto |- parserLocalDeclarationIR* ==> contextInst sto parserLocalDeclarationIR*
  ;; ../../../../spec-concrete/6.10.3-instantiation-parser-declaration.watsup:37.1-38.31
  rulegroup nil
   match
    (expl-input) Ci | sto | []
    (impl-input) Ci | sto | parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}
    (impl-input-premises)
    -- if parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) Ci | sto | []
  }

  ;; ../../../../spec-concrete/6.10.3-instantiation-parser-declaration.watsup:40.1-44.114
  rulegroup cons-none
   match
    (expl-input) Ci_0 | sto_0 | parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{}
    (impl-input) Ci_0 | sto_0 | parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}
    (impl-input-premises)
    -- if parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} matches _ :: _
    -- let parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*} = parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}
   paths
  {
    rulepath cons-none
    (premises)
    -- ParserLocalDecl_inst: Ci_0 sto_0 |- parserLocalDeclarationIR_h ==> Ci_1 sto_1 parserLocalDeclarationIR'?{parserLocalDeclarationIR' <- parserLocalDeclarationIR'?}
    -- if parserLocalDeclarationIR'?{parserLocalDeclarationIR' <- parserLocalDeclarationIR'?} matches ()
    -- ParserLocalDecls_inst: Ci_1 sto_1 |- parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*} ==> Ci_2 sto_2 parserLocalDeclarationIR_t'*{parserLocalDeclarationIR_t' <- parserLocalDeclarationIR_t'*}
    (output) Ci_2 | sto_2 | parserLocalDeclarationIR_t'*{parserLocalDeclarationIR_t' <- parserLocalDeclarationIR_t'*}
  }

  ;; ../../../../spec-concrete/6.10.3-instantiation-parser-declaration.watsup:46.1-50.114
  rulegroup cons-some
   match
    (expl-input) Ci_0 | sto_0 | parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{}
    (impl-input) Ci_0 | sto_0 | parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}
    (impl-input-premises)
    -- if parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} matches _ :: _
    -- let parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*} = parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}
   paths
  {
    rulepath cons-some
    (premises)
    -- ParserLocalDecl_inst: Ci_0 sto_0 |- parserLocalDeclarationIR_h ==> Ci_1 sto_1 parserLocalDeclarationIR'?{parserLocalDeclarationIR' <- parserLocalDeclarationIR'?}
    -- if parserLocalDeclarationIR'?{parserLocalDeclarationIR' <- parserLocalDeclarationIR'?} matches (_)
    -- let ?(parserLocalDeclarationIR_h') = parserLocalDeclarationIR'?{parserLocalDeclarationIR' <- parserLocalDeclarationIR'?}
    -- ParserLocalDecls_inst: Ci_1 sto_1 |- parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*} ==> Ci_2 sto_2 parserLocalDeclarationIR_t'*{parserLocalDeclarationIR_t' <- parserLocalDeclarationIR_t'*}
    (output) Ci_2 | sto_2 | parserLocalDeclarationIR_h' :: parserLocalDeclarationIR_t'*{parserLocalDeclarationIR_t' <- parserLocalDeclarationIR_t'*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:140.1-142.23
relation TableProperty_inst: contextInst sto |- tablePropertyIR ==> contextInst sto tablePropertyIR
  ;; ../../../../spec-concrete/6.11.1-instantiation-control-table.watsup:8.1-9.79
  rulegroup key
   match
    (expl-input) Ci | sto | key={ tableKeyListIR }
    (impl-input) Ci | sto | tablePropertyIR
    (impl-input-premises)
    -- if tablePropertyIR matches `KEY={%}`
    -- let key={ tableKeyListIR } = tablePropertyIR
   paths
  {
    rulepath key
    (premises)
    (output) Ci | sto | key={ tableKeyListIR }
  }

  ;; ../../../../spec-concrete/6.11.1-instantiation-control-table.watsup:12.1-13.93
  rulegroup actions
   match
    (expl-input) Ci | sto | actions={ tableActionListIR }
    (impl-input) Ci | sto | tablePropertyIR
    (impl-input-premises)
    -- if tablePropertyIR matches `ACTIONS={%}`
    -- let actions={ tableActionListIR } = tablePropertyIR
   paths
  {
    rulepath actions
    (premises)
    (output) Ci | sto | actions={ tableActionListIR }
  }

  ;; ../../../../spec-concrete/6.11.1-instantiation-control-table.watsup:16.1-18.76
  rulegroup entries
   match
    (expl-input) Ci | sto | annotationList constOptIR entries={ tableEntryListIR }
    (impl-input) Ci | sto | tablePropertyIR
    (impl-input-premises)
    -- if tablePropertyIR matches `%%ENTRIES={%}`
    -- let annotationList constOptIR entries={ tableEntryListIR } = tablePropertyIR
   paths
  {
    rulepath entries
    (premises)
    (output) Ci | sto | annotationList constOptIR entries={ tableEntryListIR }
  }

  ;; ../../../../spec-concrete/6.11.1-instantiation-control-table.watsup:21.1-23.87
  rulegroup custom-default-action
   match
    (expl-input) Ci | sto | annotationList constOptIR default_action= tableActionReferenceIR ;
    (impl-input) Ci | sto | tablePropertyIR
    (impl-input-premises)
    -- if tablePropertyIR matches `%%DEFAULT_ACTION=%;`
    -- let annotationList constOptIR default_action= tableActionReferenceIR ; = tablePropertyIR
   paths
  {
    rulepath custom-default-action
    (premises)
    (output) Ci | sto | annotationList constOptIR default_action= tableActionReferenceIR ;
  }

  ;; ../../../../spec-concrete/6.11.1-instantiation-control-table.watsup:26.1-31.72
  rulegroup custom
   match
    (expl-input) Ci | sto | annotationList constOptIR custom nameIR = typedExpressionIR ;
    (impl-input) Ci | sto | tablePropertyIR
    (impl-input-premises)
    -- if tablePropertyIR matches `%%CUSTOM%%;`
    -- let annotationList constOptIR custom nameIR = typedExpressionIR ; = tablePropertyIR
   paths
  {
    rulepath custom
    (premises)
    -- let Ci_inner = $enter_path(Ci, nameIR)
    -- Expr_inst: local Ci_inner sto |- typedExpressionIR ==> sto_1 value
    (output) Ci | sto_1 | annotationList constOptIR custom_const nameIR = value ;
  }

  ;; ../../../../spec-concrete/6.11.1-instantiation-control-table.watsup:34.1-36.88
  rulegroup custom-const
   match
    (expl-input) Ci | sto | annotationList constOptIR custom_const nameIR constantInitializerIR ;
    (impl-input) Ci | sto | tablePropertyIR
    (impl-input-premises)
    -- if tablePropertyIR matches `%%CUSTOM_CONST%%;`
    -- let annotationList constOptIR custom_const nameIR constantInitializerIR ; = tablePropertyIR
   paths
  {
    rulepath custom-const
    (premises)
    (output) Ci | sto | annotationList constOptIR custom_const nameIR constantInitializerIR ;
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:144.1-146.23
relation TableProperties_inst: contextInst sto |- tablePropertyIR* ==> contextInst sto tablePropertyIR*
  ;; ../../../../spec-concrete/6.11.1-instantiation-control-table.watsup:38.1-39.31
  rulegroup nil
   match
    (expl-input) Ci | sto | []
    (impl-input) Ci | sto | tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
    (impl-input-premises)
    -- if tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) Ci | sto | []
  }

  ;; ../../../../spec-concrete/6.11.1-instantiation-control-table.watsup:41.1-45.95
  rulegroup cons
   match
    (expl-input) Ci_0 | sto_0 | tablePropertyIR_h :: tablePropertyIR_t*{}
    (impl-input) Ci_0 | sto_0 | tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
    (impl-input-premises)
    -- if tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} matches _ :: _
    -- let tablePropertyIR_h :: tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*} = tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
   paths
  {
    rulepath cons
    (premises)
    -- TableProperty_inst: Ci_0 sto_0 |- tablePropertyIR_h ==> Ci_1 sto_1 tablePropertyIR_h'
    -- TableProperties_inst: Ci_1 sto_1 |- tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*} ==> Ci_2 sto_2 tablePropertyIR_t'*{tablePropertyIR_t' <- tablePropertyIR_t'*}
    (output) Ci_2 | sto_2 | tablePropertyIR_h' :: tablePropertyIR_t'*{tablePropertyIR_t' <- tablePropertyIR_t'*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:148.1-150.23
relation ControlLocalDecl_inst: contextInst sto |- controlLocalDeclarationIR ==> contextInst sto controlLocalDeclarationIR?
  ;; ../../../../spec-concrete/6.11.2-instantiation-control-declaration.watsup:9.1-11.101
  rulegroup constantDeclarationIR
   match
    (expl-input) Ci_0 | sto_0 | constantDeclarationIR as controlLocalDeclarationIR
    (impl-input) Ci_0 | sto_0 | controlLocalDeclarationIR
    (impl-input-premises)
    -- if controlLocalDeclarationIR <: constantDeclarationIR
    -- let constantDeclarationIR = controlLocalDeclarationIR as constantDeclarationIR
   paths
  {
    rulepath constantDeclarationIR
    (premises)
    -- Decl_inst: block Ci_0 sto_0 |- constantDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
    -- if declarationIR?{declarationIR <- declarationIR?} <: constantDeclarationIR?
    -- let constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as constantDeclarationIR?
    (output) Ci_1 | sto_1 | constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} as controlLocalDeclarationIR?
  }

  ;; ../../../../spec-concrete/6.11.2-instantiation-control-declaration.watsup:15.1-17.90
  rulegroup instantiationIR
   match
    (expl-input) Ci_0 | sto_0 | instantiationIR as controlLocalDeclarationIR
    (impl-input) Ci_0 | sto_0 | controlLocalDeclarationIR
    (impl-input-premises)
    -- if controlLocalDeclarationIR <: instantiationIR
    -- let instantiationIR = controlLocalDeclarationIR as instantiationIR
   paths
  {
    rulepath instantiationIR
    (premises)
    -- Decl_inst: block Ci_0 sto_0 |- instantiationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
    -- if declarationIR?{declarationIR <- declarationIR?} <: constantDeclarationIR?
    -- let constantDeclarationIR?{constantDeclarationIR <- constantDeclarationIR?} = declarationIR?{declarationIR <- declarationIR?} as constantDeclarationIR?
    (output) Ci_1 | sto_1 | constantDeclarationIR?{constantDeclarationIR <- constantDeclarationIR?} as controlLocalDeclarationIR?
  }

  ;; ../../../../spec-concrete/6.11.2-instantiation-control-declaration.watsup:21.1-22.67
  rulegroup variableDeclarationIR
   match
    (expl-input) Ci | sto | variableDeclarationIR as controlLocalDeclarationIR
    (impl-input) Ci | sto | controlLocalDeclarationIR
    (impl-input-premises)
    -- if controlLocalDeclarationIR <: variableDeclarationIR
    -- let variableDeclarationIR = controlLocalDeclarationIR as variableDeclarationIR
   paths
  {
    rulepath variableDeclarationIR
    (premises)
    (output) Ci | sto | ?(variableDeclarationIR as controlLocalDeclarationIR)
  }

  ;; ../../../../spec-concrete/6.11.2-instantiation-control-declaration.watsup:26.1-28.97
  rulegroup actionDeclarationIR
   match
    (expl-input) Ci_0 | sto_0 | actionDeclarationIR as controlLocalDeclarationIR
    (impl-input) Ci_0 | sto_0 | controlLocalDeclarationIR
    (impl-input-premises)
    -- if controlLocalDeclarationIR <: actionDeclarationIR
    -- let actionDeclarationIR = controlLocalDeclarationIR as actionDeclarationIR
   paths
  {
    rulepath actionDeclarationIR
    (premises)
    -- Decl_inst: block Ci_0 sto_0 |- actionDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
    -- if declarationIR?{declarationIR <- declarationIR?} <: actionDeclarationIR?
    -- let actionDeclarationIR_inst?{actionDeclarationIR_inst <- actionDeclarationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as actionDeclarationIR?
    (output) Ci_1 | sto_1 | actionDeclarationIR_inst?{actionDeclarationIR_inst <- actionDeclarationIR_inst?} as controlLocalDeclarationIR?
  }

  ;; ../../../../spec-concrete/6.11.2-instantiation-control-declaration.watsup:32.1-45.30
  rulegroup tableDeclarationIR
   match
    (expl-input) Ci_0 | sto_0 | _annotationList table typeIR nameIR { tablePropertyListIR } as controlLocalDeclarationIR
    (impl-input) Ci_0 | sto_0 | controlLocalDeclarationIR
    (impl-input-premises)
    -- if controlLocalDeclarationIR <: tableDeclarationIR
    -- let _annotationList table typeIR nameIR { tablePropertyListIR } = controlLocalDeclarationIR as tableDeclarationIR
   paths
  {
    rulepath tableDeclarationIR
    (premises)
    -- let Ci_inner = $enter_path(Ci_0, nameIR)
    -- Constructor_inst: block Ci_0 sto_0 |- table nameIR { tablePropertyListIR } < [] >( [] # [] )==> sto_1 objDyn
    -- let oid = Ci_0.path ++ [nameIR]
    -- let sto_2 = $add_sto(sto_1, oid, objDyn)
    -- let Ci_1 = $add_value_inst(block, Ci_0, nameIR, ! oid as value)
    -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;
    (output) Ci_1 | sto_1 | ?(constantDeclarationIR as controlLocalDeclarationIR)
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:152.1-154.23
relation ControlLocalDecls_inst: contextInst sto |- controlLocalDeclarationIR* ==> contextInst sto controlLocalDeclarationIR*
  ;; ../../../../spec-concrete/6.11.2-instantiation-control-declaration.watsup:52.1-53.31
  rulegroup nil
   match
    (expl-input) Ci | sto | []
    (impl-input) Ci | sto | controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
    (impl-input-premises)
    -- if controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) Ci | sto | []
  }

  ;; ../../../../spec-concrete/6.11.2-instantiation-control-declaration.watsup:55.1-59.117
  rulegroup cons-none
   match
    (expl-input) Ci_0 | sto_0 | controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{}
    (impl-input) Ci_0 | sto_0 | controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
    (impl-input-premises)
    -- if controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} matches _ :: _
    -- let controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*} = controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
   paths
  {
    rulepath cons-none
    (premises)
    -- ControlLocalDecl_inst: Ci_0 sto_0 |- controlLocalDeclarationIR_h ==> Ci_1 sto_1 controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?}
    -- if controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?} matches ()
    -- ControlLocalDecls_inst: Ci_1 sto_1 |- controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*} ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*{controlLocalDeclarationIR_t' <- controlLocalDeclarationIR_t'*}
    (output) Ci_2 | sto_2 | controlLocalDeclarationIR_t'*{controlLocalDeclarationIR_t' <- controlLocalDeclarationIR_t'*}
  }

  ;; ../../../../spec-concrete/6.11.2-instantiation-control-declaration.watsup:61.1-65.117
  rulegroup cons-some
   match
    (expl-input) Ci_0 | sto_0 | controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{}
    (impl-input) Ci_0 | sto_0 | controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
    (impl-input-premises)
    -- if controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} matches _ :: _
    -- let controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*} = controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
   paths
  {
    rulepath cons-some
    (premises)
    -- ControlLocalDecl_inst: Ci_0 sto_0 |- controlLocalDeclarationIR_h ==> Ci_1 sto_1 controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?}
    -- if controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?} matches (_)
    -- let ?(controlLocalDeclarationIR_h') = controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?}
    -- ControlLocalDecls_inst: Ci_1 sto_1 |- controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*} ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*{controlLocalDeclarationIR_t' <- controlLocalDeclarationIR_t'*}
    (output) Ci_2 | sto_2 | controlLocalDeclarationIR_h' :: controlLocalDeclarationIR_t'*{controlLocalDeclarationIR_t' <- controlLocalDeclarationIR_t'*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:160.1-162.26
relation Decls_inst: cursor contextInst sto |- declarationIR* ==> contextInst sto declarationIR*
  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:489.1-490.33
  rulegroup nil
   match
    (expl-input) p | Ci | sto | []
    (impl-input) p | Ci | sto | declarationIR*{declarationIR <- declarationIR*}
    (impl-input-premises)
    -- if declarationIR*{declarationIR <- declarationIR*} matches []
   paths
  {
    rulepath nil
    (premises)
    (output) Ci | sto | []
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:492.1-496.83
  rulegroup cons-none
   match
    (expl-input) p | Ci_0 | sto_0 | declarationIR_h :: declarationIR_t*{}
    (impl-input) p | Ci_0 | sto_0 | declarationIR*{declarationIR <- declarationIR*}
    (impl-input-premises)
    -- if declarationIR*{declarationIR <- declarationIR*} matches _ :: _
    -- let declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*} = declarationIR*{declarationIR <- declarationIR*}
   paths
  {
    rulepath cons-none
    (premises)
    -- Decl_inst: p Ci_0 sto_0 |- declarationIR_h ==> Ci_1 sto_1 declarationIR'?{declarationIR' <- declarationIR'?}
    -- if declarationIR'?{declarationIR' <- declarationIR'?} matches ()
    -- Decls_inst: p Ci_1 sto_1 |- declarationIR_t*{declarationIR_t <- declarationIR_t*} ==> Ci_2 sto_2 declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}
    (output) Ci_2 | sto_2 | declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:498.1-502.83
  rulegroup cons-some
   match
    (expl-input) p | Ci_0 | sto_0 | declarationIR_h :: declarationIR_t*{}
    (impl-input) p | Ci_0 | sto_0 | declarationIR*{declarationIR <- declarationIR*}
    (impl-input-premises)
    -- if declarationIR*{declarationIR <- declarationIR*} matches _ :: _
    -- let declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*} = declarationIR*{declarationIR <- declarationIR*}
   paths
  {
    rulepath cons-some
    (premises)
    -- Decl_inst: p Ci_0 sto_0 |- declarationIR_h ==> Ci_1 sto_1 declarationIR'?{declarationIR' <- declarationIR'?}
    -- if declarationIR'?{declarationIR' <- declarationIR'?} matches (_)
    -- let ?(declarationIR_h') = declarationIR'?{declarationIR' <- declarationIR'?}
    -- Decls_inst: p Ci_1 sto_1 |- declarationIR_t*{declarationIR_t <- declarationIR_t*} ==> Ci_2 sto_2 declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}
    (output) Ci_2 | sto_2 | declarationIR_h' :: declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:164.1-166.26
relation Decl_inst: cursor contextInst sto |- declarationIR ==> contextInst sto declarationIR?
  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:16.1-21.30
  rulegroup constantDeclarationIR
   match
    (expl-input) p | Ci_0 | sto | annotationList const typeIR nameIR = value ; as declarationIR
    (impl-input) p | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if declarationIR <: constantDeclarationIR
    -- let annotationList const typeIR nameIR = value ; = declarationIR as constantDeclarationIR
   paths
  {
    rulepath constantDeclarationIR
    (premises)
    -- let Ci_1 = $add_value_inst(p, Ci_0, nameIR, value)
    -- let constantDeclarationIR = annotationList const typeIR nameIR = value ;
    (output) Ci_1 | sto | $wrap_decl(p, constantDeclarationIR as declarationIR)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:52.1-79.30
  rulegroup instantiationIR-extern
   match
    (expl-input) p | Ci_0 | sto_0 | _annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ; as declarationIR
    (impl-input) p | Ci_0 | sto_0 | declarationIR
    (impl-input-premises)
    -- if declarationIR <: instantiationIR
    -- let _annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ; = declarationIR as instantiationIR
   paths
  {
    rulepath instantiationIR-extern
    (premises)
    -- let (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR)
    -- if (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} matches (_)
    -- let ?((_cid, consDyn, id_default*{id_default <- id_default*})) = (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?}
    -- let Ci_inner = $enter_path(Ci_0, nameIR)
    -- Constructor_inst: p Ci_inner sto_0 |- consDyn < typeArgumentListIR >( argumentListIR # id_default*{id_default <- id_default*} )==> sto_1 objDyn
    -- let objDyn' = objDyn
    -- if objDyn' matches `EXTERN{%%%%}`
    -- let extern{ tid theta venv renv } = objDyn'
    -- let Ci_decl = $empty_context_inst[path = Ci_0.path][global = Ci_0.global]
    -- let objectDeclarationListIR = $get_init_decls(objectInitializerOptIR)
    -- Decls_inst: block Ci_decl sto_1 |- objectDeclarationListIR as declarationIR* ==> Ci_decl_post sto_2 _declarationIR*{_declarationIR <- _declarationIR*}
    -- let venv_merged = $merge_venvs(venv, Ci_decl_post.block.venv)
    -- let renv_merged = $merge_renv_with_extern(renv, Ci_decl_post.block.renv)
    -- let objDyn_1 = extern{ tid theta venv_merged renv_merged }
    -- let oid = Ci_0.path ++ [nameIR]
    -- let sto_3 = $add_sto(sto_2, oid, objDyn_1)
    -- let Ci_1 = $add_value_inst(p, Ci_0, nameIR, ! oid as value)
    -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;
    (output) Ci_1 | sto_2 | $wrap_decl(p, constantDeclarationIR as declarationIR)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:85.1-102.30
  rulegroup instantiationIR-non-extern
   match
    (expl-input) p | Ci_0 | sto_0 | _annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ; as declarationIR
    (impl-input) p | Ci_0 | sto_0 | declarationIR
    (impl-input-premises)
    -- if declarationIR <: instantiationIR
    -- let _annotationList typeIR prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ; = declarationIR as instantiationIR
   paths
  {
    rulepath instantiationIR-non-extern
    (premises)
    -- let (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR)
    -- if (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?} matches (_)
    -- let ?((_cid, consDyn, id_default*{id_default <- id_default*})) = (cid, consDyn, id*)?{(cid, consDyn, id*) <- (cid, consDyn, id*)?}
    -- let Ci_inner = $enter_path(Ci_0, nameIR)
    -- Constructor_inst: p Ci_inner sto_0 |- consDyn < typeArgumentListIR >( argumentListIR # id_default*{id_default <- id_default*} )==> sto_1 objDyn
    -- if ~$is_extern_object(objDyn)
    -- let oid = Ci_0.path ++ [nameIR]
    -- let sto_2 = $add_sto(sto_1, oid, objDyn)
    -- let Ci_1 = $add_value_inst(p, Ci_0, nameIR, ! oid as value)
    -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;
    (output) Ci_1 | sto_1 | $wrap_decl(p, constantDeclarationIR as declarationIR)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:120.1-129.65
  rulegroup functionDeclarationIR
   match
    (expl-input) p | Ci_0 | sto | _annotationList typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) blockStatementIR as declarationIR
    (impl-input) p | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if declarationIR <: functionDeclarationIR
    -- let _annotationList typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) blockStatementIR = declarationIR as functionDeclarationIR
   paths
  {
    rulepath functionDeclarationIR
    (premises)
    -- let rid = $rid_IR(nameIR, parameterListIR)
    -- let funcDyn = function< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ) blockStatementIR
    -- let Ci_1 = $add_routine_overload_inst(p, Ci_0, rid, funcDyn as routineDyn)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:135.1-140.69
  rulegroup actionDeclarationIR
   match
    (expl-input) p | Ci_0 | sto | _annotationList action nameIR ( parameterListIR ) blockStatementIR as declarationIR
    (impl-input) p | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if declarationIR <: actionDeclarationIR
    -- let _annotationList action nameIR ( parameterListIR ) blockStatementIR = declarationIR as actionDeclarationIR
   paths
  {
    rulepath actionDeclarationIR
    (premises)
    -- let rid = $rid_IR(nameIR, parameterListIR)
    -- let funcDyn = action( parameterListIR ){ blockStatementIR }
    -- let Ci_1 = $add_routine_non_overload_inst(p, Ci_0, rid, funcDyn as routineDyn)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:146.1-150.81
  rulegroup errorDeclarationIR
   match
    (expl-input) global | Ci_0 | sto | error{ nameIR*{} } as declarationIR
    (impl-input) cursor | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: errorDeclarationIR
    -- let error{ nameIR*{nameIR <- nameIR*} } = declarationIR as errorDeclarationIR
   paths
  {
    rulepath errorDeclarationIR
    (premises)
    -- (let nameIR_field = $concat_text(["error.", nameIR]))*{nameIR <- nameIR*, nameIR_field <- nameIR_field*}
    -- let Ci_1 = $add_values_inst(global, Ci_0, nameIR_field*{nameIR_field <- nameIR_field*}, error. nameIR as value*{nameIR <- nameIR*})
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:156.1-159.80
  rulegroup matchKindDeclarationIR
   match
    (expl-input) global | Ci_0 | sto | match_kind{ nameIR*{} } as declarationIR
    (impl-input) cursor | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: matchKindDeclarationIR
    -- let match_kind{ nameIR*{nameIR <- nameIR*} } = declarationIR as matchKindDeclarationIR
   paths
  {
    rulepath matchKindDeclarationIR
    (premises)
    -- let Ci_1 = $add_values_inst(global, Ci_0, nameIR*{nameIR <- nameIR*}, match_kind. nameIR as value*{nameIR <- nameIR*})
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:167.1-178.65
  rulegroup externFunctionDeclarationIR
   match
    (expl-input) p | Ci_0 | sto | _annotationList extern typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) ; as declarationIR
    (impl-input) p | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if declarationIR <: externFunctionDeclarationIR
    -- let _annotationList extern typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) ; = declarationIR as externFunctionDeclarationIR
   paths
  {
    rulepath externFunctionDeclarationIR
    (premises)
    -- let rid = $rid_IR(nameIR, parameterListIR)
    -- let funcDyn = extern_function< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ){ ?() }
    -- let Ci_1 = $add_routine_overload_inst(p, Ci_0, rid, funcDyn as routineDyn)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:204.1-223.60
  rulegroup extern-object-no-constructors
   match
    (expl-input) p | Ci_0 | sto | annotationList extern nameIR < typeParameterListIR , typeParameterListIR_inferred >{ methodPrototypeIR*{} } as declarationIR
    (impl-input) p | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if declarationIR <: externObjectDeclarationIR
    -- let annotationList extern nameIR < typeParameterListIR , typeParameterListIR_inferred >{ methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} } = declarationIR as externObjectDeclarationIR
   paths
  {
    rulepath extern-object-no-constructors
    (premises)
    -- let (methodPrototypeIR'*{methodPrototypeIR' <- methodPrototypeIR'*}, methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*}) = $split_constructors_IR(methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*})
    -- if methodPrototypeIR'*{methodPrototypeIR' <- methodPrototypeIR'*} matches []
    -- Bind_methods: $empty_rdenv |- methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} ==> rdenv
    -- let externObjectTypeIR = extern nameIR rdenv
    -- let polyTypeDefIR = externObjectTypeIR as typeIR < typeParameterListIR , [] >
    -- let Ci_1 = $add_typedef_inst(p, Ci_0, nameIR, polyTypeDefIR as typeDefIR)
    -- let cid = $cid_IR(nameIR, [])
    -- let consDyn = extern nameIR < typeParameterListIR >( [] ){ methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} }
    -- let Ci_2 = $add_constructor_inst(p, Ci_1, cid, consDyn)
    (output) Ci_2 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:225.1-241.120
  rulegroup extern-object-with-constructors
   match
    (expl-input) p | Ci_0 | sto | annotationList extern nameIR < typeParameterListIR , typeParameterListIR_inferred >{ methodPrototypeIR*{} } as declarationIR
    (impl-input) p | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if declarationIR <: externObjectDeclarationIR
    -- let annotationList extern nameIR < typeParameterListIR , typeParameterListIR_inferred >{ methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} } = declarationIR as externObjectDeclarationIR
   paths
  {
    rulepath extern-object-with-constructors
    (premises)
    -- let (methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*}, methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*}) = $split_constructors_IR(methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*})
    -- Bind_methods: $empty_rdenv |- methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} ==> rdenv
    -- let externObjectTypeIR = extern nameIR rdenv
    -- let polyTypeDefIR = externObjectTypeIR as typeIR < typeParameterListIR , [] >
    -- let Ci_1 = $add_typedef_inst(p, Ci_0, nameIR, polyTypeDefIR as typeDefIR)
    -- Bind_constructors: p Ci_1 typeParameterListIR methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} |- methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*} ==> Ci_2
    (output) Ci_2 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:250.1-260.60
  rulegroup parserDeclarationIR
   match
    (expl-input) p | Ci_0 | sto | _annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR } as declarationIR
    (impl-input) p | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if declarationIR <: parserDeclarationIR
    -- let _annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR } = declarationIR as parserDeclarationIR
   paths
  {
    rulepath parserDeclarationIR
    (premises)
    -- let cid = $cid_IR(nameIR, constructorParameterListIR)
    -- let consDyn = parser< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
    -- let Ci_1 = $add_constructor_inst(p, Ci_0, cid, consDyn)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:269.1-280.60
  rulegroup controlDeclarationIR
   match
    (expl-input) p | Ci_0 | sto | _annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR } as declarationIR
    (impl-input) p | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if declarationIR <: controlDeclarationIR
    -- let _annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR } = declarationIR as controlDeclarationIR
   paths
  {
    rulepath controlDeclarationIR
    (premises)
    -- let cid = $cid_IR(nameIR, constructorParameterListIR)
    -- let consDyn = control< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
    -- let Ci_1 = $add_constructor_inst(p, Ci_0, cid, consDyn)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:293.1-299.85
  rulegroup typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-enum
   match
    (expl-input) global | Ci_0 | sto | _annotationList enum nameIR { nameIR_mem*{} } as declarationIR
    (impl-input) cursor | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: enumTypeDeclarationIR
    -- let enumTypeDeclarationIR = declarationIR as enumTypeDeclarationIR
    -- if enumTypeDeclarationIR matches `%ENUM%{%}`
    -- let _annotationList enum nameIR { nameIR_mem*{nameIR_mem <- nameIR_mem*} } = enumTypeDeclarationIR
   paths
  {
    rulepath typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-enum
    (premises)
    -- (let nameIR_path = $concat_text([nameIR, ".", nameIR_mem]))*{nameIR_mem <- nameIR_mem*, nameIR_path <- nameIR_path*}
    -- let Ci_1 = $add_values_inst(global, Ci_0, nameIR_path*{nameIR_path <- nameIR_path*}, nameIR . nameIR_mem as value*{nameIR_mem <- nameIR_mem*})
    -- let Ci_2 = $add_typedef_inst(global, Ci_1, nameIR, enum nameIR { nameIR_mem*{nameIR_mem <- nameIR_mem*} } as typeDefIR)
    (output) Ci_2 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:304.1-313.113
  rulegroup typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-serializableEnum
   match
    (expl-input) global | Ci_0 | sto_0 | _annotationList enum typeIR nameIR { nameIR_mem = typedExpressionIR*{} } as declarationIR
    (impl-input) cursor | Ci_0 | sto_0 | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: enumTypeDeclarationIR
    -- let enumTypeDeclarationIR = declarationIR as enumTypeDeclarationIR
    -- if enumTypeDeclarationIR matches `%ENUM%%{%}`
    -- let _annotationList enum typeIR nameIR { nameIR_mem = typedExpressionIR*{nameIR_mem <- nameIR_mem*, typedExpressionIR <- typedExpressionIR*} } = enumTypeDeclarationIR
   paths
  {
    rulepath typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-serializableEnum
    (premises)
    -- Exprs_inst: global Ci_0 sto_0 |- typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ==> sto_1 value_mem*{value_mem <- value_mem*}
    -- (let nameIR_path = $concat_text([nameIR, ".", nameIR_mem]))*{nameIR_mem <- nameIR_mem*, nameIR_path <- nameIR_path*}
    -- let Ci_1 = $add_values_inst(global, Ci_0, nameIR_path*{nameIR_path <- nameIR_path*}, nameIR . nameIR_mem # value_mem as value*{nameIR_mem <- nameIR_mem*, value_mem <- value_mem*})
    -- let Ci_2 = $add_typedef_inst(global, Ci_1, nameIR, enum nameIR # typeIR { nameIR_mem = value_mem ;*{nameIR_mem <- nameIR_mem*, value_mem <- value_mem*} } as typeDefIR)
    (output) Ci_2 | sto_1 | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:321.1-331.66
  rulegroup typeDeclarationIR-derivedTypeDeclarationIR-structTypeDeclarationIR
   match
    (expl-input) global | Ci_0 | sto | _annotationList struct nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR*{} } as declarationIR
    (impl-input) cursor | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: structTypeDeclarationIR
    -- let _annotationList struct nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR*{typeFieldIR <- typeFieldIR*} } = declarationIR as structTypeDeclarationIR
   paths
  {
    rulepath typeDeclarationIR-derivedTypeDeclarationIR-structTypeDeclarationIR
    (premises)
    -- (let _annotationList' typeIR nameIR_field ; = typeFieldIR)*{_annotationList' <- _annotationList'*, nameIR_field <- nameIR_field*, typeFieldIR <- typeFieldIR*, typeIR <- typeIR*}
    -- let typeDefIR = struct nameIR { typeIR nameIR_field ;*{nameIR_field <- nameIR_field*, typeIR <- typeIR*} } as typeIR < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:339.1-349.66
  rulegroup typeDeclarationIR-derivedTypeDeclarationIR-headerTypeDeclarationIR
   match
    (expl-input) global | Ci_0 | sto | _annotationList header nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR*{} } as declarationIR
    (impl-input) cursor | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: headerTypeDeclarationIR
    -- let _annotationList header nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR*{typeFieldIR <- typeFieldIR*} } = declarationIR as headerTypeDeclarationIR
   paths
  {
    rulepath typeDeclarationIR-derivedTypeDeclarationIR-headerTypeDeclarationIR
    (premises)
    -- (let _annotationList' typeIR nameIR_field ; = typeFieldIR)*{_annotationList' <- _annotationList'*, nameIR_field <- nameIR_field*, typeFieldIR <- typeFieldIR*, typeIR <- typeIR*}
    -- let typeDefIR = header nameIR { typeIR nameIR_field ;*{nameIR_field <- nameIR_field*, typeIR <- typeIR*} } as typeIR < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:357.1-367.66
  rulegroup typeDeclarationIR-derivedTypeDeclarationIR-headerUnionTypeDeclarationIR
   match
    (expl-input) global | Ci_0 | sto | _annotationList header_union nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR*{} } as declarationIR
    (impl-input) cursor | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: headerUnionTypeDeclarationIR
    -- let _annotationList header_union nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR*{typeFieldIR <- typeFieldIR*} } = declarationIR as headerUnionTypeDeclarationIR
   paths
  {
    rulepath typeDeclarationIR-derivedTypeDeclarationIR-headerUnionTypeDeclarationIR
    (premises)
    -- (let _annotationList' typeIR nameIR_field ; = typeFieldIR)*{_annotationList' <- _annotationList'*, nameIR_field <- nameIR_field*, typeFieldIR <- typeFieldIR*, typeIR <- typeIR*}
    -- let typeDefIR = header_union nameIR { typeIR nameIR_field ;*{nameIR_field <- nameIR_field*, typeIR <- typeIR*} } as typeIR < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:377.1-382.71
  rulegroup typeDeclarationIR-typedefDeclarationIR-typedef-typeIR
   match
    (expl-input) global | Ci_0 | sto | _annotationList typedef typeIR as typedefTypeIR nameIR ; as declarationIR
    (impl-input) cursor | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: typedefDeclarationIR
    -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
    -- if typedefDeclarationIR matches `%TYPEDEF%%;`
    -- let _annotationList typedef typedefTypeIR nameIR ; = typedefDeclarationIR
    -- if typedefTypeIR <: typeIR
    -- let typeIR = typedefTypeIR as typeIR
   paths
  {
    rulepath typeDeclarationIR-typedefDeclarationIR-typedef-typeIR
    (premises)
    -- let typeIR_typedef = typedef nameIR typeIR as typeIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeIR_typedef as typeDefIR)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:386.1-399.71
  rulegroup typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclarationIR-monoTypeDefIR
   match
    (expl-input) global | Ci_0 | sto | _annotationList typedef derivedTypeDeclarationIR as typedefTypeIR nameIR ; as declarationIR
    (impl-input) cursor | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: typedefDeclarationIR
    -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
    -- if typedefDeclarationIR matches `%TYPEDEF%%;`
    -- let _annotationList typedef typedefTypeIR nameIR ; = typedefDeclarationIR
    -- if typedefTypeIR <: derivedTypeDeclarationIR
    -- let derivedTypeDeclarationIR = typedefTypeIR as derivedTypeDeclarationIR
   paths
  {
    rulepath typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclarationIR-monoTypeDefIR
    (premises)
    -- Decl_inst: global Ci_0 $empty_sto |- derivedTypeDeclarationIR as declarationIR ==> Ci_local _sto _declarationIR?{_declarationIR <- _declarationIR?}
    -- let { tid*{tid <- tid*} } = $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_local.global.tdenv), $dom_map<tid, typeDefIR>(Ci_0.global.tdenv))
    -- if tid*{tid <- tid*} matches [ _/1 ]
    -- let [tid_newtype] = tid*{tid <- tid*}
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(global, Ci_local, . tid_newtype)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- let typeDefIR'' = typeDefIR
    -- if typeDefIR'' <: monoTypeDefIR
    -- let monoTypeDefIR = typeDefIR'' as monoTypeDefIR
    -- let typeIR_typedef = typedef nameIR monoTypeDefIR as typeIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeIR_typedef as typeDefIR)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:401.1-414.71
  rulegroup typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclaration-polyTypeDefIR
   match
    (expl-input) global | Ci_0 | sto | _annotationList typedef derivedTypeDeclarationIR as typedefTypeIR nameIR ; as declarationIR
    (impl-input) cursor | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: typedefDeclarationIR
    -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
    -- if typedefDeclarationIR matches `%TYPEDEF%%;`
    -- let _annotationList typedef typedefTypeIR nameIR ; = typedefDeclarationIR
    -- if typedefTypeIR <: derivedTypeDeclarationIR
    -- let derivedTypeDeclarationIR = typedefTypeIR as derivedTypeDeclarationIR
   paths
  {
    rulepath typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclaration-polyTypeDefIR
    (premises)
    -- Decl_inst: global Ci_0 $empty_sto |- derivedTypeDeclarationIR as declarationIR ==> Ci_local _sto _declarationIR?{_declarationIR <- _declarationIR?}
    -- let { tid*{tid <- tid*} } = $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_local.global.tdenv), $dom_map<tid, typeDefIR>(Ci_0.global.tdenv))
    -- if tid*{tid <- tid*} matches [ _/1 ]
    -- let [tid_newtype] = tid*{tid <- tid*}
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(global, Ci_local, . tid_newtype)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- let typeDefIR'' = typeDefIR
    -- if typeDefIR'' <: polyTypeDefIR
    -- let polyTypeDefIR = typeDefIR'' as polyTypeDefIR
    -- let typeIR_typedef = typedef nameIR polyTypeDefIR < [] > as typeIR as typeIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeIR_typedef as typeDefIR)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:418.1-423.71
  rulegroup typeDeclarationIR-typedefDeclarationIR-newtype
   match
    (expl-input) global | Ci_0 | sto | _annotationList type typeIR nameIR ; as declarationIR
    (impl-input) cursor | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: typedefDeclarationIR
    -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
    -- if typedefDeclarationIR matches `%TYPE%%;`
    -- let _annotationList type typeIR nameIR ; = typedefDeclarationIR
   paths
  {
    rulepath typeDeclarationIR-typedefDeclarationIR-newtype
    (premises)
    -- let typeIR_newtype = type nameIR typeIR as typeIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeIR_newtype as typeDefIR)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:431.1-441.73
  rulegroup typeDeclarationIR-parserTypeDeclarationIR
   match
    (expl-input) global | Ci_0 | sto | _annotationList parser nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{} ); as declarationIR
    (impl-input) cursor | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: parserTypeDeclarationIR
    -- let _annotationList parser nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ); = declarationIR as parserTypeDeclarationIR
   paths
  {
    rulepath typeDeclarationIR-parserTypeDeclarationIR
    (premises)
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let typeIR_parser = parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
    -- let typeDefIR_parser = typeIR_parser < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR_parser)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:449.1-459.74
  rulegroup typeDeclarationIR-controlTypeDeclarationIR
   match
    (expl-input) global | Ci_0 | sto | _annotationList control nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{} ); as declarationIR
    (impl-input) cursor | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: controlTypeDeclarationIR
    -- let _annotationList control nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ); = declarationIR as controlTypeDeclarationIR
   paths
  {
    rulepath typeDeclarationIR-controlTypeDeclarationIR
    (premises)
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let typeIR_control = control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
    -- let typeDefIR_control = typeIR_control < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR_control)
    (output) Ci_1 | sto | ?()
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:468.1-483.73
  rulegroup typeDeclarationIR-packageTypeDeclarationIR
   match
    (expl-input) p | Ci_0 | sto | _annotationList package nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{} ); as declarationIR
    (impl-input) p | Ci_0 | sto | declarationIR
    (impl-input-premises)
    -- if declarationIR <: packageTypeDeclarationIR
    -- let _annotationList package nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ); = declarationIR as packageTypeDeclarationIR
   paths
  {
    rulepath typeDeclarationIR-packageTypeDeclarationIR
    (premises)
    -- (let _annotationList' _direction typeIR _nameIR _constantInitializerOptIR = parameterIR)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _nameIR <- _nameIR*, parameterIR <- parameterIR*, typeIR <- typeIR*}
    -- let typeIR_package = package< typeIR*{typeIR <- typeIR*} > as typeIR
    -- let typeDefIR_package = typeIR_package < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
    -- let Ci_1 = $add_typedef_inst(p, Ci_0, nameIR, typeDefIR_package)
    -- let cid = $cid_IR(nameIR, parameterIR*{parameterIR <- parameterIR*})
    -- let consDyn_package = package< typeParameterListIR ++ typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} )
    -- let Ci_2 = $add_constructor_inst(global, Ci_1, cid, consDyn_package)
    (output) Ci_2 | sto | ?()
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:168.1-170.17
relation Program_inst: |- p4programIR ==> cenv tdenv renv venv sto
  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:508.1-514.72
  rulegroup 
   match
    (expl-input) declarationIR*{} ;
    (impl-input) declarationIR*{declarationIR <- declarationIR*} ;
    (impl-input-premises)
   paths
  {
    rulepath 
    (premises)
    -- let Ci_0 = $empty_context_inst
    -- let sto_0 = $empty_sto
    -- Decls_inst: global Ci_0 sto_0 |- declarationIR*{declarationIR <- declarationIR*} ==> Ci_1 sto_1 declarationIR'*{declarationIR' <- declarationIR'*}
    -- if declarationIR'*{declarationIR' <- declarationIR'*} matches []
    (output) Ci_1.global.cenv | Ci_1.global.tdenv | Ci_1.global.renv | Ci_1.global.venv | sto_1
  }

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:6.1-6.84
def $partition_default_parameters(parameterIR*, id*) : (parameterIR*, parameterIR*) =

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:8.1-8.65
  clause 0(parameterIR*{parameterIR <- parameterIR*}, id_default*{id_default <- id_default*}) = ([], [])
  -- if parameterIR*{parameterIR <- parameterIR*} matches []

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:9.1-17.28
  clause 1(parameterIR*{parameterIR <- parameterIR*}, id_default*{id_default <- id_default*}) = (parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_h :: parameterIR_default*{parameterIR_default <- parameterIR_default*})
  -- if parameterIR*{parameterIR <- parameterIR*} matches _ :: _
  -- let parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} = parameterIR*{parameterIR <- parameterIR*}
  -- let _annotationList _direction _typeIR id_h _constantInitializerOptIR = parameterIR_h
  -- let (parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_default*{parameterIR_default <- parameterIR_default*}) = $partition_default_parameters(parameterIR_t*{parameterIR_t <- parameterIR_t*}, id_default*{id_default <- id_default*})
  -- if id_h <- id_default*{id_default <- id_default*}

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:19.1-27.31
  clause 2(parameterIR*{parameterIR <- parameterIR*}, id_default*{id_default <- id_default*}) = (parameterIR_h :: parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_default*{parameterIR_default <- parameterIR_default*})
  -- if parameterIR*{parameterIR <- parameterIR*} matches _ :: _
  -- let parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} = parameterIR*{parameterIR <- parameterIR*}
  -- let _annotationList _direction _typeIR id_h _constantInitializerOptIR = parameterIR_h
  -- let (parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_default*{parameterIR_default <- parameterIR_default*}) = $partition_default_parameters(parameterIR_t*{parameterIR_t <- parameterIR_t*}, id_default*{id_default <- id_default*})
  -- if ~id_h <- id_default*{id_default <- id_default*}

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:30.1-30.146
def $align_cparams_with_args(constructorParameterIR*, argumentIR*, id*) : (constructorParameterIR*, argumentIR*, constructorParameterIR*, value*) =

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:33.1-40.71
  clause 0(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}) = (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*})
  -- let (constructorParameterIR_nondefault*{constructorParameterIR_nondefault <- constructorParameterIR_nondefault*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}) = $partition_default_parameters(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, id_default*{id_default <- id_default*})
  -- (let _annotationList _direction _typeIR id _constantInitializerOptIR = constructorParameterIR_nondefault)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_nondefault <- constructorParameterIR_nondefault*, id <- id*}
  -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}) = $align_cparams_with_args'({ id : constructorParameterIR_nondefault*{constructorParameterIR_nondefault <- constructorParameterIR_nondefault*, id <- id*} }, constructorParameterIR_nondefault*{constructorParameterIR_nondefault <- constructorParameterIR_nondefault*}, argumentIR*{argumentIR <- argumentIR*})
  -- (let _annotationList' _direction' _typeIR' _nameIR constantInitializerOptIR = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _direction' <- _direction'*, _nameIR <- _nameIR*, _typeIR' <- _typeIR'*, constantInitializerOptIR <- constantInitializerOptIR*, constructorParameterIR_default <- constructorParameterIR_default*}
  -- (if constantInitializerOptIR matches (_))*{constantInitializerOptIR <- constantInitializerOptIR*}
  -- (let ?(= value_default) = constantInitializerOptIR)*{constantInitializerOptIR <- constantInitializerOptIR*, value_default <- value_default*}

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:31.1-31.142
def $align_cparams_with_args'(map<id, constructorParameterIR>, constructorParameterIR*, argumentIR*) : (constructorParameterIR*, argumentIR*) =

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:42.1-42.99
  clause 0({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}) = ([], [])
  -- if constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} matches []
  -- if argumentIR*{argumentIR <- argumentIR*} matches []

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:43.1-50.63
  clause 1({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}) = (constructorParameterIR_h :: constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_h :: argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*})
  -- if constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} matches _ :: _
  -- let constructorParameterIR_h :: constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*} = constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}
  -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
  -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
  -- let argumentIR' = argumentIR_h
  -- if argumentIR' <: typedExpressionIR
  -- let typedExpressionIR = argumentIR' as typedExpressionIR
  -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}) = $align_cparams_with_args'({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*}, argumentIR_t*{argumentIR_t <- argumentIR_t*})

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:51.1-58.63
  clause 2({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}) = (constructorParameterIR_h :: constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_h :: argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*})
  -- if constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} matches _ :: _
  -- let constructorParameterIR_h :: constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*} = constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}
  -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
  -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
  -- if (argumentIR_h = _)
  -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}) = $align_cparams_with_args'({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*}, argumentIR_t*{argumentIR_t <- argumentIR_t*})

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:59.1-68.63
  clause 3({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}) = (constructorParameterIR_matching :: constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_h :: argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*})
  -- if constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} matches _ :: _
  -- let constructorParameterIR_h :: constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*} = constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}
  -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
  -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
  -- let argumentIR' = argumentIR_h
  -- if argumentIR' matches `%=%`
  -- let nameIR = _typedExpressionIR = argumentIR'
  -- let constructorParameterIR'?{constructorParameterIR' <- constructorParameterIR'?} = $find_map<id, constructorParameterIR>({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, nameIR)
  -- if constructorParameterIR'?{constructorParameterIR' <- constructorParameterIR'?} matches (_)
  -- let ?(constructorParameterIR_matching) = constructorParameterIR'?{constructorParameterIR' <- constructorParameterIR'?}
  -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}) = $align_cparams_with_args'({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*}, argumentIR_t*{argumentIR_t <- argumentIR_t*})

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:197.1-197.59
def $init_table(tablePropertyListIR) : tablePropertyListIR =

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:200.1-200.59
  clause 0(tablePropertyListIR) = tablePropertyListIR

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:11.1-11.55
def $wrap_decl(cursor, declarationIR) : declarationIR? =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:13.1-13.44
  clause 0(cursor, declarationIR) = ?()
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:14.1-14.49
  clause 1(_cursor, declarationIR) = ?(declarationIR)

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:28.1-28.70
def $get_init_decls(objectInitializerOptIR) : objectDeclarationListIR =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:30.1-30.31
  clause 0(objectInitializerIR?{objectInitializerIR <- objectInitializerIR?}) = []
  -- if objectInitializerIR?{objectInitializerIR <- objectInitializerIR?} matches ()

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:31.1-31.79
  clause 1(objectInitializerOptIR) = objectDeclarationListIR
  -- if objectInitializerOptIR matches (_)
  -- let ?(={ objectDeclarationListIR }) = objectInitializerOptIR

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:34.1-34.36
def $merge_venvs(venv, venv) : venv =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:36.1-37.44
  clause 0(venv, { id : value*{id <- id*, value <- value*} }) = $adds_map<id, value>(venv, id*{id <- id*}, value*{value <- value*})

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:40.1-40.47
def $merge_renv_with_extern(renv, renv) : renv =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:42.1-42.51
  clause 0(renv, set<pair<rid, routineDyn>>) = renv
  -- if (set<pair<rid, routineDyn>> = { [] })

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:43.1-50.18
  clause 1(renv, { pair<rid, routineDyn>*{pair<rid, routineDyn> <- pair<rid, routineDyn>*} }) = $merge_renv_with_extern(renv_post, { rid_t : routineDyn_t*{rid_t <- rid_t*, routineDyn_t <- routineDyn_t*} })
  -- if pair<rid, routineDyn>*{pair<rid, routineDyn> <- pair<rid, routineDyn>*} matches _ :: _
  -- let rid_h : routineDyn_h :: rid_t : routineDyn_t*{rid_t <- rid_t*, routineDyn_t <- routineDyn_t*} = pair<rid, routineDyn>*{pair<rid, routineDyn> <- pair<rid, routineDyn>*}
  -- let routineDyn = routineDyn_h
  -- if routineDyn <: funcDyn
  -- let funcDyn = routineDyn as funcDyn
  -- if funcDyn matches `FUNCTION<%>(%)%`
  -- let function< typeParameterListIR >( parameterListIR ) blockStatementIR = funcDyn
  -- let routineDyn_h_post = extern_method< typeParameterListIR >( parameterListIR ) ?(blockStatementIR) as routineDyn
  -- let renv_post = $update_map<rid, routineDyn>(renv, rid_h, routineDyn_h_post)

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:81.1-81.37
def $is_extern_object(objDyn) : bool =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:82.1-82.50
  clause 0(objDyn) = true
  -- if objDyn matches `EXTERN{%%%%}`
  -- let extern{ _tid _theta _venv _renv } = objDyn

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:83.1-83.33
  clause 1(_objDyn) = false

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:108.1-108.43
def $rid_IR(nameIR, parameterListIR) : rid =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:111.1-111.70
  clause 0(nameIR, parameterIR*{parameterIR <- parameterIR*}) = nameIR ( $pid_IR(parameterIR)*{parameterIR <- parameterIR*} )

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:109.1-109.31
def $pid_IR(parameterIR) : pid =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:113.1-113.48
  clause 0(_annotationList _direction _typeIR nameIR constantInitializerIR?{constantInitializerIR <- constantInitializerIR?}) = nameIR # false
  -- if constantInitializerIR?{constantInitializerIR <- constantInitializerIR?} matches ()

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:114.1-114.65
  clause 1(_annotationList _direction _typeIR nameIR constantInitializerOptIR) = nameIR # true
  -- if constantInitializerOptIR matches (_)
  -- let ?(constantInitializerIR) = constantInitializerOptIR

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:116.1-116.54
def $cid_IR(nameIR, constructorParameterListIR) : cid =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:118.1-118.94
  clause 0(nameIR, constructorParameterListIR) = $rid_IR(nameIR, constructorParameterListIR)

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:182.1-182.90
def $split_constructors_IR(methodPrototypeIR*) : (methodPrototypeIR*, methodPrototypeIR*) =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:184.1-184.45
  clause 0(methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}) = ([], [])
  -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches []

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:185.1-190.53
  clause 1(methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}) = (methodPrototypeIR_h :: methodPrototypeIR_t_constructor*{methodPrototypeIR_t_constructor <- methodPrototypeIR_t_constructor*}, methodPrototypeIR_t_method*{methodPrototypeIR_t_method <- methodPrototypeIR_t_method*})
  -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches _ :: _
  -- let methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} = methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
  -- let methodPrototypeIR' = methodPrototypeIR_h
  -- if methodPrototypeIR' matches `%%<,%>(%);`
  -- let _annotationList _nameIR <, _typeParameterListIR >( _parameterListIR ); = methodPrototypeIR'
  -- let (methodPrototypeIR_t_constructor*{methodPrototypeIR_t_constructor <- methodPrototypeIR_t_constructor*}, methodPrototypeIR_t_method*{methodPrototypeIR_t_method <- methodPrototypeIR_t_method*}) = $split_constructors_IR(methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*})

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:191.1-196.53
  clause 2(methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}) = (methodPrototypeIR_t_constructor*{methodPrototypeIR_t_constructor <- methodPrototypeIR_t_constructor*}, methodPrototypeIR_h :: methodPrototypeIR_t_method*{methodPrototypeIR_t_method <- methodPrototypeIR_t_method*})
  -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches _ :: _
  -- let methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} = methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
  -- let methodPrototypeIR' = methodPrototypeIR_h
  -- if methodPrototypeIR' matches `%%;`
  -- let _annotationList _functionPrototypeIR ; = methodPrototypeIR'
  -- let (methodPrototypeIR_t_constructor*{methodPrototypeIR_t_constructor <- methodPrototypeIR_t_constructor*}, methodPrototypeIR_t_method*{methodPrototypeIR_t_method <- methodPrototypeIR_t_method*}) = $split_constructors_IR(methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*})

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:197.1-202.53
  clause 3(methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}) = (methodPrototypeIR_t_constructor*{methodPrototypeIR_t_constructor <- methodPrototypeIR_t_constructor*}, methodPrototypeIR_h :: methodPrototypeIR_t_method*{methodPrototypeIR_t_method <- methodPrototypeIR_t_method*})
  -- if methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} matches _ :: _
  -- let methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*} = methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*}
  -- let methodPrototypeIR' = methodPrototypeIR_h
  -- if methodPrototypeIR' matches `%ABSTRACT%;`
  -- let _annotationList abstract _functionPrototypeIR ; = methodPrototypeIR'
  -- let (methodPrototypeIR_t_constructor*{methodPrototypeIR_t_constructor <- methodPrototypeIR_t_constructor*}, methodPrototypeIR_t_method*{methodPrototypeIR_t_method <- methodPrototypeIR_t_method*}) = $split_constructors_IR(methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*})
