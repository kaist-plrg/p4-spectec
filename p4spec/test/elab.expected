;; ../../../../spec-concrete/0-aux.watsup:18.1-18.21
def $sum(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:20.1-20.21
def $max(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:22.1-22.21
def $min(nat*) : nat =

;; ../../../../spec-concrete/0-aux.watsup:28.1-28.29
def $int_to_text(int) : text =

;; ../../../../spec-concrete/0-aux.watsup:30.1-30.31
def $concat_text(text*) : text =

  ;; ../../../../spec-concrete/0-aux.watsup:31.1-31.27
  clause 0(text*{text <- text*}) = ""
  -- if text*{text <- text*} matches []

  ;; ../../../../spec-concrete/0-aux.watsup:32.1-32.58
  clause 1(text*{text <- text*}) = t_h ++ $concat_text(t_t*{t_t <- t_t*})
  -- if text*{text <- text*} matches _ :: _
  -- let t_h :: t_t*{t_t <- t_t*} = text*{text <- text*}

;; ../../../../spec-concrete/0-aux.watsup:34.1-34.37
def $strip_prefix(text, text) : text =

;; ../../../../spec-concrete/0-aux.watsup:35.1-35.37
def $strip_suffix(text, text) : text =

;; ../../../../spec-concrete/0-aux.watsup:41.1-41.23
def $init_(nat) : nat* =

  ;; ../../../../spec-concrete/0-aux.watsup:42.1-42.20
  clause 0(nat) = []
  -- if (nat = 0)

  ;; ../../../../spec-concrete/0-aux.watsup:43.1-44.15
  clause 1(n) = (n - 1) :: $init_((n - 1))
  -- otherwise

;; ../../../../spec-concrete/0-aux.watsup:46.1-46.29
def $repeat_<X>(X, nat) : X* =

  ;; ../../../../spec-concrete/0-aux.watsup:47.1-47.28
  clause 0(X, nat) = []
  -- if (nat = 0)

  ;; ../../../../spec-concrete/0-aux.watsup:48.1-49.15
  clause 1(X, n) = [X] ++ $repeat_<X>(X, (n - 1))
  -- otherwise

;; ../../../../spec-concrete/0-aux.watsup:51.1-51.22
def $rev_<X>(X*) : X* =

;; ../../../../spec-concrete/0-aux.watsup:53.1-53.28
def $concat_<X>(X**) : X* =

;; ../../../../spec-concrete/0-aux.watsup:55.1-55.39
def $partition_<X>(X*, nat) : (X*, X*) =

;; ../../../../spec-concrete/0-aux.watsup:57.1-57.35
def $assoc_<X, Y>(X, (X, Y)*) : Y? =

;; ../../../../spec-concrete/0-aux.watsup:59.1-59.29
def $distinct_<K>(K*) : bool =

;; ../../../../spec-concrete/0-aux.watsup:65.17-65.24
syntax set<K> = 
   | { K* }

;; ../../../../spec-concrete/0-aux.watsup:67.1-67.27
def $empty_set<K> : set<K> =

  ;; ../../../../spec-concrete/0-aux.watsup:68.1-68.29
  clause 0 = { [] }

;; ../../../../spec-concrete/0-aux.watsup:70.1-70.33
def $in_set<K>(K, set<K>) : bool =

  ;; ../../../../spec-concrete/0-aux.watsup:71.1-71.41
  clause 0(K, { K_e*{K_e <- K_e*} }) = K <- K_e*{K_e <- K_e*}

;; ../../../../spec-concrete/0-aux.watsup:73.1-73.47
def $intersect_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:75.1-75.43
def $union_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:77.1-77.37
def $unions_set<K>(set<K>*) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:79.1-79.42
def $diff_set<K>(set<K>, set<K>) : set<K> =

;; ../../../../spec-concrete/0-aux.watsup:81.1-81.39
def $sub_set<K>(set<K>, set<K>) : bool =

;; ../../../../spec-concrete/0-aux.watsup:83.1-83.38
def $eq_set<K>(set<K>, set<K>) : bool =

;; ../../../../spec-concrete/0-aux.watsup:89.21-89.27
syntax pair<K, V> = 
   | K : V

;; ../../../../spec-concrete/0-aux.watsup:91.20-91.35
syntax map<K, V> = set<pair<K, V>>

;; ../../../../spec-concrete/0-aux.watsup:93.1-93.33
def $empty_map<K, V> : map<K, V> =

  ;; ../../../../spec-concrete/0-aux.watsup:94.1-94.32
  clause 0 = { [] }

;; ../../../../spec-concrete/0-aux.watsup:96.1-96.39
def $dom_map<K, V>(map<K, V>) : set<K> =

  ;; ../../../../spec-concrete/0-aux.watsup:97.1-97.45
  clause 0({ K : V*{K <- K*, V <- V*} }) = { K*{K <- K*} }

;; ../../../../spec-concrete/0-aux.watsup:99.1-99.39
def $find_map<K, V>(map<K, V>, K) : V? =

;; ../../../../spec-concrete/0-aux.watsup:101.1-101.41
def $find_maps<K, V>(map<K, V>*, K) : V? =

;; ../../../../spec-concrete/0-aux.watsup:103.1-103.48
def $add_map<K, V>(map<K, V>, K, V) : map<K, V> =

;; ../../../../spec-concrete/0-aux.watsup:105.1-105.51
def $adds_map<K, V>(map<K, V>, K*, V*) : map<K, V> =

;; ../../../../spec-concrete/0-aux.watsup:107.1-107.51
def $update_map<K, V>(map<K, V>, K, V) : map<K, V> =

;; ../../../../spec-concrete/1-syntax.watsup:6.1-7.7
syntax trailingCommaOpt = 
   | 
   | ,

;; ../../../../spec-concrete/1-syntax.watsup:14.1-15.10
syntax booleanLiteral = 
   | true
   | false

;; ../../../../spec-concrete/1-syntax.watsup:22.1-24.35
syntax numberLiteral = 
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)

;; ../../../../spec-concrete/1-syntax.watsup:30.24-30.57
syntax stringLiteral = 
   | " text " hint(print "#%#")

;; ../../../../spec-concrete/1-syntax.watsup:43.21-43.29
syntax identifier = 
   | text

;; ../../../../spec-concrete/1-syntax.watsup:44.25-44.34
syntax typeIdentifier = 
   | text

;; ../../../../spec-concrete/1-syntax.watsup:51.1-53.30
syntax nonTypeName = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority

;; ../../../../spec-concrete/1-syntax.watsup:56.1-57.23
syntax prefixedNonTypeName = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName

;; ../../../../spec-concrete/1-syntax.watsup:63.19-63.33
syntax typeName = typeIdentifier

;; ../../../../spec-concrete/1-syntax.watsup:66.1-67.21
syntax prefixedTypeName = 
   | text
   | . typeName

;; ../../../../spec-concrete/1-syntax.watsup:74.1-76.36
syntax tableCustomName = 
   | text
   | text
   | apply
   | state
   | type
   | priority

;; ../../../../spec-concrete/1-syntax.watsup:83.1-85.9
syntax name = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list

;; ../../../../spec-concrete/1-syntax.watsup:88.1-89.21
syntax nameList = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list
   | nameList , name

;; ../../../../spec-concrete/1-syntax.watsup:91.1-91.40
def $flatten_nameList(nameList) : name* =

  ;; ../../../../spec-concrete/1-syntax.watsup:92.1-92.35
  clause 0(nameList) = [name]
  -- if nameList <: name
  -- let name = nameList as name

  ;; ../../../../spec-concrete/1-syntax.watsup:93.1-94.42
  clause 1(nameList') = $flatten_nameList(nameList) ++ [name]
  -- if nameList' matches `%,%`
  -- let nameList , name = nameList'

;; ../../../../spec-concrete/1-syntax.watsup:96.17-96.21
syntax member = name

;; ../../../../spec-concrete/1-syntax.watsup:102.20-102.45
syntax direction = 
   | 
   | in
   | out
   | inout

;; ../../../../spec-concrete/1-syntax.watsup:115.1-126.32
syntax baseType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>

;; ../../../../spec-concrete/1-syntax.watsup:134.26-134.64
syntax specializedType = 
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:137.1-138.20
syntax namedType = 
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:144.26-144.51
syntax headerStackType = 
   | namedType [ expression ]

;; ../../../../spec-concrete/1-syntax.watsup:152.19-152.41
syntax listType = 
   | list< typeArgument >

;; ../../../../spec-concrete/1-syntax.watsup:158.20-158.47
syntax tupleType = 
   | tuple< typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:165.1-169.14
syntax type = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:172.1-174.15
syntax typeOrVoid = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | text

;; ../../../../spec-concrete/1-syntax.watsup:180.24-180.28
syntax typeParameter = name

;; ../../../../spec-concrete/1-syntax.watsup:183.1-184.39
syntax typeParameterList = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list
   | typeParameterList , typeParameter

;; ../../../../spec-concrete/1-syntax.watsup:186.1-186.67
def $flatten_typeParameterList(typeParameterList) : typeParameter* =

  ;; ../../../../spec-concrete/1-syntax.watsup:187.1-187.62
  clause 0(typeParameterList) = [typeParameter]
  -- if typeParameterList <: typeParameter
  -- let typeParameter = typeParameterList as typeParameter

  ;; ../../../../spec-concrete/1-syntax.watsup:188.1-189.69
  clause 1(typeParameterList') = $flatten_typeParameterList(typeParameterList) ++ [typeParameter]
  -- if typeParameterList' matches `%,%`
  -- let typeParameterList , typeParameter = typeParameterList'

;; ../../../../spec-concrete/1-syntax.watsup:192.1-193.27
syntax typeParameterListOpt = 
   | 
   | < typeParameterList >

;; ../../../../spec-concrete/1-syntax.watsup:195.1-195.73
def $flatten_typeParameterListOpt(typeParameterListOpt) : typeParameter* =

  ;; ../../../../spec-concrete/1-syntax.watsup:196.1-196.48
  clause 0(typeParameterListOpt) = []
  -- if typeParameterListOpt matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:197.1-198.50
  clause 1(typeParameterListOpt) = $flatten_typeParameterList(typeParameterList)
  -- if typeParameterListOpt matches `<%>`
  -- let < typeParameterList > = typeParameterListOpt

;; ../../../../spec-concrete/1-syntax.watsup:207.3-207.52
syntax parameter = 
   | annotationList direction type name initializerOpt

;; ../../../../spec-concrete/1-syntax.watsup:210.1-211.39
syntax nonEmptyParameterList = 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList , parameter

;; ../../../../spec-concrete/1-syntax.watsup:214.1-215.26
syntax parameterList = 
   | 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList , parameter

;; ../../../../spec-concrete/1-syntax.watsup:217.1-217.55
def $flatten_parameterList(parameterList) : parameter* =

  ;; ../../../../spec-concrete/1-syntax.watsup:218.1-218.41
  clause 0(parameterList) = []
  -- if parameterList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:219.1-219.50
  clause 1(parameterList) = [parameter]
  -- if parameterList <: parameter
  -- let parameter = parameterList as parameter

  ;; ../../../../spec-concrete/1-syntax.watsup:220.1-221.67
  clause 2(parameterList) = $flatten_parameterList(nonEmptyParameterList as parameterList) ++ [parameter]
  -- if parameterList <: nonEmptyParameterList
  -- let nonEmptyParameterList' = parameterList as nonEmptyParameterList
  -- if nonEmptyParameterList' matches `%,%`
  -- let nonEmptyParameterList , parameter = nonEmptyParameterList'

;; ../../../../spec-concrete/1-syntax.watsup:227.31-227.40
syntax constructorParameter = parameter

;; ../../../../spec-concrete/1-syntax.watsup:229.35-229.48
syntax constructorParameterList = parameterList

;; ../../../../spec-concrete/1-syntax.watsup:232.1-233.23
syntax constructorParameterListOpt = 
   | 
   | ( parameterList )

;; ../../../../spec-concrete/1-syntax.watsup:235.1-236.26
def $flatten_constructorParameterListOpt(constructorParameterListOpt) : constructorParameter* =

  ;; ../../../../spec-concrete/1-syntax.watsup:238.1-238.55
  clause 0(constructorParameterListOpt) = []
  -- if constructorParameterListOpt matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:239.1-240.42
  clause 1(constructorParameterListOpt) = $flatten_parameterList(parameterList)
  -- if constructorParameterListOpt matches `(%)`
  -- let ( parameterList ) = constructorParameterListOpt

;; ../../../../spec-concrete/1-syntax.watsup:246.26-246.44
syntax namedExpression = 
   | name = expression

;; ../../../../spec-concrete/1-syntax.watsup:249.1-250.43
syntax namedExpressionList = 
   | name = expression
   | namedExpressionList , namedExpression

;; ../../../../spec-concrete/1-syntax.watsup:252.1-252.73
def $flatten_namedExpressionList(namedExpressionList) : namedExpression* =

  ;; ../../../../spec-concrete/1-syntax.watsup:253.1-253.68
  clause 0(namedExpressionList) = [namedExpression]
  -- if namedExpressionList <: namedExpression
  -- let namedExpression = namedExpressionList as namedExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:254.1-255.75
  clause 1(namedExpressionList') = $flatten_namedExpressionList(namedExpressionList) ++ [namedExpression]
  -- if namedExpressionList' matches `%,%`
  -- let namedExpressionList , namedExpression = namedExpressionList'

;; ../../../../spec-concrete/1-syntax.watsup:266.1-268.18
syntax literalExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")

;; ../../../../spec-concrete/1-syntax.watsup:275.1-276.9
syntax referenceExpression = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this

;; ../../../../spec-concrete/1-syntax.watsup:282.28-282.32
syntax defaultExpression = 
   | ...

;; ../../../../spec-concrete/1-syntax.watsup:290.15-290.32
syntax unop = 
   | !
   | ~
   | -
   | +

;; ../../../../spec-concrete/1-syntax.watsup:292.26-292.41
syntax unaryExpression = 
   | unop expression

;; ../../../../spec-concrete/1-syntax.watsup:295.1-297.35
syntax binop = 
   | *
   | /
   | %
   | +
   | -
   | |+|
   | |-|
   | <<
   | >>
   | <=
   | >=
   | <
   | >
   | !=
   | ==
   | &
   | ^
   | |
   | ++
   | &&
   | ||

;; ../../../../spec-concrete/1-syntax.watsup:299.27-299.54
syntax binaryExpression = 
   | expression binop expression

;; ../../../../spec-concrete/1-syntax.watsup:302.3-302.38
syntax binaryExpressionNonBrace = 
   | expressionNonBrace binop expression

;; ../../../../spec-concrete/1-syntax.watsup:305.3-305.41
syntax ternaryExpression = 
   | expression ? expression : expression

;; ../../../../spec-concrete/1-syntax.watsup:308.3-308.49
syntax ternaryExpressionNonBrace = 
   | expressionNonBrace ? expression : expression

;; ../../../../spec-concrete/1-syntax.watsup:314.25-314.45
syntax castExpression = 
   | ( type ) expression

;; ../../../../spec-concrete/1-syntax.watsup:323.1-324.48
syntax dataExpression = 
   | {#}
   | { dataElementExpression trailingCommaOpt }

;; ../../../../spec-concrete/1-syntax.watsup:333.3-333.18
syntax errorAccessExpression = 
   | error. member

;; ../../../../spec-concrete/1-syntax.watsup:336.3-336.29
syntax memberAccessExpression = 
   | memberAccessBase . member

;; ../../../../spec-concrete/1-syntax.watsup:339.1-340.45
syntax indexAccessExpression = 
   | expression [ expression ]
   | expression [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:343.1-345.26
syntax accessExpression = 
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:348.3-348.37
syntax memberAccessExpressionNonBrace = 
   | memberAccessBaseNonBrace . member

;; ../../../../spec-concrete/1-syntax.watsup:351.1-352.53
syntax indexAccessExpressionNonBrace = 
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:355.1-357.34
syntax accessExpressionNonBrace = 
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:371.1-372.62
syntax callExpression = 
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )

;; ../../../../spec-concrete/1-syntax.watsup:375.1-376.70
syntax callExpressionNonBrace = 
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )

;; ../../../../spec-concrete/1-syntax.watsup:382.34-382.49
syntax parenthesizedExpression = 
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:389.1-399.28
syntax expression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:403.1-405.33
syntax expressionList = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expressionList , expression

;; ../../../../spec-concrete/1-syntax.watsup:407.1-407.58
def $flatten_expressionList(expressionList) : expression* =

  ;; ../../../../spec-concrete/1-syntax.watsup:408.1-408.42
  clause 0(expressionList) = []
  -- if expressionList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:409.1-409.53
  clause 1(expressionList) = [expression]
  -- if expressionList <: expression
  -- let expression = expressionList as expression

  ;; ../../../../spec-concrete/1-syntax.watsup:410.1-411.60
  clause 2(expressionList') = $flatten_expressionList(expressionList) ++ [expression]
  -- if expressionList' matches `%,%`
  -- let expressionList , expression = expressionList'

;; ../../../../spec-concrete/1-syntax.watsup:414.1-415.15
syntax memberAccessBase = 
   | text
   | . typeName
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:417.36-417.50
syntax sequenceElementExpression = expressionList

;; ../../../../spec-concrete/1-syntax.watsup:420.1-423.54
syntax recordElementExpression = 
   | name = expression
   | name = expression ,...
   | name = expression , namedExpressionList
   | name = expression , namedExpressionList ,...

;; ../../../../spec-concrete/1-syntax.watsup:426.1-427.28
syntax dataElementExpression = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expressionList , expression
   | name = expression
   | name = expression ,...
   | name = expression , namedExpressionList
   | name = expression , namedExpressionList ,...

;; ../../../../spec-concrete/1-syntax.watsup:429.24-429.34
syntax routineTarget = expression

;; ../../../../spec-concrete/1-syntax.watsup:430.28-430.37
syntax constructorTarget = namedType

;; ../../../../spec-concrete/1-syntax.watsup:433.1-434.22
syntax callTarget = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:441.1-449.28
syntax expressionNonBrace = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:452.1-453.23
syntax memberAccessBaseNonBrace = 
   | text
   | . typeName
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:455.32-455.50
syntax routineTargetNonBrace = expressionNonBrace

;; ../../../../spec-concrete/1-syntax.watsup:458.1-459.22
syntax callTargetNonBrace = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:461.1-461.57
def $expressionNonBrace(expressionNonBrace) : expression =

  ;; ../../../../spec-concrete/1-syntax.watsup:462.1-462.63
  clause 0(expressionNonBrace) = literalExpression as expression
  -- if expressionNonBrace <: literalExpression
  -- let literalExpression = expressionNonBrace as literalExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:463.1-463.67
  clause 1(expressionNonBrace) = referenceExpression as expression
  -- if expressionNonBrace <: referenceExpression
  -- let referenceExpression = expressionNonBrace as referenceExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:464.1-464.59
  clause 2(expressionNonBrace) = unaryExpression as expression
  -- if expressionNonBrace <: unaryExpression
  -- let unaryExpression = expressionNonBrace as unaryExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:465.1-469.65
  clause 3(expressionNonBrace) = expression_l binop expression_r as expression
  -- if expressionNonBrace <: binaryExpressionNonBrace
  -- let expressionNonBrace_l binop expression_r = expressionNonBrace as binaryExpressionNonBrace
  -- let expression_l = $expressionNonBrace(expressionNonBrace_l)

  ;; ../../../../spec-concrete/1-syntax.watsup:470.1-474.71
  clause 4(expressionNonBrace) = expression_cond ? expression_true : expression_false as expression
  -- if expressionNonBrace <: ternaryExpressionNonBrace
  -- let expressionNonBrace_cond ? expression_true : expression_false = expressionNonBrace as ternaryExpressionNonBrace
  -- let expression_cond = $expressionNonBrace(expressionNonBrace_cond)

  ;; ../../../../spec-concrete/1-syntax.watsup:475.1-475.57
  clause 5(expressionNonBrace) = castExpression as expression
  -- if expressionNonBrace <: castExpression
  -- let castExpression = expressionNonBrace as castExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:476.1-476.71
  clause 6(expressionNonBrace) = errorAccessExpression as expression
  -- if expressionNonBrace <: errorAccessExpression
  -- let errorAccessExpression = expressionNonBrace as errorAccessExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:477.1-478.31
  clause 7(expressionNonBrace) = prefixedTypeName as memberAccessBase . member as expression
  -- if expressionNonBrace <: memberAccessExpressionNonBrace
  -- let memberAccessBaseNonBrace . member = expressionNonBrace as memberAccessExpressionNonBrace
  -- if memberAccessBaseNonBrace <: prefixedTypeName
  -- let prefixedTypeName = memberAccessBaseNonBrace as prefixedTypeName

  ;; ../../../../spec-concrete/1-syntax.watsup:479.1-481.71
  clause 8(expressionNonBrace) = expression_base as memberAccessBase . member as expression
  -- if expressionNonBrace <: memberAccessExpressionNonBrace
  -- let memberAccessBaseNonBrace . member = expressionNonBrace as memberAccessExpressionNonBrace
  -- if memberAccessBaseNonBrace <: expressionNonBrace
  -- let expressionNonBrace_base = memberAccessBaseNonBrace as expressionNonBrace
  -- let expression_base = $expressionNonBrace(expressionNonBrace_base)

  ;; ../../../../spec-concrete/1-syntax.watsup:482.1-486.71
  clause 9(expressionNonBrace) = expression_base [ expression_index ] as expression
  -- if expressionNonBrace <: indexAccessExpressionNonBrace
  -- let indexAccessExpressionNonBrace = expressionNonBrace as indexAccessExpressionNonBrace
  -- if indexAccessExpressionNonBrace matches `%[%]`
  -- let expressionNonBrace_base [ expression_index ] = indexAccessExpressionNonBrace
  -- let expression_base = $expressionNonBrace(expressionNonBrace_base)

  ;; ../../../../spec-concrete/1-syntax.watsup:487.1-491.71
  clause 10(expressionNonBrace) = expression_base [ expression_hi : expression_lo ] as expression
  -- if expressionNonBrace <: indexAccessExpressionNonBrace
  -- let indexAccessExpressionNonBrace = expressionNonBrace as indexAccessExpressionNonBrace
  -- if indexAccessExpressionNonBrace matches `%[%:%]`
  -- let expressionNonBrace_base [ expression_hi : expression_lo ] = indexAccessExpressionNonBrace
  -- let expression_base = $expressionNonBrace(expressionNonBrace_base)

  ;; ../../../../spec-concrete/1-syntax.watsup:492.1-496.61
  clause 11(expressionNonBrace') = expression as callTarget ( argumentList ) as expression
  -- if expressionNonBrace' <: callExpressionNonBrace
  -- let callExpressionNonBrace = expressionNonBrace' as callExpressionNonBrace
  -- if callExpressionNonBrace matches `%(%)`
  -- let callTargetNonBrace ( argumentList ) = callExpressionNonBrace
  -- if callTargetNonBrace <: expressionNonBrace
  -- let expressionNonBrace = callTargetNonBrace as expressionNonBrace
  -- let expression = $expressionNonBrace(expressionNonBrace)

  ;; ../../../../spec-concrete/1-syntax.watsup:497.1-500.40
  clause 12(expressionNonBrace) = constructorTarget as callTarget ( argumentList ) as expression
  -- if expressionNonBrace <: callExpressionNonBrace
  -- let callExpressionNonBrace = expressionNonBrace as callExpressionNonBrace
  -- if callExpressionNonBrace matches `%(%)`
  -- let callTargetNonBrace ( argumentList ) = callExpressionNonBrace
  -- if callTargetNonBrace <: constructorTarget
  -- let constructorTarget = callTargetNonBrace as constructorTarget

  ;; ../../../../spec-concrete/1-syntax.watsup:501.1-505.61
  clause 13(expressionNonBrace') = expression < realTypeArgumentList >( argumentList ) as expression
  -- if expressionNonBrace' <: callExpressionNonBrace
  -- let callExpressionNonBrace = expressionNonBrace' as callExpressionNonBrace
  -- if callExpressionNonBrace matches `%<%>(%)`
  -- let expressionNonBrace < realTypeArgumentList >( argumentList ) = callExpressionNonBrace
  -- let expression = $expressionNonBrace(expressionNonBrace)

  ;; ../../../../spec-concrete/1-syntax.watsup:506.1-506.75
  clause 14(expressionNonBrace) = parenthesizedExpression as expression
  -- if expressionNonBrace <: parenthesizedExpression
  -- let parenthesizedExpression = expressionNonBrace as parenthesizedExpression

;; ../../../../spec-concrete/1-syntax.watsup:513.1-517.7
syntax simpleKeysetExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _

;; ../../../../spec-concrete/1-syntax.watsup:520.1-521.57
syntax simpleKeysetExpressionList = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _
   | simpleKeysetExpressionList , simpleKeysetExpression

;; ../../../../spec-concrete/1-syntax.watsup:523.1-524.28
def $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList) : simpleKeysetExpression* =

  ;; ../../../../spec-concrete/1-syntax.watsup:525.1-526.27
  clause 0(simpleKeysetExpressionList) = [simpleKeysetExpression]
  -- if simpleKeysetExpressionList <: simpleKeysetExpression
  -- let simpleKeysetExpression = simpleKeysetExpressionList as simpleKeysetExpression

  ;; ../../../../spec-concrete/1-syntax.watsup:527.1-531.34
  clause 1(simpleKeysetExpressionList') = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList) ++ [simpleKeysetExpression]
  -- if simpleKeysetExpressionList' matches `%,%`
  -- let simpleKeysetExpressionList , simpleKeysetExpression = simpleKeysetExpressionList'

;; ../../../../spec-concrete/1-syntax.watsup:534.1-538.62
syntax tupleKeysetExpression = 
   | ( expression &&& expression )
   | ( expression .. expression )
   | (default)
   | (_)
   | ( simpleKeysetExpression , simpleKeysetExpressionList )

;; ../../../../spec-concrete/1-syntax.watsup:541.1-542.26
syntax keysetExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _
   | ( expression &&& expression )
   | ( expression .. expression )
   | (default)
   | (_)
   | ( simpleKeysetExpression , simpleKeysetExpressionList )

;; ../../../../spec-concrete/1-syntax.watsup:549.1-551.7
syntax realTypeArgument = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _

;; ../../../../spec-concrete/1-syntax.watsup:554.1-555.45
syntax realTypeArgumentList = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | realTypeArgumentList , realTypeArgument

;; ../../../../spec-concrete/1-syntax.watsup:557.1-557.76
def $flatten_realTypeArgumentList(realTypeArgumentList) : realTypeArgument* =

  ;; ../../../../spec-concrete/1-syntax.watsup:558.1-558.71
  clause 0(realTypeArgumentList) = [realTypeArgument]
  -- if realTypeArgumentList <: realTypeArgument
  -- let realTypeArgument = realTypeArgumentList as realTypeArgument

  ;; ../../../../spec-concrete/1-syntax.watsup:559.1-560.78
  clause 1(realTypeArgumentList') = $flatten_realTypeArgumentList(realTypeArgumentList) ++ [realTypeArgument]
  -- if realTypeArgumentList' matches `%,%`
  -- let realTypeArgumentList , realTypeArgument = realTypeArgumentList'

;; ../../../../spec-concrete/1-syntax.watsup:563.1-564.16
syntax typeArgument = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority

;; ../../../../spec-concrete/1-syntax.watsup:568.1-570.37
syntax typeArgumentList = 
   | 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | typeArgumentList , typeArgument

;; ../../../../spec-concrete/1-syntax.watsup:572.1-572.64
def $flatten_typeArgumentList(typeArgumentList) : typeArgument* =

  ;; ../../../../spec-concrete/1-syntax.watsup:573.1-573.44
  clause 0(typeArgumentList) = []
  -- if typeArgumentList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:574.1-574.59
  clause 1(typeArgumentList) = [typeArgument]
  -- if typeArgumentList <: typeArgument
  -- let typeArgument = typeArgumentList as typeArgument

  ;; ../../../../spec-concrete/1-syntax.watsup:575.1-576.66
  clause 2(typeArgumentList') = $flatten_typeArgumentList(typeArgumentList) ++ [typeArgument]
  -- if typeArgumentList' matches `%,%`
  -- let typeArgumentList , typeArgument = typeArgumentList'

;; ../../../../spec-concrete/1-syntax.watsup:583.1-586.7
syntax argument = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _

;; ../../../../spec-concrete/1-syntax.watsup:589.1-590.37
syntax argumentListNonEmpty = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _
   | argumentListNonEmpty , argument

;; ../../../../spec-concrete/1-syntax.watsup:593.1-594.25
syntax argumentList = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _
   | argumentListNonEmpty , argument

;; ../../../../spec-concrete/1-syntax.watsup:596.1-596.52
def $flatten_argumentList(argumentList) : argument* =

  ;; ../../../../spec-concrete/1-syntax.watsup:597.1-597.40
  clause 0(argumentList) = []
  -- if argumentList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:598.1-598.47
  clause 1(argumentList) = [argument]
  -- if argumentList <: argument
  -- let argument = argumentList as argument

  ;; ../../../../spec-concrete/1-syntax.watsup:599.1-600.62
  clause 2(argumentList) = $flatten_argumentList(argumentListNonEmpty as argumentList) ++ [argument]
  -- if argumentList <: argumentListNonEmpty
  -- let argumentListNonEmpty' = argumentList as argumentListNonEmpty
  -- if argumentListNonEmpty' matches `%,%`
  -- let argumentListNonEmpty , argument = argumentListNonEmpty'

;; ../../../../spec-concrete/1-syntax.watsup:607.1-611.16
syntax lvalue = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | lvalue . member
   | lvalue [ expression ]
   | lvalue [ expression : expression ]
   | ( lvalue )

;; ../../../../spec-concrete/1-syntax.watsup:621.25-621.27
syntax emptyStatement = 
   | ;

;; ../../../../spec-concrete/1-syntax.watsup:628.1-630.34
syntax assignop = 
   | =
   | +=
   | -=
   | |+|=
   | |-|=
   | *=
   | /=
   | %=
   | <<=
   | >>=
   | &=
   | ^=
   | |=

;; ../../../../spec-concrete/1-syntax.watsup:632.30-632.59
syntax assignmentStatement = 
   | lvalue assignop expression ;

;; ../../../../spec-concrete/1-syntax.watsup:639.1-640.54
syntax callStatement = 
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );

;; ../../../../spec-concrete/1-syntax.watsup:646.37-646.76
syntax directApplicationStatement = 
   | namedType .apply( argumentList );

;; ../../../../spec-concrete/1-syntax.watsup:653.1-654.25
syntax returnStatement = 
   | return;
   | return expression ;

;; ../../../../spec-concrete/1-syntax.watsup:660.24-660.31
syntax exitStatement = 
   | exit;

;; ../../../../spec-concrete/1-syntax.watsup:668.25-668.70
syntax blockStatement = 
   | annotationList { blockElementStatementList }

;; ../../../../spec-concrete/1-syntax.watsup:677.1-678.48
syntax conditionalStatement = 
   | if( expression ) statement
   | if( expression ) statement else statement

;; ../../../../spec-concrete/1-syntax.watsup:687.1-690.31
syntax forInitStatement = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression

;; ../../../../spec-concrete/1-syntax.watsup:693.1-694.53
syntax forInitStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forInitStatementListNonEmpty , forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:697.1-698.33
syntax forInitStatementList = 
   | 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forInitStatementListNonEmpty , forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:700.29-700.45
syntax forUpdateStatement = forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:703.1-704.57
syntax forUpdateStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty , forUpdateStatement

;; ../../../../spec-concrete/1-syntax.watsup:707.1-708.35
syntax forUpdateStatementList = 
   | 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty , forUpdateStatement

;; ../../../../spec-concrete/1-syntax.watsup:711.1-712.30
syntax forCollectionExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression .. expression

;; ../../../../spec-concrete/1-syntax.watsup:715.1-720.81
syntax forStatement = 
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement

;; ../../../../spec-concrete/1-syntax.watsup:727.1-728.23
syntax switchLabel = 
   | default
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:731.1-732.19
syntax switchCase = 
   | switchLabel : blockStatement
   | switchLabel :

;; ../../../../spec-concrete/1-syntax.watsup:735.1-736.30
syntax switchCaseList = 
   | 
   | switchCaseList switchCase

;; ../../../../spec-concrete/1-syntax.watsup:738.1-738.58
def $flatten_switchCaseList(switchCaseList) : switchCase* =

  ;; ../../../../spec-concrete/1-syntax.watsup:739.1-739.42
  clause 0(switchCaseList) = []
  -- if switchCaseList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:740.1-741.62
  clause 1(switchCaseList') = $flatten_switchCaseList(switchCaseList) ++ [switchCase]
  -- if switchCaseList' matches `%%`
  -- let switchCaseList switchCase = switchCaseList'

;; ../../../../spec-concrete/1-syntax.watsup:743.26-743.68
syntax switchStatement = 
   | switch( expression ){ switchCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:749.25-749.33
syntax breakStatement = 
   | break;

;; ../../../../spec-concrete/1-syntax.watsup:751.28-751.39
syntax continueStatement = 
   | continue;

;; ../../../../spec-concrete/1-syntax.watsup:758.1-769.20
syntax statement = 
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | return;
   | return expression ;
   | exit;
   | annotationList { blockElementStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement
   | break;
   | continue;
   | switch( expression ){ switchCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:779.22-779.35
syntax initializer = 
   | = expression

;; ../../../../spec-concrete/1-syntax.watsup:782.3-782.48
syntax constantDeclaration = 
   | annotationList const type name initializer ;

;; ../../../../spec-concrete/1-syntax.watsup:785.1-786.16
syntax initializerOpt = 
   | 
   | = expression

;; ../../../../spec-concrete/1-syntax.watsup:789.3-789.45
syntax variableDeclaration = 
   | annotationList type name initializerOpt ;

;; ../../../../spec-concrete/1-syntax.watsup:792.1-794.14
syntax blockElementStatement = 
   | annotationList const type name initializer ;
   | annotationList type name initializerOpt ;
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | return;
   | return expression ;
   | exit;
   | annotationList { blockElementStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement
   | break;
   | continue;
   | switch( expression ){ switchCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:797.1-798.52
syntax blockElementStatementList = 
   | 
   | blockElementStatementList blockElementStatement

;; ../../../../spec-concrete/1-syntax.watsup:800.1-801.27
def $flatten_blockElementStatementList(blockElementStatementList) : blockElementStatement* =

  ;; ../../../../spec-concrete/1-syntax.watsup:802.1-802.53
  clause 0(blockElementStatementList) = []
  -- if blockElementStatementList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:803.1-807.30
  clause 1(blockElementStatementList') = $flatten_blockElementStatementList(blockElementStatementList) ++ [blockElementStatement]
  -- if blockElementStatementList' matches `%%`
  -- let blockElementStatementList blockElementStatement = blockElementStatementList'

;; ../../../../spec-concrete/1-syntax.watsup:814.3-814.58
syntax functionPrototype = 
   | typeOrVoid name typeParameterListOpt ( parameterList )

;; ../../../../spec-concrete/1-syntax.watsup:817.3-817.50
syntax functionDeclaration = 
   | annotationList functionPrototype blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:824.3-824.63
syntax actionDeclaration = 
   | annotationList action name ( parameterList ) blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:832.28-832.57
syntax objectInitializer = 
   | ={ objectDeclarationList }

;; ../../../../spec-concrete/1-syntax.watsup:836.1-837.68
syntax instantiation = 
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;

;; ../../../../spec-concrete/1-syntax.watsup:840.1-841.18
syntax objectDeclaration = 
   | annotationList functionPrototype blockStatement
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;

;; ../../../../spec-concrete/1-syntax.watsup:844.1-845.44
syntax objectDeclarationList = 
   | 
   | objectDeclarationList objectDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:847.1-847.79
def $flatten_objectDeclarationList(objectDeclarationList) : objectDeclaration* =

  ;; ../../../../spec-concrete/1-syntax.watsup:848.1-848.49
  clause 0(objectDeclarationList) = []
  -- if objectDeclarationList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:849.1-853.29
  clause 1(objectDeclarationList') = $flatten_objectDeclarationList(objectDeclarationList) ++ [objectDeclaration]
  -- if objectDeclarationList' matches `%%`
  -- let objectDeclarationList objectDeclaration = objectDeclarationList'

;; ../../../../spec-concrete/1-syntax.watsup:859.27-859.46
syntax errorDeclaration = 
   | error{ nameList }

;; ../../../../spec-concrete/1-syntax.watsup:865.31-865.72
syntax matchKindDeclaration = 
   | match_kind{ nameList trailingCommaOpt }

;; ../../../../spec-concrete/1-syntax.watsup:876.1-877.76
syntax enumTypeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }

;; ../../../../spec-concrete/1-syntax.watsup:883.20-883.47
syntax typeField = 
   | annotationList type name ;

;; ../../../../spec-concrete/1-syntax.watsup:886.1-887.28
syntax typeFieldList = 
   | 
   | typeFieldList typeField

;; ../../../../spec-concrete/1-syntax.watsup:889.1-889.55
def $flatten_typeFieldList(typeFieldList) : typeField* =

  ;; ../../../../spec-concrete/1-syntax.watsup:890.1-890.41
  clause 0(typeFieldList) = []
  -- if typeFieldList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:891.1-892.59
  clause 1(typeFieldList') = $flatten_typeFieldList(typeFieldList) ++ [typeField]
  -- if typeFieldList' matches `%%`
  -- let typeFieldList typeField = typeFieldList'

;; ../../../../spec-concrete/1-syntax.watsup:895.3-895.69
syntax structTypeDeclaration = 
   | annotationList struct name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:898.3-898.69
syntax headerTypeDeclaration = 
   | annotationList header name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:901.3-901.75
syntax headerUnionTypeDeclaration = 
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:904.1-907.31
syntax derivedTypeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:914.1-915.27
syntax typedefType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:918.1-919.37
syntax typedefDeclaration = 
   | annotationList typedef typedefType name ;
   | annotationList type type name ;

;; ../../../../spec-concrete/1-syntax.watsup:926.3-926.45
syntax externFunctionDeclaration = 
   | annotationList extern functionPrototype ;

;; ../../../../spec-concrete/1-syntax.watsup:929.1-931.49
syntax methodPrototype = 
   | annotationList typeIdentifier ( parameterList );
   | annotationList functionPrototype ;
   | annotationList abstract functionPrototype ;

;; ../../../../spec-concrete/1-syntax.watsup:934.1-935.40
syntax methodPrototypeList = 
   | 
   | methodPrototypeList methodPrototype

;; ../../../../spec-concrete/1-syntax.watsup:937.1-937.73
def $flatten_methodPrototypeList(methodPrototypeList) : methodPrototype* =

  ;; ../../../../spec-concrete/1-syntax.watsup:938.1-938.47
  clause 0(methodPrototypeList) = []
  -- if methodPrototypeList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:939.1-942.77
  clause 1(methodPrototypeList') = $flatten_methodPrototypeList(methodPrototypeList) ++ [methodPrototype]
  -- if methodPrototypeList' matches `%%`
  -- let methodPrototypeList methodPrototype = methodPrototypeList'

;; ../../../../spec-concrete/1-syntax.watsup:945.3-945.82
syntax externObjectDeclaration = 
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }

;; ../../../../spec-concrete/1-syntax.watsup:948.1-949.28
syntax externDeclaration = 
   | annotationList extern functionPrototype ;
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }

;; ../../../../spec-concrete/1-syntax.watsup:959.21-959.48
syntax selectCase = 
   | keysetExpression : name ;

;; ../../../../spec-concrete/1-syntax.watsup:962.1-963.30
syntax selectCaseList = 
   | 
   | selectCaseList selectCase

;; ../../../../spec-concrete/1-syntax.watsup:965.1-965.58
def $flatten_selectCaseList(selectCaseList) : selectCase* =

  ;; ../../../../spec-concrete/1-syntax.watsup:966.1-966.42
  clause 0(selectCaseList) = []
  -- if selectCaseList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:967.1-968.62
  clause 1(selectCaseList') = $flatten_selectCaseList(selectCaseList) ++ [selectCase]
  -- if selectCaseList' matches `%%`
  -- let selectCaseList selectCase = selectCaseList'

;; ../../../../spec-concrete/1-syntax.watsup:970.27-970.73
syntax selectExpression = 
   | select( expressionList ){ selectCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:977.1-978.21
syntax stateExpression = 
   | name ;
   | select( expressionList ){ selectCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:981.1-982.31
syntax transitionStatement = 
   | 
   | transition stateExpression

;; ../../../../spec-concrete/1-syntax.watsup:989.1-991.21
syntax valueSetType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | tuple< typeArgumentList >
   | text
   | . typeName

;; ../../../../spec-concrete/1-syntax.watsup:994.3-994.69
syntax valueSetDeclaration = 
   | annotationList value_set< valueSetType >( expression ) name ;

;; ../../../../spec-concrete/1-syntax.watsup:1001.3-1001.72
syntax parserTypeDeclaration = 
   | annotationList parser name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1009.31-1009.70
syntax parserBlockStatement = 
   | annotationList { parserStatementList }

;; ../../../../spec-concrete/1-syntax.watsup:1012.1-1019.25
syntax parserStatement = 
   | annotationList const type name initializer ;
   | annotationList type name initializerOpt ;
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | annotationList { parserStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement

;; ../../../../spec-concrete/1-syntax.watsup:1022.1-1023.40
syntax parserStatementList = 
   | 
   | parserStatementList parserStatement

;; ../../../../spec-concrete/1-syntax.watsup:1025.1-1025.73
def $flatten_parserStatementList(parserStatementList) : parserStatement* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1026.1-1026.47
  clause 0(parserStatementList) = []
  -- if parserStatementList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1027.1-1028.77
  clause 1(parserStatementList') = $flatten_parserStatementList(parserStatementList) ++ [parserStatement]
  -- if parserStatementList' matches `%%`
  -- let parserStatementList parserStatement = parserStatementList'

;; ../../../../spec-concrete/1-syntax.watsup:1031.3-1031.73
syntax parserState = 
   | annotationList state name { parserStatementList transitionStatement }

;; ../../../../spec-concrete/1-syntax.watsup:1034.1-1035.32
syntax parserStateList = 
   | annotationList state name { parserStatementList transitionStatement }
   | parserStateList parserState

;; ../../../../spec-concrete/1-syntax.watsup:1037.1-1037.61
def $flatten_parserStateList(parserStateList) : parserState* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1038.1-1038.56
  clause 0(parserStateList) = [parserState]
  -- if parserStateList <: parserState
  -- let parserState = parserStateList as parserState

  ;; ../../../../spec-concrete/1-syntax.watsup:1039.1-1040.65
  clause 1(parserStateList') = $flatten_parserStateList(parserStateList) ++ [parserState]
  -- if parserStateList' matches `%%`
  -- let parserStateList parserState = parserStateList'

;; ../../../../spec-concrete/1-syntax.watsup:1043.1-1046.24
syntax parserLocalDeclaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList type name initializerOpt ;
   | annotationList value_set< valueSetType >( expression ) name ;

;; ../../../../spec-concrete/1-syntax.watsup:1049.1-1050.54
syntax parserLocalDeclarationList = 
   | 
   | parserLocalDeclarationList parserLocalDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:1052.1-1053.28
def $flatten_parserLocalDeclarationList(parserLocalDeclarationList) : parserLocalDeclaration* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1054.1-1054.54
  clause 0(parserLocalDeclarationList) = []
  -- if parserLocalDeclarationList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1055.1-1059.34
  clause 1(parserLocalDeclarationList') = $flatten_parserLocalDeclarationList(parserLocalDeclarationList) ++ [parserLocalDeclaration]
  -- if parserLocalDeclarationList' matches `%%`
  -- let parserLocalDeclarationList parserLocalDeclaration = parserLocalDeclarationList'

;; ../../../../spec-concrete/1-syntax.watsup:1062.3-1064.52
syntax parserDeclaration = 
   | annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }

;; ../../../../spec-concrete/1-syntax.watsup:1074.16-1074.21
syntax const = 
   | const

;; ../../../../spec-concrete/1-syntax.watsup:1077.1-1078.10
syntax constOpt = 
   | 
   | const

;; ../../../../spec-concrete/1-syntax.watsup:1080.1-1080.41
def $flatten_constOpt(constOpt) : const? =

  ;; ../../../../spec-concrete/1-syntax.watsup:1081.1-1081.36
  clause 0(constOpt) = ?()
  -- if constOpt matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1082.1-1082.37
  clause 1(constOpt) = ?(const)
  -- if constOpt <: const
  -- let const = constOpt as const

;; ../../../../spec-concrete/1-syntax.watsup:1088.19-1088.55
syntax tableKey = 
   | expression : name annotationList ;

;; ../../../../spec-concrete/1-syntax.watsup:1091.1-1092.26
syntax tableKeyList = 
   | 
   | tableKeyList tableKey

;; ../../../../spec-concrete/1-syntax.watsup:1094.1-1094.52
def $flatten_tableKeyList(tableKeyList) : tableKey* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1095.1-1095.40
  clause 0(tableKeyList) = []
  -- if tableKeyList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1096.1-1097.56
  clause 1(tableKeyList') = $flatten_tableKeyList(tableKeyList) ++ [tableKey]
  -- if tableKeyList' matches `%%`
  -- let tableKeyList tableKey = tableKeyList'

;; ../../../../spec-concrete/1-syntax.watsup:1104.1-1105.42
syntax tableActionReference = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | prefixedNonTypeName ( argumentList )

;; ../../../../spec-concrete/1-syntax.watsup:1107.22-1107.60
syntax tableAction = 
   | annotationList tableActionReference ;

;; ../../../../spec-concrete/1-syntax.watsup:1110.1-1111.32
syntax tableActionList = 
   | 
   | tableActionList tableAction

;; ../../../../spec-concrete/1-syntax.watsup:1113.1-1113.61
def $flatten_tableActionList(tableActionList) : tableAction* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1114.1-1114.43
  clause 0(tableActionList) = []
  -- if tableActionList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1115.1-1116.63
  clause 1(tableActionList') = $flatten_tableActionList(tableActionList) ++ [tableAction]
  -- if tableActionList' matches `%%`
  -- let tableActionList tableAction = tableActionList'

;; ../../../../spec-concrete/1-syntax.watsup:1123.1-1124.35
syntax tableEntryPriority = 
   | priority= numberLiteral :
   | priority=( expression ):

;; ../../../../spec-concrete/1-syntax.watsup:1127.1-1128.72
syntax tableEntry = 
   | constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ;
   | constOpt keysetExpression : tableActionReference annotationList ;

;; ../../../../spec-concrete/1-syntax.watsup:1131.1-1132.30
syntax tableEntryList = 
   | 
   | tableEntryList tableEntry

;; ../../../../spec-concrete/1-syntax.watsup:1134.1-1134.58
def $flatten_tableEntryList(tableEntryList) : tableEntry* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1135.1-1135.42
  clause 0(tableEntryList) = []
  -- if tableEntryList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1136.1-1137.62
  clause 1(tableEntryList') = $flatten_tableEntryList(tableEntryList) ++ [tableEntry]
  -- if tableEntryList' matches `%%`
  -- let tableEntryList tableEntry = tableEntryList'

;; ../../../../spec-concrete/1-syntax.watsup:1144.1-1147.59
syntax tableProperty = 
   | key={ tableKeyList }
   | actions={ tableActionList }
   | annotationList constOpt entries={ tableEntryList }
   | annotationList constOpt tableCustomName initializer ;

;; ../../../../spec-concrete/1-syntax.watsup:1150.1-1151.36
syntax tablePropertyList = 
   | 
   | tablePropertyList tableProperty

;; ../../../../spec-concrete/1-syntax.watsup:1153.1-1153.67
def $flatten_tablePropertyList(tablePropertyList) : tableProperty* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1154.1-1154.45
  clause 0(tablePropertyList) = []
  -- if tablePropertyList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1155.1-1156.69
  clause 1(tablePropertyList') = $flatten_tablePropertyList(tablePropertyList) ++ [tableProperty]
  -- if tablePropertyList' matches `%%`
  -- let tablePropertyList tableProperty = tablePropertyList'

;; ../../../../spec-concrete/1-syntax.watsup:1159.3-1159.51
syntax tableDeclaration = 
   | annotationList table name { tablePropertyList }

;; ../../../../spec-concrete/1-syntax.watsup:1166.3-1166.73
syntax controlTypeDeclaration = 
   | annotationList control name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1172.22-1172.36
syntax controlBody = blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:1175.1-1179.21
syntax controlLocalDeclaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList type name initializerOpt ;
   | annotationList action name ( parameterList ) blockStatement
   | annotationList table name { tablePropertyList }

;; ../../../../spec-concrete/1-syntax.watsup:1182.1-1183.56
syntax controlLocalDeclarationList = 
   | 
   | controlLocalDeclarationList controlLocalDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:1185.1-1186.29
def $flatten_controlLocalDeclarationList(controlLocalDeclarationList) : controlLocalDeclaration* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1188.1-1188.55
  clause 0(controlLocalDeclarationList) = []
  -- if controlLocalDeclarationList matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1189.1-1193.32
  clause 1(controlLocalDeclarationList') = $flatten_controlLocalDeclarationList(controlLocalDeclarationList) ++ [controlLocalDeclaration]
  -- if controlLocalDeclarationList' matches `%%`
  -- let controlLocalDeclarationList controlLocalDeclaration = controlLocalDeclarationList'

;; ../../../../spec-concrete/1-syntax.watsup:1196.3-1198.55
syntax controlDeclaration = 
   | annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }

;; ../../../../spec-concrete/1-syntax.watsup:1205.3-1205.73
syntax packageTypeDeclaration = 
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1212.1-1216.27
syntax typeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }
   | annotationList typedef typedefType name ;
   | annotationList type type name ;
   | annotationList parser name typeParameterListOpt ( parameterList );
   | annotationList control name typeParameterListOpt ( parameterList );
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1223.1-1232.20
syntax declaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList functionPrototype blockStatement
   | annotationList action name ( parameterList ) blockStatement
   | error{ nameList }
   | match_kind{ nameList trailingCommaOpt }
   | annotationList extern functionPrototype ;
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }
   | annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }
   | annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }
   | annotationList typedef typedefType name ;
   | annotationList type type name ;
   | annotationList parser name typeParameterListOpt ( parameterList );
   | annotationList control name typeParameterListOpt ( parameterList );
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1239.1-1256.27
syntax annotationToken = 
   | unexpected_token
   | abstract
   | action
   | actions
   | apply
   | bool
   | bit
   | break
   | const
   | continue
   | control
   | default
   | else
   | entries
   | enum
   | error
   | exit
   | extern
   | false
   | for
   | header
   | header_union
   | if
   | in
   | inout
   | int
   | key
   | match_kind
   | type
   | out
   | parser
   | package
   | pragma
   | return
   | select
   | state
   | string
   | struct
   | switch
   | table
   | this
   | transition
   | true
   | tuple
   | typedef
   | varbit
   | value_set
   | list
   | void
   | _
   | text
   | text
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | &&&
   | ..
   | <<
   | &&
   | ||
   | ==
   | !=
   | >=
   | <=
   | ++
   | +
   | |+|
   | -
   | |-|
   | *
   | /
   | %
   | |
   | &
   | ^
   | ~
   | [
   | ]
   | {
   | }
   | <
   | >
   | !
   | :
   | ,
   | ?
   | .
   | =
   | ;
   | @

;; ../../../../spec-concrete/1-syntax.watsup:1259.1-1261.35
syntax annotationBody = 
   | 
   | annotationBody ( annotationBody )
   | annotationBody annotationToken

;; ../../../../spec-concrete/1-syntax.watsup:1264.3-1264.41
syntax structuredAnnotationBody = 
   | dataElementExpression trailingCommaOpt

;; ../../../../spec-concrete/1-syntax.watsup:1267.1-1269.42
syntax annotation = 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]

;; ../../../../spec-concrete/1-syntax.watsup:1272.1-1273.38
syntax annotationListNonEmpty = 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]
   | annotationListNonEmpty annotation

;; ../../../../spec-concrete/1-syntax.watsup:1276.1-1277.27
syntax annotationList = 
   | 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]
   | annotationListNonEmpty annotation

;; ../../../../spec-concrete/1-syntax.watsup:1284.1-1286.17
syntax p4program = 
   | 
   | p4program declaration
   | p4program ;

;; ../../../../spec-concrete/1-syntax.watsup:1288.1-1288.49
def $flatten_p4program(p4program) : declaration* =

  ;; ../../../../spec-concrete/1-syntax.watsup:1289.1-1289.37
  clause 0(p4program) = []
  -- if p4program matches ``EMPTY`

  ;; ../../../../spec-concrete/1-syntax.watsup:1290.1-1291.53
  clause 1(p4program') = $flatten_p4program(p4program) ++ [declaration]
  -- if p4program' matches `%%`
  -- let p4program declaration = p4program'

  ;; ../../../../spec-concrete/1-syntax.watsup:1292.1-1293.34
  clause 2(p4program') = $flatten_p4program(p4program)
  -- if p4program' matches `%;`
  -- let p4program ; = p4program'

;; ../../../../spec-concrete/2.0-domain.watsup:5.17-5.21
syntax nameIR = text

;; ../../../../spec-concrete/2.0-domain.watsup:7.1-7.25
def $name(name) : nameIR =

  ;; ../../../../spec-concrete/2.0-domain.watsup:9.1-9.21
  clause 0(name) = t
  -- if name <: identifier
  -- let t = name as identifier

  ;; ../../../../spec-concrete/2.0-domain.watsup:10.1-10.22
  clause 1(name) = t
  -- if name <: typeIdentifier
  -- let t = name as typeIdentifier

  ;; ../../../../spec-concrete/2.0-domain.watsup:11.1-11.27
  clause 2(name) = "apply"
  -- if (name = apply as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:12.1-12.23
  clause 3(name) = "key"
  -- if (name = key as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:13.1-13.31
  clause 4(name) = "actions"
  -- if (name = actions as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:14.1-14.27
  clause 5(name) = "state"
  -- if (name = state as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:15.1-15.31
  clause 6(name) = "entries"
  -- if (name = entries as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:16.1-16.25
  clause 7(name) = "type"
  -- if (name = type as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:17.1-17.33
  clause 8(name) = "priority"
  -- if (name = priority as name)

  ;; ../../../../spec-concrete/2.0-domain.watsup:18.1-18.25
  clause 9(name) = "list"
  -- if name matches `LIST`

;; ../../../../spec-concrete/2.0-domain.watsup:20.1-20.47
def $tableCustomName(tableCustomName) : nameIR =

  ;; ../../../../spec-concrete/2.0-domain.watsup:22.1-22.32
  clause 0(tableCustomName) = t
  -- if tableCustomName <: identifier
  -- let t = tableCustomName as identifier

  ;; ../../../../spec-concrete/2.0-domain.watsup:23.1-23.33
  clause 1(tableCustomName) = t
  -- if tableCustomName <: typeIdentifier
  -- let t = tableCustomName as typeIdentifier

  ;; ../../../../spec-concrete/2.0-domain.watsup:24.1-24.38
  clause 2(tableCustomName) = "apply"
  -- if tableCustomName matches `APPLY`

  ;; ../../../../spec-concrete/2.0-domain.watsup:25.1-25.38
  clause 3(tableCustomName) = "state"
  -- if tableCustomName matches `STATE`

  ;; ../../../../spec-concrete/2.0-domain.watsup:26.1-26.36
  clause 4(tableCustomName) = "type"
  -- if tableCustomName matches `TYPE`

  ;; ../../../../spec-concrete/2.0-domain.watsup:27.1-27.44
  clause 5(tableCustomName) = "priority"
  -- if tableCustomName matches `PRIORITY`

;; ../../../../spec-concrete/2.0-domain.watsup:33.13-33.17
syntax id = text

;; ../../../../spec-concrete/2.0-domain.watsup:39.14-39.16
syntax tid = id

;; ../../../../spec-concrete/2.0-domain.watsup:41.1-41.23
def $fresh_tid : tid =

;; ../../../../spec-concrete/2.0-domain.watsup:42.1-42.28
def $fresh_tids(nat) : tid* =

  ;; ../../../../spec-concrete/2.0-domain.watsup:44.1-44.25
  clause 0(nat) = []
  -- if (nat = 0)

  ;; ../../../../spec-concrete/2.0-domain.watsup:45.1-46.15
  clause 1(n) = $fresh_tid :: $fresh_tids((n - 1))
  -- otherwise

;; ../../../../spec-concrete/2.0-domain.watsup:56.14-56.24
syntax pid = 
   | id # bool

;; ../../../../spec-concrete/2.0-domain.watsup:57.14-57.26
syntax rid = 
   | id ( pid* )

;; ../../../../spec-concrete/2.0-domain.watsup:59.1-59.36
def $rid(name, parameterList) : rid =

  ;; ../../../../spec-concrete/2.0-domain.watsup:63.1-64.42
  clause 0(name, parameterList) = $name(name) ( $pids(parameterList) )

;; ../../../../spec-concrete/2.0-domain.watsup:60.1-60.32
def $pids(parameterList) : pid* =

  ;; ../../../../spec-concrete/2.0-domain.watsup:66.1-66.24
  clause 0(parameterList) = []
  -- if parameterList matches ``EMPTY`

  ;; ../../../../spec-concrete/2.0-domain.watsup:67.1-67.39
  clause 1(parameterList) = [$pid(parameter)]
  -- if parameterList <: parameter
  -- let parameter = parameterList as parameter

  ;; ../../../../spec-concrete/2.0-domain.watsup:68.1-69.56
  clause 2(parameterList) = $pids(nonEmptyParameterList as parameterList) ++ [$pid(parameter)]
  -- if parameterList <: nonEmptyParameterList
  -- let nonEmptyParameterList' = parameterList as nonEmptyParameterList
  -- if nonEmptyParameterList' matches `%,%`
  -- let nonEmptyParameterList , parameter = nonEmptyParameterList'

;; ../../../../spec-concrete/2.0-domain.watsup:61.1-61.26
def $pid(parameter) : pid =

  ;; ../../../../spec-concrete/2.0-domain.watsup:71.1-71.51
  clause 0(_annotationList _direction _type name initializerOpt) = $name(name) # false
  -- if initializerOpt matches ``EMPTY`

  ;; ../../../../spec-concrete/2.0-domain.watsup:72.1-72.55
  clause 1(_annotationList _direction _type name initializerOpt) = $name(name) # true
  -- if initializerOpt <: initializer
  -- let initializer = initializerOpt as initializer

;; ../../../../spec-concrete/2.0-domain.watsup:78.14-78.17
syntax cid = rid

;; ../../../../spec-concrete/2.0-domain.watsup:80.1-80.50
def $cid(name, constructorParameterListOpt) : cid =

  ;; ../../../../spec-concrete/2.0-domain.watsup:82.1-82.46
  clause 0(name, constructorParameterListOpt) = $name(name) ( [] )
  -- if constructorParameterListOpt matches ``EMPTY`

  ;; ../../../../spec-concrete/2.0-domain.watsup:83.1-84.42
  clause 1(name, constructorParameterListOpt) = $name(name) ( $pids(parameterList) )
  -- if constructorParameterListOpt matches `(%)`
  -- let ( parameterList ) = constructorParameterListOpt

;; ../../../../spec-concrete/2.0-domain.watsup:88.1-88.48
def $expression_as_lvalue(expression) : lvalue? =

  ;; ../../../../spec-concrete/2.0-domain.watsup:90.1-90.69
  clause 0(expression) = ?(referenceExpression as lvalue)
  -- if expression <: referenceExpression
  -- let referenceExpression = expression as referenceExpression

  ;; ../../../../spec-concrete/2.0-domain.watsup:91.1-92.51
  clause 1(expression') = ?(lvalue . member)
  -- if expression' <: memberAccessExpression
  -- let memberAccessBase . member = expression' as memberAccessExpression
  -- if memberAccessBase <: expression
  -- let expression = memberAccessBase as expression
  -- let lvalue'?{lvalue' <- lvalue'?} = $expression_as_lvalue(expression)
  -- if lvalue'?{lvalue' <- lvalue'?} matches (_)
  -- let ?(lvalue) = lvalue'?{lvalue' <- lvalue'?}

  ;; ../../../../spec-concrete/2.0-domain.watsup:93.1-94.51
  clause 2(expression') = ?(( lvalue ))
  -- if expression' <: parenthesizedExpression
  -- let ( expression ) = expression' as parenthesizedExpression
  -- let lvalue'?{lvalue' <- lvalue'?} = $expression_as_lvalue(expression)
  -- if lvalue'?{lvalue' <- lvalue'?} matches (_)
  -- let ?(lvalue) = lvalue'?{lvalue' <- lvalue'?}

;; ../../../../spec-concrete/2.0-domain.watsup:99.14-99.17
syntax oid = id*

;; ../../../../spec-concrete/2.1.1-value.watsup:14.1-17.18
syntax primitiveValue = 
   | b bool
   | error. id
   | match_kind. id
   | " text " hint(print "#%#")

;; ../../../../spec-concrete/2.1.1-value.watsup:24.1-25.21
syntax numberValue = 
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat

;; ../../../../spec-concrete/2.1.1-value.watsup:27.20-27.50
syntax baseValue = 
   | b bool
   | error. id
   | match_kind. id
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat

;; ../../../../spec-concrete/2.1.1-value.watsup:35.20-35.31
syntax listValue = 
   | [ value* ]

;; ../../../../spec-concrete/2.1.1-value.watsup:36.21-36.32
syntax tupleValue = 
   | ( value* )

;; ../../../../spec-concrete/2.1.1-value.watsup:37.27-37.55
syntax headerStackValue = 
   | [ value* #( nat ; nat )]

;; ../../../../spec-concrete/2.1.1-value.watsup:39.21-39.32
syntax fieldValue = 
   | value id ;

;; ../../../../spec-concrete/2.1.1-value.watsup:41.22-41.49
syntax structValue = 
   | struct tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:42.22-42.49
syntax headerValue = 
   | header tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:43.27-43.60
syntax headerUnionValue = 
   | header_union tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:46.1-47.23
syntax enumValue = 
   | tid . id
   | tid . id # value

;; ../../../../spec-concrete/2.1.1-value.watsup:50.1-56.14
syntax dataValue = 
   | [ value* ]
   | ( value* )
   | [ value* #( nat ; nat )]
   | struct tid { fieldValue* }
   | header tid { fieldValue* }
   | header_union tid { fieldValue* }
   | tid . id
   | tid . id # value

;; ../../../../spec-concrete/2.1.1-value.watsup:62.23-62.30
syntax defaultValue = 
   | default

;; ../../../../spec-concrete/2.1.1-value.watsup:64.29-64.33
syntax invalidHeaderValue = 
   | {#}

;; ../../../../spec-concrete/2.1.1-value.watsup:67.1-68.28
syntax sequenceValue = 
   | seq( value* )
   | seq( value* ,...)

;; ../../../../spec-concrete/2.1.1-value.watsup:71.1-72.36
syntax recordValue = 
   | record{ fieldValue* }
   | record{ fieldValue* ,...}

;; ../../../../spec-concrete/2.1.1-value.watsup:75.1-77.29
syntax setValue = 
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }

;; ../../../../spec-concrete/2.1.1-value.watsup:80.1-81.38
syntax tableValue = 
   | table_enum tid . id
   | table_struct tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:84.1-89.15
syntax synthesizedValue = 
   | default
   | {#}
   | seq( value* )
   | seq( value* ,...)
   | record{ fieldValue* }
   | record{ fieldValue* ,...}
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }
   | table_enum tid . id
   | table_struct tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:95.31-95.37
syntax objectReferenceValue = 
   | ! oid

;; ../../../../spec-concrete/2.1.1-value.watsup:102.1-105.25
syntax value = 
   | b bool
   | error. id
   | match_kind. id
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat
   | [ value* ]
   | ( value* )
   | [ value* #( nat ; nat )]
   | struct tid { fieldValue* }
   | header tid { fieldValue* }
   | header_union tid { fieldValue* }
   | tid . id
   | tid . id # value
   | default
   | {#}
   | seq( value* )
   | seq( value* ,...)
   | record{ fieldValue* }
   | record{ fieldValue* ,...}
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }
   | table_enum tid . id
   | table_struct tid { fieldValue* }
   | ! oid

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:5.1-5.28
def $to_int(int, int) : int =

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:12.1-12.31
def $to_bitstr(int, int) : int =

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:18.1-18.28
def $to_number(value) : int =

  ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:20.1-20.24
  clause 0(value) = i
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i = numberLiteral

  ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:21.1-21.38
  clause 1(value) = $to_int(w as int, i)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i = numberLiteral

  ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:22.1-22.26
  clause 2(value) = i
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i = numberLiteral

  ;; ../../../../spec-concrete/2.1.2-value-aux.watsup:23.1-23.31
  clause 3(value) = i
  -- if value <: numberValue
  -- let numberValue = value as numberValue
  -- if numberValue matches `%V%#%`
  -- let w v i # _nat = numberValue

;; ../../../../spec-concrete/2.2.1-type.watsup:14.1-18.11
syntax primitiveTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string

;; ../../../../spec-concrete/2.2.1-type.watsup:25.1-28.20
syntax numberTypeIR = 
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >

;; ../../../../spec-concrete/2.2.1-type.watsup:30.21-30.51
syntax baseTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >

;; ../../../../spec-concrete/2.2.1-type.watsup:40.1-41.31
syntax namedTypeIR = 
   | tid tid
   | polyTypeDefIR < typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:52.1-53.20
syntax aliasTypeIR = 
   | typedef tid typeIR
   | type tid typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:59.21-59.37
syntax listTypeIR = 
   | list< typeIR >

;; ../../../../spec-concrete/2.2.1-type.watsup:60.22-60.40
syntax tupleTypeIR = 
   | tuple< typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:61.28-61.43
syntax headerStackTypeIR = 
   | typeIR [ nat ]

;; ../../../../spec-concrete/2.2.1-type.watsup:63.22-63.34
syntax fieldTypeIR = 
   | typeIR id ;

;; ../../../../spec-concrete/2.2.1-type.watsup:65.23-65.51
syntax structTypeIR = 
   | struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:66.23-66.51
syntax headerTypeIR = 
   | header tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:67.28-67.62
syntax headerUnionTypeIR = 
   | header_union tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:69.23-69.37
syntax valueFieldIR = 
   | id = value ;

;; ../../../../spec-concrete/2.2.1-type.watsup:72.1-73.42
syntax enumTypeIR = 
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:76.1-82.15
syntax dataTypeIR = 
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:92.3-92.40
syntax externObjectTypeIR = 
   | extern tid map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/2.2.1-type.watsup:93.29-93.57
syntax parserObjectTypeIR = 
   | parser( parameterTypeIR* )

;; ../../../../spec-concrete/2.2.1-type.watsup:94.30-94.59
syntax controlObjectTypeIR = 
   | control( parameterTypeIR* )

;; ../../../../spec-concrete/2.2.1-type.watsup:95.30-95.50
syntax packageObjectTypeIR = 
   | package< typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:96.28-96.47
syntax tableObjectTypeIR = 
   | table tid # typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:99.1-103.22
syntax objectTypeIR = 
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:106.1-108.17
syntax definedTypeIR = 
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:114.24-114.31
syntax defaultTypeIR = 
   | default

;; ../../../../spec-concrete/2.2.1-type.watsup:116.30-116.44
syntax invalidHeaderTypeIR = 
   | header_invalid

;; ../../../../spec-concrete/2.2.1-type.watsup:119.1-120.29
syntax sequenceTypeIR = 
   | seq< typeIR* >
   | seq< typeIR* ,...>

;; ../../../../spec-concrete/2.2.1-type.watsup:123.1-124.37
syntax recordTypeIR = 
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}

;; ../../../../spec-concrete/2.2.1-type.watsup:126.20-126.36
syntax setTypeIR = 
   | set< typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:129.1-130.39
syntax tableTypeIR = 
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:133.1-138.16
syntax synthesizedTypeIR = 
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:145.1-148.22
syntax typeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:154.24-154.30
syntax monoTypeDefIR = typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:156.24-156.48
syntax polyTypeDefIR = 
   | typeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:158.20-158.49
syntax typeDefIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }
   | typeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:164.26-164.52
syntax parameterTypeIR = 
   | direction typeIR id value?

;; ../../../../spec-concrete/2.2.1-type.watsup:171.1-174.33
syntax functionTypeIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )

;; ../../../../spec-concrete/2.2.1-type.watsup:177.1-182.27
syntax methodTypeIR = 
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:185.1-186.17
syntax routineTypeIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:192.31-192.44
syntax monoRoutineTypeDefIR = routineTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:194.31-194.62
syntax polyRoutineTypeDefIR = 
   | routineTypeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:197.1-198.25
syntax routineTypeDefIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR
   | routineTypeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:204.37-204.52
syntax constructorParameterTypeIR = parameterTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:211.3-211.58
syntax constructorTypeIR = 
   | constructor( constructorParameterTypeIR* )-> typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:217.31-217.66
syntax constructorTypeDefIR = 
   | constructorTypeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:9.1-9.34
def $is_baseTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:10.1-10.38
  clause 0(typeIR) = true
  -- if typeIR <: baseTypeIR
  -- let baseTypeIR = typeIR as baseTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:11.1-12.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:16.1-16.39
def $is_primitiveTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:17.1-17.48
  clause 0(typeIR) = true
  -- if typeIR <: primitiveTypeIR
  -- let primitiveTypeIR = typeIR as primitiveTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:18.1-19.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:21.1-21.35
def $is_void_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:22.1-22.33
  clause 0(typeIR) = true
  -- if (typeIR = void as typeIR)

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:23.1-24.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:26.1-26.35
def $is_bool_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:27.1-27.33
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:28.1-29.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:31.1-31.36
def $is_error_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:32.1-32.35
  clause 0(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:33.1-34.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:36.1-36.40
def $is_matchkind_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:37.1-37.44
  clause 0(typeIR) = true
  -- if (typeIR = match_kind as typeIR)

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:38.1-39.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:41.1-41.37
def $is_string_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:42.1-42.37
  clause 0(typeIR) = true
  -- if (typeIR = string as typeIR)

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:43.1-44.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:48.1-48.36
def $is_numberTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:49.1-49.42
  clause 0(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:50.1-51.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:53.1-53.44
def $is_arbitrary_int_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:54.1-54.41
  clause 0(typeIR) = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:55.1-56.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:58.1-58.40
def $is_fixed_int_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:59.1-59.44
  clause 0(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:60.1-61.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:63.1-63.40
def $is_fixed_bit_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:64.1-64.44
  clause 0(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:65.1-66.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:76.1-76.34
def $is_dataTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:77.1-77.38
  clause 0(typeIR) = true
  -- if typeIR <: dataTypeIR
  -- let dataTypeIR = typeIR as dataTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:78.1-79.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:81.1-81.41
def $is_headerStackTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:82.1-82.52
  clause 0(typeIR) = true
  -- if typeIR <: headerStackTypeIR
  -- let headerStackTypeIR = typeIR as headerStackTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:83.1-84.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:88.1-88.36
def $is_objectTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:89.1-89.42
  clause 0(typeIR) = true
  -- if typeIR <: objectTypeIR
  -- let objectTypeIR = typeIR as objectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:90.1-91.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:93.1-93.44
def $is_extern_object_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:94.1-94.56
  clause 0(typeIR) = true
  -- if typeIR <: externObjectTypeIR
  -- let externObjectTypeIR = typeIR as externObjectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:95.1-96.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:98.1-98.44
def $is_parser_object_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:99.1-99.56
  clause 0(typeIR) = true
  -- if typeIR <: parserObjectTypeIR
  -- let parserObjectTypeIR = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:100.1-101.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:103.1-103.45
def $is_control_object_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:104.1-104.58
  clause 0(typeIR) = true
  -- if typeIR <: controlObjectTypeIR
  -- let controlObjectTypeIR = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:105.1-106.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:108.1-108.45
def $is_package_object_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:109.1-109.58
  clause 0(typeIR) = true
  -- if typeIR <: packageObjectTypeIR
  -- let packageObjectTypeIR = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:110.1-111.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:113.1-113.43
def $is_table_object_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:114.1-114.56
  clause 0(typeIR) = true
  -- if typeIR <: controlObjectTypeIR
  -- let controlObjectTypeIR = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:115.1-116.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:120.1-120.41
def $is_synthesizedTypeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:121.1-121.52
  clause 0(typeIR) = true
  -- if typeIR <: tableObjectTypeIR
  -- let tableObjectTypeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:122.1-123.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:125.1-125.34
def $is_set_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:126.1-126.38
  clause 0(typeIR) = true
  -- if typeIR <: setTypeIR
  -- let set< _typeIR*{_typeIR <- _typeIR*} > = typeIR as setTypeIR

  ;; ../../../../spec-concrete/2.2.2-type-aux.watsup:127.1-128.15
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:5.16-5.24
syntax bound = set<tid>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:6.16-6.32
syntax theta = map<tid, typeIR>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:8.1-8.31
def $free_type(typeIR) : bound =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:33.1-33.38
  clause 0(typeIR) = { [] }
  -- if typeIR <: baseTypeIR
  -- let baseTypeIR = typeIR as baseTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:37.1-37.35
  clause 1(typeIR) = { [tid] }
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid tid = namedTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:39.1-42.59
  clause 2(typeIR') = $union_set<tid>(bound_base, bound_args)
  -- if typeIR' <: namedTypeIR
  -- let namedTypeIR = typeIR' as namedTypeIR
  -- if namedTypeIR matches `%<%>`
  -- let polyTypeDefIR < typeIR*{typeIR <- typeIR*} > = namedTypeIR
  -- let bound_base = $free_typeDef(polyTypeDefIR as typeDefIR)
  -- let bound_args = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:46.1-46.54
  clause 3(typeIR') = $free_type(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPEDEF%%`
  -- let typedef _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:48.1-48.51
  clause 4(typeIR') = $free_type(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:52.1-52.54
  clause 5(typeIR') = $free_type(typeIR)
  -- if typeIR' <: listTypeIR
  -- let list< typeIR > = typeIR' as listTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:54.1-55.42
  clause 6(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:57.1-57.51
  clause 7(typeIR') = $free_type(typeIR)
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:59.1-60.42
  clause 8(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: headerTypeIR
  -- let header _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:62.1-63.42
  clause 9(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: headerUnionTypeIR
  -- let header_union _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:65.1-66.42
  clause 10(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: structTypeIR
  -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:68.1-68.41
  clause 11(typeIR) = { [] }
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:70.1-70.61
  clause 12(typeIR') = $free_type(typeIR)
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:74.1-75.62
  clause 13(typeIR) = $unions_set<tid>($free_routineTypeDef(routineTypeDefIR)*{routineTypeDefIR <- routineTypeDefIR*})
  -- if typeIR <: externObjectTypeIR
  -- let extern _tid { _rid : routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} } = typeIR as externObjectTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:77.1-80.64
  clause 14(typeIR) = bound_params
  -- if typeIR <: parserObjectTypeIR
  -- let parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as parserObjectTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:82.1-85.64
  clause 15(typeIR) = bound_params
  -- if typeIR <: controlObjectTypeIR
  -- let control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as controlObjectTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:87.1-88.42
  clause 16(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: packageObjectTypeIR
  -- let package< typeIR*{typeIR <- typeIR*} > = typeIR' as packageObjectTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:90.1-90.55
  clause 17(typeIR') = $free_type(typeIR)
  -- if typeIR' <: tableObjectTypeIR
  -- let table _tid # typeIR = typeIR' as tableObjectTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:94.1-94.35
  clause 18(typeIR) = { [] }
  -- if (typeIR = default as typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:96.1-96.42
  clause 19(typeIR) = { [] }
  -- if (typeIR = header_invalid as typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:98.1-99.42
  clause 20(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR' as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%>`
  -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:101.1-102.42
  clause 21(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR' as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%,...>`
  -- let seq< typeIR*{typeIR <- typeIR*} ,...> = sequenceTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:104.1-105.42
  clause 22(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: recordTypeIR
  -- let recordTypeIR = typeIR' as recordTypeIR
  -- if recordTypeIR matches `RECORD{%}`
  -- let record{ typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = recordTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:107.1-108.42
  clause 23(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: recordTypeIR
  -- let recordTypeIR = typeIR' as recordTypeIR
  -- if recordTypeIR matches `RECORD{%,...}`
  -- let record{ typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} ,...} = recordTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:110.1-111.42
  clause 24(typeIR') = $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: setTypeIR
  -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:113.1-113.47
  clause 25(typeIR) = { [] }
  -- if typeIR <: tableTypeIR
  -- let tableTypeIR = typeIR as tableTypeIR
  -- if tableTypeIR matches `TABLE_ENUM%{%}`
  -- let table_enum _tid { _id*{_id <- _id*} } = tableTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:115.1-115.49
  clause 26(typeIR) = { [] }
  -- if typeIR <: tableTypeIR
  -- let tableTypeIR = typeIR as tableTypeIR
  -- if tableTypeIR matches `TABLE_STRUCT%{%}`
  -- let table_struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:9.1-9.37
def $free_typeDef(typeDefIR) : bound =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:121.1-121.47
  clause 0(typeDefIR) = $free_type(typeIR)
  -- if typeDefIR <: typeIR
  -- let typeIR = typeDefIR as typeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:123.1-126.49
  clause 1(typeDefIR) = $diff_set<tid>(bound_base, bound_tparams)
  -- if typeDefIR <: polyTypeDefIR
  -- let typeIR_base < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = typeDefIR as polyTypeDefIR
  -- let bound_base = $free_typeDef(typeIR_base as typeDefIR)
  -- let bound_tparams = { tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} }

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:10.1-10.49
def $free_parameterType(parameterTypeIR) : bound =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:132.1-132.59
  clause 0(_direction typeIR _id _value?{_value <- _value?}) = $free_type(typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:11.1-11.45
def $free_routineType(routineTypeIR) : bound =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:138.1-144.43
  clause 0(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
  -- let builtin_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
  -- let bound_ret = $free_type(typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:146.1-152.43
  clause 1(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `FUNCTION(%)->%`
  -- let function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
  -- let bound_ret = $free_type(typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:154.1-160.43
  clause 2(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
  -- let extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
  -- let bound_ret = $free_type(typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:162.1-167.64
  clause 3(routineTypeIR) = bound_params
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `ACTION(%)`
  -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:169.1-175.43
  clause 4(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
  -- let builtin_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
  -- let bound_ret = $free_type(typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:177.1-183.43
  clause 5(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
  -- let extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
  -- let bound_ret = $free_type(typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:185.1-191.43
  clause 6(routineTypeIR) = $union_set<tid>(bound_params, bound_ret)
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})
  -- let bound_ret = $free_type(typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:193.1-198.64
  clause 7(routineTypeIR) = bound_params
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `PARSER_APPLY(%)`
  -- let parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:200.1-205.64
  clause 8(routineTypeIR) = bound_params
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `CONTROL_APPLY(%)`
  -- let control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
  -- let bound_params = $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:207.1-211.43
  clause 9(routineTypeIR) = bound_ret
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `TABLE_APPLY->%`
  -- let table_apply-> typeIR_ret = methodTypeIR
  -- let bound_ret = $free_type(typeIR_ret)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:12.1-12.51
def $free_routineTypeDef(routineTypeDefIR) : bound =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:217.1-218.37
  clause 0(routineTypeDefIR) = $free_routineType(routineTypeIR)
  -- if routineTypeDefIR <: routineTypeIR
  -- let routineTypeIR = routineTypeDefIR as routineTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:220.1-225.49
  clause 1(routineTypeDefIR) = $diff_set<tid>(bound_base, bound_tparams)
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- let bound_base = $free_routineTypeDef(routineTypeIR as routineTypeDefIR)
  -- let bound_tparams = { tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} }

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:14.1-14.40
def $subst_type(theta, typeIR) : typeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:231.1-231.43
  clause 0(set<pair<tid, typeIR>>, typeIR) = typeIR
  -- if (set<pair<tid, typeIR>> = { [] })

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:232.1-233.15
  clause 1(theta, typeIR) = $subst_type'(theta, typeIR)
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:15.1-15.41
def $subst_type'(theta, typeIR) : typeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:237.1-238.52
  clause 0(theta, typeIR') = typeIR
  -- if typeIR' <: namedTypeIR
  -- let namedTypeIR = typeIR' as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid tid = namedTypeIR
  -- let typeIR''?{typeIR'' <- typeIR''?} = $find_map<tid, typeIR>(theta, tid)
  -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
  -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:240.1-244.54
  clause 1(theta, typeIR') = polyTypeDefIR_subst < typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
  -- if typeIR' <: namedTypeIR
  -- let namedTypeIR = typeIR' as namedTypeIR
  -- if namedTypeIR matches `%<%>`
  -- let polyTypeDefIR < typeIR*{typeIR <- typeIR*} > = namedTypeIR
  -- let typeDefIR = $subst_typeDef'(theta, polyTypeDefIR as typeDefIR)
  -- if typeDefIR <: polyTypeDefIR
  -- let polyTypeDefIR_subst = typeDefIR as polyTypeDefIR
  -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:248.1-250.51
  clause 2(theta, typeIR') = typedef tid typeIR_subst as typeIR
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPEDEF%%`
  -- let typedef tid typeIR = aliasTypeIR
  -- let typeIR_subst = $subst_type'(theta, typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:252.1-254.51
  clause 3(theta, typeIR') = type tid typeIR_subst as typeIR
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type tid typeIR = aliasTypeIR
  -- let typeIR_subst = $subst_type'(theta, typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:258.1-260.51
  clause 4(theta, typeIR') = list< typeIR_subst > as typeIR
  -- if typeIR' <: listTypeIR
  -- let list< typeIR > = typeIR' as listTypeIR
  -- let typeIR_subst = $subst_type'(theta, typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:262.1-264.54
  clause 5(theta, typeIR') = tuple< typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
  -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:266.1-268.51
  clause 6(theta, typeIR') = typeIR_subst [ n ] as typeIR
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ n ] = typeIR' as headerStackTypeIR
  -- let typeIR_subst = $subst_type'(theta, typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:270.1-275.58
  clause 7(theta, typeIR) = struct tid { typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} } as typeIR
  -- if typeIR <: structTypeIR
  -- let struct tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as structTypeIR
  -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:277.1-282.58
  clause 8(theta, typeIR) = header tid { typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} } as typeIR
  -- if typeIR <: headerTypeIR
  -- let header tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerTypeIR
  -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:284.1-289.58
  clause 9(theta, typeIR) = header_union tid { typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} } as typeIR
  -- if typeIR <: headerUnionTypeIR
  -- let header_union tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerUnionTypeIR
  -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:291.1-296.51
  clause 10(theta, typeIR') = enum tid # typeIR_subst { valueFieldIR*{valueFieldIR <- valueFieldIR*} } as typeIR
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum tid # typeIR { valueFieldIR*{valueFieldIR <- valueFieldIR*} } = enumTypeIR
  -- let typeIR_subst = $subst_type'(theta, typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:300.1-306.60
  clause 11(theta, typeIR) = extern tid { rid : routineTypeDefIR_subst*{rid <- rid*, routineTypeDefIR_subst <- routineTypeDefIR_subst*} } as typeIR
  -- if typeIR <: externObjectTypeIR
  -- let extern tid { rid : routineTypeDefIR*{rid <- rid*, routineTypeDefIR <- routineTypeDefIR*} } = typeIR as externObjectTypeIR
  -- (let routineTypeDefIR_subst = $subst_routineTypeDef'(theta, routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*, routineTypeDefIR_subst <- routineTypeDefIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:308.1-311.58
  clause 12(theta, typeIR) = parser( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as typeIR
  -- if typeIR <: parserObjectTypeIR
  -- let parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as parserObjectTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:313.1-316.58
  clause 13(theta, typeIR) = control( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as typeIR
  -- if typeIR <: controlObjectTypeIR
  -- let control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as controlObjectTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:318.1-320.54
  clause 14(theta, typeIR') = package< typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
  -- if typeIR' <: packageObjectTypeIR
  -- let package< typeIR*{typeIR <- typeIR*} > = typeIR' as packageObjectTypeIR
  -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:322.1-324.51
  clause 15(theta, typeIR') = table tid # typeIR_subst as typeIR
  -- if typeIR' <: tableObjectTypeIR
  -- let table tid # typeIR = typeIR' as tableObjectTypeIR
  -- let typeIR_subst = $subst_type'(theta, typeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:328.1-330.54
  clause 16(theta, typeIR') = seq< typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
  -- if typeIR' <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR' as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%>`
  -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR
  -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:332.1-334.54
  clause 17(theta, typeIR') = seq< typeIR_subst*{typeIR_subst <- typeIR_subst*} ,...> as typeIR
  -- if typeIR' <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR' as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%,...>`
  -- let seq< typeIR*{typeIR <- typeIR*} ,...> = sequenceTypeIR
  -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:336.1-341.58
  clause 18(theta, typeIR) = record{ typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} } as typeIR
  -- if typeIR <: recordTypeIR
  -- let recordTypeIR = typeIR as recordTypeIR
  -- if recordTypeIR matches `RECORD{%}`
  -- let record{ typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = recordTypeIR
  -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:343.1-348.58
  clause 19(theta, typeIR) = record{ typeIR_f_subst id_f ;*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*} ,...} as typeIR
  -- if typeIR <: recordTypeIR
  -- let recordTypeIR = typeIR as recordTypeIR
  -- if recordTypeIR matches `RECORD{%,...}`
  -- let record{ typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} ,...} = recordTypeIR
  -- (let typeIR_f_subst = $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:350.1-352.54
  clause 20(theta, typeIR') = set< typeIR_subst*{typeIR_subst <- typeIR_subst*} > as typeIR
  -- if typeIR' <: setTypeIR
  -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR
  -- (let typeIR_subst = $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:356.1-357.15
  clause 21(theta, typeIR) = typeIR
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:16.1-16.49
def $subst_typeDef(theta, typeDefIR) : typeDefIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:363.1-363.52
  clause 0(set<pair<tid, typeIR>>, typeDefIR) = typeDefIR
  -- if (set<pair<tid, typeIR>> = { [] })

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:364.1-366.15
  clause 1(theta, typeDefIR) = $subst_typeDef'(theta, typeDefIR)
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:17.1-17.50
def $subst_typeDef'(theta, typeDefIR) : typeDefIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:368.1-368.65
  clause 0(theta, typeDefIR) = $subst_type'(theta, typeIR) as typeDefIR
  -- if typeDefIR <: typeIR
  -- let typeIR = typeDefIR as typeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:370.1-389.62
  clause 1(theta, typeDefIR) = typeIR_base_subst < tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} , tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} > as typeDefIR
  -- if typeDefIR <: polyTypeDefIR
  -- let typeIR_base < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = typeDefIR as polyTypeDefIR
  -- let { tid_free*{tid_free <- tid_free*} } = $diff_set<tid>($free_type(typeIR_base), { tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} })
  -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}
  -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
  -- (let ?(typeIR_free) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}
  -- let bound_capture = $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*})
  -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|)
  -- (if ~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}
  -- let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} = tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|]
  -- let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} = tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|]
  -- let theta' = $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, tid tid_fresh_spec as typeIR*{tid_fresh_spec <- tid_fresh_spec*})
  -- let theta'' = $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, tid tid_fresh_hidden as typeIR*{tid_fresh_hidden <- tid_fresh_hidden*})
  -- let typeIR_base_subst = $subst_type(theta'', typeIR_base)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:18.1-18.67
def $subst_parameterType(theta, parameterTypeIR) : parameterTypeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:395.1-396.20
  clause 0(set<pair<tid, typeIR>>, parameterTypeIR) = parameterTypeIR
  -- if (set<pair<tid, typeIR>> = { [] })

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:397.1-399.15
  clause 1(theta, parameterTypeIR) = $subst_parameterType'(theta, parameterTypeIR)
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:19.1-19.68
def $subst_parameterType'(theta, parameterTypeIR) : parameterTypeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:401.1-403.51
  clause 0(theta, direction typeIR id value?{value <- value?}) = direction typeIR_subst id value?{value <- value?}
  -- let typeIR_subst = $subst_type'(theta, typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:20.1-20.61
def $subst_routineType(theta, routineTypeIR) : routineTypeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:409.1-410.18
  clause 0(set<pair<tid, typeIR>>, routineTypeIR) = routineTypeIR
  -- if (set<pair<tid, typeIR>> = { [] })

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:411.1-413.15
  clause 1(theta, routineTypeIR) = $subst_routineType'(theta, routineTypeIR)
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:21.1-21.62
def $subst_routineType'(theta, routineTypeIR) : routineTypeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:415.1-422.59
  clause 0(theta, routineTypeIR) = builtin_function( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
  -- let builtin_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:424.1-431.59
  clause 1(theta, routineTypeIR) = function( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `FUNCTION(%)->%`
  -- let function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:433.1-440.59
  clause 2(theta, routineTypeIR) = extern_function( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
  -- let extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:442.1-448.58
  clause 3(theta, routineTypeIR) = action( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as routineTypeIR
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `ACTION(%)`
  -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:450.1-457.59
  clause 4(theta, routineTypeIR) = builtin_method( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
  -- let builtin_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:459.1-466.59
  clause 5(theta, routineTypeIR) = extern_method( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
  -- let extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:468.1-475.59
  clause 6(theta, routineTypeIR) = extern_methodabstract( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:477.1-483.58
  clause 7(theta, routineTypeIR) = parser_apply( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as routineTypeIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `PARSER_APPLY(%)`
  -- let parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:485.1-491.58
  clause 8(theta, routineTypeIR) = control_apply( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} ) as routineTypeIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `CONTROL_APPLY(%)`
  -- let control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:493.1-498.59
  clause 9(theta, routineTypeIR) = table_apply-> typeIR_ret_subst as routineTypeIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `TABLE_APPLY->%`
  -- let table_apply-> typeIR_ret = methodTypeIR
  -- let typeIR_ret_subst = $subst_type'(theta, typeIR_ret)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:22.1-22.70
def $subst_routineTypeDef(theta, routineTypeDefIR) : routineTypeDefIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:504.1-505.21
  clause 0(set<pair<tid, typeIR>>, routineTypeDefIR) = routineTypeDefIR
  -- if (set<pair<tid, typeIR>> = { [] })

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:506.1-508.15
  clause 1(theta, routineTypeDefIR) = $subst_routineTypeDef'(theta, routineTypeDefIR)
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:23.1-23.71
def $subst_routineTypeDef'(theta, routineTypeDefIR) : routineTypeDefIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:510.1-511.46
  clause 0(theta, routineTypeDefIR) = $subst_routineType'(theta, routineTypeIR) as routineTypeDefIR
  -- if routineTypeDefIR <: routineTypeIR
  -- let routineTypeIR = routineTypeDefIR as routineTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:513.1-532.73
  clause 1(theta, routineTypeDefIR) = routineTypeIR_subst < tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} , tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} > as routineTypeDefIR
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- let { tid_free*{tid_free <- tid_free*} } = $diff_set<tid>($free_routineType(routineTypeIR), { tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} })
  -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}
  -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
  -- (let ?(typeIR_free) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}
  -- let bound_capture = $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*})
  -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|)
  -- (if ~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}
  -- let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} = tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|]
  -- let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} = tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|]
  -- let theta' = $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, tid tid_fresh_spec as typeIR*{tid_fresh_spec <- tid_fresh_spec*})
  -- let theta'' = $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, tid tid_fresh_hidden as typeIR*{tid_fresh_hidden <- tid_fresh_hidden*})
  -- let routineTypeIR_subst = $subst_routineType(theta'', routineTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:24.1-24.73
def $subst_constructorType(theta, constructorTypeIR) : constructorTypeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:538.1-539.22
  clause 0(set<pair<tid, typeIR>>, constructorTypeIR) = constructorTypeIR
  -- if (set<pair<tid, typeIR>> = { [] })

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:540.1-542.15
  clause 1(theta, constructorTypeIR) = $subst_constructorType'(theta, constructorTypeIR)
  -- otherwise

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:25.1-25.74
def $subst_constructorType'(theta, constructorTypeIR) : constructorTypeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:544.1-551.59
  clause 0(theta, constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_obj) = constructor( parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} )-> typeIR_obj_subst
  -- (let parameterTypeIR_subst = $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}
  -- let typeIR_obj_subst = $subst_type'(theta, typeIR_obj)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:561.1-561.53
def $specialize_typeDef(typeDefIR, typeIR*) : typeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:563.1-563.46
  clause 0(typeDefIR, typeIR'*{typeIR' <- typeIR'*}) = typeIR
  -- if typeDefIR <: typeIR
  -- let typeIR = typeDefIR as typeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches []

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:565.1-568.49
  clause 1(typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = $subst_type(theta, typeIR_base)
  -- if typeDefIR <: polyTypeDefIR
  -- let typeIR_base < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = typeDefIR as polyTypeDefIR
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- let theta = { tid_tparam : typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} }

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:574.1-575.29
def $specialize_routineTypeDef(routineTypeDefIR, typeIR*) : (routineTypeDefIR, tid*) =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:577.1-578.25
  clause 0(routineTypeDefIR, typeIR*{typeIR <- typeIR*}) = (routineTypeIR as routineTypeDefIR, [])
  -- if routineTypeDefIR <: routineTypeIR
  -- let routineTypeIR = routineTypeDefIR as routineTypeIR
  -- if typeIR*{typeIR <- typeIR*} matches []

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:580.1-587.49
  clause 1(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR) as routineTypeDefIR, [])
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- if (|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
  -- let theta = { tid_tparam : typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} }

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:589.1-597.54
  clause 2(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*}) as (routineTypeDefIR, tid*)
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- if ((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))
  -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|)
  -- let theta = { tid_tparam : tid tid_fresh as typeIR*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*} }

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:599.1-610.53
  clause 3(routineTypeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*}) as (routineTypeDefIR, tid*)
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- if (((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))
  -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|)
  -- let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} = typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ tid tid_fresh as typeIR*{tid_fresh <- tid_fresh*}
  -- let theta = { tid_tparam : typeIR_arg_new*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*} }

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:616.1-617.30
def $specialize_constructorTypeDef(constructorTypeDefIR, typeIR*) : (constructorTypeIR, tid*) =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:619.1-628.57
  clause 0(constructorTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} >, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, [])
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- if (|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)
  -- let theta = { tid_tparam : typeIR_arg*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} }
  -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:630.1-640.57
  clause 1(constructorTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} >, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, tid_fresh*{tid_fresh <- tid_fresh*})
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- if ((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))
  -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|)
  -- let theta = { tid_tparam : tid tid_fresh as typeIR*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*} }
  -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:642.1-655.57
  clause 2(constructorTypeIR < tid*{tid <- tid*} , tid_hidden*{tid_hidden <- tid_hidden*} >, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = (constructorTypeIR_subst, tid_fresh*{tid_fresh <- tid_fresh*})
  -- let tid_tparam*{tid_tparam <- tid_tparam*} = tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}
  -- if (((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))
  -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|)
  -- let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} = typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ tid tid_fresh as typeIR*{tid_fresh <- tid_fresh*}
  -- let theta = { tid_tparam : typeIR_arg_new*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*} }
  -- let constructorTypeIR_subst = $subst_constructorType(theta, constructorTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:662.1-662.28
def $canon(typeIR) : typeIR =

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:664.1-665.65
  clause 0(typeIR') = $canon(typeIR)
  -- if typeIR' <: namedTypeIR
  -- let namedTypeIR = typeIR' as namedTypeIR
  -- if namedTypeIR matches `%<%>`
  -- let polyTypeDefIR < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR
  -- let typeIR = $specialize_typeDef(polyTypeDefIR as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:667.1-667.46
  clause 1(typeIR') = $canon(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPEDEF%%`
  -- let typedef _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/2.2.3-type-subst.watsup:669.1-670.15
  clause 2(typeIR) = typeIR
  -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:7.1-7.38
def $is_nominal_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:10.1-11.40
  clause 0(typeIR) = $is_nominal_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:8.1-8.39
def $is_nominal_typeIR'(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:12.1-12.41
  clause 0(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:13.1-13.48
  clause 1(typeIR) = true
  -- if typeIR <: structTypeIR
  -- let struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:14.1-14.48
  clause 2(typeIR) = true
  -- if typeIR <: headerTypeIR
  -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:15.1-15.54
  clause 3(typeIR) = true
  -- if typeIR <: headerUnionTypeIR
  -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:16.1-16.46
  clause 4(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:17.1-17.51
  clause 5(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:18.1-18.43
  clause 6(typeIR) = true
  -- if typeIR <: externObjectTypeIR
  -- let extern _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:19.1-19.45
  clause 7(typeIR) = true
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:20.1-21.15
  clause 8(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:25.1-25.42
def $is_defaultable_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:28.1-29.44
  clause 0(typeIR) = $is_defaultable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:26.1-26.43
def $is_defaultable_typeIR'(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:30.1-30.41
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:31.1-31.42
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:32.1-32.43
  clause 2(typeIR) = true
  -- if (typeIR = string as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:33.1-33.49
  clause 3(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:34.1-35.35
  clause 4(typeIR') = $is_defaultable_typeIR(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:36.1-37.40
  clause 5(typeIR') = true
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
  -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:38.1-39.35
  clause 6(typeIR') = $is_defaultable_typeIR(typeIR)
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:40.1-41.40
  clause 7(typeIR') = true
  -- if typeIR' <: structTypeIR
  -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR
  -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:42.1-43.40
  clause 8(typeIR') = true
  -- if typeIR' <: headerTypeIR
  -- let header _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR
  -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:44.1-45.40
  clause 9(typeIR') = true
  -- if typeIR' <: headerUnionTypeIR
  -- let header_union _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR
  -- (if $is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:46.1-46.50
  clause 10(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:47.1-48.35
  clause 11(typeIR') = $is_defaultable_typeIR(typeIR)
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:49.1-50.15
  clause 12(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:54.1-54.40
def $is_equalable_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:57.1-58.42
  clause 0(typeIR) = $is_equalable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:55.1-55.41
def $is_equalable_typeIR'(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:59.1-59.40
  clause 0(typeIR) = false
  -- if (typeIR = void as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:60.1-60.43
  clause 1(typeIR) = false
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid tid = namedTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:61.1-61.46
  clause 2(typeIR) = false
  -- if typeIR <: externObjectTypeIR
  -- let extern _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:62.1-62.49
  clause 3(typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:63.1-63.50
  clause 4(typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:64.1-64.50
  clause 5(typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:65.1-65.48
  clause 6(typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:66.1-66.43
  clause 7(typeIR) = false
  -- if (typeIR = default as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:67.1-67.54
  clause 8(typeIR) = false
  -- if typeIR <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%,...>`
  -- let seq< _typeIR*{_typeIR <- _typeIR*} ,...> = sequenceTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:68.1-68.57
  clause 9(typeIR) = false
  -- if typeIR <: recordTypeIR
  -- let recordTypeIR = typeIR as recordTypeIR
  -- if recordTypeIR matches `RECORD{%,...}`
  -- let record{ _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} ,...} = recordTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:69.1-69.50
  clause 10(typeIR) = false
  -- if (typeIR = header_invalid as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:70.1-70.46
  clause 11(typeIR) = false
  -- if typeIR <: setTypeIR
  -- let set< _typeIR*{_typeIR <- _typeIR*} > = typeIR as setTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:71.1-71.55
  clause 12(typeIR) = false
  -- if typeIR <: tableTypeIR
  -- let tableTypeIR = typeIR as tableTypeIR
  -- if tableTypeIR matches `TABLE_ENUM%{%}`
  -- let table_enum _tid { _id*{_id <- _id*} } = tableTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:72.1-72.57
  clause 13(typeIR) = false
  -- if typeIR <: tableTypeIR
  -- let tableTypeIR = typeIR as tableTypeIR
  -- if tableTypeIR matches `TABLE_STRUCT%{%}`
  -- let table_struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:73.1-74.15
  clause 14(typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/2.2.4-type-util.watsup:78.1-78.41
def $is_assignable_typeIR(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:81.1-82.43
  clause 0(typeIR) = $is_assignable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:79.1-79.42
def $is_assignable_typeIR'(typeIR) : bool =

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:83.1-83.41
  clause 0(typeIR) = false
  -- if (typeIR = void as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:84.1-84.43
  clause 1(typeIR) = false
  -- if (typeIR = string as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:85.1-85.40
  clause 2(typeIR) = false
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:86.1-86.49
  clause 3(typeIR) = false
  -- if typeIR <: objectTypeIR
  -- let objectTypeIR = typeIR as objectTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:87.1-87.54
  clause 4(typeIR) = false
  -- if typeIR <: synthesizedTypeIR
  -- let synthesizedTypeIR = typeIR as synthesizedTypeIR

  ;; ../../../../spec-concrete/2.2.4-type-util.watsup:88.1-89.15
  clause 5(typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:5.1-7.20
relation Type_alpha: typeIR ~~ typeIR

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:27.1-28.27
  rulegroup basetype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:27.1-28.27
    rule basetype: typeIR ~~ typeIR'
    -- if typeIR <: baseTypeIR
    -- let baseTypeIR = typeIR as baseTypeIR
    -- if typeIR' <: baseTypeIR
    -- let baseTypeIR' = typeIR' as baseTypeIR
    -- if (baseTypeIR = baseTypeIR')
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:32.1-33.26
  rulegroup nametype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:32.1-33.26
    rule nametype: typeIR ~~ typeIR'
    -- if typeIR <: namedTypeIR
    -- let namedTypeIR = typeIR as namedTypeIR
    -- if namedTypeIR matches `TID%`
    -- let tid tid = namedTypeIR
    -- if typeIR' <: namedTypeIR
    -- let namedTypeIR' = typeIR' as namedTypeIR
    -- if namedTypeIR' matches `TID%`
    -- let tid tid' = namedTypeIR'
    -- if (tid = tid')
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:35.1-56.2
  rulegroup spectype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:37.3-45.43
    rule nominal: typeIR ~~ typeIR'
    -- if typeIR <: namedTypeIR
    -- let namedTypeIR = typeIR as namedTypeIR
    -- if namedTypeIR matches `%<%>`
    -- let polyTypeDefIR_a < typeIR_a*{typeIR_a <- typeIR_a*} > = namedTypeIR
    -- if typeIR' <: namedTypeIR
    -- let namedTypeIR' = typeIR' as namedTypeIR
    -- if namedTypeIR' matches `%<%>`
    -- let polyTypeDefIR_b < typeIR_b*{typeIR_b <- typeIR_b*} > = namedTypeIR'
    -- let typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a as typeDefIR, typeIR_a*{typeIR_a <- typeIR_a*})
    -- let typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b as typeDefIR, typeIR_b*{typeIR_b <- typeIR_b*})
    -- if Type_alpha: typeIR_a_spec ~~ typeIR_b_spec holds
    -- if ($is_nominal_typeIR(typeIR_a_spec) /\ $is_nominal_typeIR(typeIR_b_spec))
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:47.3-54.48
    rule structural: typeIR ~~ typeIR'
    -- if typeIR <: namedTypeIR
    -- let namedTypeIR = typeIR as namedTypeIR
    -- if namedTypeIR matches `%<%>`
    -- let polyTypeDefIR_a < typeIR_a*{typeIR_a <- typeIR_a*} > = namedTypeIR
    -- if typeIR' <: namedTypeIR
    -- let namedTypeIR' = typeIR' as namedTypeIR
    -- if namedTypeIR' matches `%<%>`
    -- let polyTypeDefIR_b < typeIR_b*{typeIR_b <- typeIR_b*} > = namedTypeIR'
    -- let typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a as typeDefIR, typeIR_a*{typeIR_a <- typeIR_a*})
    -- let typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b as typeDefIR, typeIR_b*{typeIR_b <- typeIR_b*})
    -- if Type_alpha: typeIR_a_spec ~~ typeIR_b_spec holds
    -- if (~$is_nominal_typeIR(typeIR_a_spec) /\ ~$is_nominal_typeIR(typeIR_b_spec))
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:60.1-70.2
  rulegroup typedeftype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:62.3-64.40
    rule left: typeIR ~~ typeIR_b
    -- if typeIR <: aliasTypeIR
    -- let aliasTypeIR = typeIR as aliasTypeIR
    -- if aliasTypeIR matches `TYPEDEF%%`
    -- let typedef _tid typeIR_a = aliasTypeIR
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds

    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:66.3-68.40
    rule right: typeIR_a ~~ typeIR
    -- if typeIR <: aliasTypeIR
    -- let aliasTypeIR = typeIR as aliasTypeIR
    -- if aliasTypeIR matches `TYPEDEF%%`
    -- let typedef _tid typeIR_b = aliasTypeIR
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:72.1-74.38
  rulegroup newtype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:72.1-74.38
    rule newtype: typeIR ~~ typeIR'
    -- if typeIR <: aliasTypeIR
    -- let aliasTypeIR = typeIR as aliasTypeIR
    -- if aliasTypeIR matches `TYPE%%`
    -- let type tid typeIR_a = aliasTypeIR
    -- if typeIR' <: aliasTypeIR
    -- let aliasTypeIR' = typeIR' as aliasTypeIR
    -- if aliasTypeIR' matches `TYPE%%`
    -- let type tid' typeIR_b = aliasTypeIR'
    -- if (tid = tid')
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:78.1-80.38
  rulegroup listtype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:78.1-80.38
    rule listtype: typeIR ~~ typeIR'
    -- if typeIR <: listTypeIR
    -- let list< typeIR_a > = typeIR as listTypeIR
    -- if typeIR' <: listTypeIR
    -- let list< typeIR_b > = typeIR' as listTypeIR
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:82.1-84.41
  rulegroup tupletype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:82.1-84.41
    rule tupletype: typeIR ~~ typeIR'
    -- if typeIR <: tupleTypeIR
    -- let tuple< typeIR_a*{typeIR_a <- typeIR_a*} > = typeIR as tupleTypeIR
    -- if typeIR' <: tupleTypeIR
    -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as tupleTypeIR
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:86.1-88.38
  rulegroup stacktype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:86.1-88.38
    rule stacktype: typeIR ~~ typeIR'
    -- if typeIR <: headerStackTypeIR
    -- let typeIR_a [ n_s ] = typeIR as headerStackTypeIR
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR_b [ n_s' ] = typeIR' as headerStackTypeIR
    -- if (n_s = n_s')
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:90.1-93.45
  rulegroup structtype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:90.1-93.45
    rule structtype: typeIR ~~ typeIR'
    -- if typeIR <: structTypeIR
    -- let struct tid { typeIR_f_a id_f ;*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} } = typeIR as structTypeIR
    -- if typeIR' <: structTypeIR
    -- let struct tid' { typeIR_f_b id_f' ;*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} } = typeIR' as structTypeIR
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
    -- (if Type_alpha: typeIR_f_a ~~ typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:95.1-98.45
  rulegroup headertype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:95.1-98.45
    rule headertype: typeIR ~~ typeIR'
    -- if typeIR <: headerTypeIR
    -- let header tid { typeIR_f_a id_f ;*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} } = typeIR as headerTypeIR
    -- if typeIR' <: headerTypeIR
    -- let header tid' { typeIR_f_b id_f' ;*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} } = typeIR' as headerTypeIR
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
    -- (if Type_alpha: typeIR_f_a ~~ typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:100.1-103.45
  rulegroup headeruniontype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:100.1-103.45
    rule headeruniontype: typeIR ~~ typeIR'
    -- if typeIR <: headerUnionTypeIR
    -- let header_union tid { typeIR_f_a id_f ;*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} } = typeIR as headerUnionTypeIR
    -- if typeIR' <: headerUnionTypeIR
    -- let header_union tid' { typeIR_f_b id_f' ;*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} } = typeIR' as headerUnionTypeIR
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
    -- (if Type_alpha: typeIR_f_a ~~ typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:105.1-106.49
  rulegroup enumtype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:105.1-106.49
    rule enumtype: typeIR ~~ typeIR'
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%{%}`
    -- let enum tid { id_f*{id_f <- id_f*} } = enumTypeIR
    -- if typeIR' <: enumTypeIR
    -- let enumTypeIR' = typeIR' as enumTypeIR
    -- if enumTypeIR' matches `ENUM%{%}`
    -- let enum tid' { id_f'*{id_f' <- id_f'*} } = enumTypeIR'
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:108.1-111.38
  rulegroup serenumtype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:108.1-111.38
    rule serenumtype: typeIR ~~ typeIR'
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum tid # typeIR_a { id_f = value_f ;*{id_f <- id_f*, value_f <- value_f*} } = enumTypeIR
    -- if typeIR' <: enumTypeIR
    -- let enumTypeIR' = typeIR' as enumTypeIR
    -- if enumTypeIR' matches `ENUM%#%{%}`
    -- let enum tid' # typeIR_b { id_f' = value_f' ;*{id_f' <- id_f'*, value_f' <- value_f'*} } = enumTypeIR'
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
    -- (if (value_f = value_f'))*{value_f <- value_f*, value_f' <- value_f'*}
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:115.1-127.73
  rulegroup externtype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:115.1-127.73
    rule externtype: typeIR ~~ typeIR'
    -- if typeIR <: externObjectTypeIR
    -- let extern tid { rid_a : routineTypeDefIR_a*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*} } = typeIR as externObjectTypeIR
    -- if typeIR' <: externObjectTypeIR
    -- let extern tid' { rid_b : routineTypeDefIR_b*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*} } = typeIR' as externObjectTypeIR
    -- if (tid = tid')
    -- if $eq_set<rid>({ rid_a*{rid_a <- rid_a*} }, { rid_b*{rid_b <- rid_b*} })
    -- (let routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} = $find_map<rid, routineTypeDefIR>({ rid_a : routineTypeDefIR_a*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*} }, rid_a))*{rid_a <- rid_a*, routineTypeDefIR? <- routineTypeDefIR?*}
    -- (if routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} matches (_))*{routineTypeDefIR? <- routineTypeDefIR?*}
    -- (let ?(routineTypeDefIR_a') = routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?})*{routineTypeDefIR? <- routineTypeDefIR?*, routineTypeDefIR_a' <- routineTypeDefIR_a'*}
    -- (let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_map<rid, routineTypeDefIR>({ rid_b : routineTypeDefIR_b*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*} }, rid_a))*{rid_a <- rid_a*, routineTypeDefIR'? <- routineTypeDefIR'?*}
    -- (if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_))*{routineTypeDefIR'? <- routineTypeDefIR'?*}
    -- (let ?(routineTypeDefIR_b') = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?})*{routineTypeDefIR'? <- routineTypeDefIR'?*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}
    -- (if RoutineTypeDef_alpha: routineTypeDefIR_a' ~~ routineTypeDefIR_b' holds)*{routineTypeDefIR_a' <- routineTypeDefIR_a'*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:129.1-131.68
  rulegroup parsertype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:129.1-131.68
    rule parsertype: typeIR ~~ typeIR'
    -- if typeIR <: parserObjectTypeIR
    -- let parser( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = typeIR as parserObjectTypeIR
    -- if typeIR' <: parserObjectTypeIR
    -- let parser( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = typeIR' as parserObjectTypeIR
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:133.1-135.68
  rulegroup controltype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:133.1-135.68
    rule controltype: typeIR ~~ typeIR'
    -- if typeIR <: controlObjectTypeIR
    -- let control( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = typeIR as controlObjectTypeIR
    -- if typeIR' <: controlObjectTypeIR
    -- let control( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = typeIR' as controlObjectTypeIR
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:137.1-139.41
  rulegroup packagetype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:137.1-139.41
    rule packagetype: typeIR ~~ typeIR'
    -- if typeIR <: packageObjectTypeIR
    -- let package< typeIR_a*{typeIR_a <- typeIR_a*} > = typeIR as packageObjectTypeIR
    -- if typeIR' <: packageObjectTypeIR
    -- let package< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as packageObjectTypeIR
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:141.1-143.38
  rulegroup tabletype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:141.1-143.38
    rule tabletype: typeIR ~~ typeIR'
    -- if typeIR <: tableObjectTypeIR
    -- let table tid # typeIR_a = typeIR as tableObjectTypeIR
    -- if typeIR' <: tableObjectTypeIR
    -- let table tid' # typeIR_b = typeIR' as tableObjectTypeIR
    -- if (tid = tid')
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:147.1-148.21
  rulegroup defaulttype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:147.1-148.21
    rule defaulttype: typeIR ~~ typeIR'
    -- if (typeIR = default as typeIR)
    -- if (typeIR' = default as typeIR)
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:150.1-152.41
  rulegroup sequencetype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:150.1-152.41
    rule sequencetype: typeIR ~~ typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR' matches `SEQ<%>`
    -- let seq< typeIR_b*{typeIR_b <- typeIR_b*} > = sequenceTypeIR'
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:154.1-156.41
  rulegroup sequencedefaulttype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:154.1-156.41
    rule sequencedefaulttype: typeIR ~~ typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR' matches `SEQ<%,...>`
    -- let seq< typeIR_b*{typeIR_b <- typeIR_b*} ,...> = sequenceTypeIR'
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:158.1-160.41
  rulegroup recordtype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:158.1-160.41
    rule recordtype: typeIR ~~ typeIR'
    -- if typeIR <: recordTypeIR
    -- let recordTypeIR = typeIR as recordTypeIR
    -- if recordTypeIR matches `RECORD{%}`
    -- let record{ typeIR_a id ;*{id <- id*, typeIR_a <- typeIR_a*} } = recordTypeIR
    -- if typeIR' <: recordTypeIR
    -- let recordTypeIR' = typeIR' as recordTypeIR
    -- if recordTypeIR' matches `RECORD{%}`
    -- let record{ typeIR_b id' ;*{id' <- id'*, typeIR_b <- typeIR_b*} } = recordTypeIR'
    -- (if (id = id'))*{id <- id*, id' <- id'*}
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:162.1-165.41
  rulegroup recorddefaulttype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:162.1-165.41
    rule recorddefaulttype: typeIR ~~ typeIR'
    -- if typeIR <: recordTypeIR
    -- let recordTypeIR = typeIR as recordTypeIR
    -- if recordTypeIR matches `RECORD{%,...}`
    -- let record{ typeIR_a id ;*{id <- id*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
    -- if typeIR' <: recordTypeIR
    -- let recordTypeIR' = typeIR' as recordTypeIR
    -- if recordTypeIR' matches `RECORD{%,...}`
    -- let record{ typeIR_b id' ;*{id' <- id'*, typeIR_b <- typeIR_b*} ,...} = recordTypeIR'
    -- (if (id = id'))*{id <- id*, id' <- id'*}
    -- (if Type_alpha: typeIR_a ~~ typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:167.1-168.35
  rulegroup invalidtype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:167.1-168.35
    rule invalidtype: typeIR ~~ typeIR'
    -- if (typeIR = header_invalid as typeIR)
    -- if (typeIR' = header_invalid as typeIR)
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:170.1-172.38
  rulegroup settype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:170.1-172.38
    rule settype: typeIR' ~~ typeIR'''
    -- if typeIR' <: setTypeIR
    -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_a] = typeIR*{typeIR <- typeIR*}
    -- if typeIR''' <: setTypeIR
    -- let set< typeIR''*{typeIR'' <- typeIR''*} > = typeIR''' as setTypeIR
    -- if typeIR''*{typeIR'' <- typeIR''*} matches [ _/1 ]
    -- let [typeIR_b] = typeIR''*{typeIR'' <- typeIR''*}
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:174.1-175.61
  rulegroup tableenumtype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:174.1-175.61
    rule tableenumtype: typeIR ~~ typeIR'
    -- if typeIR <: tableTypeIR
    -- let tableTypeIR = typeIR as tableTypeIR
    -- if tableTypeIR matches `TABLE_ENUM%{%}`
    -- let table_enum tid { id_f*{id_f <- id_f*} } = tableTypeIR
    -- if typeIR' <: tableTypeIR
    -- let tableTypeIR' = typeIR' as tableTypeIR
    -- if tableTypeIR' matches `TABLE_ENUM%{%}`
    -- let table_enum tid' { id_f'*{id_f' <- id_f'*} } = tableTypeIR'
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:177.1-180.45
  rulegroup tablestructtype {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:177.1-180.45
    rule tablestructtype: typeIR ~~ typeIR'
    -- if typeIR <: tableTypeIR
    -- let tableTypeIR = typeIR as tableTypeIR
    -- if tableTypeIR matches `TABLE_STRUCT%{%}`
    -- let table_struct tid { typeIR_f_a id_f ;*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*} } = tableTypeIR
    -- if typeIR' <: tableTypeIR
    -- let tableTypeIR' = typeIR' as tableTypeIR
    -- if tableTypeIR' matches `TABLE_STRUCT%{%}`
    -- let table_struct tid' { typeIR_f_b id_f' ;*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*} } = tableTypeIR'
    -- (if (id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}
    -- if (tid = tid')
    -- (if Type_alpha: typeIR_f_a ~~ typeIR_f_b holds)*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}
  }

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:9.1-11.20
relation ParameterType_alpha: parameterTypeIR ~~ parameterTypeIR

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:186.1-188.38
  rulegroup  {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:186.1-188.38
    rule : _direction typeIR_a _id _value?{_value <- _value?} ~~ _direction' typeIR_b _id' _value'?{_value' <- _value'?}
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
  }

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:13.1-15.20
relation RoutineType_alpha: routineTypeIR ~~ routineTypeIR

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:194.1-198.46
  rulegroup builtinfunction {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:194.1-198.46
    rule builtinfunction: routineTypeIR ~~ routineTypeIR'
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
    -- let builtin_function( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = functionTypeIR
    -- if routineTypeIR' <: functionTypeIR
    -- let functionTypeIR' = routineTypeIR' as functionTypeIR
    -- if functionTypeIR' matches `BUILTIN_FUNCTION(%)->%`
    -- let builtin_function( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = functionTypeIR'
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:200.1-204.46
  rulegroup function {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:200.1-204.46
    rule function: routineTypeIR ~~ routineTypeIR'
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `FUNCTION(%)->%`
    -- let function( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = functionTypeIR
    -- if routineTypeIR' <: functionTypeIR
    -- let functionTypeIR' = routineTypeIR' as functionTypeIR
    -- if functionTypeIR' matches `FUNCTION(%)->%`
    -- let function( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = functionTypeIR'
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:206.1-208.68
  rulegroup action {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:206.1-208.68
    rule action: routineTypeIR ~~ routineTypeIR'
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `ACTION(%)`
    -- let action( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = functionTypeIR
    -- if routineTypeIR' <: functionTypeIR
    -- let functionTypeIR' = routineTypeIR' as functionTypeIR
    -- if functionTypeIR' matches `ACTION(%)`
    -- let action( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = functionTypeIR'
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:210.1-214.46
  rulegroup externfunction {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:210.1-214.46
    rule externfunction: routineTypeIR ~~ routineTypeIR'
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
    -- let extern_function( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = functionTypeIR
    -- if routineTypeIR' <: functionTypeIR
    -- let functionTypeIR' = routineTypeIR' as functionTypeIR
    -- if functionTypeIR' matches `EXTERN_FUNCTION(%)->%`
    -- let extern_function( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = functionTypeIR'
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:216.1-220.46
  rulegroup builtinmethod {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:216.1-220.46
    rule builtinmethod: routineTypeIR ~~ routineTypeIR'
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
    -- let builtin_method( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = methodTypeIR
    -- if routineTypeIR' <: methodTypeIR
    -- let methodTypeIR' = routineTypeIR' as methodTypeIR
    -- if methodTypeIR' matches `BUILTIN_METHOD(%)->%`
    -- let builtin_method( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = methodTypeIR'
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:222.1-226.46
  rulegroup externmethod {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:222.1-226.46
    rule externmethod: routineTypeIR ~~ routineTypeIR'
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
    -- let extern_method( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = methodTypeIR
    -- if routineTypeIR' <: methodTypeIR
    -- let methodTypeIR' = routineTypeIR' as methodTypeIR
    -- if methodTypeIR' matches `EXTERN_METHOD(%)->%`
    -- let extern_method( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = methodTypeIR'
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:228.1-232.46
  rulegroup externmethod-abstract {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:228.1-232.46
    rule externmethod-abstract: routineTypeIR ~~ routineTypeIR'
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
    -- let extern_methodabstract( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} )-> typeIR_ret_a = methodTypeIR
    -- if routineTypeIR' <: methodTypeIR
    -- let methodTypeIR' = routineTypeIR' as methodTypeIR
    -- if methodTypeIR' matches `EXTERN_METHODABSTRACT(%)->%`
    -- let extern_methodabstract( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} )-> typeIR_ret_b = methodTypeIR'
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:234.1-237.68
  rulegroup parserapply {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:234.1-237.68
    rule parserapply: routineTypeIR ~~ routineTypeIR'
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `PARSER_APPLY(%)`
    -- let parser_apply( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = methodTypeIR
    -- if routineTypeIR' <: methodTypeIR
    -- let methodTypeIR' = routineTypeIR' as methodTypeIR
    -- if methodTypeIR' matches `PARSER_APPLY(%)`
    -- let parser_apply( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = methodTypeIR'
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:239.1-242.68
  rulegroup controlapply {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:239.1-242.68
    rule controlapply: routineTypeIR ~~ routineTypeIR'
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `CONTROL_APPLY(%)`
    -- let control_apply( parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} ) = methodTypeIR
    -- if routineTypeIR' <: methodTypeIR
    -- let methodTypeIR' = routineTypeIR' as methodTypeIR
    -- if methodTypeIR' matches `CONTROL_APPLY(%)`
    -- let control_apply( parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} ) = methodTypeIR'
    -- (if ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds)*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:244.1-247.46
  rulegroup tableapply {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:244.1-247.46
    rule tableapply: routineTypeIR ~~ routineTypeIR'
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `TABLE_APPLY->%`
    -- let table_apply-> typeIR_ret_a = methodTypeIR
    -- if routineTypeIR' <: methodTypeIR
    -- let methodTypeIR' = routineTypeIR' as methodTypeIR
    -- if methodTypeIR' matches `TABLE_APPLY->%`
    -- let table_apply-> typeIR_ret_b = methodTypeIR'
    -- if Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds
  }

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:17.1-19.20
relation RoutineTypeDef_alpha: routineTypeDefIR ~~ routineTypeDefIR

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:253.1-255.59
  rulegroup mono {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:253.1-255.59
    rule mono: routineTypeDefIR ~~ routineTypeDefIR'
    -- if routineTypeDefIR <: routineTypeIR
    -- let routineTypeIR_a = routineTypeDefIR as routineTypeIR
    -- if routineTypeDefIR' <: routineTypeIR
    -- let routineTypeIR_b = routineTypeDefIR' as routineTypeIR
    -- if RoutineType_alpha: routineTypeIR_a ~~ routineTypeIR_b holds
  }

  ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:257.1-276.71
  rulegroup poly {


    ;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:257.1-276.71
    rule poly: routineTypeDefIR ~~ routineTypeDefIR'
    -- if routineTypeDefIR <: polyRoutineTypeDefIR
    -- let routineTypeIR_a < tid_a*{tid_a <- tid_a*} , tid_hidden_a*{tid_hidden_a <- tid_hidden_a*} > = routineTypeDefIR as polyRoutineTypeDefIR
    -- if routineTypeDefIR' <: polyRoutineTypeDefIR
    -- let routineTypeIR_b < tid_b*{tid_b <- tid_b*} , tid_hidden_b*{tid_hidden_b <- tid_hidden_b*} > = routineTypeDefIR' as polyRoutineTypeDefIR
    -- if (|tid_a*{tid_a <- tid_a*}| = |tid_b*{tid_b <- tid_b*}|)
    -- if (|tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}| = |tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}|)
    -- let tid_fresh*{tid_fresh <- tid_fresh*} = $fresh_tids((|tid_a*{tid_a <- tid_a*}| + |tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}|))
    -- let tid_a'*{tid_a' <- tid_a'*} = tid_a*{tid_a <- tid_a*} ++ tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}
    -- let theta_a = { tid_a' : tid tid_fresh as typeIR*{tid_a' <- tid_a'*, tid_fresh <- tid_fresh*} }
    -- let routineTypeIR_a_subst = $subst_routineType(theta_a, routineTypeIR_a)
    -- let tid_b'*{tid_b' <- tid_b'*} = tid_b*{tid_b <- tid_b*} ++ tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}
    -- let theta_b = { tid_b' : tid tid_fresh as typeIR*{tid_b' <- tid_b'*, tid_fresh <- tid_fresh*} }
    -- let routineTypeIR_b_subst = $subst_routineType(theta_b, routineTypeIR_b)
    -- if RoutineType_alpha: routineTypeIR_a_subst ~~ routineTypeIR_b_subst holds
  }

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:5.14-5.30
syntax ctk = 
   | lctk
   | ctk
   | dyn

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:7.1-7.30
def $join_ctk(ctk, ctk) : ctk =

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:9.1-9.33
  clause 0(ctk, ctk') = lctk
  -- if ctk matches `LCTK`
  -- if ctk' matches `LCTK`

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:10.1-10.31
  clause 1(ctk, ctk') = ctk
  -- if ctk matches `LCTK`
  -- if ctk' matches `CTK`

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:11.1-11.31
  clause 2(ctk, ctk') = ctk
  -- if ctk matches `CTK`
  -- if ctk' matches `LCTK`

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:12.1-12.30
  clause 3(ctk, ctk') = ctk
  -- if ctk matches `CTK`
  -- if ctk' matches `CTK`

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:13.1-14.15
  clause 4(ctk_a, ctk_b) = dyn
  -- otherwise

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:16.1-16.27
def $joins_ctk(ctk*) : ctk =

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:18.1-18.26
  clause 0(ctk*{ctk <- ctk*}) = dyn
  -- if ctk*{ctk <- ctk*} matches []

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:19.1-19.26
  clause 1(ctk'*{ctk' <- ctk'*}) = ctk
  -- if ctk'*{ctk' <- ctk'*} matches [ _/1 ]
  -- let [ctk] = ctk'*{ctk' <- ctk'*}

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:20.1-20.57
  clause 2(ctk'*{ctk' <- ctk'*}) = $join_ctk(ctk_a, ctk_b)
  -- if ctk'*{ctk' <- ctk'*} matches _ :: _
  -- let ctk_a :: ctk*{ctk <- ctk*} = ctk'*{ctk' <- ctk'*}
  -- if ctk*{ctk <- ctk*} matches [ _/1 ]
  -- let [ctk_b] = ctk*{ctk <- ctk*}

  ;; ../../../../spec-concrete/2.3-compile-time-known.watsup:21.1-22.40
  clause 3(ctk'*{ctk' <- ctk'*}) = $joins_ctk(ctk_d :: ctk_c*{ctk_c <- ctk_c*})
  -- if ctk'*{ctk' <- ctk'*} matches _ :: _
  -- let ctk_a :: ctk*{ctk <- ctk*} = ctk'*{ctk' <- ctk'*}
  -- if ctk*{ctk <- ctk*} matches _ :: _
  -- let ctk_b :: ctk_c*{ctk_c <- ctk_c*} = ctk*{ctk <- ctk*}
  -- let ctk_d = $join_ctk(ctk_a, ctk_b)

;; ../../../../spec-concrete/3-numerics.watsup:5.1-5.21
def $pow2(nat) : int =

;; ../../../../spec-concrete/3-numerics.watsup:7.1-7.25
def $shl(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:8.1-8.25
def $shr(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:9.1-9.36
def $shr_arith(int, int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:11.1-11.21
def $bneg(int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:12.1-12.26
def $band(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:13.1-13.26
def $bxor(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:14.1-14.25
def $bor(int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:16.1-16.33
def $bitacc(int, int, int) : int =

;; ../../../../spec-concrete/3-numerics.watsup:24.1-24.28
def $un_bnot(value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:26.1-27.22
  clause 0(value) = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i = numberLiteral
  -- let i' = $bneg(i)

;; ../../../../spec-concrete/3-numerics.watsup:31.1-31.28
def $un_lnot(value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:33.1-33.27
  clause 0(value) = b ~b as value
  -- if value <: primitiveValue
  -- let primitiveValue = value as primitiveValue
  -- if primitiveValue matches `B%`
  -- let b b = primitiveValue

;; ../../../../spec-concrete/3-numerics.watsup:37.1-37.28
def $un_plus(value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:39.1-39.24
  clause 0(value) = d i as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i = numberLiteral

  ;; ../../../../spec-concrete/3-numerics.watsup:40.1-40.28
  clause 1(value) = w w i as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i = numberLiteral

  ;; ../../../../spec-concrete/3-numerics.watsup:41.1-41.28
  clause 2(value) = w s i as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i = numberLiteral

;; ../../../../spec-concrete/3-numerics.watsup:45.1-45.29
def $un_minus(value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:47.1-47.29
  clause 0(value) = d -i as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i = numberLiteral

  ;; ../../../../spec-concrete/3-numerics.watsup:48.1-49.29
  clause 1(value) = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i = numberLiteral
  -- let i' = ($pow2(w) - i)

  ;; ../../../../spec-concrete/3-numerics.watsup:50.1-51.46
  clause 2(value) = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i = numberLiteral
  -- let i' = $to_bitstr(w as int, $to_int(w as int, -i))

;; ../../../../spec-concrete/3-numerics.watsup:59.1-59.36
def $bin_plus(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:61.1-61.45
  clause 0(value, value') = d (i_l + i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:62.1-65.43
  clause 1(value, value') = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, (i_l' + i_r'))

  ;; ../../../../spec-concrete/3-numerics.watsup:66.1-69.43
  clause 2(value, value') = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, (i_l' + i_r'))

  ;; ../../../../spec-concrete/3-numerics.watsup:84.1-87.43
  clause 3(value, value') = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, (i_l' - i_r'))

  ;; ../../../../spec-concrete/3-numerics.watsup:102.1-105.43
  clause 4(value, value') = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, (i_l' * i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:73.1-73.39
def $bin_satplus(value, value) : value =

;; ../../../../spec-concrete/3-numerics.watsup:77.1-77.37
def $bin_minus(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:79.1-79.46
  clause 0(value, value') = d (i_l - i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:80.1-83.43
  clause 1(value, value') = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, (i_l' - i_r'))

  ;; ../../../../spec-concrete/3-numerics.watsup:98.1-101.43
  clause 2(value, value') = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, (i_l' * i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:91.1-91.40
def $bin_satminus(value, value) : value =

;; ../../../../spec-concrete/3-numerics.watsup:95.1-95.35
def $bin_mul(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:97.1-97.44
  clause 0(value, value') = d (i_l * i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

;; ../../../../spec-concrete/3-numerics.watsup:109.1-109.35
def $bin_div(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:111.1-111.44
  clause 0(value, value') = d (i_l / i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

;; ../../../../spec-concrete/3-numerics.watsup:115.1-115.35
def $bin_mod(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:117.1-117.44
  clause 0(value, value') = d (i_l \ i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

;; ../../../../spec-concrete/3-numerics.watsup:121.1-121.35
def $bin_shl(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:123.1-123.46
  clause 0(value, value') = d $shl(i_l, i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:124.1-124.50
  clause 1(value, value') = d $shl(i_l, i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:125.1-126.33
  clause 2(value, value') = d $shl(i_l, i_r') as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_r' = $to_int(w_r as int, i_r)

  ;; ../../../../spec-concrete/3-numerics.watsup:128.1-129.49
  clause 3(value, value') = $bin_shl(w_l w i_l as value, w_l w $to_int(w_l as int, i_r) as value)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:130.1-131.45
  clause 4(value, value') = w_l w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i' = $to_bitstr(w_l as int, $shl(i_l, i_r))

  ;; ../../../../spec-concrete/3-numerics.watsup:132.1-134.46
  clause 5(value, value') = w_l w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_r' = $to_int(w_r as int, i_r)
  -- let i' = $to_bitstr(w_l as int, $shl(i_l, i_r'))

  ;; ../../../../spec-concrete/3-numerics.watsup:136.1-137.49
  clause 6(value, value') = $bin_shl(w_l s i_l as value, w_l s $to_int(w_l as int, i_r) as value)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:138.1-140.46
  clause 7(value, value') = w_l s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- let i' = $to_bitstr(w_l as int, $shl(i_l', i_r))

  ;; ../../../../spec-concrete/3-numerics.watsup:141.1-144.47
  clause 8(value, value') = w_l s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- let i_r' = $to_int(w_r as int, i_r)
  -- let i' = $to_bitstr(w_l as int, $shl(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:148.1-148.35
def $bin_shr(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:150.1-150.46
  clause 0(value, value') = d $shr(i_l, i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:151.1-151.50
  clause 1(value, value') = d $shr(i_l, i_r) as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:152.1-153.33
  clause 2(value, value') = d $shr(i_l, i_r') as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_r' = $to_int(w_r as int, i_r)

  ;; ../../../../spec-concrete/3-numerics.watsup:155.1-156.49
  clause 3(value, value') = $bin_shr(w_l w i_l as value, w_l w $to_int(w_l as int, i_r) as value)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:157.1-158.45
  clause 4(value, value') = w_l w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i' = $to_bitstr(w_l as int, $shr(i_l, i_r))

  ;; ../../../../spec-concrete/3-numerics.watsup:159.1-161.46
  clause 5(value, value') = w_l w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_r' = $to_int(w_r as int, i_r)
  -- let i' = $to_bitstr(w_l as int, $shr(i_l, i_r'))

  ;; ../../../../spec-concrete/3-numerics.watsup:163.1-167.34
  clause 6(value, value') = w_l s i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- if (i_l' < 0 as int)
  -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
  -- let i'' = $to_bitstr(w_l as int, i')

  ;; ../../../../spec-concrete/3-numerics.watsup:168.1-172.34
  clause 7(value, value') = w_l s i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- if (i_l' >= 0 as int)
  -- let i' = $shr(i_l, i_r)
  -- let i'' = $to_bitstr(w_l as int, i')

  ;; ../../../../spec-concrete/3-numerics.watsup:173.1-177.34
  clause 8(value, value') = w_l s i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- if (i_l' < 0 as int)
  -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
  -- let i'' = $to_bitstr(w_l as int, i')

  ;; ../../../../spec-concrete/3-numerics.watsup:178.1-182.34
  clause 9(value, value') = w_l s i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- if (i_l' >= 0 as int)
  -- let i' = $shr(i_l, i_r)
  -- let i'' = $to_bitstr(w_l as int, i')

  ;; ../../../../spec-concrete/3-numerics.watsup:183.1-188.34
  clause 10(value, value') = w_l s i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- let i_r' = $to_int(w_r as int, i_r)
  -- if (i_l' < 0 as int)
  -- let i' = $shr_arith(i_l, i_r, ($pow2(w_l) - 1 as int))
  -- let i'' = $to_bitstr(w_l as int, i')

  ;; ../../../../spec-concrete/3-numerics.watsup:189.1-194.34
  clause 11(value, value') = w_l s i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- let i_r' = $to_int(w_r as int, i_r)
  -- if (i_l' >= 0 as int)
  -- let i' = $shr(i_l, i_r)
  -- let i'' = $to_bitstr(w_l as int, i')

;; ../../../../spec-concrete/3-numerics.watsup:198.1-198.33
def $bin_le(value, value) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:200.1-200.42
  clause 0(value, value') = (i_l <= i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:201.1-201.46
  clause 1(value, value') = (i_l <= i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')

  ;; ../../../../spec-concrete/3-numerics.watsup:202.1-204.31
  clause 2(value, value') = (i_l' <= i_r')
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:208.1-208.33
def $bin_ge(value, value) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:210.1-210.42
  clause 0(value, value') = (i_l >= i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:211.1-211.46
  clause 1(value, value') = (i_l >= i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')

  ;; ../../../../spec-concrete/3-numerics.watsup:212.1-214.31
  clause 2(value, value') = (i_l' >= i_r')
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:218.1-218.33
def $bin_lt(value, value) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:220.1-220.41
  clause 0(value, value') = (i_l < i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:221.1-221.45
  clause 1(value, value') = (i_l < i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')

  ;; ../../../../spec-concrete/3-numerics.watsup:222.1-224.31
  clause 2(value, value') = (i_l' < i_r')
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:228.1-228.33
def $bin_gt(value, value) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:230.1-230.41
  clause 0(value, value') = (i_l > i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_r = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:231.1-231.45
  clause 1(value, value') = (i_l > i_r)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')

  ;; ../../../../spec-concrete/3-numerics.watsup:232.1-234.31
  clause 2(value, value') = (i_l' > i_r')
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)

;; ../../../../spec-concrete/3-numerics.watsup:238.1-238.33
def $bin_eq(value, value) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:242.1-243.42
  clause 0(value, value') = (primitiveValue_a = primitiveValue_b)
  -- if value <: primitiveValue
  -- let primitiveValue_a = value as primitiveValue
  -- if value' <: primitiveValue
  -- let primitiveValue_b = value' as primitiveValue

  ;; ../../../../spec-concrete/3-numerics.watsup:245.1-245.40
  clause 1(value, value') = (i_a = i_b)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i_a = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `D%`
  -- let d i_b = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:246.1-246.63
  clause 2(value, value') = ((w_a = w_b) /\ (i_a = i_b))
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_a w i_a = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_b w i_b = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:247.1-247.63
  clause 3(value, value') = ((w_a = w_b) /\ (i_a = i_b))
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_a s i_a = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_b s i_b = numberLiteral'

  ;; ../../../../spec-concrete/3-numerics.watsup:248.1-248.73
  clause 4(value, value') = ((w_a = w_b) /\ (i_a = i_b))
  -- if value <: numberValue
  -- let numberValue = value as numberValue
  -- if numberValue matches `%V%#%`
  -- let w_a v i_a # _nat = numberValue
  -- if value' <: numberValue
  -- let numberValue' = value' as numberValue
  -- if numberValue' matches `%V%#%`
  -- let w_b v i_b # _nat' = numberValue'

  ;; ../../../../spec-concrete/3-numerics.watsup:250.1-251.33
  clause 5(value, value') = $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})
  -- if value <: listValue
  -- let [ value_a*{value_a <- value_a*} ] = value as listValue
  -- if value' <: listValue
  -- let [ value_b*{value_b <- value_b*} ] = value' as listValue

  ;; ../../../../spec-concrete/3-numerics.watsup:252.1-253.33
  clause 6(value, value') = $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})
  -- if value <: tupleValue
  -- let ( value_a*{value_a <- value_a*} ) = value as tupleValue
  -- if value' <: tupleValue
  -- let ( value_b*{value_b <- value_b*} ) = value' as tupleValue

  ;; ../../../../spec-concrete/3-numerics.watsup:254.1-255.52
  clause 7(value, value') = ($bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*}) /\ (n_s_a = n_s_b))
  -- if value <: headerStackValue
  -- let [ value_a*{value_a <- value_a*} #( _nat ; n_s_a )] = value as headerStackValue
  -- if value' <: headerStackValue
  -- let [ value_b*{value_b <- value_b*} #( _nat' ; n_s_b )] = value' as headerStackValue

  ;; ../../../../spec-concrete/3-numerics.watsup:256.1-261.67
  clause 8(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
  -- if value <: structValue
  -- let struct tid_a { value_f_a id_f_a ;*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} } = value as structValue
  -- if value' <: structValue
  -- let struct tid_b { value_f_b id_f_b ;*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} } = value' as structValue

  ;; ../../../../spec-concrete/3-numerics.watsup:262.1-267.67
  clause 9(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
  -- if value <: headerValue
  -- let header tid_a { value_f_a id_f_a ;*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} } = value as headerValue
  -- if value' <: headerValue
  -- let header tid_b { value_f_b id_f_b ;*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} } = value' as headerValue

  ;; ../../../../spec-concrete/3-numerics.watsup:268.1-273.67
  clause 10(value, value') = ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))
  -- if value <: headerUnionValue
  -- let header_union tid_a { value_f_a id_f_a ;*{id_f_a <- id_f_a*, value_f_a <- value_f_a*} } = value as headerUnionValue
  -- if value' <: headerUnionValue
  -- let header_union tid_b { value_f_b id_f_b ;*{id_f_b <- id_f_b*, value_f_b <- value_f_b*} } = value' as headerUnionValue

  ;; ../../../../spec-concrete/3-numerics.watsup:274.1-275.41
  clause 11(value, value') = ((tid_a = tid_b) /\ (id_f_a = id_f_b))
  -- if value <: enumValue
  -- let enumValue = value as enumValue
  -- if enumValue matches `%.%`
  -- let tid_a . id_f_a = enumValue
  -- if value' <: enumValue
  -- let enumValue' = value' as enumValue
  -- if enumValue' matches `%.%`
  -- let tid_b . id_f_b = enumValue'

  ;; ../../../../spec-concrete/3-numerics.watsup:276.1-277.74
  clause 12(value, value') = (((tid_a = tid_b) /\ (id_f_a = id_f_b)) /\ $bin_eq(value_f_a, value_f_b))
  -- if value <: enumValue
  -- let enumValue = value as enumValue
  -- if enumValue matches `%.%#%`
  -- let tid_a . id_f_a # value_f_a = enumValue
  -- if value' <: enumValue
  -- let enumValue' = value' as enumValue
  -- if enumValue' matches `%.%#%`
  -- let tid_b . id_f_b # value_f_b = enumValue'

  ;; ../../../../spec-concrete/3-numerics.watsup:278.1-278.31
  clause 13(value, value') = true
  -- if (value = {#} as value)
  -- if (value' = {#} as value)

;; ../../../../spec-concrete/3-numerics.watsup:239.1-239.36
def $bin_eqs(value*, value*) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:280.1-280.30
  clause 0(value*{value <- value*}, value'*{value' <- value'*}) = true
  -- if value*{value <- value*} matches []
  -- if value'*{value' <- value'*} matches []

  ;; ../../../../spec-concrete/3-numerics.watsup:281.1-281.34
  clause 1(value*{value <- value*}, value'*{value' <- value'*}) = false
  -- if value*{value <- value*} matches []
  -- if value'*{value' <- value'*} matches _ :: _
  -- let _value :: _value'*{_value' <- _value'*} = value'*{value' <- value'*}

  ;; ../../../../spec-concrete/3-numerics.watsup:282.1-282.34
  clause 2(value*{value <- value*}, value'*{value' <- value'*}) = false
  -- if value*{value <- value*} matches _ :: _
  -- let _value :: _value'*{_value' <- _value'*} = value*{value <- value*}
  -- if value'*{value' <- value'*} matches []

  ;; ../../../../spec-concrete/3-numerics.watsup:283.1-284.70
  clause 3(value*{value <- value*}, value'*{value' <- value'*}) = ($bin_eq(value_a_h, value_b_h) /\ $bin_eqs(value_a_t*{value_a_t <- value_a_t*}, value_b_t*{value_b_t <- value_b_t*}))
  -- if value*{value <- value*} matches _ :: _
  -- let value_a_h :: value_a_t*{value_a_t <- value_a_t*} = value*{value <- value*}
  -- if value'*{value' <- value'*} matches _ :: _
  -- let value_b_h :: value_b_t*{value_b_t <- value_b_t*} = value'*{value' <- value'*}

;; ../../../../spec-concrete/3-numerics.watsup:240.1-240.55
def $bin_eqs_fields((value, id)*, (value, id)*) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:286.1-286.37
  clause 0((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = true
  -- if (value, id)*{(value, id) <- (value, id)*} matches []
  -- if (value, id)'*{(value, id)' <- (value, id)'*} matches []

  ;; ../../../../spec-concrete/3-numerics.watsup:287.1-287.41
  clause 1((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = false
  -- if (value, id)*{(value, id) <- (value, id)*} matches []
  -- if (value, id)'*{(value, id)' <- (value, id)'*} matches _ :: _
  -- let _(value, id) :: _(value, id)'*{_(value, id)' <- _(value, id)'*} = (value, id)'*{(value, id)' <- (value, id)'*}

  ;; ../../../../spec-concrete/3-numerics.watsup:288.1-288.41
  clause 2((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = false
  -- if (value, id)*{(value, id) <- (value, id)*} matches _ :: _
  -- let _(value, id) :: _(value, id)'*{_(value, id)' <- _(value, id)'*} = (value, id)*{(value, id) <- (value, id)*}
  -- if (value, id)'*{(value, id)' <- (value, id)'*} matches []

  ;; ../../../../spec-concrete/3-numerics.watsup:289.1-293.67
  clause 3((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*}) = (((id_a_h = id_b_h) /\ $bin_eq(value_a_h, value_b_h)) /\ $bin_eqs_fields((value_a_t, id_a_t)*{id_a_t <- id_a_t*, value_a_t <- value_a_t*}, (value_b_t, id_b_t)*{id_b_t <- id_b_t*, value_b_t <- value_b_t*}))
  -- if (value, id)*{(value, id) <- (value, id)*} matches _ :: _
  -- let (value_a_h, id_a_h) :: (value_a_t, id_a_t)*{id_a_t <- id_a_t*, value_a_t <- value_a_t*} = (value, id)*{(value, id) <- (value, id)*}
  -- if (value, id)'*{(value, id)' <- (value, id)'*} matches _ :: _
  -- let (value_b_h, id_b_h) :: (value_b_t, id_b_t)*{id_b_t <- id_b_t*, value_b_t <- value_b_t*} = (value, id)'*{(value, id)' <- (value, id)'*}

;; ../../../../spec-concrete/3-numerics.watsup:297.1-297.33
def $bin_ne(value, value) : bool =

  ;; ../../../../spec-concrete/3-numerics.watsup:299.1-299.59
  clause 0(value_l, value_r) = ~$bin_eq(value_l, value_r)

;; ../../../../spec-concrete/3-numerics.watsup:303.1-303.36
def $bin_band(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:305.1-306.44
  clause 0(value, value') = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')
  -- let i' = $to_bitstr(w as int, $band(i_l, i_r))

  ;; ../../../../spec-concrete/3-numerics.watsup:308.1-311.46
  clause 1(value, value') = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, $band(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:315.1-315.36
def $bin_bxor(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:317.1-318.44
  clause 0(value, value') = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')
  -- let i' = $to_bitstr(w as int, $bxor(i_l, i_r))

  ;; ../../../../spec-concrete/3-numerics.watsup:320.1-323.46
  clause 1(value, value') = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, $bxor(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:327.1-327.35
def $bin_bor(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:329.1-330.43
  clause 0(value, value') = w w i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w' w i_r = numberLiteral'
  -- if (w = w')
  -- let i' = $to_bitstr(w as int, $bor(i_l, i_r))

  ;; ../../../../spec-concrete/3-numerics.watsup:332.1-335.45
  clause 1(value, value') = w s i' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w' s i_r = numberLiteral'
  -- if (w = w')
  -- let i_l' = $to_int(w as int, i_l)
  -- let i_r' = $to_int(w as int, i_r)
  -- let i' = $to_bitstr(w as int, $bor(i_l', i_r'))

;; ../../../../spec-concrete/3-numerics.watsup:339.1-339.38
def $bin_concat(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:341.1-345.35
  clause 0(value, value') = w w i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i_l' = $shl(i_l, w_r as int)
  -- let i_l'' = (i_l' + i_r)
  -- let w = (w_l + w_r)
  -- let i'' = $to_bitstr(w as int, i_l'')

  ;; ../../../../spec-concrete/3-numerics.watsup:346.1-350.35
  clause 1(value, value') = w w i'' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w_l w i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_l' = $shl(i_l, w_r as int)
  -- let i_l'' = (i_l' + i_r)
  -- let w = (w_l + w_r)
  -- let i'' = $to_bitstr(w as int, i_l'')

  ;; ../../../../spec-concrete/3-numerics.watsup:352.1-357.37
  clause 2(value, value') = w s i''' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%W%`
  -- let w_r w i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- let i_l'' = $shl(i_l', w_r as int)
  -- let i_l''' = (i_l'' + i_r)
  -- let w = (w_l + w_r)
  -- let i''' = $to_bitstr(w as int, i_l''')

  ;; ../../../../spec-concrete/3-numerics.watsup:358.1-363.37
  clause 3(value, value') = w s i''' as value
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w_l s i_l = numberLiteral
  -- if value' <: numberLiteral
  -- let numberLiteral' = value' as numberLiteral
  -- if numberLiteral' matches `%S%`
  -- let w_r s i_r = numberLiteral'
  -- let i_l' = $to_int(w_l as int, i_l)
  -- let i_l'' = $shl(i_l', w_r as int)
  -- let i_l''' = (i_l'' + i_r)
  -- let w = (w_l + w_r)
  -- let i''' = $to_bitstr(w as int, i_l''')

;; ../../../../spec-concrete/3-numerics.watsup:367.1-367.36
def $bin_land(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:369.1-369.45
  clause 0(value, value') = b (b_l /\ b_r) as value
  -- if value <: primitiveValue
  -- let primitiveValue = value as primitiveValue
  -- if primitiveValue matches `B%`
  -- let b b_l = primitiveValue
  -- if value' <: primitiveValue
  -- let primitiveValue' = value' as primitiveValue
  -- if primitiveValue' matches `B%`
  -- let b b_r = primitiveValue'

;; ../../../../spec-concrete/3-numerics.watsup:373.1-373.35
def $bin_lor(value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:375.1-375.44
  clause 0(value, value') = b (b_l \/ b_r) as value
  -- if value <: primitiveValue
  -- let primitiveValue = value as primitiveValue
  -- if primitiveValue matches `B%`
  -- let b b_l = primitiveValue
  -- if value' <: primitiveValue
  -- let primitiveValue' = value' as primitiveValue
  -- if primitiveValue' matches `B%`
  -- let b b_r = primitiveValue'

;; ../../../../spec-concrete/3-numerics.watsup:381.1-381.36
def $cast_op(typeIR, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:398.1-398.50
  clause 0(typeIR, value) = $cast_bool(typeIR, b)
  -- if value <: primitiveValue
  -- let primitiveValue = value as primitiveValue
  -- if primitiveValue matches `B%`
  -- let b b = primitiveValue

  ;; ../../../../spec-concrete/3-numerics.watsup:414.1-414.52
  clause 1(typeIR, value) = $cast_arbint(typeIR, i)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `D%`
  -- let d i = numberLiteral

  ;; ../../../../spec-concrete/3-numerics.watsup:432.1-432.57
  clause 2(typeIR, value) = $cast_fixbit(typeIR, w, i)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w i = numberLiteral

  ;; ../../../../spec-concrete/3-numerics.watsup:449.1-449.57
  clause 3(typeIR, value) = $cast_fixint(typeIR, w, i)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%S%`
  -- let w s i = numberLiteral

  ;; ../../../../spec-concrete/3-numerics.watsup:462.1-463.48
  clause 4(typeIR, value) = $cast_struct(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
  -- if value <: structValue
  -- let struct tid { value_f id_f ;*{id_f <- id_f*, value_f <- value_f*} } = value as structValue

  ;; ../../../../spec-concrete/3-numerics.watsup:476.1-477.48
  clause 5(typeIR, value) = $cast_header(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
  -- if value <: headerValue
  -- let header tid { value_f id_f ;*{id_f <- id_f*, value_f <- value_f*} } = value as headerValue

  ;; ../../../../spec-concrete/3-numerics.watsup:481.1-481.64
  clause 6(typeIR, value') = $cast_op(typeIR, value)
  -- if value' <: enumValue
  -- let enumValue = value' as enumValue
  -- if enumValue matches `%.%#%`
  -- let _tid . _id # value = enumValue

  ;; ../../../../spec-concrete/3-numerics.watsup:510.1-510.71
  clause 7(typeIR, value') = $cast_sequence(typeIR, value*{value <- value*})
  -- if value' <: sequenceValue
  -- let sequenceValue = value' as sequenceValue
  -- if sequenceValue matches `SEQ(%)`
  -- let seq( value*{value <- value*} ) = sequenceValue

  ;; ../../../../spec-concrete/3-numerics.watsup:538.1-539.39
  clause 8(typeIR, value') = $cast_record(typeIR, (value, id)*{id <- id*, value <- value*})
  -- if value' <: recordValue
  -- let recordValue = value' as recordValue
  -- if recordValue matches `RECORD{%}`
  -- let record{ value id ;*{id <- id*, value <- value*} } = recordValue

  ;; ../../../../spec-concrete/3-numerics.watsup:545.1-545.49
  clause 9(typeIR, value) = $default(typeIR)
  -- if (value = default as value)

  ;; ../../../../spec-concrete/3-numerics.watsup:582.1-583.39
  clause 10(typeIR, value') = $cast_set_singleton(typeIR, value)
  -- if value' <: setValue
  -- let setValue = value' as setValue
  -- if setValue matches `SET{%}`
  -- let set{ value } = setValue

  ;; ../../../../spec-concrete/3-numerics.watsup:584.1-585.45
  clause 11(typeIR, value) = $cast_set_mask(typeIR, value_b, value_m)
  -- if value <: setValue
  -- let setValue = value as setValue
  -- if setValue matches `SET{%&&&%}`
  -- let set{ value_b &&& value_m } = setValue

  ;; ../../../../spec-concrete/3-numerics.watsup:586.1-587.46
  clause 12(typeIR, value) = $cast_set_range(typeIR, value_l, value_u)
  -- if value <: setValue
  -- let setValue = value as setValue
  -- if setValue matches `SET{%..%}`
  -- let set{ value_l .. value_u } = setValue

;; ../../../../spec-concrete/3-numerics.watsup:383.1-383.29
def $default(typeIR) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:594.1-594.49
  clause 0(typeIR) = $default'($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:384.1-384.30
def $default'(typeIR) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:596.1-596.30
  clause 0(typeIR) = b false as value
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:597.1-597.42
  clause 1(typeIR) = error. "NoError" as value
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:598.1-599.24
  clause 2(typeIR) = " text_empty " as value
  -- if (typeIR = string as typeIR)
  -- let text_empty = ""

  ;; ../../../../spec-concrete/3-numerics.watsup:601.1-601.25
  clause 3(typeIR) = d 0 as int as value
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:602.1-602.34
  clause 4(typeIR) = w w 0 as int as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:603.1-603.34
  clause 5(typeIR) = w s 0 as int as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:604.1-604.42
  clause 6(typeIR) = w v 0 as int # 0 as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:606.1-606.59
  clause 7(typeIR') = [ $default(typeIR)*{typeIR <- typeIR*} ] as value
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:608.1-609.56
  clause 8(typeIR') = [ value*{value <- value*} #( 0 ; n_s )] as value
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ n_s ] = typeIR' as headerStackTypeIR
  -- let value*{value <- value*} = $repeat_<value>($default(typeIR), n_s)

  ;; ../../../../spec-concrete/3-numerics.watsup:611.1-612.50
  clause 9(typeIR) = struct tid { $default(typeIR_f) id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } as value
  -- if typeIR <: structTypeIR
  -- let struct tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as structTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:614.1-615.50
  clause 10(typeIR) = header tid { $default(typeIR_f) id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } as value
  -- if typeIR <: headerTypeIR
  -- let header tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:617.1-618.56
  clause 11(typeIR) = header_union tid { $default(typeIR_f) id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } as value
  -- if typeIR <: headerUnionTypeIR
  -- let header_union tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerUnionTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:620.1-620.57
  clause 12(typeIR) = tid . id_f_h as value
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum tid { id*{id <- id*} } = enumTypeIR
  -- if id*{id <- id*} matches _ :: _
  -- let id_f_h :: _id*{_id <- _id*} = id*{id <- id*}

  ;; ../../../../spec-concrete/3-numerics.watsup:622.1-625.67
  clause 13(typeIR') = tid . id_zero # value_zero as value
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum tid # typeIR { id_f = value_f ;*{id_f <- id_f*, value_f <- value_f*} } = enumTypeIR
  -- let value_zero = $cast_arbint(typeIR, 0 as int)
  -- let id?{id <- id?} = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})
  -- if id?{id <- id?} matches (_)
  -- let ?(id_zero) = id?{id <- id?}

  ;; ../../../../spec-concrete/3-numerics.watsup:627.1-631.34
  clause 14(typeIR') = tid . id_zero # value_zero as value
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum tid # typeIR { id_f = value_f ;*{id_f <- id_f*, value_f <- value_f*} } = enumTypeIR
  -- let value_zero = $cast_arbint(typeIR, 0 as int)
  -- if (?() = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}))
  -- let id_zero = "__UNSPECIFIED"

;; ../../../../spec-concrete/3-numerics.watsup:388.1-388.37
def $cast_bool(typeIR, bool) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:391.1-391.59
  clause 0(typeIR, b) = $cast_bool'($canon(typeIR), b)

;; ../../../../spec-concrete/3-numerics.watsup:389.1-389.38
def $cast_bool'(typeIR, bool) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:393.1-393.31
  clause 0(typeIR, b) = b b as value
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:394.1-394.42
  clause 1(typeIR, bool) = w w 1 as int as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if (bool = true)

  ;; ../../../../spec-concrete/3-numerics.watsup:395.1-395.43
  clause 2(typeIR, bool) = w w 0 as int as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if (bool = false)

  ;; ../../../../spec-concrete/3-numerics.watsup:396.1-396.58
  clause 3(typeIR', b) = $cast_bool(typeIR, b)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:402.1-402.38
def $cast_arbint(typeIR, int) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:405.1-405.63
  clause 0(typeIR, i) = $cast_arbint'($canon(typeIR), i)

;; ../../../../spec-concrete/3-numerics.watsup:403.1-403.39
def $cast_arbint'(typeIR, int) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:407.1-407.39
  clause 0(typeIR, i) = b (i = 0 as int) as value
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:408.1-408.32
  clause 1(typeIR, i) = d i as value
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:409.1-409.58
  clause 2(typeIR, i) = w w $to_bitstr(w as int, i) as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:410.1-410.58
  clause 3(typeIR, i) = w s $to_bitstr(w as int, i) as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:411.1-411.62
  clause 4(typeIR', i) = $cast_arbint(typeIR, i)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:412.1-412.73
  clause 5(typeIR'', i) = set{ $cast_arbint(typeIR, i) } as value
  -- if typeIR'' <: setTypeIR
  -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
  -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:418.1-418.43
def $cast_fixbit(typeIR, nat, int) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:421.1-421.69
  clause 0(typeIR, w, i) = $cast_fixbit'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:419.1-419.44
def $cast_fixbit'(typeIR, nat, int) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:423.1-423.42
  clause 0(typeIR, w, i) = b (i = 1 as int) as value
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:424.1-424.35
  clause 1(typeIR, _nat, i) = d i as value
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:425.1-426.33
  clause 2(typeIR, _nat, i) = w_to w i' as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w_to > = numberTypeIR
  -- let i' = $to_bitstr(w_to as int, i)

  ;; ../../../../spec-concrete/3-numerics.watsup:427.1-428.33
  clause 3(typeIR, _nat, i) = w_to s i' as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w_to > = numberTypeIR
  -- let i' = $to_bitstr(w_to as int, i)

  ;; ../../../../spec-concrete/3-numerics.watsup:429.1-429.68
  clause 4(typeIR', w, i) = $cast_fixbit(typeIR, w, i)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:430.1-430.79
  clause 5(typeIR'', w, i) = set{ $cast_fixbit(typeIR, w, i) } as value
  -- if typeIR'' <: setTypeIR
  -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
  -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:436.1-436.43
def $cast_fixint(typeIR, nat, int) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:439.1-439.69
  clause 0(typeIR, w, i) = $cast_fixint'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:437.1-437.44
def $cast_fixint'(typeIR, nat, int) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:441.1-441.47
  clause 0(typeIR, w, i) = d $to_int(w as int, i) as value
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:442.1-443.50
  clause 1(typeIR, w_from, i) = w_to w i' as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w_to > = numberTypeIR
  -- let i' = $to_bitstr(w_to as int, $to_int(w_from as int, i))

  ;; ../../../../spec-concrete/3-numerics.watsup:444.1-445.50
  clause 2(typeIR, w_from, i) = w_to s i' as value
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w_to > = numberTypeIR
  -- let i' = $to_bitstr(w_to as int, $to_int(w_from as int, i))

  ;; ../../../../spec-concrete/3-numerics.watsup:446.1-446.68
  clause 3(typeIR', w, i) = $cast_fixint(typeIR, w, i)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:447.1-447.79
  clause 4(typeIR'', w, i) = set{ $cast_fixint(typeIR, w, i) } as value
  -- if typeIR'' <: setTypeIR
  -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
  -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:453.1-453.52
def $cast_struct(typeIR, tid, (value, id)*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:456.1-457.57
  clause 0(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = $cast_struct'($canon(typeIR), tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../spec-concrete/3-numerics.watsup:454.1-454.53
def $cast_struct'(typeIR, tid, (value, id)*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:459.1-460.39
  clause 0(typeIR, tid', (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = struct tid { value_f id_f ;*{id_f <- id_f*, value_f <- value_f*} } as value
  -- if typeIR <: structTypeIR
  -- let struct tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR
  -- if (tid = tid')

;; ../../../../spec-concrete/3-numerics.watsup:467.1-467.52
def $cast_header(typeIR, tid, (value, id)*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:470.1-471.57
  clause 0(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = $cast_header'($canon(typeIR), tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../spec-concrete/3-numerics.watsup:468.1-468.53
def $cast_header'(typeIR, tid, (value, id)*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:473.1-474.39
  clause 0(typeIR, tid', (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = header tid { value_f id_f ;*{id_f <- id_f*, value_f <- value_f*} } as value
  -- if typeIR <: headerTypeIR
  -- let header tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR
  -- if (tid = tid')

;; ../../../../spec-concrete/3-numerics.watsup:485.1-485.43
def $cast_sequence(typeIR, value*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:488.1-489.44
  clause 0(typeIR, value*{value <- value*}) = $cast_sequence'($canon(typeIR), value*{value <- value*})

;; ../../../../spec-concrete/3-numerics.watsup:486.1-486.44
def $cast_sequence'(typeIR, value*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:491.1-492.34
  clause 0(typeIR', value*{value <- value*}) = [ $cast_op(typeIR, value)*{value <- value*} ] as value
  -- if typeIR' <: listTypeIR
  -- let list< typeIR > = typeIR' as listTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:494.1-495.34
  clause 1(typeIR', value*{value <- value*}) = ( $cast_op(typeIR, value)*{typeIR <- typeIR*, value <- value*} ) as value
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:497.1-500.25
  clause 2(typeIR', value*{value <- value*}) = [ value_cast*{value_cast <- value_cast*} #( n_idx ; n_s )] as value
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ n_s ] = typeIR' as headerStackTypeIR
  -- (let value_cast = $cast_op(typeIR, value))*{value <- value*, value_cast <- value_cast*}
  -- let n_idx = |value*{value <- value*}|

  ;; ../../../../spec-concrete/3-numerics.watsup:502.1-504.50
  clause 3(typeIR, value*{value <- value*}) = struct tid { value_cast id_f ;*{id_f <- id_f*, value_cast <- value_cast*} } as value
  -- if typeIR <: structTypeIR
  -- let struct tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as structTypeIR
  -- (let value_cast = $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

  ;; ../../../../spec-concrete/3-numerics.watsup:506.1-508.50
  clause 4(typeIR, value*{value <- value*}) = header tid { value_cast id_f ;*{id_f <- id_f*, value_cast <- value_cast*} } as value
  -- if typeIR <: headerTypeIR
  -- let header tid { typeIR_f id_f ;*{id_f <- id_f*, typeIR_f <- typeIR_f*} } = typeIR as headerTypeIR
  -- (let value_cast = $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

;; ../../../../spec-concrete/3-numerics.watsup:516.1-516.47
def $cast_record(typeIR, (value, id)*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:519.1-520.48
  clause 0(typeIR, (value, id)*{id <- id*, value <- value*}) = $cast_record'($canon(typeIR), (value, id)*{id <- id*, value <- value*})

;; ../../../../spec-concrete/3-numerics.watsup:517.1-517.48
def $cast_record'(typeIR, (value, id)*) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:522.1-528.57
  clause 0(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = struct tid { value_f_cast id_f ;*{id_f <- id_f*, value_f_cast <- value_f_cast*} } as value
  -- if typeIR <: structTypeIR
  -- let struct tid { typeIR_t_f id_t_f ;*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*} } = typeIR as structTypeIR
  -- (let value?{value <- value?} = $find_map<id, value>({ id_f : value_f*{id_f <- id_f*, value_f <- value_f*} }, id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}
  -- (if value?{value <- value?} matches (_))*{value? <- value?*}
  -- (let ?(value_f') = value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}
  -- (let value_f_cast = $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

  ;; ../../../../spec-concrete/3-numerics.watsup:530.1-536.57
  clause 1(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}) = header tid { value_f_cast id_f ;*{id_f <- id_f*, value_f_cast <- value_f_cast*} } as value
  -- if typeIR <: headerTypeIR
  -- let header tid { typeIR_t_f id_t_f ;*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*} } = typeIR as headerTypeIR
  -- (let value?{value <- value?} = $find_map<id, value>({ id_f : value_f*{id_f <- id_f*, value_f <- value_f*} }, id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}
  -- (if value?{value <- value?} matches (_))*{value? <- value?*}
  -- (let ?(value_f') = value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}
  -- (let value_f_cast = $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

;; ../../../../spec-concrete/3-numerics.watsup:551.1-551.47
def $cast_set_singleton(typeIR, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:554.1-555.48
  clause 0(typeIR, value) = $cast_set_singleton'($canon(typeIR), value)

;; ../../../../spec-concrete/3-numerics.watsup:552.1-552.48
def $cast_set_singleton'(typeIR, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:557.1-558.37
  clause 0(typeIR'', value) = set{ $cast_op(typeIR, value) } as value
  -- if typeIR'' <: setTypeIR
  -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
  -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}

;; ../../../../spec-concrete/3-numerics.watsup:560.1-560.49
def $cast_set_mask(typeIR, value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:563.1-564.54
  clause 0(typeIR, value_b, value_m) = $cast_set_mask'($canon(typeIR), value_b, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:561.1-561.50
def $cast_set_mask'(typeIR, value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:566.1-569.49
  clause 0(typeIR'', value_b, value_m) = set{ value_b_cast &&& value_m_cast } as value
  -- if typeIR'' <: setTypeIR
  -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
  -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
  -- let value_b_cast = $cast_op(typeIR, value_b)
  -- let value_m_cast = $cast_op(typeIR, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:571.1-571.50
def $cast_set_range(typeIR, value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:574.1-575.55
  clause 0(typeIR, value_l, value_u) = $cast_set_range'($canon(typeIR), value_l, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:572.1-572.51
def $cast_set_range'(typeIR, value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:577.1-580.49
  clause 0(typeIR'', value_l, value_u) = set{ value_l_cast .. value_u_cast } as value
  -- if typeIR'' <: setTypeIR
  -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
  -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
  -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
  -- let value_l_cast = $cast_op(typeIR, value_l)
  -- let value_u_cast = $cast_op(typeIR, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:637.1-637.44
def $bitacc_op(value, value, value) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:639.1-644.35
  clause 0(value_b, value_h, value_l) = w w i as value
  -- let i_b = $to_number(value_b)
  -- let i_h = $to_number(value_h)
  -- let i_l = $to_number(value_l)
  -- let int = ((i_h + 1 as int) - i_l)
  -- if int <: nat
  -- let w = int as nat
  -- let i = $bitacc(i_b, i_h, i_l)

;; ../../../../spec-concrete/3-numerics.watsup:650.1-650.32
def $sizeof(typeIR, id) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:681.1-681.69
  clause 0(typeIR, text) = $sizeof_minSizeInBits(typeIR)
  -- if (text = "minSizeInBits")

  ;; ../../../../spec-concrete/3-numerics.watsup:688.1-688.71
  clause 1(typeIR, text) = $sizeof_minSizeInBytes(typeIR)
  -- if (text = "minSizeInBytes")

  ;; ../../../../spec-concrete/3-numerics.watsup:707.1-707.69
  clause 2(typeIR, text) = $sizeof_maxSizeInBits(typeIR)
  -- if (text = "maxSizeInBits")

  ;; ../../../../spec-concrete/3-numerics.watsup:714.1-714.71
  clause 3(typeIR, text) = $sizeof_maxSizeInBytes(typeIR)
  -- if (text = "maxSizeInBytes")

;; ../../../../spec-concrete/3-numerics.watsup:652.1-652.42
def $sizeof_minSizeInBits(typeIR) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:666.1-666.69
  clause 0(typeIR) = d $sizeof_minSizeInBits'(typeIR) as int as value

;; ../../../../spec-concrete/3-numerics.watsup:653.1-653.41
def $sizeof_minSizeInBits'(typeIR) : nat =

  ;; ../../../../spec-concrete/3-numerics.watsup:667.1-667.77
  clause 0(typeIR) = $sizeof_minSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:654.1-654.42
def $sizeof_minSizeInBits''(typeIR) : nat =

  ;; ../../../../spec-concrete/3-numerics.watsup:669.1-669.38
  clause 0(typeIR) = 1
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:670.1-670.44
  clause 1(typeIR) = w
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:671.1-671.44
  clause 2(typeIR) = w
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:672.1-672.47
  clause 3(typeIR) = 0
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:673.1-673.76
  clause 4(typeIR') = $sizeof_minSizeInBits'(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:674.1-674.86
  clause 5(typeIR') = $sizeof_minSizeInBits'(typeIR)
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:675.1-675.88
  clause 6(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:676.1-676.93
  clause 7(typeIR') = ($sizeof_minSizeInBits'(typeIR) * n_size)
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:677.1-677.98
  clause 8(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: structTypeIR
  -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:678.1-678.98
  clause 9(typeIR') = $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: headerTypeIR
  -- let header _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:679.1-679.104
  clause 10(typeIR') = $min($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: headerUnionTypeIR
  -- let header_union _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:656.1-656.43
def $sizeof_minSizeInBytes(typeIR) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:685.1-686.48
  clause 0(typeIR) = d (n_size / 8) as int as value
  -- let n_size = $sizeof_minSizeInBits'(typeIR)

;; ../../../../spec-concrete/3-numerics.watsup:658.1-658.42
def $sizeof_maxSizeInBits(typeIR) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:692.1-692.69
  clause 0(typeIR) = d $sizeof_maxSizeInBits'(typeIR) as int as value

;; ../../../../spec-concrete/3-numerics.watsup:659.1-659.41
def $sizeof_maxSizeInBits'(typeIR) : nat =

  ;; ../../../../spec-concrete/3-numerics.watsup:693.1-693.77
  clause 0(typeIR) = $sizeof_maxSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:660.1-660.42
def $sizeof_maxSizeInBits''(typeIR) : nat =

  ;; ../../../../spec-concrete/3-numerics.watsup:695.1-695.38
  clause 0(typeIR) = 1
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/3-numerics.watsup:696.1-696.44
  clause 1(typeIR) = w
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:697.1-697.44
  clause 2(typeIR) = w
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:698.1-698.47
  clause 3(typeIR) = w
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< w > = numberTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:699.1-699.76
  clause 4(typeIR') = $sizeof_maxSizeInBits'(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:700.1-700.86
  clause 5(typeIR') = $sizeof_maxSizeInBits'(typeIR)
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:701.1-701.88
  clause 6(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:702.1-702.93
  clause 7(typeIR') = ($sizeof_maxSizeInBits'(typeIR) * n_size)
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:703.1-703.98
  clause 8(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: structTypeIR
  -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:704.1-704.98
  clause 9(typeIR') = $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: headerTypeIR
  -- let header _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR

  ;; ../../../../spec-concrete/3-numerics.watsup:705.1-705.104
  clause 10(typeIR') = $max($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})
  -- if typeIR' <: headerUnionTypeIR
  -- let header_union _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR

;; ../../../../spec-concrete/3-numerics.watsup:662.1-662.43
def $sizeof_maxSizeInBytes(typeIR) : value =

  ;; ../../../../spec-concrete/3-numerics.watsup:711.1-712.48
  clause 0(typeIR) = d (n_size / 8) as int as value
  -- let n_size = $sizeof_maxSizeInBits'(typeIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:6.1-7.14
syntax prefixedNameIR = 
   | ` nameIR
   | . nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:9.1-9.63
def $prefixedNonTypeName(prefixedNonTypeName) : prefixedNameIR =

  ;; ../../../../spec-concrete/4-ir-syntax.watsup:10.1-10.62
  clause 0(prefixedNonTypeName) = ` $name(nonTypeName as name)
  -- if prefixedNonTypeName <: nonTypeName
  -- let nonTypeName = prefixedNonTypeName as nonTypeName

  ;; ../../../../spec-concrete/4-ir-syntax.watsup:11.1-11.69
  clause 1(prefixedNonTypeName) = . $name(nonTypeName as name)
  -- if prefixedNonTypeName matches ``ID.%`
  -- let . nonTypeName = prefixedNonTypeName

;; ../../../../spec-concrete/4-ir-syntax.watsup:13.1-13.57
def $prefixedTypeName(prefixedTypeName) : prefixedNameIR =

  ;; ../../../../spec-concrete/4-ir-syntax.watsup:14.1-14.53
  clause 0(prefixedTypeName) = ` $name(typeName as name)
  -- if prefixedTypeName <: typeName
  -- let typeName = prefixedTypeName as typeName

  ;; ../../../../spec-concrete/4-ir-syntax.watsup:15.1-15.61
  clause 1(prefixedTypeName) = . $name(typeName as name)
  -- if prefixedTypeName matches ``TID.%`
  -- let . typeName = prefixedTypeName

;; ../../../../spec-concrete/4-ir-syntax.watsup:17.1-17.53
def $flatten_prefixedNameIR(prefixedNameIR) : nameIR =

  ;; ../../../../spec-concrete/4-ir-syntax.watsup:18.1-18.48
  clause 0(prefixedNameIR) = nameIR
  -- if prefixedNameIR matches ``%`
  -- let ` nameIR = prefixedNameIR

  ;; ../../../../spec-concrete/4-ir-syntax.watsup:19.1-19.55
  clause 1(prefixedNameIR) = "." ++ nameIR
  -- if prefixedNameIR matches `.%`
  -- let . nameIR = prefixedNameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:21.21-21.28
syntax nameListIR = nameIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:27.26-27.29
syntax typeParameterIR = tid

;; ../../../../spec-concrete/4-ir-syntax.watsup:29.30-29.46
syntax typeParameterListIR = typeParameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:38.3-38.66
syntax parameterIR = 
   | annotationList direction typeIR nameIR constantInitializerOptIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:40.26-40.38
syntax parameterListIR = parameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:46.33-46.44
syntax constructorParameterIR = parameterIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:48.37-48.49
syntax constructorParameterListIR = parameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:56.28-56.55
syntax namedExpressionIR = 
   | nameIR = typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:58.32-58.50
syntax namedExpressionListIR = namedExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:68.30-68.47
syntax literalExpressionIR = literalExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:74.32-74.46
syntax referenceExpressionIR = prefixedNameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:80.30-80.47
syntax defaultExpressionIR = defaultExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:86.28-86.50
syntax unaryExpressionIR = 
   | unop typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:89.3-89.44
syntax binaryExpressionIR = 
   | typedExpressionIR binop typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:92.3-92.62
syntax ternaryExpressionIR = 
   | typedExpressionIR ? typedExpressionIR : typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:98.27-98.56
syntax castExpressionIR = 
   | ( typeIR ) typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:107.1-111.46
syntax dataExpressionIR = 
   | {#}
   | seq{ typedExpressionListIR }
   | seq{ typedExpressionListIR ,...}
   | record{ namedExpressionListIR }
   | record{ namedExpressionListIR ,...}

;; ../../../../spec-concrete/4-ir-syntax.watsup:120.3-120.18
syntax errorAccessExpressionIR = 
   | error. nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:123.3-123.31
syntax memberAccessExpressionIR = 
   | memberAccessBaseIR . nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:126.1-127.66
syntax indexAccessExpressionIR = 
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]

;; ../../../../spec-concrete/4-ir-syntax.watsup:130.1-132.28
syntax accessExpressionIR = 
   | error. nameIR
   | memberAccessBaseIR . nameIR
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]

;; ../../../../spec-concrete/4-ir-syntax.watsup:143.1-146.25
syntax routineTargetIR = 
   | ` nameIR
   | . nameIR
   | typedExpressionIR . nameIR
   | type prefixedNameIR . nameIR
   | ( routineTargetIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:148.30-148.68
syntax constructorTargetIR = 
   | prefixedNameIR < typeArgumentListIR >

;; ../../../../spec-concrete/4-ir-syntax.watsup:151.1-152.64
syntax callExpressionIR = 
   | constructorTargetIR ( argumentListIR )
   | routineTargetIR < typeArgumentListIR >( argumentListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:158.36-158.58
syntax parenthesizedExpressionIR = 
   | ( typedExpressionIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:165.1-175.30
syntax expressionIR = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | ` nameIR
   | . nameIR
   | ...
   | unop typedExpressionIR
   | typedExpressionIR binop typedExpressionIR
   | typedExpressionIR ? typedExpressionIR : typedExpressionIR
   | ( typeIR ) typedExpressionIR
   | {#}
   | seq{ typedExpressionListIR }
   | seq{ typedExpressionListIR ,...}
   | record{ namedExpressionListIR }
   | record{ namedExpressionListIR ,...}
   | error. nameIR
   | memberAccessBaseIR . nameIR
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]
   | constructorTargetIR ( argumentListIR )
   | routineTargetIR < typeArgumentListIR >( argumentListIR )
   | ( typedExpressionIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:177.27-177.42
syntax expressionNoteIR = 
   | ( typeIR ctk )

;; ../../../../spec-concrete/4-ir-syntax.watsup:180.3-180.35
syntax typedExpressionIR = 
   | expressionIR # expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:182.32-182.50
syntax typedExpressionListIR = typedExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:185.1-186.22
syntax memberAccessBaseIR = 
   | type prefixedNameIR
   | expressionIR # expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:193.1-197.7
syntax simpleKeysetExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR &&& typedExpressionIR
   | typedExpressionIR .. typedExpressionIR
   | default
   | _

;; ../../../../spec-concrete/4-ir-syntax.watsup:199.39-199.64
syntax simpleKeysetExpressionListIR = simpleKeysetExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:201.34-201.67
syntax tupleKeysetExpressionIR = 
   | ( simpleKeysetExpressionListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:204.1-205.28
syntax keysetExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR &&& typedExpressionIR
   | typedExpressionIR .. typedExpressionIR
   | default
   | _
   | ( simpleKeysetExpressionListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:211.25-211.31
syntax typeArgumentIR = typeIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:213.29-213.44
syntax typeArgumentListIR = typeArgumentIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:220.1-223.7
syntax argumentIR = 
   | expressionIR # expressionNoteIR
   | nameIR = typedExpressionIR
   | nameIR =_
   | _

;; ../../../../spec-concrete/4-ir-syntax.watsup:225.25-225.36
syntax argumentListIR = argumentIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:232.1-236.23
syntax lvalueIR = 
   | ` nameIR
   | . nameIR
   | typedLvalueIR . nameIR
   | typedLvalueIR [ typedExpressionIR ]
   | typedLvalueIR [ typedExpressionIR : typedExpressionIR ]
   | ( typedLvalueIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:238.24-238.47
syntax typedLvalueIR = 
   | lvalueIR #( typeIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:248.27-248.41
syntax emptyStatementIR = emptyStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:255.3-255.46
syntax assignmentStatementIR = 
   | typedLvalueIR assignop typedExpressionIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:262.3-262.65
syntax callStatementIR = 
   | routineTargetIR < typeArgumentListIR >( argumentListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:269.3-269.49
syntax directApplicationStatementIR = 
   | prefixedNameIR .apply( argumentListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:276.1-277.32
syntax returnStatementIR = 
   | return;
   | return typedExpressionIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:283.26-283.39
syntax exitStatementIR = exitStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:292.3-292.50
syntax blockStatementIR = 
   | annotationList { blockElementStatementListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:301.1-302.59
syntax conditionalStatementIR = 
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:311.1-314.35
syntax forInitStatementIR = 
   | annotationList typeIR nameIR initializerOptIR
   | lvalueIR ( argumentListIR )
   | lvalueIR < typeArgumentListIR >( argumentListIR )
   | lvalueIR assignop expressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:316.33-316.52
syntax forInitStatementListIR = forInitStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:318.31-318.49
syntax forUpdateStatementIR = forInitStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:320.35-320.56
syntax forUpdateStatementListIR = forUpdateStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:323.1-324.44
syntax forCollectionExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR .. typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:327.1-335.18
syntax forStatementIR = 
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:342.1-343.22
syntax switchLabelIR = 
   | default
   | expressionIR # expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:346.1-347.21
syntax switchCaseIR = 
   | switchLabelIR : blockStatementIR
   | switchLabelIR :

;; ../../../../spec-concrete/4-ir-syntax.watsup:349.27-349.40
syntax switchCaseListIR = switchCaseIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:352.3-352.54
syntax switchStatementIR = 
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:358.27-358.41
syntax breakStatementIR = breakStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:360.30-360.47
syntax continueStatementIR = continueStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:367.1-378.22
syntax statementIR = 
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | return;
   | return typedExpressionIR ;
   | exit;
   | annotationList { blockElementStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR
   | break;
   | continue;
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:388.32-388.40
syntax constantInitializerIR = 
   | = value

;; ../../../../spec-concrete/4-ir-syntax.watsup:390.35-390.57
syntax constantInitializerOptIR = constantInitializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:393.3-393.62
syntax constantDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:395.24-395.44
syntax initializerIR = 
   | = typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:397.27-397.41
syntax initializerOptIR = initializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:400.3-400.51
syntax variableDeclarationIR = 
   | annotationList typeIR nameIR initializerOptIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:403.1-405.16
syntax blockElementStatementIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | return;
   | return typedExpressionIR ;
   | exit;
   | annotationList { blockElementStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR
   | break;
   | continue;
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:407.38-407.62
syntax blockElementStatementListIR = blockElementStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:414.3-415.73
syntax functionPrototypeIR = 
   | typeIR nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:418.3-418.54
syntax functionDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:425.3-425.69
syntax actionDeclarationIR = 
   | annotationList action nameIR ( parameterListIR ) blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:433.30-433.61
syntax objectInitializerIR = 
   | ={ objectDeclarationListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:435.33-435.53
syntax objectInitializerOptIR = objectInitializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:438.3-440.30
syntax instantiationIR = 
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:443.1-444.20
syntax objectDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:446.34-446.54
syntax objectDeclarationListIR = objectDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:452.29-452.50
syntax errorDeclarationIR = 
   | error{ nameListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:458.33-458.59
syntax matchKindDeclarationIR = 
   | match_kind{ nameListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:469.1-470.65
syntax enumTypeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:476.22-476.53
syntax typeFieldIR = 
   | annotationList typeIR nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:478.26-478.38
syntax typeFieldListIR = typeFieldIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:481.3-482.73
syntax structTypeDeclarationIR = 
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:485.3-486.73
syntax headerTypeDeclarationIR = 
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:489.3-490.73
syntax headerUnionTypeDeclarationIR = 
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:493.1-496.33
syntax derivedTypeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:503.1-504.29
syntax typedefTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:507.1-508.41
syntax typedefDeclarationIR = 
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:515.3-515.47
syntax externFunctionDeclarationIR = 
   | annotationList extern functionPrototypeIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:518.1-520.51
syntax methodPrototypeIR = 
   | annotationList nameIR <, typeParameterListIR >( parameterListIR );
   | annotationList functionPrototypeIR ;
   | annotationList abstract functionPrototypeIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:522.32-522.50
syntax methodPrototypeListIR = methodPrototypeIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:525.3-527.31
syntax externObjectDeclarationIR = 
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:530.1-531.30
syntax externDeclarationIR = 
   | annotationList extern functionPrototypeIR ;
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:541.23-541.54
syntax selectCaseIR = 
   | keysetExpressionIR : nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:543.27-543.40
syntax selectCaseListIR = selectCaseIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:546.3-546.58
syntax selectExpressionIR = 
   | select( typedExpressionListIR ){ selectCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:553.1-554.23
syntax stateExpressionIR = 
   | nameIR ;
   | select( typedExpressionListIR ){ selectCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:556.32-556.60
syntax transitionStatementIR = 
   | transition stateExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:563.3-563.72
syntax valueSetDeclarationIR = 
   | annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:570.3-571.76
syntax parserTypeDeclarationIR = 
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:580.3-580.44
syntax parserBlockStatementIR = 
   | annotationList { parserStatementListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:583.1-590.27
syntax parserStatementIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | annotationList { parserStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:592.32-592.50
syntax parserStatementListIR = parserStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:595.3-596.53
syntax parserStateIR = 
   | annotationList state nameIR { parserStatementListIR transitionStatementIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:598.28-598.42
syntax parserStateListIR = parserStateIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:601.1-604.26
syntax parserLocalDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:607.3-607.28
syntax parserLocalDeclarationListIR = parserLocalDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:610.3-613.56
syntax parserDeclarationIR = 
   | annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:623.18-623.23
syntax constIR = const

;; ../../../../spec-concrete/4-ir-syntax.watsup:625.21-625.29
syntax constOptIR = constIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:631.21-631.66
syntax tableKeyIR = 
   | typedExpressionIR : nameIR annotationList ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:633.25-633.36
syntax tableKeyListIR = tableKeyIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:639.33-639.67
syntax tableActionReferenceIR = 
   | prefixedNameIR ( argumentListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:641.24-641.64
syntax tableActionIR = 
   | annotationList tableActionReferenceIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:643.28-643.42
syntax tableActionListIR = tableActionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:650.1-651.42
syntax tableEntryPriorityIR = 
   | priority= numberLiteral :
   | priority=( typedExpressionIR ):

;; ../../../../spec-concrete/4-ir-syntax.watsup:653.34-653.55
syntax tableEntryPriorityOptIR = tableEntryPriorityIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:656.3-657.67
syntax tableEntryIR = 
   | constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:659.27-659.40
syntax tableEntryListIR = tableEntryIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:666.1-672.75
syntax tablePropertyIR = 
   | key={ tableKeyListIR }
   | actions={ tableActionListIR }
   | annotationList constOptIR entries={ tableEntryListIR }
   | annotationList constOptIR default_action= tableActionReferenceIR ;
   | annotationList constOptIR custom nameIR initializerIR ;
   | annotationList constOptIR custom_const nameIR constantInitializerIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:674.30-674.46
syntax tablePropertyListIR = tablePropertyIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:677.3-677.62
syntax tableDeclarationIR = 
   | annotationList table typeIR nameIR { tablePropertyListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:684.3-686.28
syntax controlTypeDeclarationIR = 
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:692.24-692.40
syntax controlBodyIR = blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:695.1-699.23
syntax controlLocalDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | annotationList action nameIR ( parameterListIR ) blockStatementIR
   | annotationList table typeIR nameIR { tablePropertyListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:702.3-702.29
syntax controlLocalDeclarationListIR = controlLocalDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:705.3-708.59
syntax controlDeclarationIR = 
   | annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:715.3-717.28
syntax packageTypeDeclarationIR = 
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:724.1-728.29
syntax typeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:735.1-744.22
syntax declarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList action nameIR ( parameterListIR ) blockStatementIR
   | error{ nameListIR }
   | match_kind{ nameListIR }
   | annotationList extern functionPrototypeIR ;
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }
   | annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
   | annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:750.22-750.39
syntax p4programIR = 
   | declarationIR* ;

;; ../../../../spec-concrete/5.0-flow.watsup:5.15-5.25
syntax flow = 
   | cont
   | ret

;; ../../../../spec-concrete/5.0-flow.watsup:9.1-9.34
def $join_flow(flow, flow) : flow =

  ;; ../../../../spec-concrete/5.0-flow.watsup:10.1-10.31
  clause 0(flow, flow') = ret
  -- if flow matches `RET`
  -- if flow' matches `RET`

  ;; ../../../../spec-concrete/5.0-flow.watsup:11.1-12.15
  clause 1(f_a, f_b) = cont
  -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:5.20-5.47
syntax varTypeIR = 
   | direction typeIR ctk value?

;; ../../../../spec-concrete/5.01-env.watsup:12.16-12.34
syntax frame = map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:14.1-14.27
def $empty_frame : frame =

  ;; ../../../../spec-concrete/5.01-env.watsup:15.1-15.47
  clause 0 = $empty_map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:18.16-18.35
syntax tdenv = map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:20.1-20.27
def $empty_tdenv : tdenv =

  ;; ../../../../spec-concrete/5.01-env.watsup:21.1-21.48
  clause 0 = $empty_map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:24.16-24.42
syntax rdenv = map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:26.1-26.27
def $empty_rdenv : rdenv =

  ;; ../../../../spec-concrete/5.01-env.watsup:27.1-27.55
  clause 0 = $empty_map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:30.16-30.46
syntax cdenv = map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:32.1-32.27
def $empty_cdenv : cdenv =

  ;; ../../../../spec-concrete/5.01-env.watsup:33.1-33.59
  clause 0 = $empty_map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:39.1-39.39
def $check_routine_name(id, id) : bool =

  ;; ../../../../spec-concrete/5.01-env.watsup:40.1-40.50
  clause 0(id_l, id_r) = (id_l = id_r)

;; ../../../../spec-concrete/5.01-env.watsup:42.1-42.37
def $check_arity(id?*, id*) : bool =

  ;; ../../../../spec-concrete/5.01-env.watsup:43.1-43.72
  clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| = |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:45.1-45.42
def $check_arity_more(id?*, id*) : bool =

  ;; ../../../../spec-concrete/5.01-env.watsup:46.1-46.77
  clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:48.1-48.42
def $check_arity_less(id?*, id*) : bool =

  ;; ../../../../spec-concrete/5.01-env.watsup:49.1-49.77
  clause 0(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*}) = (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| < |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:51.1-51.44
def $get_missing_parameters(id*, id*) : id* =

  ;; ../../../../spec-concrete/5.01-env.watsup:53.1-53.48
  clause 0(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = []
  -- if id*{id <- id*} matches []

  ;; ../../../../spec-concrete/5.01-env.watsup:54.1-59.47
  clause 1(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = id_param_h :: $get_missing_parameters(id_param_t*{id_param_t <- id_param_t*}, id_arg*{id_arg <- id_arg*})
  -- if id*{id <- id*} matches _ :: _
  -- let id_param_h :: id_param_t*{id_param_t <- id_param_t*} = id*{id <- id*}
  -- if ~$in_set<id>(id_param_h, { id_arg*{id_arg <- id_arg*} })

  ;; ../../../../spec-concrete/5.01-env.watsup:60.1-65.15
  clause 2(id*{id <- id*}, id_arg*{id_arg <- id_arg*}) = $get_missing_parameters(id_param_t*{id_param_t <- id_param_t*}, id_arg*{id_arg <- id_arg*})
  -- if id*{id <- id*} matches _ :: _
  -- let id_param_h :: id_param_t*{id_param_t <- id_param_t*} = id*{id <- id*}
  -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:68.1-68.61
def $find_match_named<V>(rid, V, id*, pid*) : (rid, V, id*)? =

  ;; ../../../../spec-concrete/5.01-env.watsup:70.1-72.50
  clause 0(rid, V, id_arg*{id_arg <- id_arg*}, id_param # bool_param*{bool_param <- bool_param*, id_param <- id_param*}) = ?((rid, V, []))
  -- if $eq_set<id>({ id_arg*{id_arg <- id_arg*} }, { id_param*{id_param <- id_param*} })

  ;; ../../../../spec-concrete/5.01-env.watsup:73.1-74.15
  clause 1(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:77.1-77.69
def $find_match_named_default<V>(rid, V, id*, pid*) : (rid, V, id*)? =

  ;; ../../../../spec-concrete/5.01-env.watsup:79.1-86.18
  clause 0(rid, V, id_arg*{id_arg <- id_arg*}, id_param # bool_param*{bool_param <- bool_param*, id_param <- id_param*}) = ?((rid, V, id_default*{id_default <- id_default*}))
  -- let id_default*{id_default <- id_default*} = $get_missing_parameters(id_param*{id_param <- id_param*}, id_arg*{id_arg <- id_arg*})
  -- if ($find_match_named<V>(rid, V, id_arg*{id_arg <- id_arg*} ++ id_default*{id_default <- id_default*}, id_param # bool_param*{bool_param <- bool_param*, id_param <- id_param*}) =/= ?())

  ;; ../../../../spec-concrete/5.01-env.watsup:87.1-88.15
  clause 1(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*}) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:91.1-91.74
def $find_match_unnamed_default<V>(rid, V, id?*, pid*) : (rid, V, id*)? =

  ;; ../../../../spec-concrete/5.01-env.watsup:93.1-95.74
  clause 0(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*}) = ?((rid, V, id_default*{id_default <- id_default*}))
  -- let (_pid*{_pid <- _pid*}, id_default # bool*{bool <- bool*, id_default <- id_default*}) = $partition_<pid>(pid*{pid <- pid*}, |id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}|)
  -- (if (bool = true))*{bool <- bool*}

  ;; ../../../../spec-concrete/5.01-env.watsup:96.1-97.15
  clause 1(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*}) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:100.1-100.64
def $find_matching<V>(id, id?*, id*, rid, V) : (rid, V, id*)? =

  ;; ../../../../spec-concrete/5.01-env.watsup:103.1-105.42
  clause 0(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' ( pid_r'*{pid_r' <- pid_r'*} ), V) = ?()
  -- if ~$check_routine_name(id_r, id_r')

  ;; ../../../../spec-concrete/5.01-env.watsup:107.1-113.50
  clause 1(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = ?()
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity_more(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

  ;; ../../../../spec-concrete/5.01-env.watsup:115.1-125.45
  clause 2(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = $find_match_named<V>(id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V, id_arg'*{id_arg' <- id_arg'*}, id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
  -- if (|id_arg'*{id_arg' <- id_arg'*}| > 0)
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

  ;; ../../../../spec-concrete/5.01-env.watsup:127.1-133.45
  clause 3(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id*{id <- id*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = ?((id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V, []))
  -- if id*{id <- id*} matches []
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

  ;; ../../../../spec-concrete/5.01-env.watsup:135.1-145.50
  clause 4(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = $find_match_named_default<V>(id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V, id_arg'*{id_arg' <- id_arg'*}, id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
  -- if (|id_arg'*{id_arg' <- id_arg'*}| > 0)
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

  ;; ../../../../spec-concrete/5.01-env.watsup:147.1-156.50
  clause 5(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id*{id <- id*}, id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V) = $find_match_unnamed_default<V>(id_r' ( id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*} ), V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param' # bool_param'*{bool_param' <- bool_param'*, id_param' <- id_param'*})
  -- if id*{id <- id*} matches []
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})

;; ../../../../spec-concrete/5.01-env.watsup:159.1-159.67
def $find_matchings<V>(id, id?*, id*, rid*, V*) : (rid, V, id*)* =

  ;; ../../../../spec-concrete/5.01-env.watsup:161.1-165.8
  clause 0(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = []
  -- if rid*{rid <- rid*} matches []
  -- if V*{V <- V*} matches []

  ;; ../../../../spec-concrete/5.01-env.watsup:166.1-171.72
  clause 1(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})
  -- if rid*{rid <- rid*} matches _ :: _
  -- let rid_h :: rid_t*{rid_t <- rid_t*} = rid*{rid <- rid*}
  -- if V*{V <- V*} matches _ :: _
  -- let V_h :: V_t*{V_t <- V_t*} = V*{V <- V*}
  -- if ($find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h) = ?())

  ;; ../../../../spec-concrete/5.01-env.watsup:172.1-178.66
  clause 2(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid'*{rid' <- rid'*}, V'*{V' <- V'*}) = (rid, V, id_default*{id_default <- id_default*}) :: $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})
  -- if rid'*{rid' <- rid'*} matches _ :: _
  -- let rid_h :: rid_t*{rid_t <- rid_t*} = rid'*{rid' <- rid'*}
  -- if V'*{V' <- V'*} matches _ :: _
  -- let V_h :: V_t*{V_t <- V_t*} = V'*{V' <- V'*}
  -- let (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} = $find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h)
  -- if (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} matches (_)
  -- let ?((rid, V, id_default*{id_default <- id_default*})) = (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?}

;; ../../../../spec-concrete/5.01-env.watsup:181.1-181.66
def $find_overloaded<V>(map<rid, V>, id, id?*) : (rid, V, id*)? =

  ;; ../../../../spec-concrete/5.01-env.watsup:184.1-190.71
  clause 0({ rid : V*{V <- V*, rid <- rid*} }, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
  -- if (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)
  -- (let id?{id <- id?} = id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}
  -- (if id?{id <- id?} matches (_))*{id? <- id?*}
  -- (let ?(id_arg') = id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}
  -- if ($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = [])

  ;; ../../../../spec-concrete/5.01-env.watsup:191.1-198.65
  clause 1({ rid : V*{V <- V*, rid <- rid*} }, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?((rid', V', id_default*{id_default <- id_default*}))
  -- if (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)
  -- (let id?{id <- id?} = id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}
  -- (if id?{id <- id?} matches (_))*{id? <- id?*}
  -- (let ?(id_arg') = id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}
  -- let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*})
  -- if (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches [ _/1 ]
  -- let [(rid', V', id_default*{id_default <- id_default*})] = (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*}

  ;; ../../../../spec-concrete/5.01-env.watsup:200.1-205.66
  clause 2({ rid : V*{V <- V*, rid <- rid*} }, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?()
  -- (if (id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}
  -- if ($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*}) = [])

  ;; ../../../../spec-concrete/5.01-env.watsup:206.1-212.60
  clause 3({ rid : V*{V <- V*, rid <- rid*} }, id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}) = ?((rid', V', id_default*{id_default <- id_default*}))
  -- (if (id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}
  -- let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} = $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*})
  -- if (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches [ _/1 ]
  -- let [(rid', V', id_default*{id_default <- id_default*})] = (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*}

;; ../../../../spec-concrete/5.01-env.watsup:218.1-218.50
def $find_non_overloaded<V>(map<rid, V>, id) : V? =

  ;; ../../../../spec-concrete/5.01-env.watsup:221.1-222.60
  clause 0({ rid : V*{V <- V*, rid <- rid*} }, id) = ?(V')
  -- let V''*{V'' <- V''*} = $find_non_overloaded'<V>({ rid : V*{V <- V*, rid <- rid*} }, id)
  -- if V''*{V'' <- V''*} matches [ _/1 ]
  -- let [V'] = V''*{V'' <- V''*}

  ;; ../../../../spec-concrete/5.01-env.watsup:223.1-224.15
  clause 1({ rid : V*{V <- V*, rid <- rid*} }, id) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.01-env.watsup:219.1-219.51
def $find_non_overloaded'<V>(map<rid, V>, id) : V* =

  ;; ../../../../spec-concrete/5.01-env.watsup:226.1-226.49
  clause 0(set<pair<rid, V>>, id) = []
  -- if (set<pair<rid, V>> = { [] })

  ;; ../../../../spec-concrete/5.01-env.watsup:227.1-233.59
  clause 1({ pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} }, id) = V_h :: V_t_found*{V_t_found <- V_t_found*}
  -- if pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches _ :: _
  -- let rid_h : V_h :: rid_t : V_t*{V_t <- V_t*, rid_t <- rid_t*} = pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}
  -- let id' ( _pid*{_pid <- _pid*} ) = rid_h
  -- if (id' = id)
  -- let V_t_found*{V_t_found <- V_t_found*} = $find_non_overloaded'<V>({ rid_t : V_t*{V_t <- V_t*, rid_t <- rid_t*} }, id)

  ;; ../../../../spec-concrete/5.01-env.watsup:234.1-241.59
  clause 2({ pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} }, id) = V_t_found*{V_t_found <- V_t_found*}
  -- if pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches _ :: _
  -- let rid_h : V_h :: rid_t : V_t*{V_t <- V_t*, rid_t <- rid_t*} = pair<rid, V>*{pair<rid, V> <- pair<rid, V>*}
  -- let id_h ( _pid*{_pid <- _pid*} ) = rid_h
  -- if (id =/= id_h)
  -- let V_t_found*{V_t_found <- V_t_found*} = $find_non_overloaded'<V>({ rid_t : V_t*{V_t <- V_t*, rid_t <- rid_t*} }, id)

;; ../../../../spec-concrete/5.02-context.watsup:5.17-5.39
syntax cursor = 
   | global
   | block
   | local

;; ../../../../spec-concrete/5.02-context.watsup:16.3-19.18
syntax globalTypingLayer = {cdenv cdenv, tdenv tdenv, rdenv rdenv, frame frame}

;; ../../../../spec-concrete/5.02-context.watsup:24.1-28.12
syntax blockKind = 
   | 
   | extern
   | parser
   | control
   | package

;; ../../../../spec-concrete/5.02-context.watsup:30.1-30.43
def $is_extern_blockKind(blockKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:31.1-31.57
  clause 0(blockKind) = (blockKind = extern)

;; ../../../../spec-concrete/5.02-context.watsup:33.1-33.43
def $is_parser_blockKind(blockKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:34.1-34.57
  clause 0(blockKind) = (blockKind = parser)

;; ../../../../spec-concrete/5.02-context.watsup:36.1-36.44
def $is_control_blockKind(blockKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:37.1-37.59
  clause 0(blockKind) = (blockKind = control)

;; ../../../../spec-concrete/5.02-context.watsup:39.1-39.44
def $is_package_blockKind(blockKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:40.1-40.59
  clause 0(blockKind) = (blockKind = package)

;; ../../../../spec-concrete/5.02-context.watsup:43.3-47.18
syntax blockTypingLayer = {id id, kind blockKind, tdenv tdenv, rdenv rdenv, frame frame}

;; ../../../../spec-concrete/5.02-context.watsup:52.1-60.23
syntax localKind = 
   | 
   | function-> typeIR
   | extern_function-> typeIR
   | action
   | extern_method-> typeIR
   | extern_methodabstract-> typeIR
   | parser_state
   | control_apply_method
   | table_apply_method

;; ../../../../spec-concrete/5.02-context.watsup:62.1-62.45
def $is_function_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:63.1-63.50
  clause 0(localKind) = true
  -- if localKind matches `FUNCTION->%`
  -- let function-> _typeIR = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:64.1-65.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:67.1-67.52
def $is_extern_function_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:68.1-70.11
  clause 0(localKind) = true
  -- if localKind matches `EXTERN_FUNCTION->%`
  -- let extern_function-> _typeIR = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:71.1-72.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:74.1-74.43
def $is_action_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:75.1-75.40
  clause 0(localKind) = true
  -- if localKind matches `ACTION`

  ;; ../../../../spec-concrete/5.02-context.watsup:76.1-77.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:79.1-79.50
def $is_extern_method_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:80.1-82.11
  clause 0(localKind) = true
  -- if localKind matches `EXTERN_METHOD->%`
  -- let extern_method-> _typeIR = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:83.1-84.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:86.1-86.59
def $is_extern_abstract_method_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:87.1-89.11
  clause 0(localKind) = true
  -- if localKind matches `EXTERN_METHODABSTRACT->%`
  -- let extern_methodabstract-> _typeIR = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:90.1-91.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:93.1-93.49
def $is_parser_state_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:94.1-94.52
  clause 0(localKind) = true
  -- if localKind matches `PARSER_STATE`

  ;; ../../../../spec-concrete/5.02-context.watsup:95.1-96.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:98.1-98.57
def $is_control_apply_method_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:99.1-101.11
  clause 0(localKind) = true
  -- if localKind matches `CONTROL_APPLY_METHOD`

  ;; ../../../../spec-concrete/5.02-context.watsup:102.1-103.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:105.1-105.55
def $is_table_apply_method_localKind(localKind) : bool =

  ;; ../../../../spec-concrete/5.02-context.watsup:106.1-108.11
  clause 0(localKind) = true
  -- if localKind matches `TABLE_APPLY_METHOD`

  ;; ../../../../spec-concrete/5.02-context.watsup:109.1-110.15
  clause 1(_localKind) = false
  -- otherwise

;; ../../../../spec-concrete/5.02-context.watsup:113.3-116.20
syntax localTypingLayer = {id id, kind localKind, tdenv tdenv, frames frame*}

;; ../../../../spec-concrete/5.02-context.watsup:123.3-125.29
syntax typingContext = {global globalTypingLayer, block blockTypingLayer, local localTypingLayer}

;; ../../../../spec-concrete/5.02-context.watsup:133.1-133.41
def $empty_typingContext : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:135.1-155.35
  clause 0 = TC
  -- let globalTypingLayer = {cdenv $empty_cdenv, tdenv $empty_tdenv, rdenv $empty_rdenv, frame $empty_frame}
  -- let blockTypingLayer = {id "", kind , tdenv $empty_tdenv, rdenv $empty_rdenv, frame $empty_frame}
  -- let localTypingLayer = {id "", kind , tdenv $empty_tdenv, frames [$empty_frame]}
  -- let TC = {global globalTypingLayer, block blockTypingLayer, local localTypingLayer}

;; ../../../../spec-concrete/5.02-context.watsup:161.1-161.42
def $bound(cursor, typingContext) : bound =

  ;; ../../../../spec-concrete/5.02-context.watsup:163.1-163.34
  clause 0(cursor, TC) = { [] }
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.02-context.watsup:164.1-164.65
  clause 1(cursor, TC) = $dom_map<tid, typeDefIR>(TC.block.tdenv)
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.02-context.watsup:165.1-167.63
  clause 2(cursor, TC) = $union_set<tid>(bound_block, bound_local)
  -- if cursor matches `LOCAL`
  -- let bound_block = $bound(block, TC)
  -- let bound_local = $dom_map<tid, typeDefIR>(TC.local.tdenv)

;; ../../../../spec-concrete/5.02-context.watsup:173.1-173.42
def $enter(typingContext) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:175.1-175.72
  clause 0(TC) = TC[local.frames = $empty_frame :: TC.local.frames]

;; ../../../../spec-concrete/5.02-context.watsup:177.1-177.41
def $exit(typingContext) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:179.1-180.46
  clause 0(TC) = TC[local.frames = frame_t*{frame_t <- frame_t*}]
  -- let frame*{frame <- frame*} = TC.local.frames
  -- if frame*{frame <- frame*} matches _ :: _
  -- let frame_h :: frame_t*{frame_t <- frame_t*} = frame*{frame <- frame*}

;; ../../../../spec-concrete/5.02-context.watsup:188.1-188.67
def $add_var(cursor, typingContext, id, varTypeIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:191.1-197.50
  clause 0(cursor, TC, id, varTypeIR) = TC'
  -- if cursor matches `GLOBAL`
  -- let frame = TC.global.frame
  -- if ~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))
  -- let _direction typeIR _ctk _value?{_value <- _value?} = varTypeIR
  -- if ((id = "main") => $is_package_object_typeIR($canon(typeIR)))
  -- let frame_update = $add_map<id, varTypeIR>(frame, id, varTypeIR)
  -- let TC' = TC[global.frame = frame_update]

  ;; ../../../../spec-concrete/5.02-context.watsup:198.1-203.49
  clause 1(cursor, TC, id, varTypeIR) = TC'
  -- if cursor matches `BLOCK`
  -- let frame = TC.block.frame
  -- if ~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))
  -- if (id =/= "main")
  -- let frame_update = $add_map<id, varTypeIR>(TC.block.frame, id, varTypeIR)
  -- let TC' = TC[block.frame = frame_update]

  ;; ../../../../spec-concrete/5.02-context.watsup:204.1-210.44
  clause 2(cursor, TC, id, varTypeIR) = TC'
  -- if cursor matches `LOCAL`
  -- let frame'*{frame' <- frame'*} = TC.local.frames
  -- if frame'*{frame' <- frame'*} matches _ :: _
  -- let frame_h :: frame_t*{frame_t <- frame_t*} = frame'*{frame' <- frame'*}
  -- if ~$in_set<id>(id, $dom_map<id, varTypeIR>(frame_h))
  -- if (id =/= "main")
  -- let frame_h_update = $add_map<id, varTypeIR>(frame_h, id, varTypeIR)
  -- let frame*{frame <- frame*} = frame_h_update :: frame_t*{frame_t <- frame_t*}
  -- let TC' = TC[local.frames = frame*{frame <- frame*}]

;; ../../../../spec-concrete/5.02-context.watsup:189.1-189.70
def $add_vars(cursor, typingContext, id*, varTypeIR*) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:212.1-212.36
  clause 0(p, TC, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*}) = TC
  -- if id*{id <- id*} matches []
  -- if varTypeIR*{varTypeIR <- varTypeIR*} matches []

  ;; ../../../../spec-concrete/5.02-context.watsup:213.1-215.54
  clause 1(p, TC, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*}) = TC''
  -- if id*{id <- id*} matches _ :: _
  -- let id_h :: id_t*{id_t <- id_t*} = id*{id <- id*}
  -- if varTypeIR*{varTypeIR <- varTypeIR*} matches _ :: _
  -- let varTypeIR_h :: varTypeIR_t*{varTypeIR_t <- varTypeIR_t*} = varTypeIR*{varTypeIR <- varTypeIR*}
  -- let TC' = $add_var(p, TC, id_h, varTypeIR_h)
  -- let TC'' = $add_vars(p, TC', id_t*{id_t <- id_t*}, varTypeIR_t*{varTypeIR_t <- varTypeIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:219.1-219.75
def $add_parameter(cursor, typingContext, parameterTypeIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:222.1-224.50
  clause 0(cursor, TC, direction typeIR id value?{value <- value?}) = TC'
  -- if direction matches ``EMPTY`
  -- let varTypeIR = typeIR ctk value?{value <- value?}
  -- let TC' = $add_var(cursor, TC, id, varTypeIR)

  ;; ../../../../spec-concrete/5.02-context.watsup:225.1-228.50
  clause 1(cursor, TC, direction typeIR id value?{value <- value?}) = TC'
  -- if (((direction = in) \/ (direction = out)) \/ (direction = inout))
  -- let varTypeIR = direction typeIR dyn value?{value <- value?}
  -- let TC' = $add_var(cursor, TC, id, varTypeIR)

;; ../../../../spec-concrete/5.02-context.watsup:220.1-220.77
def $add_parameters(cursor, typingContext, parameterTypeIR*) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:230.1-230.42
  clause 0(cursor, TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

  ;; ../../../../spec-concrete/5.02-context.watsup:231.1-233.64
  clause 1(cursor, TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC''
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
  -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
  -- let TC' = $add_parameter(cursor, TC, parameterTypeIR_h)
  -- let TC'' = $add_parameters(cursor, TC', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:237.1-237.78
def $add_constructorParameter(typingContext, parameterTypeIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:240.1-242.49
  clause 0(TC, direction typeIR id value?{value <- value?}) = TC'
  -- if value?{value <- value?} matches ()
  -- let varTypeIR = direction typeIR ctk ?()
  -- let TC' = $add_var(block, TC, id, varTypeIR)

  ;; ../../../../spec-concrete/5.02-context.watsup:243.1-245.49
  clause 1(TC, direction typeIR id value'?{value' <- value'?}) = TC'
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}
  -- let varTypeIR = direction typeIR ctk ?(value)
  -- let TC' = $add_var(block, TC, id, varTypeIR)

;; ../../../../spec-concrete/5.02-context.watsup:238.1-238.80
def $add_constructorParameters(typingContext, parameterTypeIR*) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:247.1-247.45
  clause 0(TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

  ;; ../../../../spec-concrete/5.02-context.watsup:248.1-250.67
  clause 1(TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = TC''
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
  -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
  -- let TC' = $add_constructorParameter(TC, parameterTypeIR_h)
  -- let TC'' = $add_constructorParameters(TC', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:254.1-254.69
def $add_type(cursor, typingContext, tid, typeDefIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:255.1-260.50
  clause 0(cursor, TC, tid, typeDefIR) = TC'
  -- if cursor matches `GLOBAL`
  -- let tdenv = TC.global.tdenv
  -- if ~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))
  -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
  -- let TC' = TC[global.tdenv = tdenv_update]

  ;; ../../../../spec-concrete/5.02-context.watsup:261.1-266.49
  clause 1(cursor, TC, tid, typeDefIR) = TC'
  -- if cursor matches `BLOCK`
  -- let tdenv = TC.block.tdenv
  -- if ~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))
  -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
  -- let TC' = TC[block.tdenv = tdenv_update]

  ;; ../../../../spec-concrete/5.02-context.watsup:267.1-272.49
  clause 2(cursor, TC, tid, typeDefIR) = TC'
  -- if cursor matches `LOCAL`
  -- let tdenv = TC.local.tdenv
  -- if ~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))
  -- let tdenv_update = $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR)
  -- let TC' = TC[local.tdenv = tdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:274.1-274.72
def $add_types(cursor, typingContext, tid*, typeDefIR*) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:275.1-275.37
  clause 0(p, TC, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*}) = TC
  -- if tid*{tid <- tid*} matches []
  -- if typeDefIR*{typeDefIR <- typeDefIR*} matches []

  ;; ../../../../spec-concrete/5.02-context.watsup:276.1-278.56
  clause 1(p, TC, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*}) = TC''
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- if typeDefIR*{typeDefIR <- typeDefIR*} matches _ :: _
  -- let typeDefIR_h :: typeDefIR_t*{typeDefIR_t <- typeDefIR_t*} = typeDefIR*{typeDefIR <- typeDefIR*}
  -- let TC' = $add_type(p, TC, tid_h, typeDefIR_h)
  -- let TC'' = $add_types(p, TC', tid_t*{tid_t <- tid_t*}, typeDefIR_t*{typeDefIR_t <- typeDefIR_t*})

;; ../../../../spec-concrete/5.02-context.watsup:282.1-282.88
def $add_routine_overload(cursor, typingContext, rid, routineTypeDefIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:284.1-289.50
  clause 0(cursor, TC, rid, routineTypeDefIR) = TC'
  -- if cursor matches `GLOBAL`
  -- let rdenv = TC.global.rdenv
  -- if ~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))
  -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
  -- let TC' = TC[global.rdenv = rdenv_update]

  ;; ../../../../spec-concrete/5.02-context.watsup:290.1-295.49
  clause 1(cursor, TC, rid, routineTypeDefIR) = TC'
  -- if cursor matches `BLOCK`
  -- let rdenv = TC.block.rdenv
  -- if ~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))
  -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
  -- let TC' = TC[block.rdenv = rdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:297.1-297.92
def $add_routine_non_overload(cursor, typingContext, rid, routineTypeDefIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:299.1-306.50
  clause 0(cursor, TC, rid, routineTypeDefIR) = TC'
  -- if cursor matches `GLOBAL`
  -- let rdenv = TC.global.rdenv
  -- let id ( _pid*{_pid <- _pid*} ) = rid
  -- let { id_k ( _pid'*{_pid' <- _pid'*} )*{_pid'* <- _pid'**, id_k <- id_k*} } = $dom_map<rid, routineTypeDefIR>(rdenv)
  -- if ~$in_set<id>(id, { id_k*{id_k <- id_k*} })
  -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
  -- let TC' = TC[global.rdenv = rdenv_update]

  ;; ../../../../spec-concrete/5.02-context.watsup:307.1-314.49
  clause 1(cursor, TC, rid, routineTypeDefIR) = TC'
  -- if cursor matches `BLOCK`
  -- let rdenv = TC.block.rdenv
  -- let id ( _pid*{_pid <- _pid*} ) = rid
  -- let { id_k ( _pid'*{_pid' <- _pid'*} )*{_pid'* <- _pid'**, id_k <- id_k*} } = $dom_map<rid, routineTypeDefIR>(rdenv)
  -- if ~$in_set<id>(id, { id_k*{id_k <- id_k*} })
  -- let rdenv_update = $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
  -- let TC' = TC[block.rdenv = rdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:318.1-318.79
def $add_constructor(typingContext, cid, constructorTypeDefIR) : typingContext =

  ;; ../../../../spec-concrete/5.02-context.watsup:320.1-325.50
  clause 0(TC, cid, constructorTypeDefIR) = TC'
  -- let cdenv = TC.global.cdenv
  -- if ~$in_set<cid>(cid, $dom_map<cid, constructorTypeDefIR>(cdenv))
  -- let cdenv_update = $add_map<cid, constructorTypeDefIR>(cdenv, cid, constructorTypeDefIR)
  -- let TC' = TC[global.cdenv = cdenv_update]

;; ../../../../spec-concrete/5.02-context.watsup:333.1-333.66
def $find_var(cursor, typingContext, prefixedNameIR) : varTypeIR? =

  ;; ../../../../spec-concrete/5.02-context.watsup:335.1-336.32
  clause 0(p, TC, prefixedNameIR) = $find_map<id, varTypeIR>(frame, id)
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR
  -- let frame = TC.global.frame

  ;; ../../../../spec-concrete/5.02-context.watsup:337.1-338.32
  clause 1(cursor, TC, prefixedNameIR) = $find_map<id, varTypeIR>(frame, id)
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame = TC.global.frame

  ;; ../../../../spec-concrete/5.02-context.watsup:339.1-341.56
  clause 2(cursor, TC, prefixedNameIR) = ?(varTypeIR)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame = TC.block.frame
  -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_map<id, varTypeIR>(frame, id)
  -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
  -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:342.1-344.50
  clause 3(cursor, TC, prefixedNameIR) = $find_var(global, TC, ` id)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame = TC.block.frame
  -- if (?() = $find_map<id, varTypeIR>(frame, id))

  ;; ../../../../spec-concrete/5.02-context.watsup:345.1-347.58
  clause 4(cursor, TC, prefixedNameIR) = ?(varTypeIR)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame*{frame <- frame*} = TC.local.frames
  -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id)
  -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
  -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:348.1-350.52
  clause 5(cursor, TC, prefixedNameIR) = $find_var(block, TC, ` id)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame*{frame <- frame*} = TC.local.frames
  -- if (?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

;; ../../../../spec-concrete/5.02-context.watsup:354.1-354.63
def $find_value(cursor, typingContext, prefixedNameIR) : value =

  ;; ../../../../spec-concrete/5.02-context.watsup:356.1-358.58
  clause 0(p, TC, prefixedNameIR) = value
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR
  -- let frame = TC.global.frame
  -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
  -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
  -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:359.1-361.58
  clause 1(cursor, TC, prefixedNameIR) = value
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame = TC.global.frame
  -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
  -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
  -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:362.1-364.58
  clause 2(cursor, TC, prefixedNameIR) = value
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame = TC.block.frame
  -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_map<id, varTypeIR>(frame, id)
  -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
  -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:365.1-367.50
  clause 3(cursor, TC, prefixedNameIR) = $find_value(global, TC, ` id)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame = TC.block.frame
  -- if (?() = $find_map<id, varTypeIR>(frame, id))

  ;; ../../../../spec-concrete/5.02-context.watsup:368.1-370.60
  clause 4(cursor, TC, prefixedNameIR) = value
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame*{frame <- frame*} = TC.local.frames
  -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id)
  -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
  -- let ?(_direction _typeIR _ctk value'?{value' <- value'?}) = varTypeIR?{varTypeIR <- varTypeIR?}
  -- if value'?{value' <- value'?} matches (_)
  -- let ?(value) = value'?{value' <- value'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:371.1-373.52
  clause 5(cursor, TC, prefixedNameIR) = $find_value(block, TC, ` id)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let frame*{frame <- frame*} = TC.local.frames
  -- if (?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

;; ../../../../spec-concrete/5.02-context.watsup:377.1-377.67
def $find_type(cursor, typingContext, prefixedNameIR) : typeDefIR? =

  ;; ../../../../spec-concrete/5.02-context.watsup:379.1-381.32
  clause 0(p, TC, prefixedNameIR) = $find_map<tid, typeDefIR>(tdenv, tid)
  -- if prefixedNameIR matches `.%`
  -- let . tid = prefixedNameIR
  -- let tdenv = TC.global.tdenv

  ;; ../../../../spec-concrete/5.02-context.watsup:382.1-384.32
  clause 1(cursor, TC, prefixedNameIR) = $find_map<tid, typeDefIR>(tdenv, tid)
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches ``%`
  -- let ` tid = prefixedNameIR
  -- let tdenv = TC.global.tdenv

  ;; ../../../../spec-concrete/5.02-context.watsup:385.1-387.58
  clause 2(cursor, TC, prefixedNameIR) = ?(typeDefIR)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` tid = prefixedNameIR
  -- let tdenv = TC.block.tdenv
  -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_map<tid, typeDefIR>(tdenv, tid)
  -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
  -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:388.1-390.52
  clause 3(cursor, TC, prefixedNameIR) = $find_type(global, TC, ` tid)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` tid = prefixedNameIR
  -- let tdenv = TC.block.tdenv
  -- if (?() = $find_map<tid, typeDefIR>(tdenv, tid))

  ;; ../../../../spec-concrete/5.02-context.watsup:391.1-393.60
  clause 4(cursor, TC, prefixedNameIR) = ?(typeDefIR)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` tid = prefixedNameIR
  -- let tdenv*{tdenv <- tdenv*} = [TC.local.tdenv]
  -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid)
  -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
  -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:394.1-396.54
  clause 5(cursor, TC, prefixedNameIR) = $find_type(block, TC, ` tid)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` tid = prefixedNameIR
  -- let tdenv*{tdenv <- tdenv*} = [TC.local.tdenv]
  -- if (?() = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid))

;; ../../../../spec-concrete/5.02-context.watsup:400.1-400.41
def $ids_arguments(argumentIR*) : id?* =

  ;; ../../../../spec-concrete/5.02-context.watsup:403.1-403.62
  clause 0(argumentIR*{argumentIR <- argumentIR*}) = $id_argument(argumentIR)*{argumentIR <- argumentIR*}

;; ../../../../spec-concrete/5.02-context.watsup:401.1-401.35
def $id_argument(argumentIR) : id? =

  ;; ../../../../spec-concrete/5.02-context.watsup:404.1-404.42
  clause 0(argumentIR) = ?()
  -- if argumentIR <: typedExpressionIR
  -- let typedExpressionIR = argumentIR as typedExpressionIR

  ;; ../../../../spec-concrete/5.02-context.watsup:405.1-405.39
  clause 1(argumentIR) = ?(nameIR)
  -- if argumentIR matches `%=%`
  -- let nameIR = _typedExpressionIR = argumentIR

  ;; ../../../../spec-concrete/5.02-context.watsup:406.1-406.40
  clause 2(argumentIR) = ?(nameIR)
  -- if argumentIR matches `%=_`
  -- let nameIR =_ = argumentIR

  ;; ../../../../spec-concrete/5.02-context.watsup:407.1-407.27
  clause 3(argumentIR) = ?()
  -- if argumentIR matches `_`

;; ../../../../spec-concrete/5.02-context.watsup:409.1-410.34
def $find_routine_overloaded(cursor, typingContext, prefixedNameIR, argumentIR*) : (rid, routineTypeDefIR, id*)? =

  ;; ../../../../spec-concrete/5.02-context.watsup:412.1-415.49
  clause 0(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR
  -- let rdenv = TC.global.rdenv
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

  ;; ../../../../spec-concrete/5.02-context.watsup:416.1-419.49
  clause 1(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let rdenv = TC.global.rdenv
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

  ;; ../../../../spec-concrete/5.02-context.watsup:420.1-425.66
  clause 2(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*}))
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let rdenv = TC.block.rdenv
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
  -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
  -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}

  ;; ../../../../spec-concrete/5.02-context.watsup:426.1-431.66
  clause 3(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_routine_overloaded(global, TC, ` id, argumentIR*{argumentIR <- argumentIR*})
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let rdenv = TC.block.rdenv
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
  -- if (?() = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}))

  ;; ../../../../spec-concrete/5.02-context.watsup:432.1-433.60
  clause 4(cursor, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_routine_overloaded(block, TC, ` id, argumentIR*{argumentIR <- argumentIR*})
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR

;; ../../../../spec-concrete/5.02-context.watsup:435.1-436.22
def $find_routine_non_overloaded(cursor, typingContext, prefixedNameIR) : routineTypeDefIR? =

  ;; ../../../../spec-concrete/5.02-context.watsup:438.1-439.64
  clause 0(p, TC, prefixedNameIR) = $find_non_overloaded<routineTypeDefIR>(TC.global.rdenv, id)
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR

  ;; ../../../../spec-concrete/5.02-context.watsup:440.1-441.64
  clause 1(cursor, TC, prefixedNameIR) = $find_non_overloaded<routineTypeDefIR>(TC.global.rdenv, id)
  -- if cursor matches `GLOBAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR

  ;; ../../../../spec-concrete/5.02-context.watsup:442.1-444.67
  clause 2(cursor, TC, prefixedNameIR) = ?(routineTypeDefIR)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_non_overloaded<routineTypeDefIR>(TC.block.rdenv, id)
  -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
  -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}

  ;; ../../../../spec-concrete/5.02-context.watsup:445.1-448.67
  clause 3(cursor, TC, prefixedNameIR) = $find_routine_non_overloaded(global, TC, ` id)
  -- if cursor matches `BLOCK`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- if (?() = $find_non_overloaded<routineTypeDefIR>(TC.block.rdenv, id))

  ;; ../../../../spec-concrete/5.02-context.watsup:449.1-450.51
  clause 4(cursor, TC, prefixedNameIR) = $find_routine_non_overloaded(block, TC, ` id)
  -- if cursor matches `LOCAL`
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR

;; ../../../../spec-concrete/5.02-context.watsup:454.1-455.38
def $find_constructor_overloaded(typingContext, prefixedNameIR, argumentIR*) : (rid, constructorTypeDefIR, id*)? =

  ;; ../../../../spec-concrete/5.02-context.watsup:457.1-460.49
  clause 0(TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR
  -- let cdenv = TC.global.cdenv
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

  ;; ../../../../spec-concrete/5.02-context.watsup:461.1-464.49
  clause 1(TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let cdenv = TC.global.cdenv
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

;; ../../../../spec-concrete/5.02-context.watsup:468.1-468.47
def $find_return_type(typingContext) : typeIR? =

  ;; ../../../../spec-concrete/5.02-context.watsup:470.1-471.48
  clause 0(TC) = ?(typeIR_ret)
  -- let localKind = TC.local.kind
  -- if localKind matches `FUNCTION->%`
  -- let function-> typeIR_ret = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:472.1-473.55
  clause 1(TC) = ?(typeIR_ret)
  -- let localKind = TC.local.kind
  -- if localKind matches `EXTERN_FUNCTION->%`
  -- let extern_function-> typeIR_ret = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:474.1-475.31
  clause 2(TC) = ?(void as typeIR)
  -- if (action = TC.local.kind)

  ;; ../../../../spec-concrete/5.02-context.watsup:476.1-477.53
  clause 3(TC) = ?(typeIR_ret)
  -- let localKind = TC.local.kind
  -- if localKind matches `EXTERN_METHOD->%`
  -- let extern_method-> typeIR_ret = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:478.1-480.22
  clause 4(TC) = ?(typeIR_ret)
  -- let localKind = TC.local.kind
  -- if localKind matches `EXTERN_METHODABSTRACT->%`
  -- let extern_methodabstract-> typeIR_ret = localKind

  ;; ../../../../spec-concrete/5.02-context.watsup:481.1-482.45
  clause 5(TC) = ?(void as typeIR)
  -- if (control_apply_method = TC.local.kind)

  ;; ../../../../spec-concrete/5.02-context.watsup:483.1-484.15
  clause 6(TC) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.03-table-context.watsup:5.19-5.31
syntax matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.03-table-context.watsup:7.22-7.72
syntax matchAction = (prefixedNameIR, parameterTypeIR*, argumentListIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:10.3-13.24
syntax matchPriority = {values nat*, init bool, delta nat, largest_wins bool}

;; ../../../../spec-concrete/5.03-table-context.watsup:16.3-17.17
syntax matchEntry = {size nat, const bool}

;; ../../../../spec-concrete/5.03-table-context.watsup:21.1-27.11
syntax matchMode = 
   | nopri
   | noprilpm nat
   | pri
   | prilpm

;; ../../../../spec-concrete/5.03-table-context.watsup:30.3-34.21
syntax tableContext = {keys matchKey*, actions matchAction*, priorities matchPriority, entries matchEntry, mode matchMode}

;; ../../../../spec-concrete/5.03-table-context.watsup:44.1-46.10
syntax tableEntryState = 
   | lpm nat
   | nolpm

;; ../../../../spec-concrete/5.03-table-context.watsup:54.1-54.38
def $empty_tableContext : tableContext =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:55.1-68.25
  clause 0 = {keys [], actions [], priorities matchPriority, entries matchEntry, mode nopri}
  -- let matchPriority = {values [], init false, delta 1, largest_wins true}
  -- let matchEntry = {size 0, const true}

;; ../../../../spec-concrete/5.03-table-context.watsup:76.1-76.54
def $add_key(tableContext, id, typeIR) : tableContext =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:78.1-80.32
  clause 0(TBLC, id, typeIR) = TBLC[keys = TBLC.keys ++ [matchKey]]
  -- let matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.03-table-context.watsup:84.1-84.95
def $add_action(tableContext, prefixedNameIR, parameterTypeIR*, argumentListIR) : tableContext =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:86.1-88.73
  clause 0(TBLC, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR) = TBLC[actions = TBLC.actions ++ [matchAction]]
  -- let matchAction = (prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:92.1-92.58
def $add_table_priority(tableContext, nat) : tableContext =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:94.1-95.65
  clause 0(TBLC, n) = TBLC[priorities.values = TBLC.priorities.values ++ [n]]

;; ../../../../spec-concrete/5.03-table-context.watsup:103.1-103.58
def $update_mode(tableContext, id, typeIR) : tableContext =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:106.1-106.77
  clause 0(TBLC, id, typeIR) = $update_mode'(TBLC, id, $canon(typeIR))

;; ../../../../spec-concrete/5.03-table-context.watsup:104.1-104.59
def $update_mode'(tableContext, id, typeIR) : tableContext =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:107.1-108.26
  clause 0(TBLC, text, typeIR) = TBLC[mode = noprilpm n]
  -- if (text = "lpm")
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< n > = numberTypeIR
  -- if (TBLC.mode = nopri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:109.1-110.26
  clause 1(TBLC, text, typeIR) = TBLC[mode = noprilpm n]
  -- if (text = "lpm")
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< n > = numberTypeIR
  -- if (TBLC.mode = nopri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:111.1-112.26
  clause 2(TBLC, text, typeIR) = TBLC[mode = noprilpm n]
  -- if (text = "lpm")
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< n > = numberTypeIR
  -- if (TBLC.mode = nopri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:113.1-114.38
  clause 3(TBLC, text, typeIR') = $update_mode(TBLC, "lpm", typeIR)
  -- if (text = "lpm")
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-table-context.watsup:115.1-116.24
  clause 4(TBLC, text, _typeIR) = TBLC[mode = prilpm]
  -- if (text = "lpm")
  -- if (TBLC.mode = pri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:117.1-118.26
  clause 5(TBLC, text, _typeIR) = TBLC[mode = pri]
  -- if (text = "range")
  -- if (TBLC.mode = nopri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:119.1-120.26
  clause 6(TBLC, text, _typeIR) = TBLC[mode = pri]
  -- if (text = "ternary")
  -- if (TBLC.mode = nopri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:121.1-122.26
  clause 7(TBLC, text, _typeIR) = TBLC[mode = pri]
  -- if (text = "optional")
  -- if (TBLC.mode = nopri)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:123.1-124.31
  clause 8(TBLC, text, _typeIR) = TBLC[mode = prilpm]
  -- if (text = "range")
  -- let matchMode = TBLC.mode
  -- if matchMode matches `NOPRILPM%`
  -- let noprilpm _nat = matchMode

  ;; ../../../../spec-concrete/5.03-table-context.watsup:125.1-126.31
  clause 9(TBLC, text, _typeIR) = TBLC[mode = prilpm]
  -- if (text = "ternary")
  -- let matchMode = TBLC.mode
  -- if matchMode matches `NOPRILPM%`
  -- let noprilpm _nat = matchMode

  ;; ../../../../spec-concrete/5.03-table-context.watsup:127.1-128.31
  clause 10(TBLC, text, _typeIR) = TBLC[mode = prilpm]
  -- if (text = "optional")
  -- let matchMode = TBLC.mode
  -- if matchMode matches `NOPRILPM%`
  -- let noprilpm _nat = matchMode

  ;; ../../../../spec-concrete/5.03-table-context.watsup:129.1-130.15
  clause 11(TBLC, _id, _typeIR) = TBLC
  -- otherwise

;; ../../../../spec-concrete/5.03-table-context.watsup:138.1-138.85
def $find_action(tableContext, prefixedNameIR) : (parameterTypeIR*, argumentListIR)? =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:141.1-141.85
  clause 0(TBLC, prefixedNameIR) = $find_action'(TBLC.actions, prefixedNameIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:139.1-139.86
def $find_action'(matchAction*, prefixedNameIR) : (parameterTypeIR*, argumentListIR)? =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:143.1-143.45
  clause 0(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = ?()
  -- if matchAction*{matchAction <- matchAction*} matches []

  ;; ../../../../spec-concrete/5.03-table-context.watsup:145.1-147.75
  clause 1(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = ?((parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR))
  -- if matchAction*{matchAction <- matchAction*} matches _ :: _
  -- let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} = matchAction*{matchAction <- matchAction*}
  -- let (prefixedNameIR', parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentListIR) = matchAction_h
  -- if (prefixedNameIR' = prefixedNameIR)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:149.1-152.44
  clause 2(matchAction*{matchAction <- matchAction*}, prefixedNameIR) = $find_action'(matchAction_t*{matchAction_t <- matchAction_t*}, prefixedNameIR)
  -- if matchAction*{matchAction <- matchAction*} matches _ :: _
  -- let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} = matchAction*{matchAction <- matchAction*}
  -- let (prefixedNameIR_h, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentListIR) = matchAction_h
  -- if (prefixedNameIR_h =/= prefixedNameIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:156.1-156.50
def $find_table_priority_last(tableContext) : nat =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:158.1-159.36
  clause 0(TBLC) = n*{n <- n*}[(|n*{n <- n*}| - 1)]
  -- let n*{n <- n*} = TBLC.priorities.values

;; ../../../../spec-concrete/5.03-table-context.watsup:165.1-165.78
def $join_tableEntryState(tableEntryState, tableEntryState) : tableEntryState =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:167.1-167.48
  clause 0(tableEntryState, tableEntryState') = lpm n
  -- if tableEntryState matches `NOLPM`
  -- if tableEntryState' matches `LPM%`
  -- let lpm n = tableEntryState'

  ;; ../../../../spec-concrete/5.03-table-context.watsup:168.1-168.48
  clause 1(tableEntryState, tableEntryState') = lpm n
  -- if tableEntryState matches `LPM%`
  -- let lpm n = tableEntryState
  -- if tableEntryState' matches `NOLPM`

  ;; ../../../../spec-concrete/5.03-table-context.watsup:169.1-169.48
  clause 2(tableEntryState, tableEntryState') = nolpm
  -- if tableEntryState matches `NOLPM`
  -- if tableEntryState' matches `NOLPM`

;; ../../../../spec-concrete/5.03-table-context.watsup:171.1-171.40
def $tableEntry_lpm_prefix(value) : nat =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:174.1-174.70
  clause 0(value) = $tableEntry_lpm_prefix'(value, 0)

;; ../../../../spec-concrete/5.03-table-context.watsup:172.1-172.46
def $tableEntry_lpm_prefix'(value, nat) : nat =

  ;; ../../../../spec-concrete/5.03-table-context.watsup:175.1-175.56
  clause 0(value, n_prefix) = n_prefix
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let nat w _int = numberLiteral
  -- if (nat = 0)

  ;; ../../../../spec-concrete/5.03-table-context.watsup:176.1-180.43
  clause 1(value, n_prefix) = $tableEntry_lpm_prefix'(value', (n_prefix + 1))
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w int = numberLiteral
  -- if int <: nat
  -- let n = int as nat
  -- if (w > 0)
  -- if ((n \ 2) =/= 0)
  -- let value' = (w - 1) w ((n - 1) / 2) as int as value

  ;; ../../../../spec-concrete/5.03-table-context.watsup:181.1-185.37
  clause 2(value, nat) = $tableEntry_lpm_prefix'(value', 0)
  -- if value <: numberLiteral
  -- let numberLiteral = value as numberLiteral
  -- if numberLiteral matches `%W%`
  -- let w w int = numberLiteral
  -- if int <: nat
  -- let n = int as nat
  -- if (nat = 0)
  -- if (w > 0)
  -- if ((n \ 2) = 0)
  -- let value' = (w - 1) w (n / 2) as int as value

;; ../../../../spec-concrete/5.03-wellformed.watsup:5.1-7.20
relation Type_wf: bound |- typeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:82.1-83.22
  rulegroup basetype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:82.1-83.22
    rule basetype: bound |- typeIR
    -- if typeIR <: baseTypeIR
    -- let baseTypeIR = typeIR as baseTypeIR
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:87.1-89.33
  rulegroup tid {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:87.1-89.33
    rule tid: bound |- typeIR
    -- if typeIR <: namedTypeIR
    -- let namedTypeIR = typeIR as namedTypeIR
    -- if namedTypeIR matches `TID%`
    -- let tid tid = namedTypeIR
    -- if $in_set<tid>(tid, bound)
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:91.1-94.30
  rulegroup spectype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:91.1-94.30
    rule spectype: bound |- typeIR'
    -- if typeIR' <: namedTypeIR
    -- let namedTypeIR = typeIR' as namedTypeIR
    -- if namedTypeIR matches `%<%>`
    -- let polyTypeDefIR < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR
    -- let typeIR = $specialize_typeDef(polyTypeDefIR as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
    -- if Type_wf: bound |- typeIR holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:112.1-115.30
  rulegroup typedeftype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:112.1-115.30
    rule typedeftype: bound |- typeIR'
    -- if typeIR' <: aliasTypeIR
    -- let aliasTypeIR = typeIR' as aliasTypeIR
    -- if aliasTypeIR matches `TYPEDEF%%`
    -- let typedef _tid typeIR = aliasTypeIR
    -- if $nestable_typedef(typeIR)
    -- if Type_wf: bound |- typeIR holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:129.1-132.30
  rulegroup newtype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:129.1-132.30
    rule newtype: bound |- typeIR'
    -- if typeIR' <: aliasTypeIR
    -- let aliasTypeIR = typeIR' as aliasTypeIR
    -- if aliasTypeIR matches `TYPE%%`
    -- let type _tid typeIR = aliasTypeIR
    -- if $nestable_new(typeIR)
    -- if Type_wf: bound |- typeIR holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:151.1-154.30
  rulegroup listttype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:151.1-154.30
    rule listttype: bound |- typeIR'
    -- if typeIR' <: listTypeIR
    -- let list< typeIR > = typeIR' as listTypeIR
    -- if $nestable_list(typeIR)
    -- if Type_wf: bound |- typeIR holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:177.1-180.33
  rulegroup tupletype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:177.1-180.33
    rule tupletype: bound |- typeIR'
    -- if typeIR' <: tupleTypeIR
    -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
    -- (if $nestable_tuple(typeIR))*{typeIR <- typeIR*}
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:192.1-195.30
  rulegroup stacktype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:192.1-195.30
    rule stacktype: bound |- typeIR'
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR
    -- if $nestable_stack(typeIR)
    -- if Type_wf: bound |- typeIR holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:218.1-222.33
  rulegroup structtype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:218.1-222.33
    rule structtype: bound |- typeIR'
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR id ;*{id <- id*, typeIR <- typeIR*} } = typeIR' as structTypeIR
    -- if $distinct_<id>(id*{id <- id*})
    -- (if $nestable_struct(typeIR))*{typeIR <- typeIR*}
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:255.1-259.33
  rulegroup headertype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:255.1-259.33
    rule headertype: bound |- typeIR'
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR id ;*{id <- id*, typeIR <- typeIR*} } = typeIR' as headerTypeIR
    -- if $distinct_<id>(id*{id <- id*})
    -- (if $nestable_header(typeIR))*{typeIR <- typeIR*}
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:272.1-276.33
  rulegroup headeruniontype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:272.1-276.33
    rule headeruniontype: bound |- typeIR'
    -- if typeIR' <: headerUnionTypeIR
    -- let header_union _tid { typeIR id ;*{id <- id*, typeIR <- typeIR*} } = typeIR' as headerUnionTypeIR
    -- if $distinct_<id>(id*{id <- id*})
    -- (if $nestable_headerunion(typeIR))*{typeIR <- typeIR*}
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:278.1-280.28
  rulegroup enumtype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:278.1-280.28
    rule enumtype: bound |- typeIR
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%{%}`
    -- let enum _tid { id*{id <- id*} } = enumTypeIR
    -- if $distinct_<id>(id*{id <- id*})
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:306.1-310.30
  rulegroup serenumtype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:306.1-310.30
    rule serenumtype: bound |- typeIR'
    -- if typeIR' <: enumTypeIR
    -- let enumTypeIR = typeIR' as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum _tid # typeIR { id = _value ;*{_value <- _value*, id <- id*} } = enumTypeIR
    -- if $distinct_<id>(id*{id <- id*})
    -- if $nestable_serenum(typeIR)
    -- if Type_wf: bound |- typeIR holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:314.1-316.53
  rulegroup externtype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:314.1-316.53
    rule externtype: bound |- typeIR
    -- if typeIR <: externObjectTypeIR
    -- let extern _tid { _rid : routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} } = typeIR as externObjectTypeIR
    -- (if RoutineTypeDef_wf: bound |- routineTypeDefIR holds)*{routineTypeDefIR <- routineTypeDefIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:318.1-320.50
  rulegroup parsertype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:318.1-320.50
    rule parsertype: bound |- typeIR
    -- if typeIR <: parserObjectTypeIR
    -- let parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as parserObjectTypeIR
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:322.1-324.50
  rulegroup controltype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:322.1-324.50
    rule controltype: bound |- typeIR
    -- if typeIR <: controlObjectTypeIR
    -- let control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as controlObjectTypeIR
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:326.1-328.33
  rulegroup packagetype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:326.1-328.33
    rule packagetype: bound |- typeIR'
    -- if typeIR' <: packageObjectTypeIR
    -- let package< typeIR*{typeIR <- typeIR*} > = typeIR' as packageObjectTypeIR
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:330.1-333.30
  rulegroup tabletype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:330.1-333.30
    rule tabletype: bound |- typeIR'
    -- if typeIR' <: tableObjectTypeIR
    -- let table _tid # typeIR = typeIR' as tableObjectTypeIR
    -- let typeIR'' = $canon(typeIR)
    -- if typeIR'' <: tableTypeIR
    -- let tableTypeIR = typeIR'' as tableTypeIR
    -- if tableTypeIR matches `TABLE_STRUCT%{%}`
    -- let table_struct _tid' { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR
    -- if Type_wf: bound |- typeIR holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:337.1-338.19
  rulegroup defaulttype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:337.1-338.19
    rule defaulttype: bound |- typeIR
    -- if (typeIR = default as typeIR)
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:340.1-342.33
  rulegroup sequencetype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:340.1-342.33
    rule sequencetype: bound |- typeIR'
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:344.1-346.33
  rulegroup sequencedefaulttype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:344.1-346.33
    rule sequencedefaulttype: bound |- typeIR'
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR*{typeIR <- typeIR*} ,...> = sequenceTypeIR
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:348.1-351.33
  rulegroup recordtype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:348.1-351.33
    rule recordtype: bound |- typeIR'
    -- if typeIR' <: recordTypeIR
    -- let recordTypeIR = typeIR' as recordTypeIR
    -- if recordTypeIR matches `RECORD{%}`
    -- let record{ typeIR id ;*{id <- id*, typeIR <- typeIR*} } = recordTypeIR
    -- if $distinct_<id>(id*{id <- id*})
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:353.1-356.33
  rulegroup recorddefaulttype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:353.1-356.33
    rule recorddefaulttype: bound |- typeIR'
    -- if typeIR' <: recordTypeIR
    -- let recordTypeIR = typeIR' as recordTypeIR
    -- if recordTypeIR matches `RECORD{%,...}`
    -- let record{ typeIR id ;*{id <- id*, typeIR <- typeIR*} ,...} = recordTypeIR
    -- if $distinct_<id>(id*{id <- id*})
    -- (if Type_wf: bound |- typeIR holds)*{typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:358.1-359.26
  rulegroup invalidtype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:358.1-359.26
    rule invalidtype: bound |- typeIR
    -- if (typeIR = header_invalid as typeIR)
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:414.1-417.30
  rulegroup settype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:414.1-417.30
    rule settype: bound |- typeIR''
    -- if typeIR'' <: setTypeIR
    -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
    -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
    -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
    -- if $nestable_set(typeIR)
    -- if Type_wf: bound |- typeIR holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:419.1-421.28
  rulegroup tableenumtype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:419.1-421.28
    rule tableenumtype: bound |- typeIR
    -- if typeIR <: tableTypeIR
    -- let tableTypeIR = typeIR as tableTypeIR
    -- if tableTypeIR matches `TABLE_ENUM%{%}`
    -- let table_enum _tid { id*{id <- id*} } = tableTypeIR
    -- if $distinct_<id>(id*{id <- id*})
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:423.1-424.33
  rulegroup tablestructtype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:423.1-424.33
    rule tablestructtype: bound |- typeIR
    -- if typeIR <: tableTypeIR
    -- let tableTypeIR = typeIR as tableTypeIR
    -- if tableTypeIR matches `TABLE_STRUCT%{%}`
    -- let table_struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:9.1-11.20
relation TypeDef_wf: bound |- typeDefIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:440.1-443.30
  rulegroup mono {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:440.1-443.30
    rule mono: bound |- typeDefIR
    -- if typeDefIR <: typeIR
    -- let typeIR = typeDefIR as typeIR
    -- if $definable_type_mono(typeIR)
    -- if Type_wf: bound |- typeIR holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:459.1-465.36
  rulegroup poly {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:459.1-465.36
    rule poly: bound |- typeDefIR
    -- if typeDefIR <: polyTypeDefIR
    -- let typeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > = typeDefIR as polyTypeDefIR
    -- if $definable_type_poly(typeIR)
    -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
    -- let bound_inner = $union_set<tid>(bound, { tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} })
    -- if Type_wf: bound_inner |- typeIR holds
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:13.1-15.20
relation ParameterType_wf: bound |- parameterTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:49.1-52.49
  rulegroup default-empty-extern {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:49.1-52.49
    rule default-empty-extern: bound |- direction typeIR _id value?{value <- value?}
    -- if direction matches ``EMPTY`
    -- if value?{value <- value?} matches ()
    -- if Type_wf: bound |- typeIR holds
    -- if $is_extern_object_typeIR($canon(typeIR))
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:54.1-57.50
  rulegroup default-none-not-extern {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:54.1-57.50
    rule default-none-not-extern: bound |- direction typeIR _id value?{value <- value?}
    -- if value?{value <- value?} matches ()
    -- if Type_wf: bound |- typeIR holds
    -- if ~$is_extern_object_typeIR($canon(typeIR))
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:59.1-62.49
  rulegroup default-some-extern {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:59.1-62.49
    rule default-some-extern: bound |- direction typeIR _id value'?{value' <- value'?}
    -- if direction matches ``EMPTY`
    -- if value'?{value' <- value'?} matches (_)
    -- let ?(value) = value'?{value' <- value'?}
    -- if Type_wf: bound |- typeIR holds
    -- if $is_extern_object_typeIR($canon(typeIR))
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:64.1-68.45
  rulegroup default-some-not-extern {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:64.1-68.45
    rule default-some-not-extern: bound |- direction typeIR _id value'?{value' <- value'?}
    -- if value'?{value' <- value'?} matches (_)
    -- let ?(value) = value'?{value' <- value'?}
    -- if Type_wf: bound |- typeIR holds
    -- if ~$is_extern_object_typeIR($canon(typeIR))
    -- if ((direction = in) \/ (direction = ))
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:17.1-19.20
relation ParameterTypes_wf: bound |- parameterTypeIR*

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:70.1-74.51
  rulegroup  {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:70.1-74.51
    rule : bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
    -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
    -- if $distinct_<id>(id*{id <- id*})
    -- (if ParameterType_wf: bound |- parameterTypeIR holds)*{parameterTypeIR <- parameterTypeIR*}
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:21.1-23.20
relation RoutineType_wf: bound |- routineTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:473.1-476.34
  rulegroup builtinfunction {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:473.1-476.34
    rule builtinfunction: bound |- routineTypeIR
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
    -- let builtin_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- if Type_wf: bound |- typeIR_ret holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:491.1-496.34
  rulegroup functiontype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:491.1-496.34
    rule functiontype: bound |- routineTypeIR
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `FUNCTION(%)->%`
    -- let function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_function(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
    -- if Type_wf: bound |- typeIR_ret holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:524.1-529.45
  rulegroup actiontype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:524.1-529.45
    rule actiontype: bound |- routineTypeIR
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `ACTION(%)`
    -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- if $directionless_trailing(direction*{direction <- direction*})
    -- (if $nestable_action(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:547.1-552.34
  rulegroup externfunctiontype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:547.1-552.34
    rule externfunctiontype: bound |- routineTypeIR
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
    -- let extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_externfunction(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
    -- if Type_wf: bound |- typeIR_ret holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:556.1-559.34
  rulegroup builtinmethod {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:556.1-559.34
    rule builtinmethod: bound |- routineTypeIR
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
    -- let builtin_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- if Type_wf: bound |- typeIR_ret holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:577.1-582.34
  rulegroup externmethod {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:577.1-582.34
    rule externmethod: bound |- routineTypeIR
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
    -- let extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_externmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
    -- if Type_wf: bound |- typeIR_ret holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:600.1-605.34
  rulegroup externabstractmethod {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:600.1-605.34
    rule externabstractmethod: bound |- routineTypeIR
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
    -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_externabstractmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
    -- if Type_wf: bound |- typeIR_ret holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:623.1-627.56
  rulegroup parserapplymethod {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:623.1-627.56
    rule parserapplymethod: bound |- routineTypeIR
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `PARSER_APPLY(%)`
    -- let parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_parserapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:644.1-648.57
  rulegroup controlapplymethod {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:644.1-648.57
    rule controlapplymethod: bound |- routineTypeIR
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `CONTROL_APPLY(%)`
    -- let control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
    -- if ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- (let direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_controlapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:650.1-651.51
  rulegroup tableapplymethod {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:650.1-651.51
    rule tableapplymethod: bound |- routineTypeIR
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `TABLE_APPLY->%`
    -- let table_apply-> typeIR = methodTypeIR
    -- if typeIR <: tableTypeIR
    -- let tableTypeIR = typeIR as tableTypeIR
    -- if tableTypeIR matches `TABLE_STRUCT%{%}`
    -- let table_struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = tableTypeIR
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:25.1-27.20
relation RoutineTypeDef_wf: bound |- routineTypeDefIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:668.1-671.44
  rulegroup mono {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:668.1-671.44
    rule mono: bound |- routineTypeDefIR
    -- if routineTypeDefIR <: routineTypeIR
    -- let routineTypeIR = routineTypeDefIR as routineTypeIR
    -- if $definable_routine_mono(routineTypeIR)
    -- if RoutineType_wf: bound |- routineTypeIR holds
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:682.1-688.50
  rulegroup poly {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:682.1-688.50
    rule poly: bound |- routineTypeDefIR
    -- if routineTypeDefIR <: polyRoutineTypeDefIR
    -- let routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > = routineTypeDefIR as polyRoutineTypeDefIR
    -- if $definable_routine_poly(routineTypeIR)
    -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
    -- let bound_inner = $union_set<tid>(bound, { tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} })
    -- if RoutineType_wf: bound_inner |- routineTypeIR holds
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:29.1-31.20
relation ConstructorParameterType_wf: bound |- parameterTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:694.1-696.30
  rulegroup  {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:694.1-696.30
    rule : bound |- direction typeIR _id _value?{_value <- _value?}
    -- if direction matches ``EMPTY`
    -- if Type_wf: bound |- typeIR holds
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:33.1-35.20
relation ConstructorParameterTypes_wf: bound |- parameterTypeIR*

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:698.1-702.62
  rulegroup  {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:698.1-702.62
    rule : bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
    -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
    -- if $distinct_<id>(id*{id <- id*})
    -- (if ConstructorParameterType_wf: bound |- parameterTypeIR holds)*{parameterTypeIR <- parameterTypeIR*}
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:37.1-39.20
relation ConstructorType_wf: bound |- constructorTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:720.1-726.46
  rulegroup externtype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:720.1-726.46
    rule externtype: bound |- constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object
    -- if ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- if Type_wf: bound |- typeIR_object holds
    -- let typeIR' = $canon(typeIR_object)
    -- if typeIR' <: externObjectTypeIR
    -- let extern _tid _map<rid, routineTypeDefIR> = typeIR' as externObjectTypeIR
    -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_constructor_extern(typeIR))*{typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:739.1-745.46
  rulegroup parsertype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:739.1-745.46
    rule parsertype: bound |- constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object
    -- if ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- if Type_wf: bound |- typeIR_object holds
    -- let typeIR' = $canon(typeIR_object)
    -- if typeIR' <: parserObjectTypeIR
    -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR' as parserObjectTypeIR
    -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_constructor_parser(typeIR))*{typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:758.1-764.47
  rulegroup controltype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:758.1-764.47
    rule controltype: bound |- constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object
    -- if ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- if Type_wf: bound |- typeIR_object holds
    -- let typeIR' = $canon(typeIR_object)
    -- if typeIR' <: controlObjectTypeIR
    -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR' as controlObjectTypeIR
    -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_constructor_control(typeIR))*{typeIR <- typeIR*}
  }

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:775.1-781.47
  rulegroup packagetype {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:775.1-781.47
    rule packagetype: bound |- constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object
    -- if ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds
    -- if Type_wf: bound |- typeIR_object holds
    -- let typeIR' = $canon(typeIR_object)
    -- if typeIR' <: packageObjectTypeIR
    -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR' as packageObjectTypeIR
    -- (let _direction typeIR _id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}
    -- (if $nestable_constructor_package(typeIR))*{typeIR <- typeIR*}
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:41.1-43.20
relation ConstructorTypeDef_wf: bound |- constructorTypeDefIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:799.1-806.58
  rulegroup  {


    ;; ../../../../spec-concrete/5.03-wellformed.watsup:799.1-806.58
    rule : bound |- constructorTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >
    -- let constructor( _constructorParameterTypeIR*{_constructorParameterTypeIR <- _constructorParameterTypeIR*} )-> typeIR_object = constructorTypeIR
    -- if $definable_constructor(typeIR_object)
    -- if $distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})
    -- let bound_inner = $union_set<tid>(bound, { tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} })
    -- if ConstructorType_wf: bound_inner |- constructorTypeIR holds
  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:98.1-98.37
def $nestable_typedef(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:101.1-101.67
  clause 0(typeIR) = $nestable'_typedef($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:99.1-99.38
def $nestable'_typedef(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:102.1-102.36
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:103.1-103.37
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:104.1-104.38
  clause 2(typeIR) = true
  -- if (typeIR = string as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:105.1-105.44
  clause 3(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:106.1-106.37
  clause 4(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:107.1-107.40
  clause 5(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:108.1-108.42
  clause 6(typeIR) = true
  -- if typeIR <: dataTypeIR
  -- let dataTypeIR = typeIR as dataTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:109.1-110.15
  clause 7(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:117.1-117.33
def $nestable_new(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:120.1-120.59
  clause 0(typeIR) = $nestable'_new($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:118.1-118.34
def $nestable'_new(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:121.1-121.32
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:122.1-122.38
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:123.1-123.38
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:124.1-124.33
  clause 3(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:125.1-125.36
  clause 4(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:126.1-127.15
  clause 5(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:136.1-136.34
def $nestable_list(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:139.1-139.61
  clause 0(typeIR) = $nestable'_list($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:137.1-137.35
def $nestable'_list(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:140.1-140.33
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:141.1-141.34
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:142.1-142.39
  clause 2(typeIR) = true
  -- if (typeIR = match_kind as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:143.1-143.35
  clause 3(typeIR) = true
  -- if (typeIR = string as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:144.1-144.41
  clause 4(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:145.1-145.34
  clause 5(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:146.1-146.37
  clause 6(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:147.1-147.39
  clause 7(typeIR) = true
  -- if typeIR <: dataTypeIR
  -- let dataTypeIR = typeIR as dataTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:148.1-149.15
  clause 8(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:156.1-156.35
def $nestable_tuple(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:159.1-159.63
  clause 0(typeIR) = $nestable'_tuple($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:157.1-157.36
def $nestable'_tuple(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:160.1-160.34
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:161.1-161.35
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:162.1-162.40
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:163.1-163.40
  clause 3(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:164.1-164.43
  clause 4(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:165.1-165.35
  clause 5(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:166.1-166.38
  clause 6(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:167.1-167.42
  clause 7(typeIR) = true
  -- if typeIR <: tupleTypeIR
  -- let tuple< _typeIR*{_typeIR <- _typeIR*} > = typeIR as tupleTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:168.1-168.43
  clause 8(typeIR') = true
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:169.1-169.45
  clause 9(typeIR) = true
  -- if typeIR <: headerTypeIR
  -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:170.1-170.51
  clause 10(typeIR) = true
  -- if typeIR <: headerUnionTypeIR
  -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:171.1-171.45
  clause 11(typeIR) = true
  -- if typeIR <: structTypeIR
  -- let struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:172.1-172.43
  clause 12(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:173.1-173.48
  clause 13(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:174.1-175.15
  clause 14(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:182.1-182.35
def $nestable_stack(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:185.1-185.63
  clause 0(typeIR) = $nestable'_stack($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:183.1-183.36
def $nestable'_stack(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:186.1-186.35
  clause 0(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:187.1-187.45
  clause 1(typeIR) = true
  -- if typeIR <: headerTypeIR
  -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:188.1-188.51
  clause 2(typeIR) = true
  -- if typeIR <: headerUnionTypeIR
  -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:189.1-190.15
  clause 3(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:197.1-197.36
def $nestable_struct(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:200.1-200.65
  clause 0(typeIR) = $nestable'_struct($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:198.1-198.37
def $nestable'_struct(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:201.1-201.35
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:202.1-202.36
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:203.1-203.41
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:204.1-204.41
  clause 3(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:205.1-205.44
  clause 4(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:206.1-206.36
  clause 5(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:207.1-207.39
  clause 6(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:208.1-208.43
  clause 7(typeIR) = true
  -- if typeIR <: tupleTypeIR
  -- let tuple< _typeIR*{_typeIR <- _typeIR*} > = typeIR as tupleTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:209.1-209.44
  clause 8(typeIR') = true
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:210.1-210.46
  clause 9(typeIR) = true
  -- if typeIR <: structTypeIR
  -- let struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:211.1-211.46
  clause 10(typeIR) = true
  -- if typeIR <: headerTypeIR
  -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:212.1-212.52
  clause 11(typeIR) = true
  -- if typeIR <: headerUnionTypeIR
  -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:213.1-213.44
  clause 12(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:214.1-214.49
  clause 13(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:215.1-216.15
  clause 14(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:224.1-224.36
def $nestable_header(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:229.1-229.65
  clause 0(typeIR) = $nestable'_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:225.1-225.37
def $nestable'_header(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:230.1-230.35
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:231.1-231.41
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:232.1-232.41
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:233.1-233.44
  clause 3(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `VARBIT<%>`
  -- let varbit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:234.1-234.36
  clause 4(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:235.1-235.39
  clause 5(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:236.1-236.49
  clause 6(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:237.1-238.44
  clause 7(typeIR') = true
  -- if typeIR' <: structTypeIR
  -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR
  -- (if $nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:239.1-240.15
  clause 8(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:226.1-226.46
def $nestable_struct_in_header(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:242.1-243.48
  clause 0(typeIR) = $nestable'_struct_in_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:227.1-227.47
def $nestable'_struct_in_header(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:244.1-244.45
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:245.1-245.51
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:246.1-246.51
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:247.1-247.46
  clause 3(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:248.1-248.49
  clause 4(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:249.1-249.59
  clause 5(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:250.1-251.44
  clause 6(typeIR') = true
  -- if typeIR' <: structTypeIR
  -- let struct _tid { typeIR _id ;*{_id <- _id*, typeIR <- typeIR*} } = typeIR' as structTypeIR
  -- (if $nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:252.1-253.15
  clause 7(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:261.1-261.41
def $nestable_headerunion(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:264.1-265.43
  clause 0(typeIR) = $nestable'_headerunion($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:262.1-262.42
def $nestable'_headerunion(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:266.1-266.41
  clause 0(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:267.1-267.44
  clause 1(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:268.1-268.51
  clause 2(typeIR) = true
  -- if typeIR <: headerTypeIR
  -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:269.1-270.15
  clause 3(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:282.1-282.37
def $nestable_serenum(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:287.1-288.39
  clause 0(typeIR) = $nestable'_serenum($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:283.1-283.38
def $nestable'_serenum(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:289.1-289.42
  clause 0(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:290.1-290.42
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:291.1-291.37
  clause 2(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:292.1-293.37
  clause 3(typeIR') = $nestable_new_in_serenum(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:294.1-295.15
  clause 4(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:284.1-284.44
def $nestable_new_in_serenum(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:297.1-298.46
  clause 0(typeIR) = $nestable_new_in_serenum'($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:285.1-285.45
def $nestable_new_in_serenum'(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:299.1-299.49
  clause 0(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:300.1-300.49
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:301.1-301.44
  clause 2(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:302.1-302.47
  clause 3(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:303.1-304.15
  clause 4(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:361.1-361.33
def $nestable_set(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:368.1-368.59
  clause 0(typeIR) = $nestable'_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:362.1-362.34
def $nestable'_set(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:369.1-369.32
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:370.1-370.33
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:371.1-371.38
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:372.1-372.38
  clause 3(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:373.1-373.33
  clause 4(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:374.1-374.36
  clause 5(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:375.1-376.40
  clause 6(typeIR') = true
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
  -- (if $nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:377.1-377.41
  clause 7(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:378.1-378.46
  clause 8(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:379.1-380.43
  clause 9(typeIR') = true
  -- if typeIR' <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR' as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%>`
  -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR
  -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:381.1-382.15
  clause 10(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:363.1-363.42
def $nestable_tuple_in_set(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:384.1-385.44
  clause 0(typeIR) = $nestable'_tuple_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:364.1-364.43
def $nestable'_tuple_in_set(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:386.1-386.41
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:387.1-387.47
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:388.1-388.47
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:389.1-389.42
  clause 3(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:390.1-390.45
  clause 4(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:391.1-392.40
  clause 5(typeIR') = true
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
  -- (if $nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:393.1-393.50
  clause 6(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:394.1-394.55
  clause 7(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:395.1-396.15
  clause 8(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:365.1-365.45
def $nestable_sequence_in_set(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:398.1-399.47
  clause 0(typeIR) = $nestable'_sequence_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:366.1-366.46
def $nestable'_sequence_in_set(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:400.1-400.44
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:401.1-401.50
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:402.1-402.50
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:403.1-403.45
  clause 3(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:404.1-404.48
  clause 4(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid _typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:405.1-406.43
  clause 5(typeIR') = true
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR*{typeIR <- typeIR*} > = typeIR' as tupleTypeIR
  -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:407.1-407.53
  clause 6(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:408.1-408.58
  clause 7(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:409.1-410.43
  clause 8(typeIR') = true
  -- if typeIR' <: sequenceTypeIR
  -- let sequenceTypeIR = typeIR' as sequenceTypeIR
  -- if sequenceTypeIR matches `SEQ<%>`
  -- let seq< typeIR*{typeIR <- typeIR*} > = sequenceTypeIR
  -- (if $nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:411.1-412.15
  clause 9(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:430.1-430.40
def $definable_type_mono(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:432.1-432.39
  clause 0(typeIR) = true
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid _tid = namedTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:433.1-433.45
  clause 1(typeIR) = true
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:434.1-434.47
  clause 2(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:435.1-435.52
  clause 3(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:436.1-436.46
  clause 4(typeIR) = true
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:437.1-438.15
  clause 5(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:445.1-445.40
def $definable_type_poly(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:447.1-447.46
  clause 0(typeIR) = true
  -- if typeIR <: tupleTypeIR
  -- let tuple< _typeIR*{_typeIR <- _typeIR*} > = typeIR as tupleTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:448.1-448.42
  clause 1(typeIR) = true
  -- if typeIR <: headerStackTypeIR
  -- let _typeIR [ _nat ] = typeIR as headerStackTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:449.1-449.49
  clause 2(typeIR) = true
  -- if typeIR <: headerTypeIR
  -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:450.1-450.55
  clause 3(typeIR) = true
  -- if typeIR <: headerUnionTypeIR
  -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:451.1-451.49
  clause 4(typeIR) = true
  -- if typeIR <: structTypeIR
  -- let struct _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as structTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:452.1-452.44
  clause 5(typeIR) = true
  -- if typeIR <: externObjectTypeIR
  -- let extern _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:453.1-453.47
  clause 6(typeIR) = true
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:454.1-454.48
  clause 7(typeIR) = true
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:455.1-455.48
  clause 8(typeIR) = true
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:456.1-457.15
  clause 9(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:478.1-478.49
def $nestable_function(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:481.1-482.51
  clause 0(direction, typeIR) = $nestable_function'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:479.1-479.50
def $nestable_function'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:483.1-484.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:485.1-486.29
  clause 1(direction, typeIR) = false
  -- if (typeIR = int as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:487.1-487.57
  clause 2(direction, typeIR) = false
  -- if typeIR <: objectTypeIR
  -- let objectTypeIR = typeIR as objectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:488.1-489.15
  clause 3(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:498.1-498.47
def $directionless_trailing(direction*) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:501.1-502.65
  clause 0(direction*{direction <- direction*}) = $directionless_trailing'(true, $rev_<direction>(direction*{direction <- direction*}))

;; ../../../../spec-concrete/5.03-wellformed.watsup:499.1-499.54
def $directionless_trailing'(bool, direction*) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:504.1-504.44
  clause 0(_bool, direction*{direction <- direction*}) = true
  -- if direction*{direction <- direction*} matches []

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:505.1-506.49
  clause 1(bool, direction'*{direction' <- direction'*}) = $directionless_trailing'(true, direction_t*{direction_t <- direction_t*})
  -- if (bool = true)
  -- if direction'*{direction' <- direction'*} matches _ :: _
  -- let direction :: direction_t*{direction_t <- direction_t*} = direction'*{direction' <- direction'*}
  -- if direction matches ``EMPTY`

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:507.1-507.68
  clause 2(bool, direction'*{direction' <- direction'*}) = false
  -- if (bool = false)
  -- if direction'*{direction' <- direction'*} matches _ :: _
  -- let direction :: direction_t*{direction_t <- direction_t*} = direction'*{direction' <- direction'*}
  -- if direction matches ``EMPTY`

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:508.1-510.31
  clause 3(_bool, direction*{direction <- direction*}) = $directionless_trailing'(false, direction_t*{direction_t <- direction_t*})
  -- if direction*{direction <- direction*} matches _ :: _
  -- let direction_h :: direction_t*{direction_t <- direction_t*} = direction*{direction <- direction*}
  -- if (direction_h =/= )

;; ../../../../spec-concrete/5.03-wellformed.watsup:512.1-512.47
def $nestable_action(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:515.1-516.49
  clause 0(direction, typeIR) = $nestable_action'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:513.1-513.48
def $nestable_action'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:517.1-518.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:519.1-519.38
  clause 1(_direction, typeIR) = false
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:520.1-520.47
  clause 2(_direction, typeIR) = false
  -- if typeIR <: objectTypeIR
  -- let objectTypeIR = typeIR as objectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:521.1-522.15
  clause 3(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:531.1-531.55
def $nestable_externfunction(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:534.1-535.57
  clause 0(direction, typeIR) = $nestable_externfunction'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:532.1-532.56
def $nestable_externfunction'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:536.1-537.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:538.1-539.29
  clause 1(direction, typeIR) = false
  -- if (typeIR = int as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:540.1-540.64
  clause 2(direction, typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:541.1-541.65
  clause 3(direction, typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:542.1-542.65
  clause 4(direction, typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:543.1-543.63
  clause 5(direction, typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:544.1-545.15
  clause 6(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:561.1-561.53
def $nestable_externmethod(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:564.1-565.55
  clause 0(direction, typeIR) = $nestable_externmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:562.1-562.54
def $nestable_externmethod'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:566.1-567.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:568.1-569.29
  clause 1(direction, typeIR) = false
  -- if (typeIR = int as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:570.1-570.62
  clause 2(direction, typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:571.1-571.63
  clause 3(direction, typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:572.1-572.63
  clause 4(direction, typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:573.1-573.61
  clause 5(direction, typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:574.1-575.15
  clause 6(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:584.1-584.61
def $nestable_externabstractmethod(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:587.1-588.63
  clause 0(direction, typeIR) = $nestable_externabstractmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:585.1-585.62
def $nestable_externabstractmethod'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:589.1-590.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:591.1-592.29
  clause 1(direction, typeIR) = false
  -- if (typeIR = int as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:593.1-593.70
  clause 2(direction, typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:594.1-594.71
  clause 3(direction, typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:595.1-595.71
  clause 4(direction, typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:596.1-596.69
  clause 5(direction, typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:597.1-598.15
  clause 6(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:607.1-607.58
def $nestable_parserapplymethod(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:610.1-611.60
  clause 0(direction, typeIR) = $nestable_parserapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:608.1-608.59
def $nestable_parserapplymethod'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:612.1-613.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:614.1-615.29
  clause 1(direction, typeIR) = false
  -- if (typeIR = int as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:616.1-616.67
  clause 2(direction, typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:617.1-617.68
  clause 3(direction, typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:618.1-618.68
  clause 4(direction, typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:619.1-619.66
  clause 5(direction, typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:620.1-621.15
  clause 6(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:629.1-629.59
def $nestable_controlapplymethod(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:632.1-633.61
  clause 0(direction, typeIR) = $nestable_controlapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:630.1-630.60
def $nestable_controlapplymethod'(direction, typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:634.1-635.29
  clause 0(direction, typeIR) = false
  -- if (typeIR = string as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:636.1-637.29
  clause 1(direction, typeIR) = false
  -- if (typeIR = int as typeIR)
  -- if (direction =/= )

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:638.1-638.68
  clause 2(direction, typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:639.1-639.69
  clause 3(direction, typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:640.1-640.67
  clause 4(direction, typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:641.1-642.15
  clause 5(_direction, _typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:657.1-657.50
def $definable_routine_mono(routineTypeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:659.1-659.66
  clause 0(routineTypeIR) = true
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
  -- let builtin_function( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = functionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:660.1-660.50
  clause 1(routineTypeIR) = true
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `ACTION(%)`
  -- let action( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = functionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:661.1-661.64
  clause 2(routineTypeIR) = true
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
  -- let builtin_method( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = methodTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:662.1-662.56
  clause 3(routineTypeIR) = true
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `PARSER_APPLY(%)`
  -- let parser_apply( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = methodTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:663.1-663.57
  clause 4(routineTypeIR) = true
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `CONTROL_APPLY(%)`
  -- let control_apply( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = methodTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:664.1-664.54
  clause 5(routineTypeIR) = true
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `TABLE_APPLY->%`
  -- let table_apply-> _typeIR = methodTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:665.1-666.15
  clause 6(_routineTypeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:673.1-673.50
def $definable_routine_poly(routineTypeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:675.1-675.58
  clause 0(routineTypeIR) = true
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `FUNCTION(%)->%`
  -- let function( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = functionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:676.1-676.65
  clause 1(routineTypeIR) = true
  -- if routineTypeIR <: functionTypeIR
  -- let functionTypeIR = routineTypeIR as functionTypeIR
  -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
  -- let extern_function( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = functionTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:677.1-677.63
  clause 2(routineTypeIR) = true
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
  -- let extern_method( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = methodTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:678.1-678.72
  clause 3(routineTypeIR) = true
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = methodTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:679.1-680.15
  clause 4(_routineTypeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:708.1-708.48
def $nestable_constructor_extern(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:711.1-712.50
  clause 0(typeIR) = $nestable'_constructor_extern($canon(typeIR))

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:713.1-713.56
  clause 1(typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

;; ../../../../spec-concrete/5.03-wellformed.watsup:709.1-709.49
def $nestable'_constructor_extern(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:714.1-714.58
  clause 0(typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:715.1-715.58
  clause 1(typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:716.1-716.56
  clause 2(typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:717.1-718.15
  clause 3(_typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:728.1-728.48
def $nestable_constructor_parser(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:731.1-732.50
  clause 0(typeIR) = $nestable'_constructor_parser($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:729.1-729.49
def $nestable'_constructor_parser(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:733.1-733.58
  clause 0(typeIR) = false
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:734.1-734.58
  clause 1(typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:735.1-735.56
  clause 2(typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:736.1-737.15
  clause 3(_typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:747.1-747.49
def $nestable_constructor_control(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:750.1-751.51
  clause 0(typeIR) = $nestable'_constructor_control($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:748.1-748.50
def $nestable'_constructor_control(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:752.1-752.58
  clause 0(typeIR) = false
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:753.1-753.59
  clause 1(typeIR) = false
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:754.1-754.57
  clause 2(typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:755.1-756.15
  clause 3(_typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:766.1-766.49
def $nestable_constructor_package(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:769.1-770.51
  clause 0(typeIR) = $nestable'_constructor_package($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:767.1-767.50
def $nestable'_constructor_package(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:771.1-771.57
  clause 0(typeIR) = false
  -- if typeIR <: tableObjectTypeIR
  -- let table _tid # _typeIR = typeIR as tableObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:772.1-773.15
  clause 1(_typeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.03-wellformed.watsup:787.1-787.42
def $definable_constructor(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:790.1-791.44
  clause 0(typeIR) = $definable'_constructor($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:788.1-788.43
def $definable'_constructor(typeIR) : bool =

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:792.1-792.47
  clause 0(typeIR) = true
  -- if typeIR <: externObjectTypeIR
  -- let extern _tid _map<rid, routineTypeDefIR> = typeIR as externObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:793.1-793.50
  clause 1(typeIR) = true
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:794.1-794.51
  clause 2(typeIR) = true
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:795.1-795.51
  clause 3(typeIR) = true
  -- if typeIR <: packageObjectTypeIR
  -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.03-wellformed.watsup:796.1-797.15
  clause 4(_typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.04-typing-relation.watsup:6.1-8.23
relation Eval_static: cursor typingContext |- typedExpressionIR ~> value

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:16.1-24.2
  rulegroup literalExpressionIR-boolean {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:18.3-19.39
    rule true: p TC |- expressionIR # ( _typeIR _ctk ) ~> b true as value
    -- if (expressionIR = true as expressionIR)

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:21.3-22.41
    rule false: p TC |- expressionIR # ( _typeIR _ctk ) ~> b false as value
    -- if (expressionIR = false as expressionIR)
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:28.1-39.2
  rulegroup literalExpressionIR-number {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:30.3-31.37
    rule arbint: p TC |- expressionIR # ( _typeIR _ctk ) ~> d i as value
    -- if expressionIR <: numberLiteral
    -- let numberLiteral = expressionIR as numberLiteral
    -- if numberLiteral matches `D%`
    -- let d i = numberLiteral

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:33.3-34.41
    rule fixbit: p TC |- expressionIR # ( _typeIR _ctk ) ~> n w i as value
    -- if expressionIR <: numberLiteral
    -- let numberLiteral = expressionIR as numberLiteral
    -- if numberLiteral matches `%W%`
    -- let n w i = numberLiteral

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:36.3-37.41
    rule fixint: p TC |- expressionIR # ( _typeIR _ctk ) ~> n s i as value
    -- if expressionIR <: numberLiteral
    -- let numberLiteral = expressionIR as numberLiteral
    -- if numberLiteral matches `%S%`
    -- let n s i = numberLiteral
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:43.1-44.49
  rulegroup literalExpressionIR-stringliteral {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:43.1-44.49
    rule literalExpressionIR-stringliteral: p TC |- expressionIR # ( _typeIR _ctk ) ~> " text " as value
    -- if expressionIR <: stringLiteral
    -- let " text " = expressionIR as stringLiteral
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:49.1-51.51
  rulegroup referenceExpression {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:49.1-51.51
    rule referenceExpression: p TC |- expressionIR # ( _typeIR _ctk ) ~> value
    -- if expressionIR <: prefixedNameIR
    -- let prefixedNameIR = expressionIR as prefixedNameIR
    -- let value = $find_value(p, TC, prefixedNameIR)
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:56.1-57.38
  rulegroup defaultExpressionIR {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:56.1-57.38
    rule defaultExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) ~> default as value
    -- if (expressionIR = ... as expressionIR)
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:62.1-80.2
  rulegroup unaryExpressionIR {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:64.3-66.55
    rule bnot: p TC |- expressionIR # ( _typeIR _ctk ) ~> $un_bnot(value)
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
    -- if unop matches `~`
    -- Eval_static: p TC |- typedExpressionIR ~> value

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:68.3-70.55
    rule lnot: p TC |- expressionIR # ( _typeIR _ctk ) ~> $un_lnot(value)
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
    -- if unop matches `!`
    -- Eval_static: p TC |- typedExpressionIR ~> value

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:72.3-74.55
    rule plus: p TC |- expressionIR # ( _typeIR _ctk ) ~> $un_plus(value)
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
    -- if unop matches `+`
    -- Eval_static: p TC |- typedExpressionIR ~> value

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:76.3-78.55
    rule minus: p TC |- expressionIR # ( _typeIR _ctk ) ~> $un_minus(value)
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
    -- if unop matches `-`
    -- Eval_static: p TC |- typedExpressionIR ~> value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:86.1-208.2
  rulegroup binaryExpressionIR {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:88.3-92.59
    rule plus: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_plus(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `+`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:94.3-98.59
    rule satplus: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_satplus(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `|+|`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:100.3-104.59
    rule minus: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_minus(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `-`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:106.3-110.59
    rule satminus: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_satminus(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `|-|`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:112.3-116.59
    rule mul: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_mul(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `*`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:118.3-122.59
    rule div: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_div(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `/`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:124.3-128.59
    rule shl: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_shl(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `<<`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:130.3-134.59
    rule shr: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_shr(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `>>`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:136.3-140.59
    rule le: p TC |- expressionIR # ( _typeIR _ctk ) ~> b $bin_le(value_l, value_r) as value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `<=`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:142.3-146.59
    rule ge: p TC |- expressionIR # ( _typeIR _ctk ) ~> b $bin_ge(value_l, value_r) as value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `>=`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:148.3-152.59
    rule lt: p TC |- expressionIR # ( _typeIR _ctk ) ~> b $bin_lt(value_l, value_r) as value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `<`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:154.3-158.59
    rule gt: p TC |- expressionIR # ( _typeIR _ctk ) ~> b $bin_gt(value_l, value_r) as value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `>`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:160.3-164.59
    rule eq: p TC |- expressionIR # ( _typeIR _ctk ) ~> b $bin_eq(value_l, value_r) as value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `==`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:166.3-170.59
    rule ne: p TC |- expressionIR # ( _typeIR _ctk ) ~> b $bin_ne(value_l, value_r) as value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `!=`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:172.3-176.59
    rule band: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_band(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `&`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:178.3-182.59
    rule bxor: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_bxor(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `^`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:184.3-188.59
    rule bor: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_bor(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `|`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:190.3-194.59
    rule concat: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_concat(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `++`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:196.3-200.59
    rule land: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_land(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `&&`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:202.3-206.59
    rule lor: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bin_lor(value_l, value_r)
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `||`
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:214.1-230.2
  rulegroup ternaryExpressionIR {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:216.3-221.65
    rule true: p TC |- expressionIR # ( _typeIR _ctk ) ~> value_true
    -- if expressionIR <: ternaryExpressionIR
    -- let typedExpressionIR_cond ? typedExpressionIR_true : typedExpressionIR_false = expressionIR as ternaryExpressionIR
    -- Eval_static: p TC |- typedExpressionIR_cond ~> value
    -- if (value = b true as value)
    -- Eval_static: p TC |- typedExpressionIR_true ~> value_true

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:223.3-228.67
    rule false: p TC |- expressionIR # ( _typeIR _ctk ) ~> value_false
    -- if expressionIR <: ternaryExpressionIR
    -- let typedExpressionIR_cond ? typedExpressionIR_true : typedExpressionIR_false = expressionIR as ternaryExpressionIR
    -- Eval_static: p TC |- typedExpressionIR_cond ~> value
    -- if (value = b false as value)
    -- Eval_static: p TC |- typedExpressionIR_false ~> value_false
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:235.1-238.45
  rulegroup castExpression {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:235.1-238.45
    rule castExpression: p TC |- expressionIR # ( _typeIR _ctk ) ~> value_cast
    -- if expressionIR <: castExpressionIR
    -- let ( typeIR ) typedExpressionIR = expressionIR as castExpressionIR
    -- Eval_static: p TC |- typedExpressionIR ~> value
    -- let value_cast = $cast_op(typeIR, value)
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:245.1-246.35
  rulegroup dataExpressionIR-invalid {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:245.1-246.35
    rule dataExpressionIR-invalid: p TC |- expressionIR # ( _typeIR _ctk ) ~> {#} as value
    -- if (expressionIR = {#} as expressionIR)
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:251.1-261.2
  rulegroup dataExpressionIR-sequence {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:253.3-255.58
    rule non-default: p TC |- expressionIR # ( _typeIR _ctk ) ~> seq( value*{value <- value*} ) as value
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
    -- if dataExpressionIR matches `SEQ{%}`
    -- let seq{ typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} } = dataExpressionIR
    -- (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:257.3-259.58
    rule default: p TC |- expressionIR # ( _typeIR _ctk ) ~> seq( value*{value <- value*} ,...) as value
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
    -- if dataExpressionIR matches `SEQ{%,...}`
    -- let seq{ typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ,...} = dataExpressionIR
    -- (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:266.1-278.2
  rulegroup dataExpressionIR-record {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:268.3-271.58
    rule non-default: p TC |- expressionIR # ( _typeIR _ctk ) ~> record{ value nameIR ;*{nameIR <- nameIR*, value <- value*} } as value
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
    -- if dataExpressionIR matches `RECORD{%}`
    -- let record{ nameIR = typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} } = dataExpressionIR
    -- (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:273.3-276.58
    rule default: p TC |- expressionIR # ( _typeIR _ctk ) ~> record{ value nameIR ;*{nameIR <- nameIR*, value <- value*} ,...} as value
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
    -- if dataExpressionIR matches `RECORD{%,...}`
    -- let record{ nameIR = typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} ,...} = dataExpressionIR
    -- (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:286.1-289.58
  rulegroup errorAccessExpressionIR {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:286.1-289.58
    rule errorAccessExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) ~> value_error
    -- if expressionIR <: errorAccessExpressionIR
    -- let error. nameIR = expressionIR as errorAccessExpressionIR
    -- let nameIR_error = "error." ++ nameIR
    -- let value_error = $find_value(p, TC, ` nameIR_error)
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:297.1-313.2
  rulegroup memberAccessExpressionIR-type {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:299.3-303.31
    rule enum: p TC |- expressionIR # ( typeIR_base _ctk ) ~> tid . nameIR as value
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR matches `TYPE%`
    -- let type prefixedNameIR = memberAccessBaseIR
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: enumTypeIR
    -- let enumTypeIR = typeDefIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%{%}`
    -- let enum tid { id_member*{id_member <- id_member*} } = enumTypeIR
    -- if nameIR <- id_member*{id_member <- id_member*}

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:305.3-311.65
    rule serenum: p TC |- expressionIR # ( typeIR_base _ctk ) ~> tid . nameIR # value as value
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR matches `TYPE%`
    -- let type prefixedNameIR = memberAccessBaseIR
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: enumTypeIR
    -- let enumTypeIR = typeDefIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum tid # typeIR { id_member = value_member ;*{id_member <- id_member*, value_member <- value_member*} } = enumTypeIR
    -- let value'?{value' <- value'?} = $assoc_<id, value>(nameIR, (id_member, value_member)*{id_member <- id_member*, value_member <- value_member*})
    -- if value'?{value' <- value'?} matches (_)
    -- let ?(value) = value'?{value' <- value'?}
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:318.1-321.36
  rulegroup memberAccessExpressionIR-typedExpressionIR-stack-size {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:318.1-321.36
    rule memberAccessExpressionIR-typedExpressionIR-stack-size: p TC |- expressionIR # ( typeIR_base _ctk ) ~> d n_size as int as value
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . text = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR <: typedExpressionIR
    -- let typedExpressionIR_base = memberAccessBaseIR as typedExpressionIR
    -- if (text = "size")
    -- let typeIR = typeIR_base
    -- if typeIR <: headerStackTypeIR
    -- let _typeIR [ n_size ] = typeIR as headerStackTypeIR
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:331.1-337.59
  rulegroup indexAccessExpressionIR-bitslice {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:331.1-337.59
    rule indexAccessExpressionIR-bitslice: p TC |- expressionIR # ( _typeIR _ctk ) ~> $bitacc_op(value_base, value_hi, value_lo)
    -- if expressionIR <: indexAccessExpressionIR
    -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
    -- if indexAccessExpressionIR matches `%[%:%]`
    -- let typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ] = indexAccessExpressionIR
    -- Eval_static: p TC |- typedExpressionIR_base ~> value_base
    -- Eval_static: p TC |- typedExpressionIR_hi ~> value_hi
    -- Eval_static: p TC |- typedExpressionIR_lo ~> value_lo
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:353.1-357.91
  rulegroup callExpressionIR-typedLvalueIR-size {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:353.1-357.91
    rule callExpressionIR-typedLvalueIR-size: p TC |- expressionIR # ( _typeIR _ctk ) ~> $sizeof(typeIR_base, nameIR)
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%<%>(%)`
    -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- let _expressionIR # ( typeIR_base _ctk' ) = typedExpressionIR_base
    -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:361.1-375.2
  rulegroup callExpressionIR-type {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:363.3-367.93
    rule size-mono: p TC |- expressionIR # ( _typeIR _ctk ) ~> $sizeof(typeIR_base, nameIR)
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%<%>(%)`
    -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if routineTargetIR matches `TYPE%.%`
    -- let type prefixedNameIR . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR_base = typeDefIR as typeIR
    -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:369.3-373.93
    rule size-poly: p TC |- expressionIR # ( _typeIR _ctk ) ~> $sizeof(typeIR_base, nameIR)
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%<%>(%)`
    -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if routineTargetIR matches `TYPE%.%`
    -- let type prefixedNameIR . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: polyTypeDefIR
    -- let typeIR_base < tid*{tid <- tid*} , tid'*{tid' <- tid'*} > = typeDefIR as polyTypeDefIR
    -- if tid*{tid <- tid*} matches []
    -- if tid'*{tid' <- tid'*} matches []
    -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:379.1-386.21
  rulegroup callExpressionIR-parenthesized {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:379.1-386.21
    rule callExpressionIR-parenthesized: p TC |- expressionIR # ( typeIR ctk ) ~> value
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%<%>(%)`
    -- let routineTargetIR' < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if routineTargetIR' matches `(%)`
    -- let ( routineTargetIR ) = routineTargetIR'
    -- Eval_static: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) as expressionIR # ( typeIR ctk ) ~> value
  }

  ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:391.1-393.53
  rulegroup parenthesizedExpressionIR {


    ;; ../../../../spec-concrete/5.06.1-expression-static-eval.watsup:391.1-393.53
    rule parenthesizedExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) ~> value
    -- if expressionIR <: parenthesizedExpressionIR
    -- let ( typedExpressionIR ) = expressionIR as parenthesizedExpressionIR
    -- Eval_static: p TC |- typedExpressionIR ~> value
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:15.1-17.23
relation Type_ok: cursor typingContext |- typeOrVoid : typeIR # tid*

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:11.1-12.29
  rulegroup boolean {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:11.1-12.29
    rule boolean: p TC |- typeOrVoid : bool as typeIR # []
    -- if (typeOrVoid = bool as typeOrVoid)
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:16.1-17.31
  rulegroup error {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:16.1-17.31
    rule error: p TC |- typeOrVoid : error as typeIR # []
    -- if (typeOrVoid = error as typeOrVoid)
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:21.1-22.41
  rulegroup matchkind {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:21.1-22.41
    rule matchkind: p TC |- typeOrVoid : match_kind as typeIR # []
    -- if (typeOrVoid = match_kind as typeOrVoid)
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:26.1-27.33
  rulegroup string {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:26.1-27.33
    rule string: p TC |- typeOrVoid : string as typeIR # []
    -- if (typeOrVoid = string as typeOrVoid)
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:31.1-32.27
  rulegroup arbint {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:31.1-32.27
    rule arbint: p TC |- typeOrVoid : int as typeIR # []
    -- if (typeOrVoid = int as typeOrVoid)
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:37.1-48.2
  rulegroup fixint {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:39.3-40.45
    rule integer: p TC |- typeOrVoid : int< n > as typeIR # []
    -- if typeOrVoid <: baseType
    -- let baseType = typeOrVoid as baseType
    -- if baseType matches `INT<%>`
    -- let int< int > = baseType
    -- if int <: nat
    -- let n = int as nat

    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:42.3-46.32
    rule expr: p TC |- typeOrVoid : int< n > as typeIR # []
    -- if typeOrVoid <: baseType
    -- let baseType = typeOrVoid as baseType
    -- if baseType matches `INT<(%)>`
    -- let int<( expression )> = baseType
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- Eval_static: p TC |- typedExpressionIR ~> value
    -- let int = $to_number(value)
    -- if int <: nat
    -- let n = int as nat
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:54.1-68.2
  rulegroup fixbit {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:56.3-57.38
    rule none: p TC |- typeOrVoid : bit< 1 > as typeIR # []
    -- if (typeOrVoid = bit as typeOrVoid)

    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:59.3-60.45
    rule integer: p TC |- typeOrVoid : bit< n > as typeIR # []
    -- if typeOrVoid <: baseType
    -- let baseType = typeOrVoid as baseType
    -- if baseType matches `BIT<%>`
    -- let bit< int > = baseType
    -- if int <: nat
    -- let n = int as nat

    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:62.3-66.32
    rule expr: p TC |- typeOrVoid : bit< n > as typeIR # []
    -- if typeOrVoid <: baseType
    -- let baseType = typeOrVoid as baseType
    -- if baseType matches `BIT<(%)>`
    -- let bit<( expression )> = baseType
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- Eval_static: p TC |- typedExpressionIR ~> value
    -- let int = $to_number(value)
    -- if int <: nat
    -- let n = int as nat
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:73.1-84.2
  rulegroup varbit {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:75.3-76.51
    rule integer: p TC |- typeOrVoid : varbit< n > as typeIR # []
    -- if typeOrVoid <: baseType
    -- let baseType = typeOrVoid as baseType
    -- if baseType matches `VARBIT<%>`
    -- let varbit< int > = baseType
    -- if int <: nat
    -- let n = int as nat

    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:78.3-82.32
    rule expr: p TC |- typeOrVoid : varbit< n > as typeIR # []
    -- if typeOrVoid <: baseType
    -- let baseType = typeOrVoid as baseType
    -- if baseType matches `VARBIT<(%)>`
    -- let varbit<( expression )> = baseType
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- Eval_static: p TC |- typedExpressionIR ~> value
    -- let int = $to_number(value)
    -- if int <: nat
    -- let n = int as nat
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:91.1-103.2
  rulegroup prefixedTypeName {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:93.3-96.53
    rule mono: p TC |- typeOrVoid : typeIR # []
    -- if typeOrVoid <: prefixedTypeName
    -- let prefixedTypeName = typeOrVoid as prefixedTypeName
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR = typeDefIR as typeIR

    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:98.3-101.60
    rule poly: p TC |- typeOrVoid : polyTypeDefIR < [] > as typeIR # []
    -- if typeOrVoid <: prefixedTypeName
    -- let prefixedTypeName = typeOrVoid as prefixedTypeName
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: polyTypeDefIR
    -- let polyTypeDefIR = typeDefIR as polyTypeDefIR
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:108.1-124.2
  rulegroup specializedType {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:110.3-113.53
    rule mono: p TC |- typeOrVoid : typeIR # []
    -- if typeOrVoid <: specializedType
    -- let prefixedTypeName < typeArgumentList > = typeOrVoid as specializedType
    -- if typeArgumentList matches ``EMPTY`
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR = typeDefIR as typeIR

    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:115.3-122.75
    rule poly: p TC |- typeOrVoid : polyTypeDefIR < typeIR_arg*{typeIR_arg <- typeIR_arg*} > as typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
    -- if typeOrVoid <: specializedType
    -- let prefixedTypeName < typeArgumentList > = typeOrVoid as specializedType
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: polyTypeDefIR
    -- let polyTypeDefIR = typeDefIR as polyTypeDefIR
    -- let typeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > = polyTypeDefIR
    -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
    -- TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeIR_arg*{typeIR_arg <- typeIR_arg*} # tid_fresh*{tid_fresh <- tid_fresh*}
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:129.1-157.2
  rulegroup headerStackType {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:131.3-142.61
    rule prefixedTypeName: p TC |- typeOrVoid : polyTypeDefIR_stack < [typeIR_base] > as typeIR # []
    -- if typeOrVoid <: headerStackType
    -- let namedType [ expression_size ] = typeOrVoid as headerStackType
    -- if namedType <: prefixedTypeName
    -- let prefixedTypeName = namedType as prefixedTypeName
    -- Type_ok: p TC |- prefixedTypeName as typeOrVoid : typeIR_base # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- Expr_ok: p TC |- expression_size : typedExpressionIR_size
    -- Eval_static: p TC |- typedExpressionIR_size ~> value_size
    -- let int = $to_number(value_size)
    -- if int <: nat
    -- let n_size = int as nat
    -- let typeIR_stack = tid "T" as typeIR [ n_size ] as typeIR
    -- let polyTypeDefIR_stack = typeIR_stack < ["T"] , [] >

    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:144.3-155.61
    rule specializedType: p TC |- typeOrVoid : polyTypeDefIR_stack < [typeIR_base] > as typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
    -- if typeOrVoid <: headerStackType
    -- let namedType [ expression_size ] = typeOrVoid as headerStackType
    -- if namedType <: specializedType
    -- let specializedType = namedType as specializedType
    -- Type_ok: p TC |- specializedType as typeOrVoid : typeIR_base # tid_fresh*{tid_fresh <- tid_fresh*}
    -- Expr_ok: p TC |- expression_size : typedExpressionIR_size
    -- Eval_static: p TC |- typedExpressionIR_size ~> value_size
    -- let int = $to_number(value_size)
    -- if int <: nat
    -- let n_size = int as nat
    -- let typeIR_stack = tid "T" as typeIR [ n_size ] as typeIR
    -- let polyTypeDefIR_stack = typeIR_stack < ["T"] , [] >
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:162.1-169.57
  rulegroup listType {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:162.1-169.57
    rule listType: p TC |- typeOrVoid : polyTypeDefIR_list < [typeIR_arg] > as typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
    -- if typeOrVoid <: listType
    -- let list< typeArgument > = typeOrVoid as listType
    -- TypeArgument_ok: p TC |- typeArgument : typeIR_arg # tid_fresh*{tid_fresh <- tid_fresh*}
    -- let typeIR_list = list< tid "T" as typeIR > as typeIR
    -- let polyTypeDefIR_list = typeIR_list < ["T"] , [] >
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:174.1-184.67
  rulegroup tupleType {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:174.1-184.67
    rule tupleType: p TC |- typeOrVoid : polyTypeDefIR_tuple < typeIR_arg*{typeIR_arg <- typeIR_arg*} > as typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
    -- if typeOrVoid <: tupleType
    -- let tuple< typeArgumentList > = typeOrVoid as tupleType
    -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
    -- TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeIR_arg*{typeIR_arg <- typeIR_arg*} # tid_fresh*{tid_fresh <- tid_fresh*}
    -- let i_idx*{i_idx <- i_idx*} = $init_(|typeIR_arg*{typeIR_arg <- typeIR_arg*}|) as int*
    -- (let tid_tparam = "T" ++ $int_to_text(i_idx))*{i_idx <- i_idx*, tid_tparam <- tid_tparam*}
    -- let typeIR_tuple = tuple< tid tid_tparam as typeIR*{tid_tparam <- tid_tparam*} > as typeIR
    -- let polyTypeDefIR_tuple = typeIR_tuple < tid_tparam*{tid_tparam <- tid_tparam*} , [] >
  }

  ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:188.1-189.29
  rulegroup void {


    ;; ../../../../spec-concrete/5.05.1-typing-type.watsup:188.1-189.29
    rule void: p TC |- typeOrVoid : void as typeIR # []
    -- if typeOrVoid matches `VOID`
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:19.1-21.23
relation TypeArgument_ok: cursor typingContext |- typeArgument : typeArgumentIR # tid*

  ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:12.1-14.49
  rulegroup type {


    ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:12.1-14.49
    rule type: p TC |- typeArgument : typeIR # tid_impl*{tid_impl <- tid_impl*}
    -- if typeArgument <: type
    -- let type = typeArgument as type
    -- Type_ok: p TC |- type as typeOrVoid : typeIR # tid_impl*{tid_impl <- tid_impl*}
  }

  ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:18.1-19.29
  rulegroup void {


    ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:18.1-19.29
    rule void: p TC |- typeArgument : void as typeArgumentIR # []
    -- if (typeArgument = void as typeArgument)
  }

  ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:23.1-25.32
  rulegroup dontcare {


    ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:23.1-25.32
    rule dontcare: p TC |- typeArgument : tid tid_impl as typeArgumentIR # [tid_impl]
    -- if (typeArgument = _ as typeArgument)
    -- let tid_impl = $fresh_tid
  }

  ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:29.1-31.33
  rulegroup nonTypeName {


    ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:29.1-31.33
    rule nonTypeName: p TC |- typeArgument : tid tid as typeArgumentIR # []
    -- if typeArgument <: nonTypeName
    -- let nonTypeName = typeArgument as nonTypeName
    -- let tid = $name(nonTypeName as name)
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:23.1-25.23
relation TypeArguments_ok: cursor typingContext |- typeArgument* : typeArgumentListIR # tid*

  ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:39.1-40.27
  rulegroup nil {


    ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:39.1-40.27
    rule nil: p TC |- typeArgument*{typeArgument <- typeArgument*} : [] # []
    -- if typeArgument*{typeArgument <- typeArgument*} matches []
  }

  ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:42.1-49.47
  rulegroup cons {


    ;; ../../../../spec-concrete/5.07.1-typing-type-argument.watsup:42.1-49.47
    rule cons: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR_h :: typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*} # tid_impl*{tid_impl <- tid_impl*}
    -- if typeArgument*{typeArgument <- typeArgument*} matches _ :: _
    -- let typeArgument_h :: typeArgument_t*{typeArgument_t <- typeArgument_t*} = typeArgument*{typeArgument <- typeArgument*}
    -- TypeArgument_ok: p TC |- typeArgument_h : typeArgumentIR_h # tid_impl_h*{tid_impl_h <- tid_impl_h*}
    -- TypeArguments_ok: p TC |- typeArgument_t*{typeArgument_t <- typeArgument_t*} : typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*} # tid_impl_t*{tid_impl_t <- tid_impl_t*}
    -- let tid_impl*{tid_impl <- tid_impl*} = tid_impl_h*{tid_impl_h <- tid_impl_h*} ++ tid_impl_t*{tid_impl_t <- tid_impl_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:31.1-31.54
relation Sub_expl: typeIR <: typeIR

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:5.1-9.54
  rulegroup  {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:5.1-9.54
    rule : typeIR_a <: typeIR_b
    -- let typeIR_a_canon = $canon(typeIR_a)
    -- let typeIR_b_canon = $canon(typeIR_b)
    -- if Sub_expl_canon: typeIR_a_canon <: typeIR_b_canon holds
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:32.1-32.60
relation Sub_expl_canon: typeIR <: typeIR

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:11.1-13.38
  rulegroup equals {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:11.1-13.38
    rule equals: typeIR_a <: typeIR_b
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:15.1-18.46
  rulegroup not-equals {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:15.1-18.46
    rule not-equals: typeIR_a <: typeIR_b
    -- if ~Type_alpha: typeIR_a ~~ typeIR_b holds
    -- if Sub_expl_canon_neq: typeIR_a <: typeIR_b holds
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:33.1-33.64
relation Sub_expl_canon_neq: typeIR <: typeIR

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:24.1-25.21
  rulegroup boolean-fixbit {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:24.1-25.21
    rule boolean-fixbit: typeIR <: typeIR'
    -- if (typeIR = bool as typeIR)
    -- if (typeIR' = bit< 1 > as typeIR)
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:27.1-38.2
  rulegroup arbint {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:29.3-30.16
    rule boolean: typeIR <: typeIR'
    -- if (typeIR = int as typeIR)
    -- if (typeIR' = bool as typeIR)

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:32.3-33.22
    rule fixint: typeIR <: typeIR'
    -- if (typeIR = int as typeIR)
    -- if typeIR' <: numberTypeIR
    -- let numberTypeIR = typeIR' as numberTypeIR
    -- if numberTypeIR matches `INT<%>`
    -- let int< _nat > = numberTypeIR

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:35.3-36.22
    rule fixbit: typeIR <: typeIR'
    -- if (typeIR = int as typeIR)
    -- if typeIR' <: numberTypeIR
    -- let numberTypeIR = typeIR' as numberTypeIR
    -- if numberTypeIR matches `BIT<%>`
    -- let bit< _nat > = numberTypeIR
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:40.1-51.2
  rulegroup fixint {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:42.3-43.22
    rule arbint: typeIR <: typeIR'
    -- if typeIR <: numberTypeIR
    -- let numberTypeIR = typeIR as numberTypeIR
    -- if numberTypeIR matches `INT<%>`
    -- let int< _nat > = numberTypeIR
    -- if (typeIR' = int as typeIR)

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:45.3-46.33
    rule fixint: typeIR <: typeIR'
    -- if typeIR <: numberTypeIR
    -- let numberTypeIR = typeIR as numberTypeIR
    -- if numberTypeIR matches `INT<%>`
    -- let int< w_a > = numberTypeIR
    -- if typeIR' <: numberTypeIR
    -- let numberTypeIR' = typeIR' as numberTypeIR
    -- if numberTypeIR' matches `INT<%>`
    -- let int< w_b > = numberTypeIR'

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:48.3-49.29
    rule fixbit: typeIR <: typeIR'
    -- if typeIR <: numberTypeIR
    -- let numberTypeIR = typeIR as numberTypeIR
    -- if numberTypeIR matches `INT<%>`
    -- let int< w > = numberTypeIR
    -- if typeIR' <: numberTypeIR
    -- let numberTypeIR' = typeIR' as numberTypeIR
    -- if numberTypeIR' matches `BIT<%>`
    -- let bit< w' > = numberTypeIR'
    -- if (w = w')
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:53.1-67.2
  rulegroup fixbit {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:55.3-56.23
    rule boolean: typeIR <: typeIR'
    -- if (typeIR = bit< 1 > as typeIR)
    -- if (typeIR' = bool as typeIR)

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:58.3-59.22
    rule arbint: typeIR <: typeIR'
    -- if typeIR <: numberTypeIR
    -- let numberTypeIR = typeIR as numberTypeIR
    -- if numberTypeIR matches `BIT<%>`
    -- let bit< _nat > = numberTypeIR
    -- if (typeIR' = int as typeIR)

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:61.3-62.29
    rule fixint: typeIR <: typeIR'
    -- if typeIR <: numberTypeIR
    -- let numberTypeIR = typeIR as numberTypeIR
    -- if numberTypeIR matches `BIT<%>`
    -- let bit< w > = numberTypeIR
    -- if typeIR' <: numberTypeIR
    -- let numberTypeIR' = typeIR' as numberTypeIR
    -- if numberTypeIR' matches `INT<%>`
    -- let int< w' > = numberTypeIR'
    -- if (w = w')

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:64.3-65.33
    rule fixbit: typeIR <: typeIR'
    -- if typeIR <: numberTypeIR
    -- let numberTypeIR = typeIR as numberTypeIR
    -- if numberTypeIR matches `BIT<%>`
    -- let bit< w_a > = numberTypeIR
    -- if typeIR' <: numberTypeIR
    -- let numberTypeIR' = typeIR' as numberTypeIR
    -- if numberTypeIR' matches `BIT<%>`
    -- let bit< w_b > = numberTypeIR'
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:69.1-79.2
  rulegroup newtype {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:71.3-73.38
    rule left: typeIR <: typeIR_b
    -- if typeIR <: aliasTypeIR
    -- let aliasTypeIR = typeIR as aliasTypeIR
    -- if aliasTypeIR matches `TYPE%%`
    -- let type _tid typeIR_a = aliasTypeIR
    -- if Sub_impl: typeIR_a <: typeIR_b holds

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:75.3-77.38
    rule right: typeIR_a <: typeIR
    -- if typeIR <: aliasTypeIR
    -- let aliasTypeIR = typeIR as aliasTypeIR
    -- if aliasTypeIR matches `TYPE%%`
    -- let type _tid typeIR_b = aliasTypeIR
    -- if Sub_impl: typeIR_a <: typeIR_b holds
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:81.1-91.2
  rulegroup serenum {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:83.3-85.38
    rule left: typeIR <: typeIR_b
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum _tid # typeIR_a { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
    -- if Sub_impl: typeIR_a <: typeIR_b holds

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:87.3-89.38
    rule right: typeIR_a <: typeIR
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum _tid # typeIR_b { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
    -- if Sub_impl: typeIR_a <: typeIR_b holds
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:93.1-95.41
  rulegroup default {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:93.1-95.41
    rule default: typeIR <: typeIR_b
    -- if (typeIR = default as typeIR)
    -- if $is_defaultable_typeIR(typeIR_b)
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:97.1-104.2
  rulegroup invalidheader {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:99.3-100.38
    rule header: typeIR <: typeIR'
    -- if (typeIR = header_invalid as typeIR)
    -- if typeIR' <: headerTypeIR
    -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR' as headerTypeIR

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:102.3-103.44
    rule headerunion: typeIR <: typeIR'
    -- if (typeIR = header_invalid as typeIR)
    -- if typeIR' <: headerUnionTypeIR
    -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR' as headerUnionTypeIR
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:106.1-129.2
  rulegroup seq {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:108.3-110.41
    rule list: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: listTypeIR
    -- let list< typeIR_b > = typeIR' as listTypeIR
    -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:112.3-114.41
    rule tuple: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: tupleTypeIR
    -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as tupleTypeIR
    -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:116.3-119.41
    rule headerstack: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR_b [ n_size ] = typeIR' as headerStackTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)
    -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:121.3-123.41
    rule struct: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
    -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:125.3-127.41
    rule header: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
    -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:131.1-163.2
  rulegroup seqdefault {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:133.3-139.52
    rule tuple: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
    -- if typeIR' <: tupleTypeIR
    -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as tupleTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
    -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
    -- (if Sub_expl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:141.3-145.43
    rule headerstack: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR_b [ n_size ] = typeIR' as headerStackTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)
    -- (if Sub_expl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}
    -- if $is_defaultable_typeIR(typeIR_b)

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:147.3-153.52
    rule struct: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
    -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
    -- (if Sub_expl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:155.3-161.52
    rule header: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
    -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
    -- (if Sub_expl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:165.1-185.2
  rulegroup record {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:167.3-174.57
    rule struct: typeIR <: typeIR'
    -- if typeIR <: recordTypeIR
    -- let recordTypeIR = typeIR as recordTypeIR
    -- if recordTypeIR matches `RECORD{%}`
    -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} } = recordTypeIR
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
    -- if $eq_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
    -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
    -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
    -- (if Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:176.3-183.57
    rule header: typeIR <: typeIR'
    -- if typeIR <: recordTypeIR
    -- let recordTypeIR = typeIR as recordTypeIR
    -- if recordTypeIR matches `RECORD{%}`
    -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} } = recordTypeIR
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
    -- if $eq_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
    -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
    -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
    -- (if Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:187.1-219.2
  rulegroup recorddefault {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:189.3-202.52
    rule struct: typeIR <: typeIR'
    -- if typeIR <: recordTypeIR
    -- let recordTypeIR = typeIR as recordTypeIR
    -- if recordTypeIR matches `RECORD{%,...}`
    -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
    -- if $sub_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
    -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
    -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- (if Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- let { id_default*{id_default <- id_default*} } = $diff_set<id>({ id_b*{id_b <- id_b*} }, { id_a*{id_a <- id_a*} })
    -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
    -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
    -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:204.3-217.52
    rule header: typeIR <: typeIR'
    -- if typeIR <: recordTypeIR
    -- let recordTypeIR = typeIR as recordTypeIR
    -- if recordTypeIR matches `RECORD{%,...}`
    -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
    -- if $sub_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
    -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
    -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- (if Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- let { id_default*{id_default <- id_default*} } = $diff_set<id>({ id_b*{id_b <- id_b*} }, { id_a*{id_a <- id_a*} })
    -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
    -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
    -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:221.1-232.2
  rulegroup set {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:223.3-225.38
    rule set: typeIR' <: typeIR'''
    -- if typeIR' <: setTypeIR
    -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_a] = typeIR*{typeIR <- typeIR*}
    -- if typeIR''' <: setTypeIR
    -- let set< typeIR''*{typeIR'' <- typeIR''*} > = typeIR''' as setTypeIR
    -- if typeIR''*{typeIR'' <- typeIR''*} matches [ _/1 ]
    -- let [typeIR_b] = typeIR''*{typeIR'' <- typeIR''*}
    -- if Sub_expl: typeIR_a <: typeIR_b holds

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:227.3-230.38
    rule non-set: typeIR_a <: typeIR'
    -- if typeIR' <: setTypeIR
    -- let set< typeIR*{typeIR <- typeIR*} > = typeIR' as setTypeIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_b] = typeIR*{typeIR <- typeIR*}
    -- if ~$is_set_typeIR(typeIR_a)
    -- if Sub_expl: typeIR_a <: typeIR_b holds
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:35.1-35.54
relation Sub_impl: typeIR <: typeIR

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:238.1-242.54
  rulegroup  {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:238.1-242.54
    rule : typeIR_a <: typeIR_b
    -- let typeIR_a_canon = $canon(typeIR_a)
    -- let typeIR_b_canon = $canon(typeIR_b)
    -- if Sub_impl_canon: typeIR_a_canon <: typeIR_b_canon holds
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:36.1-36.60
relation Sub_impl_canon: typeIR <: typeIR

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:244.1-246.38
  rulegroup equals {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:244.1-246.38
    rule equals: typeIR_a <: typeIR_b
    -- if Type_alpha: typeIR_a ~~ typeIR_b holds
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:248.1-251.46
  rulegroup not-equals {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:248.1-251.46
    rule not-equals: typeIR_a <: typeIR_b
    -- if ~Type_alpha: typeIR_a ~~ typeIR_b holds
    -- if Sub_impl_canon_neq: typeIR_a <: typeIR_b holds
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:37.1-37.64
relation Sub_impl_canon_neq: typeIR <: typeIR

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:257.1-265.2
  rulegroup arbint {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:259.3-260.22
    rule fixint: typeIR <: typeIR'
    -- if (typeIR = int as typeIR)
    -- if typeIR' <: numberTypeIR
    -- let numberTypeIR = typeIR' as numberTypeIR
    -- if numberTypeIR matches `INT<%>`
    -- let int< _nat > = numberTypeIR

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:262.3-263.22
    rule fixbit: typeIR <: typeIR'
    -- if (typeIR = int as typeIR)
    -- if typeIR' <: numberTypeIR
    -- let numberTypeIR = typeIR' as numberTypeIR
    -- if numberTypeIR matches `BIT<%>`
    -- let bit< _nat > = numberTypeIR
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:267.1-269.36
  rulegroup serenum-left {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:267.1-269.36
    rule serenum-left: typeIR <: typeIR_b
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum _tid # typeIR_a { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
    -- if Sub_impl: typeIR_a <: typeIR_b holds
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:271.1-273.41
  rulegroup default {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:271.1-273.41
    rule default: typeIR <: typeIR_b
    -- if (typeIR = default as typeIR)
    -- if $is_defaultable_typeIR(typeIR_b)
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:275.1-282.2
  rulegroup invalidheader {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:277.3-278.38
    rule header: typeIR <: typeIR'
    -- if (typeIR = header_invalid as typeIR)
    -- if typeIR' <: headerTypeIR
    -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR' as headerTypeIR

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:280.3-281.44
    rule headerunion: typeIR <: typeIR'
    -- if (typeIR = header_invalid as typeIR)
    -- if typeIR' <: headerUnionTypeIR
    -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR' as headerUnionTypeIR
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:284.1-311.2
  rulegroup seq {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:286.3-288.41
    rule list: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: listTypeIR
    -- let list< typeIR_b > = typeIR' as listTypeIR
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:290.3-292.41
    rule tuple: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: tupleTypeIR
    -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as tupleTypeIR
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:294.3-297.41
    rule headerstack: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR_b [ n_size ] = typeIR' as headerStackTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:299.3-301.41
    rule struct: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:303.3-305.41
    rule header: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:307.3-309.41
    rule seq: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} > = sequenceTypeIR
    -- if typeIR' <: sequenceTypeIR
    -- let sequenceTypeIR' = typeIR' as sequenceTypeIR
    -- if sequenceTypeIR' matches `SEQ<%>`
    -- let seq< typeIR_b*{typeIR_b <- typeIR_b*} > = sequenceTypeIR'
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:313.1-345.2
  rulegroup seqdefault {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:315.3-321.52
    rule tuple: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
    -- if typeIR' <: tupleTypeIR
    -- let tuple< typeIR_b*{typeIR_b <- typeIR_b*} > = typeIR' as tupleTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
    -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
    -- (if Sub_impl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:323.3-327.43
    rule stack: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR_b [ n_size ] = typeIR' as headerStackTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)
    -- (if Sub_impl: typeIR_a <: typeIR_b holds)*{typeIR_a <- typeIR_a*}
    -- if $is_defaultable_typeIR(typeIR_b)

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:329.3-335.52
    rule struct: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
    -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
    -- (if Sub_impl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:337.3-343.52
    rule header: typeIR <: typeIR'
    -- if typeIR <: sequenceTypeIR
    -- let sequenceTypeIR = typeIR as sequenceTypeIR
    -- if sequenceTypeIR matches `SEQ<%,...>`
    -- let seq< typeIR_a*{typeIR_a <- typeIR_a*} ,...> = sequenceTypeIR
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR_b _id ;*{_id <- _id*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
    -- if (|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)
    -- let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) = $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|)
    -- (if Sub_impl: typeIR_a <: typeIR_b_non_default holds)*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:347.1-367.2
  rulegroup record {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:349.3-356.57
    rule struct: typeIR <: typeIR'
    -- if typeIR <: recordTypeIR
    -- let recordTypeIR = typeIR as recordTypeIR
    -- if recordTypeIR matches `RECORD{%}`
    -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} } = recordTypeIR
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
    -- if $eq_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
    -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
    -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
    -- (if Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:358.3-365.57
    rule header: typeIR <: typeIR'
    -- if typeIR <: recordTypeIR
    -- let recordTypeIR = typeIR as recordTypeIR
    -- if recordTypeIR matches `RECORD{%}`
    -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} } = recordTypeIR
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
    -- if $eq_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
    -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
    -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_b_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}
    -- (if Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}
  }

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:369.1-401.2
  rulegroup recorddefault {


    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:371.3-384.52
    rule struct: typeIR <: typeIR'
    -- if typeIR <: recordTypeIR
    -- let recordTypeIR = typeIR as recordTypeIR
    -- if recordTypeIR matches `RECORD{%,...}`
    -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as structTypeIR
    -- if $sub_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
    -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
    -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- (if Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- let { id_default*{id_default <- id_default*} } = $diff_set<id>({ id_b*{id_b <- id_b*} }, { id_a*{id_a <- id_a*} })
    -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
    -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
    -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}

    ;; ../../../../spec-concrete/5.05.2-subtype.watsup:386.3-399.52
    rule header: typeIR <: typeIR'
    -- if typeIR <: recordTypeIR
    -- let recordTypeIR = typeIR as recordTypeIR
    -- if recordTypeIR matches `RECORD{%,...}`
    -- let record{ typeIR_a id_a ;*{id_a <- id_a*, typeIR_a <- typeIR_a*} ,...} = recordTypeIR
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR_b id_b ;*{id_b <- id_b*, typeIR_b <- typeIR_b*} } = typeIR' as headerTypeIR
    -- if $sub_set<id>({ id_a*{id_a <- id_a*} }, { id_b*{id_b <- id_b*} })
    -- (let typeIR''?{typeIR'' <- typeIR''?} = $find_map<id, typeIR>({ id_a : typeIR_a*{id_a <- id_a*, typeIR_a <- typeIR_a*} }, id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}
    -- (if typeIR''?{typeIR'' <- typeIR''?} matches (_))*{typeIR''? <- typeIR''?*}
    -- (let ?(typeIR_a_aligned) = typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}
    -- (let typeIR'''?{typeIR''' <- typeIR'''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}
    -- (if typeIR'''?{typeIR''' <- typeIR'''?} matches (_))*{typeIR'''? <- typeIR'''?*}
    -- (let ?(typeIR_b_non_default_aligned) = typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- (if Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds)*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}
    -- let { id_default*{id_default <- id_default*} } = $diff_set<id>({ id_b*{id_b <- id_b*} }, { id_a*{id_a <- id_a*} })
    -- (let typeIR''''?{typeIR'''' <- typeIR''''?} = $find_map<id, typeIR>({ id_b : typeIR_b*{id_b <- id_b*, typeIR_b <- typeIR_b*} }, id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}
    -- (if typeIR''''?{typeIR'''' <- typeIR''''?} matches (_))*{typeIR''''? <- typeIR''''?*}
    -- (let ?(typeIR_b_default) = typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}
    -- (if $is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:43.1-45.23
relation Expr_ok: cursor typingContext |- expression : typedExpressionIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:12.1-22.2
  rulegroup literalExpression-boolean {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:14.3-16.44
    rule true: p TC |- expression : true as expressionIR # expressionNoteIR
    -- if (expression = true as expression)
    -- let expressionNoteIR = ( bool as typeIR lctk )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:18.3-20.44
    rule false: p TC |- expression : false as expressionIR # expressionNoteIR
    -- if (expression = false as expression)
    -- let expressionNoteIR = ( bool as typeIR lctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:26.1-40.2
  rulegroup literalExpression-number {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:28.3-30.43
    rule literalExpression-number-arbint: p TC |- expression : d i as expressionIR # expressionNoteIR
    -- if expression <: numberLiteral
    -- let numberLiteral = expression as numberLiteral
    -- if numberLiteral matches `D%`
    -- let d i = numberLiteral
    -- let expressionNoteIR = ( int as typeIR lctk )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:32.3-34.52
    rule literalExpression-number-fixint: p TC |- expression : n s i as expressionIR # expressionNoteIR
    -- if expression <: numberLiteral
    -- let numberLiteral = expression as numberLiteral
    -- if numberLiteral matches `%S%`
    -- let n s i = numberLiteral
    -- let expressionNoteIR = ( int< n > as typeIR lctk )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:36.3-38.52
    rule literalExpression-number-fixbit: p TC |- expression : n w i as expressionIR # expressionNoteIR
    -- if expression <: numberLiteral
    -- let numberLiteral = expression as numberLiteral
    -- if numberLiteral matches `%W%`
    -- let n w i = numberLiteral
    -- let expressionNoteIR = ( bit< n > as typeIR lctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:44.1-46.44
  rulegroup literalExpression-stringliteral {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:44.1-46.44
    rule literalExpression-stringliteral: p TC |- expression : " text " as expressionIR # expressionNoteIR
    -- if expression <: stringLiteral
    -- let " text " = expression as stringLiteral
    -- let expressionNoteIR = ( string as typeIR lctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:54.1-68.2
  rulegroup referenceExpression {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:56.3-60.45
    rule prefixedNonTypeName: p TC |- expression : prefixedNameIR as expressionIR # expressionNoteIR
    -- if expression <: prefixedNonTypeName
    -- let prefixedNonTypeName = expression as prefixedNonTypeName
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedNameIR)
    -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
    -- let ?(_direction typeIR ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
    -- let expressionNoteIR = ( typeIR ctk )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:62.3-66.45
    rule this: p TC |- expression : prefixedNameIR as expressionIR # expressionNoteIR
    -- if (expression = this as expression)
    -- let prefixedNameIR = ` "this"
    -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedNameIR)
    -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
    -- let ?(_direction typeIR ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
    -- let expressionNoteIR = ( typeIR ctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:72.1-74.45
  rulegroup defaultExpression {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:72.1-74.45
    rule defaultExpression: p TC |- expression : ... as expressionIR # expressionNoteIR
    -- if (expression = ... as expression)
    -- let expressionNoteIR = ( default as typeIR lctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:88.1-97.58
  rulegroup unaryExpression-lnot {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:88.1-97.58
    rule unaryExpression-lnot: p TC |- expression' : ! typedExpressionIR_reduced as expressionIR # expressionNoteIR
    -- if expression' <: unaryExpression
    -- let unop expression = expression' as unaryExpression
    -- if unop matches `!`
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_lnot)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    -- let _expressionIR # expressionNoteIR = typedExpressionIR_reduced
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:110.1-119.58
  rulegroup unaryExpression-bnot {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:110.1-119.58
    rule unaryExpression-bnot: p TC |- expression' : ~ typedExpressionIR_reduced as expressionIR # expressionNoteIR
    -- if expression' <: unaryExpression
    -- let unop expression = expression' as unaryExpression
    -- if unop matches `~`
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_bnot)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    -- let _expressionIR # expressionNoteIR = typedExpressionIR_reduced
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:133.1-143.58
  rulegroup unaryExpression-uplusminus {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:133.1-143.58
    rule unaryExpression-uplusminus: p TC |- expression' : unop typedExpressionIR_reduced as expressionIR # expressionNoteIR
    -- if expression' <: unaryExpression
    -- let unop expression = expression' as unaryExpression
    -- if ((unop = +) \/ (unop = -))
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR, $compat_uplusminus)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    -- let _expressionIR # expressionNoteIR = typedExpressionIR_reduced
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:160.1-182.59
  rulegroup binaryExpression-plusminusmult {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:160.1-182.59
    rule binaryExpression-plusminusmult: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
    -- if binop <- [+, -, *]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_plusminusmult)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:196.1-218.59
  rulegroup binaryExpression-satplusminus {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:196.1-218.59
    rule binaryExpression-satplusminus: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
    -- if binop <- [|+|, |-|]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_satplusminus)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:231.1-289.2
  rulegroup binaryExpression-divmod {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:233.3-260.61
    rule rhs-lctk: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
    -- if binop <- [/, %]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if (ctk_r_reduced = lctk)
    -- Eval_static: p TC |- typedExpressionIR_r_reduced ~> value_r
    -- let int = $to_number(value_r)
    -- if int <: nat
    -- let n_r = int as nat
    -- if (n_r > 0)
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:262.3-287.61
    rule rhs-non-lctk: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
    -- if binop <- [/, %]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if (ctk_r_reduced =/= lctk)
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:310.1-362.2
  rulegroup binaryExpression-shift {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:312.3-334.63
    rule rhs-fixbit: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
    -- if binop <- [<<, >>]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let _expressionIR # ( typeIR_l_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( typeIR_r_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if $is_fixed_bit_typeIR(typeIR_r_reduced)
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_l_reduced ctk_reduced )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:336.3-360.63
    rule rhs-non-fixbit: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
    -- if binop <- [<<, >>]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let _expressionIR # ( typeIR_l_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( typeIR_r_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if (ctk_r_reduced = lctk)
    -- if ($is_arbitrary_int_typeIR(typeIR_r_reduced) \/ $is_fixed_int_typeIR(typeIR_r_reduced))
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_l_reduced ctk_reduced )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:366.1-384.46
  rulegroup binaryExpression-eq {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:366.1-384.46
    rule binaryExpression-eq: p TC |- expression : typedExpressionIR_l_cast binop typedExpressionIR_r_cast as expressionIR # expressionNoteIR
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
    -- if binop <- [==, !=]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let _expressionIR # ( typeIR_cast ctk_l_cast ) = typedExpressionIR_l_cast
    -- let _expressionIR' # ( _typeIR ctk_r_cast ) = typedExpressionIR_r_cast
    -- if $is_equalable_typeIR(typeIR_cast)
    -- let ctk_cast = $join_ctk(ctk_l_cast, ctk_r_cast)
    -- let expressionNoteIR = ( bool as typeIR ctk_cast )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:399.1-421.49
  rulegroup binaryExpression-compare {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:399.1-421.49
    rule binaryExpression-compare: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
    -- if binop <- [<=, >=, <, >]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_compare)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( bool as typeIR ctk_reduced )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:435.1-457.59
  rulegroup binaryExpression-bitwise {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:435.1-457.59
    rule binaryExpression-bitwise: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
    -- if binop <- [&, ^, |]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_bitwise)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:485.1-507.59
  rulegroup binaryExpression-concat {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:485.1-507.59
    rule binaryExpression-concat: p TC |- expression : typedExpressionIR_l_reduced ++ typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
    -- if binop matches `++`
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_concat)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let _expressionIR # ( typeIR_l_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( typeIR_r_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- let typeIR?{typeIR <- typeIR?} = $result_concat(typeIR_l_reduced, typeIR_r_reduced)
    -- if typeIR?{typeIR <- typeIR?} matches (_)
    -- let ?(typeIR_reduced) = typeIR?{typeIR <- typeIR?}
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:520.1-542.59
  rulegroup binaryExpression-logical {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:520.1-542.59
    rule binaryExpression-logical: p TC |- expression : typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced as expressionIR # expressionNoteIR
    -- if expression <: binaryExpression
    -- let expression_l binop expression_r = expression as binaryExpression
    -- if binop <- [&&, ||]
    -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_logical)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( _typeIR ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- let ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
    -- let expressionNoteIR = ( typeIR_reduced ctk_reduced )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:548.1-569.48
  rulegroup ternaryExpression {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:548.1-569.48
    rule ternaryExpression: p TC |- expression : typedExpressionIR_cond ? typedExpressionIR_true_cast : typedExpressionIR_false_cast as expressionIR # expressionNoteIR
    -- if expression <: ternaryExpression
    -- let expression_cond ? expression_true : expression_false = expression as ternaryExpression
    -- Expr_ok: p TC |- expression_cond : typedExpressionIR_cond
    -- let _expressionIR # ( typeIR ctk_cond ) = typedExpressionIR_cond
    -- if (typeIR = bool as typeIR)
    -- Expr_ok: p TC |- expression_true : typedExpressionIR_true
    -- Expr_ok: p TC |- expression_false : typedExpressionIR_false
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_true, typedExpressionIR_false)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_true_cast, typedExpressionIR_false_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let _expressionIR' # ( typeIR_cast ctk_true_cast ) = typedExpressionIR_true_cast
    -- let _expressionIR'' # ( _typeIR ctk_false_cast ) = typedExpressionIR_false_cast
    -- if ($is_arbitrary_int_typeIR(typeIR_cast) => (ctk_cond =/= dyn))
    -- let ctk = $joins_ctk([ctk_cond, ctk_true_cast, ctk_false_cast])
    -- let expressionNoteIR = ( typeIR_cast ctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:574.1-587.45
  rulegroup castExpression {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:574.1-587.45
    rule castExpression: p TC |- expression' : ( typeIR_t ) typedExpressionIR as expressionIR # expressionNoteIR
    -- if expression' <: castExpression
    -- let ( type_t ) expression = expression' as castExpression
    -- Type_ok: p TC |- type_t as typeOrVoid : typeIR_t # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(p, TC) |- typeIR_t holds
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
    -- if Sub_expl: typeIR <: typeIR_t holds
    -- let expressionNoteIR = ( typeIR_t ctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:594.1-596.52
  rulegroup dataExpression-invalid {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:594.1-596.52
    rule dataExpression-invalid: p TC |- expression : {#} as expressionIR # expressionNoteIR
    -- if (expression = {#} as expression)
    -- let expressionNoteIR = ( header_invalid as typeIR lctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:604.1-640.2
  rulegroup dataExpression-sequenceElementExpression {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:606.3-620.45
    rule non-default: p TC |- expression : seq{ typedExpressionIR_e*{typedExpressionIR_e <- typedExpressionIR_e*} } as expressionIR # expressionNoteIR
    -- if expression <: dataExpression
    -- let dataExpression = expression as dataExpression
    -- if dataExpression matches `{%%}`
    -- let { dataElementExpression _trailingCommaOpt } = dataExpression
    -- if dataElementExpression <: expressionList
    -- let expressionList = dataElementExpression as expressionList
    -- let expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList)
    -- if ~... as expression <- expression_e*{expression_e <- expression_e*}
    -- if (expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList))
    -- (Expr_ok: p TC |- expression_e : typedExpressionIR_e)*{expression_e <- expression_e*, typedExpressionIR_e <- typedExpressionIR_e*}
    -- (let _expressionIR # ( typeIR_e ctk_e ) = typedExpressionIR_e)*{_expressionIR <- _expressionIR*, ctk_e <- ctk_e*, typeIR_e <- typeIR_e*, typedExpressionIR_e <- typedExpressionIR_e*}
    -- let typeIR = seq< typeIR_e*{typeIR_e <- typeIR_e*} > as typeIR
    -- let ctk = $joins_ctk(ctk_e*{ctk_e <- ctk_e*})
    -- let expressionNoteIR = ( typeIR ctk )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:622.3-638.45
    rule default: p TC |- expression : seq{ typedExpressionIR_e_h*{typedExpressionIR_e_h <- typedExpressionIR_e_h*} ,...} as expressionIR # expressionNoteIR
    -- if expression <: dataExpression
    -- let dataExpression = expression as dataExpression
    -- if dataExpression matches `{%%}`
    -- let { dataElementExpression _trailingCommaOpt } = dataExpression
    -- if dataElementExpression <: expressionList
    -- let expressionList = dataElementExpression as expressionList
    -- let expression_e*{expression_e <- expression_e*} = $flatten_expressionList(expressionList)
    -- if ... as expression <- expression_e*{expression_e <- expression_e*}
    -- let expression''*{expression'' <- expression''*} = $rev_<expression>(expression_e*{expression_e <- expression_e*})
    -- if expression''*{expression'' <- expression''*} matches _ :: _
    -- let expression' :: expression_e_h_rev*{expression_e_h_rev <- expression_e_h_rev*} = expression''*{expression'' <- expression''*}
    -- if (expression' = ... as expression)
    -- let expression_e_h*{expression_e_h <- expression_e_h*} = $rev_<expression>(expression_e_h_rev*{expression_e_h_rev <- expression_e_h_rev*})
    -- if ~... as expression <- expression_e_h*{expression_e_h <- expression_e_h*}
    -- (Expr_ok: p TC |- expression_e_h : typedExpressionIR_e_h)*{expression_e_h <- expression_e_h*, typedExpressionIR_e_h <- typedExpressionIR_e_h*}
    -- (let _expressionIR # ( typeIR_e_h ctk_e_h ) = typedExpressionIR_e_h)*{_expressionIR <- _expressionIR*, ctk_e_h <- ctk_e_h*, typeIR_e_h <- typeIR_e_h*, typedExpressionIR_e_h <- typedExpressionIR_e_h*}
    -- let typeIR = seq< typeIR_e_h*{typeIR_e_h <- typeIR_e_h*} ,...> as typeIR
    -- let ctk = $joins_ctk(ctk_e_h*{ctk_e_h <- ctk_e_h*})
    -- let expressionNoteIR = ( typeIR ctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:650.1-714.2
  rulegroup dataExpression-recordElementExpression {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:652.3-663.47
    rule single-non-default: p TC |- expression : record{ [nameIR_f = typedExpressionIR_f] } as expressionIR # expressionNoteIR
    -- if expression <: dataExpression
    -- let dataExpression = expression as dataExpression
    -- if dataExpression matches `{%%}`
    -- let { dataElementExpression _trailingCommaOpt } = dataExpression
    -- if dataElementExpression <: recordElementExpression
    -- let recordElementExpression = dataElementExpression as recordElementExpression
    -- if recordElementExpression matches `%=%`
    -- let name_f = expression_f = recordElementExpression
    -- let nameIR_f = $name(name_f)
    -- Expr_ok: p TC |- expression_f : typedExpressionIR_f
    -- let _expressionIR # ( typeIR_f ctk_f ) = typedExpressionIR_f
    -- let typeIR = record{ [typeIR_f nameIR_f ;] } as typeIR
    -- let expressionNoteIR = ( typeIR ctk_f )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:665.3-676.47
    rule single-default: p TC |- expression : record{ [nameIR_f = typedExpressionIR_f] ,...} as expressionIR # expressionNoteIR
    -- if expression <: dataExpression
    -- let dataExpression = expression as dataExpression
    -- if dataExpression matches `{%%}`
    -- let { dataElementExpression _trailingCommaOpt } = dataExpression
    -- if dataElementExpression <: recordElementExpression
    -- let recordElementExpression = dataElementExpression as recordElementExpression
    -- if recordElementExpression matches `%=%,...`
    -- let name_f = expression_f ,... = recordElementExpression
    -- let nameIR_f = $name(name_f)
    -- Expr_ok: p TC |- expression_f : typedExpressionIR_f
    -- let _expressionIR # ( typeIR_f ctk_f ) = typedExpressionIR_f
    -- let typeIR = record{ [typeIR_f nameIR_f ;] ,...} as typeIR
    -- let expressionNoteIR = ( typeIR ctk_f )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:678.3-694.45
    rule multiple-non-default: p TC |- expression : record{ nameIR_f = typedExpressionIR_f*{nameIR_f <- nameIR_f*, typedExpressionIR_f <- typedExpressionIR_f*} } as expressionIR # expressionNoteIR
    -- if expression <: dataExpression
    -- let dataExpression = expression as dataExpression
    -- if dataExpression matches `{%%}`
    -- let { dataElementExpression _trailingCommaOpt } = dataExpression
    -- if dataElementExpression <: recordElementExpression
    -- let recordElementExpression = dataElementExpression as recordElementExpression
    -- if recordElementExpression matches `%=%,%`
    -- let name_f_h = expression_f_h , namedExpressionList_t = recordElementExpression
    -- let name_f_t = expression_f_t*{expression_f_t <- expression_f_t*, name_f_t <- name_f_t*} = $flatten_namedExpressionList(namedExpressionList_t)
    -- let name_f*{name_f <- name_f*} = name_f_h :: name_f_t*{name_f_t <- name_f_t*}
    -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
    -- let expression_f*{expression_f <- expression_f*} = expression_f_h :: expression_f_t*{expression_f_t <- expression_f_t*}
    -- (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}
    -- (let _expressionIR # ( typeIR_f ctk_f ) = typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}
    -- let typeIR = record{ typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } as typeIR
    -- let ctk = $joins_ctk(ctk_f*{ctk_f <- ctk_f*})
    -- let expressionNoteIR = ( typeIR ctk )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:696.3-712.45
    rule multiple-default: p TC |- expression : record{ nameIR_f = typedExpressionIR_f*{nameIR_f <- nameIR_f*, typedExpressionIR_f <- typedExpressionIR_f*} ,...} as expressionIR # expressionNoteIR
    -- if expression <: dataExpression
    -- let dataExpression = expression as dataExpression
    -- if dataExpression matches `{%%}`
    -- let { dataElementExpression _trailingCommaOpt } = dataExpression
    -- if dataElementExpression <: recordElementExpression
    -- let recordElementExpression = dataElementExpression as recordElementExpression
    -- if recordElementExpression matches `%=%,%,...`
    -- let name_f_h = expression_f_h , namedExpressionList_t ,... = recordElementExpression
    -- let name_f_t = expression_f_t*{expression_f_t <- expression_f_t*, name_f_t <- name_f_t*} = $flatten_namedExpressionList(namedExpressionList_t)
    -- let name_f*{name_f <- name_f*} = name_f_h :: name_f_t*{name_f_t <- name_f_t*}
    -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
    -- let expression_f*{expression_f <- expression_f*} = expression_f_h :: expression_f_t*{expression_f_t <- expression_f_t*}
    -- (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}
    -- (let _expressionIR # ( typeIR_f ctk_f ) = typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}
    -- let typeIR = record{ typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} ,...} as typeIR
    -- let ctk = $joins_ctk(ctk_f*{ctk_f <- ctk_f*})
    -- let expressionNoteIR = ( typeIR ctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:722.1-729.43
  rulegroup accessExpression-errorAccessExpression {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:722.1-729.43
    rule accessExpression-errorAccessExpression: p TC |- expression : error. nameIR as expressionIR # expressionNoteIR
    -- if expression <: errorAccessExpression
    -- let error. member = expression as errorAccessExpression
    -- let nameIR = $name(member)
    -- let nameIR_error = "error." ++ nameIR
    -- if (error. nameIR as value = $find_value(p, TC, ` nameIR_error))
    -- let expressionNoteIR = ( error as typeIR lctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:737.1-767.2
  rulegroup accessExpression-memberAccessExpression-prefixedTypeName {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:739.3-751.51
    rule enum: p TC |- expression : type prefixedNameIR_base . nameIR as expressionIR # expressionNoteIR
    -- if expression <: memberAccessExpression
    -- let memberAccessBase . member = expression as memberAccessExpression
    -- if memberAccessBase <: prefixedTypeName
    -- let prefixedTypeName_base = memberAccessBase as prefixedTypeName
    -- let prefixedNameIR_base = $prefixedTypeName(prefixedTypeName_base)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR_base)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR_base = typeDefIR as typeIR
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%{%}`
    -- let enum _tid { nameIR_f*{nameIR_f <- nameIR_f*} } = enumTypeIR
    -- let nameIR = $name(member)
    -- if nameIR <- nameIR_f*{nameIR_f <- nameIR_f*}
    -- let expressionNoteIR = ( typeIR_base lctk )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:753.3-765.51
    rule serenum: p TC |- expression : type prefixedNameIR_base . nameIR as expressionIR # expressionNoteIR
    -- if expression <: memberAccessExpression
    -- let memberAccessBase . member = expression as memberAccessExpression
    -- if memberAccessBase <: prefixedTypeName
    -- let prefixedTypeName_base = memberAccessBase as prefixedTypeName
    -- let prefixedNameIR_base = $prefixedTypeName(prefixedTypeName_base)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(p, TC, prefixedNameIR_base)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR_base = typeDefIR as typeIR
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: enumTypeIR
    -- let enumTypeIR = typeIR as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum _tid # _typeIR { nameIR_f = _value ;*{_value <- _value*, nameIR_f <- nameIR_f*} } = enumTypeIR
    -- let nameIR = $name(member)
    -- if nameIR <- nameIR_f*{nameIR_f <- nameIR_f*}
    -- let expressionNoteIR = ( typeIR_base lctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:771.1-898.2
  rulegroup accessExpression-memberAccessExpression-expression {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:773.3-785.53
    rule headerstack-size: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . "size" as expressionIR # expressionNoteIR
    -- if expression <: memberAccessExpression
    -- let memberAccessBase . member = expression as memberAccessExpression
    -- if memberAccessBase <: expression
    -- let expression_base = memberAccessBase as expression
    -- if ("size" = $name(member))
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- let expressionNoteIR = ( bit< 32 > as typeIR lctk )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:787.3-802.52
    rule headerstack-lastIndex: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . "lastIndex" as expressionIR # expressionNoteIR
    -- if expression <: memberAccessExpression
    -- let memberAccessBase . member = expression as memberAccessExpression
    -- if memberAccessBase <: expression
    -- let expression_base = memberAccessBase as expression
    -- if ("lastIndex" = $name(member))
    -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- let expressionNoteIR = ( bit< 32 > as typeIR dyn )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:804.3-819.45
    rule headerstack-last: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . "last" as expressionIR # expressionNoteIR
    -- if expression <: memberAccessExpression
    -- let memberAccessBase . member = expression as memberAccessExpression
    -- if memberAccessBase <: expression
    -- let expression_base = memberAccessBase as expression
    -- if ("last" = $name(member))
    -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- let expressionNoteIR = ( typeIR dyn )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:821.3-836.45
    rule headerstack-next: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . "next" as expressionIR # expressionNoteIR
    -- if expression <: memberAccessExpression
    -- let memberAccessBase . member = expression as memberAccessExpression
    -- if memberAccessBase <: expression
    -- let expression_base = memberAccessBase as expression
    -- if ("next" = $name(member))
    -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- let expressionNoteIR = ( typeIR dyn )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:838.3-851.45
    rule struct: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # expressionNoteIR
    -- if expression <: memberAccessExpression
    -- let memberAccessBase . member = expression as memberAccessExpression
    -- if memberAccessBase <: expression
    -- let expression_base = memberAccessBase as expression
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as structTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let expressionNoteIR = ( typeIR dyn )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:853.3-866.45
    rule header: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # expressionNoteIR
    -- if expression <: memberAccessExpression
    -- let memberAccessBase . member = expression as memberAccessExpression
    -- if memberAccessBase <: expression
    -- let expression_base = memberAccessBase as expression
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as headerTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let expressionNoteIR = ( typeIR dyn )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:868.3-881.45
    rule headerunion: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # expressionNoteIR
    -- if expression <: memberAccessExpression
    -- let memberAccessBase . member = expression as memberAccessExpression
    -- if memberAccessBase <: expression
    -- let expression_base = memberAccessBase as expression
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerUnionTypeIR
    -- let header_union _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as headerUnionTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let expressionNoteIR = ( typeIR dyn )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:883.3-896.45
    rule tablestruct: p TC |- expression : typedExpressionIR_base as memberAccessBaseIR . nameIR as expressionIR # expressionNoteIR
    -- if expression <: memberAccessExpression
    -- let memberAccessBase . member = expression as memberAccessExpression
    -- if memberAccessBase <: expression
    -- let expression_base = memberAccessBase as expression
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: tableTypeIR
    -- let tableTypeIR = typeIR' as tableTypeIR
    -- if tableTypeIR matches `TABLE_STRUCT%{%}`
    -- let table_struct _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = tableTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let expressionNoteIR = ( typeIR dyn )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:916.1-996.2
  rulegroup indexAccessExpression-index {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:918.3-943.57
    rule tuple: p TC |- expression : typedExpressionIR_base [ typedExpressionIR_index_reduced ] as expressionIR # expressionNoteIR
    -- if expression <: indexAccessExpression
    -- let indexAccessExpression = expression as indexAccessExpression
    -- if indexAccessExpression matches `%[%]`
    -- let expression_base [ expression_index ] = indexAccessExpression
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
    -- let _expressionIR # ( typeIR_base ctk_base ) = typedExpressionIR_base
    -- let _expressionIR' # ( typeIR_index ctk_index ) = typedExpressionIR_index
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: tupleTypeIR
    -- let tuple< typeIR_e*{typeIR_e <- typeIR_e*} > = typeIR as tupleTypeIR
    -- if (ctk_index = lctk)
    -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
    -- let int = $to_number(value_index)
    -- if int <: nat
    -- let n_index = int as nat
    -- if (n_index < |typeIR_e*{typeIR_e <- typeIR_e*}|)
    -- let expressionNoteIR = ( typeIR_e*{typeIR_e <- typeIR_e*}[n_index] dyn )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:945.3-970.45
    rule headerstack-lctk: p TC |- expression : typedExpressionIR_base [ typedExpressionIR_index_reduced ] as expressionIR # expressionNoteIR
    -- if expression <: indexAccessExpression
    -- let indexAccessExpression = expression as indexAccessExpression
    -- if indexAccessExpression matches `%[%]`
    -- let expression_base [ expression_index ] = indexAccessExpression
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
    -- let _expressionIR # ( typeIR_base ctk_base ) = typedExpressionIR_base
    -- let _expressionIR' # ( typeIR_index ctk_index ) = typedExpressionIR_index
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- if (ctk_index = lctk)
    -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
    -- let int = $to_number(value_index)
    -- if int <: nat
    -- let n_index = int as nat
    -- if (n_index < n_size)
    -- let expressionNoteIR = ( typeIR dyn )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:972.3-994.45
    rule headerstack-non-lctk: p TC |- expression : typedExpressionIR_base [ typedExpressionIR_index_reduced ] as expressionIR # expressionNoteIR
    -- if expression <: indexAccessExpression
    -- let indexAccessExpression = expression as indexAccessExpression
    -- if indexAccessExpression matches `%[%]`
    -- let expression_base [ expression_index ] = indexAccessExpression
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
    -- let _expressionIR # ( typeIR_base ctk_base ) = typedExpressionIR_base
    -- let _expressionIR' # ( typeIR_index ctk_index ) = typedExpressionIR_index
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- if (ctk_index =/= lctk)
    -- let expressionNoteIR = ( typeIR dyn )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1037.1-1084.56
  rulegroup indexAccessExpression-bitslice {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1037.1-1084.56
    rule indexAccessExpression-bitslice: p TC |- expression : typedExpressionIR_base [ typedExpressionIR_hi_reduced : typedExpressionIR_lo_reduced ] as expressionIR # expressionNoteIR
    -- if expression <: indexAccessExpression
    -- let indexAccessExpression = expression as indexAccessExpression
    -- if indexAccessExpression matches `%[%:%]`
    -- let expression_base [ expression_hi : expression_lo ] = indexAccessExpression
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
    -- Expr_ok: p TC |- expression_hi : typedExpressionIR_hi
    -- Expr_ok: p TC |- expression_lo : typedExpressionIR_lo
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_base, $compat_bitslice_base)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_base_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let _expressionIR # ( typeIR_base_reduced ctk_base_reduced ) = typedExpressionIR_base_reduced
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_hi_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    -- let typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} = $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index)
    -- if typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} matches (_)
    -- let ?(typedExpressionIR_lo_reduced) = typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?}
    -- let _expressionIR' # ( typeIR_hi_reduced ctk_hi_reduced ) = typedExpressionIR_hi_reduced
    -- let _expressionIR'' # ( typeIR_lo_reduced ctk_lo_reduced ) = typedExpressionIR_lo_reduced
    -- if (ctk_hi_reduced = lctk)
    -- Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi
    -- let int = $to_number(value_hi)
    -- if int <: nat
    -- let n_hi = int as nat
    -- if (ctk_lo_reduced = lctk)
    -- Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo
    -- let int' = $to_number(value_lo)
    -- if int' <: nat
    -- let n_lo = int' as nat
    -- if $is_valid_bitslice(typeIR_base_reduced, n_lo, n_hi)
    -- let typeIR = bit< ((n_hi - n_lo) + 1) > as typeIR
    -- let expressionNoteIR = ( typeIR ctk_base_reduced )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1092.1-1148.2
  rulegroup callExpression-routineTarget {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1094.3-1117.49
    rule non-typeArgumentList: p TC |- expression : callExpressionIR as expressionIR # expressionNoteIR
    -- if expression <: callExpression
    -- let callExpression = expression as callExpression
    -- if callExpression matches `%(%)`
    -- let callTarget ( argumentList ) = callExpression
    -- if callTarget <: routineTarget
    -- let routineTarget = callTarget as routineTarget
    -- RoutineTarget_ok: p TC |- routineTarget : routineTargetIR
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- RoutineType_ok: p TC |- routineTargetIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- let tid_infer*{tid_infer <- tid_infer*} = tid_inserted*{tid_inserted <- tid_inserted*}
    -- Call_ok: p TC |- routineTypeIR < [] # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if (typeIR_ret =/= void as typeIR)
    -- let ctk = $is_static_routineTarget(routineTargetIR)
    -- let callExpressionIR = routineTargetIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let expressionNoteIR = ( typeIR_ret ctk )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1119.3-1146.49
    rule typeArgumentList: p TC |- expression : callExpressionIR as expressionIR # expressionNoteIR
    -- if expression <: callExpression
    -- let callExpression = expression as callExpression
    -- if callExpression matches `%<%>(%)`
    -- let routineTarget < realTypeArgumentList >( argumentList ) = callExpression
    -- RoutineTarget_ok: p TC |- routineTarget : routineTargetIR
    -- let realTypeArgument*{realTypeArgument <- realTypeArgument*} = $flatten_realTypeArgumentList(realTypeArgumentList)
    -- TypeArguments_ok: p TC |- realTypeArgument*{realTypeArgument <- realTypeArgument*} as typeArgument* : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
    -- Call_ok: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if (typeIR_ret =/= void as typeIR)
    -- let ctk = $is_static_routineTarget(routineTargetIR)
    -- let callExpressionIR = routineTargetIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let expressionNoteIR = ( typeIR_ret ctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1181.1-1230.2
  rulegroup callExpression-constructorTarget {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1183.3-1202.52
    rule prefixedTypeName: p TC |- expression : callExpressionIR as expressionIR # expressionNoteIR
    -- if expression <: callExpression
    -- let callExpression = expression as callExpression
    -- if callExpression matches `%(%)`
    -- let callTarget ( argumentList ) = callExpression
    -- if callTarget <: prefixedTypeName
    -- let prefixedTypeName = callTarget as prefixedTypeName
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- ConstructorType_ok: p TC |- prefixedNameIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
    -- Inst_ok: p TC anon |- constructorTypeIR < [] # tid_impl*{tid_impl <- tid_impl*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if $is_concrete_extern_object(typeIR_object)
    -- let callExpressionIR = prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} > ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let expressionNoteIR = ( typeIR_object ctk )

    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1204.3-1228.52
    rule specializedType: p TC |- expression : callExpressionIR as expressionIR # expressionNoteIR
    -- if expression <: callExpression
    -- let callExpression = expression as callExpression
    -- if callExpression matches `%(%)`
    -- let callTarget ( argumentList ) = callExpression
    -- if callTarget <: specializedType
    -- let prefixedTypeName < typeArgumentList > = callTarget as specializedType
    -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
    -- TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- ConstructorType_ok: p TC |- prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
    -- Inst_ok: p TC anon |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if $is_concrete_extern_object(typeIR_object)
    -- let callExpressionIR = prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} > ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let expressionNoteIR = ( typeIR_object ctk )
  }

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1235.1-1238.50
  rulegroup parenthesizedExpression {


    ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1235.1-1238.50
    rule parenthesizedExpression: p TC |- expression' : ( typedExpressionIR ) as expressionIR # expressionNoteIR
    -- if expression' <: parenthesizedExpression
    -- let ( expression ) = expression' as parenthesizedExpression
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- let _expressionIR # expressionNoteIR = typedExpressionIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:51.1-53.23
relation Argument_ok: cursor typingContext |- argument : argumentIR

  ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:9.1-11.53
  rulegroup expression {


    ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:9.1-11.53
    rule expression: p TC |- argument : typedExpressionIR as argumentIR
    -- if argument <: expression
    -- let expression = argument as expression
    -- Expr_ok: p TC |- expression : typedExpressionIR
  }

  ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:15.1-18.53
  rulegroup name-expression {


    ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:15.1-18.53
    rule name-expression: p TC |- argument : nameIR = typedExpressionIR
    -- if argument matches `%=%`
    -- let name = expression = argument
    -- let nameIR = $name(name)
    -- Expr_ok: p TC |- expression : typedExpressionIR
  }

  ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:22.1-24.29
  rulegroup name-dontcare {


    ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:22.1-24.29
    rule name-dontcare: p TC |- argument : nameIR =_
    -- if argument matches `%=_`
    -- let name =_ = argument
    -- let nameIR = $name(name)
  }

  ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:28.1-29.18
  rulegroup dontcare {


    ;; ../../../../spec-concrete/5.07.2-typing-argument.watsup:28.1-29.18
    rule dontcare: p TC |- argument : _
    -- if argument matches `_`
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:59.1-61.23
relation Lvalue_ok: cursor typingContext |- lvalue : typedLvalueIR

  ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:12.1-16.45
  rulegroup referenceExpression-prefixedNonTypeName {


    ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:12.1-16.45
    rule referenceExpression-prefixedNonTypeName: p TC |- lvalue : prefixedNameIR as lvalueIR #( typeIR )
    -- if lvalue <: prefixedNonTypeName
    -- let prefixedNonTypeName = lvalue as prefixedNonTypeName
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedNameIR)
    -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
    -- let ?(direction typeIR ctk value?{value <- value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
    -- if ctk matches `DYN`
    -- if value?{value <- value?} matches ()
    -- if ((direction = out) \/ (direction = inout))
  }

  ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:23.1-84.2
  rulegroup lvalue-member {


    ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:25.3-40.56
    rule headerstack-next-last: p TC |- lvalue : typedLvalueIR
    -- if lvalue matches `%.%`
    -- let lvalue_base . member = lvalue
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR
    -- let nameIR = $name(member)
    -- if ((nameIR = "next") \/ (nameIR = "last"))
    -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))
    -- let typedLvalueIR = typedLvalueIR_base . nameIR #( typeIR )

    ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:42.3-54.56
    rule struct: p TC |- lvalue : typedLvalueIR
    -- if lvalue matches `%.%`
    -- let lvalue_base . member = lvalue
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: structTypeIR
    -- let struct _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as structTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let typedLvalueIR = typedLvalueIR_base . nameIR #( typeIR )

    ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:56.3-68.56
    rule header: p TC |- lvalue : typedLvalueIR
    -- if lvalue matches `%.%`
    -- let lvalue_base . member = lvalue
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerTypeIR
    -- let header _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as headerTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let typedLvalueIR = typedLvalueIR_base . nameIR #( typeIR )

    ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:70.3-82.56
    rule headerunion: p TC |- lvalue : typedLvalueIR
    -- if lvalue matches `%.%`
    -- let lvalue_base . member = lvalue
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerUnionTypeIR
    -- let header_union _tid { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } = typeIR' as headerUnionTypeIR
    -- let nameIR = $name(member)
    -- let typeIR''?{typeIR'' <- typeIR''?} = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*})
    -- if typeIR''?{typeIR'' <- typeIR''?} matches (_)
    -- let ?(typeIR) = typeIR''?{typeIR'' <- typeIR''?}
    -- let typedLvalueIR = typedLvalueIR_base . nameIR #( typeIR )
  }

  ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:88.1-141.2
  rulegroup lvalue-expression {


    ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:90.3-115.27
    rule index-lctk: p TC |- lvalue : typedLvalueIR
    -- if lvalue matches `%[%]`
    -- let lvalue_base [ expression_index ] = lvalue
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
    -- let _expressionIR # ( typeIR_index ctk_index ) = typedExpressionIR_index
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- if (ctk_index = lctk)
    -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
    -- let int = $to_number(value_index)
    -- if int <: nat
    -- let n_index = int as nat
    -- if (n_index < n_size)
    -- let typedLvalueIR = typedLvalueIR_base [ typedExpressionIR_index_reduced ] #( typeIR )

    ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:117.3-139.27
    rule index-non-lctk: p TC |- lvalue : typedLvalueIR
    -- if lvalue matches `%[%]`
    -- let lvalue_base [ expression_index ] = lvalue
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ n_size ] = typeIR' as headerStackTypeIR
    -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
    -- let _expressionIR # ( typeIR_index ctk_index ) = typedExpressionIR_index
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_index_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- if (ctk_index =/= lctk)
    -- let typedLvalueIR = typedLvalueIR_base [ typedExpressionIR_index_reduced ] #( typeIR )
  }

  ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:145.1-186.25
  rulegroup lvalue-expression-expression {


    ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:145.1-186.25
    rule lvalue-expression-expression: p TC |- lvalue : typedLvalueIR
    -- if lvalue matches `%[%:%]`
    -- let lvalue_base [ expression_hi : expression_lo ] = lvalue
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- if $compat_bitslice_base(typeIR_base)
    -- Expr_ok: p TC |- expression_hi : typedExpressionIR_hi
    -- Expr_ok: p TC |- expression_lo : typedExpressionIR_lo
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_hi_reduced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_lo_reduced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    -- let _expressionIR # ( typeIR_hi_reduced ctk_hi_reduced ) = typedExpressionIR_hi_reduced
    -- let _expressionIR' # ( typeIR_lo_reduced ctk_lo_reduced ) = typedExpressionIR_lo_reduced
    -- if (ctk_hi_reduced = lctk)
    -- Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi
    -- let int = $to_number(value_hi)
    -- if int <: nat
    -- let n_hi = int as nat
    -- if (ctk_lo_reduced = lctk)
    -- Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo
    -- let int' = $to_number(value_lo)
    -- if int' <: nat
    -- let n_lo = int' as nat
    -- if $is_valid_bitslice(typeIR_base, n_lo, n_hi)
    -- let typeIR = bit< ((n_hi - n_lo) + 1) > as typeIR
    -- let typedLvalueIR = typedLvalueIR_base [ typedExpressionIR_hi_reduced : typedExpressionIR_lo_reduced ] #( typeIR )
  }

  ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:190.1-197.54
  rulegroup parenthesized {


    ;; ../../../../spec-concrete/5.08-typing-lvalue.watsup:190.1-197.54
    rule parenthesized: p TC |- lvalue : typedLvalueIR
    -- if lvalue matches `(%)`
    -- let ( lvalue_base ) = lvalue
    -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
    -- let _lvalueIR #( typeIR_base ) = typedLvalueIR_base
    -- let typedLvalueIR = ( typedLvalueIR_base ) #( typeIR_base )
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:67.1-69.26
relation Stmt_ok: cursor typingContext flow |- statement : typingContext flow statementIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:10.1-11.25
  rulegroup emptyStatement {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:10.1-11.25
    rule emptyStatement: p TC f |- statement : TC f ; as statementIR
    -- if (statement = ; as statement)
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:19.1-31.76
  rulegroup assignmentStatement-eq {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:19.1-31.76
    rule assignmentStatement-eq: p TC f |- statement : TC f typedLvalueIR = typedExpressionIR ; as statementIR
    -- if statement <: assignmentStatement
    -- let lvalue assignop expression ; = statement as assignmentStatement
    -- if assignop matches `=`
    -- Lvalue_ok: p TC |- lvalue : typedLvalueIR
    -- Expr_ok: p TC |- expression : typedExpressionIR
    -- let _lvalueIR #( typeIR_l ) = typedLvalueIR
    -- let _expressionIR # ( typeIR_r _ctk ) = typedExpressionIR
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR_l)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:42.1-86.2
  rulegroup callStatement {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:44.3-61.81
    rule callStatement-no-typeArgumentList: p TC f |- statement : TC f callStatementIR as statementIR
    -- if statement <: callStatement
    -- let callStatement = statement as callStatement
    -- if callStatement matches `%(%);`
    -- let lvalue_routine ( argumentList ); = callStatement
    -- RoutineTarget_lvalue_ok: p TC |- lvalue_routine : routineTargetIR
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- RoutineType_ok: p TC |- routineTargetIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
    -- Call_ok: p TC |- routineTypeIR < [] # tid_impl*{tid_impl <- tid_impl*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let callStatementIR = routineTargetIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} );

    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:63.3-84.81
    rule callStatement-typeArgumentList: p TC f |- statement : TC f callStatementIR as statementIR
    -- if statement <: callStatement
    -- let callStatement = statement as callStatement
    -- if callStatement matches `%<%>(%);`
    -- let lvalue_routine < typeArgumentList >( argumentList ); = callStatement
    -- RoutineTarget_lvalue_ok: p TC |- lvalue_routine : routineTargetIR
    -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
    -- TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
    -- Call_ok: p TC |- routineTypeIR < [] # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let callStatementIR = routineTargetIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} );
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:101.1-121.57
  rulegroup directApplicationStatement-prefixedTypeName {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:101.1-121.57
    rule directApplicationStatement-prefixedTypeName: p TC_0 f |- statement : TC_0 f directApplicationStatementIR as statementIR
    -- if statement <: directApplicationStatement
    -- let namedType .apply( argumentList ); = statement as directApplicationStatement
    -- Expr_ok: p TC_0 |- namedType as callTarget ( ) as expression : expressionIR # ( typeIR_object _ctk )
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%(%)`
    -- let prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} > ( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- if $compat_direct_application(typeIR_object)
    -- let nameIR_object = "__direct_application"
    -- let TC_1 = $add_var(p, TC_0, nameIR_object, typeIR_object ctk ?())
    -- let lvalue = nameIR_object as lvalue . "apply" as member
    -- Stmt_ok: p TC_1 f |- lvalue ( argumentList ); as statement : _typingContext _flow statementIR
    -- if statementIR <: callStatementIR
    -- let callStatementIR = statementIR as callStatementIR
    -- let routineTargetIR < typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} ); = callStatementIR
    -- if (routineTargetIR = ` nameIR_object as expressionIR # ( typeIR_object ctk ) . "apply")
    -- if typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} matches []
    -- let directApplicationStatementIR = prefixedNameIR .apply( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} );
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:129.1-150.2
  rulegroup returnStatement {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:131.3-135.39
    rule non-expression: cursor TC f |- statement : TC ret return; as statementIR
    -- if cursor matches `LOCAL`
    -- if (statement = return; as statement)
    -- if (?(void as typeIR) = $find_return_type(TC))

    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:137.3-148.80
    rule expression: cursor TC f |- statement : TC ret return typedExpressionIR_cast ; as statementIR
    -- if cursor matches `LOCAL`
    -- if statement <: returnStatement
    -- let returnStatement = statement as returnStatement
    -- if returnStatement matches `RETURN%;`
    -- let return expression ; = returnStatement
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
    -- let typeIR'?{typeIR' <- typeIR'?} = $find_return_type(TC)
    -- if typeIR'?{typeIR' <- typeIR'?} matches (_)
    -- let ?(typeIR_ret) = typeIR'?{typeIR' <- typeIR'?}
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR_ret)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:155.1-156.37
  rulegroup exitStatement {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:155.1-156.37
    rule exitStatement: p TC f |- statement : TC f exit; as statementIR
    -- if (statement = exit; as statement)
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:160.1-163.53
  rulegroup blockStatement {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:160.1-163.53
    rule blockStatement: cursor TC_0 f_0 |- statement : TC_1 f_1 blockStatementIR as statementIR
    -- if cursor matches `LOCAL`
    -- if statement <: blockStatement
    -- let blockStatement = statement as blockStatement
    -- Block_ok: TC_0 f_0 |- blockStatement : TC_1 f_1 blockStatementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:171.1-198.2
  rulegroup conditionalStatement {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:173.3-182.75
    rule non-else: p TC f |- statement : TC f if( typedExpressionIR_cond ) statementIR_then as statementIR
    -- if statement <: conditionalStatement
    -- let conditionalStatement = statement as conditionalStatement
    -- if conditionalStatement matches `IF(%)%`
    -- let if( expression_cond ) statement_then = conditionalStatement
    -- Expr_ok: p TC |- expression_cond : typedExpressionIR_cond
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR_cond
    -- if (typeIR = bool as typeIR)
    -- Stmt_ok: p TC f |- statement_then : TC_then f_then statementIR_then

    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:184.3-196.46
    rule else: p TC f |- statement : TC f_post if( typedExpressionIR_cond ) statementIR_then else statementIR_else as statementIR
    -- if statement <: conditionalStatement
    -- let conditionalStatement = statement as conditionalStatement
    -- if conditionalStatement matches `IF(%)%ELSE%`
    -- let if( expression_cond ) statement_then else statement_else = conditionalStatement
    -- Expr_ok: p TC |- expression_cond : typedExpressionIR_cond
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR_cond
    -- if (typeIR = bool as typeIR)
    -- Stmt_ok: p TC f |- statement_then : TC_then f_then statementIR_then
    -- Stmt_ok: p TC f |- statement_else : TC_else f_else statementIR_else
    -- let f_post = $join_flow(f_then, f_else)
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:286.1-303.64
  rulegroup switch-table-apply {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:286.1-303.64
    rule switch-table-apply: cursor TC f |- statement : TC f_post switchStatementIR as statementIR
    -- if cursor matches `LOCAL`
    -- if statement <: switchStatement
    -- let switch( expression_switch ){ switchCaseList } = statement as switchStatement
    -- Expr_ok: local TC |- expression_switch : typedExpressionIR_switch
    -- let _expressionIR # ( typeIR_switch _ctk ) = typedExpressionIR_switch
    -- let typeIR = $canon(typeIR_switch)
    -- if typeIR <: tableTypeIR
    -- let tableTypeIR = typeIR as tableTypeIR
    -- if tableTypeIR matches `TABLE_ENUM%{%}`
    -- let table_enum tid_table_enum { _id*{_id <- _id*} } = tableTypeIR
    -- let tid_table = $strip_prefix($strip_suffix(tid_table_enum, ")"), "action_list(")
    -- let switchCase*{switchCase <- switchCase*} = $flatten_switchCaseList(switchCaseList)
    -- SwitchCases_table_ok: TC f tid_table |- switchCase*{switchCase <- switchCase*} : f_post switchCaseIR*{switchCaseIR <- switchCaseIR*} # switchLabel*{switchLabel <- switchLabel*}
    -- if $distinct_<switchLabel>(switchLabel*{switchLabel <- switchLabel*})
    -- let switchStatementIR = switch( typedExpressionIR_switch ){ switchCaseIR*{switchCaseIR <- switchCaseIR*} }
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:390.1-406.64
  rulegroup switch-general {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:390.1-406.64
    rule switch-general: cursor TC f |- statement : TC f_post switchStatementIR as statementIR
    -- if cursor matches `LOCAL`
    -- if statement <: switchStatement
    -- let switch( expression_switch ){ switchCaseList } = statement as switchStatement
    -- Expr_ok: local TC |- expression_switch : typedExpressionIR_switch
    -- let _expressionIR # ( typeIR_switch _ctk ) = typedExpressionIR_switch
    -- if $compat_switch(typeIR_switch)
    -- let switchCase*{switchCase <- switchCase*} = $flatten_switchCaseList(switchCaseList)
    -- SwitchCases_general_ok: TC f typeIR_switch |- switchCase*{switchCase <- switchCase*} : f_post switchCaseIR*{switchCaseIR <- switchCaseIR*} # switchLabel*{switchLabel <- switchLabel*}
    -- if $distinct_<switchLabel>(switchLabel*{switchLabel <- switchLabel*})
    -- let switchStatementIR = switch( typedExpressionIR_switch ){ switchCaseIR*{switchCaseIR <- switchCaseIR*} }
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:71.1-73.26
relation Stmts_ok: cursor typingContext flow |- statement* : typingContext flow statementIR*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:75.1-78.23
relation BlockElementStmt_ok: typingContext flow |- blockElementStatement : typingContext flow blockElementStatementIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:414.1-416.77
  rulegroup constantDeclaration {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:414.1-416.77
    rule constantDeclaration: TC_0 f |- blockElementStatement : TC_1 f constantDeclarationIR as blockElementStatementIR
    -- if blockElementStatement <: constantDeclaration
    -- let constantDeclaration = blockElementStatement as constantDeclaration
    -- Decl_ok: local TC_0 |- constantDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: constantDeclarationIR
    -- let constantDeclarationIR = declarationIR as constantDeclarationIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:422.1-460.2
  rulegroup variableDeclaration {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:424.3-437.46
    rule empty: TC_0 f |- blockElementStatement : TC_1 f variableDeclarationIR as blockElementStatementIR
    -- if blockElementStatement <: variableDeclaration
    -- let annotationList type name initializerOpt ; = blockElementStatement as variableDeclaration
    -- if initializerOpt matches ``EMPTY`
    -- Type_ok: local TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(local, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(local, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?() ;

    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:439.3-458.75
    rule initializer: TC_0 f |- blockElementStatement : TC_1 f variableDeclarationIR as blockElementStatementIR
    -- if blockElementStatement <: variableDeclaration
    -- let annotationList type name initializerOpt ; = blockElementStatement as variableDeclaration
    -- if initializerOpt <: initializer
    -- let = expression_init = initializerOpt as initializer
    -- Type_ok: local TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(local, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- Expr_ok: local TC_0 |- expression_init : typedExpressionIR_init
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(local, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?(= typedExpressionIR_init_cast) ;
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:464.1-466.66
  rulegroup statement {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:464.1-466.66
    rule statement: TC_0 f |- blockElementStatement : TC_1 f_post statementIR as blockElementStatementIR
    -- if blockElementStatement <: statement
    -- let statement = blockElementStatement as statement
    -- Stmt_ok: local TC_0 f |- statement : TC_1 f_post statementIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:80.1-83.23
relation BlockElementStmts_ok: typingContext flow |- blockElementStatement* : typingContext flow blockElementStatementIR*

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:472.1-473.25
  rulegroup nil {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:472.1-473.25
    rule nil: TC f |- blockElementStatement*{blockElementStatement <- blockElementStatement*} : TC f []
    -- if blockElementStatement*{blockElementStatement <- blockElementStatement*} matches []
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:475.1-481.75
  rulegroup cons {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:475.1-481.75
    rule cons: TC_0 f_0 |- blockElementStatement*{blockElementStatement <- blockElementStatement*} : TC_2 f_2 blockElementStatementIR_h :: blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*}
    -- if blockElementStatement*{blockElementStatement <- blockElementStatement*} matches _ :: _
    -- let blockElementStatement_h :: blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} = blockElementStatement*{blockElementStatement <- blockElementStatement*}
    -- BlockElementStmt_ok: TC_0 f_0 |- blockElementStatement_h : TC_1 f_1 blockElementStatementIR_h
    -- BlockElementStmts_ok: TC_1 f_1 |- blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} : TC_2 f_2 blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:85.1-88.23
relation Block_ok: typingContext flow |- blockStatement : typingContext flow blockStatementIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:489.1-500.72
  rulegroup  {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:489.1-500.72
    rule : TC_0 f |- annotationList { blockElementStatementList } : TC_3 f_post blockStatementIR
    -- let blockElementStatement*{blockElementStatement <- blockElementStatement*} = $flatten_blockElementStatementList(blockElementStatementList)
    -- let TC_1 = $enter(TC_0)
    -- BlockElementStmts_ok: TC_1 f |- blockElementStatement*{blockElementStatement <- blockElementStatement*} : TC_2 f_post blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*}
    -- let TC_3 = $exit(TC_2)
    -- let blockStatementIR = annotationList { blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} }
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:95.1-97.23
relation Parameter_ok: cursor typingContext |- parameter : parameterIR # tid*

  ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:12.1-19.29
  rulegroup empty {


    ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:12.1-19.29
    rule empty: p TC |- annotationList direction type name initializerOpt : annotationList direction typeIR nameIR ?() # tid_fresh*{tid_fresh <- tid_fresh*}
    -- if initializerOpt matches ``EMPTY`
    -- Type_ok: p TC |- type as typeOrVoid : typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
    -- let bound = $union_set<tid>($bound(p, TC), { tid_fresh*{tid_fresh <- tid_fresh*} })
    -- if Type_wf: bound |- typeIR holds
    -- let nameIR = $name(name)
  }

  ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:23.1-41.68
  rulegroup initializer {


    ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:23.1-41.68
    rule initializer: p TC |- annotationList direction type name initializerOpt : annotationList direction typeIR nameIR ?(= value_init) # tid_fresh*{tid_fresh <- tid_fresh*}
    -- if initializerOpt <: initializer
    -- let = expression_init = initializerOpt as initializer
    -- Type_ok: p TC |- type as typeOrVoid : typeIR # tid_fresh*{tid_fresh <- tid_fresh*}
    -- let bound = $union_set<tid>($bound(p, TC), { tid_fresh*{tid_fresh <- tid_fresh*} })
    -- if Type_wf: bound |- typeIR holds
    -- Expr_ok: p TC |- expression_init : typedExpressionIR_init
    -- let _expressionIR # ( typeIR_init ctk ) = typedExpressionIR_init
    -- if ctk matches `LCTK`
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let nameIR = $name(name)
    -- Eval_static: p TC |- typedExpressionIR_init_cast ~> value_init
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:99.1-101.23
relation Parameters_ok: cursor typingContext |- parameter* : parameterListIR # tid*

  ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:49.1-50.27
  rulegroup nil {


    ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:49.1-50.27
    rule nil: p TC |- parameter*{parameter <- parameter*} : [] # []
    -- if parameter*{parameter <- parameter*} matches []
  }

  ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:52.1-56.74
  rulegroup cons {


    ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:52.1-56.74
    rule cons: p TC |- parameter*{parameter <- parameter*} : parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} # tid_fresh_h*{tid_fresh_h <- tid_fresh_h*} ++ tid_fresh_t*{tid_fresh_t <- tid_fresh_t*}
    -- if parameter*{parameter <- parameter*} matches _ :: _
    -- let parameter_h :: parameter_t*{parameter_t <- parameter_t*} = parameter*{parameter <- parameter*}
    -- Parameter_ok: p TC |- parameter_h : parameterIR_h # tid_fresh_h*{tid_fresh_h <- tid_fresh_h*}
    -- Parameters_ok: p TC |- parameter_t*{parameter_t <- parameter_t*} : parameterIR_t*{parameterIR_t <- parameterIR_t*} # tid_fresh_t*{tid_fresh_t <- tid_fresh_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:103.1-103.48
def $parameterIR(parameterIR) : parameterTypeIR =

  ;; ../../../../spec-concrete/5.04-typing-relation.watsup:104.1-105.32
  clause 0(_annotationList direction typeIR nameIR constantInitializerIR?{constantInitializerIR <- constantInitializerIR?}) = direction typeIR nameIR ?()
  -- if constantInitializerIR?{constantInitializerIR <- constantInitializerIR?} matches ()

  ;; ../../../../spec-concrete/5.04-typing-relation.watsup:106.1-107.34
  clause 1(_annotationList direction typeIR nameIR constantInitializerOptIR) = direction typeIR nameIR ?(value)
  -- if constantInitializerOptIR matches (_)
  -- let ?(= value) = constantInitializerOptIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:109.1-112.23
relation ConstructorParameter_ok: cursor typingContext |- constructorParameter : constructorParameterIR # tid*

  ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:64.1-67.64
  rulegroup  {


    ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:64.1-67.64
    rule : p TC |- constructorParameter : constructorParameterIR # tid_fresh*{tid_fresh <- tid_fresh*}
    -- Parameter_ok: p TC |- constructorParameter : constructorParameterIR # tid_fresh*{tid_fresh <- tid_fresh*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:114.1-117.23
relation ConstructorParameters_ok: cursor typingContext |- constructorParameter* : constructorParameterListIR # tid*

  ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:75.1-78.66
  rulegroup  {


    ;; ../../../../spec-concrete/5.09-typing-parameter.watsup:75.1-78.66
    rule : p TC |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid_fresh*{tid_fresh <- tid_fresh*}
    -- Parameters_ok: p TC |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid_fresh*{tid_fresh <- tid_fresh*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:119.1-119.81
def $constructorParameterIR(constructorParameterIR) : constructorParameterTypeIR =

  ;; ../../../../spec-concrete/5.04-typing-relation.watsup:120.1-121.41
  clause 0(constructorParameterIR) = $parameterIR(constructorParameterIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:127.1-129.23
relation ExternMethod_ok: typingContext tid |- methodPrototype : typingContext methodPrototypeIR

  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:9.1-39.79
  rulegroup non-abstract {


    ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:9.1-39.79
    rule non-abstract: TC_0 tid_extern |- methodPrototype : TC_4 methodPrototypeIR
    -- if methodPrototype matches `%%;`
    -- let annotationList typeOrVoid name typeParameterListOpt ( parameterList ) ; = methodPrototype
    -- let nameIR = $name(name)
    -- if (nameIR =/= tid_extern)
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(local, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- Type_ok: local TC_1 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- let TC_2 = TC_1[local.kind = extern_method-> typeIR_ret]
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: local TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_3 = $add_parameters(local, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let rid = $rid(name, parameterList)
    -- let methodTypeIR = extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
    -- let routineTypeDefIR = methodTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
    -- if RoutineTypeDef_wf: $bound(block, TC_0) |- routineTypeDefIR holds
    -- let TC_4 = $add_routine_overload(block, TC_0, rid, routineTypeDefIR)
    -- let methodPrototypeIR = annotationList typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) ;
  }

  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:43.1-73.79
  rulegroup abstract {


    ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:43.1-73.79
    rule abstract: TC_0 tid_extern |- methodPrototype : TC_4 methodPrototypeIR
    -- if methodPrototype matches `%ABSTRACT%;`
    -- let annotationList abstract typeOrVoid name typeParameterListOpt ( parameterList ) ; = methodPrototype
    -- let nameIR = $name(name)
    -- if (nameIR =/= tid_extern)
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(local, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- Type_ok: local TC_1 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- let TC_2 = TC_1[local.kind = extern_methodabstract-> typeIR_ret]
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: local TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_3 = $add_parameters(local, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let rid = $rid(name, parameterList)
    -- let methodTypeIR = extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
    -- let routineTypeDefIR = methodTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
    -- if RoutineTypeDef_wf: $bound(block, TC_0) |- routineTypeDefIR holds
    -- let TC_4 = $add_routine_overload(block, TC_0, rid, routineTypeDefIR)
    -- let methodPrototypeIR = annotationList abstract typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) ;
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:131.1-133.23
relation ExternMethods_ok: typingContext tid |- methodPrototype* : typingContext methodPrototypeIR*

  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:81.1-82.32
  rulegroup nil {


    ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:81.1-82.32
    rule nil: TC tid_extern |- methodPrototype*{methodPrototype <- methodPrototype*} : TC []
    -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []
  }

  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:84.1-90.68
  rulegroup cons {


    ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:84.1-90.68
    rule cons: TC_0 tid_extern |- methodPrototype*{methodPrototype <- methodPrototype*} : TC_2 methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
    -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
    -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
    -- ExternMethod_ok: TC_0 tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h
    -- ExternMethods_ok: TC_1 tid_extern |- methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} : TC_2 methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:135.1-137.23
relation ExternConstructor_ok: typingContext tid |- methodPrototype : typingContext methodPrototypeIR

  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:100.1-126.80
  rulegroup  {


    ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:100.1-126.80
    rule : TC_0 tid_extern |- methodPrototype : TC_1 methodPrototypeIR
    -- if methodPrototype matches `%%(%);`
    -- let annotationList typeIdentifier ( parameterList ); = methodPrototype
    -- let nameIR = $name(typeIdentifier as name)
    -- if (nameIR = tid_extern)
    -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_parameterList(parameterList)
    -- ConstructorParameters_ok: block TC_0 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(global, TC_0, ` nameIR)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: polyTypeDefIR
    -- let typeIR_extern < tid_expl*{tid_expl <- tid_expl*} , tid*{tid <- tid*} > = typeDefIR as polyTypeDefIR
    -- if tid*{tid <- tid*} matches []
    -- let cid = $cid(typeIdentifier as name, ( parameterList ))
    -- let typeIR_extern_spec = typeIR_extern < tid_expl*{tid_expl <- tid_expl*} , [] > < tid tid_expl as typeIR*{tid_expl <- tid_expl*} > as typeIR
    -- let constructorTypeIR = constructor( constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} )-> typeIR_extern_spec
    -- let constructorTypeDefIR = constructorTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >
    -- if ConstructorTypeDef_wf: $bound(block, TC_0) |- constructorTypeDefIR holds
    -- let TC_1 = $add_constructor(TC_0, cid, constructorTypeDefIR)
    -- let methodPrototypeIR = annotationList nameIR <, tid_impl*{tid_impl <- tid_impl*} >( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} );
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:139.1-141.23
relation ExternConstructors_ok: typingContext tid |- methodPrototype* : typingContext methodPrototypeIR*

  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:134.1-135.32
  rulegroup nil {


    ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:134.1-135.32
    rule nil: TC tid_extern |- methodPrototype*{methodPrototype <- methodPrototype*} : TC []
    -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []
  }

  ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:137.1-143.73
  rulegroup cons {


    ;; ../../../../spec-concrete/5.12-typing-extern-method.watsup:137.1-143.73
    rule cons: TC_0 tid_extern |- methodPrototype*{methodPrototype <- methodPrototype*} : TC_2 methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
    -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
    -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
    -- ExternConstructor_ok: TC_0 tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h
    -- ExternConstructors_ok: TC_1 tid_extern |- methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} : TC_2 methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:147.1-149.23
relation ParserTransition_ok: typingContext nameIR* |- transitionStatement : transitionStatementIR

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:11.1-15.7
  rulegroup empty {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:11.1-15.7
    rule empty: TC_0 nameIR_state*{nameIR_state <- nameIR_state*} |- transitionStatement : transition "reject" ;
    -- if transitionStatement matches ``EMPTY`
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:19.1-26.55
  rulegroup name {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:19.1-26.55
    rule name: TC_0 nameIR_state*{nameIR_state <- nameIR_state*} |- transitionStatement : transitionStatementIR
    -- if transitionStatement matches `TRANSITION%`
    -- let transition stateExpression = transitionStatement
    -- if stateExpression matches `%;`
    -- let name ; = stateExpression
    -- let nameIR = $name(name)
    -- if nameIR <- nameIR_state*{nameIR_state <- nameIR_state*}
    -- let transitionStatementIR = transition nameIR ;
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:308.1-322.75
  rulegroup switch {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:308.1-322.75
    rule switch: TC_0 nameIR_state*{nameIR_state <- nameIR_state*} |- transitionStatement : transitionStatementIR
    -- if transitionStatement matches `TRANSITION%`
    -- let transition stateExpression = transitionStatement
    -- if stateExpression <: selectExpression
    -- let select( expressionList_key ){ selectCaseList } = stateExpression as selectExpression
    -- let expression_key*{expression_key <- expression_key*} = $flatten_expressionList(expressionList_key)
    -- (Expr_ok: local TC_0 |- expression_key : typedExpressionIR_key)*{expression_key <- expression_key*, typedExpressionIR_key <- typedExpressionIR_key*}
    -- (let _expressionIR # ( typeIR_key _ctk ) = typedExpressionIR_key)*{_ctk <- _ctk*, _expressionIR <- _expressionIR*, typeIR_key <- typeIR_key*, typedExpressionIR_key <- typedExpressionIR_key*}
    -- (if Type_wf: $bound(local, TC_0) |- set< [typeIR_key] > as typeIR holds)*{typeIR_key <- typeIR_key*}
    -- let selectCase*{selectCase <- selectCase*} = $flatten_selectCaseList(selectCaseList)
    -- (SelectCase_ok: TC_0 nameIR_state*{nameIR_state <- nameIR_state*} typeIR_key*{typeIR_key <- typeIR_key*} |- selectCase : selectCaseIR)*{selectCase <- selectCase*, selectCaseIR <- selectCaseIR*}
    -- let transitionStatementIR = transition select( typedExpressionIR_key*{typedExpressionIR_key <- typedExpressionIR_key*} ){ selectCaseIR*{selectCaseIR <- selectCaseIR*} } as stateExpressionIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:151.1-153.20
relation ParserStmt_ok: typingContext |- parserStatement : typingContext parserStatementIR

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:332.1-336.55
  rulegroup constantDeclaration {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:332.1-336.55
    rule constantDeclaration: TC_0 |- parserStatement : TC_1 constantDeclarationIR as parserStatementIR
    -- if parserStatement <: constantDeclaration
    -- let constantDeclaration = parserStatement as constantDeclaration
    -- Decl_ok: local TC_0 |- constantDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: constantDeclarationIR
    -- let constantDeclarationIR = declarationIR as constantDeclarationIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:342.1-380.2
  rulegroup variableDeclaration {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:344.3-357.46
    rule empty: TC_0 |- parserStatement : TC_1 variableDeclarationIR as parserStatementIR
    -- if parserStatement <: variableDeclaration
    -- let annotationList type name initializerOpt ; = parserStatement as variableDeclaration
    -- if initializerOpt matches ``EMPTY`
    -- Type_ok: local TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(local, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(local, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?() ;

    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:359.3-378.75
    rule initializer: TC_0 |- parserStatement : TC_1 variableDeclarationIR as parserStatementIR
    -- if parserStatement <: variableDeclaration
    -- let annotationList type name initializerOpt ; = parserStatement as variableDeclaration
    -- if initializerOpt <: initializer
    -- let = expression_init = initializerOpt as initializer
    -- Type_ok: local TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(local, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- Expr_ok: local TC_0 |- expression_init : typedExpressionIR_init
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(local, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?(= typedExpressionIR_init_cast) ;
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:384.1-388.57
  rulegroup emptyStatement {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:384.1-388.57
    rule emptyStatement: TC |- parserStatement : TC emptyStatementIR as parserStatementIR
    -- if parserStatement <: emptyStatement
    -- let emptyStatement = parserStatement as emptyStatement
    -- Stmt_ok: local TC cont |- emptyStatement as statement : typingContext flow statementIR
    -- if (typingContext = TC)
    -- if flow matches `CONT`
    -- if statementIR <: emptyStatementIR
    -- let emptyStatementIR = statementIR as emptyStatementIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:392.1-396.65
  rulegroup assignmentStatement {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:392.1-396.65
    rule assignmentStatement: TC_0 |- parserStatement : TC_1 assignmentStatementIR as parserStatementIR
    -- if parserStatement <: assignmentStatement
    -- let assignmentStatement = parserStatement as assignmentStatement
    -- Stmt_ok: local TC_0 cont |- assignmentStatement as statement : TC_1 flow statementIR
    -- if flow matches `CONT`
    -- if statementIR <: assignmentStatementIR
    -- let assignmentStatementIR = statementIR as assignmentStatementIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:400.1-404.59
  rulegroup callStatement {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:400.1-404.59
    rule callStatement: TC_0 |- parserStatement : TC_1 callStatementIR as parserStatementIR
    -- if parserStatement <: callStatement
    -- let callStatement = parserStatement as callStatement
    -- Stmt_ok: local TC_0 cont |- callStatement as statement : TC_1 flow statementIR
    -- if flow matches `CONT`
    -- if statementIR <: callStatementIR
    -- let callStatementIR = statementIR as callStatementIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:408.1-412.72
  rulegroup directApplicationStatement {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:408.1-412.72
    rule directApplicationStatement: TC_0 |- parserStatement : TC_1 directApplicationStatementIR as parserStatementIR
    -- if parserStatement <: directApplicationStatement
    -- let directApplicationStatement = parserStatement as directApplicationStatement
    -- Stmt_ok: local TC_0 cont |- directApplicationStatement as statement : TC_1 flow statementIR
    -- if flow matches `CONT`
    -- if statementIR <: directApplicationStatementIR
    -- let directApplicationStatementIR = statementIR as directApplicationStatementIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:417.1-427.72
  rulegroup parserBlockStatement {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:417.1-427.72
    rule parserBlockStatement: TC_0 |- parserStatement' : TC_1 parserBlockStatementIR as parserStatementIR
    -- if parserStatement' <: parserBlockStatement
    -- let annotationList { parserStatementList } = parserStatement' as parserBlockStatement
    -- let parserStatement*{parserStatement <- parserStatement*} = $flatten_parserStatementList(parserStatementList)
    -- let TC_1 = $enter(TC_0)
    -- ParserStmts_ok: TC_1 |- parserStatement*{parserStatement <- parserStatement*} : TC_2 parserStatementIR*{parserStatementIR <- parserStatementIR*}
    -- let TC_3 = $exit(TC_2)
    -- let parserBlockStatementIR = annotationList { parserStatementIR*{parserStatementIR <- parserStatementIR*} }
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:431.1-435.66
  rulegroup conditionalStatement {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:431.1-435.66
    rule conditionalStatement: TC_0 |- parserStatement : TC_1 conditionalStatementIR as parserStatementIR
    -- if parserStatement <: conditionalStatement
    -- let conditionalStatement = parserStatement as conditionalStatement
    -- Stmt_ok: local TC_0 cont |- conditionalStatement as statement : TC_1 flow statementIR
    -- if flow matches `CONT`
    -- if statementIR <: conditionalStatementIR
    -- let conditionalStatementIR = statementIR as conditionalStatementIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:155.1-157.20
relation ParserStmts_ok: typingContext |- parserStatement* : typingContext parserStatementIR*

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:443.1-444.21
  rulegroup nil {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:443.1-444.21
    rule nil: TC |- parserStatement*{parserStatement <- parserStatement*} : TC []
    -- if parserStatement*{parserStatement <- parserStatement*} matches []
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:446.1-452.55
  rulegroup cons {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:446.1-452.55
    rule cons: TC_0 |- parserStatement*{parserStatement <- parserStatement*} : TC_2 parserStatementIR_h :: parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*}
    -- if parserStatement*{parserStatement <- parserStatement*} matches _ :: _
    -- let parserStatement_h :: parserStatement_t*{parserStatement_t <- parserStatement_t*} = parserStatement*{parserStatement <- parserStatement*}
    -- ParserStmt_ok: TC_0 |- parserStatement_h : TC_1 parserStatementIR_h
    -- ParserStmts_ok: TC_1 |- parserStatement_t*{parserStatement_t <- parserStatement_t*} : TC_2 parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:159.1-161.23
relation ParserState_ok: typingContext nameIR* |- parserState : parserStateIR

  ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:8.1-26.82
  rulegroup  {


    ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:8.1-26.82
    rule : TC_0 nameIR_state*{nameIR_state <- nameIR_state*} |- annotationList state name { parserStatementList transitionStatement } : parserStateIR
    -- let nameIR = $name(name)
    -- let TC_1 = $enter(TC_0)
    -- let parserStatement*{parserStatement <- parserStatement*} = $flatten_parserStatementList(parserStatementList)
    -- ParserStmts_ok: TC_1 |- parserStatement*{parserStatement <- parserStatement*} : TC_2 parserStatementIR*{parserStatementIR <- parserStatementIR*}
    -- ParserTransition_ok: TC_2 nameIR_state*{nameIR_state <- nameIR_state*} |- transitionStatement : transitionStatementIR
    -- let TC_3 = $exit(TC_2)
    -- let parserStateIR = annotationList state nameIR { parserStatementIR*{parserStatementIR <- parserStatementIR*} transitionStatementIR }
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:163.1-165.20
relation ParserStates_ok: typingContext |- parserState* : parserStateIR*

  ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:34.1-46.77
  rulegroup  {


    ;; ../../../../spec-concrete/5.13.2-typing-parser-state.watsup:34.1-46.77
    rule : TC |- parserState*{parserState <- parserState*} : parserStateIR*{parserStateIR <- parserStateIR*}
    -- (let _annotationList state name_state { _parserStatementList _transitionStatement } = parserState)*{_annotationList <- _annotationList*, _parserStatementList <- _parserStatementList*, _transitionStatement <- _transitionStatement*, name_state <- name_state*, parserState <- parserState*}
    -- (let nameIR_state = $name(name_state))*{nameIR_state <- nameIR_state*, name_state <- name_state*}
    -- if $distinct_<nameIR>(nameIR_state*{nameIR_state <- nameIR_state*})
    -- if "start" <- nameIR_state*{nameIR_state <- nameIR_state*}
    -- if (~"accept" <- nameIR_state*{nameIR_state <- nameIR_state*} /\ ~"reject" <- nameIR_state*{nameIR_state <- nameIR_state*})
    -- let nameIR_state_impl*{nameIR_state_impl <- nameIR_state_impl*} = "accept" :: "reject" :: nameIR_state*{nameIR_state <- nameIR_state*}
    -- (ParserState_ok: TC nameIR_state_impl*{nameIR_state_impl <- nameIR_state_impl*} |- parserState : parserStateIR)*{parserState <- parserState*, parserStateIR <- parserStateIR*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:167.1-170.20
relation ParserLocalDecl_ok: typingContext |- parserLocalDeclaration : typingContext parserLocalDeclarationIR

  ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:9.1-13.55
  rulegroup constantDeclaration {


    ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:9.1-13.55
    rule constantDeclaration: TC_0 |- parserLocalDeclaration : TC_1 constantDeclarationIR as parserLocalDeclarationIR
    -- if parserLocalDeclaration <: constantDeclaration
    -- let constantDeclaration = parserLocalDeclaration as constantDeclaration
    -- Decl_ok: block TC_0 |- constantDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: constantDeclarationIR
    -- let constantDeclarationIR = declarationIR as constantDeclarationIR
  }

  ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:17.1-21.49
  rulegroup instantiation {


    ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:17.1-21.49
    rule instantiation: TC_0 |- parserLocalDeclaration : TC_1 instantiationIR as parserLocalDeclarationIR
    -- if parserLocalDeclaration <: instantiation
    -- let instantiation = parserLocalDeclaration as instantiation
    -- Decl_ok: block TC_0 |- instantiation as declaration : TC_1 declarationIR
    -- if declarationIR <: instantiationIR
    -- let instantiationIR = declarationIR as instantiationIR
  }

  ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:27.1-65.2
  rulegroup variableDeclaration {


    ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:29.3-42.46
    rule empty: TC_0 |- parserLocalDeclaration : TC_1 variableDeclarationIR as parserLocalDeclarationIR
    -- if parserLocalDeclaration <: variableDeclaration
    -- let annotationList type name initializerOpt ; = parserLocalDeclaration as variableDeclaration
    -- if initializerOpt matches ``EMPTY`
    -- Type_ok: block TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(block, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(block, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?() ;

    ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:44.3-63.75
    rule initializer: TC_0 |- parserLocalDeclaration : TC_1 variableDeclarationIR as parserLocalDeclarationIR
    -- if parserLocalDeclaration <: variableDeclaration
    -- let annotationList type name initializerOpt ; = parserLocalDeclaration as variableDeclaration
    -- if initializerOpt <: initializer
    -- let = expression_init = initializerOpt as initializer
    -- Type_ok: block TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(block, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- Expr_ok: block TC_0 |- expression_init : typedExpressionIR_init
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(block, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?(= typedExpressionIR_init_cast) ;
  }

  ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:71.1-88.78
  rulegroup valueSetDeclaration {


    ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:71.1-88.78
    rule valueSetDeclaration: TC_0 |- parserLocalDeclaration : TC_1 valueSetDeclarationIR as parserLocalDeclarationIR
    -- if parserLocalDeclaration <: valueSetDeclaration
    -- let annotationList value_set< valueSetType >( expression ) name ; = parserLocalDeclaration as valueSetDeclaration
    -- Type_ok: block TC_0 |- valueSetType as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(block, TC_0) |- set< [typeIR] > as typeIR holds
    -- Expr_ok: block TC_0 |- expression : typedExpressionIR
    -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR
    -- if (ctk =/= dyn)
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(block, TC_0, nameIR, set< [typeIR] > as typeIR ctk ?())
    -- let valueSetDeclarationIR = annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:172.1-175.20
relation ParserLocalDecls_ok: typingContext |- parserLocalDeclaration* : typingContext parserLocalDeclarationIR*

  ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:96.1-97.21
  rulegroup nil {


    ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:96.1-97.21
    rule nil: TC |- parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} : TC []
    -- if parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} matches []
  }

  ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:99.1-105.67
  rulegroup cons {


    ;; ../../../../spec-concrete/5.13.3-typing-parser-declaration.watsup:99.1-105.67
    rule cons: TC_0 |- parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} : TC_2 parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*}
    -- if parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} matches _ :: _
    -- let parserLocalDeclaration_h :: parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} = parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}
    -- ParserLocalDecl_ok: TC_0 |- parserLocalDeclaration_h : TC_1 parserLocalDeclarationIR_h
    -- ParserLocalDecls_ok: TC_1 |- parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} : TC_2 parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:181.1-183.23
relation TableKey_ok: typingContext tableContext |- tableKey : tableContext tableKeyIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:45.1-62.77
  rulegroup  {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:45.1-62.77
    rule : TC TBLC_0 |- expression : name_matchkind annotationList ; : TBLC_2 tableKeyIR
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
    -- if Type_wf: $bound(local, TC) |- set< [typeIR] > as typeIR holds
    -- let nameIR_matchkind = $name(name_matchkind)
    -- if (match_kind. nameIR_matchkind as value = $find_value(local, TC, ` nameIR_matchkind))
    -- if $compat_table_key(nameIR_matchkind, typeIR)
    -- let TBLC_1 = $update_mode(TBLC_0, nameIR_matchkind, typeIR)
    -- let TBLC_2 = $add_key(TBLC_1, nameIR_matchkind, typeIR)
    -- let tableKeyIR = typedExpressionIR : nameIR_matchkind annotationList ;
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:185.1-187.23
relation TableKeys_ok: typingContext tableContext |- tableKey* : tableContext tableKeyListIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:70.1-71.28
  rulegroup nil {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:70.1-71.28
    rule nil: TC TBLC |- tableKey*{tableKey <- tableKey*} : TBLC []
    -- if tableKey*{tableKey <- tableKey*} matches []
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:73.1-77.67
  rulegroup cons {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:73.1-77.67
    rule cons: TC TBLC_0 |- tableKey*{tableKey <- tableKey*} : TBLC_2 tableKeyIR_h :: tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*}
    -- if tableKey*{tableKey <- tableKey*} matches _ :: _
    -- let tableKey_h :: tableKey_t*{tableKey_t <- tableKey_t*} = tableKey*{tableKey <- tableKey*}
    -- TableKey_ok: TC TBLC_0 |- tableKey_h : TBLC_1 tableKeyIR_h
    -- TableKeys_ok: TC TBLC_1 |- tableKey_t*{tableKey_t <- tableKey_t*} : TBLC_2 tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:189.1-192.23
relation Call_action_partial_ok: typingContext |- parameterTypeIR* @ argumentListIR : parameterTypeIR* , parameterTypeIR* @ argumentListIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:101.1-113.42
  rulegroup  {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:101.1-113.42
    rule : TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} , parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- if (|parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- Call_convention_ok: local TC action |- parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:194.1-196.23
relation TableAction_ok: typingContext tableContext |- tableAction : tableContext tableActionIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:120.1-134.68
  rulegroup prefixedNonTypeName {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:120.1-134.68
    rule prefixedNonTypeName: TC TBLC_0 |- annotationList tableActionReference ; : TBLC_1 tableActionIR
    -- if tableActionReference <: prefixedNonTypeName
    -- let prefixedNonTypeName = tableActionReference as prefixedNonTypeName
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_routine_non_overloaded(local, TC, prefixedNameIR)
    -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
    -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}
    -- if routineTypeDefIR <: functionTypeIR
    -- let functionTypeIR = routineTypeDefIR as functionTypeIR
    -- if functionTypeIR matches `ACTION(%)`
    -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
    -- Call_action_partial_ok: TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ [] : parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} , parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} @ argumentIR*{argumentIR <- argumentIR*}
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- let TBLC_1 = $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, [])
    -- let tableActionIR = annotationList prefixedNameIR ( [] ) ;
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:138.1-155.81
  rulegroup prefixedNonTypeName-argumentList {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:138.1-155.81
    rule prefixedNonTypeName-argumentList: TC TBLC_0 |- annotationList tableActionReference ; : TBLC_1 tableActionIR
    -- if tableActionReference matches `%(%)`
    -- let prefixedNonTypeName ( argumentList ) = tableActionReference
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} = $find_routine_non_overloaded(local, TC, prefixedNameIR)
    -- if routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches (_)
    -- let ?(routineTypeDefIR) = routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?}
    -- if routineTypeDefIR <: functionTypeIR
    -- let functionTypeIR = routineTypeDefIR as functionTypeIR
    -- if functionTypeIR matches `ACTION(%)`
    -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: local TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- Call_action_partial_ok: TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} , parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    -- let TBLC_1 = $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})
    -- let tableActionIR = annotationList prefixedNameIR ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} ) ;
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:198.1-200.23
relation TableActions_ok: typingContext tableContext |- tableAction* : tableContext tableActionListIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:163.1-164.28
  rulegroup nil {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:163.1-164.28
    rule nil: TC TBLC |- tableAction*{tableAction <- tableAction*} : TBLC []
    -- if tableAction*{tableAction <- tableAction*} matches []
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:166.1-170.76
  rulegroup cons {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:166.1-170.76
    rule cons: TC TBLC_0 |- tableAction*{tableAction <- tableAction*} : TBLC_2 tableActionIR_h :: tableActionIR_t*{tableActionIR_t <- tableActionIR_t*}
    -- if tableAction*{tableAction <- tableAction*} matches _ :: _
    -- let tableAction_h :: tableAction_t*{tableAction_t <- tableAction_t*} = tableAction*{tableAction <- tableAction*}
    -- TableAction_ok: TC TBLC_0 |- tableAction_h : TBLC_1 tableActionIR_h
    -- TableActions_ok: TC TBLC_1 |- tableAction_t*{tableAction_t <- tableAction_t*} : TBLC_2 tableActionIR_t*{tableActionIR_t <- tableActionIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:202.1-205.23
relation Call_action_default_ok: typingContext |- parameterTypeIR* @ argumentListIR : parameterTypeIR* , parameterTypeIR* @ argumentListIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:178.1-188.42
  rulegroup  {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:178.1-188.42
    rule : TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} , parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- Call_convention_ok: local TC action |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:207.1-209.23
relation TableDefaultAction_ok: typingContext tableContext |- initializer : tableActionReferenceIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:192.1-197.56
  rulegroup prefixedNonTypeName {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:192.1-197.56
    rule prefixedNonTypeName: TC TBLC |- = expression : prefixedNameIR ( [] )
    -- if expression <: prefixedNonTypeName
    -- let prefixedNonTypeName = expression as prefixedNonTypeName
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- if (?(([], [])) = $find_action(TBLC, prefixedNameIR))
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:201.1-222.57
  rulegroup prefixedNonTypeName-argumentList {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:201.1-222.57
    rule prefixedNonTypeName-argumentList: TC TBLC |- = expression : prefixedNameIR ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if expression <: callExpression
    -- let callExpression = expression as callExpression
    -- if callExpression matches `%(%)`
    -- let callTarget ( argumentList ) = callExpression
    -- if callTarget <: prefixedNonTypeName
    -- let prefixedNonTypeName = callTarget as prefixedNonTypeName
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- let (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} = $find_action(TBLC, prefixedNameIR)
    -- if (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} matches (_)
    -- let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) = (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: local TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- Call_action_default_ok: TC |- parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*} , parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    -- let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} = argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
    -- let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} = argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
    -- (if (argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:211.1-213.23
relation TableEntry_keyset_ok: typingContext tableContext |- keysetExpression : tableEntryState keysetExpressionIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:427.1-434.53
  rulegroup simpleKeysetExpression-expression {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:427.1-434.53
    rule simpleKeysetExpression-expression: TC TBLC |- keysetExpression : TBLS simpleKeysetExpressionIR as keysetExpressionIR
    -- if keysetExpression <: expression
    -- let expression = keysetExpression as expression
    -- if (|TBLC.keys| = 1)
    -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression as simpleKeysetExpression] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
    -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:438.1-445.53
  rulegroup simpleKeysetExpression-mask {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:438.1-445.53
    rule simpleKeysetExpression-mask: TC TBLC |- keysetExpression : TBLS simpleKeysetExpressionIR as keysetExpressionIR
    -- if keysetExpression <: simpleKeysetExpression
    -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
    -- if simpleKeysetExpression matches `%&&&%`
    -- let expression_l &&& expression_r = simpleKeysetExpression
    -- if (|TBLC.keys| = 1)
    -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression_l &&& expression_r] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
    -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:449.1-456.53
  rulegroup simpleKeysetExpression-range {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:449.1-456.53
    rule simpleKeysetExpression-range: TC TBLC |- keysetExpression : TBLS simpleKeysetExpressionIR as keysetExpressionIR
    -- if keysetExpression <: simpleKeysetExpression
    -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
    -- if simpleKeysetExpression matches `%..%`
    -- let expression_l .. expression_r = simpleKeysetExpression
    -- if (|TBLC.keys| = 1)
    -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression_l .. expression_r] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
    -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:460.1-472.2
  rulegroup simpleKeysetExpression-default {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:462.3-465.23
    rule noprilpm: TC TBLC |- keysetExpression : TBLS default as keysetExpressionIR
    -- if (keysetExpression = default as keysetExpression)
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- let TBLS = lpm n

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:467.3-470.23
    rule non-noprilpm: TC TBLC |- keysetExpression : TBLS default as keysetExpressionIR
    -- if (keysetExpression = default as keysetExpression)
    -- if (((TBLC.mode = nopri) \/ (TBLC.mode = pri)) \/ (TBLC.mode = prilpm))
    -- let TBLS = nolpm
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:476.1-488.2
  rulegroup simpleKeysetExpression-dontcare {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:478.3-481.23
    rule noprilpm: TC TBLC |- keysetExpression : TBLS _ as keysetExpressionIR
    -- if (keysetExpression = _ as keysetExpression)
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- let TBLS = lpm 0

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:483.3-486.23
    rule non-noprilpm: TC TBLC |- keysetExpression : TBLS _ as keysetExpressionIR
    -- if (keysetExpression = _ as keysetExpression)
    -- if (((TBLC.mode = nopri) \/ (TBLC.mode = pri)) \/ (TBLC.mode = prilpm))
    -- let TBLS = nolpm
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:495.1-503.53
  rulegroup tupleKeysetExpression-mask {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:495.1-503.53
    rule tupleKeysetExpression-mask: TC TBLC |- keysetExpression : TBLS ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
    -- if keysetExpression <: tupleKeysetExpression
    -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
    -- if tupleKeysetExpression matches `(%&&&%)`
    -- let ( expression_l &&& expression_r ) = tupleKeysetExpression
    -- if (|TBLC.keys| = 1)
    -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression_l &&& expression_r] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
    -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:507.1-515.53
  rulegroup tupleKeysetExpression-range {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:507.1-515.53
    rule tupleKeysetExpression-range: TC TBLC |- keysetExpression : TBLS ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
    -- if keysetExpression <: tupleKeysetExpression
    -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
    -- if tupleKeysetExpression matches `(%..%)`
    -- let ( expression_l .. expression_r ) = tupleKeysetExpression
    -- if (|TBLC.keys| = 1)
    -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ [expression_l .. expression_r] : TBLS simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
    -- if simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*} matches [ _/1 ]
    -- let [simpleKeysetExpressionIR] = simpleKeysetExpressionIR'*{simpleKeysetExpressionIR' <- simpleKeysetExpressionIR'*}
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:519.1-531.2
  rulegroup tupleKeysetExpression-default {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:521.3-524.23
    rule noprilpm: TC TBLC |- keysetExpression : TBLS ( [default] ) as keysetExpressionIR
    -- if (keysetExpression = (default) as keysetExpression)
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- let TBLS = lpm n

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:526.3-529.23
    rule non-noprilpm: TC TBLC |- keysetExpression : TBLS ( [default] ) as keysetExpressionIR
    -- if (keysetExpression = (default) as keysetExpression)
    -- if (((TBLC.mode = nopri) \/ (TBLC.mode = pri)) \/ (TBLC.mode = prilpm))
    -- let TBLS = nolpm
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:535.1-547.2
  rulegroup tupleKeysetExpression-dontcare {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:537.3-540.23
    rule noprilpm: TC TBLC |- keysetExpression : TBLS ( [_] ) as keysetExpressionIR
    -- if (keysetExpression = (_) as keysetExpression)
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- let TBLS = lpm 0

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:542.3-545.23
    rule non-noprilpm: TC TBLC |- keysetExpression : TBLS ( [_] ) as keysetExpressionIR
    -- if (keysetExpression = (_) as keysetExpression)
    -- if (((TBLC.mode = nopri) \/ (TBLC.mode = pri)) \/ (TBLC.mode = prilpm))
    -- let TBLS = nolpm
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:551.1-563.54
  rulegroup tupleKeysetExpression-list {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:551.1-563.54
    rule tupleKeysetExpression-list: TC TBLC |- keysetExpression : TBLS ( simpleKeysetExpressionIR*{simpleKeysetExpressionIR <- simpleKeysetExpressionIR*} ) as keysetExpressionIR
    -- if keysetExpression <: tupleKeysetExpression
    -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
    -- if tupleKeysetExpression matches `(%,%)`
    -- let ( simpleKeysetExpression_h , simpleKeysetExpressionList_t ) = tupleKeysetExpression
    -- let simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t)
    -- let simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} = simpleKeysetExpression_h :: simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*}
    -- if (|TBLC.keys| = |simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}|)
    -- TableEntry_keysets_simple_ok: TC TBLC nolpm |- TBLC.keys @ simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} : TBLS simpleKeysetExpressionIR*{simpleKeysetExpressionIR <- simpleKeysetExpressionIR*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:215.1-217.23
relation TableEntry_action_ok: typingContext tableContext |- tableActionReference : tableActionReferenceIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:573.1-577.56
  rulegroup prefixedNonTypeName {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:573.1-577.56
    rule prefixedNonTypeName: TC TBLC |- tableActionReference : prefixedNameIR ( [] )
    -- if tableActionReference <: prefixedNonTypeName
    -- let prefixedNonTypeName = tableActionReference as prefixedNonTypeName
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- if (?(([], [])) = $find_action(TBLC, prefixedNameIR))
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:581.1-602.57
  rulegroup prefixedNonTypeName-argumentList {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:581.1-602.57
    rule prefixedNonTypeName-argumentList: TC TBLC |- tableActionReference : prefixedNameIR ( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if tableActionReference matches `%(%)`
    -- let prefixedNonTypeName ( argumentList ) = tableActionReference
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- let (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} = $find_action(TBLC, prefixedNameIR)
    -- if (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?} matches (_)
    -- let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) = (parameterTypeIR*, argumentListIR)?{(parameterTypeIR*, argumentListIR) <- (parameterTypeIR*, argumentListIR)?}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: local TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- Call_action_default_ok: TC |- parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*} @ argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*} , parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*} @ argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
    -- let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} = argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
    -- let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} = argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|]
    -- (if (argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:219.1-222.26
relation TableEntry_priority_ok: typingContext tableContext tableEntryState |- tableEntryPriority? : tableContext tableEntryPriorityOptIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:612.1-676.2
  rulegroup non-specified {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:614.3-616.28
    rule nopri: TC TBLC TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC ?()
    -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
    -- if (TBLC.mode = nopri)

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:618.3-621.30
    rule noprilpm: TC TBLC TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC ?()
    -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- let tableEntryState = TBLS
    -- if tableEntryState matches `LPM%`
    -- let lpm n_prefix = tableEntryState

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:623.3-635.50
    rule pri-prilpm-number-init-largest-wins: TC TBLC_0 TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC_1 ?(priority= d n as int :)
    -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if (TBLC_0.priorities.values = [])
    -- if TBLC_0.priorities.largest_wins
    -- let n_size = TBLC_0.entries.size
    -- let n_delta = TBLC_0.priorities.delta
    -- let n = (((n_size - 1) * n_delta) + 1)
    -- let TBLC_1 = $add_table_priority(TBLC_0, n)

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:637.3-646.50
    rule pri-prilpm-number-init-non-largest-wins: TC TBLC_0 TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC_1 ?(priority= d 1 as int :)
    -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if (TBLC_0.priorities.values = [])
    -- if ~TBLC_0.priorities.largest_wins
    -- let TBLC_1 = $add_table_priority(TBLC_0, 1)

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:648.3-660.50
    rule pri-prilpm-number-non-init-largest-wins: TC TBLC_0 TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC_1 ?(priority= d n as int :)
    -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if (TBLC_0.priorities.values =/= [])
    -- if TBLC_0.priorities.largest_wins
    -- let n_last = $find_table_priority_last(TBLC_0)
    -- let n_delta = TBLC_0.priorities.delta
    -- let n = (n_last - n_delta)
    -- let TBLC_1 = $add_table_priority(TBLC_0, n)

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:662.3-674.50
    rule pri-prilpm-number-non-init-non-largest-wins: TC TBLC_0 TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC_1 ?(priority= d n as int :)
    -- if tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} matches ()
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if (TBLC_0.priorities.values =/= [])
    -- if ~TBLC_0.priorities.largest_wins
    -- let n_last = $find_table_priority_last(TBLC_0)
    -- let n_delta = TBLC_0.priorities.delta
    -- let n = (n_last + n_delta)
    -- let TBLC_1 = $add_table_priority(TBLC_0, n)
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:680.1-708.2
  rulegroup specified-number {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:682.3-693.50
    rule pri-prilpm-number-init: TC TBLC_0 TBLS |- tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} : TBLC_2 ?(priority= numberLiteral :)
    -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
    -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
    -- if tableEntryPriority matches `PRIORITY=%:`
    -- let priority= numberLiteral : = tableEntryPriority
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if ~TBLC_0.entries.const
    -- if (TBLC_0.priorities.values = [])
    -- let int = $to_number(numberLiteral as value)
    -- if int <: nat
    -- let n = int as nat
    -- let TBLC_1 = TBLC_0[priorities.init = true]
    -- let TBLC_2 = $add_table_priority(TBLC_1, n)

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:695.3-706.50
    rule pri-prilpm-number-non-init: TC TBLC_0 TBLS |- tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} : TBLC_1 ?(priority= numberLiteral :)
    -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
    -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
    -- if tableEntryPriority matches `PRIORITY=%:`
    -- let priority= numberLiteral : = tableEntryPriority
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if ~TBLC_0.entries.const
    -- if (TBLC_0.priorities.values =/= [])
    -- if TBLC_0.priorities.init
    -- let int = $to_number(numberLiteral as value)
    -- if int <: nat
    -- let n = int as nat
    -- let TBLC_1 = $add_table_priority(TBLC_0, n)
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:712.1-746.2
  rulegroup specified-expression {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:714.3-728.50
    rule pri-prilpm-expression-init: TC TBLC_0 TBLS |- tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} : TBLC_2 ?(priority=( typedExpressionIR ):)
    -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
    -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
    -- if tableEntryPriority matches `PRIORITY=(%):`
    -- let priority=( expression ): = tableEntryPriority
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if ~TBLC_0.entries.const
    -- if (TBLC_0.priorities.values = [])
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR
    -- if ctk matches `LCTK`
    -- Eval_static: local TC |- typedExpressionIR ~> value
    -- let int = $to_number(value)
    -- if int <: nat
    -- let n = int as nat
    -- let TBLC_1 = TBLC_0[priorities.init = true]
    -- let TBLC_2 = $add_table_priority(TBLC_1, n)

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:730.3-744.50
    rule pri-prilpm-expression-non-init: TC TBLC_0 TBLS |- tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} : TBLC_1 ?(priority=( typedExpressionIR ):)
    -- if tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} matches (_)
    -- let ?(tableEntryPriority) = tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?}
    -- if tableEntryPriority matches `PRIORITY=(%):`
    -- let priority=( expression ): = tableEntryPriority
    -- if ((TBLC_0.mode = pri) \/ (TBLC_0.mode = prilpm))
    -- if ~TBLC_0.entries.const
    -- if (TBLC_0.priorities.values =/= [])
    -- if TBLC_0.priorities.init
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR
    -- if ctk matches `LCTK`
    -- Eval_static: local TC |- typedExpressionIR ~> value
    -- let int = $to_number(value)
    -- if int <: nat
    -- let n = int as nat
    -- let TBLC_1 = $add_table_priority(TBLC_0, n)
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:224.1-226.23
relation TableEntry_ok: typingContext tableContext |- tableEntry : tableContext tableEntryIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:751.1-766.73
  rulegroup priority {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:751.1-766.73
    rule priority: TC TBLC_0 |- tableEntry : TBLC_1 tableEntryIR
    -- if tableEntry matches `%%%:%%;`
    -- let constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ; = tableEntry
    -- TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR
    -- TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR
    -- TableEntry_priority_ok: TC TBLC_0 TBLS |- ?(tableEntryPriority) : TBLC_1 tableEntryPriorityOptIR
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tableEntryIR = constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:770.1-784.73
  rulegroup non-priority {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:770.1-784.73
    rule non-priority: TC TBLC_0 |- tableEntry : TBLC_1 tableEntryIR
    -- if tableEntry matches `%%:%%;`
    -- let constOpt keysetExpression : tableActionReference annotationList ; = tableEntry
    -- TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR
    -- TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR
    -- TableEntry_priority_ok: TC TBLC_0 TBLS |- ?() : TBLC_1 tableEntryPriorityOptIR
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tableEntryIR = constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:228.1-230.23
relation TableEntries_ok: typingContext tableContext |- tableEntry* : tableContext tableEntryListIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:792.1-793.28
  rulegroup nil {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:792.1-793.28
    rule nil: TC TBLC |- tableEntry*{tableEntry <- tableEntry*} : TBLC []
    -- if tableEntry*{tableEntry <- tableEntry*} matches []
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:795.1-799.74
  rulegroup cons {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:795.1-799.74
    rule cons: TC TBLC_0 |- tableEntry*{tableEntry <- tableEntry*} : TBLC_2 tableEntryIR_h :: tableEntryIR_t*{tableEntryIR_t <- tableEntryIR_t*}
    -- if tableEntry*{tableEntry <- tableEntry*} matches _ :: _
    -- let tableEntry_h :: tableEntry_t*{tableEntry_t <- tableEntry_t*} = tableEntry*{tableEntry <- tableEntry*}
    -- TableEntry_ok: TC TBLC_0 |- tableEntry_h : TBLC_1 tableEntryIR_h
    -- TableEntries_ok: TC TBLC_1 |- tableEntry_t*{tableEntry_t <- tableEntry_t*} : TBLC_2 tableEntryIR_t*{tableEntryIR_t <- tableEntryIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:232.1-234.23
relation TableProperty_ok: typingContext tableContext |- tableProperty : tableContext tablePropertyIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:809.1-813.63
  rulegroup key {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:809.1-813.63
    rule key: TC TBLC_0 |- tableProperty : TBLC_1 key={ tableKeyIR*{tableKeyIR <- tableKeyIR*} }
    -- if tableProperty matches `KEY={%}`
    -- let key={ tableKeyList } = tableProperty
    -- let tableKey*{tableKey <- tableKey*} = $flatten_tableKeyList(tableKeyList)
    -- TableKeys_ok: TC TBLC_0 |- tableKey*{tableKey <- tableKey*} : TBLC_1 tableKeyIR*{tableKeyIR <- tableKeyIR*}
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:817.1-821.72
  rulegroup actions {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:817.1-821.72
    rule actions: TC TBLC_0 |- tableProperty : TBLC_1 actions={ tableActionIR*{tableActionIR <- tableActionIR*} }
    -- if tableProperty matches `ACTIONS={%}`
    -- let actions={ tableActionList } = tableProperty
    -- let tableAction*{tableAction <- tableAction*} = $flatten_tableActionList(tableActionList)
    -- TableActions_ok: TC TBLC_0 |- tableAction*{tableAction <- tableAction*} : TBLC_1 tableActionIR*{tableActionIR <- tableActionIR*}
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:825.1-837.70
  rulegroup entries {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:825.1-837.70
    rule entries: TC TBLC_0 |- tableProperty : TBLC_3 annotationList constOptIR entries={ tableEntryIR*{tableEntryIR <- tableEntryIR*} }
    -- if tableProperty matches `%%ENTRIES={%}`
    -- let annotationList constOpt entries={ tableEntryList } = tableProperty
    -- let tableEntry*{tableEntry <- tableEntry*} = $flatten_tableEntryList(tableEntryList)
    -- if ((|TBLC_0.keys| = 0) => (|tableEntry*{tableEntry <- tableEntry*}| = 0))
    -- let TBLC_1 = TBLC_0[entries.size = |tableEntry*{tableEntry <- tableEntry*}|]
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let TBLC_2 = TBLC_1[entries.const = (constOptIR = ?(const))]
    -- TableEntries_ok: TC TBLC_2 |- tableEntry*{tableEntry <- tableEntry*} : TBLC_3 tableEntryIR*{tableEntryIR <- tableEntryIR*}
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:841.1-851.78
  rulegroup default-action {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:841.1-851.78
    rule default-action: TC TBLC |- tableProperty : TBLC tablePropertyIR
    -- if tableProperty matches `%%%%;`
    -- let annotationList constOpt tableCustomName initializer ; = tableProperty
    -- if ("default_action" = $tableCustomName(tableCustomName))
    -- TableDefaultAction_ok: TC TBLC |- initializer : tableActionReferenceIR
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tablePropertyIR = annotationList constOptIR default_action= tableActionReferenceIR ;
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:853.1-925.2
  rulegroup custom {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:855.3-869.76
    rule size: TC TBLC |- tableProperty : TBLC tablePropertyIR
    -- if tableProperty matches `%%%%;`
    -- let annotationList constOpt tableCustomName = expression ; = tableProperty
    -- if ("size" = $tableCustomName(tableCustomName))
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
    -- if (($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tablePropertyIR = annotationList constOptIR custom "size" = typedExpressionIR ;

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:871.3-886.72
    rule largest-priority-wins: TC TBLC_0 |- tableProperty : TBLC_1 tablePropertyIR
    -- if tableProperty matches `%%%%;`
    -- let annotationList constOpt tableCustomName = expression ; = tableProperty
    -- if ("largest_priority_wins" = $tableCustomName(tableCustomName))
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
    -- if (typeIR = bool as typeIR)
    -- Eval_static: local TC |- typedExpressionIR ~> value
    -- if value <: primitiveValue
    -- let primitiveValue = value as primitiveValue
    -- if primitiveValue matches `B%`
    -- let b b_largest_priority_wins = primitiveValue
    -- let TBLC_1 = TBLC_0[priorities.largest_wins = b_largest_priority_wins]
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tablePropertyIR = annotationList constOptIR custom_const "largest_priority_wins" = b b_largest_priority_wins as value ;

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:888.3-908.49
    rule priority-delta: TC TBLC_0 |- tableProperty : TBLC_1 tablePropertyIR
    -- if tableProperty matches `%%%%;`
    -- let annotationList constOpt tableCustomName = expression ; = tableProperty
    -- if ("priority_delta" = $tableCustomName(tableCustomName))
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
    -- if (($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))
    -- Eval_static: local TC |- typedExpressionIR ~> value
    -- let int = $to_number(value)
    -- if int <: nat
    -- let n_delta = int as nat
    -- if (n_delta > 0)
    -- let TBLC_1 = TBLC_0[priorities.delta = n_delta]
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tablePropertyIR = annotationList constOptIR custom_const "priority_delta" = d n_delta as int as value ;

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:910.3-923.76
    rule unknown: TC TBLC |- tableProperty : TBLC tablePropertyIR
    -- if tableProperty matches `%%%%;`
    -- let annotationList constOpt tableCustomName = expression ; = tableProperty
    -- let nameIR = $tableCustomName(tableCustomName)
    -- if (((nameIR =/= "size") /\ (nameIR =/= "largest_priority_wins")) /\ (nameIR =/= "priority_delta"))
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let constOptIR = $flatten_constOpt(constOpt)
    -- let tablePropertyIR = annotationList constOptIR custom nameIR = typedExpressionIR ;
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:236.1-238.23
relation TableProperties_ok: typingContext tableContext |- tableProperty* : tableContext tablePropertyListIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:933.1-934.28
  rulegroup nil {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:933.1-934.28
    rule nil: TC TBLC |- tableProperty*{tableProperty <- tableProperty*} : TBLC []
    -- if tableProperty*{tableProperty <- tableProperty*} matches []
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:936.1-940.83
  rulegroup cons {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:936.1-940.83
    rule cons: TC TBLC_0 |- tableProperty*{tableProperty <- tableProperty*} : TBLC_2 tablePropertyIR_h :: tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*}
    -- if tableProperty*{tableProperty <- tableProperty*} matches _ :: _
    -- let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty*{tableProperty <- tableProperty*}
    -- TableProperty_ok: TC TBLC_0 |- tableProperty_h : TBLC_1 tablePropertyIR_h
    -- TableProperties_ok: TC TBLC_1 |- tableProperty_t*{tableProperty_t <- tableProperty_t*} : TBLC_2 tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:240.1-242.20
relation Table_ok: typingContext |- tableProperty* : tableContext tablePropertyListIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:974.1-982.79
  rulegroup  {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:974.1-982.79
    rule : TC |- tableProperty*{tableProperty <- tableProperty*} : TBLC_1 tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
    -- if ($count_table_keys(tableProperty*{tableProperty <- tableProperty*}) <= 1)
    -- if ($count_table_actions(tableProperty*{tableProperty <- tableProperty*}) = 1)
    -- let TBLC_0 = $empty_tableContext
    -- TableProperties_ok: TC TBLC_0 |- tableProperty*{tableProperty <- tableProperty*} : TBLC_1 tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:244.1-246.23
relation TableType_ok: typingContext tableContext |- name : typingContext typeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:984.1-1010.59
  rulegroup  {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:984.1-1010.59
    rule : TC_0 TBLC |- name : TC_1 typeIR_table
    -- let nameIR = $name(name)
    -- let tid_enum = "action_list(" ++ nameIR ++ ")"
    -- let (prefixedNameIR_action, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentListIR)*{_argumentListIR <- _argumentListIR*, _parameterTypeIR* <- _parameterTypeIR**, prefixedNameIR_action <- prefixedNameIR_action*} = TBLC.actions
    -- (let id_enum_field = $flatten_prefixedNameIR(prefixedNameIR_action))*{id_enum_field <- id_enum_field*, prefixedNameIR_action <- prefixedNameIR_action*}
    -- let typeIR_table_enum = table_enum tid_enum { id_enum_field*{id_enum_field <- id_enum_field*} } as typeIR
    -- (let value_enum_field = table_enum tid_enum . id_enum_field as value)*{id_enum_field <- id_enum_field*, value_enum_field <- value_enum_field*}
    -- (let varTypeIR_enum_field = typeIR_table_enum lctk ?(value_enum_field))*{value_enum_field <- value_enum_field*, varTypeIR_enum_field <- varTypeIR_enum_field*}
    -- let TC_1 = $add_vars(block, TC_0, tid_enum ++ "." ++ id_enum_field*{id_enum_field <- id_enum_field*}, varTypeIR_enum_field*{varTypeIR_enum_field <- varTypeIR_enum_field*})
    -- let tid_struct = "apply_result(" ++ nameIR ++ ")"
    -- let typeIR_table_struct = table_struct tid_struct { [bool as typeIR "hit" ;, bool as typeIR "miss" ;, typeIR_table_enum "action_run" ;] } as typeIR
    -- let typeIR_table = table nameIR # typeIR_table_struct as typeIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:248.1-251.20
relation ControlLocalDecl_ok: typingContext |- controlLocalDeclaration : typingContext controlLocalDeclarationIR

  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:9.1-11.77
  rulegroup constantDeclaration {


    ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:9.1-11.77
    rule constantDeclaration: TC_0 |- controlLocalDeclaration : TC_1 constantDeclarationIR as controlLocalDeclarationIR
    -- if controlLocalDeclaration <: constantDeclaration
    -- let constantDeclaration = controlLocalDeclaration as constantDeclaration
    -- Decl_ok: block TC_0 |- constantDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: constantDeclarationIR
    -- let constantDeclarationIR = declarationIR as constantDeclarationIR
  }

  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:15.1-17.65
  rulegroup instantiation {


    ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:15.1-17.65
    rule instantiation: TC_0 |- controlLocalDeclaration : TC_1 instantiationIR as controlLocalDeclarationIR
    -- if controlLocalDeclaration <: instantiation
    -- let instantiation = controlLocalDeclaration as instantiation
    -- Decl_ok: block TC_0 |- instantiation as declaration : TC_1 declarationIR
    -- if declarationIR <: instantiationIR
    -- let instantiationIR = declarationIR as instantiationIR
  }

  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:23.1-61.2
  rulegroup variableDeclaration {


    ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:25.3-38.46
    rule empty: TC_0 |- controlLocalDeclaration : TC_1 variableDeclarationIR as controlLocalDeclarationIR
    -- if controlLocalDeclaration <: variableDeclaration
    -- let annotationList type name initializerOpt ; = controlLocalDeclaration as variableDeclaration
    -- if initializerOpt matches ``EMPTY`
    -- Type_ok: block TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(block, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(block, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?() ;

    ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:40.3-59.75
    rule initializer: TC_0 |- controlLocalDeclaration : TC_1 variableDeclarationIR as controlLocalDeclarationIR
    -- if controlLocalDeclaration <: variableDeclaration
    -- let annotationList type name initializerOpt ; = controlLocalDeclaration as variableDeclaration
    -- if initializerOpt <: initializer
    -- let = expression_init = initializerOpt as initializer
    -- Type_ok: block TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(block, TC_0) |- typeIR holds
    -- if $is_assignable_typeIR(typeIR)
    -- Expr_ok: block TC_0 |- expression_init : typedExpressionIR_init
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_init, typeIR)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_init_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(block, TC_0, nameIR, inout typeIR dyn ?())
    -- let variableDeclarationIR = annotationList typeIR nameIR ?(= typedExpressionIR_init_cast) ;
  }

  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:65.1-67.73
  rulegroup actionDeclaration {


    ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:65.1-67.73
    rule actionDeclaration: TC_0 |- controlLocalDeclaration : TC_1 actionDeclarationIR as controlLocalDeclarationIR
    -- if controlLocalDeclaration <: actionDeclaration
    -- let actionDeclaration = controlLocalDeclaration as actionDeclaration
    -- Decl_ok: block TC_0 |- actionDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: actionDeclarationIR
    -- let actionDeclarationIR = declarationIR as actionDeclarationIR
  }

  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:73.1-87.71
  rulegroup tableDeclaration {


    ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:73.1-87.71
    rule tableDeclaration: TC_0 |- controlLocalDeclaration : TC_3 tableDeclarationIR as controlLocalDeclarationIR
    -- if controlLocalDeclaration <: tableDeclaration
    -- let annotationList table name { tablePropertyList } = controlLocalDeclaration as tableDeclaration
    -- let TC_1 = TC_0[local.kind = table_apply_method]
    -- let tableProperty*{tableProperty <- tableProperty*} = $flatten_tablePropertyList(tablePropertyList)
    -- Table_ok: TC_1 |- tableProperty*{tableProperty <- tableProperty*} : TBLC tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
    -- let nameIR = $name(name)
    -- TableType_ok: TC_1 TBLC |- name : TC_2 typeIR_table
    -- let TC_3 = $add_var(block, TC_2, nameIR, typeIR_table dyn ?())
    -- let tableDeclarationIR = annotationList table typeIR_table nameIR { tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} }
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:253.1-256.20
relation ControlLocalDecls_ok: typingContext |- controlLocalDeclaration* : typingContext controlLocalDeclarationIR*

  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:95.1-96.21
  rulegroup nil {


    ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:95.1-96.21
    rule nil: TC |- controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} : TC []
    -- if controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} matches []
  }

  ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:98.1-104.69
  rulegroup cons {


    ;; ../../../../spec-concrete/5.14.2-typing-control-declaration.watsup:98.1-104.69
    rule cons: TC_0 |- controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} : TC_2 controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*}
    -- if controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} matches _ :: _
    -- let controlLocalDeclaration_h :: controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} = controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}
    -- ControlLocalDecl_ok: TC_0 |- controlLocalDeclaration_h : TC_1 controlLocalDeclarationIR_h
    -- ControlLocalDecls_ok: TC_1 |- controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} : TC_2 controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:262.1-264.23
relation Decl_ok: cursor typingContext |- declaration : typingContext declarationIR

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:9.1-29.57
  rulegroup constantDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:9.1-29.57
    rule constantDeclaration: p TC_0 |- declaration : TC_1 constantDeclarationIR as declarationIR
    -- if declaration <: constantDeclaration
    -- let annotationList const type name = expression_value ; = declaration as constantDeclaration
    -- Type_ok: p TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(p, TC_0) |- typeIR holds
    -- Expr_ok: p TC_0 |- expression_value : typedExpressionIR_value
    -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR_value
    -- if ctk matches `LCTK`
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_value, typeIR)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_value_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- Eval_static: p TC_0 |- typedExpressionIR_value_cast ~> value
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(p, TC_0, nameIR, typeIR lctk ?(value))
    -- let constantDeclarationIR = annotationList const typeIR nameIR = value ;
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:36.1-88.2
  rulegroup instantiation-non-objectInitializer {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:38.3-58.73
    rule prefixedTypeName: p TC_0 |- declaration : TC_1 instantiationIR as declarationIR
    -- if declaration <: instantiation
    -- let instantiation = declaration as instantiation
    -- if instantiation matches `%%(%)%;`
    -- let annotationList type ( argumentList ) name ; = instantiation
    -- if type <: prefixedTypeName
    -- let prefixedTypeName = type as prefixedTypeName
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- ConstructorType_ok: p TC_0 |- prefixedNameIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
    -- Inst_ok: p TC_0 named |- constructorTypeIR < [] # tid_impl*{tid_impl <- tid_impl*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(p, TC_0, nameIR, typeIR_object ctk ?())
    -- let instantiationIR = annotationList prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR*{argumentIR <- argumentIR*} ) nameIR ?() ;

    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:60.3-86.73
    rule specializedType: p TC_0 |- declaration : TC_1 instantiationIR as declarationIR
    -- if declaration <: instantiation
    -- let instantiation = declaration as instantiation
    -- if instantiation matches `%%(%)%;`
    -- let annotationList type ( argumentList ) name ; = instantiation
    -- if type <: specializedType
    -- let prefixedTypeName < typeArgumentList > = type as specializedType
    -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
    -- TypeArguments_ok: p TC_0 |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- ConstructorType_ok: p TC_0 |- prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
    -- Inst_ok: p TC_0 named |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let nameIR = $name(name)
    -- let TC_1 = $add_var(p, TC_0, nameIR, typeIR_object ctk ?())
    -- let instantiationIR = annotationList prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR*{argumentIR <- argumentIR*} ) nameIR ?() ;
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:194.1-289.2
  rulegroup instantiation-objectInitializer {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:196.3-238.100
    rule prefixedTypeName: p TC_0 |- declaration : TC_2 instantiationIR as declarationIR
    -- if declaration <: instantiation
    -- let instantiation = declaration as instantiation
    -- if instantiation matches `%%(%)%%;`
    -- let annotationList type ( argumentList ) name ={ objectDeclarationList } ; = instantiation
    -- if type <: prefixedTypeName
    -- let prefixedTypeName = type as prefixedTypeName
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- ConstructorType_ok: p TC_0 |- prefixedNameIR < [] >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
    -- Inst_ok: p TC_0 named |- constructorTypeIR < [] # tid_impl*{tid_impl <- tid_impl*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if $is_extern_object_typeIR($canon(typeIR_object))
    -- let typeIR' = typeIR_object
    -- if typeIR' <: namedTypeIR
    -- let namedTypeIR = typeIR' as namedTypeIR
    -- if namedTypeIR matches `%<%>`
    -- let typeIR < tid_expl*{tid_expl <- tid_expl*} , tid'*{tid' <- tid'*} > < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR
    -- if typeIR <: externObjectTypeIR
    -- let extern tid_extern rdenv_extern = typeIR as externObjectTypeIR
    -- if (tid'*{tid' <- tid'*} = tid_impl*{tid_impl <- tid_impl*})
    -- let TC_1 = $add_var(local, TC_0, "this", typeIR_object ctk ?())
    -- let objectDeclaration*{objectDeclaration <- objectDeclaration*} = $flatten_objectDeclarationList(objectDeclarationList)
    -- Decls_object_ok: p TC_1 { [] } { [] } |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : frame_init rdenv_init objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*}
    -- let tid*{tid <- tid*} = tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}
    -- let theta = { tid : typeIR_arg*{tid <- tid*, typeIR_arg <- typeIR_arg*} }
    -- let rdenv_init_subst = $subst_rdenv(theta, rdenv_extern, rdenv_init)
    -- let typeIR_object_init = extern tid_extern rdenv_init_subst as typeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > < typeIR_arg*{typeIR_arg <- typeIR_arg*} > as typeIR
    -- if $is_concrete_extern_object(typeIR_object_init)
    -- let nameIR = $name(name)
    -- let TC_2 = $add_var(p, TC_0, nameIR, typeIR_object_init ctk ?())
    -- let instantiationIR = annotationList prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR*{argumentIR <- argumentIR*} ) nameIR ?(={ objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*} }) ;

    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:240.3-287.100
    rule specializedType: p TC_0 |- declaration : TC_2 instantiationIR as declarationIR
    -- if declaration <: instantiation
    -- let instantiation = declaration as instantiation
    -- if instantiation matches `%%(%)%%;`
    -- let annotationList type ( argumentList ) name ={ objectDeclarationList } ; = instantiation
    -- if type <: specializedType
    -- let prefixedTypeName < typeArgumentList > = type as specializedType
    -- let typeArgument*{typeArgument <- typeArgument*} = $flatten_typeArgumentList(typeArgumentList)
    -- TypeArguments_ok: p TC_0 |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- let argument*{argument <- argument*} = $flatten_argumentList(argumentList)
    -- (Argument_ok: p TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- ConstructorType_ok: p TC_0 |- prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- let tid_infer*{tid_infer <- tid_infer*} = tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*}
    -- Inst_ok: p TC_0 named |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if $is_extern_object_typeIR($canon(typeIR_object))
    -- let typeIR' = typeIR_object
    -- if typeIR' <: namedTypeIR
    -- let namedTypeIR = typeIR' as namedTypeIR
    -- if namedTypeIR matches `%<%>`
    -- let typeIR < tid_expl*{tid_expl <- tid_expl*} , tid'*{tid' <- tid'*} > < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR
    -- if typeIR <: externObjectTypeIR
    -- let extern tid_extern rdenv_extern = typeIR as externObjectTypeIR
    -- if (tid'*{tid' <- tid'*} = tid_impl*{tid_impl <- tid_impl*})
    -- let TC_1 = $add_var(local, TC_0, "this", typeIR_object ctk ?())
    -- let objectDeclaration*{objectDeclaration <- objectDeclaration*} = $flatten_objectDeclarationList(objectDeclarationList)
    -- Decls_object_ok: p TC_1 { [] } { [] } |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : frame_init rdenv_init objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*}
    -- let tid*{tid <- tid*} = tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*}
    -- let theta = { tid : typeIR_arg*{tid <- tid*, typeIR_arg <- typeIR_arg*} }
    -- let rdenv_init_subst = $subst_rdenv(theta, rdenv_extern, rdenv_init)
    -- let typeIR_object_init = extern tid_extern rdenv_init_subst as typeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > < typeIR_arg*{typeIR_arg <- typeIR_arg*} > as typeIR
    -- if $is_concrete_extern_object(typeIR_object_init)
    -- let nameIR = $name(name)
    -- let TC_2 = $add_var(p, TC_0, nameIR, typeIR_object_init ctk ?())
    -- let instantiationIR = annotationList prefixedNameIR < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR*{argumentIR <- argumentIR*} ) nameIR ?(={ objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*} }) ;
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:297.1-328.27
  rulegroup functionDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:297.1-328.27
    rule functionDeclaration: p TC_0 |- declaration : TC_4 functionDeclarationIR as declarationIR
    -- if declaration <: functionDeclaration
    -- let annotationList typeOrVoid name typeParameterListOpt ( parameterList ) blockStatement = declaration as functionDeclaration
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(local, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- Type_ok: local TC_1 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: local TC_1 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_2 = $add_parameters(local, TC_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let TC_3 = TC_2[local.kind = function-> typeIR_ret]
    -- Block_ok: TC_3 cont |- blockStatement : _typingContext f blockStatementIR
    -- if ((f = ret) \/ (typeIR_ret = void as typeIR))
    -- let rid = $rid(name, parameterList)
    -- let functionTypeIR = function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
    -- let routineTypeDefIR = functionTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
    -- if RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds
    -- let TC_4 = $add_routine_overload(p, TC_0, rid, routineTypeDefIR)
    -- let nameIR = $name(name)
    -- let functionDeclarationIR = annotationList typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) blockStatementIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:334.1-355.72
  rulegroup actionDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:334.1-355.72
    rule actionDeclaration: p TC_0 |- declaration : TC_3 actionDeclarationIR as declarationIR
    -- if declaration <: actionDeclaration
    -- let annotationList action name ( parameterList ) blockStatement = declaration as actionDeclaration
    -- let TC_1 = TC_0[local.kind = action]
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: local TC_1 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_2 = $add_parameters(local, TC_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- Block_ok: TC_2 cont |- blockStatement : _typingContext _flow blockStatementIR
    -- let rid = $rid(name, parameterList)
    -- let functionTypeIR = action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
    -- if RoutineTypeDef_wf: $bound(p, TC_0) |- functionTypeIR as routineTypeDefIR holds
    -- let TC_3 = $add_routine_non_overload(p, TC_0, rid, functionTypeIR as routineTypeDefIR)
    -- let nameIR = $name(name)
    -- let actionDeclarationIR = annotationList action nameIR ( parameterIR*{parameterIR <- parameterIR*} ) blockStatementIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:360.1-370.88
  rulegroup errorDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:360.1-370.88
    rule errorDeclaration: cursor TC_0 |- declaration : TC_1 error{ nameIR*{nameIR <- nameIR*} } as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: errorDeclaration
    -- let error{ nameList } = declaration as errorDeclaration
    -- let name*{name <- name*} = $flatten_nameList(nameList)
    -- (let nameIR = $name(name))*{name <- name*, nameIR <- nameIR*}
    -- if $distinct_<nameIR>(nameIR*{nameIR <- nameIR*})
    -- (let nameIR_error = "error." ++ nameIR)*{nameIR <- nameIR*, nameIR_error <- nameIR_error*}
    -- (let value_error = error. nameIR as value)*{nameIR <- nameIR*, value_error <- value_error*}
    -- let TC_1 = $add_vars(global, TC_0, nameIR_error*{nameIR_error <- nameIR_error*}, error as typeIR lctk ?(value_error)*{value_error <- value_error*})
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:375.1-384.92
  rulegroup matchKindDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:375.1-384.92
    rule matchKindDeclaration: cursor TC_0 |- declaration : TC_1 match_kind{ nameIR*{nameIR <- nameIR*} } as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: matchKindDeclaration
    -- let match_kind{ nameList _trailingCommaOpt } = declaration as matchKindDeclaration
    -- let name*{name <- name*} = $flatten_nameList(nameList)
    -- (let nameIR = $name(name))*{name <- name*, nameIR <- nameIR*}
    -- if $distinct_<nameIR>(nameIR*{nameIR <- nameIR*})
    -- (let value_match_kind = match_kind. nameIR as value)*{nameIR <- nameIR*, value_match_kind <- value_match_kind*}
    -- let TC_1 = $add_vars(global, TC_0, nameIR*{nameIR <- nameIR*}, match_kind as typeIR lctk ?(value_match_kind)*{value_match_kind <- value_match_kind*})
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:393.1-420.79
  rulegroup externDeclaration-externFunctionDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:393.1-420.79
    rule externDeclaration-externFunctionDeclaration: cursor TC_0 |- declaration : TC_4 externFunctionDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: externFunctionDeclaration
    -- let annotationList extern typeOrVoid name typeParameterListOpt ( parameterList ) ; = declaration as externFunctionDeclaration
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(local, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- Type_ok: local TC_1 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- let TC_2 = TC_1[local.kind = extern_function-> typeIR_ret]
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: local TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_3 = $add_parameters(local, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let rid = $rid(name, parameterList)
    -- let functionTypeIR = extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
    -- let routineTypeDefIR = functionTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
    -- if RoutineTypeDef_wf: $bound(global, TC_0) |- routineTypeDefIR holds
    -- let TC_4 = $add_routine_overload(global, TC_0, rid, routineTypeDefIR)
    -- let nameIR = $name(name)
    -- let externFunctionDeclarationIR = annotationList extern typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) ;
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:448.1-481.73
  rulegroup externDeclaration-externObjectDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:448.1-481.73
    rule externDeclaration-externObjectDeclaration: cursor TC_0 |- declaration : TC_8 externObjectDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: externObjectDeclaration
    -- let annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList } = declaration as externObjectDeclaration
    -- let methodPrototype*{methodPrototype <- methodPrototype*} = $flatten_methodPrototypeList(methodPrototypeList)
    -- let (methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*}, methodPrototype_method*{methodPrototype_method <- methodPrototype_method*}) = $split_constructors(methodPrototype*{methodPrototype <- methodPrototype*})
    -- let TC_1 = TC_0[block.kind = extern]
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_2 = $add_types(block, TC_1, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let nameIR = $name(nonTypeName as name)
    -- ExternMethods_ok: TC_2 nameIR |- methodPrototype_method*{methodPrototype_method <- methodPrototype_method*} : TC_3 methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*}
    -- let typeIR_extern = extern nameIR TC_3.block.rdenv as typeIR
    -- let typeDefIR_extern = typeIR_extern < tid_expl*{tid_expl <- tid_expl*} , [] > as typeDefIR
    -- let TC_4 = $add_type(global, TC_0, nameIR, typeDefIR_extern)
    -- let TC_5 = TC_4[block.kind = extern]
    -- let TC_6 = $add_types(block, TC_5, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- ExternConstructors_ok: TC_6 nameIR |- methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*} : TC_7 methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*}
    -- let TC_8 = TC_4[global.cdenv = TC_7.global.cdenv]
    -- let externObjectDeclarationIR = annotationList extern nameIR < tid_expl*{tid_expl <- tid_expl*} , [] >{ methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*} ++ methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*} }
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:489.1-536.56
  rulegroup parserDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:489.1-536.56
    rule parserDeclaration: cursor TC_0 |- declaration : TC_6 parserDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: parserDeclaration
    -- let annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList } = declaration as parserDeclaration
    -- if typeParameterListOpt matches ``EMPTY`
    -- let TC_1 = TC_0[block.kind = parser]
    -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_constructorParameterListOpt(constructorParameterListOpt)
    -- ConstructorParameters_ok: block TC_1 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
    -- let TC_2 = $add_parameters(block, TC_1, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*})
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: block TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid'*{tid' <- tid'*}
    -- if tid'*{tid' <- tid'*} matches []
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_3 = $add_parameters(block, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} = $flatten_parserLocalDeclarationList(parserLocalDeclarationList)
    -- ParserLocalDecls_ok: TC_3 |- parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} : TC_4 parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*}
    -- let TC_5 = TC_4[local.kind = parser_state]
    -- let parserState*{parserState <- parserState*} = $flatten_parserStateList(parserStateList)
    -- ParserStates_ok: TC_5 |- parserState*{parserState <- parserState*} : parserStateIR*{parserStateIR <- parserStateIR*}
    -- let methodTypeIR = parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
    -- if RoutineTypeDef_wf: $bound(global, TC_0) |- methodTypeIR as routineTypeDefIR holds
    -- let cid = $cid(name, constructorParameterListOpt)
    -- let typeIR_parser = parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
    -- let typeIR_parser_spec = typeIR_parser < [] , [] > < [] > as typeIR
    -- let constructorTypeIR = constructor( constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} )-> typeIR_parser_spec
    -- let constructorTypeDefIR = constructorTypeIR < [] , [] >
    -- if ConstructorTypeDef_wf: $bound(global, TC_0) |- constructorTypeDefIR holds
    -- let TC_6 = $add_constructor(TC_0, cid, constructorTypeDefIR)
    -- let nameIR = $name(name)
    -- let parserDeclarationIR = annotationList parser nameIR < [] >( parameterIR*{parameterIR <- parameterIR*} )( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} parserStateIR*{parserStateIR <- parserStateIR*} }
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:544.1-590.60
  rulegroup controlDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:544.1-590.60
    rule controlDeclaration: cursor TC_0 |- declaration : TC_6 controlDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: controlDeclaration
    -- let annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody } = declaration as controlDeclaration
    -- if typeParameterListOpt matches ``EMPTY`
    -- let TC_1 = TC_0[block.kind = control]
    -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_constructorParameterListOpt(constructorParameterListOpt)
    -- ConstructorParameters_ok: block TC_1 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
    -- let TC_2 = $add_parameters(block, TC_1, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*})
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: block TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid'*{tid' <- tid'*}
    -- if tid'*{tid' <- tid'*} matches []
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_3 = $add_parameters(block, TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} = $flatten_controlLocalDeclarationList(controlLocalDeclarationList)
    -- ControlLocalDecls_ok: TC_3 |- controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} : TC_4 controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
    -- let TC_5 = TC_4[local.kind = control_apply_method]
    -- Block_ok: TC_5 cont |- controlBody : _typingContext _flow controlBodyIR
    -- let methodTypeIR = control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
    -- if RoutineTypeDef_wf: $bound(global, TC_0) |- methodTypeIR as routineTypeDefIR holds
    -- let cid = $cid(name, constructorParameterListOpt)
    -- let typeIR_control = control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
    -- let typeIR_control_spec = typeIR_control < [] , [] > < [] > as typeIR
    -- let constructorTypeIR = constructor( constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} )-> typeIR_control_spec
    -- let constructorTypeDefIR = constructorTypeIR < [] , [] >
    -- if ConstructorTypeDef_wf: $bound(global, TC_0) |- constructorTypeDefIR holds
    -- let TC_6 = $add_constructor(TC_0, cid, constructorTypeDefIR)
    -- let nameIR = $name(name)
    -- let controlDeclarationIR = annotationList control nameIR < [] >( parameterIR*{parameterIR <- parameterIR*} )( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} apply controlBodyIR }
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:603.1-620.54
  rulegroup typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:603.1-620.54
    rule typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration: cursor TC_0 |- declaration : TC_2 enumTypeDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: enumTypeDeclaration
    -- let enumTypeDeclaration = declaration as enumTypeDeclaration
    -- if enumTypeDeclaration matches `%ENUM%{%%}`
    -- let annotationList enum name { nameList_field _trailingCommaOpt } = enumTypeDeclaration
    -- let nameIR = $name(name)
    -- let name_field*{name_field <- name_field*} = $flatten_nameList(nameList_field)
    -- (let nameIR_field = $name(name_field))*{nameIR_field <- nameIR_field*, name_field <- name_field*}
    -- let typeIR_enum = enum nameIR { nameIR_field*{nameIR_field <- nameIR_field*} } as typeIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_enum as typeDefIR holds
    -- let TC_1 = $add_type(global, TC_0, nameIR, typeIR_enum as typeDefIR)
    -- (let id_field = nameIR ++ "." ++ nameIR_field)*{id_field <- id_field*, nameIR_field <- nameIR_field*}
    -- (let value_field = nameIR . nameIR_field as value)*{nameIR_field <- nameIR_field*, value_field <- value_field*}
    -- let TC_2 = $add_vars(global, TC_1, id_field*{id_field <- id_field*}, typeIR_enum lctk ?(value_field)*{value_field <- value_field*})
    -- let enumTypeDeclarationIR = annotationList enum nameIR { nameIR_field*{nameIR_field <- nameIR_field*} }
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:666.1-689.72
  rulegroup typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration-serializable {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:666.1-689.72
    rule typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration-serializable: cursor TC_0 |- declaration : TC_3 enumTypeDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: enumTypeDeclaration
    -- let enumTypeDeclaration = declaration as enumTypeDeclaration
    -- if enumTypeDeclaration matches `%ENUM%%{%%}`
    -- let annotationList enum type name { namedExpressionList_field _trailingCommaOpt } = enumTypeDeclaration
    -- Type_ok: global TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(global, TC_0) |- typeIR holds
    -- let nameIR = $name(name)
    -- let namedExpression_field*{namedExpression_field <- namedExpression_field*} = $flatten_namedExpressionList(namedExpressionList_field)
    -- Enum_serializable_fields_ok: TC_0 nameIR typeIR |- namedExpression_field*{namedExpression_field <- namedExpression_field*} : TC_1 namedExpressionIR_field*{namedExpressionIR_field <- namedExpressionIR_field*} # value_field*{value_field <- value_field*}
    -- (let nameIR_field = _typedExpressionIR = namedExpressionIR_field)*{_typedExpressionIR <- _typedExpressionIR*, nameIR_field <- nameIR_field*, namedExpressionIR_field <- namedExpressionIR_field*}
    -- (let id_field = nameIR ++ "." ++ nameIR_field)*{id_field <- id_field*, nameIR_field <- nameIR_field*}
    -- let typeIR_enum = enum nameIR # typeIR { nameIR_field = value_field ;*{nameIR_field <- nameIR_field*, value_field <- value_field*} } as typeIR
    -- let TC_2 = $add_vars(global, TC_0, id_field*{id_field <- id_field*}, typeIR_enum lctk ?(value_field)*{value_field <- value_field*})
    -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_enum as typeDefIR holds
    -- let TC_3 = $add_type(global, TC_2, nameIR, typeIR_enum as typeDefIR)
    -- let enumTypeDeclarationIR = annotationList enum typeIR nameIR { namedExpressionIR_field*{namedExpressionIR_field <- namedExpressionIR_field*} }
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:695.1-717.66
  rulegroup typeDeclaration-derivedTypeDeclaration-structTypeDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:695.1-717.66
    rule typeDeclaration-derivedTypeDeclaration-structTypeDeclaration: cursor TC_0 |- declaration : TC_2 structTypeDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: structTypeDeclaration
    -- let annotationList struct name typeParameterListOpt { typeFieldList } = declaration as structTypeDeclaration
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(block, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let annotationList_field type_field name_field ;*{annotationList_field <- annotationList_field*, name_field <- name_field*, type_field <- type_field*} = $flatten_typeFieldList(typeFieldList)
    -- (Type_ok: block TC_1 |- type_field as typeOrVoid : typeIR_field # tid_impl_field*{tid_impl_field <- tid_impl_field*})*{tid_impl_field* <- tid_impl_field**, typeIR_field <- typeIR_field*, type_field <- type_field*}
    -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_field*{tid_impl_field <- tid_impl_field*}*{tid_impl_field* <- tid_impl_field**})
    -- let nameIR = $name(name)
    -- (let nameIR_field = $name(name_field))*{nameIR_field <- nameIR_field*, name_field <- name_field*}
    -- let typeIR_struct = struct nameIR { typeIR_field nameIR_field ;*{nameIR_field <- nameIR_field*, typeIR_field <- typeIR_field*} } as typeIR
    -- let typeDefIR_struct = typeIR_struct < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_struct holds
    -- let TC_2 = $add_type(global, TC_0, nameIR, typeDefIR_struct)
    -- let structTypeDeclarationIR = annotationList struct nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >{ annotationList_field typeIR_field nameIR_field ;*{annotationList_field <- annotationList_field*, nameIR_field <- nameIR_field*, typeIR_field <- typeIR_field*} }
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:723.1-745.54
  rulegroup typeDeclaration-derivedTypeDeclaration-headerTypeDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:723.1-745.54
    rule typeDeclaration-derivedTypeDeclaration-headerTypeDeclaration: cursor TC_0 |- declaration : TC_2 headerTypeDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: headerTypeDeclaration
    -- let annotationList header name typeParameterListOpt { typeFieldList } = declaration as headerTypeDeclaration
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(block, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let annotationList_f type_f name_f ;*{annotationList_f <- annotationList_f*, name_f <- name_f*, type_f <- type_f*} = $flatten_typeFieldList(typeFieldList)
    -- (Type_ok: block TC_1 |- type_f as typeOrVoid : typeIR_f # tid_impl_f*{tid_impl_f <- tid_impl_f*})*{tid_impl_f* <- tid_impl_f**, typeIR_f <- typeIR_f*, type_f <- type_f*}
    -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_f*{tid_impl_f <- tid_impl_f*}*{tid_impl_f* <- tid_impl_f**})
    -- let nameIR = $name(name)
    -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
    -- let typeIR_header = header nameIR { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } as typeIR
    -- let typeDefIR_header = typeIR_header < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_header holds
    -- let TC_2 = $add_type(global, TC_0, nameIR, typeDefIR_header)
    -- let headerTypeDeclarationIR = annotationList header nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >{ annotationList_f typeIR_f nameIR_f ;*{annotationList_f <- annotationList_f*, nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} }
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:751.1-773.54
  rulegroup typeDeclaration-derivedTypeDeclaration-headerUnionTypeDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:751.1-773.54
    rule typeDeclaration-derivedTypeDeclaration-headerUnionTypeDeclaration: cursor TC_0 |- declaration : TC_2 headerUnionTypeDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: headerUnionTypeDeclaration
    -- let annotationList header_union name typeParameterListOpt { typeFieldList } = declaration as headerUnionTypeDeclaration
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_1 = $add_types(block, TC_0, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let annotationList_f type_f name_f ;*{annotationList_f <- annotationList_f*, name_f <- name_f*, type_f <- type_f*} = $flatten_typeFieldList(typeFieldList)
    -- (Type_ok: block TC_1 |- type_f as typeOrVoid : typeIR_f # tid_impl_f*{tid_impl_f <- tid_impl_f*})*{tid_impl_f* <- tid_impl_f**, typeIR_f <- typeIR_f*, type_f <- type_f*}
    -- let tid_impl*{tid_impl <- tid_impl*} = $concat_<tid>(tid_impl_f*{tid_impl_f <- tid_impl_f*}*{tid_impl_f* <- tid_impl_f**})
    -- let nameIR = $name(name)
    -- (let nameIR_f = $name(name_f))*{nameIR_f <- nameIR_f*, name_f <- name_f*}
    -- let typeIR_union = header_union nameIR { typeIR_f nameIR_f ;*{nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} } as typeIR
    -- let typeDefIR_union = typeIR_union < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_union holds
    -- let TC_2 = $add_type(global, TC_0, nameIR, typeDefIR_union)
    -- let headerUnionTypeDeclarationIR = annotationList header_union nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >{ annotationList_f typeIR_f nameIR_f ;*{annotationList_f <- annotationList_f*, nameIR_f <- nameIR_f*, typeIR_f <- typeIR_f*} }
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:784.1-841.2
  rulegroup typeDeclaration-typedefDeclaration-typedef {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:786.3-799.50
    rule type: cursor TC_0 |- declaration : TC_1 typedefDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: typedefDeclaration
    -- let typedefDeclaration = declaration as typedefDeclaration
    -- if typedefDeclaration matches `%TYPEDEF%%;`
    -- let annotationList typedef typedefType name ; = typedefDeclaration
    -- if typedefType <: type
    -- let type = typedefType as type
    -- Type_ok: global TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(global, TC_0) |- typeIR holds
    -- let nameIR = $name(name)
    -- let typeIR_typedef = typedef nameIR typeIR as typeIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_typedef as typeDefIR holds
    -- let TC_1 = $add_type(global, TC_0, nameIR, typeIR_typedef as typeDefIR)
    -- let typedefDeclarationIR = annotationList typedef typeIR as typedefTypeIR nameIR ;

    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:801.3-819.68
    rule derivedTypeDeclaration-mono: cursor TC_0 |- declaration : TC_1 typedefDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: typedefDeclaration
    -- let typedefDeclaration = declaration as typedefDeclaration
    -- if typedefDeclaration matches `%TYPEDEF%%;`
    -- let annotationList typedef typedefType name ; = typedefDeclaration
    -- if typedefType <: derivedTypeDeclaration
    -- let derivedTypeDeclaration = typedefType as derivedTypeDeclaration
    -- Decl_ok: global TC_0 |- derivedTypeDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: derivedTypeDeclarationIR
    -- let derivedTypeDeclarationIR = declarationIR as derivedTypeDeclarationIR
    -- let { tid'*{tid' <- tid'*} } = $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.global.tdenv), $dom_map<tid, typeDefIR>(TC_0.global.tdenv))
    -- if tid'*{tid' <- tid'*} matches [ _/1 ]
    -- let [tid] = tid'*{tid' <- tid'*}
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(global, TC_1, ` tid)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR = typeDefIR as typeIR
    -- let nameIR = $name(name)
    -- let typeIR_typedef = typedef nameIR typeIR as typeIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_typedef as typeDefIR holds
    -- let TC_2 = $add_type(global, TC_0, nameIR, typeIR_typedef as typeDefIR)
    -- let typedefDeclarationIR = annotationList typedef derivedTypeDeclarationIR as typedefTypeIR nameIR ;

    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:821.3-839.68
    rule derivedTypeDeclaration-poly: cursor TC_0 |- declaration : TC_1 typedefDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: typedefDeclaration
    -- let typedefDeclaration = declaration as typedefDeclaration
    -- if typedefDeclaration matches `%TYPEDEF%%;`
    -- let annotationList typedef typedefType name ; = typedefDeclaration
    -- if typedefType <: derivedTypeDeclaration
    -- let derivedTypeDeclaration = typedefType as derivedTypeDeclaration
    -- Decl_ok: global TC_0 |- derivedTypeDeclaration as declaration : TC_1 declarationIR
    -- if declarationIR <: derivedTypeDeclarationIR
    -- let derivedTypeDeclarationIR = declarationIR as derivedTypeDeclarationIR
    -- let { tid'*{tid' <- tid'*} } = $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.global.tdenv), $dom_map<tid, typeDefIR>(TC_0.global.tdenv))
    -- if tid'*{tid' <- tid'*} matches [ _/1 ]
    -- let [tid] = tid'*{tid' <- tid'*}
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_type(global, TC_1, ` tid)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: polyTypeDefIR
    -- let typeIR < tid''*{tid'' <- tid''*} , tid'''*{tid''' <- tid'''*} > = typeDefIR as polyTypeDefIR
    -- if tid''*{tid'' <- tid''*} matches []
    -- if tid'''*{tid''' <- tid'''*} matches []
    -- let nameIR = $name(name)
    -- let typeIR_typedef = typedef nameIR typeIR < [] , [] > < [] > as typeIR as typeIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_typedef as typeDefIR holds
    -- let TC_2 = $add_type(global, TC_0, nameIR, typeIR_typedef as typeDefIR)
    -- let typedefDeclarationIR = annotationList typedef derivedTypeDeclarationIR as typedefTypeIR nameIR ;
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:845.1-858.45
  rulegroup typeDeclaration-typedefDeclaration-newtype {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:845.1-858.45
    rule typeDeclaration-typedefDeclaration-newtype: cursor TC_0 |- declaration : TC_1 typedefDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: typedefDeclaration
    -- let typedefDeclaration = declaration as typedefDeclaration
    -- if typedefDeclaration matches `%TYPE%%;`
    -- let annotationList type type name ; = typedefDeclaration
    -- Type_ok: global TC_0 |- type as typeOrVoid : typeIR # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- if Type_wf: $bound(global, TC_0) |- typeIR holds
    -- let nameIR = $name(name)
    -- let typeIR_newtype = type nameIR typeIR as typeIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeIR_newtype as typeDefIR holds
    -- let TC_1 = $add_type(global, TC_0, nameIR, typeIR_newtype as typeDefIR)
    -- let typedefDeclarationIR = annotationList type typeIR nameIR ;
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:864.1-885.86
  rulegroup typeDeclaration-parserTypeDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:864.1-885.86
    rule typeDeclaration-parserTypeDeclaration: cursor TC_0 |- declaration : TC_3 parserTypeDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: parserTypeDeclaration
    -- let annotationList parser name typeParameterListOpt ( parameterList ); = declaration as parserTypeDeclaration
    -- let TC_1 = TC_0[block.kind = parser]
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_2 = $add_types(block, TC_1, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: block TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let nameIR = $name(name)
    -- let typeIR_parser = parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
    -- let typeDefIR_parser = typeIR_parser < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_parser holds
    -- let TC_3 = $add_type(global, TC_0, nameIR, typeDefIR_parser)
    -- let parserTypeDeclarationIR = annotationList parser nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} );
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:891.1-912.87
  rulegroup typeDeclaration-controlTypeDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:891.1-912.87
    rule typeDeclaration-controlTypeDeclaration: cursor TC_0 |- declaration : TC_3 controlTypeDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: controlTypeDeclaration
    -- let annotationList control name typeParameterListOpt ( parameterList ); = declaration as controlTypeDeclaration
    -- let TC_1 = TC_0[block.kind = control]
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_2 = $add_types(block, TC_1, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: block TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let nameIR = $name(name)
    -- let typeIR_control = control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
    -- let typeDefIR_control = typeIR_control < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as typeDefIR
    -- if TypeDef_wf: $bound(global, TC_0) |- typeDefIR_control holds
    -- let TC_3 = $add_type(global, TC_0, nameIR, typeDefIR_control)
    -- let controlTypeDeclarationIR = annotationList control nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} );
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:918.1-952.40
  rulegroup typeDeclaration-packageTypeDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:918.1-952.40
    rule typeDeclaration-packageTypeDeclaration: cursor TC_0 |- declaration : TC_4 packageTypeDeclarationIR as declarationIR
    -- if cursor matches `GLOBAL`
    -- if declaration <: packageTypeDeclaration
    -- let annotationList package name typeParameterListOpt ( parameterList ); = declaration as packageTypeDeclaration
    -- let TC_1 = TC_0[block.kind = package]
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_2 = $add_types(block, TC_1, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- let constructorParameter*{constructorParameter <- constructorParameter*} = $flatten_parameterList(parameterList)
    -- ConstructorParameters_ok: block TC_2 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let constructorParameterTypeIR = $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}
    -- let nameIR = $name(name)
    -- (let _direction typeIR_package_inner _id _value?{_value <- _value?} = constructorParameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, constructorParameterTypeIR <- constructorParameterTypeIR*, typeIR_package_inner <- typeIR_package_inner*}
    -- let typeIR_package = package< typeIR_package_inner*{typeIR_package_inner <- typeIR_package_inner*} > as typeIR
    -- let polyTypeDefIR_package = typeIR_package < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >
    -- if TypeDef_wf: $bound(global, TC_0) |- polyTypeDefIR_package as typeDefIR holds
    -- let TC_3 = $add_type(global, TC_0, nameIR, polyTypeDefIR_package as typeDefIR)
    -- let cid = $cid(name, ( parameterList ))
    -- let typeIR_package_spec = polyTypeDefIR_package < tid tid_expl as typeIR*{tid_expl <- tid_expl*} ++ tid tid_impl as typeIR*{tid_impl <- tid_impl*} > as typeIR
    -- let constructorTypeIR = constructor( constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} )-> typeIR_package_spec
    -- let constructorTypeDefIR = constructorTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >
    -- if ConstructorTypeDef_wf: $bound(global, TC_0) |- constructorTypeDefIR holds
    -- let TC_4 = $add_constructor(TC_3, cid, constructorTypeDefIR)
    -- let packageTypeDeclarationIR = annotationList package nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} );
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:266.1-268.23
relation Decls_ok: cursor typingContext |- declaration* : typingContext declarationIR*

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:958.1-959.23
  rulegroup nil {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:958.1-959.23
    rule nil: p TC |- declaration*{declaration <- declaration*} : TC []
    -- if declaration*{declaration <- declaration*} matches []
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:961.1-965.64
  rulegroup cons {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:961.1-965.64
    rule cons: p TC_0 |- declaration*{declaration <- declaration*} : TC_2 declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*}
    -- if declaration*{declaration <- declaration*} matches _ :: _
    -- let declaration_h :: declaration_t*{declaration_t <- declaration_t*} = declaration*{declaration <- declaration*}
    -- Decl_ok: p TC_0 |- declaration_h : TC_1 declarationIR_h
    -- Decls_ok: p TC_1 |- declaration_t*{declaration_t <- declaration_t*} : TC_2 declarationIR_t*{declarationIR_t <- declarationIR_t*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:270.1-272.17
relation Program_ok: |- p4program : typingContext p4programIR

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:971.1-975.65
  rulegroup  {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:971.1-975.65
    rule : |- p4program : TC_1 declarationIR*{declarationIR <- declarationIR*} ;
    -- let declaration*{declaration <- declaration*} = $flatten_p4program(p4program)
    -- let TC_0 = $empty_typingContext
    -- Decls_ok: global TC_0 |- declaration*{declaration <- declaration*} : TC_1 declarationIR*{declarationIR <- declarationIR*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:282.18-282.35
syntax actctxt = 
   | action
   | noaction

;; ../../../../spec-concrete/5.04-typing-relation.watsup:284.1-287.29
relation Call_convention_expr_ok: cursor typingContext actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:51.1-56.59
  rulegroup in {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:51.1-56.59
    rule in: p TC actctxt |- direction typeIR_param _id _value?{_value <- _value?} @ typedExpressionIR_arg : typedExpressionIR_arg_cast
    -- if direction matches `IN`
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:101.1-109.51
  rulegroup out-inout {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:101.1-109.51
    rule out-inout: p TC actctxt |- direction typeIR_param _id _value?{_value <- _value?} @ typedExpressionIR_arg : typedExpressionIR_arg
    -- if ((direction = out) \/ (direction = inout))
    -- let _expressionIR # ( typeIR_arg _ctk ) = typedExpressionIR_arg
    -- if Type_alpha: typeIR_param ~~ typeIR_arg holds
    -- if Expr_lvalue_ok: p TC |- typedExpressionIR_arg holds
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:113.1-131.2
  rulegroup empty {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:115.3-120.61
    rule action: p TC actctxt |- direction typeIR_param _id _value?{_value <- _value?} @ typedExpressionIR_arg : typedExpressionIR_arg_cast
    -- if actctxt matches `ACTION`
    -- if direction matches ``EMPTY`
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_arg, typeIR_param)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_arg_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}

    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:122.3-129.26
    rule non-action: p TC actctxt |- direction typeIR_param _id _value?{_value <- _value?} @ typedExpressionIR_arg : typedExpressionIR_arg
    -- if actctxt matches `NOACTION`
    -- if direction matches ``EMPTY`
    -- let _expressionIR # ( typeIR_arg ctk_arg ) = typedExpressionIR_arg
    -- if Type_alpha: typeIR_param ~~ typeIR_arg holds
    -- if (ctk_arg =/= dyn)
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:289.1-292.29
relation Call_convention_argument_ok: cursor typingContext actctxt |- parameterTypeIR @ argumentIR : argumentIR

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:137.1-142.45
  rulegroup typedExpression {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:137.1-142.45
    rule typedExpression: p TC actctxt |- parameterTypeIR @ argumentIR : typedExpressionIR_cast as argumentIR
    -- if argumentIR <: typedExpressionIR
    -- let typedExpressionIR = argumentIR as typedExpressionIR
    -- Call_convention_expr_ok: p TC actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR_cast
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:146.1-151.45
  rulegroup nameIR-typedExpression {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:146.1-151.45
    rule nameIR-typedExpression: p TC actctxt |- parameterTypeIR @ argumentIR : nameIR = typedExpressionIR_cast
    -- if argumentIR matches `%=%`
    -- let nameIR = typedExpressionIR = argumentIR
    -- Call_convention_expr_ok: p TC actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR_cast
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:155.1-158.36
  rulegroup nameIR-dontcare {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:155.1-158.36
    rule nameIR-dontcare: p TC actctxt |- parameterTypeIR @ argumentIR : nameIR =_
    -- if argumentIR matches `%=_`
    -- let nameIR =_ = argumentIR
    -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR
    -- if direction matches `OUT`
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:162.1-164.36
  rulegroup dontcare {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:162.1-164.36
    rule dontcare: p TC actctxt |- parameterTypeIR @ argumentIR : _
    -- if argumentIR matches `_`
    -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR
    -- if direction matches `OUT`
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:294.1-297.29
relation Call_convention_ok: cursor typingContext actctxt |- parameterTypeIR* @ argumentListIR : argumentListIR

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:170.1-171.35
  rulegroup nil {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:170.1-171.35
    rule nil: p TC actctxt |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : []
    -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:173.1-182.41
  rulegroup cons {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:173.1-182.41
    rule cons: p TC actctxt |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_h_cast :: argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*}
    -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
    -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
    -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
    -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
    -- Call_convention_argument_ok: p TC actctxt |- parameterTypeIR_h @ argumentIR_h : argumentIR_h_cast
    -- Call_convention_ok: p TC actctxt |- parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} @ argumentIR_t*{argumentIR_t <- argumentIR_t*} : argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*}
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:307.1-307.52
def $is_static_routineTarget(routineTargetIR) : ctk =

  ;; ../../../../spec-concrete/5.04-typing-relation.watsup:309.1-311.56
  clause 0(routineTargetIR) = lctk
  -- if routineTargetIR matches `%.%`
  -- let _typedExpressionIR . nameIR = routineTargetIR
  -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

  ;; ../../../../spec-concrete/5.04-typing-relation.watsup:312.1-314.56
  clause 1(routineTargetIR) = lctk
  -- if routineTargetIR matches `TYPE%.%`
  -- let type _prefixedNameIR . nameIR = routineTargetIR
  -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]

  ;; ../../../../spec-concrete/5.04-typing-relation.watsup:315.1-316.15
  clause 2(_routineTargetIR) = dyn
  -- otherwise

;; ../../../../spec-concrete/5.04-typing-relation.watsup:318.1-320.23
relation RoutineTarget_ok: cursor typingContext |- routineTarget : routineTargetIR

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:12.1-18.74
  rulegroup prefixedNonTypeName {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:12.1-18.74
    rule prefixedNonTypeName: p TC |- routineTarget : prefixedNameIR as routineTargetIR
    -- if routineTarget <: prefixedNonTypeName
    -- let prefixedNonTypeName = routineTarget as prefixedNonTypeName
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- if (((prefixedNameIR = ` "verify") \/ (prefixedNameIR = . "verify")) => (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind))))
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:22.1-23.29
  rulegroup this {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:22.1-23.29
    rule this: p TC |- routineTarget : ` "this" as routineTargetIR
    -- if (routineTarget = this as routineTarget)
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:31.1-34.31
  rulegroup memberAccessExpression-prefixedTypeName {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:31.1-34.31
    rule memberAccessExpression-prefixedTypeName: p TC |- routineTarget : type prefixedNameIR . nameIR
    -- if routineTarget <: memberAccessExpression
    -- let memberAccessBase . member = routineTarget as memberAccessExpression
    -- if memberAccessBase <: prefixedTypeName
    -- let prefixedTypeName = memberAccessBase as prefixedTypeName
    -- let prefixedNameIR = $prefixedTypeName(prefixedTypeName)
    -- let nameIR = $name(member)
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:38.1-41.63
  rulegroup memberAccessExpression-expression {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:38.1-41.63
    rule memberAccessExpression-expression: p TC |- routineTarget : typedExpressionIR_base . nameIR
    -- if routineTarget <: memberAccessExpression
    -- let memberAccessBase . member = routineTarget as memberAccessExpression
    -- if memberAccessBase <: expression
    -- let expression_base = memberAccessBase as expression
    -- let nameIR = $name(member)
    -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:45.1-47.60
  rulegroup parenthesizedExpression {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:45.1-47.60
    rule parenthesizedExpression: p TC |- routineTarget : ( routineTargetIR )
    -- if routineTarget <: parenthesizedExpression
    -- let ( expression ) = routineTarget as parenthesizedExpression
    -- RoutineTarget_ok: p TC |- expression : routineTargetIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:322.1-324.23
relation RoutineTarget_lvalue_ok: cursor typingContext |- lvalue : routineTargetIR

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:69.1-72.60
  rulegroup  {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:69.1-72.60
    rule : p TC |- lvalue : routineTargetIR
    -- let expression = $lvalue(lvalue)
    -- RoutineTarget_ok: p TC |- expression : routineTargetIR
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:326.1-329.29
relation RoutineType_ok: cursor typingContext |- routineTargetIR < typeArgumentListIR >( argumentIR* ): routineTypeIR <# tid* >(# id* )

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:83.1-93.45
  rulegroup referenceExpressionIR {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:83.1-93.45
    rule referenceExpressionIR: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): functionTypeIR as routineTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
    -- if routineTargetIR <: prefixedNameIR
    -- let prefixedNameIR = routineTargetIR as prefixedNameIR
    -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_routine_overloaded(p, TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*})
    -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
    -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
    -- let (routineTypeDefIR, tid*) = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- if (routineTypeDefIR, tid*) <: (functionTypeIR, tid*)
    -- let (functionTypeIR, tid_impl*{tid_impl <- tid_impl*}) = (routineTypeDefIR, tid*) as (functionTypeIR, tid*)
    -- let bound = $union_set<tid>($bound(p, TC), { tid_impl*{tid_impl <- tid_impl*} })
    -- if RoutineType_wf: bound |- functionTypeIR as routineTypeIR holds
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:97.1-103.55
  rulegroup typedExpressionIR-nameIR-builtin-method-minmax-SizeIn-BitsBytes {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:97.1-103.55
    rule typedExpressionIR-nameIR-builtin-method-minmax-SizeIn-BitsBytes: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# [] )
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
    -- let methodTypeIR = builtin_method( [] )-> int as typeIR
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:105.1-116.67
  rulegroup typedExpressionIR-nameIR-builtin-method-stack-push-pop-front {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:105.1-116.67
    rule typedExpressionIR-nameIR-builtin-method-stack-push-pop-front: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR'*{argumentIR' <- argumentIR'*} ): methodTypeIR as routineTypeIR <# [] >(# [] )
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR'*{argumentIR' <- argumentIR'*} matches [ _/1 ]
    -- let [argumentIR] = argumentIR'*{argumentIR' <- argumentIR'*}
    -- if nameIR <- ["push_front", "pop_front"]
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR
    -- let parameterTypeIR = int as typeIR "count" ?()
    -- let methodTypeIR = builtin_method( [parameterTypeIR] )-> int as typeIR
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:118.1-127.56
  rulegroup typedExpressionIR-nameIR-builtin-method-header-isValid {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:118.1-127.56
    rule typedExpressionIR-nameIR-builtin-method-header-isValid: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# [] )
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- if nameIR <- ["isValid"]
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: headerTypeIR
    -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR
    -- let methodTypeIR = builtin_method( [] )-> bool as typeIR
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:129.1-138.56
  rulegroup typedExpressionIR-nameIR-builtin-method-union-isValid {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:129.1-138.56
    rule typedExpressionIR-nameIR-builtin-method-union-isValid: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# [] )
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- if nameIR <- ["isValid"]
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: headerUnionTypeIR
    -- let header_union _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerUnionTypeIR
    -- let methodTypeIR = builtin_method( [] )-> bool as typeIR
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:140.1-149.56
  rulegroup typedExpressionIR-nameIR-builtin-method-header-set-ValidInvalid {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:140.1-149.56
    rule typedExpressionIR-nameIR-builtin-method-header-set-ValidInvalid: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# [] )
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- if nameIR <- ["setValid", "setInvalid"]
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: headerTypeIR
    -- let header _tid { _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*} } = typeIR as headerTypeIR
    -- let methodTypeIR = builtin_method( [] )-> void as typeIR
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:151.1-169.44
  rulegroup typedExpressionIR-nameIR-extern-method {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:151.1-169.44
    rule typedExpressionIR-nameIR-extern-method: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . nameIR = routineTargetIR
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: externObjectTypeIR
    -- let extern _tid { rid_f : routineTypeDefIR_f*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*} } = typeIR as externObjectTypeIR
    -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
    -- let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} = $find_overloaded<routineTypeDefIR>({ rid_f : routineTypeDefIR_f*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*} }, nameIR, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
    -- if (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches (_)
    -- let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) = (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?}
    -- let (routineTypeDefIR, tid*) = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- if (routineTypeDefIR, tid*) <: (routineTypeIR, tid*)
    -- let (routineTypeIR, tid_impl*{tid_impl <- tid_impl*}) = (routineTypeDefIR, tid*) as (routineTypeIR, tid*)
    -- let bound = $union_set<tid>($bound(p, TC), { tid_impl*{tid_impl <- tid_impl*} })
    -- if RoutineType_wf: bound |- routineTypeIR holds
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:171.1-189.22
  rulegroup typedExpressionIR-nameIR-parser-apply-method {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:171.1-189.22
    rule typedExpressionIR-nameIR-parser-apply-method: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# id_default*{id_default <- id_default*} )
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . text = routineTargetIR
    -- if (text = "apply")
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: parserObjectTypeIR
    -- let parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as parserObjectTypeIR
    -- let methodTypeIR = parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
    -- (let _direction _typeIR id_param value_param?{value_param <- value_param?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}
    -- (let pid = id_param # (value_param?{value_param <- value_param?} =/= ?()))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}
    -- let rid = "apply" ( pid*{pid <- pid*} )
    -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
    -- let (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} = $find_overloaded<routineTypeDefIR>({ [rid : methodTypeIR as routineTypeDefIR] }, "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
    -- if (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} matches (_)
    -- let ?((rid, routineTypeDefIR, id*)) = (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?}
    -- if (rid, routineTypeDefIR, id*) <: (rid, methodTypeIR, id*)
    -- let (rid', methodTypeIR', id_default*{id_default <- id_default*}) = (rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)
    -- if (rid' = rid)
    -- if (methodTypeIR' = methodTypeIR)
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:191.1-209.22
  rulegroup typedExpressionIR-nameIR-control-apply-method {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:191.1-209.22
    rule typedExpressionIR-nameIR-control-apply-method: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# id_default*{id_default <- id_default*} )
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . text = routineTargetIR
    -- if (text = "apply")
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: controlObjectTypeIR
    -- let control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = typeIR as controlObjectTypeIR
    -- let methodTypeIR = control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )
    -- (let _direction _typeIR id_param value_param?{value_param <- value_param?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}
    -- (let pid = id_param # (value_param?{value_param <- value_param?} =/= ?()))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}
    -- let rid = "apply" ( pid*{pid <- pid*} )
    -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments(argumentIR*{argumentIR <- argumentIR*})
    -- let (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} = $find_overloaded<routineTypeDefIR>({ [rid : methodTypeIR as routineTypeDefIR] }, "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
    -- if (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?} matches (_)
    -- let ?((rid, routineTypeDefIR, id*)) = (rid, routineTypeDefIR, id*)'?{(rid, routineTypeDefIR, id*)' <- (rid, routineTypeDefIR, id*)'?}
    -- if (rid, routineTypeDefIR, id*) <: (rid, methodTypeIR, id*)
    -- let (rid', methodTypeIR', id_default*{id_default <- id_default*}) = (rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)
    -- if (rid' = rid)
    -- if (methodTypeIR' = methodTypeIR)
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:211.1-218.52
  rulegroup typedExpressionIR-nameIR-table-apply-method {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:211.1-218.52
    rule typedExpressionIR-nameIR-table-apply-method: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): methodTypeIR as routineTypeIR <# [] >(# [] )
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR_base . text = routineTargetIR
    -- if (text = "apply")
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- let _expressionIR # ( typeIR_base _ctk ) = typedExpressionIR_base
    -- let typeIR = $canon(typeIR_base)
    -- if typeIR <: tableObjectTypeIR
    -- let table _tid # typeIR_table = typeIR as tableObjectTypeIR
    -- let methodTypeIR = table_apply-> typeIR_table
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:224.1-228.85
  rulegroup parenthesized {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:224.1-228.85
    rule parenthesized: p TC |- routineTargetIR' < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
    -- if routineTargetIR' matches `(%)`
    -- let ( routineTargetIR ) = routineTargetIR'
    -- RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): routineTypeIR <# tid_inserted*{tid_inserted <- tid_inserted*} >(# id_default*{id_default <- id_default*} )
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:336.1-340.35
relation Call_ok: cursor typingContext |- routineTypeIR < typeArgumentListIR # tid* >( argumentListIR # id* ): typeIR < typeArgumentListIR >( argumentListIR )

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:245.1-262.40
  rulegroup builtin-function {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:245.1-262.40
    rule builtin-function: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `BUILTIN_FUNCTION(%)->%`
    -- let builtin_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
    -- if tid*{tid <- tid*} matches []
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- if $callable_builtin_function(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:276.1-306.40
  rulegroup function {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:276.1-306.40
    rule function: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret_inferred < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `FUNCTION(%)->%`
    -- let function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
    -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
    -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
    -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
    -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
    -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
    -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
    -- let functionTypeIR_inferred = function( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_ret_inferred
    -- if RoutineType_wf: $bound(p, TC) |- functionTypeIR_inferred as routineTypeIR holds
    -- if $callable_function(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:318.1-348.40
  rulegroup externfunction {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:318.1-348.40
    rule externfunction: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret_inferred < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `EXTERN_FUNCTION(%)->%`
    -- let extern_function( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = functionTypeIR
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
    -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
    -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
    -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
    -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
    -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
    -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
    -- let functionTypeIR_inferred = extern_function( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_ret_inferred
    -- if RoutineType_wf: $bound(p, TC) |- functionTypeIR_inferred as routineTypeIR holds
    -- if $callable_extern_function(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:360.1-376.38
  rulegroup action {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:360.1-376.38
    rule action: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): void as typeIR < [] >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if routineTypeIR <: functionTypeIR
    -- let functionTypeIR = routineTypeIR as functionTypeIR
    -- if functionTypeIR matches `ACTION(%)`
    -- let action( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = functionTypeIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if tid*{tid <- tid*} matches []
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- if $callable_action(p, TC)
    -- Call_convention_ok: p TC action |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:389.1-406.40
  rulegroup builtin-method {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:389.1-406.40
    rule builtin-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `BUILTIN_METHOD(%)->%`
    -- let builtin_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
    -- if tid*{tid <- tid*} matches []
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- if $callable_builtin_method(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:418.1-448.40
  rulegroup extern-method {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:418.1-448.40
    rule extern-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret_inferred < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
    -- let extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
    -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
    -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
    -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
    -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
    -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
    -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
    -- let methodTypeIR_inferred = extern_method( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_ret_inferred
    -- if RoutineType_wf: $bound(p, TC) |- methodTypeIR_inferred as routineTypeIR holds
    -- if $callable_extern_method(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:460.1-490.40
  rulegroup extern-abstract-method {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:460.1-490.40
    rule extern-abstract-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_ret_inferred < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
    -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
    -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
    -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
    -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
    -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
    -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
    -- let typeIR_ret_inferred = $subst_type(inference, typeIR_ret)
    -- let methodTypeIR_inferred = extern_methodabstract( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_ret_inferred
    -- if RoutineType_wf: $bound(p, TC) |- methodTypeIR_inferred as routineTypeIR holds
    -- if $callable_extern_abstract_method(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:501.1-518.40
  rulegroup parser-apply-method {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:501.1-518.40
    rule parser-apply-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): void as typeIR < [] >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `PARSER_APPLY(%)`
    -- let parser_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if tid*{tid <- tid*} matches []
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- if $callable_parser_apply_method(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:529.1-546.40
  rulegroup control-apply-method {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:529.1-546.40
    rule control-apply-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): void as typeIR < [] >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `CONTROL_APPLY(%)`
    -- let control_apply( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) = methodTypeIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if tid*{tid <- tid*} matches []
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- if $callable_control_apply_method(p, TC)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:558.1-562.44
  rulegroup table-apply-method {


    ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:558.1-562.44
    rule table-apply-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id*{id <- id*} ): typeIR_table < [] >( [] )
    -- if routineTypeIR <: methodTypeIR
    -- let methodTypeIR = routineTypeIR as methodTypeIR
    -- if methodTypeIR matches `TABLE_APPLY->%`
    -- let table_apply-> typeIR_table = methodTypeIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if tid*{tid <- tid*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- if id*{id <- id*} matches []
    -- if $callable_table_apply_method(p, TC)
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:350.1-353.29
relation ConstructorType_ok: cursor typingContext |- prefixedNameIR < typeArgumentListIR >( argumentIR* ): constructorTypeIR <# tid* >(# id* )

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:5.1-15.52
  rulegroup  {


    ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:5.1-15.52
    rule : p TC |- prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): constructorTypeIR <# tid_impl*{tid_impl <- tid_impl*} >(# id_default*{id_default <- id_default*} )
    -- let (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} = $find_constructor_overloaded(TC, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*})
    -- if (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} matches (_)
    -- let ?((cid, constructorTypeDefIR, id_default*{id_default <- id_default*})) = (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?}
    -- let (constructorTypeIR, tid_impl*{tid_impl <- tid_impl*}) = $specialize_constructorTypeDef(constructorTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- let bound = $union_set<tid>($bound(p, TC), { tid_impl*{tid_impl <- tid_impl*} })
    -- if ConstructorType_wf: bound |- constructorTypeIR holds
  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:360.19-360.31
syntax instctxt = 
   | named
   | anon

;; ../../../../spec-concrete/5.04-typing-relation.watsup:362.1-369.38
relation Inst_ok: cursor typingContext instctxt |- constructorTypeIR < typeArgumentListIR # tid* >( argumentListIR # id* ): typeIR < typeArgumentListIR >( argumentListIR )

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:79.1-113.44
  rulegroup package {


    ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:79.1-113.44
    rule package: cursor TC instctxt |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object_inferred < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- if cursor matches `GLOBAL`
    -- let constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object = constructorTypeIR
    -- let typeIR = $canon(typeIR_object)
    -- if typeIR <: packageObjectTypeIR
    -- let package< _typeIR*{_typeIR <- _typeIR*} > = typeIR as packageObjectTypeIR
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
    -- (let typeIR'?{typeIR' <- typeIR'?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR'? <- typeIR'?*}
    -- (if typeIR'?{typeIR' <- typeIR'?} matches (_))*{typeIR'? <- typeIR'?*}
    -- (let ?(typeIR_inferred) = typeIR'?{typeIR' <- typeIR'?})*{typeIR'? <- typeIR'?*, typeIR_inferred <- typeIR_inferred*}
    -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
    -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
    -- let typeIR_object_inferred = $subst_type(inference, typeIR_object)
    -- let constructorTypeIR_inferred = constructor( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_object_inferred
    -- if ConstructorType_wf: $bound(global, TC) |- constructorTypeIR_inferred holds
    -- if $instantiable(global, TC, instctxt, typeIR_object_inferred)
    -- Call_convention_ok: block TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:117.1-151.40
  rulegroup non-package {


    ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:117.1-151.40
    rule non-package: p TC instctxt |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): typeIR_object_inferred < typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} >( argumentIR_cast*{argumentIR_cast <- argumentIR_cast*} )
    -- let constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object = constructorTypeIR
    -- if ~$is_package_object_typeIR($canon(typeIR_object))
    -- let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} = $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})
    -- if (|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)
    -- let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} = $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*})
    -- let inference = $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*})
    -- (let typeIR?{typeIR <- typeIR?} = $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}
    -- (if typeIR?{typeIR <- typeIR?} matches (_))*{typeIR? <- typeIR?*}
    -- (let ?(typeIR_inferred) = typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}
    -- let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} = typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*}
    -- (let parameterTypeIR_aligned_inferred = $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}
    -- let typeIR_object_inferred = $subst_type(inference, typeIR_object)
    -- let constructorTypeIR_inferred = constructor( parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} )-> typeIR_object_inferred
    -- if ConstructorType_wf: $bound(p, TC) |- constructorTypeIR_inferred holds
    -- if $instantiable(p, TC, instctxt, typeIR_object_inferred)
    -- Call_convention_ok: p TC noaction |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} @ argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}
  }

;; ../../../../spec-concrete/5.05.2-subtype.watsup:412.1-416.23
def $reduce_serenum_unary(typedExpressionIR, $check(typeIR) : bool) : typedExpressionIR? =

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:419.1-422.23
  clause 0(typedExpressionIR, $check) = ?(typedExpressionIR)
  -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
  -- if $check(typeIR)

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:424.1-430.79
  clause 1(typedExpressionIR, $check) = $reduce_serenum_unary(typedExpressionIR_cast, $check)
  -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
  -- if ~$check(typeIR)
  -- let typeIR' = typeIR
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR_underlying { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
  -- let typedExpressionIR_cast = ( typeIR_underlying ) typedExpressionIR as expressionIR # ( typeIR_underlying ctk )

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:432.1-433.15
  clause 2(typedExpressionIR, $check) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.05.2-subtype.watsup:437.1-442.44
def $reduce_serenum_binary(typedExpressionIR, typedExpressionIR, $check(typeIR, typeIR) : bool) : (typedExpressionIR, typedExpressionIR)? =

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:444.1-448.35
  clause 0(typedExpressionIR_l, typedExpressionIR_r, $check) = ?((typedExpressionIR_l, typedExpressionIR_r))
  -- let _expressionIR # ( typeIR_l _ctk ) = typedExpressionIR_l
  -- let _expressionIR' # ( typeIR_r _ctk' ) = typedExpressionIR_r
  -- if $check(typeIR_l, typeIR_r)

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:450.1-458.87
  clause 1(typedExpressionIR_l, typedExpressionIR_r, $check) = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r, $check)
  -- let _expressionIR # ( typeIR_l ctk_l ) = typedExpressionIR_l
  -- let _expressionIR' # ( typeIR_r _ctk ) = typedExpressionIR_r
  -- if ~$check(typeIR_l, typeIR_r)
  -- let typeIR = typeIR_l
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR_l_underlying { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
  -- let typedExpressionIR_l_cast = ( typeIR_l_underlying ) typedExpressionIR_l as expressionIR # ( typeIR_l_underlying ctk_l )

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:460.1-468.87
  clause 2(typedExpressionIR_l, typedExpressionIR_r, $check) = $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r_cast, $check)
  -- let _expressionIR # ( typeIR_l _ctk ) = typedExpressionIR_l
  -- let _expressionIR' # ( typeIR_r ctk_r ) = typedExpressionIR_r
  -- if ~$check(typeIR_l, typeIR_r)
  -- let typeIR = typeIR_r
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR_r_underlying { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR
  -- let typedExpressionIR_r_cast = ( typeIR_r_underlying ) typedExpressionIR_r as expressionIR # ( typeIR_r_underlying ctk_r )

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:470.1-471.15
  clause 3(typedExpressionIR_l, typedExpressionIR_r, $check) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.05.2-subtype.watsup:482.1-482.66
def $coerce_unary(typedExpressionIR, typeIR) : typedExpressionIR? =

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:484.1-486.37
  clause 0(typedExpressionIR, typeIR_to) = ?(typedExpressionIR)
  -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
  -- if Type_alpha: typeIR ~~ typeIR_to holds

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:488.1-493.63
  clause 1(typedExpressionIR, typeIR_to) = ?(typedExpressionIR_cast)
  -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
  -- if ~Type_alpha: typeIR ~~ typeIR_to holds
  -- if Sub_impl: typeIR <: typeIR_to holds
  -- let typedExpressionIR_cast = ( typeIR_to ) typedExpressionIR as expressionIR # ( typeIR_to ctk )

;; ../../../../spec-concrete/5.05.2-subtype.watsup:497.1-498.44
def $coerce_binary(typedExpressionIR, typedExpressionIR) : (typedExpressionIR, typedExpressionIR)? =

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:500.1-504.38
  clause 0(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l, typedExpressionIR_r))
  -- let _expressionIR # ( typeIR_l _ctk ) = typedExpressionIR_l
  -- let _expressionIR' # ( typeIR_r _ctk' ) = typedExpressionIR_r
  -- if Type_alpha: typeIR_l ~~ typeIR_r holds

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:506.1-513.65
  clause 1(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l_cast, typedExpressionIR_r))
  -- let _expressionIR # ( typeIR_l ctk_l ) = typedExpressionIR_l
  -- let _expressionIR' # ( typeIR_r _ctk ) = typedExpressionIR_r
  -- if ~Type_alpha: typeIR_l ~~ typeIR_r holds
  -- if Sub_impl: typeIR_l <: typeIR_r holds
  -- let typedExpressionIR_l_cast = ( typeIR_r ) typedExpressionIR_l as expressionIR # ( typeIR_r ctk_l )

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:515.1-523.65
  clause 2(typedExpressionIR_l, typedExpressionIR_r) = ?((typedExpressionIR_l, typedExpressionIR_r_cast))
  -- let _expressionIR # ( typeIR_l _ctk ) = typedExpressionIR_l
  -- let _expressionIR' # ( typeIR_r ctk_r ) = typedExpressionIR_r
  -- if ~Type_alpha: typeIR_l ~~ typeIR_r holds
  -- if ~Sub_impl: typeIR_l <: typeIR_r holds
  -- if Sub_impl: typeIR_r <: typeIR_l holds
  -- let typedExpressionIR_r_cast = ( typeIR_l ) typedExpressionIR_r as expressionIR # ( typeIR_l ctk_r )

  ;; ../../../../spec-concrete/5.05.2-subtype.watsup:525.1-526.15
  clause 3(typedExpressionIR_l, typedExpressionIR_r) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:80.1-80.32
def $compat_lnot(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:83.1-83.57
  clause 0(typeIR) = $compat'_lnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:81.1-81.33
def $compat'_lnot(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:84.1-84.31
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:85.1-86.14
  clause 1(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:101.1-101.32
def $compat_bnot(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:104.1-104.57
  clause 0(typeIR) = $compat'_bnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:102.1-102.33
def $compat'_bnot(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:105.1-105.37
  clause 0(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:106.1-106.37
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:107.1-108.15
  clause 2(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:123.1-123.38
def $compat_uplusminus(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:126.1-126.69
  clause 0(typeIR) = $compat'_uplusminus($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:124.1-124.39
def $compat'_uplusminus(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:127.1-127.36
  clause 0(typeIR) = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:128.1-128.43
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:129.1-129.43
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:130.1-131.15
  clause 3(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:149.1-149.49
def $compat_plusminusmult(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:152.1-153.63
  clause 0(typeIR_l, typeIR_r) = $compat'_plusminusmult($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:150.1-150.50
def $compat'_plusminusmult(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:154.1-154.44
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:155.1-155.58
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:156.1-156.58
  clause 2(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:157.1-158.15
  clause 3(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:186.1-186.48
def $compat_satplusminus(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:189.1-190.62
  clause 0(typeIR_l, typeIR_r) = $compat'_satplusminus($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:187.1-187.49
def $compat'_satplusminus(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:191.1-191.57
  clause 0(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:192.1-192.57
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:193.1-194.15
  clause 2(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:222.1-222.42
def $compat_divmod(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:225.1-226.56
  clause 0(typeIR_l, typeIR_r) = $compat'_divmod($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:223.1-223.43
def $compat'_divmod(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:227.1-227.37
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:228.1-229.15
  clause 1(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:293.1-293.41
def $compat_shift(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:296.1-297.55
  clause 0(typeIR_l, typeIR_r) = $compat'_shift($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:294.1-294.42
def $compat'_shift(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:298.1-298.36
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:299.1-299.43
  clause 1(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR = typeIR' as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:300.1-300.43
  clause 2(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR = typeIR' as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:301.1-301.43
  clause 3(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:302.1-302.50
  clause 4(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:303.1-303.50
  clause 5(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:304.1-304.43
  clause 6(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:305.1-305.50
  clause 7(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:306.1-306.50
  clause 8(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:307.1-308.15
  clause 9(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:388.1-388.43
def $compat_compare(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:391.1-392.57
  clause 0(typeIR_l, typeIR_r) = $compat'_compare($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:389.1-389.44
def $compat'_compare(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:393.1-393.38
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:394.1-394.52
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:395.1-395.52
  clause 2(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:396.1-397.15
  clause 3(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:425.1-425.43
def $compat_bitwise(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:428.1-429.57
  clause 0(typeIR_l, typeIR_r) = $compat'_bitwise($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:426.1-426.44
def $compat'_bitwise(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:430.1-430.52
  clause 0(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:431.1-431.52
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:432.1-433.15
  clause 2(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:461.1-461.42
def $compat_concat(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:464.1-465.56
  clause 0(typeIR_l, typeIR_r) = $compat'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:462.1-462.43
def $compat'_concat(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:466.1-466.51
  clause 0(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:467.1-467.51
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:468.1-468.51
  clause 2(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:469.1-469.51
  clause 3(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< _nat' > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:470.1-471.15
  clause 4(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:473.1-473.45
def $result_concat(typeIR, typeIR) : typeIR? =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:476.1-477.56
  clause 0(typeIR_l, typeIR_r) = $result'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:474.1-474.46
def $result'_concat(typeIR, typeIR) : typeIR? =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:478.1-478.72
  clause 0(typeIR, typeIR') = ?(int< (w_a + w_b) > as typeIR)
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w_a > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w_b > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:479.1-479.72
  clause 1(typeIR, typeIR') = ?(int< (w_a + w_b) > as typeIR)
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w_a > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w_b > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:480.1-480.72
  clause 2(typeIR, typeIR') = ?(bit< (w_a + w_b) > as typeIR)
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w_a > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w_b > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:481.1-481.72
  clause 3(typeIR, typeIR') = ?(bit< (w_a + w_b) > as typeIR)
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w_a > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w_b > = numberTypeIR'

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:482.1-483.15
  clause 4(typeIR_l, typeIR_r) = ?()
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:511.1-511.43
def $compat_logical(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:514.1-515.57
  clause 0(typeIR_l, typeIR_r) = $compat'_logical($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:512.1-512.44
def $compat'_logical(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:516.1-516.40
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = bool as typeIR)
  -- if (typeIR' = bool as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:517.1-518.15
  clause 1(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:905.1-905.39
def $compat_array_index(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:908.1-909.40
  clause 0(typeIR) = $compat'_arrayindex($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:906.1-906.39
def $compat'_arrayindex(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:910.1-910.36
  clause 0(typeIR) = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:911.1-911.43
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:912.1-912.43
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:913.1-914.15
  clause 3(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1000.1-1000.41
def $compat_bitslice_base(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1003.1-1004.43
  clause 0(typeIR) = $compat'_bitslice_base($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1001.1-1001.42
def $compat'_bitslice_base(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1005.1-1005.39
  clause 0(typeIR) = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1006.1-1006.50
  clause 1(typeIR) = (w > 0)
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1007.1-1007.46
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1008.1-1009.15
  clause 3(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1011.1-1011.42
def $compat_bitslice_index(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1014.1-1015.44
  clause 0(typeIR) = $compat'_bitslice_index($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1012.1-1012.43
def $compat'_bitslice_index(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1016.1-1016.40
  clause 0(typeIR) = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1017.1-1017.47
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1018.1-1018.47
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1019.1-1020.15
  clause 3(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1022.1-1022.48
def $is_valid_bitslice(typeIR, nat, nat) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1025.1-1026.71
  clause 0(typeIR, n_lo, n_hi) = ((n_lo <= n_hi) /\ $is_valid_bitslice'($canon(typeIR), n_lo, n_hi))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1023.1-1023.49
def $is_valid_bitslice'(typeIR, nat, nat) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1027.1-1027.42
  clause 0(typeIR, _nat, _nat') = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1028.1-1030.37
  clause 1(typeIR, n_lo, n_hi) = ((n_hi <= w) /\ (w_slice <= w))
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- let w_slice = ((n_hi - n_lo) + 1)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1031.1-1033.37
  clause 2(typeIR, n_lo, n_hi) = ((n_hi <= w) /\ (w_slice <= w))
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- let w_slice = ((n_hi - n_lo) + 1)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1034.1-1035.15
  clause 3(_typeIR, _nat, _nat') = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1154.1-1154.46
def $is_concrete_extern_object(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1159.1-1160.50
  clause 0(typeIR) = $is_concrete_extern_object'($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1155.1-1155.47
def $is_concrete_extern_object'(typeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1162.1-1163.42
  clause 0(typeIR) = true
  -- if ~$is_extern_object_typeIR(typeIR)

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1164.1-1165.58
  clause 1(typeIR) = true
  -- if typeIR <: externObjectTypeIR
  -- let extern _tid { _rid : routineTypeDefIR*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} } = typeIR as externObjectTypeIR
  -- (if $is_concrete_extern_object''(routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*}

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1166.1-1167.15
  clause 2(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1156.1-1156.58
def $is_concrete_extern_object''(routineTypeDefIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1169.1-1170.49
  clause 0(routineTypeDefIR) = $is_concrete_extern_object'''(routineTypeIR)
  -- if routineTypeDefIR <: routineTypeIR
  -- let routineTypeIR = routineTypeDefIR as routineTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1171.1-1172.50
  clause 1(routineTypeDefIR) = (true = $is_concrete_extern_object'''(routineTypeIR))
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < _tid*{_tid <- _tid*} , _tid'*{_tid' <- _tid'*} > = routineTypeDefIR as polyRoutineTypeDefIR

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1157.1-1157.56
def $is_concrete_extern_object'''(routineTypeIR) : bool =

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1174.1-1174.79
  clause 0(routineTypeIR) = false
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} )-> _typeIR = methodTypeIR

  ;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1175.1-1176.15
  clause 1(_routineTypeIR) = true
  -- otherwise

;; ../../../../spec-concrete/5.10-typing-statement.watsup:91.1-91.46
def $compat_direct_application(typeIR) : bool =

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:94.1-95.48
  clause 0(typeIR) = $compat'_direct_application($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:92.1-92.47
def $compat'_direct_application(typeIR) : bool =

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:96.1-96.54
  clause 0(typeIR) = true
  -- if typeIR <: parserObjectTypeIR
  -- let parser( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as parserObjectTypeIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:97.1-97.55
  clause 1(typeIR) = true
  -- if typeIR <: controlObjectTypeIR
  -- let control( _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} ) = typeIR as controlObjectTypeIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:98.1-99.15
  clause 2(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.10-typing-statement.watsup:213.1-215.26
relation SwitchLabel_table_ok: typingContext tid bool |- switchLabel : switchLabelIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:219.1-220.41
  rulegroup default {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:219.1-220.41
    rule default: TC tid_table bool |- switchLabel : default
    -- if (bool = true)
    -- if switchLabel matches `DEFAULT`
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:224.1-236.57
  rulegroup expressionNonBrace-prefixedNonTypeName {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:224.1-236.57
    rule expressionNonBrace-prefixedNonTypeName: TC tid_table _bool |- switchLabel : typedExpressionIR_label as switchLabelIR
    -- if switchLabel <: prefixedNonTypeName
    -- let prefixedNonTypeName = switchLabel as prefixedNonTypeName
    -- let prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
    -- if prefixedNameIR matches ``%`
    -- let ` nameIR_label = prefixedNameIR
    -- let tid_table_enum = "action_list(" ++ tid_table ++ ")"
    -- let id_label = tid_table_enum ++ "." ++ nameIR_label
    -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(local, TC, ` id_label)
    -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
    -- let ?(_direction typeIR_label ctk_label value?{value <- value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
    -- if value?{value <- value?} matches (_)
    -- let ?(value_label) = value?{value <- value?}
    -- if (value_label = table_enum tid_table_enum . nameIR_label as value)
    -- let typedExpressionIR_label = ` nameIR_label as expressionIR # ( typeIR_label ctk_label )
  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:242.1-244.29
relation SwitchCase_table_ok: typingContext flow tid bool |- switchCase : flow switchCaseIR # switchLabel

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:248.1-256.57
  rulegroup switchLabel-blockStatement {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:248.1-256.57
    rule switchLabel-blockStatement: TC f tid_table b_last |- switchCase : f_post switchCaseIR # switchLabel
    -- if switchCase matches `%:%`
    -- let switchLabel : blockStatement = switchCase
    -- SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR
    -- Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR
    -- let switchCaseIR = switchLabelIR : blockStatementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:260.1-266.40
  rulegroup switchLabel {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:260.1-266.40
    rule switchLabel: TC f tid_table b_last |- switchCase : f switchCaseIR # switchLabel
    -- if switchCase matches `%:`
    -- let switchLabel : = switchCase
    -- SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR
    -- let switchCaseIR = switchLabelIR :
  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:270.1-272.26
relation SwitchCases_table_ok: typingContext flow tid |- switchCase* : flow switchCaseListIR # switchLabel*

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:274.1-275.39
  rulegroup nil {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:274.1-275.39
    rule nil: TC f tid_table |- switchCase*{switchCase <- switchCase*} : f [] # []
    -- if switchCase*{switchCase <- switchCase*} matches []
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:277.1-284.80
  rulegroup cons {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:277.1-284.80
    rule cons: TC f tid_table |- switchCase*{switchCase <- switchCase*} : f_t switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} # switchLabel_h :: switchLabel_t*{switchLabel_t <- switchLabel_t*}
    -- if switchCase*{switchCase <- switchCase*} matches _ :: _
    -- let switchCase_h :: switchCase_t*{switchCase_t <- switchCase_t*} = switchCase*{switchCase <- switchCase*}
    -- let b_last = (switchCase_t*{switchCase_t <- switchCase_t*} = [])
    -- SwitchCase_table_ok: TC f tid_table b_last |- switchCase_h : f_h switchCaseIR_h # switchLabel_h
    -- SwitchCases_table_ok: TC f_h tid_table |- switchCase_t*{switchCase_t <- switchCase_t*} : f_t switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} # switchLabel_t*{switchLabel_t <- switchLabel_t*}
  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:309.1-311.26
relation SwitchLabel_general_ok: typingContext typeIR bool |- switchLabel : switchLabelIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:315.1-316.33
  rulegroup default {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:315.1-316.33
    rule default: TC _typeIR bool |- switchLabel : default
    -- if (bool = true)
    -- if switchLabel matches `DEFAULT`
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:320.1-328.56
  rulegroup expressionNonBrace {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:320.1-328.56
    rule expressionNonBrace: TC typeIR_switch _bool |- switchLabel : typedExpressionIR_label_cast as switchLabelIR
    -- if switchLabel <: expressionNonBrace
    -- let expressionNonBrace_label = switchLabel as expressionNonBrace
    -- let expression_label = $expressionNonBrace(expressionNonBrace_label)
    -- Expr_ok: local TC |- expression_label : typedExpressionIR_label
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_label, typeIR_switch)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_label_cast) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR_label_cast
    -- if ctk matches `LCTK`
  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:332.1-334.29
relation SwitchCase_general_ok: typingContext flow typeIR bool |- switchCase : flow switchCaseIR # switchLabel

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:338.1-346.57
  rulegroup switchLabel-blockStatement {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:338.1-346.57
    rule switchLabel-blockStatement: TC f typeIR_switch b_last |- switchCase : f_post switchCaseIR # switchLabel
    -- if switchCase matches `%:%`
    -- let switchLabel : blockStatement = switchCase
    -- SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR
    -- Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR
    -- let switchCaseIR = switchLabelIR : blockStatementIR
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:350.1-356.40
  rulegroup switchLabel {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:350.1-356.40
    rule switchLabel: TC f typeIR_switch b_last |- switchCase : f switchCaseIR # switchLabel
    -- if switchCase matches `%:`
    -- let switchLabel : = switchCase
    -- SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR
    -- let switchCaseIR = switchLabelIR :
  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:360.1-362.26
relation SwitchCases_general_ok: typingContext flow typeIR |- switchCase* : flow switchCaseListIR # switchLabel*

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:364.1-365.43
  rulegroup nil {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:364.1-365.43
    rule nil: TC f typeIR_switch |- switchCase*{switchCase <- switchCase*} : f [] # []
    -- if switchCase*{switchCase <- switchCase*} matches []
  }

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:367.1-375.84
  rulegroup cons {


    ;; ../../../../spec-concrete/5.10-typing-statement.watsup:367.1-375.84
    rule cons: TC f typeIR_switch |- switchCase*{switchCase <- switchCase*} : f_t switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} # switchLabel_h :: switchLabel_t*{switchLabel_t <- switchLabel_t*}
    -- if switchCase*{switchCase <- switchCase*} matches _ :: _
    -- let switchCase_h :: switchCase_t*{switchCase_t <- switchCase_t*} = switchCase*{switchCase <- switchCase*}
    -- let b_last = (switchCase_t*{switchCase_t <- switchCase_t*} = [])
    -- SwitchCase_general_ok: TC f typeIR_switch b_last |- switchCase_h : f_h switchCaseIR_h # switchLabel_h
    -- SwitchCases_general_ok: TC f_h typeIR_switch |- switchCase_t*{switchCase_t <- switchCase_t*} : f_t switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} # switchLabel_t*{switchLabel_t <- switchLabel_t*}
  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:377.1-377.34
def $compat_switch(typeIR) : bool =

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:380.1-381.36
  clause 0(typeIR) = $compat'_switch($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:378.1-378.35
def $compat'_switch(typeIR) : bool =

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:382.1-382.34
  clause 0(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:383.1-383.39
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:384.1-384.39
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:385.1-385.42
  clause 3(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:386.1-386.47
  clause 4(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # _typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.10-typing-statement.watsup:387.1-388.15
  clause 5(typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:92.1-95.29
relation Decl_object_ok: cursor typingContext frame rdenv |- objectDeclaration : frame rdenv objectDeclarationIR

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:105.1-140.27
  rulegroup functionDeclaration {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:105.1-140.27
    rule functionDeclaration: p TC_0 frame rdenv |- objectDeclaration : frame rdenv_init functionDeclarationIR as objectDeclarationIR
    -- if objectDeclaration <: functionDeclaration
    -- let annotationList typeOrVoid name typeParameterListOpt ( parameterList ) blockStatement = objectDeclaration as functionDeclaration
    -- let TC_1 = TC_0[block.kind = extern]
    -- let TC_2 = TC_1[block.frame = frame]
    -- let typeParameter*{typeParameter <- typeParameter*} = $flatten_typeParameterListOpt(typeParameterListOpt)
    -- (let tid_expl = $name(typeParameter))*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}
    -- let TC_3 = $add_types(local, TC_2, tid_expl*{tid_expl <- tid_expl*}, tid tid_expl as typeDefIR*{tid_expl <- tid_expl*})
    -- Type_ok: local TC_3 |- typeOrVoid : typeIR_ret # tid*{tid <- tid*}
    -- if tid*{tid <- tid*} matches []
    -- let parameter*{parameter <- parameter*} = $flatten_parameterList(parameterList)
    -- Parameters_ok: local TC_3 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} # tid_impl*{tid_impl <- tid_impl*}
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let TC_4 = $add_parameters(local, TC_3, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})
    -- let TC_5 = TC_4[local.kind = extern_method-> typeIR_ret]
    -- Block_ok: TC_5 cont |- blockStatement : _typingContext f blockStatementIR
    -- if ((f = ret) \/ (typeIR_ret = void as typeIR))
    -- let rid = $rid(name, parameterList)
    -- let methodTypeIR = extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret
    -- let routineTypeDefIR = methodTypeIR as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
    -- if RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds
    -- let rdenv_init = $update_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR)
    -- let nameIR = $name(name)
    -- let functionDeclarationIR = annotationList typeIR_ret nameIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} >( parameterIR*{parameterIR <- parameterIR*} ) blockStatementIR
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:144.1-153.61
  rulegroup instantiation {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:144.1-153.61
    rule instantiation: p TC_0 frame rdenv |- objectDeclaration : frame_init rdenv instantiationIR as objectDeclarationIR
    -- if objectDeclaration <: instantiation
    -- let instantiation = objectDeclaration as instantiation
    -- Decl_ok: p TC_0 |- instantiation as declaration : TC_1 declarationIR
    -- if declarationIR <: instantiationIR
    -- let instantiationIR = declarationIR as instantiationIR
    -- let _annotationList _prefixedNameIR < _typeArgumentListIR >( _argumentListIR ) nameIR _objectInitializerOptIR ; = instantiationIR
    -- let varTypeIR'?{varTypeIR' <- varTypeIR'?} = $find_var(p, TC_1, ` nameIR)
    -- if varTypeIR'?{varTypeIR' <- varTypeIR'?} matches (_)
    -- let ?(varTypeIR) = varTypeIR'?{varTypeIR' <- varTypeIR'?}
    -- let frame_init = $update_map<id, varTypeIR>(frame, nameIR, varTypeIR)
  }

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:155.1-158.29
relation Decls_object_ok: cursor typingContext frame rdenv |- objectDeclaration* : frame rdenv objectDeclarationListIR

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:160.1-161.44
  rulegroup nil {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:160.1-161.44
    rule nil: p TC frame rdenv |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : frame rdenv []
    -- if objectDeclaration*{objectDeclaration <- objectDeclaration*} matches []
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:163.1-171.69
  rulegroup cons {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:163.1-171.69
    rule cons: p TC frame_0 rdenv_0 |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : frame_2 rdenv_2 objectDeclarationIR_h :: objectDeclarationIR_t*{objectDeclarationIR_t <- objectDeclarationIR_t*}
    -- if objectDeclaration*{objectDeclaration <- objectDeclaration*} matches _ :: _
    -- let objectDeclaration_h :: objectDeclaration_t*{objectDeclaration_t <- objectDeclaration_t*} = objectDeclaration*{objectDeclaration <- objectDeclaration*}
    -- Decl_object_ok: p TC frame_0 rdenv_0 |- objectDeclaration_h : frame_1 rdenv_1 objectDeclarationIR_h
    -- Decls_object_ok: p TC frame_1 rdenv_1 |- objectDeclaration_t*{objectDeclaration_t <- objectDeclaration_t*} : frame_2 rdenv_2 objectDeclarationIR_t*{objectDeclarationIR_t <- objectDeclarationIR_t*}
  }

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:173.1-173.46
def $subst_rdenv(theta, rdenv, rdenv) : rdenv =

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:175.1-175.63
  clause 0(theta, rdenv_extern, set<pair<rid, routineTypeDefIR>>) = rdenv_extern
  -- if (set<pair<rid, routineTypeDefIR>> = { [] })

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:176.1-192.93
  clause 1(theta, rdenv_extern, { pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*} }) = $subst_rdenv(theta, rdenv_extern_subst, { rid_init_t : routineTypeDefIR_init_t*{rid_init_t <- rid_init_t*, routineTypeDefIR_init_t <- routineTypeDefIR_init_t*} })
  -- if pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*} matches _ :: _
  -- let rid_init_h : routineTypeDefIR_init_h :: rid_init_t : routineTypeDefIR_init_t*{rid_init_t <- rid_init_t*, routineTypeDefIR_init_t <- routineTypeDefIR_init_t*} = pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*}
  -- let routineTypeDefIR''?{routineTypeDefIR'' <- routineTypeDefIR''?} = $find_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h)
  -- if routineTypeDefIR''?{routineTypeDefIR'' <- routineTypeDefIR''?} matches (_)
  -- let ?(routineTypeDefIR') = routineTypeDefIR''?{routineTypeDefIR'' <- routineTypeDefIR''?}
  -- if routineTypeDefIR' <: polyRoutineTypeDefIR
  -- let routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > = routineTypeDefIR' as polyRoutineTypeDefIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret = methodTypeIR
  -- let routineTypeDefIR = extern_method( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_ret as routineTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > as routineTypeDefIR
  -- let routineTypeDefIR_subst = $subst_routineTypeDef(theta, routineTypeDefIR)
  -- if RoutineTypeDef_alpha: routineTypeDefIR_subst ~~ routineTypeDefIR_init_h holds
  -- let rdenv_extern_subst = $update_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h, routineTypeDefIR_subst)

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:426.1-426.81
def $split_constructors(methodPrototype*) : (methodPrototype*, methodPrototype*) =

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:428.1-428.42
  clause 0(methodPrototype*{methodPrototype <- methodPrototype*}) = ([], [])
  -- if methodPrototype*{methodPrototype <- methodPrototype*} matches []

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:429.1-434.48
  clause 1(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_h :: methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
  -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
  -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
  -- let methodPrototype' = methodPrototype_h
  -- if methodPrototype' matches `%%(%);`
  -- let _annotationList _typeIdentifier ( _parameterList ); = methodPrototype'
  -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:435.1-440.48
  clause 2(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
  -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
  -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
  -- let methodPrototype' = methodPrototype_h
  -- if methodPrototype' matches `%%;`
  -- let _annotationList _functionPrototype ; = methodPrototype'
  -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:441.1-446.48
  clause 3(methodPrototype*{methodPrototype <- methodPrototype*}) = (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})
  -- if methodPrototype*{methodPrototype <- methodPrototype*} matches _ :: _
  -- let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} = methodPrototype*{methodPrototype <- methodPrototype*}
  -- let methodPrototype' = methodPrototype_h
  -- if methodPrototype' matches `%ABSTRACT%;`
  -- let _annotationList abstract _functionPrototype ; = methodPrototype'
  -- let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) = $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*})

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:624.1-627.26
relation Enum_serializable_field_ok: typingContext nameIR typeIR |- namedExpression : typingContext namedExpressionIR # value

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:629.1-644.74
  rulegroup  {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:629.1-644.74
    rule : TC_0 nameIR_enum typeIR |- name = expression : TC_1 nameIR = typedExpressionIR_cast # value
    -- Expr_ok: block TC_0 |- expression : typedExpressionIR
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR, typeIR)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_cast) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
    -- let _expressionIR # ( _typeIR ctk ) = typedExpressionIR_cast
    -- if ctk matches `LCTK`
    -- Eval_static: block TC_0 |- typedExpressionIR_cast ~> value
    -- let nameIR = $name(name)
    -- let typeIR_enum = enum nameIR_enum # typeIR { [] } as typeIR
    -- let value_enum = nameIR_enum . nameIR # value as value
    -- let TC_1 = $add_var(block, TC_0, nameIR, typeIR_enum lctk ?(value_enum))
  }

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:646.1-649.26
relation Enum_serializable_fields_ok: typingContext nameIR typeIR |- namedExpression* : typingContext namedExpressionIR* # value*

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:651.1-652.47
  rulegroup nil {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:651.1-652.47
    rule nil: TC nameIR_enum typeIR |- namedExpression*{namedExpression <- namedExpression*} : TC [] # []
    -- if namedExpression*{namedExpression <- namedExpression*} matches []
  }

  ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:654.1-664.55
  rulegroup cons {


    ;; ../../../../spec-concrete/5.11-typing-declaration.watsup:654.1-664.55
    rule cons: TC_0 nameIR_enum typeIR |- namedExpression*{namedExpression <- namedExpression*} : TC_2 namedExpressionIR*{namedExpressionIR <- namedExpressionIR*} # value_field*{value_field <- value_field*}
    -- if namedExpression*{namedExpression <- namedExpression*} matches _ :: _
    -- let namedExpression_h :: namedExpression_t*{namedExpression_t <- namedExpression_t*} = namedExpression*{namedExpression <- namedExpression*}
    -- Enum_serializable_field_ok: TC_0 nameIR_enum typeIR |- namedExpression_h : TC_1 namedExpressionIR_h # value_field_h
    -- Enum_serializable_fields_ok: TC_1 nameIR_enum typeIR |- namedExpression_t*{namedExpression_t <- namedExpression_t*} : TC_2 namedExpressionIR_t*{namedExpressionIR_t <- namedExpressionIR_t*} # value_field_t*{value_field_t <- value_field_t*}
    -- let namedExpressionIR*{namedExpressionIR <- namedExpressionIR*} = namedExpressionIR_h :: namedExpressionIR_t*{namedExpressionIR_t <- namedExpressionIR_t*}
    -- let value_field*{value_field <- value_field*} = value_field_h :: value_field_t*{value_field_t <- value_field_t*}
  }

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:33.1-35.23
relation SelectCase_keyset_simple_ok: typingContext typeIR |- simpleKeysetExpression : simpleKeysetExpressionIR

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:39.1-45.38
  rulegroup expression-set-alpha {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:39.1-45.38
    rule expression-set-alpha: TC typeIR_key |- simpleKeysetExpression : typedExpressionIR as simpleKeysetExpressionIR
    -- if simpleKeysetExpression <: expression
    -- let expression = simpleKeysetExpression as expression
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR'' _ctk ) = typedExpressionIR
    -- if typeIR'' <: setTypeIR
    -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
    -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
    -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
    -- if Type_alpha: typeIR ~~ typeIR_key holds
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:47.1-58.69
  rulegroup expression-set-subtype {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:47.1-58.69
    rule expression-set-subtype: TC typeIR_key |- simpleKeysetExpression : typedExpressionIR_cast as simpleKeysetExpressionIR
    -- if simpleKeysetExpression <: expression
    -- let expression = simpleKeysetExpression as expression
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR'' _ctk ) = typedExpressionIR
    -- if typeIR'' <: setTypeIR
    -- let set< typeIR'*{typeIR' <- typeIR'*} > = typeIR'' as setTypeIR
    -- if typeIR'*{typeIR' <- typeIR'*} matches [ _/1 ]
    -- let [typeIR] = typeIR'*{typeIR' <- typeIR'*}
    -- if ~Type_alpha: typeIR ~~ typeIR_key holds
    -- if Sub_impl: typeIR <: typeIR_key holds
    -- let typeIR_cast = set< [typeIR_key] > as typeIR
    -- let typedExpressionIR_cast = ( typeIR_cast ) typedExpressionIR as expressionIR # ( typeIR_cast dyn )
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:60.1-72.69
  rulegroup expression-non-set {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:60.1-72.69
    rule expression-non-set: TC typeIR_key |- simpleKeysetExpression : typedExpressionIR_cast as simpleKeysetExpressionIR
    -- if simpleKeysetExpression <: expression
    -- let expression = simpleKeysetExpression as expression
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
    -- if ~$is_set_typeIR(typeIR)
    -- if Sub_impl: typeIR <: typeIR_key holds
    -- let typeIR_cast = set< [typeIR_key] > as typeIR
    -- let typedExpressionIR_cast = ( typeIR_cast ) typedExpressionIR as expressionIR # ( typeIR_cast dyn )
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:87.1-109.63
  rulegroup mask {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:87.1-109.63
    rule mask: TC typeIR_key |- simpleKeysetExpression : typedExpressionIR_l_coerced &&& typedExpressionIR_r_coerced
    -- if simpleKeysetExpression matches `%&&&%`
    -- let expression_l &&& expression_r = simpleKeysetExpression
    -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced _ctk ) = typedExpressionIR_l_reduced
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_l_reduced, typeIR_key)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_l_coerced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR_r_reduced, typeIR_key)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_r_coerced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:124.1-147.63
  rulegroup range {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:124.1-147.63
    rule range: TC typeIR_key |- simpleKeysetExpression : typedExpressionIR_l_coerced .. typedExpressionIR_r_coerced
    -- if simpleKeysetExpression matches `%..%`
    -- let expression_l .. expression_r = simpleKeysetExpression
    -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced _ctk ) = typedExpressionIR_l_reduced
    -- let _expressionIR' # ( typeIR _ctk' ) = typedExpressionIR_r_reduced
    -- if (typeIR = typeIR_reduced)
    -- let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} = $coerce_unary(typedExpressionIR_l_reduced, typeIR_key)
    -- if typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches (_)
    -- let ?(typedExpressionIR_l_coerced) = typedExpressionIR?{typedExpressionIR <- typedExpressionIR?}
    -- let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} = $coerce_unary(typedExpressionIR_r_reduced, typeIR_key)
    -- if typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches (_)
    -- let ?(typedExpressionIR_r_coerced) = typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?}
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:151.1-152.37
  rulegroup default {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:151.1-152.37
    rule default: TC typeIR_key |- simpleKeysetExpression : default
    -- if simpleKeysetExpression matches `DEFAULT`
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:156.1-157.27
  rulegroup dontcare {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:156.1-157.27
    rule dontcare: TC typeIR_key |- simpleKeysetExpression : _
    -- if simpleKeysetExpression matches `_`
  }

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:76.1-76.40
def $compat_mask(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:79.1-80.54
  clause 0(typeIR_l, typeIR_r) = $compat'_mask($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:77.1-77.41
def $compat'_mask(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:81.1-81.35
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:82.1-82.49
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:83.1-83.49
  clause 2(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:84.1-85.15
  clause 3(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:113.1-113.41
def $compat_range(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:116.1-117.55
  clause 0(typeIR_l, typeIR_r) = $compat'_range($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:114.1-114.42
def $compat'_range(typeIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:118.1-118.36
  clause 0(typeIR, typeIR') = true
  -- if (typeIR = int as typeIR)
  -- if (typeIR' = int as typeIR)

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:119.1-119.50
  clause 1(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `INT<%>`
  -- let int< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:120.1-120.50
  clause 2(typeIR, typeIR') = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< w > = numberTypeIR
  -- if typeIR' <: numberTypeIR
  -- let numberTypeIR' = typeIR' as numberTypeIR
  -- if numberTypeIR' matches `BIT<%>`
  -- let bit< w' > = numberTypeIR'
  -- if (w = w')

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:121.1-122.15
  clause 3(typeIR_l, typeIR_r) = false
  -- otherwise

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:161.1-163.23
relation SelectCase_keyset_ok: typingContext typeIR* |- keysetExpression : keysetExpressionIR

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:170.1-173.61
  rulegroup simpleKeysetExpression-expression {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:170.1-173.61
    rule simpleKeysetExpression-expression: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if keysetExpression <: expression
    -- let expression = keysetExpression as expression
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression as simpleKeysetExpression : simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:177.1-180.81
  rulegroup simpleKeysetExpression-mask {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:177.1-180.81
    rule simpleKeysetExpression-mask: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if keysetExpression <: simpleKeysetExpression
    -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
    -- if simpleKeysetExpression matches `%&&&%`
    -- let expression_l &&& expression_r = simpleKeysetExpression
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression_l &&& expression_r : simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:184.1-187.80
  rulegroup simpleKeysetExpression-range {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:184.1-187.80
    rule simpleKeysetExpression-range: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if keysetExpression <: simpleKeysetExpression
    -- let simpleKeysetExpression = keysetExpression as simpleKeysetExpression
    -- if simpleKeysetExpression matches `%..%`
    -- let expression_l .. expression_r = simpleKeysetExpression
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression_l .. expression_r : simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:191.1-207.2
  rulegroup simpleKeysetExpression-default {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:193.3-194.32
    rule zero-to-one: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : default as keysetExpressionIR
    -- if typeIR*{typeIR <- typeIR*} matches []
    -- if (keysetExpression = default as keysetExpression)

    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:196.3-199.60
    rule one-to-one: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if (keysetExpression = default as keysetExpression)
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- default : simpleKeysetExpressionIR

    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:201.3-205.72
    rule many-to-one: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
    -- if (keysetExpression = default as keysetExpression)
    -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
    -- SelectCase_keyset_simple_ok: TC seq< typeIR_key*{typeIR_key <- typeIR_key*} > as typeIR |- default : simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:211.1-224.2
  rulegroup simpleKeysetExpression-dontcare {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:213.3-216.55
    rule one-to-one: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if (keysetExpression = _ as keysetExpression)
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- _ : simpleKeysetExpressionIR

    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:218.3-222.67
    rule many-to-one: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : simpleKeysetExpressionIR as keysetExpressionIR
    -- if (keysetExpression = _ as keysetExpression)
    -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
    -- SelectCase_keyset_simple_ok: TC seq< typeIR_key*{typeIR_key <- typeIR_key*} > as typeIR |- _ : simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:231.1-234.81
  rulegroup tupleKeysetExpression-mask {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:231.1-234.81
    rule tupleKeysetExpression-mask: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if keysetExpression <: tupleKeysetExpression
    -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
    -- if tupleKeysetExpression matches `(%&&&%)`
    -- let ( expression_l &&& expression_r ) = tupleKeysetExpression
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression_l &&& expression_r : simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:238.1-241.80
  rulegroup tupleKeysetExpression-range {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:238.1-241.80
    rule tupleKeysetExpression-range: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if keysetExpression <: tupleKeysetExpression
    -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
    -- if tupleKeysetExpression matches `(%..%)`
    -- let ( expression_l .. expression_r ) = tupleKeysetExpression
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- expression_l .. expression_r : simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:245.1-258.2
  rulegroup tupleKeysetExpression-default {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:247.3-250.60
    rule one-to-one: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if (keysetExpression = (default) as keysetExpression)
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- default : simpleKeysetExpressionIR

    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:252.3-256.72
    rule many-to-one: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
    -- if (keysetExpression = (default) as keysetExpression)
    -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
    -- SelectCase_keyset_simple_ok: TC seq< typeIR_key*{typeIR_key <- typeIR_key*} > as typeIR |- default : simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:262.1-275.2
  rulegroup tupleKeysetExpression-dontcare {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:264.3-267.55
    rule one-to-one: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
    -- if typeIR*{typeIR <- typeIR*} matches [ _/1 ]
    -- let [typeIR_key] = typeIR*{typeIR <- typeIR*}
    -- if (keysetExpression = (_) as keysetExpression)
    -- SelectCase_keyset_simple_ok: TC typeIR_key |- _ : simpleKeysetExpressionIR

    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:269.3-273.67
    rule many-to-one: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : ( [simpleKeysetExpressionIR] ) as keysetExpressionIR
    -- if (keysetExpression = (_) as keysetExpression)
    -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| > 1)
    -- SelectCase_keyset_simple_ok: TC seq< typeIR_key*{typeIR_key <- typeIR_key*} > as typeIR |- _ : simpleKeysetExpressionIR
  }

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:279.1-290.75
  rulegroup tupleKeysetExpression-list {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:279.1-290.75
    rule tupleKeysetExpression-list: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : ( simpleKeysetExpressionIR*{simpleKeysetExpressionIR <- simpleKeysetExpressionIR*} ) as keysetExpressionIR
    -- if keysetExpression <: tupleKeysetExpression
    -- let tupleKeysetExpression = keysetExpression as tupleKeysetExpression
    -- if tupleKeysetExpression matches `(%,%)`
    -- let ( simpleKeysetExpression_h , simpleKeysetExpressionList_t ) = tupleKeysetExpression
    -- let simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t)
    -- let simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} = simpleKeysetExpression_h :: simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*}
    -- if (|typeIR_key*{typeIR_key <- typeIR_key*}| = |simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}|)
    -- (SelectCase_keyset_simple_ok: TC typeIR_key |- simpleKeysetExpression : simpleKeysetExpressionIR)*{simpleKeysetExpression <- simpleKeysetExpression*, simpleKeysetExpressionIR <- simpleKeysetExpressionIR*, typeIR_key <- typeIR_key*}
  }

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:294.1-296.26
relation SelectCase_ok: typingContext nameIR* typeIR* |- selectCase : selectCaseIR

  ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:298.1-306.32
  rulegroup  {


    ;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:298.1-306.32
    rule : TC nameIR_state*{nameIR_state <- nameIR_state*} typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : name ; : keysetExpressionIR : nameIR ;
    -- SelectCase_keyset_ok: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : keysetExpressionIR
    -- let nameIR = $name(name)
    -- if nameIR <- nameIR_state*{nameIR_state <- nameIR_state*}
  }

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:7.1-7.52
def $compat_table_exact_optional_key(typeIR) : bool =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:10.1-11.54
  clause 0(typeIR) = $compat'_table_exact_optional_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:8.1-8.53
def $compat'_table_exact_optional_key(typeIR) : bool =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:12.1-12.51
  clause 0(typeIR) = true
  -- if (typeIR = bool as typeIR)

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:13.1-13.52
  clause 1(typeIR) = true
  -- if (typeIR = error as typeIR)

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:14.1-14.59
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:15.1-16.45
  clause 3(typeIR') = $compat_table_exact_optional_key(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:17.1-17.60
  clause 4(typeIR) = true
  -- if typeIR <: enumTypeIR
  -- let enumTypeIR = typeIR as enumTypeIR
  -- if enumTypeIR matches `ENUM%{%}`
  -- let enum _tid { _id*{_id <- _id*} } = enumTypeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:18.1-19.45
  clause 5(typeIR') = $compat_table_exact_optional_key(typeIR)
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:21.1-21.55
def $compat_table_lpm_ternary_range_key(typeIR) : bool =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:24.1-25.57
  clause 0(typeIR) = $compat'_table_lpm_ternary_range_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:22.1-22.56
def $compat'_table_lpm_ternary_range_key(typeIR) : bool =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:26.1-26.53
  clause 0(typeIR) = true
  -- if (typeIR = int as typeIR)

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:27.1-27.60
  clause 1(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `INT<%>`
  -- let int< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:28.1-28.60
  clause 2(typeIR) = true
  -- if typeIR <: numberTypeIR
  -- let numberTypeIR = typeIR as numberTypeIR
  -- if numberTypeIR matches `BIT<%>`
  -- let bit< _nat > = numberTypeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:29.1-30.48
  clause 3(typeIR') = $compat_table_lpm_ternary_range_key(typeIR)
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR = typeIR' as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type _tid typeIR = aliasTypeIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:31.1-32.48
  clause 4(typeIR') = $compat_table_lpm_ternary_range_key(typeIR)
  -- if typeIR' <: enumTypeIR
  -- let enumTypeIR = typeIR' as enumTypeIR
  -- if enumTypeIR matches `ENUM%#%{%}`
  -- let enum _tid # typeIR { _valueFieldIR*{_valueFieldIR <- _valueFieldIR*} } = enumTypeIR

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:34.1-34.45
def $compat_table_key(nameIR, typeIR) : bool =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:36.1-38.49
  clause 0(nameIR, typeIR) = true
  -- if ((nameIR = "exact") \/ (nameIR = "optional"))
  -- if $compat_table_exact_optional_key(typeIR)

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:39.1-41.52
  clause 1(nameIR, typeIR) = true
  -- if (((nameIR = "lpm") \/ (nameIR = "ternary")) \/ (nameIR = "range"))
  -- if $compat_table_lpm_ternary_range_key(typeIR)

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:42.1-43.15
  clause 2(nameIR, typeIR) = false
  -- otherwise

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:85.1-86.41
def $split_dataplane_parameters(parameterTypeIR*) : (parameterTypeIR*, parameterTypeIR*) =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:88.1-88.50
  clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = ([], [])
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:89.1-93.56
  clause 1(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_h :: parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
  -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
  -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR_h
  -- if direction matches ``EMPTY`
  -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:94.1-99.56
  clause 2(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) = (parameterTypeIR_h :: parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
  -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
  -- let direction _typeIR _id _value?{_value <- _value?} = parameterTypeIR_h
  -- if (direction =/= )
  -- let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) = $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*})

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:236.1-239.26
relation TableEntry_keyset_simple_ok: typingContext tableContext |- matchKey @ simpleKeysetExpression : tableEntryState simpleKeysetExpressionIR

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:243.1-275.2
  rulegroup expression {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:245.3-258.69
    rule lpm: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : lpm n typedExpressionIR_set as simpleKeysetExpressionIR
    -- if (text = "lpm")
    -- if simpleKeysetExpression <: expression
    -- let expression = simpleKeysetExpression as expression
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
    -- if Sub_impl: typeIR <: typeIR_key holds
    -- let typeIR_set = set< [typeIR_key] > as typeIR
    -- let typedExpressionIR_set = ( typeIR_set ) typedExpressionIR as expressionIR # ( typeIR_set ctk )

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:260.3-273.69
    rule non-lpm: TC TBLC |- (typeIR_key, nameIR_matchkind) @ simpleKeysetExpression : nolpm typedExpressionIR_set as simpleKeysetExpressionIR
    -- if simpleKeysetExpression <: expression
    -- let expression = simpleKeysetExpression as expression
    -- if (nameIR_matchkind =/= "lpm")
    -- Expr_ok: local TC |- expression : typedExpressionIR
    -- let _expressionIR # ( typeIR ctk ) = typedExpressionIR
    -- if Sub_impl: typeIR <: typeIR_key holds
    -- let typeIR_set = set< [typeIR_key] > as typeIR
    -- let typedExpressionIR_set = ( typeIR_set ) typedExpressionIR as expressionIR # ( typeIR_set ctk )
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:279.1-331.2
  rulegroup mask {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:281.3-308.68
    rule lpm: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : lpm n_prefix typedExpressionIR_l_reduced &&& typedExpressionIR_r_reduced
    -- if (text = "lpm")
    -- if simpleKeysetExpression matches `%&&&%`
    -- let expression_l &&& expression_r = simpleKeysetExpression
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode
    -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if Sub_impl: typeIR_reduced <: typeIR_key holds
    -- if (ctk_r_reduced = lctk)
    -- Eval_static: local TC |- typedExpressionIR_r_reduced ~> value_r
    -- let i_r = $to_number(value_r)
    -- let n_prefix = $tableEntry_lpm_prefix(n w $to_bitstr(n as int, i_r) as value)

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:310.3-329.46
    rule ternary: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : nolpm typedExpressionIR_l_reduced &&& typedExpressionIR_r_reduced
    -- if (text = "ternary")
    -- if simpleKeysetExpression matches `%&&&%`
    -- let expression_l &&& expression_r = simpleKeysetExpression
    -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if Sub_impl: typeIR_reduced <: typeIR_key holds
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:335.1-354.44
  rulegroup range-range {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:335.1-354.44
    rule range-range: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : nolpm typedExpressionIR_l_reduced .. typedExpressionIR_r_reduced
    -- if (text = "range")
    -- if simpleKeysetExpression matches `%..%`
    -- let expression_l .. expression_r = simpleKeysetExpression
    -- Expr_ok: local TC |- expression_l : typedExpressionIR_l
    -- Expr_ok: local TC |- expression_r : typedExpressionIR_r
    -- let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
    -- if (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches (_)
    -- let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) = (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?}
    -- let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} = $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range)
    -- if (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches (_)
    -- let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) = (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?}
    -- let _expressionIR # ( typeIR_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
    -- if Sub_impl: typeIR_reduced <: typeIR_key holds
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:358.1-371.2
  rulegroup default {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:360.3-363.33
    rule lpm: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : lpm n default
    -- if (text = "lpm")
    -- if simpleKeysetExpression matches `DEFAULT`
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm n = matchMode

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:365.3-369.39
    rule non-lpm: TC TBLC |- (typeIR_key, nameIR_matchkind) @ simpleKeysetExpression : nolpm default
    -- if simpleKeysetExpression matches `DEFAULT`
    -- if (nameIR_matchkind =/= "lpm")
    -- if (nameIR_matchkind =/= "exact")
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:375.1-388.2
  rulegroup dontcare {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:377.3-380.33
    rule lpm: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : lpm 0 _
    -- if (text = "lpm")
    -- if simpleKeysetExpression matches `_`
    -- let matchMode = TBLC.mode
    -- if matchMode matches `NOPRILPM%`
    -- let noprilpm _nat = matchMode

    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:382.3-386.39
    rule non-lpm: TC TBLC |- (typeIR_key, nameIR_matchkind) @ simpleKeysetExpression : nolpm _
    -- if simpleKeysetExpression matches `_`
    -- if (nameIR_matchkind =/= "lpm")
    -- if (nameIR_matchkind =/= "exact")
  }

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:396.1-399.29
relation TableEntry_keysets_simple_ok: typingContext tableContext tableEntryState |- matchKey* @ simpleKeysetExpression* : tableEntryState simpleKeysetExpressionIR*

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:401.1-402.40
  rulegroup nil {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:401.1-402.40
    rule nil: TC TBLC TBLS |- matchKey*{matchKey <- matchKey*} @ simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} : TBLS []
    -- if matchKey*{matchKey <- matchKey*} matches []
    -- if simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} matches []
  }

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:404.1-414.59
  rulegroup cons {


    ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:404.1-414.59
    rule cons: TC TBLC TBLS_0 |- matchKey*{matchKey <- matchKey*} @ simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} : TBLS_3 simpleKeysetExpressionIR_h :: simpleKeysetExpressionIR_t*{simpleKeysetExpressionIR_t <- simpleKeysetExpressionIR_t*}
    -- if matchKey*{matchKey <- matchKey*} matches _ :: _
    -- let matchKey_h :: matchKey_t*{matchKey_t <- matchKey_t*} = matchKey*{matchKey <- matchKey*}
    -- if simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} matches _ :: _
    -- let simpleKeysetExpression_h :: simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} = simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*}
    -- TableEntry_keyset_simple_ok: TC TBLC |- matchKey_h @ simpleKeysetExpression_h : TBLS_1 simpleKeysetExpressionIR_h
    -- let TBLS_2 = $join_tableEntryState(TBLS_0, TBLS_1)
    -- TableEntry_keysets_simple_ok: TC TBLC TBLS_2 |- matchKey_t*{matchKey_t <- matchKey_t*} @ simpleKeysetExpression_t*{simpleKeysetExpression_t <- simpleKeysetExpression_t*} : TBLS_3 simpleKeysetExpressionIR_t*{simpleKeysetExpressionIR_t <- simpleKeysetExpressionIR_t*}
  }

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:948.1-948.44
def $count_table_keys(tableProperty*) : nat =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:950.1-950.31
  clause 0(tableProperty*{tableProperty <- tableProperty*}) = 0
  -- if tableProperty*{tableProperty <- tableProperty*} matches []

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:951.1-954.47
  clause 1(tableProperty'*{tableProperty' <- tableProperty'*}) = (1 + $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*}))
  -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
  -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
  -- if tableProperty matches `KEY={%}`
  -- let key={ _tableKeyList } = tableProperty

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:955.1-959.15
  clause 2(tableProperty*{tableProperty <- tableProperty*}) = $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*})
  -- if tableProperty*{tableProperty <- tableProperty*} matches _ :: _
  -- let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty*{tableProperty <- tableProperty*}
  -- otherwise

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:961.1-961.47
def $count_table_actions(tableProperty*) : nat =

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:963.1-963.34
  clause 0(tableProperty*{tableProperty <- tableProperty*}) = 0
  -- if tableProperty*{tableProperty <- tableProperty*} matches []

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:964.1-967.50
  clause 1(tableProperty'*{tableProperty' <- tableProperty'*}) = (1 + $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*}))
  -- if tableProperty'*{tableProperty' <- tableProperty'*} matches _ :: _
  -- let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty'*{tableProperty' <- tableProperty'*}
  -- if tableProperty matches `ACTIONS={%}`
  -- let actions={ _tableActionList } = tableProperty

  ;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:968.1-972.15
  clause 2(tableProperty*{tableProperty <- tableProperty*}) = $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*})
  -- if tableProperty*{tableProperty <- tableProperty*} matches _ :: _
  -- let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} = tableProperty*{tableProperty <- tableProperty*}
  -- otherwise

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:7.1-7.73
def $filter_default_parameters(parameterTypeIR*, id*) : parameterTypeIR* =

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:9.1-9.55
  clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = []
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches []

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:10.1-16.28
  clause 1(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
  -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
  -- let _direction _typeIR id_h _value?{_value <- _value?} = parameterTypeIR_h
  -- if id_h <- id_default*{id_default <- id_default*}

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:17.1-22.15
  clause 2(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}) = parameterTypeIR_h :: $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})
  -- if parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} matches _ :: _
  -- let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} = parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}
  -- otherwise

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:26.1-26.71
def $align_parameters(parameterTypeIR*, argumentIR*) : parameterTypeIR* =

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:29.1-32.90
  clause 0(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}
  -- (let _direction _typeIR id _value?{_value <- _value?} = parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}
  -- (let parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?} = $align_parameters'({ id : parameterTypeIR*{id <- id*, parameterTypeIR <- parameterTypeIR*} }, parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, parameterTypeIR <- parameterTypeIR*, parameterTypeIR'? <- parameterTypeIR'?*}
  -- (if parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?} matches (_))*{parameterTypeIR'? <- parameterTypeIR'?*}
  -- (let ?(parameterTypeIR_aligned) = parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?})*{parameterTypeIR'? <- parameterTypeIR'?*, parameterTypeIR_aligned <- parameterTypeIR_aligned*}

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:27.1-27.96
def $align_parameters'(map<id, parameterTypeIR>, parameterTypeIR, argumentIR) : parameterTypeIR? =

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:34.1-35.20
  clause 0(_map<id, parameterTypeIR>, parameterTypeIR, argumentIR) = ?(parameterTypeIR)
  -- if argumentIR <: typedExpressionIR
  -- let typedExpressionIR = argumentIR as typedExpressionIR

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:36.1-37.80
  clause 1({ id_param : parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }, _parameterTypeIR, argumentIR) = $find_map<id, parameterTypeIR>({ id_param : parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }, nameIR)
  -- if argumentIR matches `%=%`
  -- let nameIR = _typedExpressionIR = argumentIR

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:38.1-39.80
  clause 2({ id_param : parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }, _parameterTypeIR, argumentIR) = $find_map<id, parameterTypeIR>({ id_param : parameterTypeIR*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }, nameIR)
  -- if argumentIR matches `%=_`
  -- let nameIR =_ = argumentIR

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:40.1-41.20
  clause 3(_map<id, parameterTypeIR>, parameterTypeIR, argumentIR) = ?(parameterTypeIR)
  -- if argumentIR matches `_`

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:60.1-62.23
relation Expr_lvalue_ok: cursor typingContext |- typedExpressionIR

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:64.1-67.45
  rulegroup referenceExpressionIR {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:64.1-67.45
    rule referenceExpressionIR: p TC |- expressionIR # ( _typeIR _ctk )
    -- if expressionIR <: prefixedNameIR
    -- let prefixedNameIR = expressionIR as prefixedNameIR
    -- let varTypeIR?{varTypeIR <- varTypeIR?} = $find_var(p, TC, prefixedNameIR)
    -- if varTypeIR?{varTypeIR <- varTypeIR?} matches (_)
    -- let ?(direction _typeIR' ctk _value?{_value <- _value?}) = varTypeIR?{varTypeIR <- varTypeIR?}
    -- if ctk matches `DYN`
    -- if ((direction = out) \/ (direction = inout))
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:69.1-90.2
  rulegroup accessExpressionIR-memberAccessExpressionIR {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:71.3-81.70
    rule headerstack-next-last: p TC |- expressionIR # ( _typeIR _ctk )
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR <: typedExpressionIR
    -- let typedExpressionIR_base = memberAccessBaseIR as typedExpressionIR
    -- if Expr_lvalue_ok: p TC |- typedExpressionIR_base holds
    -- let _expressionIR # ( typeIR_base _ctk' ) = typedExpressionIR_base
    -- let typeIR' = $canon(typeIR_base)
    -- if typeIR' <: headerStackTypeIR
    -- let typeIR [ _nat ] = typeIR' as headerStackTypeIR
    -- if ((nameIR = "next") \/ (nameIR = "last"))
    -- if (((p = block) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = local) /\ $is_parser_state_localKind(TC.local.kind)))

    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:83.3-88.54
    rule non-headerstack: p TC |- expressionIR # ( _typeIR _ctk )
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR <: typedExpressionIR
    -- let typedExpressionIR_base = memberAccessBaseIR as typedExpressionIR
    -- if Expr_lvalue_ok: p TC |- typedExpressionIR_base holds
    -- let _expressionIR # ( typeIR_base _ctk' ) = typedExpressionIR_base
    -- if ~$is_headerStackTypeIR($canon(typeIR_base))
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:92.1-94.52
  rulegroup accessExpressionIR-indexAccessExpressionIR {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:92.1-94.52
    rule accessExpressionIR-indexAccessExpressionIR: p TC |- expressionIR # ( _typeIR _ctk )
    -- if expressionIR <: indexAccessExpressionIR
    -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
    -- if indexAccessExpressionIR matches `%[%]`
    -- let typedExpressionIR_base [ typedExpressionIR_index ] = indexAccessExpressionIR
    -- if Expr_lvalue_ok: p TC |- typedExpressionIR_base holds
  }

  ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:96.1-99.52
  rulegroup accessExpressionIR-indexAccessExpressionIR-bitslice {


    ;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:96.1-99.52
    rule accessExpressionIR-indexAccessExpressionIR-bitslice: p TC |- expressionIR # ( _typeIR _ctk )
    -- if expressionIR <: indexAccessExpressionIR
    -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
    -- if indexAccessExpressionIR matches `%[%:%]`
    -- let typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ] = indexAccessExpressionIR
    -- if Expr_lvalue_ok: p TC |- typedExpressionIR_base holds
  }

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:6.1-7.12
syntax infer = 
   | knownas typeIR
   | unknown

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:9.21-9.36
syntax constraint = map<tid, infer>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:11.1-11.41
def $empty_constraint(tid*) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:12.1-12.53
  clause 0(tid*{tid <- tid*}) = { tid : unknown*{tid <- tid*} }

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:14.20-14.36
syntax inference = map<tid, typeIR>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:20.1-20.60
def $infer(tid*, parameterTypeIR*, argumentIR*) : inference =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:44.1-52.61
  clause 0(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) = inference
  -- let constraint_init = $empty_constraint(tid_infer*{tid_infer <- tid_infer*})
  -- (let constraint_pair = $infer'(constraint_init, parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, constraint_pair <- constraint_pair*, parameterTypeIR <- parameterTypeIR*}
  -- let constraint_inferred = $merge_constraints(constraint_init, constraint_pair*{constraint_pair <- constraint_pair*})
  -- let inference = $resolve_constraint(constraint_inferred)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:21.1-21.66
def $infer'(constraint, parameterTypeIR, argumentIR) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:54.1-57.51
  clause 0(constraint, parameterTypeIR, argumentIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if argumentIR <: typedExpressionIR
  -- let typedExpressionIR = argumentIR as typedExpressionIR
  -- let _direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR
  -- let _expressionIR # ( typeIR_arg _ctk ) = typedExpressionIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:59.1-62.51
  clause 1(constraint, parameterTypeIR, argumentIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if argumentIR matches `%=%`
  -- let nameIR = typedExpressionIR = argumentIR
  -- let _direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR
  -- let _expressionIR # ( typeIR_arg _ctk ) = typedExpressionIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:64.1-64.68
  clause 2(constraint, parameterTypeIR, argumentIR) = constraint
  -- if argumentIR matches `%=_`
  -- let nameIR =_ = argumentIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:66.1-66.58
  clause 3(constraint, parameterTypeIR, argumentIR) = constraint
  -- if argumentIR matches `_`

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:23.1-23.66
def $gen_constraint_type(constraint, typeIR, typeIR) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:74.1-76.66
  clause 0(constraint, typeIR, typeIR_arg) = $update_map<tid, infer>(constraint, tid_param, knownas typeIR_arg)
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `TID%`
  -- let tid tid_param = namedTypeIR
  -- if $in_set<tid>(tid_param, $dom_map<tid, infer>(constraint))

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:78.1-99.26
  clause 1(constraint_0, typeIR, typeIR') = constraint_2
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `%<%>`
  -- let polyTypeDefIR_param < typeIR_param*{typeIR_param <- typeIR_param*} > = namedTypeIR
  -- if typeIR' <: namedTypeIR
  -- let namedTypeIR' = typeIR' as namedTypeIR
  -- if namedTypeIR' matches `%<%>`
  -- let polyTypeDefIR_arg < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR'
  -- let typeIR_specialized_param = $specialize_typeDef(polyTypeDefIR_param as typeDefIR, typeIR_param*{typeIR_param <- typeIR_param*})
  -- let typeIR_specialized_arg = $specialize_typeDef(polyTypeDefIR_arg as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if ($is_nominal_typeIR(typeIR_specialized_param) /\ $is_nominal_typeIR(typeIR_specialized_arg))
  -- let constraint_1 = $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg)
  -- let constraint_2 = $gen_constraint_types(constraint_1, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:101.1-117.26
  clause 2(constraint_0, typeIR, typeIR') = constraint_1
  -- if typeIR <: namedTypeIR
  -- let namedTypeIR = typeIR as namedTypeIR
  -- if namedTypeIR matches `%<%>`
  -- let polyTypeDefIR_param < typeIR_param*{typeIR_param <- typeIR_param*} > = namedTypeIR
  -- if typeIR' <: namedTypeIR
  -- let namedTypeIR' = typeIR' as namedTypeIR
  -- if namedTypeIR' matches `%<%>`
  -- let polyTypeDefIR_arg < typeIR_arg*{typeIR_arg <- typeIR_arg*} > = namedTypeIR'
  -- let typeIR_specialized_param = $specialize_typeDef(polyTypeDefIR_param as typeDefIR, typeIR_param*{typeIR_param <- typeIR_param*})
  -- let typeIR_specialized_arg = $specialize_typeDef(polyTypeDefIR_arg as typeDefIR, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if (~$is_nominal_typeIR(typeIR_specialized_param) /\ ~$is_nominal_typeIR(typeIR_specialized_arg))
  -- let constraint_1 = $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg)

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:121.1-122.63
  clause 3(constraint, typeIR, typeIR_arg) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPEDEF%%`
  -- let typedef _tid typeIR_param = aliasTypeIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:124.1-125.63
  clause 4(constraint, typeIR_param, typeIR) = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPEDEF%%`
  -- let typedef _tid typeIR_arg = aliasTypeIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:127.1-128.63
  clause 5(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if typeIR <: aliasTypeIR
  -- let aliasTypeIR = typeIR as aliasTypeIR
  -- if aliasTypeIR matches `TYPE%%`
  -- let type tid typeIR_param = aliasTypeIR
  -- if typeIR' <: aliasTypeIR
  -- let aliasTypeIR' = typeIR' as aliasTypeIR
  -- if aliasTypeIR' matches `TYPE%%`
  -- let type tid' typeIR_arg = aliasTypeIR'
  -- if (tid = tid')

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:132.1-137.63
  clause 6(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if typeIR <: listTypeIR
  -- let list< typeIR_param > = typeIR as listTypeIR
  -- if typeIR' <: listTypeIR
  -- let list< typeIR_arg > = typeIR' as listTypeIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:139.1-144.66
  clause 7(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: tupleTypeIR
  -- let tuple< typeIR_param*{typeIR_param <- typeIR_param*} > = typeIR as tupleTypeIR
  -- if typeIR' <: tupleTypeIR
  -- let tuple< typeIR_arg*{typeIR_arg <- typeIR_arg*} > = typeIR' as tupleTypeIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:146.1-151.63
  clause 8(constraint, typeIR, typeIR') = $gen_constraint_type(constraint, typeIR_param, typeIR_arg)
  -- if typeIR <: headerStackTypeIR
  -- let typeIR_param [ n_size ] = typeIR as headerStackTypeIR
  -- if typeIR' <: headerStackTypeIR
  -- let typeIR_arg [ n_size' ] = typeIR' as headerStackTypeIR
  -- if (n_size = n_size')

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:153.1-158.66
  clause 9(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: structTypeIR
  -- let struct tid { typeIR_param id_field ;*{id_field <- id_field*, typeIR_param <- typeIR_param*} } = typeIR as structTypeIR
  -- if typeIR' <: structTypeIR
  -- let struct tid' { typeIR_arg id_field' ;*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} } = typeIR' as structTypeIR
  -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
  -- if (tid = tid')

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:160.1-165.66
  clause 10(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: headerTypeIR
  -- let header tid { typeIR_param id_field ;*{id_field <- id_field*, typeIR_param <- typeIR_param*} } = typeIR as headerTypeIR
  -- if typeIR' <: headerTypeIR
  -- let header tid' { typeIR_arg id_field' ;*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} } = typeIR' as headerTypeIR
  -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
  -- if (tid = tid')

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:167.1-172.66
  clause 11(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: headerUnionTypeIR
  -- let header_union tid { typeIR_param id_field ;*{id_field <- id_field*, typeIR_param <- typeIR_param*} } = typeIR as headerUnionTypeIR
  -- if typeIR' <: headerUnionTypeIR
  -- let header_union tid' { typeIR_arg id_field' ;*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*} } = typeIR' as headerUnionTypeIR
  -- (if (id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}
  -- if (tid = tid')

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:176.1-185.6
  clause 12(constraint, typeIR, typeIR') = $gen_constraint_routines(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*})
  -- if typeIR <: externObjectTypeIR
  -- let extern tid { rid : routineTypeDefIR_param*{rid <- rid*, routineTypeDefIR_param <- routineTypeDefIR_param*} } = typeIR as externObjectTypeIR
  -- if typeIR' <: externObjectTypeIR
  -- let extern tid' { rid' : routineTypeDefIR_arg*{rid' <- rid'*, routineTypeDefIR_arg <- routineTypeDefIR_arg*} } = typeIR' as externObjectTypeIR
  -- (if (rid = rid'))*{rid <- rid*, rid' <- rid'*}
  -- if (tid = tid')

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:187.1-194.58
  clause 13(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: parserObjectTypeIR
  -- let parser( parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} ) = typeIR as parserObjectTypeIR
  -- if typeIR' <: parserObjectTypeIR
  -- let parser( parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} ) = typeIR' as parserObjectTypeIR
  -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
  -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
  -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:196.1-203.58
  clause 14(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: controlObjectTypeIR
  -- let control( parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} ) = typeIR as controlObjectTypeIR
  -- if typeIR' <: controlObjectTypeIR
  -- let control( parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} ) = typeIR' as controlObjectTypeIR
  -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
  -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
  -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:205.1-210.66
  clause 15(constraint, typeIR, typeIR') = $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- if typeIR <: packageObjectTypeIR
  -- let package< typeIR_param*{typeIR_param <- typeIR_param*} > = typeIR as packageObjectTypeIR
  -- if typeIR' <: packageObjectTypeIR
  -- let package< typeIR_arg*{typeIR_arg <- typeIR_arg*} > = typeIR' as packageObjectTypeIR

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:214.1-216.15
  clause 16(constraint, typeIR_param, typeIR_arg) = constraint
  -- otherwise

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:24.1-24.69
def $gen_constraint_types(constraint, typeIR*, typeIR*) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:220.1-223.69
  clause 0(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*}) = $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})
  -- (let constraint_pair = $gen_constraint_type(constraint, typeIR_param, typeIR_arg))*{constraint_pair <- constraint_pair*, typeIR_arg <- typeIR_arg*, typeIR_param <- typeIR_param*}

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:25.1-28.15
def $gen_constraint_routine(constraint, routineTypeDefIR, routineTypeDefIR) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:227.1-238.77
  clause 0(constraint_0, routineTypeDefIR, routineTypeDefIR') = constraint_2
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < _tid*{_tid <- _tid*} , _tid'*{_tid' <- _tid'*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHOD(%)->%`
  -- let extern_method( parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} )-> typeIR_ret_param = methodTypeIR
  -- if routineTypeDefIR' <: polyRoutineTypeDefIR
  -- let routineTypeIR' < _tid''*{_tid'' <- _tid''*} , _tid'''*{_tid''' <- _tid'''*} > = routineTypeDefIR' as polyRoutineTypeDefIR
  -- if routineTypeIR' <: methodTypeIR
  -- let methodTypeIR' = routineTypeIR' as methodTypeIR
  -- if methodTypeIR' matches `EXTERN_METHOD(%)->%`
  -- let extern_method( parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} )-> typeIR_ret_arg = methodTypeIR'
  -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
  -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
  -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}
  -- let constraint_1 = $gen_constraint_types(constraint_0, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- let constraint_2 = $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg)

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:240.1-251.77
  clause 1(constraint_0, routineTypeDefIR, routineTypeDefIR') = constraint_2
  -- if routineTypeDefIR <: polyRoutineTypeDefIR
  -- let routineTypeIR < _tid*{_tid <- _tid*} , _tid'*{_tid' <- _tid'*} > = routineTypeDefIR as polyRoutineTypeDefIR
  -- if routineTypeIR <: methodTypeIR
  -- let methodTypeIR = routineTypeIR as methodTypeIR
  -- if methodTypeIR matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} )-> typeIR_ret_param = methodTypeIR
  -- if routineTypeDefIR' <: polyRoutineTypeDefIR
  -- let routineTypeIR' < _tid''*{_tid'' <- _tid''*} , _tid'''*{_tid''' <- _tid'''*} > = routineTypeDefIR' as polyRoutineTypeDefIR
  -- if routineTypeIR' <: methodTypeIR
  -- let methodTypeIR' = routineTypeIR' as methodTypeIR
  -- if methodTypeIR' matches `EXTERN_METHODABSTRACT(%)->%`
  -- let extern_methodabstract( parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} )-> typeIR_ret_arg = methodTypeIR'
  -- (let direction typeIR_param _id _value?{_value <- _value?} = parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}
  -- (let direction' typeIR_arg _id' _value'?{_value' <- _value'?} = parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}
  -- (if (direction' = direction))*{direction <- direction*, direction' <- direction'*}
  -- let constraint_1 = $gen_constraint_types(constraint_0, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})
  -- let constraint_2 = $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:29.1-32.15
def $gen_constraint_routines(constraint, routineTypeDefIR*, routineTypeDefIR*) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:255.1-266.12
  clause 0(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*}) = $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})
  -- (let constraint_pair = $gen_constraint_routine(constraint, routineTypeDefIR_param, routineTypeDefIR_arg))*{constraint_pair <- constraint_pair*, routineTypeDefIR_arg <- routineTypeDefIR_arg*, routineTypeDefIR_param <- routineTypeDefIR_param*}

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:34.1-34.59
def $merge_constraint(constraint, constraint) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:272.1-276.52
  clause 0(constraint_pre, constraint_post) = $merge_constraint'(constraint_pre, constraint_post, tid_pre*{tid_pre <- tid_pre*}, { [] })
  -- let { tid_pre*{tid_pre <- tid_pre*} } = $dom_map<tid, infer>(constraint_pre)
  -- let { tid_post*{tid_post <- tid_post*} } = $dom_map<tid, infer>(constraint_post)
  -- if $eq_set<tid>({ tid_pre*{tid_pre <- tid_pre*} }, { tid_post*{tid_post <- tid_post*} })

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:35.1-35.78
def $merge_constraint'(constraint, constraint, tid*, constraint) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:278.1-281.15
  clause 0(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = constraint
  -- if tid*{tid <- tid*} matches []

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:283.1-292.60
  clause 1(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- if (?(unknown) = $find_map<tid, infer>(constraint_pre, tid_h))
  -- if (?(unknown) = $find_map<tid, infer>(constraint_post, tid_h))
  -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, unknown)

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:294.1-303.73
  clause 2(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- if (?(unknown) = $find_map<tid, infer>(constraint_pre, tid_h))
  -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_post, tid_h)
  -- if infer'?{infer' <- infer'?} matches (_)
  -- let ?(infer) = infer'?{infer' <- infer'?}
  -- if infer matches `KNOWNAS%`
  -- let knownas typeIR_post = infer
  -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, knownas typeIR_post)

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:305.1-314.72
  clause 3(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
  -- if infer'?{infer' <- infer'?} matches (_)
  -- let ?(infer) = infer'?{infer' <- infer'?}
  -- if infer matches `KNOWNAS%`
  -- let knownas typeIR_pre = infer
  -- if (?(unknown) = $find_map<tid, infer>(constraint_post, tid_h))
  -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, knownas typeIR_pre)

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:316.1-326.73
  clause 4(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
  -- if infer'?{infer' <- infer'?} matches (_)
  -- let ?(infer) = infer'?{infer' <- infer'?}
  -- if infer matches `KNOWNAS%`
  -- let knownas typeIR_pre = infer
  -- let infer'''?{infer''' <- infer'''?} = $find_map<tid, infer>(constraint_post, tid_h)
  -- if infer'''?{infer''' <- infer'''?} matches (_)
  -- let ?(infer'') = infer'''?{infer''' <- infer'''?}
  -- if infer'' matches `KNOWNAS%`
  -- let knownas typeIR_post = infer''
  -- if Sub_impl: typeIR_pre <: typeIR_post holds
  -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, knownas typeIR_post)

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:328.1-339.72
  clause 5(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint) = $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)
  -- if tid*{tid <- tid*} matches _ :: _
  -- let tid_h :: tid_t*{tid_t <- tid_t*} = tid*{tid <- tid*}
  -- let infer'?{infer' <- infer'?} = $find_map<tid, infer>(constraint_pre, tid_h)
  -- if infer'?{infer' <- infer'?} matches (_)
  -- let ?(infer) = infer'?{infer' <- infer'?}
  -- if infer matches `KNOWNAS%`
  -- let knownas typeIR_pre = infer
  -- let infer'''?{infer''' <- infer'''?} = $find_map<tid, infer>(constraint_post, tid_h)
  -- if infer'''?{infer''' <- infer'''?} matches (_)
  -- let ?(infer'') = infer'''?{infer''' <- infer'''?}
  -- if infer'' matches `KNOWNAS%`
  -- let knownas typeIR_post = infer''
  -- if ~Sub_impl: typeIR_pre <: typeIR_post holds
  -- if Sub_impl: typeIR_post <: typeIR_pre holds
  -- let constraint_updated = $update_map<tid, infer>(constraint, tid_h, knownas typeIR_pre)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:36.1-36.61
def $merge_constraints(constraint, constraint*) : constraint =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:341.1-341.61
  clause 0(constraint_pre, constraint*{constraint <- constraint*}) = constraint_pre
  -- if constraint*{constraint <- constraint*} matches []

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:343.1-351.65
  clause 1(constraint_pre_0, constraint*{constraint <- constraint*}) = constraint_pre_2
  -- if constraint*{constraint <- constraint*} matches _ :: _
  -- let constraint_post_h :: constraint_post_t*{constraint_post_t <- constraint_post_t*} = constraint*{constraint <- constraint*}
  -- let constraint_pre_1 = $merge_constraint(constraint_pre_0, constraint_post_h)
  -- let constraint_pre_2 = $merge_constraints(constraint_pre_1, constraint_post_t*{constraint_post_t <- constraint_post_t*})

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:38.1-38.48
def $resolve_constraint(constraint) : inference =

  ;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:357.1-359.35
  clause 0({ tid : infer*{infer <- infer*, tid <- tid*} }) = { tid : typeIR*{tid <- tid*, typeIR <- typeIR*} }
  -- (let infer' = infer)*{infer <- infer*, infer' <- infer'*}
  -- (if infer' matches `KNOWNAS%`)*{infer' <- infer'*}
  -- (let knownas typeIR = infer')*{infer' <- infer'*, typeIR <- typeIR*}

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:21.1-21.65
def $instantiable_extern(cursor, typingContext, instctxt) : bool =

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:23.1-23.54
  clause 0(cursor, TC, instctxt) = true
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:24.1-24.53
  clause 1(cursor, TC, instctxt) = true
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:25.1-25.53
  clause 2(cursor, TC, instctxt) = true
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:27.1-27.65
def $instantiable_parser(cursor, typingContext, instctxt) : bool =

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:29.1-30.20
  clause 0(cursor, TC, instctxt) = (instctxt = anon)
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:31.1-32.40
  clause 1(cursor, TC, instctxt) = $is_parser_blockKind(TC.block.kind)
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:33.1-34.46
  clause 2(cursor, TC, instctxt) = $is_parser_state_localKind(TC.local.kind)
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:36.1-36.66
def $instantiable_control(cursor, typingContext, instctxt) : bool =

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:38.1-39.20
  clause 0(cursor, TC, instctxt) = (instctxt = anon)
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:40.1-41.41
  clause 1(cursor, TC, instctxt) = $is_control_blockKind(TC.block.kind)
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:42.1-43.54
  clause 2(cursor, TC, instctxt) = $is_control_apply_method_localKind(TC.local.kind)
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:45.1-45.66
def $instantiable_package(cursor, typingContext, instctxt) : bool =

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:47.1-47.55
  clause 0(cursor, TC, instctxt) = true
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:48.1-49.41
  clause 1(cursor, TC, instctxt) = $is_package_blockKind(TC.block.kind)
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:50.1-50.55
  clause 2(cursor, TC, instctxt) = false
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:52.1-52.64
def $instantiable_table(cursor, typingContext, instctxt) : bool =

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:54.1-54.54
  clause 0(cursor, TC, instctxt) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:55.1-56.41
  clause 1(cursor, TC, instctxt) = $is_control_blockKind(TC.block.kind)
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:57.1-57.53
  clause 2(cursor, TC, instctxt) = false
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:59.1-59.66
def $instantiable(cursor, typingContext, instctxt, typeIR) : bool =

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:61.1-63.49
  clause 0(p, TC, instctxt, typeIR) = $instantiable_extern(p, TC, instctxt)
  -- if $is_extern_object_typeIR($canon(typeIR))

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:64.1-66.49
  clause 1(p, TC, instctxt, typeIR) = $instantiable_parser(p, TC, instctxt)
  -- if $is_parser_object_typeIR($canon(typeIR))

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:67.1-69.50
  clause 2(p, TC, instctxt, typeIR) = $instantiable_control(p, TC, instctxt)
  -- if $is_control_object_typeIR($canon(typeIR))

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:70.1-72.50
  clause 3(p, TC, instctxt, typeIR) = $instantiable_package(p, TC, instctxt)
  -- if $is_package_object_typeIR($canon(typeIR))

  ;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:73.1-75.48
  clause 4(p, TC, instctxt, typeIR) = $instantiable_table(p, TC, instctxt)
  -- if $is_table_object_typeIR($canon(typeIR))

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:55.1-55.33
def $lvalue(lvalue) : expression =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:56.1-56.55
  clause 0(lvalue) = referenceExpression as expression
  -- if lvalue <: referenceExpression
  -- let referenceExpression = lvalue as referenceExpression

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:57.1-59.47
  clause 1(lvalue) = expression_base as memberAccessBase . member as expression
  -- if lvalue matches `%.%`
  -- let lvalue_base . member = lvalue
  -- let expression_base = $lvalue(lvalue_base)

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:60.1-62.47
  clause 2(lvalue) = expression_base [ expression_index ] as expression
  -- if lvalue matches `%[%]`
  -- let lvalue_base [ expression_index ] = lvalue
  -- let expression_base = $lvalue(lvalue_base)

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:63.1-65.47
  clause 3(lvalue) = expression_base [ expression_hi : expression_lo ] as expression
  -- if lvalue matches `%[%:%]`
  -- let lvalue_base [ expression_hi : expression_lo ] = lvalue
  -- let expression_base = $lvalue(lvalue_base)

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:66.1-67.37
  clause 4(lvalue') = ( expression ) as expression
  -- if lvalue' matches `(%)`
  -- let ( lvalue ) = lvalue'
  -- let expression = $lvalue(lvalue)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:239.1-239.61
def $callable_builtin_function(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:241.1-241.50
  clause 0(cursor, TC) = true
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:242.1-242.49
  clause 1(cursor, TC) = true
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:243.1-243.49
  clause 2(cursor, TC) = true
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:266.1-266.53
def $callable_function(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:268.1-268.43
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:269.1-271.44
  clause 1(cursor, TC) = ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:272.1-274.60
  clause 2(cursor, TC) = (~$is_extern_method_localKind(TC.local.kind) /\ ~$is_extern_abstract_method_localKind(TC.local.kind))
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:310.1-310.60
def $callable_extern_function(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:312.1-312.50
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:313.1-315.44
  clause 1(cursor, TC) = ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:316.1-316.48
  clause 2(cursor, TC) = true
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:352.1-352.51
def $callable_action(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:354.1-354.41
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:355.1-355.40
  clause 1(cursor, TC) = false
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:356.1-358.57
  clause 2(cursor, TC) = ($is_action_localKind(TC.local.kind) \/ $is_control_apply_method_localKind(TC.local.kind))
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:383.1-383.59
def $callable_builtin_method(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:385.1-385.48
  clause 0(cursor, TC) = true
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:386.1-386.47
  clause 1(cursor, TC) = true
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:387.1-387.47
  clause 2(cursor, TC) = true
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:410.1-410.58
def $callable_extern_method(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:412.1-412.48
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:413.1-415.44
  clause 1(cursor, TC) = ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:416.1-416.46
  clause 2(cursor, TC) = true
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:452.1-452.67
def $callable_extern_abstract_method(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:454.1-454.57
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:455.1-457.44
  clause 1(cursor, TC) = ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:458.1-458.55
  clause 2(cursor, TC) = true
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:494.1-494.64
def $callable_parser_apply_method(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:496.1-496.54
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:497.1-497.53
  clause 1(cursor, TC) = false
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:498.1-499.46
  clause 2(cursor, TC) = $is_parser_state_localKind(TC.local.kind)
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:522.1-522.65
def $callable_control_apply_method(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:524.1-524.55
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:525.1-525.54
  clause 1(cursor, TC) = false
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:526.1-527.54
  clause 2(cursor, TC) = $is_control_apply_method_localKind(TC.local.kind)
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:550.1-550.63
def $callable_table_apply_method(cursor, typingContext) : bool =

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:552.1-552.53
  clause 0(cursor, TC) = false
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:553.1-553.52
  clause 1(cursor, TC) = false
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:554.1-556.55
  clause 2(cursor, TC) = ($is_control_apply_method_localKind(TC.local.kind) \/ $is_table_apply_method_localKind(TC.local.kind))
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:5.1-5.27
def $empty_theta : theta =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:6.1-6.47
  clause 0 = $empty_map<tid, typeIR>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:8.15-8.29
syntax venv = map<id, value>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:10.1-10.25
def $empty_venv : venv =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:11.1-11.42
  clause 0 = $empty_map<id, value>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:13.19-13.41
syntax stateDyn = parserBlockStatementIR

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:15.15-15.34
syntax senv = map<name, stateDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:17.1-17.25
def $empty_senv : senv =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:18.1-18.47
  clause 0 = $empty_map<name, stateDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:25.1-28.34
syntax lvalueDyn = 
   | ` nameIR
   | . nameIR
   | lvalueDyn . nameIR
   | lvalueDyn [ value ]
   | lvalueDyn [ value : value ]

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:37.1-40.96
syntax funcDyn = 
   | builtin_function< typeParameterListIR >( parameterListIR ){ blockElementStatementListIR }
   | function< typeParameterListIR >( parameterListIR ) blockStatementIR
   | action( parameterListIR ){ blockStatementIR }
   | extern_function< typeParameterListIR >( parameterListIR ){ blockElementStatementIR? }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:43.1-48.41
syntax methodDyn = 
   | builtin_method( parameterListIR )# lvalueDyn
   | extern_method< typeParameterListIR >( parameterListIR )
   | extern_methodabstract< typeParameterListIR >( parameterListIR )
   | parser_apply( parameterListIR ){ parserLocalDeclarationListIR ; senv }
   | control_apply( parameterListIR ){ controlLocalDeclarationListIR ; renv ; blockElementStatementListIR }
   | table_apply{ tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:51.1-52.14
syntax routineDyn = 
   | builtin_function< typeParameterListIR >( parameterListIR ){ blockElementStatementListIR }
   | function< typeParameterListIR >( parameterListIR ) blockStatementIR
   | action( parameterListIR ){ blockStatementIR }
   | extern_function< typeParameterListIR >( parameterListIR ){ blockElementStatementIR? }
   | builtin_method( parameterListIR )# lvalueDyn
   | extern_method< typeParameterListIR >( parameterListIR )
   | extern_methodabstract< typeParameterListIR >( parameterListIR )
   | parser_apply( parameterListIR ){ parserLocalDeclarationListIR ; senv }
   | control_apply( parameterListIR ){ controlLocalDeclarationListIR ; renv ; blockElementStatementListIR }
   | table_apply{ tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:55.15-55.35
syntax renv = map<rid, routineDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:57.1-57.25
def $empty_renv : renv =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:58.1-58.48
  clause 0 = $empty_map<rid, routineDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:65.1-69.42
syntax consDyn = 
   | extern nameIR < typeParameterListIR >( constructorParameterListIR ){ methodPrototypeListIR }
   | parser< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
   | control< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
   | package< typeParameterListIR >( constructorParameterListIR )
   | table nameIR { tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:72.15-72.32
syntax cenv = map<cid, consDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:74.1-74.25
def $empty_cenv : cenv =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:75.1-75.45
  clause 0 = $empty_map<cid, consDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:82.1-86.44
syntax objDyn = 
   | extern{ tid theta venv renv }
   | parser{ venv parameterListIR parserLocalDeclarationListIR senv }
   | control{ venv parameterListIR controlLocalDeclarationListIR renv controlBodyIR }
   | package{ theta venv }
   | table{ tid venv tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:89.14-89.30
syntax sto = map<oid, objDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:91.1-91.23
def $empty_sto : sto =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:93.1-93.43
  clause 0 = $empty_map<oid, objDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:95.1-95.37
def $add_sto(sto, oid, objDyn) : sto =

  ;; ../../../../spec-concrete/6.01-env-dynamic.watsup:97.1-98.44
  clause 0(sto, oid, objDyn) = $add_map<oid, objDyn>(sto, oid, objDyn)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:8.3-11.16
syntax glayerInst = {cenv cenv, tdenv tdenv, renv renv, venv venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:16.3-19.16
syntax blayerInst = {theta theta, renv renv, senv senv, venv venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:24.3-25.18
syntax llayerInst = {theta theta, venvs venv*}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:32.3-35.23
syntax contextInst = {path oid, global glayerInst, block blayerInst, local llayerInst}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:43.1-43.32
def $empty_block : blayerInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:45.1-49.23
  clause 0 = {theta $empty_theta, renv $empty_renv, senv $empty_senv, venv $empty_venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:51.1-51.32
def $empty_local : llayerInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:53.1-55.17
  clause 0 = {theta $empty_theta, venvs []}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:57.1-57.40
def $empty_context_inst : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:59.1-67.82
  clause 0 = Ci
  -- let glayerInst = {cenv $empty_cenv, tdenv $empty_tdenv, renv $empty_renv, venv $empty_venv}
  -- let blayerInst = $empty_block
  -- let llayerInst = $empty_local
  -- let Ci = {path [], global glayerInst, block blayerInst, local llayerInst}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:74.1-74.43
def $enter_inst(contextInst) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:76.1-76.73
  clause 0(Ci) = Ci[local.venvs = $empty_venv :: Ci.local.venvs]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:78.1-78.42
def $exit_inst(contextInst) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:80.1-81.43
  clause 0(Ci) = Ci[local.venvs = venv_t*{venv_t <- venv_t*}]
  -- let venv*{venv <- venv*} = Ci.local.venvs
  -- if venv*{venv <- venv*} matches _ :: _
  -- let venv_h :: venv_t*{venv_t <- venv_t*} = venv*{venv <- venv*}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:87.1-87.47
def $enter_path(contextInst, id) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:89.1-89.54
  clause 0(Ci, id) = Ci[path = Ci.path ++ [id]]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:95.1-95.58
def $copy_context_inst(cursor, contextInst) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:97.1-97.90
  clause 0(cursor, Ci) = Ci[block = $empty_block][local = $empty_local]
  -- if cursor matches `GLOBAL`

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:98.1-98.64
  clause 1(cursor, Ci) = Ci[local = $empty_local]
  -- if cursor matches `BLOCK`

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:99.1-99.39
  clause 2(cursor, Ci) = Ci
  -- if cursor matches `LOCAL`

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:107.1-107.65
def $add_value_inst(cursor, contextInst, id, value) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:110.1-111.62
  clause 0(cursor, Ci, id, value) = Ci[global.venv = venv]
  -- if cursor matches `GLOBAL`
  -- let venv = $add_map<id, value>(Ci.global.venv, id, value)

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:112.1-113.61
  clause 1(cursor, Ci, id, value) = Ci[block.venv = venv]
  -- if cursor matches `BLOCK`
  -- let venv = $add_map<id, value>(Ci.block.venv, id, value)

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:114.1-116.57
  clause 2(cursor, Ci, id, value) = Ci[local.venvs = venv_h :: venv_t*{venv_t <- venv_t*}]
  -- if cursor matches `LOCAL`
  -- let venv*{venv <- venv*} = Ci.local.venvs
  -- if venv*{venv <- venv*} matches _ :: _
  -- let venv_h :: venv_t*{venv_t <- venv_t*} = venv*{venv <- venv*}
  -- let venv_h' = $add_map<id, value>(venv_h, id, value)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:108.1-108.68
def $add_values_inst(cursor, contextInst, id*, value*) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:118.1-118.43
  clause 0(p, Ci, id*{id <- id*}, value*{value <- value*}) = Ci
  -- if id*{id <- id*} matches []
  -- if value*{value <- value*} matches []

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:119.1-121.57
  clause 1(p, Ci, id*{id <- id*}, value*{value <- value*}) = Ci''
  -- if id*{id <- id*} matches _ :: _
  -- let id_h :: id_t*{id_t <- id_t*} = id*{id <- id*}
  -- if value*{value <- value*} matches _ :: _
  -- let value_h :: value_t*{value_t <- value_t*} = value*{value <- value*}
  -- let Ci' = $add_value_inst(p, Ci, id_h, value_h)
  -- let Ci'' = $add_values_inst(p, Ci', id_t*{id_t <- id_t*}, value_t*{value_t <- value_t*})

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:125.1-125.83
def $add_routine_overload_inst(cursor, contextInst, rid, routineDyn) : contextInst =

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:127.1-127.87
def $add_routine_non_overload_inst(cursor, contextInst, rid, routineDyn) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:129.1-131.74
  clause 0(cursor, Ci, rid, routineDyn) = Ci[global.renv = renv]
  -- if cursor matches `GLOBAL`
  -- if ~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.global.renv))
  -- let renv = $add_map<rid, routineDyn>(Ci.global.renv, rid, routineDyn)

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:133.1-135.73
  clause 1(cursor, Ci, rid, routineDyn) = Ci[block.renv = renv]
  -- if cursor matches `BLOCK`
  -- if ~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.block.renv))
  -- let renv = $add_map<rid, routineDyn>(Ci.block.renv, rid, routineDyn)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:137.1-137.84
def $add_tparams_inst(cursor, contextInst, typeParameterIR*, typeIR*) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:141.1-141.44
  clause 0(p, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeIR*{typeIR <- typeIR*}) = Ci
  -- if typeParameterIR*{typeParameterIR <- typeParameterIR*} matches []
  -- if typeIR*{typeIR <- typeIR*} matches []

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:142.1-144.67
  clause 1(p, Ci, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeIR*{typeIR <- typeIR*}) = $add_tparams_inst(p, Ci', typeParameterIR_t*{typeParameterIR_t <- typeParameterIR_t*}, typeIR_t*{typeIR_t <- typeIR_t*})
  -- if typeParameterIR*{typeParameterIR <- typeParameterIR*} matches _ :: _
  -- let typeParameterIR_h :: typeParameterIR_t*{typeParameterIR_t <- typeParameterIR_t*} = typeParameterIR*{typeParameterIR <- typeParameterIR*}
  -- if typeIR*{typeIR <- typeIR*} matches _ :: _
  -- let typeIR_h :: typeIR_t*{typeIR_t <- typeIR_t*} = typeIR*{typeIR <- typeIR*}
  -- let Ci' = $add_tparam_inst(p, Ci, typeParameterIR_h, typeIR_h)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:138.1-138.81
def $add_tparam_inst(cursor, contextInst, typeParameterIR, typeIR) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:146.1-147.79
  clause 0(cursor, Ci, typeParameterIR, typeIR) = Ci[block.theta = theta]
  -- if cursor matches `BLOCK`
  -- let theta = $add_map<tid, typeIR>(Ci.block.theta, typeParameterIR, typeIR)

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:148.1-149.79
  clause 1(cursor, Ci, typeParameterIR, typeIR) = Ci[local.theta = theta]
  -- if cursor matches `LOCAL`
  -- let theta = $add_map<tid, typeIR>(Ci.local.theta, typeParameterIR, typeIR)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:152.1-152.75
def $add_constructor_inst(cursor, contextInst, cid, consDyn) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:154.1-155.68
  clause 0(cursor, Ci, cid, consDyn) = Ci[global.cenv = cenv]
  -- if cursor matches `GLOBAL`
  -- let cenv = $add_map<cid, consDyn>(Ci.global.cenv, cid, consDyn)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:158.1-158.73
def $add_typedef_inst(cursor, contextInst, tid, typeDefIR) : contextInst =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:160.1-161.74
  clause 0(cursor, Ci, tid, typeDefIR) = Ci[global.tdenv = tdenv]
  -- if cursor matches `GLOBAL`
  -- let tdenv = $add_map<tid, typeDefIR>(Ci.global.tdenv, tid, typeDefIR)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:169.1-169.59
def $find_value_inst(cursor, contextInst, nameIR) : value? =

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:172.1-172.66
def $find_type_inst(cursor, contextInst, prefixedNameIR) : typeIR =

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:176.1-176.65
def $find_typedef_inst(cursor, contextInst, nameIR) : typeDefIR? =

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:180.1-180.44
def $ids_arguments_IR(argumentIR*) : id?* =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:183.1-183.68
  clause 0(argumentIR*{argumentIR <- argumentIR*}) = $id_argument_IR(argumentIR)*{argumentIR <- argumentIR*}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:181.1-181.38
def $id_argument_IR(argumentIR) : id? =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:184.1-184.45
  clause 0(argumentIR) = ?()
  -- if argumentIR <: typedExpressionIR
  -- let typedExpressionIR = argumentIR as typedExpressionIR

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:185.1-185.42
  clause 1(argumentIR) = ?(nameIR)
  -- if argumentIR matches `%=%`
  -- let nameIR = _typedExpressionIR = argumentIR

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:186.1-186.43
  clause 2(argumentIR) = ?(nameIR)
  -- if argumentIR matches `%=_`
  -- let nameIR =_ = argumentIR

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:187.1-187.30
  clause 3(argumentIR) = ?()
  -- if argumentIR matches `_`

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:189.1-189.103
def $find_constructor_overloaded_inst(contextInst, prefixedNameIR, argumentIR*) : (rid, consDyn, id*)? =

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:190.1-192.52
  clause 0(Ci, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<consDyn>(Ci.global.cenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if prefixedNameIR matches ``%`
  -- let ` id = prefixedNameIR
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments_IR(argumentIR*{argumentIR <- argumentIR*})

  ;; ../../../../spec-concrete/6.02-context-instantiation.watsup:194.1-196.52
  clause 1(Ci, prefixedNameIR, argumentIR*{argumentIR <- argumentIR*}) = $find_overloaded<consDyn>(Ci.global.cenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})
  -- if prefixedNameIR matches `.%`
  -- let . id = prefixedNameIR
  -- let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} = $ids_arguments_IR(argumentIR*{argumentIR <- argumentIR*})

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:3.1-5.17
relation Program_inst: |- p4programIR ==> cenv tdenv renv venv sto

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:377.1-381.72
  rulegroup  {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:377.1-381.72
    rule : |- declarationIR*{declarationIR <- declarationIR*} ; ==> Ci_1.global.cenv Ci_1.global.tdenv Ci_1.global.renv Ci_1.global.venv sto_1
    -- let Ci_0 = $empty_context_inst
    -- let sto_0 = $empty_sto
    -- Decls_inst: global Ci_0 sto_0 |- declarationIR*{declarationIR <- declarationIR*} ==> Ci_1 sto_1 declarationIR'*{declarationIR' <- declarationIR'*}
    -- if declarationIR'*{declarationIR' <- declarationIR'*} matches []
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:7.1-9.35
relation Constructor_inst: cursor contextInst sto |- consDyn < typeArgumentListIR >( argumentListIR # id* )==> sto objDyn

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:93.1-110.75
  rulegroup extern {


    ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:93.1-110.75
    rule extern: p Ci sto |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> sto' extern{ nameIR Ci_callee_4.block.theta Ci_callee_4.block.venv Ci_callee_4.block.renv }
    -- if consDyn matches `EXTERN%<%>(%){%}`
    -- let extern nameIR < typeParameterIR*{typeParameterIR <- typeParameterIR*} >( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} } = consDyn
    -- let p_callee = block
    -- let Ci_callee_0 = $copy_context_inst(global, Ci)
    -- let Ci_callee_1 = $add_tparams_inst(global, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
    -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
    -- Eval_args: p p_callee Ci_callee_1 sto |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto'
    -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
    -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
    -- Methods_inst: block Ci_callee_3 |- methodPrototypeIR*{methodPrototypeIR <- methodPrototypeIR*} ==> Ci_callee_4
  }

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:112.1-130.77
  rulegroup parser {


    ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:112.1-130.77
    rule parser: p Ci sto |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> sto''' parser{ Ci_callee_3.block.venv parameterIR*{parameterIR <- parameterIR*} parserLocalDeclarationIR'*{parserLocalDeclarationIR' <- parserLocalDeclarationIR'*} Ci_state.block.senv }
    -- if consDyn matches `PARSER<%>(%)(%){%%}`
    -- let parser< typeParameterIR*{typeParameterIR <- typeParameterIR*} >( parameterIR*{parameterIR <- parameterIR*} )( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} parserStateIR*{parserStateIR <- parserStateIR*} } = consDyn
    -- let p_callee = block
    -- let Ci_callee_0 = $copy_context_inst(global, Ci)
    -- let Ci_callee_1 = $add_tparams_inst(global, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
    -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
    -- Eval_args: p p_callee Ci_callee_1 sto |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto'
    -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
    -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
    -- ParserLocalDecls_inst: block Ci_callee_3 sto' |- parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} ==> Ci_local sto'' parserLocalDeclarationIR'*{parserLocalDeclarationIR' <- parserLocalDeclarationIR'*}
    -- ParserStates_inst: Ci_local sto'' |- parserStateIR*{parserStateIR <- parserStateIR*} ==> Ci_state sto'''
  }

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:132.1-150.82
  rulegroup control {


    ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:132.1-150.82
    rule control: p Ci sto |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> sto''' control{ Ci_callee_3.block.venv parameterIR*{parameterIR <- parameterIR*} controlLocalDeclarationIR'*{controlLocalDeclarationIR' <- controlLocalDeclarationIR'*} Ci_local.block.renv controlBodyIR' }
    -- if consDyn matches `CONTROL<%>(%)(%){%APPLY%}`
    -- let control< typeParameterIR*{typeParameterIR <- typeParameterIR*} >( parameterIR*{parameterIR <- parameterIR*} )( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ){ controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} apply controlBodyIR } = consDyn
    -- let p_callee = block
    -- let Ci_callee_0 = $copy_context_inst(global, Ci)
    -- let Ci_callee_1 = $add_tparams_inst(global, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
    -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
    -- Eval_args: p p_callee Ci_callee_1 sto |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto'
    -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
    -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
    -- ControlLocalDecls_inst: Ci_callee_3 sto' |- controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} ==> Ci_local sto'' controlLocalDeclarationIR'*{controlLocalDeclarationIR' <- controlLocalDeclarationIR'*}
    -- Block_inst: Ci_local sto'' true |- controlBodyIR ==> _contextInst sto''' controlBodyIR'
  }

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:152.1-168.98
  rulegroup package {


    ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:152.1-168.98
    rule package: p Ci sto_0 |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> sto_1 package{ Ci_callee_3.block.theta Ci_callee_3.block.venv }
    -- if consDyn matches `PACKAGE<%>(%)`
    -- let package< typeParameterIR*{typeParameterIR <- typeParameterIR*} >( constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} ) = consDyn
    -- let p_callee = block
    -- let Ci_callee_0 = $copy_context_inst(global, Ci)
    -- let Ci_callee_1 = $add_tparams_inst(global, Ci_callee_0, typeParameterIR*{typeParameterIR <- typeParameterIR*}, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
    -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
    -- Eval_args: p p_callee Ci_callee_1 sto_0 |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto_1
    -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
    -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
  }

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:175.1-194.41
  rulegroup table {


    ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:175.1-194.41
    rule table: p Ci sto |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> sto' table{ nameIR venv tablePropertyListIR_inst }
    -- if consDyn matches `TABLE%{%}`
    -- let table nameIR { tablePropertyListIR } = consDyn
    -- let p_callee = local
    -- let Ci_callee_0 = $copy_context_inst(global, Ci)
    -- let Ci_callee_1 = $add_tparams_inst(global, Ci_callee_0, [], typeArgumentIR*{typeArgumentIR <- typeArgumentIR*})
    -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*}) = $align_cparams_with_args([], argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*})
    -- (let _annotationList _direction _typeIR id_aligned _constantInitializerOptIR = constructorParameterIR_aligned)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_aligned <- constructorParameterIR_aligned*, id_aligned <- id_aligned*}
    -- Eval_args: p p_callee Ci_callee_1 sto |- id_aligned*{id_aligned <- id_aligned*} argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*} ==> Ci_callee_2 sto'
    -- (let _annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR' = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR' <- _constantInitializerOptIR'*, _direction' <- _direction'*, _typeIR' <- _typeIR'*, constructorParameterIR_default <- constructorParameterIR_default*, id_cparam_default <- id_cparam_default*}
    -- let Ci_callee_3 = $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*{id_cparam_default <- id_cparam_default*}, value_default*{value_default <- value_default*})
    -- let Ci_frame = $enter_inst(Ci_callee_3)
    -- TableProperties_inst: Ci_frame sto' |- tablePropertyListIR ==> Ci_table sto'' tablePropertyListIR_inst
    -- let venv'*{venv' <- venv'*} = Ci_table.local.venvs
    -- if venv'*{venv' <- venv'*} matches _ :: _
    -- let venv :: _venv*{_venv <- _venv*} = venv'*{venv' <- venv'*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:19.1-21.26
relation Exprs_inst: cursor contextInst sto |- typedExpressionIR* ==> sto value*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:23.1-25.26
relation Expr_inst: cursor contextInst sto |- typedExpressionIR ==> sto value

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:8.1-9.41
  rulegroup literalExpressionIR-true {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:8.1-9.41
    rule literalExpressionIR-true: p Ci sto |- expressionIR # _expressionNoteIR ==> sto b true as value
    -- if (expressionIR = true as expressionIR)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:11.1-12.43
  rulegroup literalExpressionIR-false {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:11.1-12.43
    rule literalExpressionIR-false: p Ci sto |- expressionIR # _expressionNoteIR ==> sto b false as value
    -- if (expressionIR = false as expressionIR)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:15.1-16.39
  rulegroup literalExpressionIR-number-arbint {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:15.1-16.39
    rule literalExpressionIR-number-arbint: p Ci sto |- expressionIR # _expressionNoteIR ==> sto d i as value
    -- if expressionIR <: numberLiteral
    -- let numberLiteral = expressionIR as numberLiteral
    -- if numberLiteral matches `D%`
    -- let d i = numberLiteral
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:18.1-19.43
  rulegroup literalExpressionIR-number-fixint {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:18.1-19.43
    rule literalExpressionIR-number-fixint: p Ci sto |- expressionIR # _expressionNoteIR ==> sto n s i as value
    -- if expressionIR <: numberLiteral
    -- let numberLiteral = expressionIR as numberLiteral
    -- if numberLiteral matches `%S%`
    -- let n s i = numberLiteral
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:21.1-22.43
  rulegroup literalExpressionIR-number-fixbit {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:21.1-22.43
    rule literalExpressionIR-number-fixbit: p Ci sto |- expressionIR # _expressionNoteIR ==> sto n w i as value
    -- if expressionIR <: numberLiteral
    -- let numberLiteral = expressionIR as numberLiteral
    -- if numberLiteral matches `%W%`
    -- let n w i = numberLiteral
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:26.1-27.53
  rulegroup literalExpressionIR-stringLiteral {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:26.1-27.53
    rule literalExpressionIR-stringLiteral: p Ci sto |- expressionIR # _expressionNoteIR ==> sto " text " as value
    -- if expressionIR <: stringLiteral
    -- let " text " = expressionIR as stringLiteral
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:34.1-36.48
  rulegroup referenceExpressionIR-id {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:34.1-36.48
    rule referenceExpressionIR-id: p Ci sto |- expressionIR # _expressionNoteIR ==> sto value
    -- if expressionIR <: prefixedNameIR
    -- let prefixedNameIR = expressionIR as prefixedNameIR
    -- if prefixedNameIR matches ``%`
    -- let ` nameIR = prefixedNameIR
    -- let value'?{value' <- value'?} = $find_value_inst(p, Ci, nameIR)
    -- if value'?{value' <- value'?} matches (_)
    -- let ?(value) = value'?{value' <- value'?}
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:40.1-42.48
  rulegroup referenceExpressionIR-dotName {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:40.1-42.48
    rule referenceExpressionIR-dotName: p Ci sto |- expressionIR # _expressionNoteIR ==> sto value
    -- if expressionIR <: prefixedNameIR
    -- let prefixedNameIR = expressionIR as prefixedNameIR
    -- if prefixedNameIR matches `.%`
    -- let . nameIR = prefixedNameIR
    -- let value'?{value' <- value'?} = $find_value_inst(p, Ci, nameIR)
    -- if value'?{value' <- value'?} matches (_)
    -- let ?(value) = value'?{value' <- value'?}
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:46.1-47.40
  rulegroup defaultExpressionIR {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:46.1-47.40
    rule defaultExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> sto default as value
    -- if (expressionIR = ... as expressionIR)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:53.1-56.32
  rulegroup unaryExpressionIR-lnot {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:53.1-56.32
    rule unaryExpressionIR-lnot: p Ci sto |- expressionIR # _expressionNoteIR ==> sto' value
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
    -- if unop matches `!`
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value
    -- if ($un_lnot(value) = value)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:60.1-63.32
  rulegroup unaryExpressionIR-bnot {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:60.1-63.32
    rule unaryExpressionIR-bnot: p Ci sto |- expressionIR # _expressionNoteIR ==> sto' value
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
    -- if unop matches `~`
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value
    -- if ($un_bnot(value) = value)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:67.1-69.61
  rulegroup unaryExpressionIR-plus {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:67.1-69.61
    rule unaryExpressionIR-plus: p Ci sto |- expressionIR # _expressionNoteIR ==> sto' value
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
    -- if unop matches `+`
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:73.1-76.33
  rulegroup unaryExpressionIR-minus {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:73.1-76.33
    rule unaryExpressionIR-minus: p Ci sto |- expressionIR # _expressionNoteIR ==> sto' value
    -- if expressionIR <: unaryExpressionIR
    -- let unop typedExpressionIR = expressionIR as unaryExpressionIR
    -- if unop matches `-`
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value
    -- if ($un_minus(value) = value)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:83.1-88.43
  rulegroup binaryExpressionIR-mul {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:83.1-88.43
    rule binaryExpressionIR-mul: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `*`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_mul(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:92.1-97.43
  rulegroup binaryExpressionIR-div {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:92.1-97.43
    rule binaryExpressionIR-div: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `/`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_div(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:101.1-106.43
  rulegroup binaryExpressionIR-mod {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:101.1-106.43
    rule binaryExpressionIR-mod: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `%`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_mod(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:110.1-115.44
  rulegroup binaryExpressionIR-plus {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:110.1-115.44
    rule binaryExpressionIR-plus: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `+`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_plus(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:119.1-124.45
  rulegroup binaryExpressionIR-minus {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:119.1-124.45
    rule binaryExpressionIR-minus: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `-`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_minus(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:128.1-133.47
  rulegroup binaryExpressionIR-satplus {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:128.1-133.47
    rule binaryExpressionIR-satplus: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `|+|`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_satplus(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:137.1-142.48
  rulegroup binaryExpressionIR-satminus {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:137.1-142.48
    rule binaryExpressionIR-satminus: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `|-|`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_satminus(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:146.1-151.43
  rulegroup binaryExpressionIR-shl {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:146.1-151.43
    rule binaryExpressionIR-shl: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `<<`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_shl(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:155.1-160.43
  rulegroup binaryExpressionIR-shr {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:155.1-160.43
    rule binaryExpressionIR-shr: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `>>`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_shr(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:164.1-169.41
  rulegroup binaryExpressionIR-le {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:164.1-169.41
    rule binaryExpressionIR-le: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' b bool as value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `<=`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let bool = $bin_le(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:173.1-178.41
  rulegroup binaryExpressionIR-ge {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:173.1-178.41
    rule binaryExpressionIR-ge: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' b bool as value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `>=`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let bool = $bin_ge(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:182.1-187.41
  rulegroup binaryExpressionIR-lt {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:182.1-187.41
    rule binaryExpressionIR-lt: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' b bool as value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `<`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let bool = $bin_lt(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:191.1-196.41
  rulegroup binaryExpressionIR-gt {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:191.1-196.41
    rule binaryExpressionIR-gt: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' b bool as value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `>`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let bool = $bin_gt(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:200.1-205.41
  rulegroup binaryExpressionIR-ne {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:200.1-205.41
    rule binaryExpressionIR-ne: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' b bool as value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `!=`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let bool = $bin_ne(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:209.1-214.41
  rulegroup binaryExpressionIR-eq {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:209.1-214.41
    rule binaryExpressionIR-eq: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' b bool as value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `==`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let bool = $bin_eq(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:218.1-223.44
  rulegroup binaryExpressionIR-band {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:218.1-223.44
    rule binaryExpressionIR-band: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `&`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_band(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:227.1-232.44
  rulegroup binaryExpressionIR-bxor {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:227.1-232.44
    rule binaryExpressionIR-bxor: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `^`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_bxor(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:236.1-241.43
  rulegroup binaryExpressionIR-bor {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:236.1-241.43
    rule binaryExpressionIR-bor: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `|`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_bor(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:245.1-250.46
  rulegroup binaryExpressionIR-concat {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:245.1-250.46
    rule binaryExpressionIR-concat: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `++`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_concat(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:254.1-259.44
  rulegroup binaryExpressionIR-land {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:254.1-259.44
    rule binaryExpressionIR-land: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `&&`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_land(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:262.1-267.43
  rulegroup binaryExpressionIR-lor {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:262.1-267.43
    rule binaryExpressionIR-lor: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value
    -- if expressionIR <: binaryExpressionIR
    -- let typedExpressionIR_l binop typedExpressionIR_r = expressionIR as binaryExpressionIR
    -- if binop matches `||`
    -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l
    -- Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r
    -- let value = $bin_lor(value_l, value_r)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:274.1-279.67
  rulegroup ternaryExpressionIR-then {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:274.1-279.67
    rule ternaryExpressionIR-then: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value_t
    -- if expressionIR <: ternaryExpressionIR
    -- let typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e = expressionIR as ternaryExpressionIR
    -- Expr_inst: p Ci sto |- typedExpressionIR_c ==> sto' value_c
    -- if (value_c = b true as value)
    -- Expr_inst: p Ci sto' |- typedExpressionIR_t ==> sto'' value_t
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:281.1-286.67
  rulegroup ternaryExpressionIR-else {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:281.1-286.67
    rule ternaryExpressionIR-else: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' value_e
    -- if expressionIR <: ternaryExpressionIR
    -- let typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e = expressionIR as ternaryExpressionIR
    -- Expr_inst: p Ci sto |- typedExpressionIR_c ==> sto' value_c
    -- if (value_c = b false as value)
    -- Expr_inst: p Ci sto' |- typedExpressionIR_e ==> sto'' value_e
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:293.1-297.42
  rulegroup castExpressionIR {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:293.1-297.42
    rule castExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> sto' value_c
    -- if expressionIR <: castExpressionIR
    -- let ( typeIR ) typedExpressionIR = expressionIR as castExpressionIR
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value
    -- let value_c = $cast_op(typeIR, value)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:305.1-307.17
  rulegroup dataExpressionIR-invalid {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:305.1-307.17
    rule dataExpressionIR-invalid: p Ci sto |- expressionIR # _expressionNoteIR ==> sto {#} as value
    -- if (expressionIR = {#} as expressionIR)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:311.1-314.67
  rulegroup dataExpressionIR-sequence {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:311.1-314.67
    rule dataExpressionIR-sequence: p Ci sto |- expressionIR # _expressionNoteIR ==> sto' seq( value*{value <- value*} ) as value
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
    -- if dataExpressionIR matches `SEQ{%}`
    -- let seq{ typedExpressionListIR } = dataExpressionIR
    -- Exprs_inst: p Ci sto |- typedExpressionListIR ==> sto' value*{value <- value*}
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:318.1-321.67
  rulegroup dataExpressionIR-sequencedefault {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:318.1-321.67
    rule dataExpressionIR-sequencedefault: p Ci sto |- expressionIR # _expressionNoteIR ==> sto' seq( value*{value <- value*} ,...) as value
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
    -- if dataExpressionIR matches `SEQ{%,...}`
    -- let seq{ typedExpressionListIR ,...} = dataExpressionIR
    -- Exprs_inst: p Ci sto |- typedExpressionListIR ==> sto' value*{value <- value*}
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:325.1-328.64
  rulegroup dataExpressionIR-record {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:325.1-328.64
    rule dataExpressionIR-record: p Ci sto |- expressionIR # _expressionNoteIR ==> sto' record{ value nameIR ;*{nameIR <- nameIR*, value <- value*} } as value
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
    -- if dataExpressionIR matches `RECORD{%}`
    -- let record{ nameIR = typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} } = dataExpressionIR
    -- Exprs_inst: p Ci sto |- typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ==> sto' value*{value <- value*}
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:332.1-335.64
  rulegroup dataExpressionIR-recorddefault {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:332.1-335.64
    rule dataExpressionIR-recorddefault: p Ci sto |- expressionIR # _expressionNoteIR ==> sto' record{ value nameIR ;*{nameIR <- nameIR*, value <- value*} ,...} as value
    -- if expressionIR <: dataExpressionIR
    -- let dataExpressionIR = expressionIR as dataExpressionIR
    -- if dataExpressionIR matches `RECORD{%,...}`
    -- let record{ nameIR = typedExpressionIR*{nameIR <- nameIR*, typedExpressionIR <- typedExpressionIR*} ,...} = dataExpressionIR
    -- Exprs_inst: p Ci sto |- typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ==> sto' value*{value <- value*}
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:346.1-350.49
  rulegroup accessExpressionIR-errorAccessExpressionIR {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:346.1-350.49
    rule accessExpressionIR-errorAccessExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> sto value
    -- if expressionIR <: errorAccessExpressionIR
    -- let error. nameIR = expressionIR as errorAccessExpressionIR
    -- let nameIR' = $concat_text(["error.", nameIR])
    -- let value'?{value' <- value'?} = $find_value_inst(p, Ci, nameIR')
    -- if value'?{value' <- value'?} matches (_)
    -- let ?(value) = value'?{value' <- value'?}
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:359.1-364.41
  rulegroup accessExpressionIR-memberAccessExpressionIR-typeaccess-enum {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:359.1-364.41
    rule accessExpressionIR-memberAccessExpressionIR-typeaccess-enum: p Ci sto |- expressionIR # _expressionNoteIR ==> sto tid . nameIR as value
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR matches `TYPE%`
    -- let type prefixedNameIR = memberAccessBaseIR
    -- let nameIR_type = $flatten_prefixedNameIR(prefixedNameIR)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(p, Ci, nameIR_type)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR = typeDefIR as typeIR
    -- let typeIR' = $canon(typeIR)
    -- if typeIR' <: enumTypeIR
    -- let enumTypeIR = typeIR' as enumTypeIR
    -- if enumTypeIR matches `ENUM%{%}`
    -- let enum tid { _id*{_id <- _id*} } = enumTypeIR
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:366.1-372.65
  rulegroup accessExpressionIR-memberAccessExpressionIR-senum {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:366.1-372.65
    rule accessExpressionIR-memberAccessExpressionIR-senum: p Ci sto |- expressionIR # _expressionNoteIR ==> sto tid . nameIR # value as value
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . nameIR = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR matches `TYPE%`
    -- let type prefixedNameIR = memberAccessBaseIR
    -- let nameIR_type = $flatten_prefixedNameIR(prefixedNameIR)
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(p, Ci, nameIR_type)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- if typeDefIR <: typeIR
    -- let typeIR = typeDefIR as typeIR
    -- let typeIR' = $canon(typeIR)
    -- if typeIR' <: enumTypeIR
    -- let enumTypeIR = typeIR' as enumTypeIR
    -- if enumTypeIR matches `ENUM%#%{%}`
    -- let enum tid # _typeIR { id_f = value_f ;*{id_f <- id_f*, value_f <- value_f*} } = enumTypeIR
    -- let value'?{value' <- value'?} = $assoc_<nameIR, value>(nameIR, (id_f, value_f)*{id_f <- id_f*, value_f <- value_f*})
    -- if value'?{value' <- value'?} matches (_)
    -- let ?(value) = value'?{value' <- value'?}
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:376.1-380.39
  rulegroup accessExpressionIR-memberAccessExpressionIR-typedExpressionIR {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:376.1-380.39
    rule accessExpressionIR-memberAccessExpressionIR-typedExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> sto' d nat_s as int as value
    -- if expressionIR <: memberAccessExpressionIR
    -- let memberAccessBaseIR . text = expressionIR as memberAccessExpressionIR
    -- if memberAccessBaseIR <: typedExpressionIR
    -- let typedExpressionIR = memberAccessBaseIR as typedExpressionIR
    -- if (text = "size")
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value
    -- let value' = value
    -- if value' <: headerStackValue
    -- let [ _value*{_value <- _value*} #( _nat ; nat_s )] = value' as headerStackValue
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:388.1-394.54
  rulegroup indexAccessExpressionIR-bitslice {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:388.1-394.54
    rule indexAccessExpressionIR-bitslice: p Ci sto |- expressionIR # _expressionNoteIR ==> sto''' value
    -- if expressionIR <: indexAccessExpressionIR
    -- let indexAccessExpressionIR = expressionIR as indexAccessExpressionIR
    -- if indexAccessExpressionIR matches `%[%:%]`
    -- let typedExpressionIR_b [ typedExpressionIR_l : typedExpressionIR_h ] = indexAccessExpressionIR
    -- Expr_inst: p Ci sto |- typedExpressionIR_b ==> sto' value_b
    -- Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto'' value_l
    -- Expr_inst: p Ci sto'' |- typedExpressionIR_h ==> sto''' value_h
    -- let value = $bitacc_op(value_b, value_l, value_h)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:400.1-405.48
  rulegroup callExpressionIR-instantiation {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:400.1-405.48
    rule callExpressionIR-instantiation: p Ci sto |- expressionIR # _expressionNoteIR ==> sto'' ! Ci.path as value
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%(%)`
    -- let prefixedNameIR < typeArgumentListIR > ( argumentListIR ) = callExpressionIR
    -- let (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci, prefixedNameIR, argumentListIR)
    -- if (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} matches (_)
    -- let ?((_rid, consDyn, id_default*{id_default <- id_default*})) = (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?}
    -- Constructor_inst: p Ci sto |- consDyn < typeArgumentListIR >( argumentListIR # id_default*{id_default <- id_default*} )==> sto' objDyn
    -- let sto'' = $add_sto(sto', Ci.path, objDyn)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:410.1-415.38
  rulegroup callExpressionIR-methodTarget-generic {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:410.1-415.38
    rule callExpressionIR-methodTarget-generic: p Ci sto |- expressionIR # _expressionNoteIR ==> sto value
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%<%>(%)`
    -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if routineTargetIR matches `%.%`
    -- let typedExpressionIR . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- let _expressionIR # ( typeIR _ctk ) = typedExpressionIR
    -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
    -- let value = $size(typeIR, nameIR)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:417.1-422.38
  rulegroup callExpressionIR-methodTarget-non-generic {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:417.1-422.38
    rule callExpressionIR-methodTarget-non-generic: p Ci sto |- expressionIR # _expressionNoteIR ==> sto value
    -- if expressionIR <: callExpressionIR
    -- let callExpressionIR = expressionIR as callExpressionIR
    -- if callExpressionIR matches `%<%>(%)`
    -- let routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ) = callExpressionIR
    -- if routineTargetIR matches `TYPE%.%`
    -- let type prefixedNameIR . nameIR = routineTargetIR
    -- if typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
    -- if nameIR <- ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]
    -- let typeIR = $find_type_inst(p, Ci, prefixedNameIR)
    -- let value = $size(typeIR, nameIR)
  }

  ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:427.1-430.61
  rulegroup parenthesizedExpressionIR {


    ;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:427.1-430.61
    rule parenthesizedExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> sto' value
    -- if expressionIR <: parenthesizedExpressionIR
    -- let ( typedExpressionIR ) = expressionIR as parenthesizedExpressionIR
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:27.1-29.26
relation Argument_inst: cursor contextInst sto |- argumentIR ==> sto value

  ;; ../../../../spec-concrete/6.06-instantiation-argument.watsup:7.1-9.61
  rulegroup expression {


    ;; ../../../../spec-concrete/6.06-instantiation-argument.watsup:7.1-9.61
    rule expression: p Ci sto |- argumentIR ==> sto' value
    -- if argumentIR <: typedExpressionIR
    -- let typedExpressionIR = argumentIR as typedExpressionIR
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value
  }

  ;; ../../../../spec-concrete/6.06-instantiation-argument.watsup:13.1-15.61
  rulegroup namedexpression {


    ;; ../../../../spec-concrete/6.06-instantiation-argument.watsup:13.1-15.61
    rule namedexpression: p Ci sto |- argumentIR ==> sto' value
    -- if argumentIR matches `%=%`
    -- let nameIR = typedExpressionIR = argumentIR
    -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:35.1-37.26
relation Decls_inst: cursor contextInst sto |- declarationIR* ==> contextInst sto declarationIR*

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:358.1-359.33
  rulegroup nil {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:358.1-359.33
    rule nil: p Ci sto |- declarationIR*{declarationIR <- declarationIR*} ==> Ci sto []
    -- if declarationIR*{declarationIR <- declarationIR*} matches []
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:361.1-365.83
  rulegroup cons-none {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:361.1-365.83
    rule cons-none: p Ci_0 sto_0 |- declarationIR*{declarationIR <- declarationIR*} ==> Ci_2 sto_2 declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}
    -- if declarationIR*{declarationIR <- declarationIR*} matches _ :: _
    -- let declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*} = declarationIR*{declarationIR <- declarationIR*}
    -- Decl_inst: p Ci_0 sto_0 |- declarationIR_h ==> Ci_1 sto_1 declarationIR'?{declarationIR' <- declarationIR'?}
    -- if declarationIR'?{declarationIR' <- declarationIR'?} matches ()
    -- Decls_inst: p Ci_1 sto_1 |- declarationIR_t*{declarationIR_t <- declarationIR_t*} ==> Ci_2 sto_2 declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:367.1-371.83
  rulegroup cons-some {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:367.1-371.83
    rule cons-some: p Ci_0 sto_0 |- declarationIR*{declarationIR <- declarationIR*} ==> Ci_2 sto_2 declarationIR_h' :: declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}
    -- if declarationIR*{declarationIR <- declarationIR*} matches _ :: _
    -- let declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*} = declarationIR*{declarationIR <- declarationIR*}
    -- Decl_inst: p Ci_0 sto_0 |- declarationIR_h ==> Ci_1 sto_1 declarationIR'?{declarationIR' <- declarationIR'?}
    -- if declarationIR'?{declarationIR' <- declarationIR'?} matches (_)
    -- let ?(declarationIR_h') = declarationIR'?{declarationIR' <- declarationIR'?}
    -- Decls_inst: p Ci_1 sto_1 |- declarationIR_t*{declarationIR_t <- declarationIR_t*} ==> Ci_2 sto_2 declarationIR_t'*{declarationIR_t' <- declarationIR_t'*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:39.1-41.26
relation Decl_inst: cursor contextInst sto |- declarationIR ==> contextInst sto declarationIR?

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:11.1-13.60
  rulegroup constantDeclarationIR-global {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:11.1-13.60
    rule constantDeclarationIR-global: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: constantDeclarationIR
    -- let _annotationList const typeIR nameIR = value ; = declarationIR as constantDeclarationIR
    -- let Ci_1 = $add_value_inst(global, Ci_0, nameIR, value)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:15.1-18.55
  rulegroup constantDeclarationIR-non-global {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:15.1-18.55
    rule constantDeclarationIR-non-global: p Ci_0 sto |- declarationIR ==> Ci_1 sto ?(annotationList const typeIR nameIR = value ; as declarationIR)
    -- if declarationIR <: constantDeclarationIR
    -- let annotationList const typeIR nameIR = value ; = declarationIR as constantDeclarationIR
    -- let Ci_1 = $add_value_inst(p, Ci_0, nameIR, value)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:26.1-36.92
  rulegroup instantiationIR-extern {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:26.1-36.92
    rule instantiationIR-extern: p Ci_0 sto_0 |- declarationIR ==> Ci_0 sto_2 ?()
    -- if declarationIR <: instantiationIR
    -- let _annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ; = declarationIR as instantiationIR
    -- let (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR)
    -- if (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} matches (_)
    -- let ?((_rid, consDyn, id_default*{id_default <- id_default*})) = (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?}
    -- let Ci_1 = $enter_path(Ci_0, nameIR)
    -- Constructor_inst: p Ci_1 sto_0 |- consDyn < typeArgumentListIR >( argumentListIR # id_default*{id_default <- id_default*} )==> sto_1 objDyn
    -- let objDyn' = objDyn
    -- if objDyn' matches `EXTERN{%%%%}`
    -- let extern{ tid theta venv renv } = objDyn'
    -- let Ci_init = $empty_context_inst[path = Ci_1.path ++ [nameIR]][global = Ci_1.global]
    -- let objectDeclarationListIR = $get_init_decls(objectInitializerOptIR)
    -- ObjectDecls_inst: block Ci_init sto_1 |- objectDeclarationListIR ==> Ci_init_2 sto_2 _objectDeclarationListIR
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:41.1-54.76
  rulegroup instantiationIR-non-extern {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:41.1-54.76
    rule instantiationIR-non-extern: p Ci_0 sto_0 |- declarationIR ==> Ci_0 sto_1 ?()
    -- if declarationIR <: instantiationIR
    -- let _annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ; = declarationIR as instantiationIR
    -- let (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR)
    -- if (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} matches (_)
    -- let ?((_rid, consDyn, id_default*{id_default <- id_default*})) = (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?}
    -- let Ci_1 = $enter_path(Ci_0, nameIR)
    -- Constructor_inst: p Ci_1 sto_0 |- consDyn < typeArgumentListIR >( argumentListIR # id_default*{id_default <- id_default*} )==> sto_1 objDyn
    -- if ~$is_extern_object(objDyn)
    -- let tid = $flatten_prefixedNameIR(prefixedNameIR)
    -- let typeIR = tid tid as typeIR
    -- let oid = Ci_1.path ++ [nameIR]
    -- let sto_2 = $add_sto(sto_1, oid, objDyn)
    -- let Ci_2 = $add_value_inst(p, Ci_1, nameIR, ! oid as value)
    -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:74.1-82.65
  rulegroup functionDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:74.1-82.65
    rule functionDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if declarationIR <: functionDeclarationIR
    -- let _annotationList typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) blockStatementIR = declarationIR as functionDeclarationIR
    -- let rid = $rid_IR(nameIR, parameterListIR)
    -- let funcDyn = function< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ) blockStatementIR
    -- let Ci_1 = $add_routine_overload_inst(p, Ci_0, rid, funcDyn as routineDyn)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:88.1-92.69
  rulegroup actionDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:88.1-92.69
    rule actionDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if declarationIR <: actionDeclarationIR
    -- let _annotationList action nameIR ( parameterListIR ) blockStatementIR = declarationIR as actionDeclarationIR
    -- let rid = $rid_IR(nameIR, parameterListIR)
    -- let funcDyn = action( parameterListIR ){ blockStatementIR }
    -- let Ci_1 = $add_routine_non_overload_inst(p, Ci_0, rid, funcDyn as routineDyn)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:98.1-101.81
  rulegroup errorDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:98.1-101.81
    rule errorDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: errorDeclarationIR
    -- let error{ nameIR*{nameIR <- nameIR*} } = declarationIR as errorDeclarationIR
    -- (let nameIR_field = $concat_text(["error.", nameIR]))*{nameIR <- nameIR*, nameIR_field <- nameIR_field*}
    -- let Ci_1 = $add_values_inst(global, Ci_0, nameIR_field*{nameIR_field <- nameIR_field*}, error. nameIR as value*{nameIR <- nameIR*})
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:107.1-109.80
  rulegroup matchKindDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:107.1-109.80
    rule matchKindDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: matchKindDeclarationIR
    -- let match_kind{ nameIR*{nameIR <- nameIR*} } = declarationIR as matchKindDeclarationIR
    -- let Ci_1 = $add_values_inst(global, Ci_0, nameIR*{nameIR <- nameIR*}, match_kind. nameIR as value*{nameIR <- nameIR*})
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:117.1-127.65
  rulegroup externFunctionDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:117.1-127.65
    rule externFunctionDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if declarationIR <: externFunctionDeclarationIR
    -- let _annotationList extern typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR ) ; = declarationIR as externFunctionDeclarationIR
    -- let rid = $rid_IR(nameIR, parameterListIR)
    -- let funcDyn = extern_function< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ){ ?() }
    -- let Ci_1 = $add_routine_overload_inst(p, Ci_0, rid, funcDyn as routineDyn)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:143.1-153.60
  rulegroup parserDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:143.1-153.60
    rule parserDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if declarationIR <: parserDeclarationIR
    -- let _annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR } = declarationIR as parserDeclarationIR
    -- let cid = $cid_IR(nameIR, constructorParameterListIR)
    -- let consDyn = parser< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
    -- let Ci_1 = $add_constructor_inst(p, Ci_0, cid, consDyn)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:162.1-172.60
  rulegroup controlDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:162.1-172.60
    rule controlDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if declarationIR <: controlDeclarationIR
    -- let _annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR } = declarationIR as controlDeclarationIR
    -- let cid = $cid_IR(nameIR, constructorParameterListIR)
    -- let consDyn = control< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
    -- let Ci_1 = $add_constructor_inst(p, Ci_0, cid, consDyn)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:185.1-189.85
  rulegroup typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-enum {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:185.1-189.85
    rule typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-enum: cursor Ci_0 sto |- declarationIR ==> Ci_2 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: enumTypeDeclarationIR
    -- let enumTypeDeclarationIR = declarationIR as enumTypeDeclarationIR
    -- if enumTypeDeclarationIR matches `%ENUM%{%}`
    -- let _annotationList enum nameIR { nameIR_mem*{nameIR_mem <- nameIR_mem*} } = enumTypeDeclarationIR
    -- (let nameIR_path = $concat_text([nameIR, ".", nameIR_mem]))*{nameIR_mem <- nameIR_mem*, nameIR_path <- nameIR_path*}
    -- let Ci_1 = $add_values_inst(global, Ci_0, nameIR_path*{nameIR_path <- nameIR_path*}, nameIR . nameIR_mem as value*{nameIR_mem <- nameIR_mem*})
    -- let Ci_2 = $add_typedef_inst(global, Ci_1, nameIR, enum nameIR { nameIR_mem*{nameIR_mem <- nameIR_mem*} } as typeDefIR)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:194.1-199.113
  rulegroup typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-serializableEnum {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:194.1-199.113
    rule typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-serializableEnum: cursor Ci_0 sto_0 |- declarationIR ==> Ci_2 sto_1 ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: enumTypeDeclarationIR
    -- let enumTypeDeclarationIR = declarationIR as enumTypeDeclarationIR
    -- if enumTypeDeclarationIR matches `%ENUM%%{%}`
    -- let _annotationList enum typeIR nameIR { nameIR_mem = typedExpressionIR*{nameIR_mem <- nameIR_mem*, typedExpressionIR <- typedExpressionIR*} } = enumTypeDeclarationIR
    -- (let nameIR_path = $concat_text([nameIR, ".", nameIR_mem]))*{nameIR_mem <- nameIR_mem*, nameIR_path <- nameIR_path*}
    -- Exprs_inst: global Ci_0 sto_0 |- typedExpressionIR*{typedExpressionIR <- typedExpressionIR*} ==> sto_1 value_mem*{value_mem <- value_mem*}
    -- let Ci_1 = $add_values_inst(global, Ci_0, nameIR_path*{nameIR_path <- nameIR_path*}, nameIR . nameIR_mem # value_mem as value*{nameIR_mem <- nameIR_mem*, value_mem <- value_mem*})
    -- let Ci_2 = $add_typedef_inst(global, Ci_1, nameIR, enum nameIR # typeIR { nameIR_mem = value_mem ;*{nameIR_mem <- nameIR_mem*, value_mem <- value_mem*} } as typeDefIR)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:207.1-216.66
  rulegroup typeDeclarationIR-derivedTypeDeclarationIR-structTypeDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:207.1-216.66
    rule typeDeclarationIR-derivedTypeDeclarationIR-structTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: structTypeDeclarationIR
    -- let _annotationList struct nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR*{typeFieldIR <- typeFieldIR*} } = declarationIR as structTypeDeclarationIR
    -- (let _annotationList' typeIR nameIR_field ; = typeFieldIR)*{_annotationList' <- _annotationList'*, nameIR_field <- nameIR_field*, typeFieldIR <- typeFieldIR*, typeIR <- typeIR*}
    -- let typeDefIR = struct nameIR { typeIR nameIR_field ;*{nameIR_field <- nameIR_field*, typeIR <- typeIR*} } as typeIR < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:224.1-233.66
  rulegroup typeDeclarationIR-derivedTypeDeclarationIR-headerTypeDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:224.1-233.66
    rule typeDeclarationIR-derivedTypeDeclarationIR-headerTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: headerTypeDeclarationIR
    -- let _annotationList header nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR*{typeFieldIR <- typeFieldIR*} } = declarationIR as headerTypeDeclarationIR
    -- (let _annotationList' typeIR nameIR_field ; = typeFieldIR)*{_annotationList' <- _annotationList'*, nameIR_field <- nameIR_field*, typeFieldIR <- typeFieldIR*, typeIR <- typeIR*}
    -- let typeDefIR = header nameIR { typeIR nameIR_field ;*{nameIR_field <- nameIR_field*, typeIR <- typeIR*} } as typeIR < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:241.1-250.66
  rulegroup typeDeclarationIR-derivedTypeDeclarationIR-headerUnionTypeDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:241.1-250.66
    rule typeDeclarationIR-derivedTypeDeclarationIR-headerUnionTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: headerUnionTypeDeclarationIR
    -- let _annotationList header_union nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR*{typeFieldIR <- typeFieldIR*} } = declarationIR as headerUnionTypeDeclarationIR
    -- (let _annotationList' typeIR nameIR_field ; = typeFieldIR)*{_annotationList' <- _annotationList'*, nameIR_field <- nameIR_field*, typeFieldIR <- typeFieldIR*, typeIR <- typeIR*}
    -- let typeDefIR = header_union nameIR { typeIR nameIR_field ;*{nameIR_field <- nameIR_field*, typeIR <- typeIR*} } as typeIR < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:260.1-264.71
  rulegroup typeDeclarationIR-typedefDeclarationIR-typedef-typeIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:260.1-264.71
    rule typeDeclarationIR-typedefDeclarationIR-typedef-typeIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: typedefDeclarationIR
    -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
    -- if typedefDeclarationIR matches `%TYPEDEF%%;`
    -- let _annotationList typedef typedefTypeIR nameIR ; = typedefDeclarationIR
    -- if typedefTypeIR <: typeIR
    -- let typeIR = typedefTypeIR as typeIR
    -- let typeIR_typedef = typedef nameIR typeIR as typeIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeIR_typedef as typeDefIR)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:268.1-277.71
  rulegroup typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclarationIR-monoTypeDefIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:268.1-277.71
    rule typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclarationIR-monoTypeDefIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: typedefDeclarationIR
    -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
    -- if typedefDeclarationIR matches `%TYPEDEF%%;`
    -- let _annotationList typedef typedefTypeIR nameIR ; = typedefDeclarationIR
    -- if typedefTypeIR <: derivedTypeDeclarationIR
    -- let derivedTypeDeclarationIR = typedefTypeIR as derivedTypeDeclarationIR
    -- Decl_inst: global Ci_0 $empty_sto |- derivedTypeDeclarationIR as declarationIR ==> Ci_local _sto _declarationIR?{_declarationIR <- _declarationIR?}
    -- let { tid*{tid <- tid*} } = $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_0.global.tdenv), $dom_map<tid, typeDefIR>(Ci_local.global.tdenv))
    -- if tid*{tid <- tid*} matches [ _/1 ]
    -- let [tid_newtype] = tid*{tid <- tid*}
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(global, Ci_local, tid_newtype)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- let typeDefIR'' = typeDefIR
    -- if typeDefIR'' <: monoTypeDefIR
    -- let monoTypeDefIR = typeDefIR'' as monoTypeDefIR
    -- let typeIR_typedef = typedef nameIR monoTypeDefIR as typeIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeIR_typedef as typeDefIR)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:279.1-288.71
  rulegroup typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclaration-polyTypeDefIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:279.1-288.71
    rule typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclaration-polyTypeDefIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: typedefDeclarationIR
    -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
    -- if typedefDeclarationIR matches `%TYPEDEF%%;`
    -- let _annotationList typedef typedefTypeIR nameIR ; = typedefDeclarationIR
    -- if typedefTypeIR <: derivedTypeDeclarationIR
    -- let derivedTypeDeclarationIR = typedefTypeIR as derivedTypeDeclarationIR
    -- Decl_inst: global Ci_0 $empty_sto |- derivedTypeDeclarationIR as declarationIR ==> Ci_local _sto _declarationIR?{_declarationIR <- _declarationIR?}
    -- let { tid*{tid <- tid*} } = $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_0.global.tdenv), $dom_map<tid, typeDefIR>(Ci_local.global.tdenv))
    -- if tid*{tid <- tid*} matches [ _/1 ]
    -- let [tid_newtype] = tid*{tid <- tid*}
    -- let typeDefIR'?{typeDefIR' <- typeDefIR'?} = $find_typedef_inst(global, Ci_local, tid_newtype)
    -- if typeDefIR'?{typeDefIR' <- typeDefIR'?} matches (_)
    -- let ?(typeDefIR) = typeDefIR'?{typeDefIR' <- typeDefIR'?}
    -- let typeDefIR'' = typeDefIR
    -- if typeDefIR'' <: polyTypeDefIR
    -- let polyTypeDefIR = typeDefIR'' as polyTypeDefIR
    -- let typeIR_typedef = typedef nameIR polyTypeDefIR < [] > as typeIR as typeIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeIR_typedef as typeDefIR)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:292.1-296.71
  rulegroup typeDeclarationIR-typedefDeclarationIR-newtype {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:292.1-296.71
    rule typeDeclarationIR-typedefDeclarationIR-newtype: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: typedefDeclarationIR
    -- let typedefDeclarationIR = declarationIR as typedefDeclarationIR
    -- if typedefDeclarationIR matches `%TYPE%%;`
    -- let _annotationList type typeIR nameIR ; = typedefDeclarationIR
    -- let typeIR_newtype = type nameIR typeIR as typeIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeIR_newtype as typeDefIR)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:304.1-313.73
  rulegroup typeDeclarationIR-parserTypeDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:304.1-313.73
    rule typeDeclarationIR-parserTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: parserTypeDeclarationIR
    -- let _annotationList parser nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ); = declarationIR as parserTypeDeclarationIR
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let typeIR_parser = parser( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
    -- let typeDefIR_parser = typeIR_parser < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR_parser)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:321.1-330.73
  rulegroup typeDeclarationIR-controlTypeDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:321.1-330.73
    rule typeDeclarationIR-controlTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> Ci_1 sto ?()
    -- if cursor matches `GLOBAL`
    -- if declarationIR <: controlTypeDeclarationIR
    -- let _annotationList control nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ); = declarationIR as controlTypeDeclarationIR
    -- (let parameterTypeIR = $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}
    -- let typeIR_parser = control( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} ) as typeIR
    -- let typeDefIR_parser = typeIR_parser < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
    -- let Ci_1 = $add_typedef_inst(global, Ci_0, nameIR, typeDefIR_parser)
  }

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:339.1-352.73
  rulegroup typeDeclarationIR-packageTypeDeclarationIR {


    ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:339.1-352.73
    rule typeDeclarationIR-packageTypeDeclarationIR: p Ci_0 sto |- declarationIR ==> Ci_2 sto ?()
    -- if declarationIR <: packageTypeDeclarationIR
    -- let _annotationList package nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} ); = declarationIR as packageTypeDeclarationIR
    -- (let _annotationList' _direction typeIR _nameIR _constantInitializerOptIR = parameterIR)*{_annotationList' <- _annotationList'*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _nameIR <- _nameIR*, parameterIR <- parameterIR*, typeIR <- typeIR*}
    -- let typeIR_package = package< typeIR*{typeIR <- typeIR*} > as typeIR
    -- let typeDefIR_package = typeIR_package < typeParameterListIR , typeParameterListIR_inferred > as typeDefIR
    -- let Ci_1 = $add_typedef_inst(p, Ci_0, nameIR, typeDefIR_package)
    -- let cid = $cid_IR(nameIR, parameterIR*{parameterIR <- parameterIR*})
    -- let consDyn_package = package< typeParameterListIR ++ typeParameterListIR_inferred >( parameterIR*{parameterIR <- parameterIR*} )
    -- let Ci_2 = $add_constructor_inst(global, Ci_1, cid, consDyn_package)
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:43.1-45.26
relation ParserLocalDecl_inst: cursor contextInst sto |- parserLocalDeclarationIR ==> contextInst sto parserLocalDeclarationIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:47.1-49.26
relation ParserLocalDecls_inst: cursor contextInst sto |- parserLocalDeclarationListIR ==> contextInst sto parserLocalDeclarationListIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:51.1-53.23
relation ControlLocalDecl_inst: contextInst sto |- controlLocalDeclarationIR ==> contextInst sto controlLocalDeclarationIR?

  ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:9.1-11.101
  rulegroup constantDeclarationIR {


    ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:9.1-11.101
    rule constantDeclarationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> Ci_1 sto_1 constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} as controlLocalDeclarationIR?
    -- if controlLocalDeclarationIR <: constantDeclarationIR
    -- let constantDeclarationIR = controlLocalDeclarationIR as constantDeclarationIR
    -- Decl_inst: block Ci_0 sto_0 |- constantDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
    -- if declarationIR?{declarationIR <- declarationIR?} <: constantDeclarationIR?
    -- let constantDeclarationIR_inst?{constantDeclarationIR_inst <- constantDeclarationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as constantDeclarationIR?
  }

  ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:15.1-17.89
  rulegroup instantiationIR {


    ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:15.1-17.89
    rule instantiationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> Ci_1 sto_1 instantiationIR_inst?{instantiationIR_inst <- instantiationIR_inst?} as controlLocalDeclarationIR?
    -- if controlLocalDeclarationIR <: instantiationIR
    -- let instantiationIR = controlLocalDeclarationIR as instantiationIR
    -- Decl_inst: block Ci_0 sto_0 |- instantiationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
    -- if declarationIR?{declarationIR <- declarationIR?} <: instantiationIR?
    -- let instantiationIR_inst?{instantiationIR_inst <- instantiationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as instantiationIR?
  }

  ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:21.1-22.67
  rulegroup variableDeclarationIR {


    ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:21.1-22.67
    rule variableDeclarationIR: Ci sto |- controlLocalDeclarationIR ==> Ci sto ?(variableDeclarationIR as controlLocalDeclarationIR)
    -- if controlLocalDeclarationIR <: variableDeclarationIR
    -- let variableDeclarationIR = controlLocalDeclarationIR as variableDeclarationIR
  }

  ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:26.1-28.97
  rulegroup actionDeclarationIR {


    ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:26.1-28.97
    rule actionDeclarationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> Ci_1 sto_1 actionDeclarationIR_inst?{actionDeclarationIR_inst <- actionDeclarationIR_inst?} as controlLocalDeclarationIR?
    -- if controlLocalDeclarationIR <: actionDeclarationIR
    -- let actionDeclarationIR = controlLocalDeclarationIR as actionDeclarationIR
    -- Decl_inst: block Ci_0 sto_0 |- actionDeclarationIR as declarationIR ==> Ci_1 sto_1 declarationIR?{declarationIR <- declarationIR?}
    -- if declarationIR?{declarationIR <- declarationIR?} <: actionDeclarationIR?
    -- let actionDeclarationIR_inst?{actionDeclarationIR_inst <- actionDeclarationIR_inst?} = declarationIR?{declarationIR <- declarationIR?} as actionDeclarationIR?
  }

  ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:32.1-39.76
  rulegroup tableDeclarationIR {


    ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:32.1-39.76
    rule tableDeclarationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> Ci_2 sto_1 ?(constantDeclarationIR as controlLocalDeclarationIR)
    -- if controlLocalDeclarationIR <: tableDeclarationIR
    -- let _annotationList table typeIR nameIR { tablePropertyListIR } = controlLocalDeclarationIR as tableDeclarationIR
    -- let Ci_1 = $enter_path(Ci_0, nameIR)
    -- Constructor_inst: block Ci_0 sto_0 |- table nameIR { tablePropertyListIR } < [] >( [] # [] )==> sto_1 objDyn
    -- let oid = Ci_1.path ++ [nameIR]
    -- let sto_2 = $add_sto(sto_1, oid, objDyn)
    -- let Ci_2 = $add_value_inst(block, Ci_1, nameIR, ! oid as value)
    -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:55.1-57.23
relation ControlLocalDecls_inst: contextInst sto |- controlLocalDeclarationIR* ==> contextInst sto controlLocalDeclarationIR*

  ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:47.1-48.31
  rulegroup nil {


    ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:47.1-48.31
    rule nil: Ci sto |- controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} ==> Ci sto []
    -- if controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} matches []
  }

  ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:50.1-54.117
  rulegroup cons-none {


    ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:50.1-54.117
    rule cons-none: Ci_0 sto_0 |- controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*{controlLocalDeclarationIR_t' <- controlLocalDeclarationIR_t'*}
    -- if controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} matches _ :: _
    -- let controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*} = controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
    -- ControlLocalDecl_inst: Ci_0 sto_0 |- controlLocalDeclarationIR_h ==> Ci_1 sto_1 controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?}
    -- if controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?} matches ()
    -- ControlLocalDecls_inst: Ci_1 sto_1 |- controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*} ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*{controlLocalDeclarationIR_t' <- controlLocalDeclarationIR_t'*}
  }

  ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:56.1-60.117
  rulegroup cons-some {


    ;; ../../../../spec-concrete/6.09.2-instantiation-control-declaration.watsup:56.1-60.117
    rule cons-some: Ci_0 sto_0 |- controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} ==> Ci_2 sto_2 controlLocalDeclarationIR_h' :: controlLocalDeclarationIR_t'*{controlLocalDeclarationIR_t' <- controlLocalDeclarationIR_t'*}
    -- if controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} matches _ :: _
    -- let controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*} = controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*}
    -- ControlLocalDecl_inst: Ci_0 sto_0 |- controlLocalDeclarationIR_h ==> Ci_1 sto_1 controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?}
    -- if controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?} matches (_)
    -- let ?(controlLocalDeclarationIR_h') = controlLocalDeclarationIR'?{controlLocalDeclarationIR' <- controlLocalDeclarationIR'?}
    -- ControlLocalDecls_inst: Ci_1 sto_1 |- controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*} ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*{controlLocalDeclarationIR_t' <- controlLocalDeclarationIR_t'*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:59.1-61.23
relation TableProperty_inst: contextInst sto |- tablePropertyIR ==> contextInst sto tablePropertyIR

  ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:8.1-9.79
  rulegroup key {


    ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:8.1-9.79
    rule key: Ci sto |- tablePropertyIR ==> Ci sto key={ tableKeyListIR }
    -- if tablePropertyIR matches `KEY={%}`
    -- let key={ tableKeyListIR } = tablePropertyIR
  }

  ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:12.1-13.93
  rulegroup actions {


    ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:12.1-13.93
    rule actions: Ci sto |- tablePropertyIR ==> Ci sto actions={ tableActionListIR }
    -- if tablePropertyIR matches `ACTIONS={%}`
    -- let actions={ tableActionListIR } = tablePropertyIR
  }

  ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:16.1-18.76
  rulegroup entries {


    ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:16.1-18.76
    rule entries: Ci sto |- tablePropertyIR ==> Ci sto annotationList constOptIR entries={ tableEntryListIR }
    -- if tablePropertyIR matches `%%ENTRIES={%}`
    -- let annotationList constOptIR entries={ tableEntryListIR } = tablePropertyIR
  }

  ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:21.1-23.87
  rulegroup custom-default-action {


    ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:21.1-23.87
    rule custom-default-action: Ci sto |- tablePropertyIR ==> Ci sto annotationList constOptIR default_action= tableActionReferenceIR ;
    -- if tablePropertyIR matches `%%DEFAULT_ACTION=%;`
    -- let annotationList constOptIR default_action= tableActionReferenceIR ; = tablePropertyIR
  }

  ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:26.1-30.68
  rulegroup custom {


    ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:26.1-30.68
    rule custom: Ci sto |- tablePropertyIR ==> Ci sto annotationList constOptIR custom_const nameIR = value ;
    -- if tablePropertyIR matches `%%CUSTOM%%;`
    -- let annotationList constOptIR custom nameIR = typedExpressionIR ; = tablePropertyIR
    -- let Ci_1 = $enter_path(Ci, nameIR)
    -- Expr_inst: local Ci_1 sto |- typedExpressionIR ==> sto_1 value
  }

  ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:33.1-35.88
  rulegroup custom-const {


    ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:33.1-35.88
    rule custom-const: Ci sto |- tablePropertyIR ==> Ci sto annotationList constOptIR custom_const nameIR constantInitializerIR ;
    -- if tablePropertyIR matches `%%CUSTOM_CONST%%;`
    -- let annotationList constOptIR custom_const nameIR constantInitializerIR ; = tablePropertyIR
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:63.1-65.23
relation TableProperties_inst: contextInst sto |- tablePropertyIR* ==> contextInst sto tablePropertyIR*

  ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:37.1-38.31
  rulegroup nil {


    ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:37.1-38.31
    rule nil: Ci sto |- tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} ==> Ci sto []
    -- if tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} matches []
  }

  ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:40.1-44.94
  rulegroup cons {


    ;; ../../../../spec-concrete/6.09.1-instantiation-control-table.watsup:40.1-44.94
    rule cons: Ci_0 sto_0 |- tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} ==> Ci_2 sto_2 tablePropertyIR_h' :: tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*}
    -- if tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} matches _ :: _
    -- let tablePropertyIR_h :: tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*} = tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}
    -- TableProperty_inst: Ci_0 sto_0 |- tablePropertyIR_h ==> Ci_1 sto_1 tablePropertyIR_h'
    -- TableProperties_inst: Ci_1 sto_1 |- tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*} ==> Ci_2 sto_2 tablePropertyIR'*{tablePropertyIR' <- tablePropertyIR'*}
    -- if (tablePropertyIR'*{tablePropertyIR' <- tablePropertyIR'*} = tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*})
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:67.1-69.26
relation ObjectDecls_inst: cursor contextInst sto |- objectDeclarationListIR ==> contextInst sto objectDeclarationListIR

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:74.1-76.23
relation Methods_inst: cursor contextInst |- methodPrototypeIR* ==> contextInst

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:78.1-80.23
relation Method_inst: cursor contextInst |- methodPrototypeIR ==> contextInst

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:86.1-88.26
relation Stmts_inst: cursor contextInst sto |- statementIR* ==> contextInst sto statementIR*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:90.1-92.26
relation Stmt_inst: cursor contextInst sto |- statementIR ==> contextInst sto statementIR

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:9.1-10.59
  rulegroup emptyStatementIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:9.1-10.59
    rule emptyStatementIR: p Ci sto |- statementIR ==> Ci sto emptyStatementIR as statementIR
    -- if statementIR <: emptyStatementIR
    -- let emptyStatementIR = statementIR as emptyStatementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:14.1-15.69
  rulegroup assignmentStatementIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:14.1-15.69
    rule assignmentStatementIR: p Ci sto |- statementIR ==> Ci sto assignmentStatementIR as statementIR
    -- if statementIR <: assignmentStatementIR
    -- let assignmentStatementIR = statementIR as assignmentStatementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:21.1-22.57
  rulegroup callStatementIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:21.1-22.57
    rule callStatementIR: p Ci sto |- statementIR ==> Ci sto callStatementIR as statementIR
    -- if statementIR <: callStatementIR
    -- let callStatementIR = statementIR as callStatementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:28.1-42.82
  rulegroup directApplicationStatementIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:28.1-42.82
    rule directApplicationStatementIR: p Ci sto_0 |- statementIR ==> Ci sto_2 blockStatementIR as statementIR
    -- if statementIR <: directApplicationStatementIR
    -- let prefixedNameIR .apply( argumentListIR ); = statementIR as directApplicationStatementIR
    -- let (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} = $find_constructor_overloaded_inst(Ci, prefixedNameIR, [])
    -- if (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?} matches (_)
    -- let ?((_rid, consDyn, _id*{_id <- _id*})) = (rid, consDyn, id*)?{(rid, consDyn, id*) <- (rid, consDyn, id*)?}
    -- Constructor_inst: p Ci sto_0 |- consDyn < [] >( [] # [] )==> sto_1 objDyn
    -- let tid_fresh = $fresh_tid
    -- let tid = $flatten_prefixedNameIR(prefixedNameIR)
    -- let typeIR = tid tid as typeIR
    -- let nameIR = $concat_text([tid, "_", tid_fresh])
    -- let oid = Ci.path ++ [nameIR]
    -- let sto_2 = $add_sto(sto_1, oid, objDyn)
    -- let constantDeclarationIR = const typeIR nameIR = ! oid as value ;
    -- let routineTargetIR = ` tid as expressionIR # ( typeIR ctk ) . "apply"
    -- let callStatementIR = routineTargetIR < [] >( argumentListIR );
    -- let blockStatementIR = { [constantDeclarationIR as blockElementStatementIR, callStatementIR as blockElementStatementIR] }
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:46.1-47.61
  rulegroup returnStatementIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:46.1-47.61
    rule returnStatementIR: p Ci sto |- statementIR ==> Ci sto returnStatementIR as statementIR
    -- if statementIR <: returnStatementIR
    -- let returnStatementIR = statementIR as returnStatementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:51.1-52.57
  rulegroup exitStatementIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:51.1-52.57
    rule exitStatementIR: p Ci sto |- statementIR ==> Ci sto exitStatementIR as statementIR
    -- if statementIR <: exitStatementIR
    -- let exitStatementIR = statementIR as exitStatementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:57.1-60.132
  rulegroup blockStatementIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:57.1-60.132
    rule blockStatementIR: p Ci sto |- statementIR ==> Ci' sto' annotationList { blockElementStatementListIR' } as statementIR
    -- if statementIR <: blockStatementIR
    -- let annotationList { blockElementStatementListIR } = statementIR as blockStatementIR
    -- Block_inst: Ci sto false |- annotationList { blockElementStatementListIR } ==> Ci' sto' _annotationList { blockElementStatementListIR' }
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:67.1-70.64
  rulegroup conditionalStatementIR-non-else {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:67.1-70.64
    rule conditionalStatementIR-non-else: p Ci sto |- statementIR'' ==> Ci sto' if( typedExpressionIR ) statementIR' as statementIR
    -- if statementIR'' <: conditionalStatementIR
    -- let conditionalStatementIR = statementIR'' as conditionalStatementIR
    -- if conditionalStatementIR matches `IF(%)%`
    -- let if( typedExpressionIR ) statementIR = conditionalStatementIR
    -- Stmt_inst: p Ci sto |- statementIR ==> _contextInst sto' statementIR'
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:74.1-78.76
  rulegroup conditionalStatementIR-else {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:74.1-78.76
    rule conditionalStatementIR-else: p Ci sto |- statementIR ==> Ci sto'' if( typedExpressionIR ) statementIR_then' else statementIR_else' as statementIR
    -- if statementIR <: conditionalStatementIR
    -- let conditionalStatementIR = statementIR as conditionalStatementIR
    -- if conditionalStatementIR matches `IF(%)%ELSE%`
    -- let if( typedExpressionIR ) statementIR_then else statementIR_else = conditionalStatementIR
    -- Stmt_inst: p Ci sto |- statementIR_then ==> _contextInst sto' statementIR_then'
    -- Stmt_inst: p Ci sto' |- statementIR_else ==> _contextInst' sto'' statementIR_else'
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:84.1-85.59
  rulegroup breakStatementIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:84.1-85.59
    rule breakStatementIR: p Ci sto |- statementIR ==> Ci sto breakStatementIR as statementIR
    -- if statementIR <: breakStatementIR
    -- let breakStatementIR = statementIR as breakStatementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:89.1-90.65
  rulegroup continueStatementIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:89.1-90.65
    rule continueStatementIR: p Ci sto |- statementIR ==> Ci sto continueStatementIR as statementIR
    -- if statementIR <: continueStatementIR
    -- let continueStatementIR = statementIR as continueStatementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:95.1-98.83
  rulegroup switchStatementIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:95.1-98.83
    rule switchStatementIR: p Ci sto |- statementIR ==> Ci' sto' switch( typedExpressionIR ){ switchCaseListIR' } as statementIR
    -- if statementIR <: switchStatementIR
    -- let switch( typedExpressionIR ){ switchCaseListIR } = statementIR as switchStatementIR
    -- SwitchCases_inst: p Ci sto |- switchCaseListIR ==> Ci' sto' switchCaseListIR'
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:94.1-96.23
relation BlockElementStmt_inst: contextInst sto |- blockElementStatementIR ==> contextInst sto blockElementStatementIR?

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:115.1-117.90
  rulegroup constantDeclarationIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:115.1-117.90
    rule constantDeclarationIR: Ci sto |- blockElementStatementIR ==> Ci' sto' ?(constantDeclarationIR' as blockElementStatementIR)
    -- if blockElementStatementIR <: constantDeclarationIR
    -- let constantDeclarationIR = blockElementStatementIR as constantDeclarationIR
    -- Decl_inst: local Ci sto |- constantDeclarationIR as declarationIR ==> Ci' sto' declarationIR'?{declarationIR' <- declarationIR'?}
    -- if declarationIR'?{declarationIR' <- declarationIR'?} matches (_)
    -- let ?(declarationIR) = declarationIR'?{declarationIR' <- declarationIR'?}
    -- if declarationIR <: constantDeclarationIR
    -- let constantDeclarationIR' = declarationIR as constantDeclarationIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:124.1-125.67
  rulegroup variableDeclarationIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:124.1-125.67
    rule variableDeclarationIR: Ci sto |- blockElementStatementIR ==> Ci sto ?(variableDeclarationIR as blockElementStatementIR)
    -- if blockElementStatementIR <: variableDeclarationIR
    -- let variableDeclarationIR = blockElementStatementIR as variableDeclarationIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:129.1-131.74
  rulegroup statementIR {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:129.1-131.74
    rule statementIR: Ci sto |- blockElementStatementIR ==> Ci' sto' ?(statementIR_inst as blockElementStatementIR)
    -- if blockElementStatementIR <: statementIR
    -- let statementIR = blockElementStatementIR as statementIR
    -- Stmt_inst: local Ci sto |- statementIR ==> Ci' sto' statementIR_inst
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:98.1-100.23
relation BlockElementStmts_inst: contextInst sto |- blockElementStatementIR* ==> contextInst sto blockElementStatementIR*

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:133.1-134.31
  rulegroup nil {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:133.1-134.31
    rule nil: Ci sto |- blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} ==> Ci sto []
    -- if blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} matches []
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:136.1-140.113
  rulegroup cons {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:136.1-140.113
    rule cons: Ci_0 sto_0 |- blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} ==> Ci_2 sto_2 blockElementStatementIR_h' :: blockElementStatementIR_t'*{blockElementStatementIR_t' <- blockElementStatementIR_t'*}
    -- if blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} matches _ :: _
    -- let blockElementStatementIR_h :: blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*} = blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*}
    -- BlockElementStmt_inst: Ci_0 sto_0 |- blockElementStatementIR_h ==> Ci_1 sto_1 blockElementStatementIR'?{blockElementStatementIR' <- blockElementStatementIR'?}
    -- if blockElementStatementIR'?{blockElementStatementIR' <- blockElementStatementIR'?} matches (_)
    -- let ?(blockElementStatementIR_h') = blockElementStatementIR'?{blockElementStatementIR' <- blockElementStatementIR'?}
    -- BlockElementStmts_inst: Ci_1 sto_1 |- blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*} ==> Ci_2 sto_2 blockElementStatementIR_t'*{blockElementStatementIR_t' <- blockElementStatementIR_t'*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:102.1-104.26
relation SwitchCases_inst: cursor contextInst sto |- switchCaseIR* ==> contextInst sto switchCaseIR*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:106.1-108.26
relation SwitchCase_inst: cursor contextInst sto |- switchCaseIR ==> contextInst sto switchCaseIR

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:100.1-102.76
  rulegroup match {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:100.1-102.76
    rule match: p Ci sto |- switchCaseIR ==> Ci' sto' switchLabelIR : blockStatementIR'
    -- if switchCaseIR matches `%:%`
    -- let switchLabelIR : blockStatementIR = switchCaseIR
    -- Stmt_inst: p Ci sto |- blockStatementIR as statementIR ==> Ci' sto' statementIR
    -- if statementIR <: blockStatementIR
    -- let blockStatementIR' = statementIR as blockStatementIR
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:104.1-105.61
  rulegroup fallthrough {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:104.1-105.61
    rule fallthrough: p Ci sto |- switchCaseIR ==> Ci sto switchLabelIR :
    -- if switchCaseIR matches `%:`
    -- let switchLabelIR : = switchCaseIR
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:114.1-116.23
relation ParserStmt_inst: contextInst sto |- parserStatementIR ==> contextInst sto parserStatementIR?

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:9.1-10.67
  rulegroup constantDeclarationIR {


    ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:9.1-10.67
    rule constantDeclarationIR: Ci sto |- parserStatementIR ==> Ci sto ?(constantDeclarationIR as parserStatementIR)
    -- if parserStatementIR <: constantDeclarationIR
    -- let constantDeclarationIR = parserStatementIR as constantDeclarationIR
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:14.1-15.67
  rulegroup variableDeclarationIR {


    ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:14.1-15.67
    rule variableDeclarationIR: Ci sto |- parserStatementIR ==> Ci sto ?(variableDeclarationIR as parserStatementIR)
    -- if parserStatementIR <: variableDeclarationIR
    -- let variableDeclarationIR = parserStatementIR as variableDeclarationIR
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:19.1-21.90
  rulegroup emptyStatementIR {


    ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:19.1-21.90
    rule emptyStatementIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 ?(emptyStatementIR_inst as parserStatementIR)
    -- if parserStatementIR <: emptyStatementIR
    -- let emptyStatementIR = parserStatementIR as emptyStatementIR
    -- Stmt_inst: local Ci_0 sto_0 |- emptyStatementIR as statementIR ==> Ci_1 sto_1 statementIR
    -- if statementIR <: emptyStatementIR
    -- let emptyStatementIR_inst = statementIR as emptyStatementIR
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:25.1-27.100
  rulegroup assignmentStatementIR {


    ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:25.1-27.100
    rule assignmentStatementIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 ?(assignmentStatementIR_inst as parserStatementIR)
    -- if parserStatementIR <: assignmentStatementIR
    -- let assignmentStatementIR = parserStatementIR as assignmentStatementIR
    -- Stmt_inst: local Ci_0 sto_0 |- assignmentStatementIR as statementIR ==> Ci_1 sto_1 statementIR
    -- if statementIR <: assignmentStatementIR
    -- let assignmentStatementIR_inst = statementIR as assignmentStatementIR
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:31.1-33.88
  rulegroup callStatementIR {


    ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:31.1-33.88
    rule callStatementIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 ?(callStatementIR_inst as parserStatementIR)
    -- if parserStatementIR <: callStatementIR
    -- let callStatementIR = parserStatementIR as callStatementIR
    -- Stmt_inst: local Ci_0 sto_0 |- callStatementIR as statementIR ==> Ci_1 sto_1 statementIR
    -- if statementIR <: callStatementIR
    -- let callStatementIR_inst = statementIR as callStatementIR
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:37.1-39.114
  rulegroup directApplicationStatementIR {


    ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:37.1-39.114
    rule directApplicationStatementIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 ?(directApplicationStatementIR_inst as parserStatementIR)
    -- if parserStatementIR <: directApplicationStatementIR
    -- let directApplicationStatementIR = parserStatementIR as directApplicationStatementIR
    -- Stmt_inst: local Ci_0 sto_0 |- directApplicationStatementIR as statementIR ==> Ci_1 sto_1 statementIR
    -- if statementIR <: directApplicationStatementIR
    -- let directApplicationStatementIR_inst = statementIR as directApplicationStatementIR
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:43.1-48.55
  rulegroup parserBlockStatementIR {


    ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:43.1-48.55
    rule parserBlockStatementIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 ?(parserBlockStatementIR as parserStatementIR)
    -- if parserStatementIR <: parserBlockStatementIR
    -- let annotationList { parserStatementListIR } = parserStatementIR as parserBlockStatementIR
    -- ParserStmts_inst: Ci_0 sto_0 |- parserStatementListIR ==> Ci_1 sto_1 parserStatementListIR_inst
    -- let parserBlockStatementIR = annotationList { parserStatementListIR_inst }
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:52.1-54.102
  rulegroup conditionalStatementIR {


    ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:52.1-54.102
    rule conditionalStatementIR: Ci_0 sto_0 |- parserStatementIR ==> Ci_1 sto_1 ?(conditionalStatementIR_inst as parserStatementIR)
    -- if parserStatementIR <: conditionalStatementIR
    -- let conditionalStatementIR = parserStatementIR as conditionalStatementIR
    -- Stmt_inst: local Ci_0 sto_0 |- conditionalStatementIR as statementIR ==> Ci_1 sto_1 statementIR
    -- if statementIR <: conditionalStatementIR
    -- let conditionalStatementIR_inst = statementIR as conditionalStatementIR
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:118.1-120.23
relation ParserStmts_inst: contextInst sto |- parserStatementIR* ==> contextInst sto parserStatementIR*

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:62.1-63.31
  rulegroup nil {


    ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:62.1-63.31
    rule nil: Ci sto |- parserStatementIR*{parserStatementIR <- parserStatementIR*} ==> Ci sto []
    -- if parserStatementIR*{parserStatementIR <- parserStatementIR*} matches []
  }

  ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:65.1-69.95
  rulegroup cons {


    ;; ../../../../spec-concrete/6.10.1-instantiation-parser-statement.watsup:65.1-69.95
    rule cons: Ci_0 sto_0 |- parserStatementIR*{parserStatementIR <- parserStatementIR*} ==> Ci_2 sto_2 parserStatementIR_h' :: parserStatementIR_t'*{parserStatementIR_t' <- parserStatementIR_t'*}
    -- if parserStatementIR*{parserStatementIR <- parserStatementIR*} matches _ :: _
    -- let parserStatementIR_h :: parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*} = parserStatementIR*{parserStatementIR <- parserStatementIR*}
    -- ParserStmt_inst: Ci_0 sto_0 |- parserStatementIR_h ==> Ci_1 sto_1 parserStatementIR'?{parserStatementIR' <- parserStatementIR'?}
    -- if parserStatementIR'?{parserStatementIR' <- parserStatementIR'?} matches (_)
    -- let ?(parserStatementIR_h') = parserStatementIR'?{parserStatementIR' <- parserStatementIR'?}
    -- ParserStmts_inst: Ci_1 sto_1 |- parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*} ==> Ci_2 sto_2 parserStatementIR_t'*{parserStatementIR_t' <- parserStatementIR_t'*}
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:122.1-124.23
relation ParserState_inst: contextInst sto |- parserStateIR ==> contextInst sto

  ;; ../../../../spec-concrete/6.10.2-instantiation-parser-state.watsup:9.1-13.101
  rulegroup  {


    ;; ../../../../spec-concrete/6.10.2-instantiation-parser-state.watsup:9.1-13.101
    rule : Ci_0 sto_0 |- annotationList state nameIR { parserStatementListIR transitionStatementIR } ==> Ci_0 sto_0
    -- ParserStmts_inst: Ci_0 sto_0 |- parserStatementListIR ==> Ci_1 sto_1 parserStatementListIR_inst
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:126.1-128.23
relation ParserStates_inst: contextInst sto |- parserStateIR* ==> contextInst sto

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:131.1-133.26
relation Block_inst: contextInst sto bool |- blockStatementIR ==> contextInst sto blockStatementIR

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:149.1-152.119
  rulegroup start {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:149.1-152.119
    rule start: Ci_0 sto_0 bool |- annotationList { blockElementStatementListIR } ==> Ci_1 sto_1 annotationList { blockElementStatementListIR_inst }
    -- if (bool = true)
    -- BlockElementStmts_inst: Ci_0 sto_0 |- blockElementStatementListIR ==> Ci_1 sto_1 blockElementStatementListIR_inst
  }

  ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:154.1-159.32
  rulegroup no-start {


    ;; ../../../../spec-concrete/6.07-instantiation-statement.watsup:154.1-159.32
    rule no-start: Ci_0 sto_0 bool |- annotationList { blockElementStatementListIR } ==> Ci_2 sto_1 annotationList { blockElementStatementListIR_inst }
    -- if (bool = false)
    -- let Ci_1 = $enter_inst(Ci_0)
    -- BlockElementStmts_inst: Ci_1 sto_0 |- blockElementStatementListIR ==> Ci_2 sto_1 blockElementStatementListIR_inst
    -- let Ci_3 = $exit_inst(Ci_2)
  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:135.1-137.26
relation Table_inst: cursor contextInst sto |- tablePropertyListIR ==> contextInst sto tablePropertyListIR

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:1.1-1.84
def $partition_default_parameters(parameterIR*, id*) : (parameterIR*, parameterIR*) =

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:3.1-3.65
  clause 0(parameterIR*{parameterIR <- parameterIR*}, id_default*{id_default <- id_default*}) = ([], [])
  -- if parameterIR*{parameterIR <- parameterIR*} matches []

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:4.1-12.28
  clause 1(parameterIR*{parameterIR <- parameterIR*}, id_default*{id_default <- id_default*}) = (parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_h :: parameterIR_default*{parameterIR_default <- parameterIR_default*})
  -- if parameterIR*{parameterIR <- parameterIR*} matches _ :: _
  -- let parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} = parameterIR*{parameterIR <- parameterIR*}
  -- let _annotationList _direction _typeIR id_h _constantInitializerOptIR = parameterIR_h
  -- let (parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_default*{parameterIR_default <- parameterIR_default*}) = $partition_default_parameters(parameterIR_t*{parameterIR_t <- parameterIR_t*}, id_default*{id_default <- id_default*})
  -- if id_h <- id_default*{id_default <- id_default*}

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:14.1-22.31
  clause 2(parameterIR*{parameterIR <- parameterIR*}, id_default*{id_default <- id_default*}) = (parameterIR_h :: parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_default*{parameterIR_default <- parameterIR_default*})
  -- if parameterIR*{parameterIR <- parameterIR*} matches _ :: _
  -- let parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*} = parameterIR*{parameterIR <- parameterIR*}
  -- let _annotationList _direction _typeIR id_h _constantInitializerOptIR = parameterIR_h
  -- let (parameterIR_nondefault*{parameterIR_nondefault <- parameterIR_nondefault*}, parameterIR_default*{parameterIR_default <- parameterIR_default*}) = $partition_default_parameters(parameterIR_t*{parameterIR_t <- parameterIR_t*}, id_default*{id_default <- id_default*})
  -- if ~id_h <- id_default*{id_default <- id_default*}

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:24.1-24.146
def $align_cparams_with_args(constructorParameterIR*, argumentIR*, id*) : (constructorParameterIR*, argumentIR*, constructorParameterIR*, value*) =

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:27.1-34.71
  clause 0(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}) = (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}, value_default*{value_default <- value_default*})
  -- let (constructorParameterIR_nondefault*{constructorParameterIR_nondefault <- constructorParameterIR_nondefault*}, constructorParameterIR_default*{constructorParameterIR_default <- constructorParameterIR_default*}) = $partition_default_parameters(constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, id_default*{id_default <- id_default*})
  -- (let _annotationList _direction _typeIR id _constantInitializerOptIR = constructorParameterIR_nondefault)*{_annotationList <- _annotationList*, _constantInitializerOptIR <- _constantInitializerOptIR*, _direction <- _direction*, _typeIR <- _typeIR*, constructorParameterIR_nondefault <- constructorParameterIR_nondefault*, id <- id*}
  -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}) = $align_cparams_with_args'({ id : constructorParameterIR_nondefault*{constructorParameterIR_nondefault <- constructorParameterIR_nondefault*, id <- id*} }, constructorParameterIR_nondefault*{constructorParameterIR_nondefault <- constructorParameterIR_nondefault*}, argumentIR*{argumentIR <- argumentIR*})
  -- (let _annotationList' _direction' _typeIR' _nameIR constantInitializerOptIR = constructorParameterIR_default)*{_annotationList' <- _annotationList'*, _direction' <- _direction'*, _nameIR <- _nameIR*, _typeIR' <- _typeIR'*, constantInitializerOptIR <- constantInitializerOptIR*, constructorParameterIR_default <- constructorParameterIR_default*}
  -- (if constantInitializerOptIR matches (_))*{constantInitializerOptIR <- constantInitializerOptIR*}
  -- (let ?(= value_default) = constantInitializerOptIR)*{constantInitializerOptIR <- constantInitializerOptIR*, value_default <- value_default*}

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:25.1-25.142
def $align_cparams_with_args'(map<id, constructorParameterIR>, constructorParameterIR*, argumentIR*) : (constructorParameterIR*, argumentIR*) =

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:36.1-44.63
  clause 0({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}) = (constructorParameterIR_h :: constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_h :: argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*})
  -- if constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} matches _ :: _
  -- let constructorParameterIR_h :: constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*} = constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}
  -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
  -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
  -- let argumentIR' = argumentIR_h
  -- if argumentIR' <: typedExpressionIR
  -- let typedExpressionIR = argumentIR' as typedExpressionIR
  -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}) = $align_cparams_with_args'({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*}, argumentIR_t*{argumentIR_t <- argumentIR_t*})

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:46.1-54.63
  clause 1({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}) = (constructorParameterIR_h :: constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_h :: argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*})
  -- if constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} matches _ :: _
  -- let constructorParameterIR_h :: constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*} = constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}
  -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
  -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
  -- if (argumentIR_h = _)
  -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}) = $align_cparams_with_args'({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*}, argumentIR_t*{argumentIR_t <- argumentIR_t*})

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:56.1-66.63
  clause 2({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}) = (constructorParameterIR_matching :: constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_h :: argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*})
  -- if constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} matches _ :: _
  -- let constructorParameterIR_h :: constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*} = constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}
  -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
  -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
  -- let argumentIR' = argumentIR_h
  -- if argumentIR' matches `%=%`
  -- let nameIR = _typedExpressionIR = argumentIR'
  -- let constructorParameterIR'?{constructorParameterIR' <- constructorParameterIR'?} = $find_map<id, constructorParameterIR>({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, nameIR)
  -- if constructorParameterIR'?{constructorParameterIR' <- constructorParameterIR'?} matches (_)
  -- let ?(constructorParameterIR_matching) = constructorParameterIR'?{constructorParameterIR' <- constructorParameterIR'?}
  -- let (constructorParameterIR_aligned*{constructorParameterIR_aligned <- constructorParameterIR_aligned*}, argumentIR_aligned*{argumentIR_aligned <- argumentIR_aligned*}) = $align_cparams_with_args'({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR_t*{constructorParameterIR_t <- constructorParameterIR_t*}, argumentIR_t*{argumentIR_t <- argumentIR_t*})

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:68.1-68.99
  clause 3({ id_map : constructorParameterIR_map*{constructorParameterIR_map <- constructorParameterIR_map*, id_map <- id_map*} }, constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, argumentIR*{argumentIR <- argumentIR*}) = ([], [])
  -- if constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} matches []
  -- if argumentIR*{argumentIR <- argumentIR*} matches []

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:70.1-72.32
relation Eval_args: cursor cursor contextInst sto |- id* argumentIR* ==> contextInst sto

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:84.1-85.50
  rulegroup nil {


    ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:84.1-85.50
    rule nil: p p_callee Ci_0 sto_0 |- id*{id <- id*} argumentIR*{argumentIR <- argumentIR*} ==> Ci_0 sto_0
    -- if id*{id <- id*} matches []
    -- if argumentIR*{argumentIR <- argumentIR*} matches []
  }

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:87.1-91.76
  rulegroup cons {


    ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:87.1-91.76
    rule cons: p p_callee Ci_0 sto_0 |- id*{id <- id*} argumentIR*{argumentIR <- argumentIR*} ==> Ci_2 sto_2
    -- if id*{id <- id*} matches _ :: _
    -- let id_h :: id_t*{id_t <- id_t*} = id*{id <- id*}
    -- if argumentIR*{argumentIR <- argumentIR*} matches _ :: _
    -- let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} = argumentIR*{argumentIR <- argumentIR*}
    -- Eval_arg: p p_callee Ci_0 sto_0 |- id_h argumentIR_h ==> Ci_1 sto_1
    -- Eval_args: p p_callee Ci_1 sto_1 |- id_t*{id_t <- id_t*} argumentIR_t*{argumentIR_t <- argumentIR_t*} ==> Ci_2 sto_2
  }

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:74.1-76.32
relation Eval_arg: cursor cursor contextInst sto |- id argumentIR ==> contextInst sto

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:78.1-82.58
  rulegroup  {


    ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:78.1-82.58
    rule : p p_callee Ci_0 sto_0 |- id argumentIR ==> Ci_1 sto_1
    -- let Ci_caller = $enter_path(Ci_0, id)
    -- Argument_inst: p Ci_caller sto_0 |- argumentIR ==> sto_1 value
    -- let Ci_1 = $add_value_inst(p_callee, Ci_0, id, value)
  }

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:170.1-170.59
def $init_table(tablePropertyListIR) : tablePropertyListIR =

  ;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:173.1-173.59
  clause 0(tablePropertyListIR) = tablePropertyListIR

;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:408.1-408.34
def $size(typeIR, nameIR) : value =

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:24.1-24.70
def $get_init_decls(objectInitializerOptIR) : objectDeclarationListIR =

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:38.1-38.37
def $is_extern_object(objDyn) : bool =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:39.1-39.50
  clause 0(objDyn) = true
  -- if objDyn matches `EXTERN{%%%%}`
  -- let extern{ _tid _theta _venv _renv } = objDyn

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:40.1-40.33
  clause 1(_objDyn) = false

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:60.1-60.43
def $rid_IR(nameIR, parameterListIR) : rid =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:63.1-63.70
  clause 0(nameIR, parameterIR*{parameterIR <- parameterIR*}) = nameIR ( $pid_IR(parameterIR)*{parameterIR <- parameterIR*} )

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:61.1-61.31
def $pid_IR(parameterIR) : pid =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:65.1-65.48
  clause 0(_annotationList _direction _typeIR nameIR constantInitializerIR?{constantInitializerIR <- constantInitializerIR?}) = nameIR # false
  -- if constantInitializerIR?{constantInitializerIR <- constantInitializerIR?} matches ()

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:66.1-66.65
  clause 1(_annotationList _direction _typeIR nameIR constantInitializerOptIR) = nameIR # true
  -- if constantInitializerOptIR matches (_)
  -- let ?(constantInitializerIR) = constantInitializerOptIR

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:68.1-68.54
def $cid_IR(nameIR, constructorParameterListIR) : cid =

  ;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:70.1-70.94
  clause 0(nameIR, constructorParameterListIR) = $rid_IR(nameIR, constructorParameterListIR)
