;; ../../../../spec/0-aux.watsup:18.1-18.21
def $sum



;; ../../../../spec/0-aux.watsup:19.1-19.21
def $max



;; ../../../../spec/0-aux.watsup:20.1-20.21
def $min



;; ../../../../spec/0-aux.watsup:26.1-27.17
def $int_to_text



;; ../../../../spec/0-aux.watsup:29.1-30.17
def $concat_text(text*)

1. Case analysis on text*

  1. Case (% matches pattern [])

    1. Return ""

  2. Case (% matches pattern _ :: _)

    1. (Let t :: t'* be text*)

    2. Return t ++ $concat_text(t'*)

;; ../../../../spec/0-aux.watsup:35.1-35.37
def $strip_prefix



;; ../../../../spec/0-aux.watsup:36.1-36.37
def $strip_suffix



;; ../../../../spec/0-aux.watsup:42.1-42.23
def $init_(nat')

1. If ((nat' = 0)), then

  1. Return []

2. Otherwise

  1. Return (nat' - 1) :: $init_((nat' - 1))

;; ../../../../spec/0-aux.watsup:47.1-47.29
def $repeat_<X>(X, nat')

1. If ((nat' = 0)), then

  1. Return []

2. Otherwise

  1. Return [X] ++ $repeat_<X>(X, (nat' - 1))

;; ../../../../spec/0-aux.watsup:53.1-54.26
def $rev_<X>



;; ../../../../spec/0-aux.watsup:56.1-57.23
def $concat_<X>



;; ../../../../spec/0-aux.watsup:59.1-59.39
def $partition_<X>



;; ../../../../spec/0-aux.watsup:61.1-62.23
def $assoc_<X, Y>



;; ../../../../spec/0-aux.watsup:64.1-65.28
def $distinct_<K>



;; ../../../../spec/0-aux.watsup:71.17-71.24
syntax set<K> = 
   | `{%}`(K*)

;; ../../../../spec/0-aux.watsup:73.1-74.43
def $empty_set<K>

1. Return ({ [] })

;; ../../../../spec/0-aux.watsup:77.1-78.36
def $in_set<K>(K, ({ K'* }))

1. Return K is in K'*

;; ../../../../spec/0-aux.watsup:81.1-82.37
def $intersect_set<K>



;; ../../../../spec/0-aux.watsup:84.1-85.37
def $union_set<K>



;; ../../../../spec/0-aux.watsup:87.1-88.37
def $unions_set<K>



;; ../../../../spec/0-aux.watsup:90.1-91.42
def $diff_set<K>



;; ../../../../spec/0-aux.watsup:93.1-94.40
def $sub_set<K>



;; ../../../../spec/0-aux.watsup:96.1-97.33
def $eq_set<K>



;; ../../../../spec/0-aux.watsup:103.21-103.27
syntax pair<K, V> = 
   | `%->%`(K, V)

;; ../../../../spec/0-aux.watsup:106.20-106.37
syntax map<K, V> = set<pair<K, V>>

;; ../../../../spec/0-aux.watsup:108.1-109.43
def $empty_map<K, V>

1. Return ({ [] })

;; ../../../../spec/0-aux.watsup:113.1-114.55
def $dom_map<K, V>(({ (K -> V)* }))

1. Return ({ K* })

;; ../../../../spec/0-aux.watsup:118.1-119.25
def $find_map<K, V>



;; ../../../../spec/0-aux.watsup:121.1-122.25
def $find_maps<K, V>



;; ../../../../spec/0-aux.watsup:124.1-125.71
def $add_map<K, V>



;; ../../../../spec/0-aux.watsup:127.1-128.71
def $adds_map<K, V>



;; ../../../../spec/0-aux.watsup:130.1-131.71
def $update_map<K, V>



;; ../../../../spec/1a-syntax-el.watsup:5.15-5.18
syntax bits = int

;; ../../../../spec/1a-syntax-el.watsup:6.16-6.19
syntax width = nat

;; ../../../../spec/1a-syntax-el.watsup:9.1-11.39
syntax num = 
   | `INT%`(int)
   | `FINT%%`(width, bits)
   | `FBIT%%`(width, bits)

;; ../../../../spec/1a-syntax-el.watsup:21.13-21.17
syntax id = text

;; ../../../../spec/1a-syntax-el.watsup:28.1-29.29
syntax name = 
   | `TOP%`(id)
   | `CURRENT%`(id)

;; ../../../../spec/1a-syntax-el.watsup:35.17-35.19
syntax member = id

;; ../../../../spec/1a-syntax-el.watsup:41.20-41.22
syntax matchkind = id

;; ../../../../spec/1a-syntax-el.watsup:47.21-47.23
syntax statelabel = id

;; ../../../../spec/1a-syntax-el.watsup:54.1-57.35
syntax unop = 
   | `BNOT`()
   | `LNOT`()
   | `UPLUS`()
   | `UMINUS`()

;; ../../../../spec/1a-syntax-el.watsup:64.1-84.36
syntax binop = 
   | `PLUS`()
   | `SPLUS`()
   | `MINUS`()
   | `SMINUS`()
   | `MUL`()
   | `DIV`()
   | `MOD`()
   | `SHL`()
   | `SHR`()
   | `LE`()
   | `GE`()
   | `LT`()
   | `GT`()
   | `EQ`()
   | `NE`()
   | `BAND`()
   | `BXOR`()
   | `BOR`()
   | `CONCAT`()
   | `LAND`()
   | `LOR`()

;; ../../../../spec/1a-syntax-el.watsup:90.14-90.37
syntax dir = 
   | `NO`()
   | `IN`()
   | `OUT`()
   | `INOUT`()

;; ../../../../spec/1a-syntax-el.watsup:103.1-117.36
syntax type = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()
   | `IntT`()
   | `FIntT%`(expr)
   | `FBitT%`(expr)
   | `VBitT%`(expr)
   | `StackT%%`(type, expr)
   | `ListT%`(type)
   | `TupleT%`(type*)
   | `NameT%`(name)
   | `SpecT%%`(name, type*)
   | `AnyT`()

;; ../../../../spec/1a-syntax-el.watsup:123.17-123.19
syntax tparam = id

;; ../../../../spec/1a-syntax-el.watsup:129.16-129.33
syntax param = 
   | `%%%%`(id, dir, type, expr?)

;; ../../../../spec/1a-syntax-el.watsup:135.17-135.22
syntax cparam = param

;; ../../../../spec/1a-syntax-el.watsup:141.15-141.19
syntax targ = type

;; ../../../../spec/1a-syntax-el.watsup:148.1-150.33
syntax arg = 
   | `ExprA%`(expr)
   | `NameA%%`(id, expr?)
   | `AnyA`()

;; ../../../../spec/1a-syntax-el.watsup:157.1-159.29
syntax keyset = 
   | `ExprK%`(expr)
   | `DefaultK`()
   | `AnyK`()

;; ../../../../spec/1a-syntax-el.watsup:165.21-165.39
syntax selectcase = 
   | `%%`(keyset*, statelabel)

;; ../../../../spec/1a-syntax-el.watsup:173.1-198.108
syntax expr = 
   | `BoolE%`(bool)
   | `StrE%`(text)
   | `NumE%`(num)
   | `NameE%`(name)
   | `SeqE%`(expr*)
   | `SeqDefaultE%`(expr*)
   | `RecordE%`((member, expr)*)
   | `RecordDefaultE%`((member, expr)*)
   | `DefaultE`()
   | `InvalidE`()
   | `UnE%%`(unop, expr)
   | `BinE%%%`(binop, expr, expr)
   | `TernE%%%`(expr, expr, expr)
   | `CastE%%`(type, expr)
   | `MaskE%%`(expr, expr)
   | `RangeE%%`(expr, expr)
   | `SelectE%%`(expr*, selectcase*)
   | `ArrAccE%%`(expr, expr)
   | `BitAccE%%%`(expr, expr, expr)
   | `ErrAccE%`(member)
   | `TypeAccE%%`(name, member)
   | `ExprAccE%%`(expr, member)
   | `CallFuncE%%%`(name, targ*, arg*)
   | `CallMethodE%%%%`(expr, member, targ*, arg*)
   | `CallTypeE%%%%`(name, member, targ*, arg*)
   | `InstE%%%`(name, targ*, arg*)

;; ../../../../spec/1a-syntax-el.watsup:204.16-204.71
syntax block = 
   | `BlockB%`(stmt*)

;; ../../../../spec/1a-syntax-el.watsup:211.1-222.55
syntax stmt = 
   | `EmptyS`()
   | `AssignS%%`(expr, expr)
   | `SwitchS%%`(expr, switchcase*)
   | `IfS%%%`(expr, stmt, stmt)
   | `BlockS%`(block)
   | `ExitS`()
   | `RetS%`(expr?)
   | `CallFuncS%%%`(name, targ*, arg*)
   | `CallMethodS%%%%`(expr, member, targ*, arg*)
   | `CallInstS%%%`(name, targ*, arg*)
   | `TransS%`(expr)
   | `DeclS%`(decl)

;; ../../../../spec/1a-syntax-el.watsup:229.1-230.35
syntax switchlabel = 
   | `ExprL%`(expr)
   | `DefaultL`()

;; ../../../../spec/1a-syntax-el.watsup:233.1-234.48
syntax switchcase = 
   | `MatchC%%`(switchlabel, block)
   | `FallC%`(switchlabel)

;; ../../../../spec/1a-syntax-el.watsup:240.22-240.38
syntax parserstate = 
   | `%%`(statelabel, block)

;; ../../../../spec/1a-syntax-el.watsup:246.14-246.22
syntax tbl = tblprop*

;; ../../../../spec/1a-syntax-el.watsup:252.17-252.31
syntax tblkey = 
   | `%%`(expr, matchkind)

;; ../../../../spec/1a-syntax-el.watsup:253.21-253.28
syntax tblkeyprop = tblkey*

;; ../../../../spec/1a-syntax-el.watsup:259.20-259.29
syntax tblaction = 
   | `%%`(name, arg*)

;; ../../../../spec/1a-syntax-el.watsup:260.24-260.34
syntax tblactionprop = tblaction*

;; ../../../../spec/1a-syntax-el.watsup:266.19-266.47
syntax tblentry = 
   | `%%%%`(bool, keyset*, tblaction, expr?)

;; ../../../../spec/1a-syntax-el.watsup:267.23-267.37
syntax tblentryprop = 
   | `%%`(bool, tblentry*)

;; ../../../../spec/1a-syntax-el.watsup:273.25-273.39
syntax tbldefaultprop = 
   | `%%`(bool, tblaction)

;; ../../../../spec/1a-syntax-el.watsup:279.24-279.40
syntax tblcustomprop = 
   | `%%%`(bool, member, expr)

;; ../../../../spec/1a-syntax-el.watsup:286.1-290.78
syntax tblprop = 
   | `KeyP%`(tblkeyprop)
   | `ActionP%`(tblactionprop)
   | `EntryP%`(tblentryprop)
   | `DefaultP%`(tbldefaultprop)
   | `CustomP%`(tblcustomprop)

;; ../../../../spec/1a-syntax-el.watsup:297.1-299.120
syntax method = 
   | `ExternConsM%%`(id, cparam*)
   | `ExternAbstractM%%%%`(id, type, tparam*, param*)
   | `ExternM%%%%`(id, type, tparam*, param*)

;; ../../../../spec/1a-syntax-el.watsup:308.1-330.136
syntax decl = 
   | `ConstD%%%`(id, type, expr)
   | `VarD%%%`(id, type, expr?)
   | `ErrD%`(member*)
   | `MatchKindD%`(member*)
   | `InstD%%%%%`(id, name, targ*, arg*, decl*)
   | `StructD%%%`(id, tparam*, (member, type)*)
   | `HeaderD%%%`(id, tparam*, (member, type)*)
   | `UnionD%%%`(id, tparam*, (member, type)*)
   | `EnumD%%`(id, member*)
   | `SEnumD%%%`(id, type, (member, expr)*)
   | `NewTypeD%%`(id, typedef)
   | `TypeDefD%%`(id, typedef)
   | `ValueSetD%%%`(id, type, expr)
   | `ParserTypeD%%%`(id, tparam*, param*)
   | `ParserD%%%%%`(id, param*, cparam*, decl*, parserstate*)
   | `TableD%%`(id, tbl)
   | `ControlTypeD%%%`(id, tparam*, param*)
   | `ControlD%%%%%`(id, param*, cparam*, decl*, block)
   | `ActionD%%%`(id, param*, block)
   | `FuncD%%%%%`(id, type, tparam*, param*, block)
   | `ExternFuncD%%%%`(id, type, tparam*, param*)
   | `ExternObjectD%%%`(id, tparam*, method*)
   | `PackageTypeD%%%`(id, tparam*, cparam*)

;; ../../../../spec/1a-syntax-el.watsup:333.1-334.15
syntax typedef = 
   | `TypeD%`(type)
   | `DeclD%`(decl)

;; ../../../../spec/1a-syntax-el.watsup:340.18-340.23
syntax program = decl*

;; ../../../../spec/1b-syntax-el-aux.watsup:5.1-6.27
def $is_boole(expr')

1. If ((expr' matches pattern `BoolE%`)), then

  1. (Let (BoolE _bool) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:11.1-12.26
def $is_stre(expr')

1. If ((expr' matches pattern `StrE%`)), then

  1. (Let (StrE _text) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:17.1-18.26
def $is_nume(expr')

1. If ((expr' matches pattern `NumE%`)), then

  1. (Let (NumE _num) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:23.1-24.27
def $is_namee(expr')

1. If ((expr' matches pattern `NameE%`)), then

  1. (Let (NameE _name) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:29.1-30.26
def $is_seqe(expr')

1. If ((expr' matches pattern `SeqE%`)), then

  1. (Let (SeqE _expr*) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:35.1-36.34
def $is_seq_defaulte(expr')

1. If ((expr' matches pattern `SeqDefaultE%`)), then

  1. (Let (SeqDefaultE _expr*) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:41.1-42.29
def $is_recorde(expr')

1. If ((expr' matches pattern `RecordE%`)), then

  1. (Let (RecordE _(member, expr)*) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:47.1-48.37
def $is_record_defaulte(expr')

1. If ((expr' matches pattern `RecordDefaultE%`)), then

  1. (Let (RecordDefaultE _(member, expr)*) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:53.1-54.30
def $is_defaulte(expr')

1. If ((expr' matches pattern `DefaultE`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:59.1-60.30
def $is_invalide(expr')

1. If ((expr' matches pattern `InvalidE`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:65.1-66.25
def $is_une(expr')

1. If ((expr' matches pattern `UnE%%`)), then

  1. (Let (UnE _unop _expr) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:71.1-72.26
def $is_bine(expr')

1. If ((expr' matches pattern `BinE%%%`)), then

  1. (Let (BinE _binop _expr _expr') be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:77.1-78.27
def $is_terne(expr')

1. If ((expr' matches pattern `TernE%%%`)), then

  1. (Let (TernE _expr _expr' _expr'') be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:83.1-84.27
def $is_caste(expr')

1. If ((expr' matches pattern `CastE%%`)), then

  1. (Let (CastE _type _expr) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:89.1-90.27
def $is_maske(expr')

1. If ((expr' matches pattern `MaskE%%`)), then

  1. (Let (MaskE _expr _expr') be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:95.1-96.28
def $is_rangee(expr')

1. If ((expr' matches pattern `RangeE%%`)), then

  1. (Let (RangeE _expr _expr') be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:101.1-102.29
def $is_selecte(expr')

1. If ((expr' matches pattern `SelectE%%`)), then

  1. (Let (SelectE _expr* _selectcase*) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:107.1-108.29
def $is_arracce(expr')

1. If ((expr' matches pattern `ArrAccE%%`)), then

  1. (Let (ArrAccE _expr _expr') be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:113.1-114.29
def $is_bitacce(expr')

1. If ((expr' matches pattern `BitAccE%%%`)), then

  1. (Let (BitAccE _expr _expr' _expr'') be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:119.1-120.29
def $is_erracce(expr')

1. If ((expr' matches pattern `ErrAccE%`)), then

  1. (Let (ErrAccE _member) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:125.1-126.30
def $is_typacce(expr')

1. If ((expr' matches pattern `TypeAccE%%`)), then

  1. (Let (TypeAccE _name _member) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:131.1-132.30
def $is_expracce(expr')

1. If ((expr' matches pattern `ExprAccE%%`)), then

  1. (Let (ExprAccE _expr _member) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:137.1-138.31
def $is_callfunce(expr')

1. If ((expr' matches pattern `CallFuncE%%%`)), then

  1. (Let (CallFuncE _name _targ* _arg*) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:143.1-144.33
def $is_callmethode(expr')

1. If ((expr' matches pattern `CallMethodE%%%%`)), then

  1. (Let (CallMethodE _expr _member _targ* _arg*) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:149.1-150.31
def $is_calltype(expr')

1. If ((expr' matches pattern `CallTypeE%%%%`)), then

  1. (Let (CallTypeE _name _member _targ* _arg*) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:155.1-156.27
def $is_inste(expr')

1. If ((expr' matches pattern `InstE%%%`)), then

  1. (Let (InstE _name _targ* _arg*) be expr')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:165.1-166.17
def $string_of_name(name)

1. Case analysis on name

  1. Case (% matches pattern `TOP%`)

    1. (Let (TOP id) be name)

    2. Return $concat_text("." :: [id])

  2. Case (% matches pattern `CURRENT%`)

    1. (Let (CURRENT id) be name)

    2. Return id

;; ../../../../spec/1b-syntax-el-aux.watsup:175.1-176.17
def $id_of_name(name)

1. Case analysis on name

  1. Case (% matches pattern `TOP%`)

    1. (Let (TOP id) be name)

    2. Return id

  2. Case (% matches pattern `CURRENT%`)

    1. (Let (CURRENT id) be name)

    2. Return id

;; ../../../../spec/2a-runtime-domain.watsup:10.14-10.16
syntax tid = id

;; ../../../../spec/2a-runtime-domain.watsup:11.51-11.59
syntax tidset = set<tid>

;; ../../../../spec/2a-runtime-domain.watsup:13.1-14.27
def $fresh_tid



;; ../../../../spec/2a-runtime-domain.watsup:16.1-17.28
def $fresh_tids(nat')

1. If ((nat' = 0)), then

  1. Return []

2. Otherwise

  1. Return $fresh_tid :: $fresh_tids((nat' - 1))

;; ../../../../spec/2a-runtime-domain.watsup:29.14-29.28
syntax fid = 
   | `%%`(id, (id, bool)*)

;; ../../../../spec/2a-runtime-domain.watsup:30.14-30.17
syntax cid = fid

;; ../../../../spec/2a-runtime-domain.watsup:34.1-34.30
def $to_fid(id, param*)

1. Return (id $to_fid'(param*))

;; ../../../../spec/2a-runtime-domain.watsup:35.1-35.35
def $to_fid'(param*)

1. Case analysis on param*

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let param_h :: param_t* be param*)

    2. (Let (id dir type expr'?) be param_h)

    3. Case analysis on expr'?

      1. Case (% matches pattern (_))

        1. (Let ?(expr) be expr'?)

        2. Return (id, true) :: $to_fid'(param_t*)

      2. Case (% matches pattern ())

        1. Return (id, false) :: $to_fid'(param_t*)

;; ../../../../spec/2a-runtime-domain.watsup:46.1-46.30
def $to_cid(id, param*)

1. Return $to_fid(id, param*)

;; ../../../../spec/2a-runtime-domain.watsup:54.14-54.17
syntax oid = id*

;; ../../../../spec/2b1-runtime-bitstr.watsup:5.17-5.20
syntax bitstr = int

;; ../../../../spec/2b1-runtime-bitstr.watsup:10.1-10.31
def $to_int



;; ../../../../spec/2b1-runtime-bitstr.watsup:14.1-14.34
def $to_bitstr



;; ../../../../spec/2b2-runtime-value.watsup:9.1-37.57
syntax val = 
   | `ErrV%`(member)
   | `MatchKindV%`(member)
   | `StrV%`(text)
   | `BoolV%`(bool)
   | `IntV%`(int)
   | `FIntV%%`(width, bitstr)
   | `FBitV%%`(width, bitstr)
   | `VBitV%%%`(width, width, bitstr)
   | `EnumFieldV%%`(id, member)
   | `SEnumFieldV%%%`(id, member, val)
   | `ListV%`(val*)
   | `TupleV%`(val*)
   | `StackV%%%`(val*, int, int)
   | `StructV%%`(id, (member, val)*)
   | `HeaderV%%`(id, (member, val)*)
   | `UnionV%%`(id, (member, val)*)
   | `RefV%`(oid)
   | `TableEnumFieldV%%`(id, member)
   | `TableStructV%%`(id, (member, val)*)
   | `SeqV%`(val*)
   | `SeqDefaultV%`(val*)
   | `RecordV%`((member, val)*)
   | `RecordDefaultV%`((member, val)*)
   | `DefaultV`()
   | `InvalidV`()
   | `SetV%`(setval)

;; ../../../../spec/2b2-runtime-value.watsup:40.1-42.83
syntax setval = 
   | `SingletonSet%`(val)
   | `MaskSet%%`(val, val)
   | `RangeSet%%`(val, val)

;; ../../../../spec/2b2-runtime-value.watsup:46.16-46.26
syntax valIL = 
   | `%%`(val, exprIL)

;; ../../../../spec/2b3-runtime-value-aux.watsup:3.1-3.24
def $get_num(val)

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i) be val)

    2. Return i

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs) be val)

    2. Return $to_int((w as int), bs)

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV _width bs) be val)

    2. Return bs

  4. Case (% matches pattern `VBitV%%%`)

    1. (Let (VBitV _width _width' bs) be val)

    2. Return bs

1. Else Phantom#0

;; ../../../../spec/2c1-runtime-type.watsup:16.3-16.21
syntax paramtyp = 
   | `%%%%`(id, dir, typ, exprIL?)

;; ../../../../spec/2c1-runtime-type.watsup:29.1-33.38
syntax primtyp = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()

;; ../../../../spec/2c1-runtime-type.watsup:36.1-39.78
syntax numtyp = 
   | `IntT`()
   | `FIntT%`(width)
   | `FBitT%`(width)
   | `VBitT%`(width)

;; ../../../../spec/2c1-runtime-type.watsup:42.1-42.21
syntax basetyp = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()
   | `IntT`()
   | `FIntT%`(width)
   | `FBitT%`(width)
   | `VBitT%`(width)

;; ../../../../spec/2c1-runtime-type.watsup:49.1-50.98
syntax abstyp = 
   | `VarT%`(id)
   | `SpecT%%`(polytypdef, typ*)

;; ../../../../spec/2c1-runtime-type.watsup:57.1-57.60
syntax aliastyp = 
   | `DefT%%`(id, typ)

;; ../../../../spec/2c1-runtime-type.watsup:60.1-68.89
syntax datatyp = 
   | `NewT%%`(id, typ)
   | `EnumT%%`(id, member*)
   | `SEnumT%%%`(id, typ, (member, val)*)
   | `ListT%`(typ)
   | `TupleT%`(typ*)
   | `StackT%%`(typ, int)
   | `StructT%%`(id, (member, typ)*)
   | `HeaderT%%`(id, (member, typ)*)
   | `UnionT%%`(id, (member, typ)*)

;; ../../../../spec/2c1-runtime-type.watsup:71.1-75.59
syntax objtyp = 
   | `ExternT%%`(id, map<fid, funcdef>)
   | `ParserT%%`(id, paramtyp*)
   | `ControlT%%`(id, paramtyp*)
   | `PackageT%%`(id, typ*)
   | `TableT%%`(id, typ)

;; ../../../../spec/2c1-runtime-type.watsup:78.1-78.32
syntax deftyp = 
   | `DefT%%`(id, typ)
   | `NewT%%`(id, typ)
   | `EnumT%%`(id, member*)
   | `SEnumT%%%`(id, typ, (member, val)*)
   | `ListT%`(typ)
   | `TupleT%`(typ*)
   | `StackT%%`(typ, int)
   | `StructT%%`(id, (member, typ)*)
   | `HeaderT%%`(id, (member, typ)*)
   | `UnionT%%`(id, (member, typ)*)
   | `ExternT%%`(id, map<fid, funcdef>)
   | `ParserT%%`(id, paramtyp*)
   | `ControlT%%`(id, paramtyp*)
   | `PackageT%%`(id, typ*)
   | `TableT%%`(id, typ)

;; ../../../../spec/2c1-runtime-type.watsup:85.1-95.55
syntax synthtyp = 
   | `DefaultT`()
   | `SeqT%`(typ*)
   | `SeqDefaultT%`(typ*)
   | `RecordT%`((member, typ)*)
   | `RecordDefaultT%`((member, typ)*)
   | `InvalidT`()
   | `SetT%`(typ)
   | `StateT`()
   | `TableEnumT%%`(id, member*)
   | `TableStructT%%`(id, (member, typ)*)
   | `AnyT`()

;; ../../../../spec/2c1-runtime-type.watsup:98.1-98.41
syntax typ = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()
   | `IntT`()
   | `FIntT%`(width)
   | `FBitT%`(width)
   | `VBitT%`(width)
   | `VarT%`(id)
   | `SpecT%%`(polytypdef, typ*)
   | `DefT%%`(id, typ)
   | `NewT%%`(id, typ)
   | `EnumT%%`(id, member*)
   | `SEnumT%%%`(id, typ, (member, val)*)
   | `ListT%`(typ)
   | `TupleT%`(typ*)
   | `StackT%%`(typ, int)
   | `StructT%%`(id, (member, typ)*)
   | `HeaderT%%`(id, (member, typ)*)
   | `UnionT%%`(id, (member, typ)*)
   | `ExternT%%`(id, map<fid, funcdef>)
   | `ParserT%%`(id, paramtyp*)
   | `ControlT%%`(id, paramtyp*)
   | `PackageT%%`(id, typ*)
   | `TableT%%`(id, typ)
   | `DefaultT`()
   | `SeqT%`(typ*)
   | `SeqDefaultT%`(typ*)
   | `RecordT%`((member, typ)*)
   | `RecordDefaultT%`((member, typ)*)
   | `InvalidT`()
   | `SetT%`(typ)
   | `StateT`()
   | `TableEnumT%%`(id, member*)
   | `TableStructT%%`(id, (member, typ)*)
   | `AnyT`()

;; ../../../../spec/2c1-runtime-type.watsup:105.3-105.12
syntax monotypdef = 
   | `MonoD%`(typ)

;; ../../../../spec/2c1-runtime-type.watsup:107.3-107.34
syntax polytypdef = 
   | `PolyD%->%`((tparam*, tparam*), typ)

;; ../../../../spec/2c1-runtime-type.watsup:110.1-111.15
syntax typdef = 
   | `MonoD%`(typ)
   | `PolyD%->%`((tparam*, tparam*), typ)

;; ../../../../spec/2c1-runtime-type.watsup:122.1-130.82
syntax functyp = 
   | `ActionT%`(paramtyp*)
   | `ExternFuncT%%`(paramtyp*, typ)
   | `FuncT%%`(paramtyp*, typ)
   | `BuiltinMethodT%%`(paramtyp*, typ)
   | `ExternMethodT%%`(paramtyp*, typ)
   | `ExternAbstractMethodT%%`(paramtyp*, typ)
   | `ParserApplyMethodT%`(paramtyp*)
   | `ControlApplyMethodT%`(paramtyp*)
   | `TableApplyMethodT%`(typ)

;; ../../../../spec/2c1-runtime-type.watsup:139.3-139.65
syntax monofuncdef = 
   | `MonoFD%`(functyp)

;; ../../../../spec/2c1-runtime-type.watsup:142.3-142.69
syntax polyfuncdef = 
   | `PolyFD%->%`((tparam*, tparam*), functyp)

;; ../../../../spec/2c1-runtime-type.watsup:145.1-146.16
syntax funcdef = 
   | `MonoFD%`(functyp)
   | `PolyFD%->%`((tparam*, tparam*), functyp)

;; ../../../../spec/2c1-runtime-type.watsup:159.3-159.52
syntax constyp = 
   | `ConsT%%`(paramtyp*, typ)

;; ../../../../spec/2c1-runtime-type.watsup:168.3-168.38
syntax consdef = 
   | `ConsD%->%`((tparam*, tparam*), constyp)

;; ../../../../spec/2c2-runtime-type-aux.watsup:7.1-8.30
def $is_base(typ)

1. If ((typ has type basetyp)), then

  1. (Let basetyp be (typ as basetyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:13.1-14.35
def $is_prim(typ)

1. If ((typ has type primtyp)), then

  1. (Let primtyp be (typ as primtyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:19.1-20.27
def $is_voidt(typ)

1. If ((typ = ((VoidT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:25.1-26.26
def $is_errt(typ)

1. If ((typ = ((ErrT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:31.1-32.33
def $is_matchkindt(typ)

1. If ((typ = ((MatchKindT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:37.1-38.26
def $is_strt(typ)

1. If ((typ = ((StrT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:43.1-44.27
def $is_boolt(typ)

1. If ((typ = ((BoolT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:49.1-50.33
def $is_num(typ)

1. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:55.1-56.24
def $is_intt(typ)

1. If ((typ = ((IntT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:61.1-62.25
def $is_fintt(typ)

1. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. If ((numtyp matches pattern `FIntT%`)), then

    1. (Let (FIntT _width) be numtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:67.1-68.27
def $is_fbitt(typ)

1. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. If ((numtyp matches pattern `FBitT%`)), then

    1. (Let (FBitT _width) be numtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:73.1-74.27
def $is_vbitt(typ)

1. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. If ((numtyp matches pattern `VBitT%`)), then

    1. (Let (VBitT _width) be numtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:79.1-80.34
def $is_abstract(typ)

1. If ((typ has type abstyp)), then

  1. (Let abstyp be (typ as abstyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:85.1-86.26
def $is_vart(typ)

1. If ((typ has type abstyp)), then

  1. (Let abstyp be (typ as abstyp))

  2. If ((abstyp matches pattern `VarT%`)), then

    1. (Let (VarT _id) be abstyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:91.1-92.27
def $is_spect(typ)

1. If ((typ has type abstyp)), then

  1. (Let abstyp be (typ as abstyp))

  2. If ((abstyp matches pattern `SpecT%%`)), then

    1. (Let (SpecT _polytypdef _typ*) be abstyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:97.1-98.33
def $is_def(typ)

1. If ((typ has type deftyp)), then

  1. (Let deftyp be (typ as deftyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:103.1-104.31
def $is_alias(typ)

1. If ((typ has type aliastyp)), then

  1. (Let aliastyp be (typ as aliastyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:109.1-110.26
def $is_deft(typ)

1. If ((typ has type aliastyp)), then

  1. (Let (DefT _id _typ) be (typ as aliastyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:115.1-116.30
def $is_data(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:121.1-122.26
def $is_newt(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `NewT%%`)), then

    1. (Let (NewT _id _typ) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:127.1-128.27
def $is_enumt(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `EnumT%%`)), then

    1. (Let (EnumT _id _member*) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:133.1-134.28
def $is_senumt(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `SEnumT%%%`)), then

    1. (Let (SEnumT _id _typ _(member, val)*) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:139.1-140.27
def $is_listt(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `ListT%`)), then

    1. (Let (ListT _typ) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:145.1-146.28
def $is_tuplet(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `TupleT%`)), then

    1. (Let (TupleT _typ*) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:151.1-152.28
def $is_stackt(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `StackT%%`)), then

    1. (Let (StackT _typ _int) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:157.1-158.29
def $is_structt(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `StructT%%`)), then

    1. (Let (StructT _id _(member, typ)*) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:163.1-164.29
def $is_headert(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `HeaderT%%`)), then

    1. (Let (HeaderT _id _(member, typ)*) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:169.1-170.28
def $is_uniont(typ)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `UnionT%%`)), then

    1. (Let (UnionT _id _(member, typ)*) be datatyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:175.1-176.32
def $is_obj(typ)

1. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:181.1-182.29
def $is_externt(typ)

1. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `ExternT%%`)), then

    1. (Let (ExternT _id _map<fid, funcdef>) be objtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:187.1-188.29
def $is_parsert(typ)

1. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `ParserT%%`)), then

    1. (Let (ParserT _id _paramtyp*) be objtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:193.1-194.30
def $is_controlt(typ)

1. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `ControlT%%`)), then

    1. (Let (ControlT _id _paramtyp*) be objtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:199.1-200.30
def $is_packaget(typ)

1. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `PackageT%%`)), then

    1. (Let (PackageT _id _typ*) be objtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:205.1-206.28
def $is_tablet(typ)

1. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `TableT%%`)), then

    1. (Let (TableT _id _typ) be objtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:211.1-212.37
def $is_synth(typ)

1. If ((typ has type synthtyp)), then

  1. (Let synthtyp be (typ as synthtyp))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:217.1-218.26
def $is_seqt(typ)

1. If ((typ has type synthtyp)), then

  1. (Let synthtyp be (typ as synthtyp))

  2. If ((synthtyp matches pattern `SeqT%`)), then

    1. (Let (SeqT _typ*) be synthtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:223.1-224.29
def $is_recordt(typ)

1. If ((typ has type synthtyp)), then

  1. (Let synthtyp be (typ as synthtyp))

  2. If ((synthtyp matches pattern `RecordT%`)), then

    1. (Let (RecordT _(member, typ)*) be synthtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:229.1-230.26
def $is_sett(typ)

1. If ((typ has type synthtyp)), then

  1. (Let synthtyp be (typ as synthtyp))

  2. If ((synthtyp matches pattern `SetT%`)), then

    1. (Let (SetT _typ) be synthtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:235.1-236.35
def $is_table_structt(typ)

1. If ((typ has type synthtyp)), then

  1. (Let synthtyp be (typ as synthtyp))

  2. If ((synthtyp matches pattern `TableStructT%%`)), then

    1. (Let (TableStructT _id _(member, typ)*) be synthtyp)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:247.1-248.29
def $is_actiont(functyp)

1. If ((functyp matches pattern `ActionT%`)), then

  1. (Let (ActionT _paramtyp*) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:253.1-254.34
def $is_externfunct(functyp)

1. If ((functyp matches pattern `ExternFuncT%%`)), then

  1. (Let (ExternFuncT _paramtyp* _typ) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:259.1-260.27
def $is_funct(functyp)

1. If ((functyp matches pattern `FuncT%%`)), then

  1. (Let (FuncT _paramtyp* _typ) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:265.1-266.37
def $is_builtinmethodt(functyp)

1. If ((functyp matches pattern `BuiltinMethodT%%`)), then

  1. (Let (BuiltinMethodT _paramtyp* _typ) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:271.1-272.36
def $is_externmethodt(functyp)

1. If ((functyp matches pattern `ExternMethodT%%`)), then

  1. (Let (ExternMethodT _paramtyp* _typ) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:277.1-278.45
def $is_externabstractmethodt(functyp)

1. If ((functyp matches pattern `ExternAbstractMethodT%%`)), then

  1. (Let (ExternAbstractMethodT _paramtyp* _typ) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:283.1-284.42
def $is_parserapplymethodt(functyp)

1. If ((functyp matches pattern `ParserApplyMethodT%`)), then

  1. (Let (ParserApplyMethodT _paramtyp*) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:289.1-290.43
def $is_controlapplymethodt(functyp)

1. If ((functyp matches pattern `ControlApplyMethodT%`)), then

  1. (Let (ControlApplyMethodT _paramtyp*) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:295.1-296.41
def $is_tableapplymethodt(functyp)

1. If ((functyp matches pattern `TableApplyMethodT%`)), then

  1. (Let (TableApplyMethodT _typ) be functyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:303.1-304.38
def $get_params_functyp(functyp)

1. Case analysis on functyp

  1. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT pt*) be functyp)

    2. Return pt*

  2. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT pt* _typ) be functyp)

    2. Return pt*

  3. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT pt* _typ) be functyp)

    2. Return pt*

  4. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT pt* _typ) be functyp)

    2. Return pt*

  5. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT pt* _typ) be functyp)

    2. Return pt*

  6. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT pt*) be functyp)

    2. Return pt*

  7. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT pt*) be functyp)

    2. Return pt*

  8. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT pt* _typ) be functyp)

    2. Return pt*

  9. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT _typ) be functyp)

    2. Return []

;; ../../../../spec/2c2-runtime-type-aux.watsup:315.1-316.39
def $get_typ_ret_functyp(functyp)

1. Case analysis on functyp

  1. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT _paramtyp*) be functyp)

    2. Return ((VoidT) as typ)

  2. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT _paramtyp* typ_r) be functyp)

    2. Return typ_r

  3. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT _paramtyp* typ_r) be functyp)

    2. Return typ_r

  4. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT _paramtyp* typ_r) be functyp)

    2. Return typ_r

  5. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT _paramtyp* typ_r) be functyp)

    2. Return typ_r

  6. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT _paramtyp*) be functyp)

    2. Return ((VoidT) as typ)

  7. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT _paramtyp*) be functyp)

    2. Return ((VoidT) as typ)

  8. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT _paramtyp* typ_r) be functyp)

    2. Return typ_r

  9. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typ_r) be functyp)

    2. Return typ_r

;; ../../../../spec/2c2-runtime-type-aux.watsup:333.1-334.38
def $get_params_funcdef(funcdef)

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft) be (funcdef as monofuncdef))

    2. Return $get_params_functyp(ft)

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD _(tparam*, tparam*) -> ft) be (funcdef as polyfuncdef))

    2. Return $get_params_functyp(ft)

;; ../../../../spec/2c2-runtime-type-aux.watsup:338.1-339.39
def $get_typ_ret_funcdef(funcdef)

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft) be (funcdef as monofuncdef))

    2. Return $get_typ_ret_functyp(ft)

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD _(tparam*, tparam*) -> ft) be (funcdef as polyfuncdef))

    2. Return $get_typ_ret_functyp(ft)

;; ../../../../spec/2c3-runtime-type-subst.watsup:5.45-5.57
syntax theta = map<id, typ>

;; ../../../../spec/2c3-runtime-type-subst.watsup:7.1-8.44
def $free_typ(typ'')

1. Case analysis on typ''

  1. Case (% has type basetyp)

    1. (Let basetyp be (typ'' as basetyp))

    2. Return ({ [] })

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. Case analysis on abstyp

      1. Case (% matches pattern `VarT%`)

        1. (Let (VarT id) be abstyp)

        2. Return ({ [id] })

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT ptd typ''*) be abstyp)

        2. (Let tidset_ptd be $free_typdef_poly(ptd))

        3. (Let tidset_typs be $unions_set<tid>($free_typ(typ'')*))

        4. Return $union_set<tid>(tidset_ptd, tidset_typs)

  3. Case (% has type aliastyp)

    1. (Let (DefT _id typ'') be (typ'' as aliastyp))

    2. Return $free_typ(typ'')

  4. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ'') be datatyp)

        2. Return $free_typ(typ'')

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*) be datatyp)

        2. Return ({ [] })

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ'' _(member, val)*) be datatyp)

        2. Return $free_typ(typ'')

      4. Case (% matches pattern `ListT%`)

        1. (Let (ListT typ'') be datatyp)

        2. Return $free_typ(typ'')

      5. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*) be datatyp)

        2. Return $unions_set<tid>($free_typ(typ'')*)

      6. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'' _int) be datatyp)

        2. Return $free_typ(typ'')

      7. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (_member, typ'')*) be datatyp)

        2. Return $unions_set<tid>($free_typ(typ'')*)

      8. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id (_member, typ'')*) be datatyp)

        2. Return $unions_set<tid>($free_typ(typ'')*)

      9. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id (_member, typ'')*) be datatyp)

        2. Return $unions_set<tid>($free_typ(typ'')*)

  5. Case (% has type objtyp)

    1. (Let objtyp be (typ'' as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT _id ({ (_fid -> fd)* })) be objtyp)

        2. Return $unions_set<tid>($free_funcdef(fd)*)

      2. Case (% matches pattern `ParserT%%`)

        1. (Let (ParserT _id pt*) be objtyp)

        2. (Let (_id' _dir typ'' _exprIL?) be pt)*

        3. Return $unions_set<tid>($free_typ(typ'')*)

      3. Case (% matches pattern `ControlT%%`)

        1. (Let (ControlT _id pt*) be objtyp)

        2. (Let (_id' _dir typ'' _exprIL?) be pt)*

        3. Return $unions_set<tid>($free_typ(typ'')*)

      4. Case (% matches pattern `PackageT%%`)

        1. (Let (PackageT _id typ''*) be objtyp)

        2. Return $unions_set<tid>($free_typ(typ'')*)

      5. Case (% matches pattern `TableT%%`)

        1. (Let (TableT _id typ'') be objtyp)

        2. Return $free_typ(typ'')

  6. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. Case analysis on synthtyp

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typ''*) be synthtyp)

        2. Return $unions_set<tid>($free_typ(typ'')*)

      2. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typ''*) be synthtyp)

        2. Return $unions_set<tid>($free_typ(typ'')*)

      3. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (_member, typ'')*) be synthtyp)

        2. Return $unions_set<tid>($free_typ(typ'')*)

      4. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (_member, typ'')*) be synthtyp)

        2. Return $unions_set<tid>($free_typ(typ'')*)

      5. Case (% matches pattern `SetT%`)

        1. (Let (SetT typ'') be synthtyp)

        2. Return $free_typ(typ'')

      6. Case (% matches pattern `TableEnumT%%`)

        1. (Let (TableEnumT _id _member*) be synthtyp)

        2. Return ({ [] })

      7. Case (% matches pattern `TableStructT%%`)

        1. (Let (TableStructT _id (_member, typ'')*) be synthtyp)

        2. Return $unions_set<tid>($free_typ(typ'')*)

    2. Else Phantom#1

2. If ((typ'' = ((DefaultT) as typ))), then

  1. Return ({ [] })

2. Else Phantom#2

3. If ((typ'' = ((InvalidT) as typ))), then

  1. Return ({ [] })

3. Else Phantom#3

4. If ((typ'' = ((StateT) as typ))), then

  1. Return ({ [] })

4. Else Phantom#4

5. If ((typ'' = ((AnyT) as typ))), then

  1. Return ({ [] })

5. Else Phantom#5

;; ../../../../spec/2c3-runtime-type-subst.watsup:9.1-10.44
def $free_typdef_poly((PolyD (tparam*, tparam_hidden*) -> typ))

1. (Let tidset_typ be $free_typ(typ))

2. (Let tidset_tparams be ({ tparam* ++ tparam_hidden* }))

3. Return $diff_set<tid>(tidset_typ, tidset_tparams)

;; ../../../../spec/2c3-runtime-type-subst.watsup:11.1-12.44
def $free_functyp(functyp)

1. Case analysis on functyp

  1. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT pt*) be functyp)

    2. (Let (_id _dir typ _exprIL?) be pt)*

    3. Return $unions_set<tid>($free_typ(typ)*)

  2. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT pt* typ_r) be functyp)

    2. (Let (_id _dir typ_p _exprIL?) be pt)*

    3. (Let tidset_params be $unions_set<tid>($free_typ(typ_p)*))

    4. (Let tidset_return be $free_typ(typ_r))

    5. Return $union_set<tid>(tidset_params, tidset_return)

  3. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT pt* typ_r) be functyp)

    2. (Let (_id _dir typ_p _exprIL?) be pt)*

    3. (Let tidset_params be $unions_set<tid>($free_typ(typ_p)*))

    4. (Let tidset_return be $free_typ(typ_r))

    5. Return $union_set<tid>(tidset_params, tidset_return)

  4. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT pt* typ_r) be functyp)

    2. (Let (_id _dir typ_p _exprIL?) be pt)*

    3. (Let tidset_params be $unions_set<tid>($free_typ(typ_p)*))

    4. (Let tidset_return be $free_typ(typ_r))

    5. Return $union_set<tid>(tidset_params, tidset_return)

  5. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT pt* typ_r) be functyp)

    2. (Let (_id _dir typ_p _exprIL?) be pt)*

    3. (Let tidset_params be $unions_set<tid>($free_typ(typ_p)*))

    4. (Let tidset_return be $free_typ(typ_r))

    5. Return $union_set<tid>(tidset_params, tidset_return)

  6. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT pt* typ_r) be functyp)

    2. (Let (_id _dir typ_p _exprIL?) be pt)*

    3. (Let tidset_params be $unions_set<tid>($free_typ(typ_p)*))

    4. (Let tidset_return be $free_typ(typ_r))

    5. Return $union_set<tid>(tidset_params, tidset_return)

  7. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT pt*) be functyp)

    2. (Let (_id _dir typ _exprIL?) be pt)*

    3. Return $unions_set<tid>($free_typ(typ)*)

  8. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT pt*) be functyp)

    2. (Let (_id _dir typ _exprIL?) be pt)*

    3. Return $unions_set<tid>($free_typ(typ)*)

  9. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typ) be functyp)

    2. Return $free_typ(typ)

;; ../../../../spec/2c3-runtime-type-subst.watsup:13.1-14.44
def $free_funcdef(funcdef)

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft) be (funcdef as monofuncdef))

    2. Return $free_functyp(ft)

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD (tparam*, tparam_hidden*) -> ft) be (funcdef as polyfuncdef))

    2. (Let tidset_ft be $free_functyp(ft))

    3. (Let tidset_tparams be ({ tparam* ++ tparam_hidden* }))

    4. Return $diff_set<tid>(tidset_ft, tidset_tparams)

;; ../../../../spec/2c3-runtime-type-subst.watsup:16.1-17.33
def $subst_typ(theta, typ''')

1. Case analysis on typ'''

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ''' as abstyp))

    2. Case analysis on abstyp

      1. Case (% matches pattern `VarT%`)

        1. (Let (VarT id) be abstyp)

        2. If ($in_set<id>(id, $dom_map<id, typ>(theta))), then

          1. (Let typ''? be $find_map<id, typ>(theta, id))

          2. If ((typ''? matches pattern (_))), then

            1. (Let ?(typ) be typ''?)

            2. Return typ

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT ptd typ*) be abstyp)

        2. (Let ptd' be $subst_typdef_poly(theta, ptd))

        3. (Let typ'''* be $subst_typ(theta, typ)*)

        4. Return ((SpecT ptd' typ'''*) as typ)

  2. Case (% has type aliastyp)

    1. (Let (DefT _id typ) be (typ''' as aliastyp))

    2. Return $subst_typ(theta, typ)

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ''' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT id typ) be datatyp)

        2. Return ((NewT id $subst_typ(theta, typ)) as typ)

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT id typ (member, val)*) be datatyp)

        2. Return ((SEnumT id $subst_typ(theta, typ) (member, val)*) as typ)

      3. Case (% matches pattern `ListT%`)

        1. (Let (ListT typ) be datatyp)

        2. Return ((ListT $subst_typ(theta, typ)) as typ)

      4. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ*) be datatyp)

        2. Return ((TupleT $subst_typ(theta, typ)*) as typ)

      5. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ int) be datatyp)

        2. Return ((StackT $subst_typ(theta, typ) int) as typ)

      6. Case (% matches pattern `StructT%%`)

        1. (Let (StructT id (member, typ)*) be datatyp)

        2. Return ((StructT id (member, $subst_typ(theta, typ))*) as typ)

      7. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT id (member, typ)*) be datatyp)

        2. Return ((HeaderT id (member, $subst_typ(theta, typ))*) as typ)

      8. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT id (member, typ)*) be datatyp)

        2. Return ((UnionT id (member, $subst_typ(theta, typ))*) as typ)

  4. Case (% has type objtyp)

    1. (Let objtyp be (typ''' as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT id fmap) be objtyp)

        2. (Let ({ (fid -> funcdef)* }) be fmap)

        3. (Let fmap' be ({ (fid -> $subst_funcdef(theta, funcdef))* }))

        4. Return ((ExternT id fmap') as typ)

      2. Case (% matches pattern `ParserT%%`)

        1. (Let (ParserT id pt*) be objtyp)

        2. (Let (id' dir typ''' exprIL?) be pt)*

        3. (Let pt' be (id' dir $subst_typ(theta, typ''') exprIL?))*

        4. Return ((ParserT id pt'*) as typ)

      3. Case (% matches pattern `ControlT%%`)

        1. (Let (ControlT id pt*) be objtyp)

        2. (Let (id' dir typ''' exprIL?) be pt)*

        3. (Let pt' be (id' dir $subst_typ(theta, typ''') exprIL?))*

        4. Return ((ControlT id pt'*) as typ)

      4. Case (% matches pattern `PackageT%%`)

        1. (Let (PackageT id typ'''*) be objtyp)

        2. Return ((PackageT id $subst_typ(theta, typ''')*) as typ)

      5. Case (% matches pattern `TableT%%`)

        1. (Let (TableT id typ''') be objtyp)

        2. Return ((TableT id $subst_typ(theta, typ''')) as typ)

  5. Case (% has type synthtyp)

    1. (Let synthtyp be (typ''' as synthtyp))

    2. Case analysis on synthtyp

      1. Case (% matches pattern `TableStructT%%`)

        1. (Let (TableStructT id (member, typ''')*) be synthtyp)

        2. Return ((TableStructT id (member, $subst_typ(theta, typ'''))*) as typ)

      2. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typ'''*) be synthtyp)

        2. Return ((SeqT $subst_typ(theta, typ''')*) as typ)

      3. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typ'''*) be synthtyp)

        2. Return ((SeqDefaultT $subst_typ(theta, typ''')*) as typ)

      4. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (member, typ''')*) be synthtyp)

        2. Return ((RecordT (member, $subst_typ(theta, typ'''))*) as typ)

      5. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (member, typ''')*) be synthtyp)

        2. Return ((RecordDefaultT (member, $subst_typ(theta, typ'''))*) as typ)

      6. Case (% matches pattern `SetT%`)

        1. (Let (SetT typ''') be synthtyp)

        2. Return ((SetT $subst_typ(theta, typ''')) as typ)

2. Otherwise

  1. Return typ'''

;; ../../../../spec/2c3-runtime-type-subst.watsup:18.1-19.33
def $subst_typdef_poly(theta, (PolyD (tparam*, tparam_hidden*) -> typ))

1. (Let ({ tid_free* }) be $diff_set<tid>($free_typ(typ), ({ tparam* ++ tparam_hidden* })))

2. (Let typ''? be $find_map<tid, typ>(theta, tid_free))*

3. If ((typ''? matches pattern (_)))*, then

  1. (Let ?(typ_free) be typ''?)*

  2. (Let tidset_capture be $unions_set<tid>($free_typ(typ_free)*))

  3. (Let tparam'* be $fresh_tids(|tparam* ++ tparam_hidden*|))

  4. If (~$in_set<tid>(tparam', tidset_capture))*, then

    1. (Let tparam''* be tparam'*[0 : |tparam*|])

    2. (Let tparam''_hidden* be tparam'*[|tparam*| : |tparam_hidden*|])

    3. (Let theta' be $adds_map<tid, typ>(theta, tparam*, ((VarT tparam'') as typ)*))

    4. (Let theta'' be $adds_map<tid, typ>(theta', tparam_hidden*, ((VarT tparam''_hidden) as typ)*))

    5. (Let typ' be $subst_typ(theta'', typ))

    6. Return (PolyD (tparam''*, tparam''_hidden*) -> typ')

  4. Else Phantom#6

3. Else Phantom#7

;; ../../../../spec/2c3-runtime-type-subst.watsup:20.1-21.33
def $subst_funcdef(theta, funcdef)

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft) be (funcdef as monofuncdef))

    2. Return ((MonoFD $subst_functyp(theta, ft)) as funcdef)

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD (tparam*, tparam_hidden*) -> ft) be (funcdef as polyfuncdef))

    2. (Let ({ tid_free* }) be $diff_set<tid>($free_functyp(ft), ({ tparam* ++ tparam_hidden* })))

    3. (Let typ? be $find_map<tid, typ>(theta, tid_free))*

    4. If ((typ? matches pattern (_)))*, then

      1. (Let ?(typ_free) be typ?)*

      2. (Let tidset_capture be $unions_set<tid>($free_typ(typ_free)*))

      3. (Let tparam'* be $fresh_tids(|tparam* ++ tparam_hidden*|))

      4. If (~$in_set<tid>(tparam', tidset_capture))*, then

        1. (Let tparam''* be tparam'*[0 : |tparam*|])

        2. (Let tparam''_hidden* be tparam'*[|tparam*| : |tparam_hidden*|])

        3. (Let theta' be $adds_map<tid, typ>(theta, tparam*, ((VarT tparam') as typ)*))

        4. (Let theta'' be $adds_map<tid, typ>(theta', tparam_hidden*, ((VarT tparam''_hidden) as typ)*))

        5. (Let ft' be $subst_functyp(theta'', ft))

        6. Return ((PolyFD (tparam''*, tparam''_hidden*) -> ft') as funcdef)

      4. Else Phantom#8

    4. Else Phantom#9

;; ../../../../spec/2c3-runtime-type-subst.watsup:22.1-23.33
def $subst_functyp(theta, functyp)

1. Case analysis on functyp

  1. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT pt* typ) be functyp)

    2. (Let (id dir typ_p exprIL?) be pt)*

    3. (Let pt' be (id dir $subst_typ(theta, typ_p) exprIL?))*

    4. Return (BuiltinMethodT pt'* $subst_typ(theta, typ))

  2. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT pt*) be functyp)

    2. (Let (id dir typ exprIL?) be pt)*

    3. (Let pt' be (id dir $subst_typ(theta, typ) exprIL?))*

    4. Return (ActionT pt'*)

  3. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT pt*) be functyp)

    2. (Let (id dir typ exprIL?) be pt)*

    3. (Let pt' be (id dir $subst_typ(theta, typ) exprIL?))*

    4. Return (ParserApplyMethodT pt'*)

  4. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT pt*) be functyp)

    2. (Let (id dir typ exprIL?) be pt)*

    3. (Let pt' be (id dir $subst_typ(theta, typ) exprIL?))*

    4. Return (ControlApplyMethodT pt'*)

  5. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typ) be functyp)

    2. Return (TableApplyMethodT $subst_typ(theta, typ))

  6. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT pt* typ) be functyp)

    2. (Let (id dir typ_p exprIL?) be pt)*

    3. (Let pt' be (id dir $subst_typ(theta, typ_p) exprIL?))*

    4. Return (ExternFuncT pt'* $subst_typ(theta, typ))

  7. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT pt* typ) be functyp)

    2. (Let (id dir typ_p exprIL?) be pt)*

    3. (Let pt' be (id dir $subst_typ(theta, typ_p) exprIL?))*

    4. Return (FuncT pt'* $subst_typ(theta, typ))

  8. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT pt* typ) be functyp)

    2. (Let (id dir typ_p exprIL?) be pt)*

    3. (Let pt' be (id dir $subst_typ(theta, typ_p) exprIL?))*

    4. Return (ExternMethodT pt'* $subst_typ(theta, typ))

  9. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT pt* typ) be functyp)

    2. (Let (id dir typ_p exprIL?) be pt)*

    3. (Let pt' be (id dir $subst_typ(theta, typ_p) exprIL?))*

    4. Return (ExternAbstractMethodT pt'* $subst_typ(theta, typ))

;; ../../../../spec/2c3-runtime-type-subst.watsup:24.1-25.33
def $subst_constyp(theta, (ConsT pt* typ))

1. (Let (id dir typ_p exprIL?) be pt)*

2. (Let pt' be (id dir $subst_typ(theta, typ_p) exprIL?))*

3. Return (ConsT pt'* $subst_typ(theta, typ))

;; ../../../../spec/2c3-runtime-type-subst.watsup:317.1-318.57
def $specialize_typdef(typdef, typ''*)

1. Case analysis on typdef

  1. Case (% has type monotypdef)

    1. (Let (MonoD typ) be (typdef as monotypdef))

    2. If ((typ''* matches pattern [])), then

      1. Return typ

    2. Else Phantom#10

  2. Case (% has type polytypdef)

    1. (Let (PolyD (tparam*, tparam_hidden*) -> typ) be (typdef as polytypdef))

    2. (Let tparam'* be tparam* ++ tparam_hidden*)

    3. (Let theta be ({ (tparam' -> typ'')* }))

    4. Return $subst_typ(theta, typ)

;; ../../../../spec/2c3-runtime-type-subst.watsup:329.1-330.57
def $specialize_funcdef(funcdef, typ'*)

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft) be (funcdef as monofuncdef))

    2. If ((typ'* matches pattern [])), then

      1. Return (ft, [])

    2. Else Phantom#11

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD (tparam*, tparam_hidden*) -> ft) be (funcdef as polyfuncdef))

    2. (Let tparam'* be tparam* ++ tparam_hidden*)

    3. If ((|tparam'*| = |typ'*|)), then

      1. Return ($subst_functyp(({ (tparam' -> typ')* }), ft), [])

    3. Else Phantom#12

    4. If (((|typ'*| = 0) /\ (|tparam'*| > 0))), then

      1. (Let tid_fresh* be $fresh_tids(|tparam'*|))

      2. Return ($subst_functyp(({ (tparam' -> ((VarT tid_fresh) as typ))* }), ft), tid_fresh*)

    4. Else Phantom#13

    5. If ((((|typ'*| > 0) /\ (|tparam*| = |typ'*|)) /\ (|tparam_hidden*| > 0))), then

      1. (Let tid_fresh* be $fresh_tids(|tparam_hidden*|))

      2. (Let typ_a'* be typ'* ++ ((VarT tid_fresh) as typ)*)

      3. Return ($subst_functyp(({ (tparam' -> typ_a')* }), ft), tid_fresh*)

    5. Else Phantom#14

;; ../../../../spec/2c3-runtime-type-subst.watsup:359.1-360.57
def $specialize_consdef((ConsD (tparam*, tparam_hidden*) -> ct), typ_a*)

1. (Let tparam'* be tparam* ++ tparam_hidden*)

2. If ((|tparam'*| = |typ_a*|)), then

  1. Return ($subst_constyp(({ (tparam' -> typ_a)* }), ct), [])

2. Else Phantom#15

3. If (((|typ_a*| = 0) /\ (|tparam'*| > 0))), then

  1. (Let tid_fresh* be $fresh_tids(|tparam'*|))

  2. Return ($subst_constyp(({ (tparam' -> ((VarT tid_fresh) as typ))* }), ct), tid_fresh*)

3. Else Phantom#16

4. If ((((|typ_a*| > 0) /\ (|tparam*| = |typ_a*|)) /\ (|tparam_hidden*| > 0))), then

  1. (Let tid_fresh* be $fresh_tids(|tparam_hidden*|))

  2. (Let typ_a'* be typ_a* ++ ((VarT tid_fresh) as typ)*)

  3. Return ($subst_constyp(({ (tparam' -> typ_a')* }), ct), tid_fresh*)

4. Else Phantom#17

;; ../../../../spec/2c3-runtime-type-subst.watsup:387.1-388.47
def $canon_typ(typ'')

1. Case analysis on typ''

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `SpecT%%`)), then

      1. (Let (SpecT ptd typ_a*) be abstyp)

      2. (Let typ be $specialize_typdef((ptd as typdef), typ_a*))

      3. Return $canon_typ(typ)

  2. Case (% has type aliastyp)

    1. (Let (DefT _id typ) be (typ'' as aliastyp))

    2. Return $canon_typ(typ)

2. Otherwise

  1. Return typ''

;; ../../../../spec/2c4-runtime-type-util.watsup:7.1-8.28
def $is_nominal(typ)

1. Return $is_nominal'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:9.1-9.29
def $is_nominal'(typ)

1. Case analysis on typ

  1. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*) be datatyp)

        2. Return true

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*) be datatyp)

        2. Return true

      4. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id _(member, typ)*) be datatyp)

        2. Return true

      5. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id _(member, typ)*) be datatyp)

        2. Return true

      6. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id _(member, typ)*) be datatyp)

        2. Return true

  2. Case (% has type objtyp)

    1. (Let objtyp be (typ as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT _id _map<fid, funcdef>) be objtyp)

        2. Return true

      2. Case (% matches pattern `TableT%%`)

        1. (Let (TableT _id _typ) be objtyp)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c4-runtime-type-util.watsup:25.1-26.32
def $is_deftable(typ)

1. Return $is_deftable'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:27.1-27.30
def $is_deftable'(typ'')

1. If ((typ'' = ((ErrT) as typ))), then

  1. Return true

2. If ((typ'' = ((StrT) as typ))), then

  1. Return true

3. If ((typ'' = ((BoolT) as typ))), then

  1. Return true

4. If ((typ'' = ((IntT) as typ))), then

  1. Return true

5. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT _width) be numtyp)

        2. Return true

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ') be datatyp)

        2. Return $is_deftable(typ')

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*) be datatyp)

        2. Return true

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ' _(member, val)*) be datatyp)

        2. Return $is_deftable(typ')

      4. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ'*) be datatyp)

        2. If ($is_deftable(typ'))*, then

          1. Return true

      5. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'' _int) be datatyp)

        2. Return $is_deftable(typ'')

      6. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (_member, typ'')*) be datatyp)

        2. If ($is_deftable(typ''))*, then

          1. Return true

      7. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id (_member, typ'')*) be datatyp)

        2. If ($is_deftable(typ''))*, then

          1. Return true

      8. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id (_member, typ'')*) be datatyp)

        2. If ($is_deftable(typ''))*, then

          1. Return true

6. Otherwise

  1. Return false

;; ../../../../spec/2c4-runtime-type-util.watsup:54.1-55.30
def $is_equalable(typ)

1. Return $is_equalable'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:56.1-56.31
def $is_equalable'(typ)

1. If ((typ = ((VoidT) as typ))), then

  1. Return false

2. Case analysis on typ

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return false

  2. Case (% has type objtyp)

    1. (Let objtyp be (typ as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT _id _map<fid, funcdef>) be objtyp)

        2. Return false

      2. Case (% matches pattern `ParserT%%`)

        1. (Let (ParserT _id _paramtyp*) be objtyp)

        2. Return false

      3. Case (% matches pattern `ControlT%%`)

        1. (Let (ControlT _id _paramtyp*) be objtyp)

        2. Return false

      4. Case (% matches pattern `PackageT%%`)

        1. (Let (PackageT _id _typ*) be objtyp)

        2. Return false

      5. Case (% matches pattern `TableT%%`)

        1. (Let (TableT _id _typ) be objtyp)

        2. Return false

  3. Case (% has type synthtyp)

    1. (Let synthtyp be (typ as synthtyp))

    2. Return ($is_seqt((synthtyp as typ)) \/ $is_recordt((synthtyp as typ)))

3. Otherwise

  1. Return true

;; ../../../../spec/2c4-runtime-type-util.watsup:72.1-73.31
def $is_assignable(typ)

1. Return $is_assignable'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:74.1-74.32
def $is_assignable'(typ)

1. If ((typ = ((VoidT) as typ))), then

  1. Return false

2. If ((typ = ((StrT) as typ))), then

  1. Return false

3. If ((typ = ((IntT) as typ))), then

  1. Return false

4. Case analysis on typ

  1. Case (% has type objtyp)

    1. (Let objtyp be (typ as objtyp))

    2. Return false

  2. Case (% has type synthtyp)

    1. (Let synthtyp be (typ as synthtyp))

    2. Return false

5. Otherwise

  1. Return true

;; ../../../../spec/2c4-runtime-type-util.watsup:89.1-89.26
def $get_width(typ)

1. Return $get_width'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:90.1-90.27
def $get_width'(typ'')

1. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numtyp)

        2. Return w

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numtyp)

        2. Return w

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT w) be numtyp)

        2. Return w

    2. Else Phantom#18

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id typ'') be datatyp)

      2. Return $get_width(typ'')

    2. Else Phantom#19

1. Else Phantom#20

;; ../../../../spec/2c5-runtime-type-alpha.watsup:5.1-7.20
relation Type_alpha: typ'', typ'''

1. Case analysis on typ''

  1. Case (% has type basetyp)

    1. (Let basetyp be (typ'' as basetyp))

    2. If ((typ''' has type basetyp)), then

      1. (Let basetyp' be (typ''' as basetyp))

      2. If ((basetyp = basetyp')), then

        1. The relation holds

      2. Else Phantom#21

    2. Else Phantom#22

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. Case analysis on abstyp

      1. Case (% matches pattern `VarT%`)

        1. (Let (VarT id) be abstyp)

        2. If ((typ''' has type abstyp)), then

          1. (Let abstyp' be (typ''' as abstyp))

          2. If ((abstyp' matches pattern `VarT%`)), then

            1. (Let (VarT id') be abstyp')

            2. If ((id = id')), then

              1. The relation holds

            2. Else Phantom#23

          2. Else Phantom#24

        2. Else Phantom#25

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT ptd_a typ_a*) be abstyp)

        2. If ((typ''' has type abstyp)), then

          1. (Let abstyp' be (typ''' as abstyp))

          2. If ((abstyp' matches pattern `SpecT%%`)), then

            1. (Let (SpecT ptd_b typ_b*) be abstyp')

            2. (Let typ_a' be $specialize_typdef((ptd_a as typdef), typ_a*))

            3. (Let typ_b' be $specialize_typdef((ptd_b as typdef), typ_b*))

            4. If ((Type_alpha: typ_a' ~~ typ_b' holds)), then

              1. If (($is_nominal(typ_a') /\ $is_nominal(typ_b'))), then

                1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

                  1. The relation holds

                1. Else Phantom#26

              1. Else Phantom#27

              2. If ((~$is_nominal(typ_a') /\ ~$is_nominal(typ_b'))), then

                1. The relation holds

              2. Else Phantom#28

            4. Else Phantom#29

          2. Else Phantom#30

        2. Else Phantom#31

  3. Case (% has type aliastyp)

    1. (Let (DefT _id typ_a) be (typ'' as aliastyp))

    2. If ((Type_alpha: typ_a ~~ typ''' holds)), then

      1. The relation holds

    2. Else Phantom#32

  4. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT id typ'') be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `NewT%%`)), then

            1. (Let (NewT id' typ''') be datatyp')

            2. If ((id = id')), then

              1. If ((Type_alpha: typ'' ~~ typ''' holds)), then

                1. The relation holds

              1. Else Phantom#33

            2. Else Phantom#34

          2. Else Phantom#35

        2. Else Phantom#36

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT id member*) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `EnumT%%`)), then

            1. (Let (EnumT id' member'*) be datatyp')

            2. If ((id = id')), then

              1. If ((member = member'))*, then

                1. The relation holds

              1. Else Phantom#37

            2. Else Phantom#38

          2. Else Phantom#39

        2. Else Phantom#40

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT id typ'' (member, val_a)*) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `SEnumT%%%`)), then

            1. (Let (SEnumT id' typ''' (member', val_b)*) be datatyp')

            2. If ((id = id')), then

              1. If ((member = member'))*, then

                1. If ((Type_alpha: typ'' ~~ typ''' holds)), then

                  1. If ((val_a = val_b))*, then

                    1. The relation holds

                  1. Else Phantom#41

                1. Else Phantom#42

              1. Else Phantom#43

            2. Else Phantom#44

          2. Else Phantom#45

        2. Else Phantom#46

      4. Case (% matches pattern `ListT%`)

        1. (Let (ListT typ'') be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `ListT%`)), then

            1. (Let (ListT typ''') be datatyp')

            2. If ((Type_alpha: typ'' ~~ typ''' holds)), then

              1. The relation holds

            2. Else Phantom#47

          2. Else Phantom#48

        2. Else Phantom#49

      5. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `TupleT%`)), then

            1. (Let (TupleT typ'''*) be datatyp')

            2. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

              1. The relation holds

            2. Else Phantom#50

          2. Else Phantom#51

        2. Else Phantom#52

      6. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'' i_size) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `StackT%%`)), then

            1. (Let (StackT typ''' i_size') be datatyp')

            2. If ((i_size = i_size')), then

              1. If ((Type_alpha: typ'' ~~ typ''' holds)), then

                1. The relation holds

              1. Else Phantom#53

            2. Else Phantom#54

          2. Else Phantom#55

        2. Else Phantom#56

      7. Case (% matches pattern `StructT%%`)

        1. (Let (StructT id (member, typ'')*) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `StructT%%`)), then

            1. (Let (StructT id' (member', typ''')*) be datatyp')

            2. If ((id = id')), then

              1. If ((member = member'))*, then

                1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

                  1. The relation holds

                1. Else Phantom#57

              1. Else Phantom#58

            2. Else Phantom#59

          2. Else Phantom#60

        2. Else Phantom#61

      8. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT id (member, typ'')*) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `HeaderT%%`)), then

            1. (Let (HeaderT id' (member', typ''')*) be datatyp')

            2. If ((id = id')), then

              1. If ((member = member'))*, then

                1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

                  1. The relation holds

                1. Else Phantom#62

              1. Else Phantom#63

            2. Else Phantom#64

          2. Else Phantom#65

        2. Else Phantom#66

      9. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT id (member, typ'')*) be datatyp)

        2. If ((typ''' has type datatyp)), then

          1. (Let datatyp' be (typ''' as datatyp))

          2. If ((datatyp' matches pattern `UnionT%%`)), then

            1. (Let (UnionT id' (member', typ''')*) be datatyp')

            2. If ((id = id')), then

              1. If ((member = member'))*, then

                1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

                  1. The relation holds

                1. Else Phantom#67

              1. Else Phantom#68

            2. Else Phantom#69

          2. Else Phantom#70

        2. Else Phantom#71

  5. Case (% has type objtyp)

    1. (Let objtyp be (typ'' as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT id fmap_a) be objtyp)

        2. If ((typ''' has type objtyp)), then

          1. (Let objtyp' be (typ''' as objtyp))

          2. If ((objtyp' matches pattern `ExternT%%`)), then

            1. (Let (ExternT id' fmap_b) be objtyp')

            2. If ((id = id')), then

              1. (Let ({ (fid_a -> fd_a)* }) be fmap_a)

              2. (Let ({ (fid_b -> fd_b)* }) be fmap_b)

              3. If ($eq_set<fid>(({ fid_a* }), ({ fid_b* }))), then

                1. (Let funcdef? be $find_map<fid, funcdef>(fmap_a, fid_a))*

                2. If ((funcdef? matches pattern (_)))*, then

                  1. (Let ?(fd_a') be funcdef?)*

                  2. (Let funcdef'? be $find_map<fid, funcdef>(fmap_b, fid_a))*

                  3. If ((funcdef'? matches pattern (_)))*, then

                    1. (Let ?(fd_b') be funcdef'?)*

                    2. If ((FuncDef_alpha: fd_a' ~~ fd_b' holds))*, then

                      1. The relation holds

                    2. Else Phantom#72

                  3. Else Phantom#73

                2. Else Phantom#74

              3. Else Phantom#75

            2. Else Phantom#76

          2. Else Phantom#77

        2. Else Phantom#78

      2. Case (% matches pattern `ParserT%%`)

        1. (Let (ParserT _id pt_a*) be objtyp)

        2. If ((typ''' has type objtyp)), then

          1. (Let objtyp' be (typ''' as objtyp))

          2. If ((objtyp' matches pattern `ParserT%%`)), then

            1. (Let (ParserT _id' pt_b*) be objtyp')

            2. (Let (_id'' dir_a typ'' _exprIL?) be pt_a)*

            3. (Let (_id''' dir_b typ''' _exprIL'?) be pt_b)*

            4. If ((dir_a = dir_b))*, then

              1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

                1. The relation holds

              1. Else Phantom#79

            4. Else Phantom#80

          2. Else Phantom#81

        2. Else Phantom#82

      3. Case (% matches pattern `ControlT%%`)

        1. (Let (ControlT _id pt_a*) be objtyp)

        2. If ((typ''' has type objtyp)), then

          1. (Let objtyp' be (typ''' as objtyp))

          2. If ((objtyp' matches pattern `ControlT%%`)), then

            1. (Let (ControlT _id' pt_b*) be objtyp')

            2. (Let (_id'' dir_a typ'' _exprIL?) be pt_a)*

            3. (Let (_id''' dir_b typ''' _exprIL'?) be pt_b)*

            4. If ((dir_a = dir_b))*, then

              1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

                1. The relation holds

              1. Else Phantom#83

            4. Else Phantom#84

          2. Else Phantom#85

        2. Else Phantom#86

      4. Case (% matches pattern `PackageT%%`)

        1. (Let (PackageT _id typ''*) be objtyp)

        2. If ((typ''' has type objtyp)), then

          1. (Let objtyp' be (typ''' as objtyp))

          2. If ((objtyp' matches pattern `PackageT%%`)), then

            1. (Let (PackageT _id' typ'''*) be objtyp')

            2. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

              1. The relation holds

            2. Else Phantom#87

          2. Else Phantom#88

        2. Else Phantom#89

      5. Case (% matches pattern `TableT%%`)

        1. (Let (TableT id typ'') be objtyp)

        2. If ((typ''' has type objtyp)), then

          1. (Let objtyp' be (typ''' as objtyp))

          2. If ((objtyp' matches pattern `TableT%%`)), then

            1. (Let (TableT id' typ''') be objtyp')

            2. If ((id = id')), then

              1. If ((Type_alpha: typ'' ~~ typ''' holds)), then

                1. The relation holds

              1. Else Phantom#90

            2. Else Phantom#91

          2. Else Phantom#92

        2. Else Phantom#93

  6. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. Case analysis on synthtyp

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typ''*) be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `SeqT%`)), then

            1. (Let (SeqT typ'''*) be synthtyp')

            2. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

              1. The relation holds

            2. Else Phantom#94

          2. Else Phantom#95

        2. Else Phantom#96

      2. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typ''*) be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `SeqDefaultT%`)), then

            1. (Let (SeqDefaultT typ'''*) be synthtyp')

            2. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

              1. The relation holds

            2. Else Phantom#97

          2. Else Phantom#98

        2. Else Phantom#99

      3. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (member, typ'')*) be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `RecordT%`)), then

            1. (Let (RecordT (member', typ''')*) be synthtyp')

            2. If ((member = member'))*, then

              1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

                1. The relation holds

              1. Else Phantom#100

            2. Else Phantom#101

          2. Else Phantom#102

        2. Else Phantom#103

      4. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (member, typ'')*) be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `RecordDefaultT%`)), then

            1. (Let (RecordDefaultT (member', typ''')*) be synthtyp')

            2. If ((member = member'))*, then

              1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

                1. The relation holds

              1. Else Phantom#104

            2. Else Phantom#105

          2. Else Phantom#106

        2. Else Phantom#107

      5. Case (% matches pattern `SetT%`)

        1. (Let (SetT typ'') be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `SetT%`)), then

            1. (Let (SetT typ''') be synthtyp')

            2. If ((Type_alpha: typ'' ~~ typ''' holds)), then

              1. The relation holds

            2. Else Phantom#108

          2. Else Phantom#109

        2. Else Phantom#110

      6. Case (% matches pattern `TableEnumT%%`)

        1. (Let (TableEnumT id member*) be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `TableEnumT%%`)), then

            1. (Let (TableEnumT id' member'*) be synthtyp')

            2. If ((id = id')), then

              1. If ((member = member'))*, then

                1. The relation holds

              1. Else Phantom#111

            2. Else Phantom#112

          2. Else Phantom#113

        2. Else Phantom#114

      7. Case (% matches pattern `TableStructT%%`)

        1. (Let (TableStructT id (member, typ'')*) be synthtyp)

        2. If ((typ''' has type synthtyp)), then

          1. (Let synthtyp' be (typ''' as synthtyp))

          2. If ((synthtyp' matches pattern `TableStructT%%`)), then

            1. (Let (TableStructT id' (member', typ''')*) be synthtyp')

            2. If ((id = id')), then

              1. If ((member = member'))*, then

                1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

                  1. The relation holds

                1. Else Phantom#115

              1. Else Phantom#116

            2. Else Phantom#117

          2. Else Phantom#118

        2. Else Phantom#119

    2. Else Phantom#120

2. If ((typ''' has type aliastyp)), then

  1. (Let (DefT _id typ''') be (typ''' as aliastyp))

  2. If ((Type_alpha: typ'' ~~ typ''' holds)), then

    1. The relation holds

  2. Else Phantom#121

2. Else Phantom#122

3. If ((typ'' = ((DefaultT) as typ))), then

  1. If ((typ''' = ((DefaultT) as typ))), then

    1. The relation holds

  1. Else Phantom#123

3. Else Phantom#124

4. If ((typ'' = ((InvalidT) as typ))), then

  1. If ((typ''' = ((InvalidT) as typ))), then

    1. The relation holds

  1. Else Phantom#125

4. Else Phantom#126

5. If ((typ'' = ((StateT) as typ))), then

  1. If ((typ''' = ((StateT) as typ))), then

    1. The relation holds

  1. Else Phantom#127

5. Else Phantom#128

6. If ((typ'' = ((AnyT) as typ))), then

  1. If ((typ''' = ((AnyT) as typ))), then

    1. The relation holds

  1. Else Phantom#129

6. Else Phantom#130

;; ../../../../spec/2c5-runtime-type-alpha.watsup:9.1-11.20
relation FuncType_alpha: functyp, functyp'

1. Case analysis on functyp

  1. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT pt_a* typ_r_a) be functyp)

    2. If ((functyp' matches pattern `BuiltinMethodT%%`)), then

      1. (Let (BuiltinMethodT pt_b* typ_r_b) be functyp')

      2. (Let (_id dir_a typ_a _exprIL?) be pt_a)*

      3. (Let (_id' dir_b typ_b _exprIL'?) be pt_b)*

      4. If ((dir_a = dir_b))*, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

          1. If ((Type_alpha: typ_r_a ~~ typ_r_b holds)), then

            1. The relation holds

          1. Else Phantom#131

        1. Else Phantom#132

      4. Else Phantom#133

    2. Else Phantom#134

  2. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT pt_a*) be functyp)

    2. If ((functyp' matches pattern `ActionT%`)), then

      1. (Let (ActionT pt_b*) be functyp')

      2. (Let (_id dir_a typ_a _exprIL?) be pt_a)*

      3. (Let (_id' dir_b typ_b _exprIL'?) be pt_b)*

      4. If ((dir_a = dir_b))*, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

          1. The relation holds

        1. Else Phantom#135

      4. Else Phantom#136

    2. Else Phantom#137

  3. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT pt_a*) be functyp)

    2. If ((functyp' matches pattern `ParserApplyMethodT%`)), then

      1. (Let (ParserApplyMethodT pt_b*) be functyp')

      2. (Let (_id dir_a typ_a _exprIL?) be pt_a)*

      3. (Let (_id' dir_b typ_b _exprIL'?) be pt_b)*

      4. If ((dir_a = dir_b))*, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

          1. The relation holds

        1. Else Phantom#138

      4. Else Phantom#139

    2. Else Phantom#140

  4. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT pt_a*) be functyp)

    2. If ((functyp' matches pattern `ControlApplyMethodT%`)), then

      1. (Let (ControlApplyMethodT pt_b*) be functyp')

      2. (Let (_id dir_a typ_a _exprIL?) be pt_a)*

      3. (Let (_id' dir_b typ_b _exprIL'?) be pt_b)*

      4. If ((dir_a = dir_b))*, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

          1. The relation holds

        1. Else Phantom#141

      4. Else Phantom#142

    2. Else Phantom#143

  5. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typ_a) be functyp)

    2. If ((functyp' matches pattern `TableApplyMethodT%`)), then

      1. (Let (TableApplyMethodT typ_b) be functyp')

      2. If ((Type_alpha: typ_a ~~ typ_b holds)), then

        1. The relation holds

      2. Else Phantom#144

    2. Else Phantom#145

  6. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT pt_a* typ_r_a) be functyp)

    2. If ((functyp' matches pattern `ExternFuncT%%`)), then

      1. (Let (ExternFuncT pt_b* typ_r_b) be functyp')

      2. (Let (_id dir_a typ_a _exprIL?) be pt_a)*

      3. (Let (_id' dir_b typ_b _exprIL'?) be pt_b)*

      4. If ((dir_a = dir_b))*, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

          1. If ((Type_alpha: typ_r_a ~~ typ_r_b holds)), then

            1. The relation holds

          1. Else Phantom#146

        1. Else Phantom#147

      4. Else Phantom#148

    2. Else Phantom#149

  7. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT pt_a* typ_r_a) be functyp)

    2. If ((functyp' matches pattern `FuncT%%`)), then

      1. (Let (FuncT pt_b* typ_r_b) be functyp')

      2. (Let (_id dir_a typ_a _exprIL?) be pt_a)*

      3. (Let (_id' dir_b typ_b _exprIL'?) be pt_b)*

      4. If ((dir_a = dir_b))*, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

          1. If ((Type_alpha: typ_r_a ~~ typ_r_b holds)), then

            1. The relation holds

          1. Else Phantom#150

        1. Else Phantom#151

      4. Else Phantom#152

    2. Else Phantom#153

  8. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT pt_a* typ_r_a) be functyp)

    2. If ((functyp' matches pattern `ExternMethodT%%`)), then

      1. (Let (ExternMethodT pt_b* typ_r_b) be functyp')

      2. (Let (_id dir_a typ_a _exprIL?) be pt_a)*

      3. (Let (_id' dir_b typ_b _exprIL'?) be pt_b)*

      4. If ((dir_a = dir_b))*, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

          1. If ((Type_alpha: typ_r_a ~~ typ_r_b holds)), then

            1. The relation holds

          1. Else Phantom#154

        1. Else Phantom#155

      4. Else Phantom#156

    2. Else Phantom#157

  9. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT pt_a* typ_r_a) be functyp)

    2. If ((functyp' matches pattern `ExternAbstractMethodT%%`)), then

      1. (Let (ExternAbstractMethodT pt_b* typ_r_b) be functyp')

      2. (Let (_id dir_a typ_a _exprIL?) be pt_a)*

      3. (Let (_id' dir_b typ_b _exprIL'?) be pt_b)*

      4. If ((dir_a = dir_b))*, then

        1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

          1. If ((Type_alpha: typ_r_a ~~ typ_r_b holds)), then

            1. The relation holds

          1. Else Phantom#158

        1. Else Phantom#159

      4. Else Phantom#160

    2. Else Phantom#161

;; ../../../../spec/2c5-runtime-type-alpha.watsup:13.1-15.20
relation FuncDef_alpha: funcdef, funcdef'

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft_a) be (funcdef as monofuncdef))

    2. If ((funcdef' has type monofuncdef)), then

      1. (Let (MonoFD ft_b) be (funcdef' as monofuncdef))

      2. If ((FuncType_alpha: ft_a ~~ ft_b holds)), then

        1. The relation holds

      2. Else Phantom#162

    2. Else Phantom#163

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD (tparam_a*, tparam_hidden_a*) -> ft_a) be (funcdef as polyfuncdef))

    2. If ((funcdef' has type polyfuncdef)), then

      1. (Let (PolyFD (tparam_b*, tparam_hidden_b*) -> ft_b) be (funcdef' as polyfuncdef))

      2. If ((|tparam_a*| = |tparam_b*|)), then

        1. If ((|tparam_hidden_a*| = |tparam_hidden_b*|)), then

          1. (Let tid_fresh* be $fresh_tids(|tparam_a* ++ tparam_hidden_a*|))

          2. (Let tparam_a'* be tparam_a* ++ tparam_hidden_a*)

          3. (Let ft_a' be $subst_functyp(({ (tparam_a' -> ((VarT tid_fresh) as typ))* }), ft_a))

          4. (Let tparam_b'* be tparam_b* ++ tparam_hidden_b*)

          5. (Let ft_b' be $subst_functyp(({ (tparam_b' -> ((VarT tid_fresh) as typ))* }), ft_b))

          6. If ((FuncType_alpha: ft_a' ~~ ft_b' holds)), then

            1. The relation holds

          6. Else Phantom#164

        1. Else Phantom#165

      2. Else Phantom#166

    2. Else Phantom#167

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:5.1-5.39
relation Type_wf: tidset, typ''''''

1. Case analysis on typ''''''

  1. Case (% has type basetyp)

    1. (Let basetyp be (typ'''''' as basetyp))

    2. The relation holds

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'''''' as abstyp))

    2. Case analysis on abstyp

      1. Case (% matches pattern `VarT%`)

        1. (Let (VarT tid) be abstyp)

        2. If ($in_set<tid>(tid, tidset)), then

          1. The relation holds

        2. Else Phantom#168

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT ptd typ_a*) be abstyp)

        2. (Let typ'''''' be $specialize_typdef((ptd as typdef), typ_a*))

        3. If ((Type_wf: tidset |- typ'''''' holds)), then

          1. The relation holds

        3. Else Phantom#169

  3. Case (% has type aliastyp)

    1. (Let (DefT _id typ'''''') be (typ'''''' as aliastyp))

    2. If ($nestable_deft(typ'''''')), then

      1. If ((Type_wf: tidset |- typ'''''' holds)), then

        1. The relation holds

      1. Else Phantom#170

    2. Else Phantom#171

  4. Case (% has type datatyp)

    1. (Let datatyp be (typ'''''' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ'''''') be datatyp)

        2. If ($nestable_newt(typ'''''')), then

          1. If ((Type_wf: tidset |- typ'''''' holds)), then

            1. The relation holds

          1. Else Phantom#172

        2. Else Phantom#173

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id member*) be datatyp)

        2. If ($distinct_<member>(member*)), then

          1. The relation holds

        2. Else Phantom#174

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ'''''' (member, val)*) be datatyp)

        2. If ($distinct_<member>(member*)), then

          1. If ($nestable_senumt(typ'''''')), then

            1. If ((Type_wf: tidset |- typ'''''' holds)), then

              1. The relation holds

            1. Else Phantom#175

          1. Else Phantom#176

        2. Else Phantom#177

      4. Case (% matches pattern `ListT%`)

        1. (Let (ListT typ'''''') be datatyp)

        2. If ($nestable_listt(typ'''''')), then

          1. If ((Type_wf: tidset |- typ'''''' holds)), then

            1. The relation holds

          1. Else Phantom#178

        2. Else Phantom#179

      5. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''''''*) be datatyp)

        2. If ($nestable_tuplet(typ''''''))*, then

          1. If ((Type_wf: tidset |- typ'''''' holds))*, then

            1. The relation holds

          1. Else Phantom#180

        2. Else Phantom#181

      6. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'''''' i_size) be datatyp)

        2. If ((i_size >= (0 as int))), then

          1. If ($nestable_stackt(typ'''''')), then

            1. If ((Type_wf: tidset |- typ'''''' holds)), then

              1. The relation holds

            1. Else Phantom#182

          1. Else Phantom#183

        2. Else Phantom#184

      7. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (member, typ'''''')*) be datatyp)

        2. If ($distinct_<member>(member*)), then

          1. If ($nestable_structt(typ''''''))*, then

            1. If ((Type_wf: tidset |- typ'''''' holds))*, then

              1. The relation holds

            1. Else Phantom#185

          1. Else Phantom#186

        2. Else Phantom#187

      8. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id (member, typ'''''')*) be datatyp)

        2. If ($distinct_<member>(member*)), then

          1. If ($nestable_headert(typ''''''))*, then

            1. If ((Type_wf: tidset |- typ'''''' holds))*, then

              1. The relation holds

            1. Else Phantom#188

          1. Else Phantom#189

        2. Else Phantom#190

      9. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id (member, typ'''''')*) be datatyp)

        2. If ($distinct_<member>(member*)), then

          1. If ($nestable_uniont(typ''''''))*, then

            1. If ((Type_wf: tidset |- typ'''''' holds))*, then

              1. The relation holds

            1. Else Phantom#191

          1. Else Phantom#192

        2. Else Phantom#193

  5. Case (% has type objtyp)

    1. (Let objtyp be (typ'''''' as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT _id fmap) be objtyp)

        2. (Let ({ (fid -> funcdef)* }) be fmap)

        3. If ((FuncDef_wf: tidset |- funcdef holds))*, then

          1. The relation holds

        3. Else Phantom#194

      2. Case (% matches pattern `ParserT%%`)

        1. (Let (ParserT _id pt*) be objtyp)

        2. If ((ParamTypes_wf: tidset |- pt* holds)), then

          1. The relation holds

        2. Else Phantom#195

      3. Case (% matches pattern `ControlT%%`)

        1. (Let (ControlT _id pt*) be objtyp)

        2. If ((ParamTypes_wf: tidset |- pt* holds)), then

          1. The relation holds

        2. Else Phantom#196

      4. Case (% matches pattern `PackageT%%`)

        1. (Let (PackageT _id typ''''''*) be objtyp)

        2. If ((Type_wf: tidset |- typ'''''' holds))*, then

          1. The relation holds

        2. Else Phantom#197

      5. Case (% matches pattern `TableT%%`)

        1. (Let (TableT _id typ'''''') be objtyp)

        2. (Let typ'''''' be $canon_typ(typ''''''))

        3. If ($is_table_structt(typ'''''')), then

          1. If ((Type_wf: tidset |- typ'''''' holds)), then

            1. The relation holds

          1. Else Phantom#198

        3. Else Phantom#199

  6. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'''''' as synthtyp))

    2. Case analysis on synthtyp

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typ''''''*) be synthtyp)

        2. If ((Type_wf: tidset |- typ'''''' holds))*, then

          1. The relation holds

        2. Else Phantom#200

      2. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typ''''''*) be synthtyp)

        2. If ((Type_wf: tidset |- typ'''''' holds))*, then

          1. The relation holds

        2. Else Phantom#201

      3. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (member, typ'''''')*) be synthtyp)

        2. If ($distinct_<member>(member*)), then

          1. If ((Type_wf: tidset |- typ'''''' holds))*, then

            1. The relation holds

          1. Else Phantom#202

        2. Else Phantom#203

      4. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (member, typ'''''')*) be synthtyp)

        2. If ($distinct_<member>(member*)), then

          1. If ((Type_wf: tidset |- typ'''''' holds))*, then

            1. The relation holds

          1. Else Phantom#204

        2. Else Phantom#205

      5. Case (% matches pattern `SetT%`)

        1. (Let (SetT typ'''''') be synthtyp)

        2. (Let typ'''''' be $canon_typ(typ''''''))

        3. If ($nestable_sett(typ'''''')), then

          1. If ((Type_wf: tidset |- typ'''''' holds)), then

            1. The relation holds

          1. Else Phantom#206

        3. Else Phantom#207

      6. Case (% matches pattern `TableEnumT%%`)

        1. (Let (TableEnumT _id member*) be synthtyp)

        2. If ($distinct_<member>(member*)), then

          1. The relation holds

        2. Else Phantom#208

      7. Case (% matches pattern `TableStructT%%`)

        1. (Let (TableStructT _id (member, typ'''''')*) be synthtyp)

        2. If ((member* = ["hit", "miss", "action_run"])), then

          1. (Let typ'''''* be typ''''''*)

          2. If ((typ'''''* matches pattern [ _/3 ])), then

            1. (Let [typ'''''', typ''', typ''''] be typ'''''*)

            2. If ((typ'''''' = ((BoolT) as typ))), then

              1. If ((typ''' = ((BoolT) as typ))), then

                1. If ((typ'''' has type synthtyp)), then

                  1. (Let synthtyp' be (typ'''' as synthtyp))

                  2. If ((synthtyp' matches pattern `TableEnumT%%`)), then

                    1. (Let (TableEnumT id_e member_e*) be synthtyp')

                    2. If ((Type_wf: tidset |- ((TableEnumT id_e member_e*) as typ) holds)), then

                      1. The relation holds

                    2. Else Phantom#209

                  2. Else Phantom#210

                1. Else Phantom#211

              1. Else Phantom#212

            2. Else Phantom#213

          2. Else Phantom#214

        2. Else Phantom#215

    2. Else Phantom#216

2. If ((typ'''''' = ((DefaultT) as typ))), then

  1. The relation holds

2. Else Phantom#217

3. If ((typ'''''' = ((InvalidT) as typ))), then

  1. The relation holds

3. Else Phantom#218

4. If ((typ'''''' = ((StateT) as typ))), then

  1. The relation holds

4. Else Phantom#219

5. If ((typ'''''' = ((AnyT) as typ))), then

  1. The relation holds

5. Else Phantom#220

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:6.1-6.42
relation TypeDef_wf: tidset, typdef

1. Case analysis on typdef

  1. Case (% has type monotypdef)

    1. (Let (MonoD typ) be (typdef as monotypdef))

    2. If ($nestable_monod(typ)), then

      1. If ((Type_wf: tidset |- typ holds)), then

        1. The relation holds

      1. Else Phantom#221

    2. Else Phantom#222

  2. Case (% has type polytypdef)

    1. (Let (PolyD (tparam*, tparam_hidden*) -> typ) be (typdef as polytypdef))

    2. If ($nestable_polyd(typ)), then

      1. If ($distinct_<tid>(tparam* ++ tparam_hidden*)), then

        1. (Let tidset' be $union_set<tid>(tidset, ({ tparam* ++ tparam_hidden* })))

        2. If ((Type_wf: tidset' |- typ holds)), then

          1. The relation holds

        2. Else Phantom#223

      1. Else Phantom#224

    2. Else Phantom#225

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:8.1-8.44
relation ParamType_wf: tidset, (_id dir typ exprIL''?)

1. Case analysis on exprIL''?

  1. Case (% matches pattern ())

    1. If ((Type_wf: tidset |- typ holds)), then

      1. If (($is_externt($canon_typ(typ)) => (dir = (NO)))), then

        1. The relation holds

      1. Else Phantom#226

    1. Else Phantom#227

  2. Case (% matches pattern (_))

    1. (Let ?(exprIL'') be exprIL''?)

    2. If ((Type_wf: tidset |- typ holds)), then

      1. If (($is_externt($canon_typ(typ)) => (dir = (NO)))), then

        1. If (((dir = (IN)) \/ (dir = (NO)))), then

          1. The relation holds

        1. Else Phantom#228

      1. Else Phantom#229

    2. Else Phantom#230

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:9.1-9.45
relation ParamTypes_wf: tidset, pt*

1. (Let (id _dir _typ _exprIL?) be pt)*

2. If ($distinct_<id>(id*)), then

  1. If ((ParamType_wf: tidset |- pt holds))*, then

    1. The relation holds

  1. Else Phantom#231

2. Else Phantom#232

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:11.1-11.43
relation FuncType_wf: tidset, functyp

1. Case analysis on functyp

  1. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT pt* typ_r) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt* holds)), then

      1. If ((Type_wf: tidset |- typ_r holds)), then

        1. The relation holds

      1. Else Phantom#233

    2. Else Phantom#234

  2. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT pt*) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt* holds)), then

      1. (Let (id dir typ exprIL?) be pt)*

      2. If ($is_trailing_action(dir*)), then

        1. (Let typ' be $canon_typ(typ))*

        2. If (((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~$is_intt(typ')) /\ ~$is_obj(typ')) /\ (~$is_strt(typ') \/ (dir = (NO)))))*, then

          1. The relation holds

        2. Else Phantom#235

      2. Else Phantom#236

    2. Else Phantom#237

  3. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT pt*) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt* holds)), then

      1. (Let (id dir typ exprIL?) be pt)*

      2. (Let typ' be $canon_typ(typ))*

      3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*, then

        1. The relation holds

      3. Else Phantom#238

    2. Else Phantom#239

  4. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT pt*) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt* holds)), then

      1. (Let (id dir typ exprIL?) be pt)*

      2. (Let typ' be $canon_typ(typ))*

      3. The relation holds

    2. Else Phantom#240

  5. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typ) be functyp)

    2. If ((typ has type synthtyp)), then

      1. (Let synthtyp be (typ as synthtyp))

      2. If ((synthtyp matches pattern `TableStructT%%`)), then

        1. (Let (TableStructT _id _(member, typ)*) be synthtyp)

        2. The relation holds

      2. Else Phantom#241

    2. Else Phantom#242

  6. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT pt* typ_r) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt* holds)), then

      1. (Let (id dir typ exprIL?) be pt)*

      2. (Let typ' be $canon_typ(typ))*

      3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*, then

        1. If ((Type_wf: tidset |- typ_r holds)), then

          1. The relation holds

        1. Else Phantom#243

      3. Else Phantom#244

    2. Else Phantom#245

  7. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT pt* typ_r) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt* holds)), then

      1. (Let (id dir typ exprIL?) be pt)*

      2. (Let typ' be $canon_typ(typ))*

      3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~$is_obj(typ')) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*, then

        1. If ((Type_wf: tidset |- typ_r holds)), then

          1. The relation holds

        1. Else Phantom#246

      3. Else Phantom#247

    2. Else Phantom#248

  8. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT pt* typ_r) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt* holds)), then

      1. (Let (id dir typ exprIL?) be pt)*

      2. (Let typ' be $canon_typ(typ))*

      3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*, then

        1. If ((Type_wf: tidset |- typ_r holds)), then

          1. The relation holds

        1. Else Phantom#249

      3. Else Phantom#250

    2. Else Phantom#251

  9. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT pt* typ_r) be functyp)

    2. If ((ParamTypes_wf: tidset |- pt* holds)), then

      1. (Let (id dir typ exprIL?) be pt)*

      2. (Let typ' be $canon_typ(typ))*

      3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*, then

        1. If ((Type_wf: tidset |- typ_r holds)), then

          1. The relation holds

        1. Else Phantom#252

      3. Else Phantom#253

    2. Else Phantom#254

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:12.1-12.43
relation FuncDef_wf: tidset, funcdef

1. Case analysis on funcdef

  1. Case (% has type monofuncdef)

    1. (Let (MonoFD ft) be (funcdef as monofuncdef))

    2. If ((((($is_builtinmethodt(ft) \/ $is_actiont(ft)) \/ $is_parserapplymethodt(ft)) \/ $is_controlapplymethodt(ft)) \/ $is_tableapplymethodt(ft))), then

      1. If ((FuncType_wf: tidset |- ft holds)), then

        1. The relation holds

      1. Else Phantom#255

    2. Else Phantom#256

  2. Case (% has type polyfuncdef)

    1. (Let (PolyFD (tparam*, tparam_hidden*) -> ft) be (funcdef as polyfuncdef))

    2. If (((($is_externfunct(ft) \/ $is_funct(ft)) \/ $is_externmethodt(ft)) \/ $is_externabstractmethodt(ft))), then

      1. If ($distinct_<tid>(tparam* ++ tparam_hidden*)), then

        1. (Let tidset' be $union_set<tid>(tidset, ({ tparam* ++ tparam_hidden* })))

        2. If ((FuncType_wf: tidset' |- ft holds)), then

          1. The relation holds

        2. Else Phantom#257

      1. Else Phantom#258

    2. Else Phantom#259

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:14.52-14.60
syntax consctxt = 
   | `CONSCTXT`()

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:15.1-15.53
relation CParamType_wf: tidset, consctxt, (id dir typ exprIL?)

1. If ((dir matches pattern `NO`)), then

  1. If ((Type_wf: tidset |- typ holds)), then

    1. The relation holds

  1. Else Phantom#260

1. Else Phantom#261

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:16.1-16.54
relation CParamTypes_wf: tidset, consctxt, pt*

1. (Let (id _dir _typ _exprIL?) be pt)*

2. If ($distinct_<id>(id*)), then

  1. If ((CParamType_wf: tidset consctxt |- pt holds))*, then

    1. The relation holds

  1. Else Phantom#262

2. Else Phantom#263

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:18.1-18.43
relation ConsType_wf: tidset, (ConsT pt* typ)

1. If ((CParamTypes_wf: tidset (CONSCTXT) |- pt* holds)), then

  1. If ((Type_wf: tidset |- typ holds)), then

    1. (Let typ'' be $canon_typ(typ))

    2. If ((typ'' has type objtyp)), then

      1. (Let objtyp be (typ'' as objtyp))

      2. Case analysis on objtyp

        1. Case (% matches pattern `ExternT%%`)

          1. (Let (ExternT id fmap) be objtyp)

          2. (Let (_id _dir typ_p _exprIL?) be pt)*

          3. (Let typ' be $canon_typ(typ_p))*

          4. If (((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))))*, then

            1. The relation holds

          4. Else Phantom#264

        2. Case (% matches pattern `ParserT%%`)

          1. (Let (ParserT _id _paramtyp*) be objtyp)

          2. (Let (_id' _dir typ_p exprIL?) be pt)*

          3. (Let typ_p' be $canon_typ(typ_p))*

          4. If (((((~$is_deft(typ_p') /\ ~$is_spect(typ_p')) /\ ~$is_controlt(typ_p')) /\ ~$is_packaget(typ_p')) /\ ~$is_tablet(typ_p')))*, then

            1. The relation holds

          4. Else Phantom#265

        3. Case (% matches pattern `ControlT%%`)

          1. (Let (ControlT _id _paramtyp*) be objtyp)

          2. (Let (_id' _dir typ_p exprIL?) be pt)*

          3. (Let typ_p' be $canon_typ(typ_p))*

          4. If (((((~$is_deft(typ_p') /\ ~$is_spect(typ_p')) /\ ~$is_parsert(typ_p')) /\ ~$is_packaget(typ_p')) /\ ~$is_tablet(typ_p')))*, then

            1. The relation holds

          4. Else Phantom#266

        4. Case (% matches pattern `PackageT%%`)

          1. (Let (PackageT _id _typ*) be objtyp)

          2. (Let (_id' _dir typ_p exprIL?) be pt)*

          3. (Let typ_p' be $canon_typ(typ_p))*

          4. If (((~$is_deft(typ_p') /\ ~$is_spect(typ_p')) /\ ~$is_tablet(typ_p')))*, then

            1. The relation holds

          4. Else Phantom#267

      2. Else Phantom#268

    2. Else Phantom#269

  1. Else Phantom#270

1. Else Phantom#271

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:19.1-19.43
relation ConsDef_wf: tidset, (ConsD (tparam*, tparam_hidden*) -> constyp)

1. (Let (ConsT _paramtyp* typ_r) be constyp)

2. (Let typ_r' be $canon_typ(typ_r))

3. If ($is_externt(typ_r')), then

  1. If ($distinct_<tid>(tparam* ++ tparam_hidden*)), then

    1. (Let tidset' be $union_set<tid>(tidset, ({ tparam* ++ tparam_hidden* })))

    2. If ((ConsType_wf: tidset' |- constyp holds)), then

      1. The relation holds

    2. Else Phantom#272

  1. Else Phantom#273

3. Else Phantom#274

4. If ($is_parsert(typ_r')), then

  1. If ($distinct_<tid>(tparam* ++ tparam_hidden*)), then

    1. (Let tidset' be $union_set<tid>(tidset, ({ tparam* ++ tparam_hidden* })))

    2. If ((ConsType_wf: tidset' |- constyp holds)), then

      1. The relation holds

    2. Else Phantom#275

  1. Else Phantom#276

4. Else Phantom#277

5. If ($is_controlt(typ_r')), then

  1. If ($distinct_<tid>(tparam* ++ tparam_hidden*)), then

    1. (Let tidset' be $union_set<tid>(tidset, ({ tparam* ++ tparam_hidden* })))

    2. If ((ConsType_wf: tidset' |- constyp holds)), then

      1. The relation holds

    2. Else Phantom#278

  1. Else Phantom#279

5. Else Phantom#280

6. If ($is_packaget(typ_r')), then

  1. If ($distinct_<tid>(tparam* ++ tparam_hidden*)), then

    1. (Let tidset' be $union_set<tid>(tidset, ({ tparam* ++ tparam_hidden* })))

    2. If ((ConsType_wf: tidset' |- constyp holds)), then

      1. The relation holds

    2. Else Phantom#281

  1. Else Phantom#282

6. Else Phantom#283

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:37.1-37.31
def $nestable_deft(typ)

1. Return $nestable'_deft($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:38.1-38.32
def $nestable'_deft(typ)

1. Case analysis on typ

  1. Case (% has type basetyp)

    1. (Let basetyp be (typ as basetyp))

    2. Return (~$is_voidt((basetyp as typ)) /\ ~$is_matchkindt((basetyp as typ)))

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:52.1-52.31
def $nestable_newt(typ)

1. Return $nestable'_newt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:53.1-53.32
def $nestable'_newt(typ)

1. If ((typ = ((BoolT) as typ))), then

  1. Return true

2. Case analysis on typ

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id _typ) be datatyp)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:73.1-73.33
def $nestable_senumt(typ)

1. Return $nestable'_senumt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:74.1-74.34
def $nestable'_senumt(typ'')

1. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id typ'') be datatyp)

      2. Return $nestable_newt_in_senumt(typ'')

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:75.1-75.41
def $nestable_newt_in_senumt(typ)

1. Return $nestable_newt_in_senumt'($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:76.1-76.42
def $nestable_newt_in_senumt'(typ)

1. Case analysis on typ

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id _typ) be datatyp)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:100.1-100.32
def $nestable_listt(typ)

1. Return $nestable'_listt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:101.1-101.33
def $nestable'_listt(typ)

1. Case analysis on typ

  1. Case (% has type basetyp)

    1. (Let basetyp be (typ as basetyp))

    2. Return ~$is_voidt((basetyp as typ))

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:114.1-114.33
def $nestable_tuplet(typ)

1. Return $nestable'_tuplet($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:115.1-115.34
def $nestable'_tuplet(typ)

1. If ((typ = ((ErrT) as typ))), then

  1. Return true

2. If ((typ = ((BoolT) as typ))), then

  1. Return true

3. Case analysis on typ

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ as numtyp))

    2. Return ~$is_intt((numtyp as typ))

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Return ~$is_listt((datatyp as typ))

4. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:131.1-131.33
def $nestable_stackt(typ)

1. Return $nestable'_stackt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:132.1-132.34
def $nestable'_stackt(typ)

1. Case analysis on typ

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT tid) be abstyp)

      2. Return true

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id _(member, typ)*) be datatyp)

        2. Return true

      2. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id _(member, typ)*) be datatyp)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:147.1-147.34
def $nestable_structt(typ)

1. Return $nestable'_structt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:148.1-148.35
def $nestable'_structt(typ)

1. If ((typ = ((ErrT) as typ))), then

  1. Return true

2. If ((typ = ((BoolT) as typ))), then

  1. Return true

3. Case analysis on typ

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ as numtyp))

    2. Return ~$is_intt((numtyp as typ))

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Return ~$is_listt((datatyp as typ))

4. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:165.1-165.34
def $nestable_headert(typ)

1. Return $nestable'_headert($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:166.1-166.35
def $nestable'_headert(typ'')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return true

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Return ~$is_intt((numtyp as typ))

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*) be datatyp)

        2. Return true

      3. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (_member, typ'')*) be datatyp)

        2. If ($nestable_structt_in_headert(typ''))*, then

          1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:167.1-167.45
def $nestable_structt_in_headert(typ)

1. Return $nestable'_structt_in_headert($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:168.1-168.46
def $nestable'_structt_in_headert(typ'')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return true

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*) be datatyp)

        2. Return true

      3. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (_member, typ'')*) be datatyp)

        2. If ($nestable_structt_in_headert(typ''))*, then

          1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:199.1-199.33
def $nestable_uniont(typ)

1. Return $nestable'_uniont($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:200.1-200.34
def $nestable'_uniont(typ)

1. Case analysis on typ

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id _(member, typ)*) be datatyp)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:262.1-262.31
def $nestable_sett(typ)

1. Return $nestable'_sett($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:263.1-263.32
def $nestable'_sett(typ'')

1. If ((typ'' = ((ErrT) as typ))), then

  1. Return true

2. If ((typ'' = ((BoolT) as typ))), then

  1. Return true

3. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*) be datatyp)

        2. Return true

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*) be datatyp)

        2. Return true

      4. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*) be datatyp)

        2. If ($nestable_tuplet_in_sett(typ''))*, then

          1. Return true

  4. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. If ((synthtyp matches pattern `SeqT%`)), then

      1. (Let (SeqT typ''*) be synthtyp)

      2. If ($nestable_seqt_in_sett(typ''))*, then

        1. Return true

4. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:264.1-264.41
def $nestable_tuplet_in_sett(typ)

1. Return $nestable'_tuplet_in_sett($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:265.1-265.42
def $nestable'_tuplet_in_sett(typ'')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return true

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*) be datatyp)

        2. Return true

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*) be datatyp)

        2. Return true

      4. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*) be datatyp)

        2. If ($nestable_tuplet_in_sett(typ''))*, then

          1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:266.1-266.39
def $nestable_seqt_in_sett(typ)

1. Return $nestable'_seqt_in_sett($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:267.1-267.40
def $nestable'_seqt_in_sett(typ'')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return true

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

  2. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*) be datatyp)

        2. Return true

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*) be datatyp)

        2. Return true

      4. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*) be datatyp)

        2. If ($nestable_seqt_in_sett(typ''))*, then

          1. Return true

  4. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. If ((synthtyp matches pattern `SeqT%`)), then

      1. (Let (SeqT typ''*) be synthtyp)

      2. If ($nestable_seqt_in_sett(typ''))*, then

        1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:339.1-339.32
def $nestable_monod(typ)

1. Case analysis on typ

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ as abstyp))

    2. If ((abstyp matches pattern `VarT%`)), then

      1. (Let (VarT _id) be abstyp)

      2. Return true

  2. Case (% has type aliastyp)

    1. (Let (DefT _id _typ) be (typ as aliastyp))

    2. Return true

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id _typ) be datatyp)

        2. Return true

      2. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _id _member*) be datatyp)

        2. Return true

      3. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id _typ _(member, val)*) be datatyp)

        2. Return true

  4. Case (% has type objtyp)

    1. (Let objtyp be (typ as objtyp))

    2. If ((objtyp matches pattern `TableT%%`)), then

      1. (Let (TableT _id _typ) be objtyp)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:355.1-355.32
def $nestable_polyd(typ)

1. Case analysis on typ

  1. Case (% has type datatyp)

    1. (Let datatyp be (typ as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT _typ*) be datatyp)

        2. Return true

      2. Case (% matches pattern `StackT%%`)

        1. (Let (StackT _typ _int) be datatyp)

        2. Return true

      3. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id _(member, typ)*) be datatyp)

        2. Return true

      4. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id _(member, typ)*) be datatyp)

        2. Return true

      5. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id _(member, typ)*) be datatyp)

        2. Return true

  2. Case (% has type objtyp)

    1. (Let objtyp be (typ as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT _id _map<fid, funcdef>) be objtyp)

        2. Return true

      2. Case (% matches pattern `ParserT%%`)

        1. (Let (ParserT _id _paramtyp*) be objtyp)

        2. Return true

      3. Case (% matches pattern `ControlT%%`)

        1. (Let (ControlT _id _paramtyp*) be objtyp)

        2. Return true

      4. Case (% matches pattern `PackageT%%`)

        1. (Let (PackageT _id _typ*) be objtyp)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:406.1-407.38
def $is_trailing_action(dir*)

1. Return $is_trailing_action'(true, $rev_<dir>(dir*))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:408.1-408.44
def $is_trailing_action'(_bool', dir''*)

1. Case analysis on dir''*

  1. Case (% matches pattern [])

    1. Return true

  2. Case (% matches pattern _ :: _)

    1. (Let dir_h :: dir_t* be dir''*)

    2. If (~(dir_h matches pattern `NO`)), then

      1. Return $is_trailing_action'(false, dir_t*)

    2. Else Phantom#284

2. Case analysis on _bool'

  1. Case (% = true)

    1. If ((dir''* matches pattern _ :: _)), then

      1. (Let dir'' :: dir_t* be dir''*)

      2. If ((dir'' matches pattern `NO`)), then

        1. Return $is_trailing_action'(true, dir_t*)

      2. Else Phantom#285

    1. Else Phantom#286

  2. Case (% = false)

    1. If ((dir''* matches pattern _ :: _)), then

      1. (Let dir'' :: dir_t* be dir''*)

      2. If ((dir'' matches pattern `NO`)), then

        1. Return false

      2. Else Phantom#287

    1. Else Phantom#288

2. Else Phantom#289

;; ../../../../spec/2d1-runtime-numerics.watsup:5.1-5.21
def $pow2



;; ../../../../spec/2d1-runtime-numerics.watsup:7.1-7.25
def $shl



;; ../../../../spec/2d1-runtime-numerics.watsup:8.1-8.25
def $shr



;; ../../../../spec/2d1-runtime-numerics.watsup:9.1-9.36
def $shr_arith



;; ../../../../spec/2d1-runtime-numerics.watsup:11.1-11.21
def $bneg



;; ../../../../spec/2d1-runtime-numerics.watsup:12.1-12.26
def $band



;; ../../../../spec/2d1-runtime-numerics.watsup:13.1-13.26
def $bxor



;; ../../../../spec/2d1-runtime-numerics.watsup:14.1-14.25
def $bor



;; ../../../../spec/2d1-runtime-numerics.watsup:16.1-16.33
def $bitacc



;; ../../../../spec/2d1-runtime-numerics.watsup:22.1-23.32
def $un_op(unop, val)

1. Case analysis on unop

  1. Case (% matches pattern `BNOT`)

    1. Return $un_bnot(val)

  2. Case (% matches pattern `LNOT`)

    1. Return $un_lnot(val)

  3. Case (% matches pattern `UPLUS`)

    1. Return $un_plus(val)

  4. Case (% matches pattern `UMINUS`)

    1. Return $un_minus(val)

;; ../../../../spec/2d1-runtime-numerics.watsup:27.1-27.24
def $un_bnot(val)

1. If ((val matches pattern `FBitV%%`)), then

  1. (Let (FBitV w bs) be val)

  2. (Let i be $bneg(bs))

  3. Return (FBitV w $to_bitstr((w as int), $bneg(bs)))

1. Else Phantom#290

;; ../../../../spec/2d1-runtime-numerics.watsup:36.1-36.24
def $un_lnot(val)

1. If ((val matches pattern `BoolV%`)), then

  1. (Let (BoolV b) be val)

  2. Return (BoolV ~b)

1. Else Phantom#291

;; ../../../../spec/2d1-runtime-numerics.watsup:44.1-44.24
def $un_plus(val)

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i) be val)

    2. Return (IntV i)

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs) be val)

    2. Return (FIntV w bs)

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs) be val)

    2. Return (FBitV w bs)

1. Else Phantom#292

;; ../../../../spec/2d1-runtime-numerics.watsup:54.1-54.25
def $un_minus(val)

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i) be val)

    2. Return (IntV -i)

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs) be val)

    2. (Let bs' be $to_bitstr((w as int), $to_int((w as int), -bs)))

    3. Return (FIntV w bs')

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs) be val)

    2. (Let bs' be ($pow2(w) - bs))

    3. Return (FBitV w bs')

1. Else Phantom#293

;; ../../../../spec/2d1-runtime-numerics.watsup:70.1-71.24
def $bin_op(binop, val_l, val_r)

1. Case analysis on binop

  1. Case (% matches pattern `PLUS`)

    1. Return $bin_plus(val_l, val_r)

  2. Case (% matches pattern `MINUS`)

    1. Return $bin_minus(val_l, val_r)

  3. Case (% matches pattern `MUL`)

    1. Return $bin_mul(val_l, val_r)

  4. Case (% matches pattern `DIV`)

    1. Return $bin_div(val_l, val_r)

  5. Case (% matches pattern `MOD`)

    1. Return $bin_mod(val_l, val_r)

  6. Case (% matches pattern `SHL`)

    1. Return $bin_shl(val_l, val_r)

  7. Case (% matches pattern `SHR`)

    1. Return $bin_shr(val_l, val_r)

  8. Case (% matches pattern `LE`)

    1. Return (BoolV $bin_le(val_l, val_r))

  9. Case (% matches pattern `GE`)

    1. Return (BoolV $bin_ge(val_l, val_r))

  10. Case (% matches pattern `LT`)

    1. Return (BoolV $bin_lt(val_l, val_r))

  11. Case (% matches pattern `GT`)

    1. Return (BoolV $bin_gt(val_l, val_r))

  12. Case (% matches pattern `EQ`)

    1. Return (BoolV $bin_eq(val_l, val_r))

  13. Case (% matches pattern `NE`)

    1. Return (BoolV ~$bin_eq(val_l, val_r))

  14. Case (% matches pattern `BAND`)

    1. Return $bin_band(val_l, val_r)

  15. Case (% matches pattern `BXOR`)

    1. Return $bin_bxor(val_l, val_r)

  16. Case (% matches pattern `BOR`)

    1. Return $bin_bor(val_l, val_r)

  17. Case (% matches pattern `CONCAT`)

    1. Return $bin_concat(val_l, val_r)

  18. Case (% matches pattern `LAND`)

    1. Return $bin_land(val_l, val_r)

  19. Case (% matches pattern `LOR`)

    1. Return $bin_lor(val_l, val_r)

1. Else Phantom#294

;; ../../../../spec/2d1-runtime-numerics.watsup:75.1-75.30
def $bin_plus(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (IntV (i_l + i_r))

    2. Else Phantom#295

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let bs be $to_bitstr((w as int), (i_l + i_r)))

        4. Return (FIntV w bs)

      2. Else Phantom#296

    2. Else Phantom#297

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let bs be $to_bitstr((w as int), (i_l + i_r)))

        4. Return (FBitV w bs)

      2. Else Phantom#298

    2. Else Phantom#299

1. Else Phantom#300

;; ../../../../spec/2d1-runtime-numerics.watsup:93.1-93.31
def $bin_minus(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (IntV (i_l - i_r))

    2. Else Phantom#301

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let bs be $to_bitstr((w as int), (i_l - i_r)))

        4. Return (FIntV w bs)

      2. Else Phantom#302

    2. Else Phantom#303

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let bs be $to_bitstr((w as int), (i_l - i_r)))

        4. Return (FBitV w bs)

      2. Else Phantom#304

    2. Else Phantom#305

1. Else Phantom#306

;; ../../../../spec/2d1-runtime-numerics.watsup:111.1-111.29
def $bin_mul(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (IntV (i_l * i_r))

    2. Else Phantom#307

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let bs be $to_bitstr((w as int), (i_l * i_r)))

        4. Return (FIntV w bs)

      2. Else Phantom#308

    2. Else Phantom#309

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let bs be $to_bitstr((w as int), (i_l * i_r)))

        4. Return (FBitV w bs)

      2. Else Phantom#310

    2. Else Phantom#311

1. Else Phantom#312

;; ../../../../spec/2d1-runtime-numerics.watsup:127.1-127.29
def $bin_div(val, val')

1. If ((val matches pattern `IntV%`)), then

  1. (Let (IntV i_l) be val)

  2. If ((val' matches pattern `IntV%`)), then

    1. (Let (IntV i_r) be val')

    2. Return (IntV (i_l / i_r))

  2. Else Phantom#313

1. Else Phantom#314

;; ../../../../spec/2d1-runtime-numerics.watsup:135.1-135.29
def $bin_mod(val, val')

1. If ((val matches pattern `IntV%`)), then

  1. (Let (IntV i_l) be val)

  2. If ((val' matches pattern `IntV%`)), then

    1. (Let (IntV i_r) be val')

    2. Return (IntV (i_l \ i_r))

  2. Else Phantom#315

1. Else Phantom#316

;; ../../../../spec/2d1-runtime-numerics.watsup:143.1-143.29
def $bin_shl(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_r) be val')

        2. Return (IntV $shl(i_l, i_r))

      2. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_r be $to_int((w_r as int), bs_r))

        3. Return (IntV $shl(i_l, i_r))

      3. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. Return (IntV $shl(i_l, bs_r))

    2. Else Phantom#317

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w_l bs_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_r) be val')

        2. (Let val_r be (FIntV w_l $to_int((w_l as int), i_r)))

        3. Return $bin_shl((FIntV w_l bs_l), val_r)

      2. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. (Let i_r be $to_int((w_r as int), bs_r))

        4. (Let i be $shl(i_l, i_r))

        5. Return (FIntV w_l $to_bitstr((w_l as int), i))

      3. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. (Let i be $shl(i_l, bs_r))

        4. Return (FIntV w_l $to_bitstr((w_l as int), i))

    2. Else Phantom#318

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w_l bs_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_r) be val')

        2. (Let val_r be (FBitV w_l $to_int((w_l as int), i_r)))

        3. Return $bin_shl((FBitV w_l bs_l), val_r)

      2. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_r be $to_int((w_r as int), bs_r))

        3. (Let i be $shl(bs_l, i_r))

        4. Return (FBitV w_l $to_bitstr((w_l as int), i))

      3. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. (Let i be $shl(bs_l, bs_r))

        3. Return (FBitV w_l $to_bitstr((w_l as int), i))

    2. Else Phantom#319

1. Else Phantom#320

;; ../../../../spec/2d1-runtime-numerics.watsup:176.1-176.29
def $bin_shr(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_r) be val')

        2. Return (IntV $shr(i_l, i_r))

      2. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_r be $to_int((w_r as int), bs_r))

        3. Return (IntV $shr(i_l, i_r))

      3. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. Return (IntV $shr(i_l, bs_r))

    2. Else Phantom#321

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w_l bs_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. If ((i_l < (0 as int))), then

          1. (Let i be $shr_arith(bs_l, i_r, ($pow2(w_l) - (1 as int))))

          2. Return (FIntV w_l $to_bitstr((w_l as int), i))

        3. Else Phantom#322

        4. If ((i_l >= (0 as int))), then

          1. (Let i be $shr(bs_l, i_r))

          2. Return (FIntV w_l $to_bitstr((w_l as int), i))

        4. Else Phantom#323

      2. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. (Let i_r be $to_int((w_r as int), bs_r))

        4. If ((i_l < (0 as int))), then

          1. (Let i be $shr_arith(bs_l, i_r, ($pow2(w_l) - (1 as int))))

          2. Return (FIntV w_l $to_bitstr((w_l as int), i))

        4. Else Phantom#324

        5. If ((i_l >= (0 as int))), then

          1. (Let i be $shr(bs_l, i_r))

          2. Return (FIntV w_l $to_bitstr((w_l as int), i))

        5. Else Phantom#325

      3. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. If ((i_l < (0 as int))), then

          1. (Let i be $shr_arith(bs_l, bs_r, ($pow2(w_l) - (1 as int))))

          2. Return (FIntV w_l $to_bitstr((w_l as int), i))

        3. Else Phantom#326

        4. If ((i_l >= (0 as int))), then

          1. (Let i be $shr(bs_l, bs_r))

          2. Return (FIntV w_l $to_bitstr((w_l as int), i))

        4. Else Phantom#327

    2. Else Phantom#328

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w_l bs_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_r) be val')

        2. (Let val_r be (FBitV w_l $to_int((w_l as int), i_r)))

        3. Return $bin_shr((FBitV w_l bs_l), val_r)

      2. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_r be $to_int((w_r as int), bs_r))

        3. (Let i be $shr(bs_l, i_r))

        4. Return (FBitV w_l $to_bitstr((w_l as int), i))

      3. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. (Let i be $shr(bs_l, bs_r))

        3. Return (FBitV w_l $to_bitstr((w_l as int), i))

    2. Else Phantom#329

1. Else Phantom#330

;; ../../../../spec/2d1-runtime-numerics.watsup:229.1-229.29
def $bin_le(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (i_l <= i_r)

    2. Else Phantom#331

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. Return (i_l <= i_r)

      2. Else Phantom#332

    2. Else Phantom#333

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. Return (bs_l <= bs_r)

      2. Else Phantom#334

    2. Else Phantom#335

1. Else Phantom#336

;; ../../../../spec/2d1-runtime-numerics.watsup:241.1-241.29
def $bin_ge(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (i_l >= i_r)

    2. Else Phantom#337

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. Return (i_l >= i_r)

      2. Else Phantom#338

    2. Else Phantom#339

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. Return (bs_l >= bs_r)

      2. Else Phantom#340

    2. Else Phantom#341

1. Else Phantom#342

;; ../../../../spec/2d1-runtime-numerics.watsup:253.1-253.29
def $bin_lt(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (i_l < i_r)

    2. Else Phantom#343

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. Return (i_l < i_r)

      2. Else Phantom#344

    2. Else Phantom#345

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. Return (bs_l < bs_r)

      2. Else Phantom#346

    2. Else Phantom#347

1. Else Phantom#348

;; ../../../../spec/2d1-runtime-numerics.watsup:265.1-265.29
def $bin_gt(val, val')

1. Case analysis on val

  1. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_l) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_r) be val')

      2. Return (i_l > i_r)

    2. Else Phantom#349

  2. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. Return (i_l > i_r)

      2. Else Phantom#350

    2. Else Phantom#351

  3. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. Return (bs_l > bs_r)

      2. Else Phantom#352

    2. Else Phantom#353

1. Else Phantom#354

;; ../../../../spec/2d1-runtime-numerics.watsup:277.1-277.29
def $bin_eq(val, val')

1. Case analysis on val

  1. Case (% matches pattern `ErrV%`)

    1. (Let (ErrV member_a) be val)

    2. If ((val' matches pattern `ErrV%`)), then

      1. (Let (ErrV member_b) be val')

      2. Return (member_a = member_b)

    2. Else Phantom#355

  2. Case (% matches pattern `MatchKindV%`)

    1. (Let (MatchKindV member_a) be val)

    2. If ((val' matches pattern `MatchKindV%`)), then

      1. (Let (MatchKindV member_b) be val')

      2. Return (member_a = member_b)

    2. Else Phantom#356

  3. Case (% matches pattern `StrV%`)

    1. (Let (StrV text_a) be val)

    2. If ((val' matches pattern `StrV%`)), then

      1. (Let (StrV text_b) be val')

      2. Return (text_a = text_b)

    2. Else Phantom#357

  4. Case (% matches pattern `BoolV%`)

    1. (Let (BoolV b_a) be val)

    2. If ((val' matches pattern `BoolV%`)), then

      1. (Let (BoolV b_b) be val')

      2. Return (b_a = b_b)

    2. Else Phantom#358

  5. Case (% matches pattern `IntV%`)

    1. (Let (IntV i_a) be val)

    2. If ((val' matches pattern `IntV%`)), then

      1. (Let (IntV i_b) be val')

      2. Return (i_a = i_b)

    2. Else Phantom#359

  6. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_a) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_b) be val')

      2. If ((w = w')), then

        1. Return (bs_a = bs_b)

      2. Else Phantom#360

    2. Else Phantom#361

  7. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_a) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_b) be val')

      2. If ((w = w')), then

        1. Return (bs_a = bs_b)

      2. Else Phantom#362

    2. Else Phantom#363

  8. Case (% matches pattern `VBitV%%%`)

    1. (Let (VBitV w _width bs_a) be val)

    2. If ((val' matches pattern `VBitV%%%`)), then

      1. (Let (VBitV w' _width' bs_b) be val')

      2. If ((w = w')), then

        1. Return (bs_a = bs_b)

      2. Else Phantom#364

    2. Else Phantom#365

  9. Case (% matches pattern `EnumFieldV%%`)

    1. (Let (EnumFieldV id_a member_a) be val)

    2. If ((val' matches pattern `EnumFieldV%%`)), then

      1. (Let (EnumFieldV id_b member_b) be val')

      2. Return ((id_a = id_b) /\ (member_a = member_b))

    2. Else Phantom#366

  10. Case (% matches pattern `SEnumFieldV%%%`)

    1. (Let (SEnumFieldV id_a member_a val_a) be val)

    2. If ((val' matches pattern `SEnumFieldV%%%`)), then

      1. (Let (SEnumFieldV id_b member_b val_b) be val')

      2. Return (((id_a = id_b) /\ (member_a = member_b)) /\ $bin_eq(val_a, val_b))

    2. Else Phantom#367

  11. Case (% matches pattern `ListV%`)

    1. (Let (ListV val_a*) be val)

    2. If ((val' matches pattern `ListV%`)), then

      1. (Let (ListV val_b*) be val')

      2. Return $bin_eqs(val_a*, val_b*)

    2. Else Phantom#368

  12. Case (% matches pattern `TupleV%`)

    1. (Let (TupleV val_a*) be val)

    2. If ((val' matches pattern `TupleV%`)), then

      1. (Let (TupleV val_b*) be val')

      2. Return $bin_eqs(val_a*, val_b*)

    2. Else Phantom#369

  13. Case (% matches pattern `StackV%%%`)

    1. (Let (StackV val_a* _int i_size_a) be val)

    2. If ((val' matches pattern `StackV%%%`)), then

      1. (Let (StackV val_b* _int' i_size_b) be val')

      2. Return ($bin_eqs(val_a*, val_b*) /\ (i_size_a = i_size_b))

    2. Else Phantom#370

  14. Case (% matches pattern `StructV%%`)

    1. (Let (StructV id_a (member_a, val_a)*) be val)

    2. If ((val' matches pattern `StructV%%`)), then

      1. (Let (StructV id_b (member_b, val_b)*) be val')

      2. Return ((id_a = id_b) /\ $bin_eqs_((member_a, val_a)*, (member_b, val_b)*))

    2. Else Phantom#371

  15. Case (% matches pattern `HeaderV%%`)

    1. (Let (HeaderV id_a (member_a, val_a)*) be val)

    2. If ((val' matches pattern `StructV%%`)), then

      1. (Let (StructV id_b (member_b, val_b)*) be val')

      2. Return ((id_a = id_b) /\ $bin_eqs_((member_a, val_a)*, (member_b, val_b)*))

    2. Else Phantom#372

  16. Case (% matches pattern `UnionV%%`)

    1. (Let (UnionV id_a (member_a, val_a)*) be val)

    2. If ((val' matches pattern `StructV%%`)), then

      1. (Let (StructV id_b (member_b, val_b)*) be val')

      2. Return ((id_a = id_b) /\ $bin_eqs_((member_a, val_a)*, (member_b, val_b)*))

    2. Else Phantom#373

  17. Case (% matches pattern `InvalidV`)

    1. If ((val' matches pattern `InvalidV`)), then

      1. Return true

    1. Else Phantom#374

1. Else Phantom#375

;; ../../../../spec/2d1-runtime-numerics.watsup:278.1-278.32
def $bin_eqs(val*, val'*)

1. Case analysis on val*

  1. Case (% matches pattern [])

    1. Case analysis on val'*

      1. Case (% matches pattern [])

        1. Return true

      2. Case (% matches pattern _ :: _)

        1. (Let _val :: _val'* be val'*)

        2. Return false

  2. Case (% matches pattern _ :: _)

    1. (Let _val :: _val'* be val*)

    2. If ((val'* matches pattern [])), then

      1. Return false

    2. Else Phantom#376

    3. (Let val_ah :: val_at* be val*)

    4. If ((val'* matches pattern _ :: _)), then

      1. (Let val_bh :: val_bt* be val'*)

      2. Return ($bin_eq(val_ah, val_bh) /\ $bin_eqs(val_at*, val_bt*))

    4. Else Phantom#377

;; ../../../../spec/2d1-runtime-numerics.watsup:279.1-279.53
def $bin_eqs_((member, val)*, (member, val)'*)

1. Case analysis on (member, val)*

  1. Case (% matches pattern [])

    1. Case analysis on (member, val)'*

      1. Case (% matches pattern [])

        1. Return true

      2. Case (% matches pattern _ :: _)

        1. (Let _(member, val) :: _(member, val)'* be (member, val)'*)

        2. Return false

  2. Case (% matches pattern _ :: _)

    1. (Let _(member, val) :: _(member, val)'* be (member, val)*)

    2. If (((member, val)'* matches pattern [])), then

      1. Return false

    2. Else Phantom#378

    3. (Let (member, val_a) :: (member_at, val_at)* be (member, val)*)

    4. If (((member, val)'* matches pattern _ :: _)), then

      1. (Let (member', val_b) :: (member_bt, val_bt)* be (member, val)'*)

      2. If ((member = member')), then

        1. Return ($bin_eq(val_a, val_b) /\ $bin_eqs_((member_at, val_at)*, (member_bt, val_bt)*))

      2. Else Phantom#379

    4. Else Phantom#380

;; ../../../../spec/2d1-runtime-numerics.watsup:325.1-325.30
def $bin_band(val, val')

1. Case analysis on val

  1. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let i be $band(i_l, i_r))

        4. Return (FIntV w $to_bitstr((w as int), i))

      2. Else Phantom#381

    2. Else Phantom#382

  2. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i be $band(bs_l, bs_r))

        2. Return (FBitV w $to_bitstr((w as int), i))

      2. Else Phantom#383

    2. Else Phantom#384

1. Else Phantom#385

;; ../../../../spec/2d1-runtime-numerics.watsup:341.1-341.30
def $bin_bxor(val, val')

1. Case analysis on val

  1. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let i be $bxor(i_l, i_r))

        4. Return (FIntV w $to_bitstr((w as int), i))

      2. Else Phantom#386

    2. Else Phantom#387

  2. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i be $bxor(bs_l, bs_r))

        2. Return (FBitV w $to_bitstr((w as int), i))

      2. Else Phantom#388

    2. Else Phantom#389

1. Else Phantom#390

;; ../../../../spec/2d1-runtime-numerics.watsup:357.1-357.29
def $bin_bor(val, val')

1. Case analysis on val

  1. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs_l) be val)

    2. If ((val' matches pattern `FIntV%%`)), then

      1. (Let (FIntV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i_l be $to_int((w as int), bs_l))

        2. (Let i_r be $to_int((w as int), bs_r))

        3. (Let i be $bor(i_l, i_r))

        4. Return (FIntV w $to_bitstr((w as int), i))

      2. Else Phantom#391

    2. Else Phantom#392

  2. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs_l) be val)

    2. If ((val' matches pattern `FBitV%%`)), then

      1. (Let (FBitV w' bs_r) be val')

      2. If ((w = w')), then

        1. (Let i be $bor(bs_l, bs_r))

        2. Return (FBitV w $to_bitstr((w as int), i))

      2. Else Phantom#393

    2. Else Phantom#394

1. Else Phantom#395

;; ../../../../spec/2d1-runtime-numerics.watsup:373.1-373.32
def $bin_concat(val, val')

1. Case analysis on val

  1. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w_l bs_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. (Let i_l' be $shl(i_l, (w_r as int)))

        4. (Let i_l'' be (i_l' + bs_r))

        5. (Let w be (w_l + w_r))

        6. Return (FIntV w $to_bitstr((w as int), i_l''))

      2. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. (Let i_l be $to_int((w_l as int), bs_l))

        3. (Let i_l' be $shl(i_l, (w_r as int)))

        4. (Let i_l'' be (i_l' + bs_r))

        5. (Let w be (w_l + w_r))

        6. Return (FIntV w $to_bitstr((w as int), i_l''))

    2. Else Phantom#396

  2. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w_l bs_l) be val)

    2. Case analysis on val'

      1. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_r bs_r) be val')

        2. (Let i_l be $shl(bs_l, (w_r as int)))

        3. (Let i_l' be (i_l + bs_r))

        4. (Let w be (w_l + w_r))

        5. Return (FBitV w $to_bitstr((w as int), i_l'))

      2. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_r bs_r) be val')

        2. (Let i_l be $shl(bs_l, (w_r as int)))

        3. (Let i_l' be (i_l + bs_r))

        4. (Let w be (w_l + w_r))

        5. Return (FBitV w $to_bitstr((w as int), i_l'))

    2. Else Phantom#397

1. Else Phantom#398

;; ../../../../spec/2d1-runtime-numerics.watsup:402.1-402.30
def $bin_land(val, val')

1. If ((val matches pattern `BoolV%`)), then

  1. (Let (BoolV b_l) be val)

  2. If ((val' matches pattern `BoolV%`)), then

    1. (Let (BoolV b_r) be val')

    2. Return (BoolV (b_l /\ b_r))

  2. Else Phantom#399

1. Else Phantom#400

;; ../../../../spec/2d1-runtime-numerics.watsup:410.1-410.29
def $bin_lor(val, val')

1. If ((val matches pattern `BoolV%`)), then

  1. (Let (BoolV b_l) be val)

  2. If ((val' matches pattern `BoolV%`)), then

    1. (Let (BoolV b_r) be val')

    2. Return (BoolV (b_l \/ b_r))

  2. Else Phantom#401

1. Else Phantom#402

;; ../../../../spec/2d1-runtime-numerics.watsup:420.1-421.21
def $cast_op(typ, val'')

1. Case analysis on val''

  1. Case (% matches pattern `BoolV%`)

    1. (Let (BoolV b) be val'')

    2. Return $cast_bool(typ, b)

  2. Case (% matches pattern `IntV%`)

    1. (Let (IntV i) be val'')

    2. Return $cast_int(typ, i)

  3. Case (% matches pattern `FIntV%%`)

    1. (Let (FIntV w bs) be val'')

    2. Return $cast_fint(typ, w, bs)

  4. Case (% matches pattern `FBitV%%`)

    1. (Let (FBitV w bs) be val'')

    2. Return $cast_fbit(typ, w, bs)

  5. Case (% matches pattern `SEnumFieldV%%%`)

    1. (Let (SEnumFieldV _id _member val'') be val'')

    2. Return $cast_op(typ, val'')

  6. Case (% matches pattern `StructV%%`)

    1. (Let (StructV id (member, val'')*) be val'')

    2. Return $cast_struct(typ, id, (member, val'')*)

  7. Case (% matches pattern `HeaderV%%`)

    1. (Let (HeaderV id (member, val'')*) be val'')

    2. Return $cast_header(typ, id, (member, val'')*)

  8. Case (% matches pattern `SeqV%`)

    1. (Let (SeqV val''*) be val'')

    2. Return $cast_seq(typ, val''*)

  9. Case (% matches pattern `RecordV%`)

    1. (Let (RecordV (member, val'')*) be val'')

    2. Return $cast_record(typ, (member, val'')*)

  10. Case (% matches pattern `DefaultV`)

    1. Return $default(typ)

  11. Case (% matches pattern `SetV%`)

    1. (Let (SetV setval) be val'')

    2. Case analysis on setval

      1. Case (% matches pattern `SingletonSet%`)

        1. (Let (SingletonSet val'') be setval)

        2. Return $cast_set_singleton(typ, val'')

      2. Case (% matches pattern `MaskSet%%`)

        1. (Let (MaskSet val_b val_m) be setval)

        2. Return $cast_set_mask(typ, val_b, val_m)

      3. Case (% matches pattern `RangeSet%%`)

        1. (Let (RangeSet val_l val_u) be setval)

        2. Return $cast_set_range(typ, val_l, val_u)

1. Else Phantom#403

;; ../../../../spec/2d1-runtime-numerics.watsup:423.1-423.24
def $default(typ)

1. Return $default'($canon_typ(typ))

;; ../../../../spec/2d1-runtime-numerics.watsup:424.1-424.25
def $default'(typ'')

1. If ((typ'' = ((ErrT) as typ))), then

  1. Return (ErrV "NoError")

1. Else Phantom#404

2. If ((typ'' = ((StrT) as typ))), then

  1. Return (StrV "")

2. Else Phantom#405

3. If ((typ'' = ((BoolT) as typ))), then

  1. Return (BoolV false)

3. Else Phantom#406

4. If ((typ'' = ((IntT) as typ))), then

  1. Return (IntV (0 as int))

4. Else Phantom#407

5. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numtyp)

        2. Return (FIntV w (0 as bitstr))

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numtyp)

        2. Return (FBitV w (0 as bitstr))

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT w) be numtyp)

        2. Return (VBitV w 0 (0 as bitstr))

    2. Else Phantom#408

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT id member*) be datatyp)

        2. If ((member* matches pattern _ :: _)), then

          1. (Let member_h :: _member* be member*)

          2. Return (EnumFieldV id member_h)

        2. Else Phantom#409

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT id typ'' (member, val)*) be datatyp)

        2. (Let val_zero be $cast_int(typ'', (0 as int)))

        3. (Let member'? be $assoc_<val, member>(val_zero, (val, member)*))

        4. If ((member'? matches pattern (_))), then

          1. (Let ?(member_zero) be member'?)

          2. Return (SEnumFieldV id member_zero val_zero)

        4. Else Phantom#410

        5. If ((?() = $assoc_<val, member>(val_zero, (val, member)*))), then

          1. Return (SEnumFieldV id "__UNSPECIFIED" val_zero)

        5. Else Phantom#411

      3. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*) be datatyp)

        2. Return (TupleV $default(typ'')*)

      4. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'' int) be datatyp)

        2. If ((int has type nat)), then

          1. (Let n_s be (int as nat))

          2. (Let val* be $repeat_<val>($default(typ''), n_s))

          3. Return (StackV val* (0 as int) (n_s as int))

        2. Else Phantom#412

      5. Case (% matches pattern `StructT%%`)

        1. (Let (StructT id (member, typ'')*) be datatyp)

        2. Return (StructV id (member, $default(typ''))*)

      6. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT id (member, typ'')*) be datatyp)

        2. Return (HeaderV id (member, $default(typ''))*)

      7. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT id (member, typ'')*) be datatyp)

        2. Return (UnionV id (member, $default(typ''))*)

    2. Else Phantom#413

5. Else Phantom#414

;; ../../../../spec/2d1-runtime-numerics.watsup:428.1-428.32
def $cast_bool(typ, b)

1. Return $cast_bool'($canon_typ(typ), b)

;; ../../../../spec/2d1-runtime-numerics.watsup:429.1-429.33
def $cast_bool'(typ'', b')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return (BoolV b')

1. Else Phantom#415

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. If ((numtyp matches pattern `FBitT%`)), then

      1. (Let (FBitT w) be numtyp)

      2. Case analysis on b'

        1. Case (% = true)

          1. Return (FBitV w (1 as bitstr))

        2. Case (% = false)

          1. Return (FBitV w (0 as bitstr))

      2. Else Phantom#416

    2. Else Phantom#417

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id typ'') be datatyp)

      2. Return $cast_bool(typ'', b')

    2. Else Phantom#418

2. Else Phantom#419

;; ../../../../spec/2d1-runtime-numerics.watsup:442.1-442.30
def $cast_int(typ, i)

1. Return $cast_int'($canon_typ(typ), i)

;; ../../../../spec/2d1-runtime-numerics.watsup:443.1-443.31
def $cast_int'(typ'', i)

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return (BoolV (i = (0 as int)))

1. Else Phantom#420

2. If ((typ'' = ((IntT) as typ))), then

  1. Return (IntV i)

2. Else Phantom#421

3. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numtyp)

        2. Return (FIntV w $to_bitstr((w as int), i))

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numtyp)

        2. Return (FBitV w $to_bitstr((w as int), i))

    2. Else Phantom#422

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id typ'') be datatyp)

      2. Return $cast_int(typ'', i)

    2. Else Phantom#423

  3. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. If ((synthtyp matches pattern `SetT%`)), then

      1. (Let (SetT typ'') be synthtyp)

      2. (Let val be $cast_int(typ'', i))

      3. Return (SetV (SingletonSet val))

    2. Else Phantom#424

3. Else Phantom#425

;; ../../../../spec/2d1-runtime-numerics.watsup:459.1-459.41
def $cast_fint(typ, w, bs)

1. Return $cast_fint'($canon_typ(typ), w, bs)

;; ../../../../spec/2d1-runtime-numerics.watsup:460.1-460.42
def $cast_fint'(typ'', w', bs)

1. If ((typ'' = ((IntT) as typ))), then

  1. Return (IntV $to_int((w' as int), bs))

1. Else Phantom#426

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w_to) be numtyp)

        2. (Let bs' be $to_bitstr((w_to as int), $to_int((w' as int), bs)))

        3. Return (FIntV w_to bs')

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w_to) be numtyp)

        2. (Let bs' be $to_bitstr((w_to as int), $to_int((w' as int), bs)))

        3. Return (FBitV w_to bs')

    2. Else Phantom#427

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id typ'') be datatyp)

      2. Return $cast_fint(typ'', w', bs)

    2. Else Phantom#428

  3. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. If ((synthtyp matches pattern `SetT%`)), then

      1. (Let (SetT typ'') be synthtyp)

      2. (Let val be $cast_fint(typ'', w', bs))

      3. Return (SetV (SingletonSet val))

    2. Else Phantom#429

2. Else Phantom#430

;; ../../../../spec/2d1-runtime-numerics.watsup:477.1-477.41
def $cast_fbit(typ, w, bs)

1. Return $cast_fbit'($canon_typ(typ), w, bs)

;; ../../../../spec/2d1-runtime-numerics.watsup:478.1-478.42
def $cast_fbit'(typ'', w', bs)

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return (BoolV (bs = (1 as bitstr)))

1. Else Phantom#431

2. If ((typ'' = ((IntT) as typ))), then

  1. Return (IntV bs)

2. Else Phantom#432

3. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w_to) be numtyp)

        2. (Let bs' be $to_bitstr((w_to as int), bs))

        3. Return (FIntV w_to bs')

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w_to) be numtyp)

        2. (Let bs' be $to_bitstr((w_to as int), bs))

        3. Return (FBitV w_to bs')

    2. Else Phantom#433

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. If ((datatyp matches pattern `NewT%%`)), then

      1. (Let (NewT _id typ'') be datatyp)

      2. Return $cast_fbit(typ'', w', bs)

    2. Else Phantom#434

  3. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'' as synthtyp))

    2. If ((synthtyp matches pattern `SetT%`)), then

      1. (Let (SetT typ'') be synthtyp)

      2. (Let val be $cast_fbit(typ'', w', bs))

      3. Return (SetV (SingletonSet val))

    2. Else Phantom#435

3. Else Phantom#436

;; ../../../../spec/2d1-runtime-numerics.watsup:500.1-500.48
def $cast_struct(typ, id, (member, val)*)

1. Return $cast_struct'($canon_typ(typ), id, (member, val)*)

;; ../../../../spec/2d1-runtime-numerics.watsup:501.1-501.49
def $cast_struct'(typ, id', (member, val)*)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `StructT%%`)), then

    1. (Let (StructT id _(member, typ)*) be datatyp)

    2. If ((id = id')), then

      1. Return (StructV id (member, val)*)

    2. Else Phantom#437

  2. Else Phantom#438

1. Else Phantom#439

;; ../../../../spec/2d1-runtime-numerics.watsup:513.1-513.48
def $cast_header(typ, id, (member, val)*)

1. Return $cast_header'($canon_typ(typ), id, (member, val)*)

;; ../../../../spec/2d1-runtime-numerics.watsup:514.1-514.49
def $cast_header'(typ, id', (member, val)*)

1. If ((typ has type datatyp)), then

  1. (Let datatyp be (typ as datatyp))

  2. If ((datatyp matches pattern `HeaderT%%`)), then

    1. (Let (HeaderT id _(member, typ)*) be datatyp)

    2. If ((id = id')), then

      1. Return (HeaderV id (member, val)*)

    2. Else Phantom#440

  2. Else Phantom#441

1. Else Phantom#442

;; ../../../../spec/2d1-runtime-numerics.watsup:526.1-526.31
def $cast_seq(typ, val*)

1. Return $cast_seq'($canon_typ(typ), val*)

;; ../../../../spec/2d1-runtime-numerics.watsup:527.1-527.32
def $cast_seq'(typ', val*)

1. If ((typ' has type datatyp)), then

  1. (Let datatyp be (typ' as datatyp))

  2. Case analysis on datatyp

    1. Case (% matches pattern `ListT%`)

      1. (Let (ListT typ) be datatyp)

      2. (Let val' be $cast_op(typ, val))*

      3. Return (ListV val'*)

    2. Case (% matches pattern `TupleT%`)

      1. (Let (TupleT typ*) be datatyp)

      2. (Let val' be $cast_op(typ, val))*

      3. Return (TupleV val'*)

    3. Case (% matches pattern `StackT%%`)

      1. (Let (StackT typ i_size) be datatyp)

      2. (Let val' be $cast_op(typ, val))*

      3. (Let i_idx be (|val*| as int))

      4. Return (StackV val'* i_idx i_size)

    4. Case (% matches pattern `StructT%%`)

      1. (Let (StructT id (member, typ)*) be datatyp)

      2. (Let val' be $cast_op(typ, val))*

      3. Return (StructV id (member, val')*)

    5. Case (% matches pattern `HeaderT%%`)

      1. (Let (HeaderT id (member, typ)*) be datatyp)

      2. (Let val' be $cast_op(typ, val))*

      3. Return (HeaderV id (member, val')*)

  2. Else Phantom#443

1. Else Phantom#444

;; ../../../../spec/2d1-runtime-numerics.watsup:553.1-553.44
def $cast_record(typ, (member, val)*)

1. Return $cast_record'($canon_typ(typ), (member, val)*)

;; ../../../../spec/2d1-runtime-numerics.watsup:554.1-554.45
def $cast_record'(typ', (member, val)*)

1. If ((typ' has type datatyp)), then

  1. (Let datatyp be (typ' as datatyp))

  2. Case analysis on datatyp

    1. Case (% matches pattern `StructT%%`)

      1. (Let (StructT id (member_t, typ)*) be datatyp)

      2. (Let val'''? be $find_map<member, val>(({ (member -> val)* }), member_t))*

      3. If ((val'''? matches pattern (_)))*, then

        1. (Let ?(val') be val'''?)*

        2. (Let val'' be $cast_op(typ, val'))*

        3. Return (StructV id (member_t, val'')*)

      3. Else Phantom#445

    2. Case (% matches pattern `HeaderT%%`)

      1. (Let (HeaderT id (member_t, typ)*) be datatyp)

      2. (Let val'''? be $find_map<member, val>(({ (member -> val)* }), member_t))*

      3. If ((val'''? matches pattern (_)))*, then

        1. (Let ?(val') be val'''?)*

        2. (Let val'' be $cast_op(typ, val'))*

        3. Return (HeaderV id (member_t, val'')*)

      3. Else Phantom#446

  2. Else Phantom#447

1. Else Phantom#448

;; ../../../../spec/2d1-runtime-numerics.watsup:581.1-581.40
def $cast_set_singleton(typ, val)

1. Return $cast_set_singleton'($canon_typ(typ), val)

;; ../../../../spec/2d1-runtime-numerics.watsup:582.1-582.41
def $cast_set_singleton'(typ', val)

1. If ((typ' has type synthtyp)), then

  1. (Let synthtyp be (typ' as synthtyp))

  2. If ((synthtyp matches pattern `SetT%`)), then

    1. (Let (SetT typ) be synthtyp)

    2. (Let val' be $cast_op(typ, val))

    3. Return (SetV (SingletonSet val'))

  2. Else Phantom#449

1. Else Phantom#450

;; ../../../../spec/2d1-runtime-numerics.watsup:589.1-589.40
def $cast_set_mask(typ, val_b, val_m)

1. Return $cast_set_mask'($canon_typ(typ), val_b, val_m)

;; ../../../../spec/2d1-runtime-numerics.watsup:590.1-590.41
def $cast_set_mask'(typ', val_b, val_m)

1. If ((typ' has type synthtyp)), then

  1. (Let synthtyp be (typ' as synthtyp))

  2. If ((synthtyp matches pattern `SetT%`)), then

    1. (Let (SetT typ) be synthtyp)

    2. (Let val_b' be $cast_op(typ, val_b))

    3. (Let val_m' be $cast_op(typ, val_m))

    4. Return (SetV (MaskSet val_b' val_m'))

  2. Else Phantom#451

1. Else Phantom#452

;; ../../../../spec/2d1-runtime-numerics.watsup:598.1-598.41
def $cast_set_range(typ, val_l, val_u)

1. Return $cast_set_range'($canon_typ(typ), val_l, val_u)

;; ../../../../spec/2d1-runtime-numerics.watsup:599.1-599.42
def $cast_set_range'(typ', val_l, val_u)

1. If ((typ' has type synthtyp)), then

  1. (Let synthtyp be (typ' as synthtyp))

  2. If ((synthtyp matches pattern `SetT%`)), then

    1. (Let (SetT typ) be synthtyp)

    2. (Let val_l' be $cast_op(typ, val_l))

    3. (Let val_u' be $cast_op(typ, val_u))

    4. Return (SetV (RangeSet val_l' val_u'))

  2. Else Phantom#453

1. Else Phantom#454

;; ../../../../spec/2d1-runtime-numerics.watsup:650.1-650.58
def $bitacc_op(val_b, val_h, val_l)

1. (Let i_b be $get_num(val_b))

2. (Let i_h be $get_num(val_h))

3. (Let i_l be $get_num(val_l))

4. (Let int be ((i_h + (1 as int)) - i_l))

5. If ((int has type nat)), then

  1. (Let w be (int as nat))

  2. (Let i be $bitacc(i_b, i_h, i_l))

  3. Return (FBitV w i)

5. Else Phantom#455

;; ../../../../spec/2d2-runtime-builtins.watsup:5.1-6.34
def $size(typ, text)

1. Case analysis on text

  1. Case (% = "minSizeInBits")

    1. Return $size_minSizeInBits(typ)

  2. Case (% = "minSizeInBytes")

    1. Return $size_minSizeInBytes(typ)

  3. Case (% = "maxSizeInBits")

    1. Return $size_maxSizeInBits(typ)

  4. Case (% = "maxSizeInBytes")

    1. Return $size_maxSizeInBytes(typ)

1. Else Phantom#456

;; ../../../../spec/2d2-runtime-builtins.watsup:8.1-8.35
def $size_minSizeInBits(typ)

1. Return (IntV ($size_minSizeInBits'(typ) as int))

;; ../../../../spec/2d2-runtime-builtins.watsup:9.1-9.36
def $size_minSizeInBits'(typ)

1. Return $size_minSizeInBits''($canon_typ(typ))

;; ../../../../spec/2d2-runtime-builtins.watsup:10.1-10.37
def $size_minSizeInBits''(typ'')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return 1

1. Else Phantom#457

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numtyp)

        2. Return w

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numtyp)

        2. Return w

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT _width) be numtyp)

        2. Return 0

    2. Else Phantom#458

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ'') be datatyp)

        2. Return $size_minSizeInBits'(typ'')

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ'' _(member, val)*) be datatyp)

        2. Return $size_minSizeInBits'(typ'')

      3. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*) be datatyp)

        2. Return $sum($size_minSizeInBits'(typ'')*)

      4. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'' int) be datatyp)

        2. If ((int has type nat)), then

          1. (Let n_s be (int as nat))

          2. Return ($size_minSizeInBits'(typ'') * n_s)

        2. Else Phantom#459

      5. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (_member, typ'')*) be datatyp)

        2. Return $sum($size_minSizeInBits'(typ'')*)

      6. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id (_member, typ'')*) be datatyp)

        2. Return $sum($size_minSizeInBits'(typ'')*)

      7. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id (_member, typ'')*) be datatyp)

        2. Return $min($size_minSizeInBits'(typ'')*)

    2. Else Phantom#460

2. Else Phantom#461

;; ../../../../spec/2d2-runtime-builtins.watsup:12.1-12.36
def $size_minSizeInBytes(typ)

1. (Let n be $size_minSizeInBits'(typ))

2. Return (IntV ((n / 8) as int))

;; ../../../../spec/2d2-runtime-builtins.watsup:14.1-14.35
def $size_maxSizeInBits(typ)

1. Return (IntV ($size_maxSizeInBits'(typ) as int))

;; ../../../../spec/2d2-runtime-builtins.watsup:15.1-15.36
def $size_maxSizeInBits'(typ)

1. Return $size_maxSizeInBits''($canon_typ(typ))

;; ../../../../spec/2d2-runtime-builtins.watsup:16.1-16.37
def $size_maxSizeInBits''(typ'')

1. If ((typ'' = ((BoolT) as typ))), then

  1. Return 1

1. Else Phantom#462

2. Case analysis on typ''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ'' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numtyp)

        2. Return w

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numtyp)

        2. Return w

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT w) be numtyp)

        2. Return w

    2. Else Phantom#463

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ'') be datatyp)

        2. Return $size_maxSizeInBits'(typ'')

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ'' _(member, val)*) be datatyp)

        2. Return $size_maxSizeInBits'(typ'')

      3. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*) be datatyp)

        2. Return $sum($size_maxSizeInBits'(typ'')*)

      4. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ'' int) be datatyp)

        2. If ((int has type nat)), then

          1. (Let n_s be (int as nat))

          2. Return ($size_maxSizeInBits'(typ'') * n_s)

        2. Else Phantom#464

      5. Case (% matches pattern `StructT%%`)

        1. (Let (StructT _id (_member, typ'')*) be datatyp)

        2. Return $sum($size_maxSizeInBits'(typ'')*)

      6. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id (_member, typ'')*) be datatyp)

        2. Return $sum($size_maxSizeInBits'(typ'')*)

      7. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id (_member, typ'')*) be datatyp)

        2. Return $max($size_maxSizeInBits'(typ'')*)

    2. Else Phantom#465

2. Else Phantom#466

;; ../../../../spec/2d2-runtime-builtins.watsup:18.1-18.36
def $size_maxSizeInBytes(typ)

1. (Let n be $size_maxSizeInBits'(typ))

2. Return (IntV ((n / 8) as int))

;; ../../../../spec/2e-runtime-env.watsup:11.15-11.31
syntax styp = 
   | `%%%%`(typ, dir, ctk, val?)

;; ../../../../spec/2e-runtime-env.watsup:18.45-18.58
syntax frame = map<id, styp>

;; ../../../../spec/2e-runtime-env.watsup:20.1-20.27
def $empty_frame

1. Return $empty_map<id, styp>

;; ../../../../spec/2e-runtime-env.watsup:24.57-24.73
syntax tdenv = map<tid, typdef>

;; ../../../../spec/2e-runtime-env.watsup:26.1-26.27
def $empty_tdenv

1. Return $empty_map<tid, typdef>

;; ../../../../spec/2e-runtime-env.watsup:30.57-30.74
syntax fdenv = map<fid, funcdef>

;; ../../../../spec/2e-runtime-env.watsup:32.1-32.27
def $empty_fdenv

1. Return $empty_map<fid, funcdef>

;; ../../../../spec/2e-runtime-env.watsup:36.57-36.74
syntax cdenv = map<fid, consdef>

;; ../../../../spec/2e-runtime-env.watsup:38.1-38.27
def $empty_cdenv

1. Return $empty_map<cid, consdef>

;; ../../../../spec/2e-runtime-env.watsup:45.1-45.36
def $check_func_name(id_l, id_r)

1. Return (id_l = id_r)

;; ../../../../spec/2e-runtime-env.watsup:49.1-49.42
def $check_arity_more(id_a?*, id_p*)

1. Return (|id_a?*| > |id_p*|)

;; ../../../../spec/2e-runtime-env.watsup:53.1-53.37
def $check_arity(id_a?*, id_p*)

1. Return (|id_a?*| = |id_p*|)

;; ../../../../spec/2e-runtime-env.watsup:57.1-57.42
def $check_arity_less(id_a?*, id_p*)

1. Return (|id_a?*| < |id_p*|)

;; ../../../../spec/2e-runtime-env.watsup:61.1-61.46
def $get_params_missing_names(id*, id_a*)

1. Case analysis on id*

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let id_p_h :: id_p_t* be id*)

    2. If (~$in_set<id>(id_p_h, ({ id_a* }))), then

      1. Return id_p_h :: $get_params_missing_names(id_p_t*, id_a*)

    2. Else Phantom#467

    3. Otherwise

      1. Return $get_params_missing_names(id_p_t*, id_a*)

;; ../../../../spec/2e-runtime-env.watsup:73.1-73.68
def $find_match_named<V>(fid, V, id_a*, (id_p, bool_p)*)

1. If ($eq_set<id>(({ id_a* }), ({ id_p* }))), then

  1. Return ?((fid, V, []))

2. Otherwise

  1. Return ?()

;; ../../../../spec/2e-runtime-env.watsup:83.1-84.59
def $find_match_named_default<V>(fid, V, id_a*, (id_p, bool_p)*)

1. (Let id_deft* be $get_params_missing_names(id_p*, id_a*))

2. If (($find_match_named<V>(fid, V, id_a* ++ id_deft*, (id_p, bool_p)*) =/= ?())), then

  1. Return ?((fid, V, id_deft*))

3. Otherwise

  1. Return ?()

;; ../../../../spec/2e-runtime-env.watsup:94.1-95.61
def $find_match_unnamed_default<V>(fid, V, id_a?*, (id_p, bool_p)*)

1. (Let ((id, bool)*, (id_deft, bool')*) be $partition_<(id, bool)>((id_p, bool_p)*, |id_a?*|))

2. If ((bool' = true))*, then

  1. Return ?((fid, V, id_deft*))

3. Otherwise

  1. Return ?()

;; ../../../../spec/2e-runtime-env.watsup:104.1-105.57
def $find_matching_func<V>(id_f, id_a?*, id_a''*, (id_f' (id_p, bool_p)*), V)

1. Case analysis on $check_func_name(id_f, id_f')

  1. Case false

    1. Return ?()

  2. Case true

    1. If ($check_arity_more(id_a?*, id_p*)), then

      1. Return ?()

    1. Else Phantom#468

2. If ((|id_a''*| > 0)), then

  1. If ($check_func_name(id_f, id_f')), then

    1. If ($check_arity(id_a?*, id_p*)), then

      1. Return $find_match_named<V>((id_f' (id_p, bool_p)*), V, id_a''*, (id_p, bool_p)*)

    1. Else Phantom#469

    2. If ($check_arity_less(id_a?*, id_p*)), then

      1. Return $find_match_named_default<V>((id_f' (id_p, bool_p)*), V, id_a''*, (id_p, bool_p)*)

    2. Else Phantom#470

  1. Else Phantom#471

2. Else Phantom#472

3. If ((id_a''* matches pattern [])), then

  1. If ($check_func_name(id_f, id_f')), then

    1. If ($check_arity(id_a?*, id_p*)), then

      1. Return ?(((id_f' (id_p, bool_p)*), V, []))

    1. Else Phantom#473

    2. If ($check_arity_less(id_a?*, id_p*)), then

      1. Return $find_match_unnamed_default<V>((id_f' (id_p, bool_p)*), V, id_a?*, (id_p, bool_p)*)

    2. Else Phantom#474

  1. Else Phantom#475

3. Else Phantom#476

;; ../../../../spec/2e-runtime-env.watsup:142.1-143.58
def $find_matching_funcs<V>(id_f, id_a?*, id_a'*, fid''*, V''*)

1. Case analysis on fid''*

  1. Case (% matches pattern [])

    1. If ((V''* matches pattern [])), then

      1. Return []

    1. Else Phantom#477

  2. Case (% matches pattern _ :: _)

    1. (Let fid_h :: fid_t* be fid''*)

    2. If ((V''* matches pattern _ :: _)), then

      1. (Let V_h :: V_t* be V''*)

      2. If (($find_matching_func<V>(id_f, id_a?*, id_a'*, fid_h, V_h) = ?())), then

        1. Return $find_matching_funcs<V>(id_f, id_a?*, id_a'*, fid_t*, V_t*)

      2. Else Phantom#478

      3. (Let (fid, V, id*)? be $find_matching_func<V>(id_f, id_a?*, id_a'*, fid_h, V_h))

      4. If (((fid, V, id*)? matches pattern (_))), then

        1. (Let ?((fid'', V'', id_deft*)) be (fid, V, id*)?)

        2. Return (fid'', V'', id_deft*) :: $find_matching_funcs<V>(id_f, id_a?*, id_a'*, fid_t*, V_t*)

      4. Else Phantom#479

    2. Else Phantom#480

;; ../../../../spec/2e-runtime-env.watsup:156.1-157.41
def $find_func<V>(id_f, id_a?*, ({ (fid -> V)* }))

1. If ((|id_a?*| > 0)), then

  1. (Let id? be id_a?)*

  2. If ((id? matches pattern (_)))*, then

    1. (Let ?(id_a') be id?)*

    2. If (($find_matching_funcs<V>(id_f, id_a?*, id_a'*, fid*, V*) = [])), then

      1. Return ?()

    2. Else Phantom#481

    3. (Let (fid, V, id*)* be $find_matching_funcs<V>(id_f, id_a?*, id_a'*, fid*, V*))

    4. If (((fid, V, id*)* matches pattern [ _/1 ])), then

      1. (Let [(fid', V', id_deft*)] be (fid, V, id*)*)

      2. Return ?((fid', V', id_deft*))

    4. Else Phantom#482

  2. Else Phantom#483

1. Else Phantom#484

2. If ((id_a? = ?()))*, then

  1. If (($find_matching_funcs<V>(id_f, id_a?*, [], fid*, V*) = [])), then

    1. Return ?()

  1. Else Phantom#485

  2. (Let (fid, V, id*)* be $find_matching_funcs<V>(id_f, id_a?*, [], fid*, V*))

  3. If (((fid, V, id*)* matches pattern [ _/1 ])), then

    1. (Let [(fid', V', id_deft*)] be (fid, V, id*)*)

    2. Return ?((fid', V', id_deft*))

  3. Else Phantom#486

2. Else Phantom#487

;; ../../../../spec/2e-runtime-env.watsup:180.1-180.55
def $find_funcs_by_name(id_f, fid*, funcdef*)

1. Case analysis on fid*

  1. Case (% matches pattern [])

    1. If ((funcdef* matches pattern [])), then

      1. Return []

    1. Else Phantom#488

  2. Case (% matches pattern _ :: _)

    1. (Let (id_h _(id, bool)*) :: fid_t* be fid*)

    2. If ((funcdef* matches pattern _ :: _)), then

      1. (Let fd_h :: fd_t* be funcdef*)

      2. If ((id_f = id_h)), then

        1. Return fd_h :: $find_funcs_by_name(id_f, fid_t*, fd_t*)

      2. Else Phantom#489

    2. Else Phantom#490

    3. (Let _fid :: fid_t* be fid*)

    4. If ((funcdef* matches pattern _ :: _)), then

      1. (Let _funcdef :: fd_t* be funcdef*)

      2. Otherwise

        1. Return $find_funcs_by_name(id_f, fid_t*, fd_t*)

    4. Else Phantom#491

;; ../../../../spec/2e-runtime-env.watsup:192.1-193.23
def $find_func_by_name(id_f, ({ (fid -> fd)* }))

1. If (([] = $find_funcs_by_name(id_f, fid*, fd*))), then

  1. Return ?()

1. Else Phantom#492

2. (Let funcdef* be $find_funcs_by_name(id_f, fid*, fd*))

3. If ((funcdef* matches pattern [ _/1 ])), then

  1. (Let [fd_f] be funcdef*)

  2. Return ?(fd_f)

3. Else Phantom#493

;; ../../../../spec/2f-runtime-ctk.watsup:5.14-5.30
syntax ctk = 
   | `LCTK`()
   | `CTK`()
   | `DYN`()

;; ../../../../spec/2f-runtime-ctk.watsup:7.1-7.81
def $join_ctk(ctk'', ctk''')

1. Case analysis on ctk''

  1. Case (% matches pattern `LCTK`)

    1. Case analysis on ctk'''

      1. Case (% matches pattern `LCTK`)

        1. Return (LCTK)

      2. Case (% matches pattern `CTK`)

        1. Return (CTK)

  2. Case (% matches pattern `CTK`)

    1. Case analysis on ctk'''

      1. Case (% matches pattern `LCTK`)

        1. Return (CTK)

      2. Case (% matches pattern `CTK`)

        1. Return (CTK)

2. Otherwise

  1. Return (DYN)

;; ../../../../spec/2f-runtime-ctk.watsup:16.1-16.75
def $joins_ctk(ctk''*)

1. Case analysis on ctk''*

  1. Case (% matches pattern [])

    1. Return (DYN)

  2. Case (% matches pattern [ _/1 ])

    1. (Let [ctk''] be ctk''*)

    2. Return ctk''

  3. Case (% matches pattern _ :: _)

    1. (Let ctk_a :: ctk''* be ctk''*)

    2. Case analysis on ctk''*

      1. Case (% matches pattern [ _/1 ])

        1. (Let [ctk_b] be ctk''*)

        2. Return $join_ctk(ctk_a, ctk_b)

      2. Case (% matches pattern _ :: _)

        1. (Let ctk_b :: ctk_c* be ctk''*)

        2. (Let ctk_d be $join_ctk(ctk_a, ctk_b))

        3. Return $joins_ctk(ctk_d :: ctk_c*)

    2. Else Phantom#494

1. Else Phantom#495

;; ../../../../spec/2g-runtime-flow.watsup:5.15-5.25
syntax flow = 
   | `CONT`()
   | `RET`()

;; ../../../../spec/2g-runtime-flow.watsup:9.1-9.85
def $join_flow(flow'', flow''')

1. If ((flow'' matches pattern `RET`)), then

  1. If ((flow''' matches pattern `RET`)), then

    1. Return (RET)

  1. Else Phantom#496

1. Else Phantom#497

2. Return (CONT)

;; ../../../../spec/3-syntax-il.watsup:5.16-5.19
syntax numIL = num

;; ../../../../spec/3-syntax-il.watsup:15.15-15.17
syntax idIL = id

;; ../../../../spec/3-syntax-il.watsup:21.17-21.21
syntax nameIL = name

;; ../../../../spec/3-syntax-il.watsup:27.19-27.23
syntax memberIL = idIL

;; ../../../../spec/3-syntax-il.watsup:33.22-33.26
syntax matchkindIL = idIL

;; ../../../../spec/3-syntax-il.watsup:39.23-39.27
syntax statelabelIL = idIL

;; ../../../../spec/3-syntax-il.watsup:45.17-45.21
syntax unopIL = unop

;; ../../../../spec/3-syntax-il.watsup:51.18-51.23
syntax binopIL = binop

;; ../../../../spec/3-syntax-il.watsup:57.16-57.19
syntax dirIL = dir

;; ../../../../spec/3-syntax-il.watsup:69.17-69.20
syntax typeIL = typ

;; ../../../../spec/3-syntax-il.watsup:75.19-75.21
syntax tparamIL = id

;; ../../../../spec/3-syntax-il.watsup:81.18-81.43
syntax paramIL = 
   | `%%%%`(idIL, dirIL, typeIL, exprIL?)

;; ../../../../spec/3-syntax-il.watsup:87.19-87.26
syntax cparamIL = paramIL

;; ../../../../spec/3-syntax-il.watsup:93.17-93.23
syntax targIL = typeIL

;; ../../../../spec/3-syntax-il.watsup:100.1-102.39
syntax argIL = 
   | `ExprA%`(exprIL)
   | `NameA%%`(idIL, exprIL?)
   | `AnyA`()

;; ../../../../spec/3-syntax-il.watsup:109.1-111.33
syntax keysetIL = 
   | `ExprK%`(exprIL)
   | `DefaultK`()
   | `AnyK`()

;; ../../../../spec/3-syntax-il.watsup:117.23-117.45
syntax selectcaseIL = 
   | `%%`(keysetIL*, statelabelIL)

;; ../../../../spec/3-syntax-il.watsup:123.18-123.29
syntax annotIL = 
   | `(%;%)`(typ, ctk)

;; ../../../../spec/3-syntax-il.watsup:125.1-151.131
syntax exprIL = 
   | `ValueE%%`(val, annotIL)
   | `BoolE%%`(bool, annotIL)
   | `StrE%%`(text, annotIL)
   | `NumE%%`(num, annotIL)
   | `NameE%%`(nameIL, annotIL)
   | `SeqE%%`(exprIL*, annotIL)
   | `SeqDefaultE%%`(exprIL*, annotIL)
   | `RecordE%%`((memberIL, exprIL)*, annotIL)
   | `RecordDefaultE%%`((memberIL, exprIL)*, annotIL)
   | `DefaultE%`(annotIL)
   | `InvalidE%`(annotIL)
   | `UnE%%%`(unopIL, exprIL, annotIL)
   | `BinE%%%%`(binopIL, exprIL, exprIL, annotIL)
   | `TernE%%%%`(exprIL, exprIL, exprIL, annotIL)
   | `CastE%%%`(typeIL, exprIL, annotIL)
   | `MaskE%%%`(exprIL, exprIL, annotIL)
   | `RangeE%%%`(exprIL, exprIL, annotIL)
   | `SelectE%%%`(exprIL*, selectcaseIL*, annotIL)
   | `ArrAccE%%%`(exprIL, exprIL, annotIL)
   | `BitAccE%%%%`(exprIL, exprIL, exprIL, annotIL)
   | `ErrAccE%%`(memberIL, annotIL)
   | `TypeAccE%%%`(nameIL, memberIL, annotIL)
   | `ExprAccE%%%`(exprIL, memberIL, annotIL)
   | `CallFuncE%%%%`(nameIL, targIL*, argIL*, annotIL)
   | `CallMethodE%%%%%`(exprIL, memberIL, targIL*, argIL*, annotIL)
   | `CallTypeE%%%%%`(nameIL, memberIL, targIL*, argIL*, annotIL)
   | `InstE%%%%%`(nameIL, targIL*, targIL*, argIL*, annotIL)

;; ../../../../spec/3-syntax-il.watsup:157.18-157.75
syntax blockIL = 
   | `BlockB%`(stmtIL*)

;; ../../../../spec/3-syntax-il.watsup:164.1-175.67
syntax stmtIL = 
   | `EmptyS`()
   | `AssignS%%`(exprIL, exprIL)
   | `SwitchS%%`(exprIL, switchcaseIL*)
   | `IfS%%%`(exprIL, stmtIL, stmtIL)
   | `BlockS%`(blockIL)
   | `ExitS`()
   | `RetS%`(exprIL?)
   | `CallFuncS%%%`(nameIL, targIL*, argIL*)
   | `CallMethodS%%%%`(exprIL, memberIL, targIL*, argIL*)
   | `CallInstS%%%%`(typeIL, nameIL, targIL*, argIL*)
   | `TransS%`(exprIL)
   | `DeclS%`(declIL)

;; ../../../../spec/3-syntax-il.watsup:182.1-183.39
syntax switchlabelIL = 
   | `ExprL%`(exprIL)
   | `DefaultL`()

;; ../../../../spec/3-syntax-il.watsup:186.1-187.56
syntax switchcaseIL = 
   | `MatchC%%`(switchlabelIL, blockIL)
   | `FallC%`(switchlabelIL)

;; ../../../../spec/3-syntax-il.watsup:193.24-193.44
syntax parserstateIL = 
   | `%%`(statelabelIL, blockIL)

;; ../../../../spec/3-syntax-il.watsup:199.16-199.26
syntax tblIL = tblpropIL*

;; ../../../../spec/3-syntax-il.watsup:205.19-205.37
syntax tblkeyIL = 
   | `%%`(exprIL, matchkindIL)

;; ../../../../spec/3-syntax-il.watsup:206.23-206.32
syntax tblkeypropIL = tblkeyIL*

;; ../../../../spec/3-syntax-il.watsup:212.22-212.53
syntax tblactionIL = 
   | `%%%%`(nameIL, argIL*, paramIL*, paramIL*)

;; ../../../../spec/3-syntax-il.watsup:213.26-213.38
syntax tblactionpropIL = tblactionIL*

;; ../../../../spec/3-syntax-il.watsup:219.21-219.52
syntax tblentryIL = 
   | `%%%%`(bool, keysetIL*, tblactionIL, val?)

;; ../../../../spec/3-syntax-il.watsup:220.25-220.41
syntax tblentrypropIL = 
   | `%%`(bool, tblentryIL*)

;; ../../../../spec/3-syntax-il.watsup:226.27-226.43
syntax tbldefaultpropIL = 
   | `%%`(bool, tblactionIL)

;; ../../../../spec/3-syntax-il.watsup:232.26-232.46
syntax tblcustompropIL = 
   | `%%%`(bool, memberIL, exprIL)

;; ../../../../spec/3-syntax-il.watsup:239.1-243.80
syntax tblpropIL = 
   | `KeyP%`(tblkeypropIL)
   | `ActionP%`(tblactionpropIL)
   | `EntryP%`(tblentrypropIL)
   | `DefaultP%`(tbldefaultpropIL)
   | `CustomP%`(tblcustompropIL)

;; ../../../../spec/3-syntax-il.watsup:250.1-252.53
syntax methodIL = 
   | `ExternConsM%%%`(idIL, tparamIL*, cparamIL*)
   | `ExternAbstractM%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*)
   | `ExternM%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*)

;; ../../../../spec/3-syntax-il.watsup:261.1-283.52
syntax declIL = 
   | `ConstD%%%`(idIL, typeIL, val)
   | `VarD%%%`(idIL, typeIL, exprIL?)
   | `ErrD%`(memberIL*)
   | `MatchKindD%`(memberIL*)
   | `InstD%%%%%%%`(idIL, typeIL, nameIL, targIL*, targIL*, argIL*, declIL*)
   | `StructD%%%%`(idIL, tparamIL*, tparamIL*, (memberIL, typeIL)*)
   | `HeaderD%%%%`(idIL, tparamIL*, tparamIL*, (memberIL, typeIL)*)
   | `UnionD%%%%`(idIL, tparamIL*, tparamIL*, (memberIL, typeIL)*)
   | `EnumD%%`(idIL, memberIL*)
   | `SEnumD%%%`(idIL, typeIL, (memberIL, val)*)
   | `NewTypeD%%`(idIL, typedefIL)
   | `TypeDefD%%`(idIL, typedefIL)
   | `ValueSetD%%%`(idIL, typeIL, exprIL)
   | `ParserTypeD%%%%`(idIL, tparamIL*, tparamIL*, paramIL*)
   | `ParserD%%%%%`(idIL, paramIL*, cparamIL*, declIL*, parserstateIL*)
   | `TableD%%%`(idIL, typeIL, tblIL)
   | `ControlTypeD%%%%`(idIL, tparamIL*, tparamIL*, paramIL*)
   | `ControlD%%%%%`(idIL, paramIL*, cparamIL*, declIL*, blockIL)
   | `ActionD%%%`(idIL, paramIL*, blockIL)
   | `FuncD%%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*, blockIL)
   | `ExternFuncD%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*)
   | `ExternObjectD%%%`(idIL, tparamIL*, methodIL*)
   | `PackageTypeD%%%%`(idIL, tparamIL*, tparamIL*, cparamIL*)

;; ../../../../spec/3-syntax-il.watsup:286.1-287.17
syntax typedefIL = 
   | `TypeD%`(typeIL)
   | `DeclD%`(declIL)

;; ../../../../spec/3-syntax-il.watsup:293.20-293.27
syntax programIL = declIL*

;; ../../../../spec/4a1-typing-context.watsup:5.17-5.39
syntax cursor = 
   | `GLOBAL`()
   | `BLOCK`()
   | `LOCAL`()

;; ../../../../spec/4a1-typing-context.watsup:16.3-19.18
syntax glayer = {`CDENV%`(cdenv), `TDENV%`(tdenv), `FDENV%`(fdenv), `FRAME%`(frame)}

;; ../../../../spec/4a1-typing-context.watsup:23.16-23.59
syntax bkind = 
   | `EMPTY`()
   | `EXTERN`()
   | `PARSER`()
   | `CONTROL`()
   | `PACKAGE`()

;; ../../../../spec/4a1-typing-context.watsup:26.3-30.18
syntax blayer = {`ID%`(id), `KIND%`(bkind), `TDENV%`(tdenv), `FDENV%`(fdenv), `FRAME%`(frame)}

;; ../../../../spec/4a1-typing-context.watsup:35.1-43.21
syntax lkind = 
   | `EMPTY`()
   | `EXTERNFUNC`()
   | `FUNC%`(typ)
   | `ACTION`()
   | `EXTERNMETHOD`()
   | `EXTERNABSTRACTMETHOD%`(typ)
   | `PARSERSTATE`()
   | `CONTROLAPPLYMETHOD`()
   | `TABLEAPPLYMETHOD`()

;; ../../../../spec/4a1-typing-context.watsup:46.3-49.20
syntax llayer = {`ID%`(id), `KIND%`(lkind), `TDENV%`(tdenv), `FRAMES%`(frame*)}

;; ../../../../spec/4a1-typing-context.watsup:56.3-58.19
syntax context = {`GLOBAL%`(glayer), `BLOCK%`(blayer), `LOCAL%`(llayer)}

;; ../../../../spec/4a1-typing-context.watsup:66.1-66.29
def $empty_context

1. (Let glayer be {CDENV $empty_map<cid, consdef>, TDENV $empty_map<tid, typdef>, FDENV $empty_map<fid, funcdef>, FRAME $empty_map<id, styp>})

2. (Let blayer be {ID "", KIND (EMPTY), TDENV $empty_map<tid, typdef>, FDENV $empty_map<fid, funcdef>, FRAME $empty_map<id, styp>})

3. (Let llayer be {ID "", KIND (EMPTY), TDENV $empty_map<tid, typdef>, FRAMES [$empty_map<id, styp>]})

4. (Let C be {GLOBAL glayer, BLOCK blayer, LOCAL llayer})

5. Return C

;; ../../../../spec/4a1-typing-context.watsup:91.1-92.23
def $enter(C)

1. Return C[LOCAL.FRAMES = $empty_map<id, styp> :: C.LOCAL.FRAMES]

;; ../../../../spec/4a1-typing-context.watsup:96.1-97.22
def $exit(C)

1. (Let frame* be C.LOCAL.FRAMES)

2. If ((frame* matches pattern _ :: _)), then

  1. (Let frame_h :: frame_t* be frame*)

  2. Return C[LOCAL.FRAMES = frame_t*]

2. Else Phantom#498

;; ../../../../spec/4a1-typing-context.watsup:106.1-107.34
def $set_blockkind(C, bkind)

1. Return C[BLOCK.KIND = bkind]

;; ../../../../spec/4a1-typing-context.watsup:111.1-112.35
def $set_localkind(C, lkind)

1. Return C[LOCAL.KIND = lkind]

;; ../../../../spec/4a1-typing-context.watsup:116.1-117.63
def $set_blockframe



;; ../../../../spec/4a1-typing-context.watsup:123.1-124.32
def $get_typ_ret_lkind(lkind)

1. Case analysis on lkind

  1. Case (% matches pattern `FUNC%`)

    1. (Let (FUNC typ) be lkind)

    2. Return typ

  2. Case (% matches pattern `ACTION`)

    1. Return ((VoidT) as typ)

  3. Case (% matches pattern `EXTERNABSTRACTMETHOD%`)

    1. (Let (EXTERNABSTRACTMETHOD typ) be lkind)

    2. Return typ

  4. Case (% matches pattern `CONTROLAPPLYMETHOD`)

    1. Return ((VoidT) as typ)

1. Else Phantom#499

;; ../../../../spec/4a1-typing-context.watsup:135.1-135.42
def $bound_tids(cursor, C)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return $empty_set<tid>

  2. Case (% matches pattern `BLOCK`)

    1. Return $dom_map<tid, typdef>(C.BLOCK.TDENV)

  3. Case (% matches pattern `LOCAL`)

    1. Return $union_set<tid>($dom_map<tid, typdef>(C.LOCAL.TDENV), $bound_tids((BLOCK), C))

;; ../../../../spec/4a1-typing-context.watsup:147.1-148.84
def $add_styp(cursor, C, id, styp)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Case analysis on id

      1. Case (% = "main")

        1. If (~$in_set<id>(id, $dom_map<id, styp>(C.GLOBAL.FRAME))), then

          1. (Let (typ _dir _ctk _val?) be styp)

          2. If ($is_packaget($canon_typ(typ))), then

            1. (Let frame be $add_map<id, styp>(C.GLOBAL.FRAME, id, styp))

            2. Return C[GLOBAL.FRAME = frame]

          2. Else Phantom#500

        1. Else Phantom#501

      2. Case (% =/= "main")

        1. If (~$in_set<id>(id, $dom_map<id, styp>(C.GLOBAL.FRAME))), then

          1. (Let frame be $add_map<id, styp>(C.GLOBAL.FRAME, id, styp))

          2. Return C[GLOBAL.FRAME = frame]

        1. Else Phantom#502

  2. Case (% matches pattern `BLOCK`)

    1. If ((id =/= "main")), then

      1. If (~$in_set<id>(id, $dom_map<id, styp>(C.BLOCK.FRAME))), then

        1. (Let frame be $add_map<id, styp>(C.BLOCK.FRAME, id, styp))

        2. Return C[BLOCK.FRAME = frame]

      1. Else Phantom#503

    1. Else Phantom#504

  3. Case (% matches pattern `LOCAL`)

    1. If ((id =/= "main")), then

      1. (Let frame'* be C.LOCAL.FRAMES)

      2. If ((frame'* matches pattern _ :: _)), then

        1. (Let frame_h :: frame_t* be frame'*)

        2. If (~$in_set<id>(id, $dom_map<id, styp>(frame_h))), then

          1. (Let frame_h' be $add_map<id, styp>(frame_h, id, styp))

          2. (Let frame* be frame_h' :: frame_t*)

          3. Return C[LOCAL.FRAMES = frame*]

        2. Else Phantom#505

      2. Else Phantom#506

    1. Else Phantom#507

;; ../../../../spec/4a1-typing-context.watsup:171.1-172.88
def $add_styps(cursor, C, id*, styp*)

1. Case analysis on id*

  1. Case (% matches pattern [])

    1. If ((styp* matches pattern [])), then

      1. Return C

    1. Else Phantom#508

  2. Case (% matches pattern _ :: _)

    1. (Let id_h :: id_t* be id*)

    2. If ((styp* matches pattern _ :: _)), then

      1. (Let styp_h :: styp_t* be styp*)

      2. (Let C' be $add_styp(cursor, C, id_h, styp_h))

      3. (Let C'' be $add_styps(cursor, C', id_t*, styp_t*))

      4. Return C''

    2. Else Phantom#509

;; ../../../../spec/4a1-typing-context.watsup:181.1-181.52
def $add_param(p, C, pt)

1. (Let (id dir typ exprIL?) be pt)

2. Case analysis on dir

  1. Case (% matches pattern `NO`)

    1. (Let C' be $add_styp(p, C, id, (typ (NO) (CTK) ?())))

    2. Return C'

  2. Case (% matches pattern `IN`)

    1. (Let C' be $add_styp(p, C, id, (typ dir (DYN) ?())))

    2. Return C'

  3. Case (% matches pattern `OUT`)

    1. (Let C' be $add_styp(p, C, id, (typ dir (DYN) ?())))

    2. Return C'

  4. Case (% matches pattern `INOUT`)

    1. (Let C' be $add_styp(p, C, id, (typ dir (DYN) ?())))

    2. Return C'

;; ../../../../spec/4a1-typing-context.watsup:191.1-191.54
def $add_params(p, C, paramtyp*)

1. Case analysis on paramtyp*

  1. Case (% matches pattern [])

    1. Return C

  2. Case (% matches pattern _ :: _)

    1. (Let pt_h :: pt_t* be paramtyp*)

    2. (Let C' be $add_param(p, C, pt_h))

    3. (Let C'' be $add_params(p, C', pt_t*))

    4. Return C''

;; ../../../../spec/4a1-typing-context.watsup:200.1-201.80
def $add_typdef(cursor, C, tid, td)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. If (~$in_set<tid>(tid, $dom_map<tid, typdef>(C.GLOBAL.TDENV))), then

      1. (Let tdenv be $add_map<tid, typdef>(C.GLOBAL.TDENV, tid, td))

      2. Return C[GLOBAL.TDENV = tdenv]

    1. Else Phantom#510

  2. Case (% matches pattern `BLOCK`)

    1. If (~$in_set<tid>(tid, $dom_map<tid, typdef>(C.BLOCK.TDENV))), then

      1. (Let tdenv be $add_map<tid, typdef>(C.BLOCK.TDENV, tid, td))

      2. Return C[BLOCK.TDENV = tdenv]

    1. Else Phantom#511

  3. Case (% matches pattern `LOCAL`)

    1. If (~$in_set<tid>(tid, $dom_map<tid, typdef>(C.LOCAL.TDENV))), then

      1. (Let tdenv be $add_map<tid, typdef>(C.LOCAL.TDENV, tid, td))

      2. Return C[LOCAL.TDENV = tdenv]

    1. Else Phantom#512

;; ../../../../spec/4a1-typing-context.watsup:213.1-214.84
def $add_typdefs(p, C, tid*, typdef*)

1. Case analysis on tid*

  1. Case (% matches pattern [])

    1. If ((typdef* matches pattern [])), then

      1. Return C

    1. Else Phantom#513

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t* be tid*)

    2. If ((typdef* matches pattern _ :: _)), then

      1. (Let td_h :: td_t* be typdef*)

      2. (Let C' be $add_typdef(p, C, tid_h, td_h))

      3. (Let C'' be $add_typdefs(p, C', tid_t*, td_t*))

      4. Return C''

    2. Else Phantom#514

;; ../../../../spec/4a1-typing-context.watsup:223.1-223.51
def $add_tparam(cursor, C, tparam)

1. Case analysis on cursor

  1. Case (% matches pattern `BLOCK`)

    1. (Let td be ((MonoD ((VarT tparam) as typ)) as typdef))

    2. If (~$in_set<tid>(tparam, $dom_map<tid, typdef>(C.BLOCK.TDENV))), then

      1. (Let tdenv be $add_map<tid, typdef>(C.BLOCK.TDENV, tparam, td))

      2. Return C[BLOCK.TDENV = tdenv]

    2. Else Phantom#515

  2. Case (% matches pattern `LOCAL`)

    1. (Let td be ((MonoD ((VarT tparam) as typ)) as typdef))

    2. If (~$in_set<tid>(tparam, $dom_map<tid, typdef>(C.LOCAL.TDENV))), then

      1. (Let tdenv be $add_map<tid, typdef>(C.LOCAL.TDENV, tparam, td))

      2. Return C[LOCAL.TDENV = tdenv]

    2. Else Phantom#516

1. Else Phantom#517

;; ../../../../spec/4a1-typing-context.watsup:234.1-234.53
def $add_tparams(p, C, tparam*)

1. Case analysis on tparam*

  1. Case (% matches pattern [])

    1. Return C

  2. Case (% matches pattern _ :: _)

    1. (Let tparam_h :: tparam_t* be tparam*)

    2. (Let C' be $add_tparam(p, C, tparam_h))

    3. (Let C'' be $add_tparams(p, C', tparam_t*))

    4. Return C''

;; ../../../../spec/4a1-typing-context.watsup:243.1-244.80
def $add_funcdef(cursor, C, fid, fd)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. If (~$in_set<fid>(fid, $dom_map<fid, funcdef>(C.GLOBAL.FDENV))), then

      1. (Let fdenv be $add_map<fid, funcdef>(C.GLOBAL.FDENV, fid, fd))

      2. Return C[GLOBAL.FDENV = fdenv]

    1. Else Phantom#518

  2. Case (% matches pattern `BLOCK`)

    1. If (~$in_set<fid>(fid, $dom_map<fid, funcdef>(C.BLOCK.FDENV))), then

      1. (Let fdenv be $add_map<fid, funcdef>(C.BLOCK.FDENV, fid, fd))

      2. Return C[BLOCK.FDENV = fdenv]

    1. Else Phantom#519

1. Else Phantom#520

;; ../../../../spec/4a1-typing-context.watsup:253.1-254.80
def $add_funcdef_non_overload(cursor, C, fid, fd)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let ({ (id_k _(id, bool)*)* }) be $dom_map<fid, funcdef>(C.GLOBAL.FDENV))

    2. (Let (id _(id, bool)'*) be fid)

    3. If (~id is in id_k*), then

      1. (Let fdenv be $add_map<fid, funcdef>(C.GLOBAL.FDENV, fid, fd))

      2. Return C[GLOBAL.FDENV = fdenv]

    3. Else Phantom#521

  2. Case (% matches pattern `BLOCK`)

    1. (Let ({ (id_k _(id, bool)*)* }) be $dom_map<fid, funcdef>(C.BLOCK.FDENV))

    2. (Let (id _(id, bool)'*) be fid)

    3. If (~id is in id_k*), then

      1. (Let fdenv be $add_map<fid, funcdef>(C.BLOCK.FDENV, fid, fd))

      2. Return C[BLOCK.FDENV = fdenv]

    3. Else Phantom#522

1. Else Phantom#523

;; ../../../../spec/4a1-typing-context.watsup:269.1-270.80
def $add_consdef(cursor, C, cid, cd)

1. If ((cursor matches pattern `GLOBAL`)), then

  1. If (~$in_set<cid>(cid, $dom_map<cid, consdef>(C.GLOBAL.CDENV))), then

    1. (Let cdenv be $add_map<cid, consdef>(C.GLOBAL.CDENV, cid, cd))

    2. Return C[GLOBAL.CDENV = cdenv]

  1. Else Phantom#524

1. Else Phantom#525

;; ../../../../spec/4a1-typing-context.watsup:282.1-283.57
def $find_styp(p', C, name)

1. If ((name matches pattern `TOP%`)), then

  1. (Let (TOP id) be name)

  2. Return $find_map<id, styp>(C.GLOBAL.FRAME, id)

1. Else Phantom#526

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_map<id, styp>(C.GLOBAL.FRAME, id)

    1. Else Phantom#527

  2. Case (% matches pattern `BLOCK`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. (Let styp'? be $find_map<id, styp>(C.BLOCK.FRAME, id))

      3. If ((styp'? matches pattern (_))), then

        1. (Let ?(styp) be styp'?)

        2. Return ?(styp)

      3. Else Phantom#528

      4. If ((?() = $find_map<id, styp>(C.BLOCK.FRAME, id))), then

        1. Return $find_styp((GLOBAL), C, (CURRENT id))

      4. Else Phantom#529

    1. Else Phantom#530

  3. Case (% matches pattern `LOCAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. (Let styp'? be $find_maps<id, styp>(C.LOCAL.FRAMES, id))

      3. If ((styp'? matches pattern (_))), then

        1. (Let ?(styp) be styp'?)

        2. Return ?(styp)

      3. Else Phantom#531

      4. If ((?() = $find_maps<id, styp>(C.LOCAL.FRAMES, id))), then

        1. Return $find_styp((BLOCK), C, (CURRENT id))

      4. Else Phantom#532

    1. Else Phantom#533

;; ../../../../spec/4a1-typing-context.watsup:298.1-299.44
def $find_val(p, C, name)

1. (Let styp? be $find_styp(p, C, name))

2. If ((styp? matches pattern (_))), then

  1. (Let ?((typ dir ctk val'?)) be styp?)

  2. If ((val'? matches pattern (_))), then

    1. (Let ?(val) be val'?)

    2. Return ?(val)

  2. Else Phantom#534

2. Else Phantom#535

;; ../../../../spec/4a1-typing-context.watsup:306.1-307.44
def $find_typdef(p', C, name)

1. If ((name matches pattern `TOP%`)), then

  1. (Let (TOP id) be name)

  2. Return $find_map<tid, typdef>(C.GLOBAL.TDENV, id)

1. Else Phantom#536

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_map<tid, typdef>(C.GLOBAL.TDENV, id)

    1. Else Phantom#537

  2. Case (% matches pattern `BLOCK`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. (Let typdef? be $find_map<tid, typdef>(C.BLOCK.TDENV, id))

      3. If ((typdef? matches pattern (_))), then

        1. (Let ?(td) be typdef?)

        2. Return ?(td)

      3. Else Phantom#538

      4. If ((?() = $find_map<tid, typdef>(C.BLOCK.TDENV, id))), then

        1. Return $find_typdef((GLOBAL), C, (CURRENT id))

      4. Else Phantom#539

    1. Else Phantom#540

  3. Case (% matches pattern `LOCAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. (Let typdef? be $find_map<tid, typdef>(C.LOCAL.TDENV, id))

      3. If ((typdef? matches pattern (_))), then

        1. (Let ?(td) be typdef?)

        2. Return ?(td)

      3. Else Phantom#541

      4. If ((?() = $find_map<tid, typdef>(C.LOCAL.TDENV, id))), then

        1. Return $find_typdef((BLOCK), C, (CURRENT id))

      4. Else Phantom#542

    1. Else Phantom#543

;; ../../../../spec/4a1-typing-context.watsup:322.1-322.28
def $to_fkey(arg*)

1. Case analysis on arg*

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let arg_h :: arg_t* be arg*)

    2. (Let arg' be arg_h)

    3. If ((arg' matches pattern `NameA%%`)), then

      1. (Let (NameA id _expr?) be arg')

      2. Return ?(id) :: $to_fkey(arg_t*)

    3. Else Phantom#544

    4. Otherwise

      1. Return ?() :: $to_fkey(arg_t*)

;; ../../../../spec/4a1-typing-context.watsup:330.1-331.58
def $find_funcdef(p', C, name, arg*)

1. If ((name matches pattern `TOP%`)), then

  1. (Let (TOP id) be name)

  2. Return $find_func<funcdef>(id, $to_fkey(arg*), C.GLOBAL.FDENV)

1. Else Phantom#545

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_func<funcdef>(id, $to_fkey(arg*), C.GLOBAL.FDENV)

    1. Else Phantom#546

  2. Case (% matches pattern `BLOCK`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. (Let (fid, funcdef, id*)? be $find_func<funcdef>(id, $to_fkey(arg*), C.BLOCK.FDENV))

      3. If (((fid, funcdef, id*)? matches pattern (_))), then

        1. (Let ?((fid, fd, id_deft*)) be (fid, funcdef, id*)?)

        2. Return ?((fid, fd, id_deft*))

      3. Else Phantom#547

      4. If ((?() = $find_func<funcdef>(id, $to_fkey(arg*), C.BLOCK.FDENV))), then

        1. Return $find_funcdef((GLOBAL), C, (CURRENT id), arg*)

      4. Else Phantom#548

    1. Else Phantom#549

  3. Case (% matches pattern `LOCAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_funcdef((BLOCK), C, (CURRENT id), arg*)

    1. Else Phantom#550

;; ../../../../spec/4a1-typing-context.watsup:341.1-342.44
def $find_funcdef_by_name(p', C, name)

1. If ((name matches pattern `TOP%`)), then

  1. (Let (TOP id) be name)

  2. Return $find_func_by_name(id, C.GLOBAL.FDENV)

1. Else Phantom#551

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_func_by_name(id, C.GLOBAL.FDENV)

    1. Else Phantom#552

  2. Case (% matches pattern `BLOCK`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. (Let funcdef? be $find_func_by_name(id, C.BLOCK.FDENV))

      3. If ((funcdef? matches pattern (_))), then

        1. (Let ?(fd) be funcdef?)

        2. Return ?(fd)

      3. Else Phantom#553

      4. If ((?() = $find_func_by_name(id, C.BLOCK.FDENV))), then

        1. Return $find_funcdef_by_name((GLOBAL), C, (CURRENT id))

      4. Else Phantom#554

    1. Else Phantom#555

  3. Case (% matches pattern `LOCAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_funcdef_by_name((BLOCK), C, (CURRENT id))

    1. Else Phantom#556

;; ../../../../spec/4a1-typing-context.watsup:354.1-355.58
def $find_consdef(p', C, name, arg*)

1. If ((name matches pattern `TOP%`)), then

  1. (Let (TOP id) be name)

  2. Return $find_func<consdef>(id, $to_fkey(arg*), C.GLOBAL.CDENV)

1. Else Phantom#557

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_func<consdef>(id, $to_fkey(arg*), C.GLOBAL.CDENV)

    1. Else Phantom#558

  2. Case (% matches pattern `BLOCK`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_consdef((GLOBAL), C, (CURRENT id), arg*)

    1. Else Phantom#559

  3. Case (% matches pattern `LOCAL`)

    1. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be name)

      2. Return $find_consdef((BLOCK), C, (CURRENT id), arg*)

    1. Else Phantom#560

;; ../../../../spec/4a2-typing-tblctx.watsup:6.1-9.11
syntax mode = 
   | `NOPRI`()
   | `NOPRILPM%`(nat)
   | `PRI`()
   | `PRILPM`()

;; ../../../../spec/4a2-typing-tblctx.watsup:12.3-15.24
syntax priority = {`VALUES%`(int*), `INIT%`(bool), `DELTA%`(int), `LARGEST_WINS%`(bool)}

;; ../../../../spec/4a2-typing-tblctx.watsup:18.3-19.17
syntax entry = {`SIZE%`(int), `CONST%`(bool)}

;; ../../../../spec/4a2-typing-tblctx.watsup:24.14-24.30
syntax key = (typ, matchkind)

;; ../../../../spec/4a2-typing-tblctx.watsup:25.17-25.42
syntax action = (name, paramtyp*, argIL*)

;; ../../../../spec/4a2-typing-tblctx.watsup:28.3-32.16
syntax tblctx = {`KEYS%`(key*), `ACTIONS%`(action*), `PRIORITIES%`(priority), `ENTRIES%`(entry), `MODE%`(mode)}

;; ../../../../spec/4a2-typing-tblctx.watsup:39.1-40.10
syntax tblstate = 
   | `LPM%`(nat)
   | `NOLPM`()

;; ../../../../spec/4a2-typing-tblctx.watsup:46.1-46.26
def $empty_pt

1. Return {VALUES [], INIT false, DELTA (1 as int), LARGEST_WINS true}

;; ../../../../spec/4a2-typing-tblctx.watsup:53.1-53.23
def $empty_et

1. Return {SIZE (0 as int), CONST true}

;; ../../../../spec/4a2-typing-tblctx.watsup:58.1-58.28
def $empty_tblctx

1. Return {KEYS [], ACTIONS [], PRIORITIES $empty_pt, ENTRIES $empty_et, MODE (NOPRI)}

;; ../../../../spec/4a2-typing-tblctx.watsup:70.1-70.35
def $add_key(key, tblctx)

1. Return tblctx[KEYS = tblctx.KEYS ++ [key]]

;; ../../../../spec/4a2-typing-tblctx.watsup:74.1-74.41
def $add_action(action, tblctx)

1. Return tblctx[ACTIONS = tblctx.ACTIONS ++ [action]]

;; ../../../../spec/4a2-typing-tblctx.watsup:78.1-78.40
def $add_priority(i, tblctx)

1. Return tblctx[PRIORITIES.VALUES = tblctx.PRIORITIES.VALUES ++ [i]]

;; ../../../../spec/4a2-typing-tblctx.watsup:87.1-87.36
def $get_lpm_prefix(val)

1. Return (LPM $get_lpm_prefix'(val, 0))

;; ../../../../spec/4a2-typing-tblctx.watsup:88.1-88.37
def $get_lpm_prefix'(val, n_prefix')

1. If ((val matches pattern `FBitV%%`)), then

  1. (Let (FBitV nat _bitstr) be val)

  2. If ((nat = 0)), then

    1. Return n_prefix'

  2. Else Phantom#561

  3. If ((_bitstr has type nat)), then

    1. (Let n be (_bitstr as nat))

    2. If ((nat > 0)), then

      1. If (((n \ 2) =/= 0)), then

        1. (Let val' be (FBitV (nat - 1) (((n - 1) / 2) as bitstr)))

        2. Return $get_lpm_prefix'(val', (n_prefix' + 1))

      1. Else Phantom#562

    2. Else Phantom#563

    3. If ((n_prefix' = 0)), then

      1. If ((nat > 0)), then

        1. If (((n \ 2) = 0)), then

          1. (Let val' be (FBitV (nat - 1) ((n / 2) as bitstr)))

          2. Return $get_lpm_prefix'(val', 0)

        1. Else Phantom#564

      1. Else Phantom#565

    3. Else Phantom#566

  3. Else Phantom#567

1. Else Phantom#568

;; ../../../../spec/4a2-typing-tblctx.watsup:107.1-107.45
def $update_mode(text', typ', tblctx)

1. Case analysis on text'

  1. Case (% = "lpm")

    1. Case analysis on tblctx.MODE

      1. Case (% matches pattern `NOPRI`)

        1. (Let w be $get_width(typ'))

        2. Return tblctx[MODE = (NOPRILPM w)]

      2. Case (% matches pattern `PRI`)

        1. Return tblctx[MODE = (PRILPM)]

  2. Case (% = "range")

    1. If ((tblctx.MODE matches pattern `NOPRI`)), then

      1. Return tblctx[MODE = (PRI)]

    2. (Let mode be tblctx.MODE)

    3. If ((mode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM _nat) be mode)

      2. Return tblctx[MODE = (PRILPM)]

  3. Case (% = "ternary")

    1. If ((tblctx.MODE matches pattern `NOPRI`)), then

      1. Return tblctx[MODE = (PRI)]

    2. (Let mode be tblctx.MODE)

    3. If ((mode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM _nat) be mode)

      2. Return tblctx[MODE = (PRILPM)]

  4. Case (% = "optional")

    1. If ((tblctx.MODE matches pattern `NOPRI`)), then

      1. Return tblctx[MODE = (PRI)]

    2. (Let mode be tblctx.MODE)

    3. If ((mode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM _nat) be mode)

      2. Return tblctx[MODE = (PRILPM)]

2. Otherwise

  1. Return tblctx

;; ../../../../spec/4a2-typing-tblctx.watsup:129.1-129.49
def $update_state(tblstate, tblstate')

1. Case analysis on tblstate

  1. Case (% matches pattern `NOLPM`)

    1. Case analysis on tblstate'

      1. Case (% matches pattern `LPM%`)

        1. (Let (LPM nat) be tblstate')

        2. Return (LPM nat)

      2. Case (% matches pattern `NOLPM`)

        1. Return (NOLPM)

  2. Case (% matches pattern `LPM%`)

    1. (Let (LPM nat) be tblstate)

    2. If ((tblstate' matches pattern `NOLPM`)), then

      1. Return (LPM nat)

    2. Else Phantom#569

;; ../../../../spec/4a2-typing-tblctx.watsup:139.1-139.54
def $find_action(tblctx, name)

1. (Let (name_a, pt_a*, argIL_a*)* be tblctx.ACTIONS)

2. Return $assoc_<name, (paramtyp*, argIL*)>(name, (name_a, (pt_a*, argIL_a*))*)

;; ../../../../spec/4a2-typing-tblctx.watsup:145.1-145.38
def $find_last_priority(tblctx)

1. (Let i_pri* be tblctx.PRIORITIES.VALUES)

2. Return i_pri*[(|i_pri*| - 1)]

;; ../../../../spec/4a2-typing-tblctx.watsup:154.1-154.38
def $keys_of_table(tblprop''*)

1. Case analysis on tblprop''*

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let tblprop'' :: tblprop_t* be tblprop''*)

    2. If ((tblprop'' matches pattern `KeyP%`)), then

      1. (Let (KeyP tblkeyprop) be tblprop'')

      2. Return tblkeyprop :: $keys_of_table(tblprop_t*)

    2. Else Phantom#570

    3. (Let tblprop_h :: tblprop_t* be tblprop''*)

    4. Otherwise

      1. Return $keys_of_table(tblprop_t*)

;; ../../../../spec/4a2-typing-tblctx.watsup:161.1-161.44
def $actions_of_table(tblprop''*)

1. Case analysis on tblprop''*

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let tblprop'' :: tblprop_t* be tblprop''*)

    2. If ((tblprop'' matches pattern `ActionP%`)), then

      1. (Let (ActionP tblactionprop) be tblprop'')

      2. Return tblactionprop :: $actions_of_table(tblprop_t*)

    2. Else Phantom#571

    3. (Let tblprop_h :: tblprop_t* be tblprop''*)

    4. Otherwise

      1. Return $actions_of_table(tblprop_t*)

;; ../../../../spec/4b-typing-relation.watsup:5.1-5.29
def $annot(exprIL)

1. Case analysis on exprIL

  1. Case (% matches pattern `ValueE%%`)

    1. (Let (ValueE _val annotIL) be exprIL)

    2. Return annotIL

  2. Case (% matches pattern `BoolE%%`)

    1. (Let (BoolE _bool annotIL) be exprIL)

    2. Return annotIL

  3. Case (% matches pattern `StrE%%`)

    1. (Let (StrE _text annotIL) be exprIL)

    2. Return annotIL

  4. Case (% matches pattern `NumE%%`)

    1. (Let (NumE _num annotIL) be exprIL)

    2. Return annotIL

  5. Case (% matches pattern `NameE%%`)

    1. (Let (NameE _nameIL annotIL) be exprIL)

    2. Return annotIL

  6. Case (% matches pattern `SeqE%%`)

    1. (Let (SeqE _exprIL* annotIL) be exprIL)

    2. Return annotIL

  7. Case (% matches pattern `SeqDefaultE%%`)

    1. (Let (SeqDefaultE _exprIL* annotIL) be exprIL)

    2. Return annotIL

  8. Case (% matches pattern `RecordE%%`)

    1. (Let (RecordE _(memberIL, exprIL)* annotIL) be exprIL)

    2. Return annotIL

  9. Case (% matches pattern `RecordDefaultE%%`)

    1. (Let (RecordDefaultE _(memberIL, exprIL)* annotIL) be exprIL)

    2. Return annotIL

  10. Case (% matches pattern `DefaultE%`)

    1. (Let (DefaultE annotIL) be exprIL)

    2. Return annotIL

  11. Case (% matches pattern `InvalidE%`)

    1. (Let (InvalidE annotIL) be exprIL)

    2. Return annotIL

  12. Case (% matches pattern `UnE%%%`)

    1. (Let (UnE _unopIL _exprIL annotIL) be exprIL)

    2. Return annotIL

  13. Case (% matches pattern `BinE%%%%`)

    1. (Let (BinE _binopIL _exprIL _exprIL' annotIL) be exprIL)

    2. Return annotIL

  14. Case (% matches pattern `TernE%%%%`)

    1. (Let (TernE _exprIL _exprIL' _exprIL'' annotIL) be exprIL)

    2. Return annotIL

  15. Case (% matches pattern `CastE%%%`)

    1. (Let (CastE _typeIL _exprIL annotIL) be exprIL)

    2. Return annotIL

  16. Case (% matches pattern `MaskE%%%`)

    1. (Let (MaskE _exprIL _exprIL' annotIL) be exprIL)

    2. Return annotIL

  17. Case (% matches pattern `RangeE%%%`)

    1. (Let (RangeE _exprIL _exprIL' annotIL) be exprIL)

    2. Return annotIL

  18. Case (% matches pattern `SelectE%%%`)

    1. (Let (SelectE _exprIL* _selectcaseIL* annotIL) be exprIL)

    2. Return annotIL

  19. Case (% matches pattern `ArrAccE%%%`)

    1. (Let (ArrAccE _exprIL _exprIL' annotIL) be exprIL)

    2. Return annotIL

  20. Case (% matches pattern `BitAccE%%%%`)

    1. (Let (BitAccE _exprIL _exprIL' _exprIL'' annotIL) be exprIL)

    2. Return annotIL

  21. Case (% matches pattern `ErrAccE%%`)

    1. (Let (ErrAccE _memberIL annotIL) be exprIL)

    2. Return annotIL

  22. Case (% matches pattern `TypeAccE%%%`)

    1. (Let (TypeAccE _nameIL _memberIL annotIL) be exprIL)

    2. Return annotIL

  23. Case (% matches pattern `ExprAccE%%%`)

    1. (Let (ExprAccE _exprIL _memberIL annotIL) be exprIL)

    2. Return annotIL

  24. Case (% matches pattern `CallFuncE%%%%`)

    1. (Let (CallFuncE _nameIL _targIL* _argIL* annotIL) be exprIL)

    2. Return annotIL

  25. Case (% matches pattern `CallMethodE%%%%%`)

    1. (Let (CallMethodE _exprIL _memberIL _targIL* _argIL* annotIL) be exprIL)

    2. Return annotIL

  26. Case (% matches pattern `CallTypeE%%%%%`)

    1. (Let (CallTypeE _nameIL _memberIL _targIL* _argIL* annotIL) be exprIL)

    2. Return annotIL

  27. Case (% matches pattern `InstE%%%%%`)

    1. (Let (InstE _nameIL _targIL* _targIL'* _argIL* annotIL) be exprIL)

    2. Return annotIL

;; ../../../../spec/4b-typing-relation.watsup:40.1-42.23
relation Eval_static: p, C, exprIL''

1. Case analysis on exprIL''

  1. Case (% matches pattern `ValueE%%`)

    1. (Let (ValueE val annotIL) be exprIL'')

    2. Result in (val (ValueE val annotIL))

  2. Case (% matches pattern `BoolE%%`)

    1. (Let (BoolE b annotIL) be exprIL'')

    2. Result in ((BoolV b) (BoolE b annotIL))

  3. Case (% matches pattern `StrE%%`)

    1. (Let (StrE t annotIL) be exprIL'')

    2. Result in ((StrV t) (StrE t annotIL))

  4. Case (% matches pattern `NumE%%`)

    1. (Let (NumE num annotIL) be exprIL'')

    2. Case analysis on num

      1. Case (% matches pattern `INT%`)

        1. (Let (INT i) be num)

        2. Result in ((IntV i) (NumE (INT i) annotIL))

      2. Case (% matches pattern `FINT%%`)

        1. (Let (FINT w i) be num)

        2. (Let bs be $to_bitstr((w as int), i))

        3. Result in ((FIntV w bs) (NumE (FINT w i) annotIL))

      3. Case (% matches pattern `FBIT%%`)

        1. (Let (FBIT w i) be num)

        2. (Let bs be $to_bitstr((w as int), i))

        3. Result in ((FBitV w bs) (NumE (FBIT w i) annotIL))

  5. Case (% matches pattern `NameE%%`)

    1. (Let (NameE name annotIL) be exprIL'')

    2. (Let val'? be $find_val(p, C, name))

    3. If ((val'? matches pattern (_))), then

      1. (Let ?(val) be val'?)

      2. Result in (val (NameE name annotIL))

    3. Else Phantom#572

  6. Case (% matches pattern `SeqE%%`)

    1. (Let (SeqE exprIL''* annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL'' ~> (val _exprIL))*

    3. Result in ((SeqV val*) (SeqE exprIL''* annotIL))

  7. Case (% matches pattern `SeqDefaultE%%`)

    1. (Let (SeqDefaultE exprIL''* annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL'' ~> (val _exprIL))*

    3. Result in ((SeqDefaultV val*) (SeqDefaultE exprIL''* annotIL))

  8. Case (% matches pattern `RecordE%%`)

    1. (Let (RecordE (member, exprIL'')* annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL'' ~> (val _exprIL))*

    3. Result in ((RecordV (member, val)*) (RecordE (member, exprIL'')* annotIL))

  9. Case (% matches pattern `RecordDefaultE%%`)

    1. (Let (RecordDefaultE (member, exprIL'')* annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL'' ~> (val _exprIL))*

    3. Result in ((RecordDefaultV (member, val)*) (RecordDefaultE (member, exprIL'')* annotIL))

  10. Case (% matches pattern `DefaultE%`)

    1. (Let (DefaultE annotIL) be exprIL'')

    2. Result in ((DefaultV) (DefaultE annotIL))

  11. Case (% matches pattern `InvalidE%`)

    1. (Let (InvalidE annotIL) be exprIL'')

    2. Result in ((InvalidV) (InvalidE annotIL))

  12. Case (% matches pattern `UnE%%%`)

    1. (Let (UnE unop exprIL'' annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL'' ~> (val _exprIL))

    3. Result in ($un_op(unop, val) (UnE unop exprIL'' annotIL))

  13. Case (% matches pattern `BinE%%%%`)

    1. (Let (BinE binop exprIL_l exprIL_r annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL_l ~> (val_l _exprIL))

    3. (Eval_static: p C |- exprIL_r ~> (val_r _exprIL'))

    4. Result in ($bin_op(binop, val_l, val_r) (BinE binop exprIL_l exprIL_r annotIL))

  14. Case (% matches pattern `TernE%%%%`)

    1. (Let (TernE exprIL_c exprIL_t exprIL_f annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL_c ~> (val' _exprIL))

    3. If ((val' = (BoolV true))), then

      1. (Eval_static: p C |- exprIL_t ~> (val _exprIL'))

      2. Result in (val (TernE exprIL_c exprIL_t exprIL_f annotIL))

    3. Else Phantom#573

    4. If ((val' = (BoolV false))), then

      1. (Eval_static: p C |- exprIL_f ~> (val _exprIL'))

      2. Result in (val (TernE exprIL_c exprIL_t exprIL_f annotIL))

    4. Else Phantom#574

  15. Case (% matches pattern `CastE%%%`)

    1. (Let (CastE typ exprIL'' annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL'' ~> (val _exprIL))

    3. Result in ($cast_op(typ, val) (CastE typ exprIL'' annotIL))

  16. Case (% matches pattern `BitAccE%%%%`)

    1. (Let (BitAccE exprIL_b exprIL_l exprIL_h annotIL) be exprIL'')

    2. (Eval_static: p C |- exprIL_b ~> (val_b _exprIL))

    3. (Eval_static: p C |- exprIL_l ~> (val_l _exprIL'))

    4. (Eval_static: p C |- exprIL_h ~> (val_h _exprIL''))

    5. Result in ($bitacc_op(val_b, val_h, val_l) (BitAccE exprIL_b exprIL_l exprIL_h annotIL))

  17. Case (% matches pattern `ErrAccE%%`)

    1. (Let (ErrAccE member annotIL) be exprIL'')

    2. (Let id be $concat_text(["error.", member]))

    3. If ((?((ErrV member)) = $find_val(p, C, (TOP id)))), then

      1. Result in ((ErrV member) (ErrAccE member annotIL))

    3. Else Phantom#575

  18. Case (% matches pattern `TypeAccE%%%`)

    1. (Let (TypeAccE name member annotIL) be exprIL'')

    2. (Let typdef'? be $find_typdef(p, C, name))

    3. If ((typdef'? matches pattern (_))), then

      1. (Let ?(typdef) be typdef'?)

      2. If ((typdef has type monotypdef)), then

        1. (Let (MonoD typ) be (typdef as monotypdef))

        2. (Let typ' be $canon_typ(typ))

        3. If ((typ' has type datatyp)), then

          1. (Let datatyp be (typ' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `EnumT%%`)

              1. (Let (EnumT id_t member_t*) be datatyp)

              2. If (member is in member_t*), then

                1. Result in ((EnumFieldV id_t member) (TypeAccE name member annotIL))

              2. Else Phantom#576

            2. Case (% matches pattern `SEnumT%%%`)

              1. (Let (SEnumT id_t typ_t (member_t, val_t)*) be datatyp)

              2. (Let val'? be $assoc_<member, val>(member, (member_t, val_t)*))

              3. If ((val'? matches pattern (_))), then

                1. (Let ?(val) be val'?)

                2. Result in ((SEnumFieldV id_t member val) (TypeAccE name member annotIL))

              3. Else Phantom#577

          2. Else Phantom#578

        3. Else Phantom#579

      2. Else Phantom#580

    3. Else Phantom#581

  19. Case (% matches pattern `ExprAccE%%%`)

    1. (Let (ExprAccE exprIL_b text annotIL) be exprIL'')

    2. If ((text = "size")), then

      1. (Eval_static: p C |- exprIL_b ~> (val' _exprIL))

      2. If ((val' matches pattern `StackV%%%`)), then

        1. (Let (StackV val* i_size i_idx) be val')

        2. Result in ((IntV i_size) (ExprAccE exprIL_b "size" annotIL))

      2. Else Phantom#582

    2. Else Phantom#583

  20. Case (% matches pattern `CallMethodE%%%%%`)

    1. (Let (CallMethodE exprIL_b member targIL* argIL* annotIL) be exprIL'')

    2. If ((targIL* matches pattern [])), then

      1. If ((argIL* matches pattern [])), then

        1. If (((((member = "minSizeInBits") \/ (member = "minSizeInBytes")) \/ (member = "maxSizeInBits")) \/ (member = "maxSizeInBytes"))), then

          1. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

          2. (Let val be $size(typ_b, member))

          3. Result in (val (CallMethodE exprIL_b member [] [] annotIL))

        1. Else Phantom#584

      1. Else Phantom#585

    2. Else Phantom#586

  21. Case (% matches pattern `CallTypeE%%%%%`)

    1. (Let (CallTypeE name member targIL* argIL* annotIL) be exprIL'')

    2. If ((targIL* matches pattern [])), then

      1. If ((argIL* matches pattern [])), then

        1. If (((((member = "minSizeInBits") \/ (member = "minSizeInBytes")) \/ (member = "maxSizeInBits")) \/ (member = "maxSizeInBytes"))), then

          1. (Let typdef'? be $find_typdef(p, C, name))

          2. If ((typdef'? matches pattern (_))), then

            1. (Let ?(typdef) be typdef'?)

            2. If ((typdef has type monotypdef)), then

              1. (Let (MonoD typ) be (typdef as monotypdef))

              2. Result in ($size(typ, member) (CallTypeE name member [] [] annotIL))

            2. Else Phantom#587

          2. Else Phantom#588

        1. Else Phantom#589

      1. Else Phantom#590

    2. Else Phantom#591

1. Else Phantom#592

;; ../../../../spec/4b-typing-relation.watsup:49.1-51.23
relation Type_ok: p, C, type''

1. Case analysis on type''

  1. Case (% matches pattern `VoidT`)

    1. Result in ((VoidT) as typ), []

  2. Case (% matches pattern `ErrT`)

    1. Result in ((ErrT) as typ), []

  3. Case (% matches pattern `MatchKindT`)

    1. Result in ((MatchKindT) as typ), []

  4. Case (% matches pattern `StrT`)

    1. Result in ((StrT) as typ), []

  5. Case (% matches pattern `BoolT`)

    1. Result in ((BoolT) as typ), []

  6. Case (% matches pattern `IntT`)

    1. Result in ((IntT) as typ), []

  7. Case (% matches pattern `FIntT%`)

    1. (Let (FIntT expr) be type'')

    2. (Expr_ok: p C |- expr : exprIL)

    3. (Let (( _typ ; ctk )) be $annot(exprIL))

    4. If ((ctk matches pattern `LCTK`)), then

      1. (Eval_static: p C |- exprIL ~> (val _exprIL))

      2. (Let int be $get_num(val))

      3. If ((int has type nat)), then

        1. (Let w be (int as nat))

        2. If ((w > 0)), then

          1. Result in ((FIntT w) as typ), []

        2. Else Phantom#593

      3. Else Phantom#594

    4. Else Phantom#595

  8. Case (% matches pattern `FBitT%`)

    1. (Let (FBitT expr) be type'')

    2. (Expr_ok: p C |- expr : exprIL)

    3. (Let (( _typ ; ctk )) be $annot(exprIL))

    4. If ((ctk matches pattern `LCTK`)), then

      1. (Eval_static: p C |- exprIL ~> (val _exprIL))

      2. (Let int be $get_num(val))

      3. If ((int has type nat)), then

        1. (Let w be (int as nat))

        2. Result in ((FBitT w) as typ), []

      3. Else Phantom#596

    4. Else Phantom#597

  9. Case (% matches pattern `VBitT%`)

    1. (Let (VBitT expr) be type'')

    2. (Expr_ok: p C |- expr : exprIL)

    3. (Let (( _typ ; ctk )) be $annot(exprIL))

    4. If ((ctk matches pattern `LCTK`)), then

      1. (Eval_static: p C |- exprIL ~> (val _exprIL))

      2. (Let int be $get_num(val))

      3. If ((int has type nat)), then

        1. (Let w be (int as nat))

        2. Result in ((VBitT w) as typ), []

      3. Else Phantom#598

    4. Else Phantom#599

  10. Case (% matches pattern `StackT%%`)

    1. (Let (StackT type'' expr) be type'')

    2. (Type_ok: p C |- type'' : typ tid_fresh*)

    3. (Expr_ok: p C |- expr : exprIL)

    4. (Let (( _typ ; ctk )) be $annot(exprIL))

    5. If ((ctk matches pattern `LCTK`)), then

      1. (Eval_static: p C |- exprIL ~> (val _exprIL))

      2. (Let i_size be $get_num(val))

      3. (Let ptd be (PolyD (["T"], []) -> ((StackT ((VarT "T") as typ) i_size) as typ)))

      4. Result in ((SpecT ptd [typ]) as typ), tid_fresh*

    5. Else Phantom#600

  11. Case (% matches pattern `ListT%`)

    1. (Let (ListT type'') be type'')

    2. (Type_ok: p C |- type'' : typ tid_fresh*)

    3. (Let ptd be (PolyD (["T"], []) -> ((ListT ((VarT "T") as typ)) as typ)))

    4. Result in ((SpecT ptd [typ]) as typ), tid_fresh*

  12. Case (% matches pattern `TupleT%`)

    1. (Let (TupleT type''*) be type'')

    2. (Type_ok: p C |- type'' : typ tid_fresh_i*)*

    3. (Let tid_fresh* be $concat_<tid>(tid_fresh_i**))

    4. (Let i_idx* be ($init_(|typ*|) as int*))

    5. (Let tid be $concat_text(["T", $int_to_text(i_idx)]))*

    6. (Let ptd be (PolyD (tid*, []) -> ((TupleT ((VarT tid) as typ)*) as typ)))

    7. Result in ((SpecT ptd typ*) as typ), tid_fresh*

  13. Case (% matches pattern `NameT%`)

    1. (Let (NameT name) be type'')

    2. (Let typdef'? be $find_typdef(p, C, name))

    3. If ((typdef'? matches pattern (_))), then

      1. (Let ?(typdef) be typdef'?)

      2. Case analysis on typdef

        1. Case (% has type monotypdef)

          1. (Let (MonoD typ) be (typdef as monotypdef))

          2. Result in typ, []

        2. Case (% has type polytypdef)

          1. (Let (PolyD (tparam*, tparam_hidden*) -> typ) be (typdef as polytypdef))

          2. (Let ptd be (PolyD (tparam*, tparam_hidden*) -> typ))

          3. Result in ((SpecT ptd []) as typ), []

    3. Else Phantom#601

  14. Case (% matches pattern `SpecT%%`)

    1. (Let (SpecT name type''*) be type'')

    2. If ((type''* matches pattern [])), then

      1. (Let typdef'? be $find_typdef(p, C, name))

      2. If ((typdef'? matches pattern (_))), then

        1. (Let ?(typdef) be typdef'?)

        2. If ((typdef has type monotypdef)), then

          1. (Let (MonoD typ) be (typdef as monotypdef))

          2. Result in typ, []

        2. Else Phantom#602

      2. Else Phantom#603

    2. Else Phantom#604

    3. (Let typdef'? be $find_typdef(p, C, name))

    4. If ((typdef'? matches pattern (_))), then

      1. (Let ?(typdef) be typdef'?)

      2. If ((typdef has type polytypdef)), then

        1. (Let ptd be (typdef as polytypdef))

        2. (Let (PolyD (tparam*, tparam_hidden*) -> typ) be ptd)

        3. (Type_ok: p C |- type'' : typ_a tid_fresh_a*)*

        4. (Let tid_fresh* be $concat_<tid>(tid_fresh_a**))

        5. Result in ((SpecT ptd typ_a*) as typ), tid_fresh*

      2. Else Phantom#605

    4. Else Phantom#606

  15. Case (% matches pattern `AnyT`)

    1. (Let tid be $fresh_tid)

    2. Result in ((VarT tid) as typ), [tid]

;; ../../../../spec/4b-typing-relation.watsup:54.1-56.20
relation Sub_expl: typ_a, typ_b

1. If ((Sub_expl_canon: $canon_typ(typ_a) <: $canon_typ(typ_b) holds)), then

  1. The relation holds

1. Else Phantom#607

;; ../../../../spec/4b-typing-relation.watsup:57.1-59.20
relation Sub_expl_canon: typ_a, typ_b

1. Case analysis on (Type_alpha: typ_a ~~ typ_b holds)

  1. Case true

    1. The relation holds

  2. Case false

    1. If ((Sub_expl_canon_neq: typ_a <: typ_b holds)), then

      1. The relation holds

    1. Else Phantom#608

;; ../../../../spec/4b-typing-relation.watsup:60.1-62.20
relation Sub_expl_canon_neq: typ''''', typ''''''

1. If ((typ''''' = ((FBitT 1) as typ))), then

  1. If ((typ'''''' = ((BoolT) as typ))), then

    1. The relation holds

  1. Else Phantom#609

1. Else Phantom#610

2. If ((typ''''' = ((BoolT) as typ))), then

  1. If ((typ'''''' = ((FBitT 1) as typ))), then

    1. The relation holds

  1. Else Phantom#611

2. Else Phantom#612

3. If ((typ''''' = ((IntT) as typ))), then

  1. If ((typ'''''' = ((BoolT) as typ))), then

    1. The relation holds

  1. Else Phantom#613

  2. If ((typ'''''' has type numtyp)), then

    1. (Let numtyp be (typ'''''' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT width) be numtyp)

        2. The relation holds

      2. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT width) be numtyp)

        2. The relation holds

    2. Else Phantom#614

  2. Else Phantom#615

3. Else Phantom#616

4. Case analysis on typ'''''

  1. Case (% has type numtyp)

    1. (Let numtyp be (typ''''' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT width) be numtyp)

        2. If ((typ'''''' has type numtyp)), then

          1. (Let numtyp' be (typ'''''' as numtyp))

          2. Case analysis on numtyp'

            1. Case (% matches pattern `FBitT%`)

              1. (Let (FBitT width') be numtyp')

              2. If ((width = width')), then

                1. The relation holds

              2. Else Phantom#617

            2. Case (% matches pattern `FIntT%`)

              1. (Let (FIntT width_b) be numtyp')

              2. The relation holds

          2. Else Phantom#618

        2. Else Phantom#619

        3. If ((typ'''''' = ((IntT) as typ))), then

          1. The relation holds

        3. Else Phantom#620

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT width) be numtyp)

        2. If ((typ'''''' has type numtyp)), then

          1. (Let numtyp' be (typ'''''' as numtyp))

          2. Case analysis on numtyp'

            1. Case (% matches pattern `FIntT%`)

              1. (Let (FIntT width') be numtyp')

              2. If ((width = width')), then

                1. The relation holds

              2. Else Phantom#621

            2. Case (% matches pattern `FBitT%`)

              1. (Let (FBitT width_b) be numtyp')

              2. The relation holds

          2. Else Phantom#622

        2. Else Phantom#623

        3. If ((typ'''''' = ((IntT) as typ))), then

          1. The relation holds

        3. Else Phantom#624

    2. Else Phantom#625

  2. Case (% has type datatyp)

    1. (Let datatyp be (typ''''' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ_a) be datatyp)

        2. If ((Sub_impl: typ_a << typ'''''' holds)), then

          1. The relation holds

        2. Else Phantom#626

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ''''' _(member, val)*) be datatyp)

        2. If ((Sub_impl: typ''''' << typ'''''' holds)), then

          1. The relation holds

        2. Else Phantom#627

    2. Else Phantom#628

  3. Case (% has type synthtyp)

    1. (Let synthtyp be (typ''''' as synthtyp))

    2. Case analysis on synthtyp

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typ'''''*) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `ListT%`)

              1. (Let (ListT typ'''''') be datatyp)

              2. If ((Sub_expl: typ''''' <: typ'''''' holds))*, then

                1. The relation holds

              2. Else Phantom#629

            2. Case (% matches pattern `TupleT%`)

              1. (Let (TupleT typ''''''*) be datatyp)

              2. If ((Sub_expl: typ''''' <: typ'''''' holds))*, then

                1. The relation holds

              2. Else Phantom#630

            3. Case (% matches pattern `StackT%%`)

              1. (Let (StackT typ'''''' i_size) be datatyp)

              2. If (((|typ'''''*| as int) <= i_size)), then

                1. If ((Sub_expl: typ''''' <: typ'''''' holds))*, then

                  1. The relation holds

                1. Else Phantom#631

              2. Else Phantom#632

            4. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (_member, typ'''''')*) be datatyp)

              2. If ((Sub_expl: typ''''' <: typ'''''' holds))*, then

                1. The relation holds

              2. Else Phantom#633

            5. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT _id (_member, typ'''''')*) be datatyp)

              2. If ((Sub_expl: typ''''' <: typ'''''' holds))*, then

                1. The relation holds

              2. Else Phantom#634

          2. Else Phantom#635

        2. Else Phantom#636

      2. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (member_a, typ''''')*) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (member_b, typ'''''')*) be datatyp)

              2. If ($eq_set<member>(({ member_a* }), ({ member_b* }))), then

                1. (Let typ''? be $find_map<member, typ>(({ (member_a -> typ''''')* }), member_a))*

                2. If ((typ''? matches pattern (_)))*, then

                  1. (Let ?(typ_a') be typ''?)*

                  2. (Let typ'''? be $find_map<member, typ>(({ (member_b -> typ'''''')* }), member_a))*

                  3. If ((typ'''? matches pattern (_)))*, then

                    1. (Let ?(typ_b') be typ'''?)*

                    2. If ((Sub_expl: typ_a' <: typ_b' holds))*, then

                      1. The relation holds

                    2. Else Phantom#637

                  3. Else Phantom#638

                2. Else Phantom#639

              2. Else Phantom#640

            2. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT _id (member_b, typ'''''')*) be datatyp)

              2. If ($eq_set<member>(({ member_a* }), ({ member_b* }))), then

                1. (Let typ''? be $find_map<member, typ>(({ (member_a -> typ''''')* }), member_a))*

                2. If ((typ''? matches pattern (_)))*, then

                  1. (Let ?(typ_a') be typ''?)*

                  2. (Let typ'''? be $find_map<member, typ>(({ (member_b -> typ'''''')* }), member_a))*

                  3. If ((typ'''? matches pattern (_)))*, then

                    1. (Let ?(typ_b') be typ'''?)*

                    2. If ((Sub_expl: typ_a' <: typ_b' holds))*, then

                      1. The relation holds

                    2. Else Phantom#641

                  3. Else Phantom#642

                2. Else Phantom#643

              2. Else Phantom#644

          2. Else Phantom#645

        2. Else Phantom#646

      3. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typ'''''*) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `TupleT%`)

              1. (Let (TupleT typ''''''*) be datatyp)

              2. If ((|typ'''''*| < |typ''''''*|)), then

                1. (Let (typ_c*, typ_d*) be $partition_<typ>(typ''''''*, |typ'''''*|))

                2. If ((Sub_expl: typ''''' <: typ_c holds))*, then

                  1. If ($is_deftable(typ_d))*, then

                    1. The relation holds

                  1. Else Phantom#647

                2. Else Phantom#648

              2. Else Phantom#649

            2. Case (% matches pattern `StackT%%`)

              1. (Let (StackT typ'''''' i_size) be datatyp)

              2. If (((|typ'''''*| as int) < i_size)), then

                1. If ((Sub_expl: typ''''' <: typ'''''' holds))*, then

                  1. If ($is_deftable(typ'''''')), then

                    1. The relation holds

                  1. Else Phantom#650

                1. Else Phantom#651

              2. Else Phantom#652

            3. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (_member, typ'''''')*) be datatyp)

              2. If ((|typ'''''*| < |typ''''''*|)), then

                1. (Let (typ_c*, typ_d*) be $partition_<typ>(typ''''''*, |typ'''''*|))

                2. If ((Sub_expl: typ''''' <: typ_c holds))*, then

                  1. If ($is_deftable(typ_d))*, then

                    1. The relation holds

                  1. Else Phantom#653

                2. Else Phantom#654

              2. Else Phantom#655

            4. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT _id (_member, typ'''''')*) be datatyp)

              2. If ((|typ'''''*| < |typ''''''*|)), then

                1. (Let (typ_c*, typ_d*) be $partition_<typ>(typ''''''*, |typ'''''*|))

                2. If ((Sub_expl: typ''''' <: typ_c holds))*, then

                  1. If ($is_deftable(typ_d))*, then

                    1. The relation holds

                  1. Else Phantom#656

                2. Else Phantom#657

              2. Else Phantom#658

          2. Else Phantom#659

        2. Else Phantom#660

      4. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (member_a, typ''''')*) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (member_b, typ'''''')*) be datatyp)

              2. If ($sub_set<member>(({ member_a* }), ({ member_b* }))), then

                1. (Let ({ member_c* }) be $diff_set<member>(({ member_b* }), ({ member_a* })))

                2. (Let typ''? be $find_map<member, typ>(({ (member_a -> typ''''')* }), member_a))*

                3. If ((typ''? matches pattern (_)))*, then

                  1. (Let ?(typ_a') be typ''?)*

                  2. (Let typ'''? be $find_map<member, typ>(({ (member_b -> typ'''''')* }), member_a))*

                  3. If ((typ'''? matches pattern (_)))*, then

                    1. (Let ?(typ_b') be typ'''?)*

                    2. If ((Sub_expl: typ_a' <: typ_b' holds))*, then

                      1. If ((typ'''? matches pattern (_)))*, then

                        1. (Let ?(typ_c') be typ'''?)*

                        2. If ($is_deftable(typ_c'))*, then

                          1. The relation holds

                        2. Else Phantom#661

                      1. Else Phantom#662

                    2. Else Phantom#663

                  3. Else Phantom#664

                3. Else Phantom#665

              2. Else Phantom#666

            2. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT _id (member_b, typ'''''')*) be datatyp)

              2. If ($sub_set<member>(({ member_a* }), ({ member_b* }))), then

                1. (Let ({ member_c* }) be $diff_set<member>(({ member_b* }), ({ member_a* })))

                2. (Let typ''? be $find_map<member, typ>(({ (member_a -> typ''''')* }), member_a))*

                3. If ((typ''? matches pattern (_)))*, then

                  1. (Let ?(typ_a') be typ''?)*

                  2. (Let typ'''? be $find_map<member, typ>(({ (member_b -> typ'''''')* }), member_a))*

                  3. If ((typ'''? matches pattern (_)))*, then

                    1. (Let ?(typ_b') be typ'''?)*

                    2. If ((Sub_expl: typ_a' <: typ_b' holds))*, then

                      1. If ((typ'''? matches pattern (_)))*, then

                        1. (Let ?(typ_c') be typ'''?)*

                        2. If ($is_deftable(typ_c'))*, then

                          1. The relation holds

                        2. Else Phantom#667

                      1. Else Phantom#668

                    2. Else Phantom#669

                  3. Else Phantom#670

                3. Else Phantom#671

              2. Else Phantom#672

          2. Else Phantom#673

        2. Else Phantom#674

      5. Case (% matches pattern `SetT%`)

        1. (Let (SetT typ''''') be synthtyp)

        2. If ((typ'''''' has type synthtyp)), then

          1. (Let synthtyp' be (typ'''''' as synthtyp))

          2. If ((synthtyp' matches pattern `SetT%`)), then

            1. (Let (SetT typ'''''') be synthtyp')

            2. If ((Sub_expl: typ''''' <: typ'''''' holds)), then

              1. The relation holds

            2. Else Phantom#675

          2. Else Phantom#676

        2. Else Phantom#677

    2. Else Phantom#678

4. Else Phantom#679

5. Case analysis on typ''''''

  1. Case (% has type datatyp)

    1. (Let datatyp be (typ'''''' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _id typ'''''') be datatyp)

        2. If ((Sub_impl: typ''''' << typ'''''' holds)), then

          1. The relation holds

        2. Else Phantom#680

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _id typ'''''' _(member, val)*) be datatyp)

        2. If ((Sub_impl: typ''''' << typ'''''' holds)), then

          1. The relation holds

        2. Else Phantom#681

    2. Else Phantom#682

  2. Case (% has type synthtyp)

    1. (Let synthtyp be (typ'''''' as synthtyp))

    2. If ((synthtyp matches pattern `SetT%`)), then

      1. (Let (SetT typ'''''') be synthtyp)

      2. If ((Sub_expl: typ''''' <: typ'''''' holds)), then

        1. The relation holds

      2. Else Phantom#683

    2. Else Phantom#684

5. Else Phantom#685

6. If ((typ''''' = ((DefaultT) as typ))), then

  1. If ($is_deftable(typ'''''')), then

    1. The relation holds

  1. Else Phantom#686

6. Else Phantom#687

7. If ((typ''''' = ((InvalidT) as typ))), then

  1. If ((typ'''''' has type datatyp)), then

    1. (Let datatyp be (typ'''''' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id _(member, typ)*) be datatyp)

        2. The relation holds

      2. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id _(member, typ)*) be datatyp)

        2. The relation holds

    2. Else Phantom#688

  1. Else Phantom#689

7. Else Phantom#690

;; ../../../../spec/4b-typing-relation.watsup:63.1-65.20
relation Sub_impl: typ_a, typ_b

1. If ((Sub_impl_canon: $canon_typ(typ_a) << $canon_typ(typ_b) holds)), then

  1. The relation holds

1. Else Phantom#691

;; ../../../../spec/4b-typing-relation.watsup:66.1-68.20
relation Sub_impl_canon: typ_a, typ_b

1. Case analysis on (Type_alpha: typ_a ~~ typ_b holds)

  1. Case true

    1. The relation holds

  2. Case false

    1. If ((Sub_impl_canon_neq: typ_a << typ_b holds)), then

      1. The relation holds

    1. Else Phantom#692

;; ../../../../spec/4b-typing-relation.watsup:69.1-71.20
relation Sub_impl_canon_neq: typ''''', typ''''''

1. If ((typ''''' = ((IntT) as typ))), then

  1. If ((typ'''''' has type numtyp)), then

    1. (Let numtyp be (typ'''''' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. The relation holds

      2. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. The relation holds

    2. Else Phantom#693

  1. Else Phantom#694

1. Else Phantom#695

2. Case analysis on typ'''''

  1. Case (% has type datatyp)

    1. (Let datatyp be (typ''''' as datatyp))

    2. If ((datatyp matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _id typ_a _(member, val)*) be datatyp)

      2. If ((Sub_impl: typ_a << typ'''''' holds)), then

        1. The relation holds

      2. Else Phantom#696

    2. Else Phantom#697

  2. Case (% has type synthtyp)

    1. (Let synthtyp be (typ''''' as synthtyp))

    2. Case analysis on synthtyp

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typ_a*) be synthtyp)

        2. Case analysis on typ''''''

          1. Case (% has type datatyp)

            1. (Let datatyp be (typ'''''' as datatyp))

            2. Case analysis on datatyp

              1. Case (% matches pattern `ListT%`)

                1. (Let (ListT typ'''''') be datatyp)

                2. If ((Sub_impl: typ_a << typ'''''' holds))*, then

                  1. The relation holds

                2. Else Phantom#698

              2. Case (% matches pattern `TupleT%`)

                1. (Let (TupleT typ''''''*) be datatyp)

                2. If ((Sub_impl: typ_a << typ'''''' holds))*, then

                  1. The relation holds

                2. Else Phantom#699

              3. Case (% matches pattern `StackT%%`)

                1. (Let (StackT typ'''''' i_size) be datatyp)

                2. If (((|typ_a*| as int) <= i_size)), then

                  1. If ((Sub_impl: typ_a << typ'''''' holds))*, then

                    1. The relation holds

                  1. Else Phantom#700

                2. Else Phantom#701

              4. Case (% matches pattern `StructT%%`)

                1. (Let (StructT _id (_member, typ'''''')*) be datatyp)

                2. If ((Sub_impl: typ_a << typ'''''' holds))*, then

                  1. The relation holds

                2. Else Phantom#702

              5. Case (% matches pattern `HeaderT%%`)

                1. (Let (HeaderT _id (_member, typ'''''')*) be datatyp)

                2. If ((Sub_impl: typ_a << typ'''''' holds))*, then

                  1. The relation holds

                2. Else Phantom#703

            2. Else Phantom#704

          2. Case (% has type synthtyp)

            1. (Let synthtyp' be (typ'''''' as synthtyp))

            2. If ((synthtyp' matches pattern `SeqT%`)), then

              1. (Let (SeqT typ''''''*) be synthtyp')

              2. If ((Sub_impl: typ_a << typ'''''' holds))*, then

                1. The relation holds

              2. Else Phantom#705

            2. Else Phantom#706

        2. Else Phantom#707

      2. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (member_a, typ_a)*) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (member_b, typ'''''')*) be datatyp)

              2. If ($eq_set<member>(({ member_a* }), ({ member_b* }))), then

                1. (Let typ''? be $find_map<member, typ>(({ (member_a -> typ_a)* }), member_a))*

                2. If ((typ''? matches pattern (_)))*, then

                  1. (Let ?(typ_a') be typ''?)*

                  2. (Let typ'''? be $find_map<member, typ>(({ (member_b -> typ'''''')* }), member_a))*

                  3. If ((typ'''? matches pattern (_)))*, then

                    1. (Let ?(typ_b') be typ'''?)*

                    2. If ((Sub_impl: typ_a' << typ_b' holds))*, then

                      1. The relation holds

                    2. Else Phantom#708

                  3. Else Phantom#709

                2. Else Phantom#710

              2. Else Phantom#711

            2. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT _id (member_b, typ'''''')*) be datatyp)

              2. If ($eq_set<member>(({ member_a* }), ({ member_b* }))), then

                1. (Let typ''? be $find_map<member, typ>(({ (member_a -> typ_a)* }), member_a))*

                2. If ((typ''? matches pattern (_)))*, then

                  1. (Let ?(typ_a') be typ''?)*

                  2. (Let typ'''? be $find_map<member, typ>(({ (member_b -> typ'''''')* }), member_a))*

                  3. If ((typ'''? matches pattern (_)))*, then

                    1. (Let ?(typ_b') be typ'''?)*

                    2. If ((Sub_impl: typ_a' << typ_b' holds))*, then

                      1. The relation holds

                    2. Else Phantom#712

                  3. Else Phantom#713

                2. Else Phantom#714

              2. Else Phantom#715

          2. Else Phantom#716

        2. Else Phantom#717

      3. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typ_a*) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `TupleT%`)

              1. (Let (TupleT typ''''''*) be datatyp)

              2. If ((|typ_a*| < |typ''''''*|)), then

                1. (Let (typ_c*, typ_d*) be $partition_<typ>(typ''''''*, |typ_a*|))

                2. If ((Sub_impl: typ_a << typ_c holds))*, then

                  1. If ($is_deftable(typ_d))*, then

                    1. The relation holds

                  1. Else Phantom#718

                2. Else Phantom#719

              2. Else Phantom#720

            2. Case (% matches pattern `StackT%%`)

              1. (Let (StackT typ'''''' i_size) be datatyp)

              2. If (((|typ_a*| as int) < i_size)), then

                1. If ((Sub_impl: typ_a << typ'''''' holds))*, then

                  1. If ($is_deftable(typ'''''')), then

                    1. The relation holds

                  1. Else Phantom#721

                1. Else Phantom#722

              2. Else Phantom#723

            3. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (_member, typ'''''')*) be datatyp)

              2. If ((|typ_a*| < |typ''''''*|)), then

                1. (Let (typ_c*, typ_d*) be $partition_<typ>(typ''''''*, |typ_a*|))

                2. If ((Sub_impl: typ_a << typ_c holds))*, then

                  1. If ($is_deftable(typ_d))*, then

                    1. The relation holds

                  1. Else Phantom#724

                2. Else Phantom#725

              2. Else Phantom#726

            4. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT _id (_member, typ'''''')*) be datatyp)

              2. If ((|typ_a*| < |typ''''''*|)), then

                1. (Let (typ_c*, typ_d*) be $partition_<typ>(typ''''''*, |typ_a*|))

                2. If ((Sub_impl: typ_a << typ_c holds))*, then

                  1. If ($is_deftable(typ_d))*, then

                    1. The relation holds

                  1. Else Phantom#727

                2. Else Phantom#728

              2. Else Phantom#729

          2. Else Phantom#730

        2. Else Phantom#731

      4. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (member_a, typ_a)*) be synthtyp)

        2. If ((typ'''''' has type datatyp)), then

          1. (Let datatyp be (typ'''''' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `StructT%%`)

              1. (Let (StructT _id (member_b, typ'''''')*) be datatyp)

              2. If ($sub_set<member>(({ member_a* }), ({ member_b* }))), then

                1. (Let ({ member_c* }) be $diff_set<member>(({ member_b* }), ({ member_a* })))

                2. (Let typ''? be $find_map<member, typ>(({ (member_a -> typ_a)* }), member_a))*

                3. If ((typ''? matches pattern (_)))*, then

                  1. (Let ?(typ_a') be typ''?)*

                  2. (Let typ'''? be $find_map<member, typ>(({ (member_b -> typ'''''')* }), member_a))*

                  3. If ((typ'''? matches pattern (_)))*, then

                    1. (Let ?(typ_b') be typ'''?)*

                    2. If ((Sub_impl: typ_a' << typ_b' holds))*, then

                      1. (Let typ''''? be $find_map<member, typ>(({ (member_b -> typ'''''')* }), member_c))*

                      2. If ((typ''''? matches pattern (_)))*, then

                        1. (Let ?(typ_c') be typ''''?)*

                        2. If ($is_deftable(typ_c'))*, then

                          1. The relation holds

                        2. Else Phantom#732

                      2. Else Phantom#733

                    2. Else Phantom#734

                  3. Else Phantom#735

                3. Else Phantom#736

              2. Else Phantom#737

            2. Case (% matches pattern `HeaderT%%`)

              1. (Let (HeaderT id (member_b, typ'''''')*) be datatyp)

              2. If ($sub_set<member>(({ member_a* }), ({ member_b* }))), then

                1. (Let ({ member_c* }) be $diff_set<member>(({ member_b* }), ({ member_a* })))

                2. (Let typ''? be $find_map<member, typ>(({ (member_a -> typ_a)* }), member_a))*

                3. If ((typ''? matches pattern (_)))*, then

                  1. (Let ?(typ_a') be typ''?)*

                  2. (Let typ'''? be $find_map<member, typ>(({ (member_b -> typ'''''')* }), member_a))*

                  3. If ((typ'''? matches pattern (_)))*, then

                    1. (Let ?(typ_b') be typ'''?)*

                    2. If ((Sub_impl: typ_a' << typ_b' holds))*, then

                      1. (Let typ''''? be $find_map<member, typ>(({ (member_b -> typ'''''')* }), member_c))*

                      2. If ((typ''''? matches pattern (_)))*, then

                        1. (Let ?(typ_c') be typ''''?)*

                        2. If ($is_deftable(typ_c'))*, then

                          1. The relation holds

                        2. Else Phantom#738

                      2. Else Phantom#739

                    2. Else Phantom#740

                  3. Else Phantom#741

                3. Else Phantom#742

              2. Else Phantom#743

          2. Else Phantom#744

        2. Else Phantom#745

    2. Else Phantom#746

2. Else Phantom#747

3. If ((typ''''' = ((DefaultT) as typ))), then

  1. If ($is_deftable(typ'''''')), then

    1. The relation holds

  1. Else Phantom#748

3. Else Phantom#749

4. If ((typ''''' = ((InvalidT) as typ))), then

  1. If ((typ'''''' has type datatyp)), then

    1. (Let datatyp be (typ'''''' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT _id _(member, typ)*) be datatyp)

        2. The relation holds

      2. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT _id _(member, typ)*) be datatyp)

        2. The relation holds

    2. Else Phantom#750

  1. Else Phantom#751

4. Else Phantom#752

;; ../../../../spec/4b-typing-relation.watsup:81.1-83.23
relation Expr_ok: p', C, expr''

1. Case analysis on expr''

  1. Case (% matches pattern `BoolE%`)

    1. (Let (BoolE b) be expr'')

    2. Result in (BoolE b (( ((BoolT) as typ) ; (LCTK) )))

  2. Case (% matches pattern `StrE%`)

    1. (Let (StrE t) be expr'')

    2. Result in (StrE t (( ((StrT) as typ) ; (LCTK) )))

  3. Case (% matches pattern `NumE%`)

    1. (Let (NumE num) be expr'')

    2. Case analysis on num

      1. Case (% matches pattern `INT%`)

        1. (Let (INT i) be num)

        2. Result in (NumE (INT i) (( ((IntT) as typ) ; (LCTK) )))

      2. Case (% matches pattern `FINT%%`)

        1. (Let (FINT w i) be num)

        2. (Let bs be $to_bitstr((w as int), i))

        3. Result in (NumE (FINT w i) (( ((FIntT w) as typ) ; (LCTK) )))

      3. Case (% matches pattern `FBIT%%`)

        1. (Let (FBIT w i) be num)

        2. (Let bs be $to_bitstr((w as int), i))

        3. Result in (NumE (FBIT w i) (( ((FBitT w) as typ) ; (LCTK) )))

  4. Case (% matches pattern `NameE%`)

    1. (Let (NameE name) be expr'')

    2. (Let styp? be $find_styp(p', C, name))

    3. If ((styp? matches pattern (_))), then

      1. (Let ?((typ _dir ctk _val?)) be styp?)

      2. Result in (NameE name (( typ ; ctk )))

    3. Else Phantom#753

  5. Case (% matches pattern `SeqE%`)

    1. (Let (SeqE expr''*) be expr'')

    2. (Expr_ok: p' C |- expr'' : exprIL)*

    3. (Let (( typ ; ctk )) be $annot(exprIL))*

    4. (Let ctk_e be $joins_ctk(ctk*))

    5. Result in (SeqE exprIL* (( ((SeqT typ*) as typ) ; ctk_e )))

  6. Case (% matches pattern `SeqDefaultE%`)

    1. (Let (SeqDefaultE expr''*) be expr'')

    2. (Expr_ok: p' C |- expr'' : exprIL)*

    3. (Let (( typ ; ctk )) be $annot(exprIL))*

    4. (Let ctk_e be $joins_ctk(ctk*))

    5. Result in (SeqDefaultE exprIL* (( ((SeqDefaultT typ*) as typ) ; ctk_e )))

  7. Case (% matches pattern `RecordE%`)

    1. (Let (RecordE (member, expr'')*) be expr'')

    2. (Expr_ok: p' C |- expr'' : exprIL)*

    3. (Let (( typ ; ctk )) be $annot(exprIL))*

    4. (Let ctk_e be $joins_ctk(ctk*))

    5. Result in (RecordE (member, exprIL)* (( ((RecordT (member, typ)*) as typ) ; ctk_e )))

  8. Case (% matches pattern `RecordDefaultE%`)

    1. (Let (RecordDefaultE (member, expr'')*) be expr'')

    2. (Expr_ok: p' C |- expr'' : exprIL)*

    3. (Let (( typ ; ctk )) be $annot(exprIL))*

    4. (Let ctk_e be $joins_ctk(ctk*))

    5. Result in (RecordE (member, exprIL)* (( ((RecordDefaultT (member, typ)*) as typ) ; ctk_e )))

  9. Case (% matches pattern `DefaultE`)

    1. Result in (DefaultE (( ((DefaultT) as typ) ; (LCTK) )))

  10. Case (% matches pattern `InvalidE`)

    1. Result in (InvalidE (( ((InvalidT) as typ) ; (LCTK) )))

  11. Case (% matches pattern `UnE%%`)

    1. (Let (UnE unop expr'') be expr'')

    2. Case analysis on unop

      1. Case (% matches pattern `BNOT`)

        1. (Expr_ok: p' C |- expr'' : exprIL)

        2. (Let exprIL'? be $reduce_senum_unary(exprIL, $compatible_bnot))

        3. If ((exprIL'? matches pattern (_))), then

          1. (Let ?(exprIL_e) be exprIL'?)

          2. (Let (( typ_e ; ctk_e )) be $annot(exprIL_e))

          3. Result in (UnE (BNOT) exprIL_e (( typ_e ; ctk_e )))

        3. Else Phantom#754

      2. Case (% matches pattern `LNOT`)

        1. (Expr_ok: p' C |- expr'' : exprIL)

        2. (Let exprIL'? be $reduce_senum_unary(exprIL, $compatible_lnot))

        3. If ((exprIL'? matches pattern (_))), then

          1. (Let ?(exprIL_e) be exprIL'?)

          2. (Let (( typ_e ; ctk_e )) be $annot(exprIL_e))

          3. Result in (UnE (LNOT) exprIL_e (( typ_e ; ctk_e )))

        3. Else Phantom#755

      3. Case (% matches pattern `UPLUS`)

        1. (Expr_ok: p' C |- expr'' : exprIL)

        2. (Let exprIL'? be $reduce_senum_unary(exprIL, $compatible_uplus))

        3. If ((exprIL'? matches pattern (_))), then

          1. (Let ?(exprIL_e) be exprIL'?)

          2. (Let (( typ_e ; ctk_e )) be $annot(exprIL_e))

          3. Result in (UnE (UPLUS) exprIL_e (( typ_e ; ctk_e )))

        3. Else Phantom#756

      4. Case (% matches pattern `UMINUS`)

        1. (Expr_ok: p' C |- expr'' : exprIL)

        2. (Let exprIL'? be $reduce_senum_unary(exprIL, $compatible_uminus))

        3. If ((exprIL'? matches pattern (_))), then

          1. (Let ?(exprIL_e) be exprIL'?)

          2. (Let (( typ_e ; ctk_e )) be $annot(exprIL_e))

          3. Result in (UnE (UMINUS) exprIL_e (( typ_e ; ctk_e )))

        3. Else Phantom#757

  12. Case (% matches pattern `BinE%%%`)

    1. (Let (BinE binop expr_l expr_r) be expr'')

    2. Case analysis on binop

      1. Case (% is in [(PLUS), (MINUS), (MUL)])

        1. (Expr_ok: p' C |- expr_l : exprIL_l)

        2. (Expr_ok: p' C |- expr_r : exprIL_r)

        3. (Let (exprIL, exprIL)? be $coerce_binary(exprIL_l, exprIL_r))

        4. If (((exprIL, exprIL)? matches pattern (_))), then

          1. (Let ?((exprIL_l', exprIL_r')) be (exprIL, exprIL)?)

          2. (Let (exprIL, exprIL)'? be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_plusminusmult))

          3. If (((exprIL, exprIL)'? matches pattern (_))), then

            1. (Let ?((exprIL_l'', exprIL_r'')) be (exprIL, exprIL)'?)

            2. (Let (( typ'' ; ctk_l'' )) be $annot(exprIL_l''))

            3. (Let (( _typ ; ctk_r'' )) be $annot(exprIL_r''))

            4. (Let ctk be $join_ctk(ctk_l'', ctk_r''))

            5. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

          3. Else Phantom#758

        4. Else Phantom#759

      2. Case (% is in [(SPLUS), (SMINUS)])

        1. (Expr_ok: p' C |- expr_l : exprIL_l)

        2. (Expr_ok: p' C |- expr_r : exprIL_r)

        3. (Let (exprIL, exprIL)? be $coerce_binary(exprIL_l, exprIL_r))

        4. If (((exprIL, exprIL)? matches pattern (_))), then

          1. (Let ?((exprIL_l', exprIL_r')) be (exprIL, exprIL)?)

          2. (Let (exprIL, exprIL)'? be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_satplusminus))

          3. If (((exprIL, exprIL)'? matches pattern (_))), then

            1. (Let ?((exprIL_l'', exprIL_r'')) be (exprIL, exprIL)'?)

            2. (Let (( typ'' ; ctk_l'' )) be $annot(exprIL_l''))

            3. (Let (( _typ ; ctk_r'' )) be $annot(exprIL_r''))

            4. (Let ctk be $join_ctk(ctk_l'', ctk_r''))

            5. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

          3. Else Phantom#760

        4. Else Phantom#761

      3. Case (% is in [(DIV), (MOD)])

        1. (Expr_ok: p' C |- expr_l : exprIL_l)

        2. (Expr_ok: p' C |- expr_r : exprIL_r)

        3. (Let (exprIL, exprIL)? be $coerce_binary(exprIL_l, exprIL_r))

        4. If (((exprIL, exprIL)? matches pattern (_))), then

          1. (Let ?((exprIL_l', exprIL_r')) be (exprIL, exprIL)?)

          2. (Let (exprIL, exprIL)'? be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_divmod))

          3. If (((exprIL, exprIL)'? matches pattern (_))), then

            1. (Let ?((exprIL_l'', exprIL_r'')) be (exprIL, exprIL)'?)

            2. (Let (( typ'' ; ctk_l'' )) be $annot(exprIL_l''))

            3. (Let (( _typ ; ctk' )) be $annot(exprIL_r''))

            4. Case analysis on (ctk' matches pattern `LCTK`)

              1. Case true

                1. (Eval_static: p' C |- exprIL_r'' ~> (val_r _exprIL))

                2. (Let int be $get_num(val_r))

                3. If ((int has type nat)), then

                  1. (Let n_r be (int as nat))

                  2. If ((n_r > 0)), then

                    1. (Let ctk be $join_ctk(ctk_l'', (LCTK)))

                    2. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

                  2. Else Phantom#762

                3. Else Phantom#763

              2. Case false

                1. (Let ctk be $join_ctk(ctk_l'', ctk'))

                2. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

          3. Else Phantom#764

        4. Else Phantom#765

      4. Case (% is in [(SHL), (SHR)])

        1. (Expr_ok: p' C |- expr_l : exprIL_l)

        2. (Expr_ok: p' C |- expr_r : exprIL_r)

        3. (Let (exprIL, exprIL)? be $reduce_senums_binary(exprIL_l, exprIL_r, $compatible_shift))

        4. If (((exprIL, exprIL)? matches pattern (_))), then

          1. (Let ?((exprIL_l', exprIL_r')) be (exprIL, exprIL)?)

          2. (Let (( typ_l' ; ctk_l' )) be $annot(exprIL_l'))

          3. (Let (( typ_r' ; ctk_r' )) be $annot(exprIL_r'))

          4. If ($is_fbitt(typ_r')), then

            1. (Let ctk be $join_ctk(ctk_l', ctk_r'))

            2. Result in (BinE binop exprIL_l' exprIL_r' (( typ_l' ; ctk )))

          4. Else Phantom#766

          5. If (($is_intt(typ_r') \/ $is_fintt(typ_r'))), then

            1. If ((ctk_r' matches pattern `LCTK`)), then

              1. (Eval_static: p' C |- exprIL_r' ~> (val_r' _exprIL))

              2. (Let int be $get_num(val_r'))

              3. If ((int has type nat)), then

                1. (Let n_r be (int as nat))

                2. (Let ctk be $join_ctk(ctk_l', ctk_r'))

                3. Result in (BinE binop exprIL_l' exprIL_r' (( typ_l' ; ctk )))

              3. Else Phantom#767

            1. Else Phantom#768

          5. Else Phantom#769

        4. Else Phantom#770

      5. Case (% is in [(EQ), (NE)])

        1. (Expr_ok: p' C |- expr_l : exprIL_l)

        2. (Expr_ok: p' C |- expr_r : exprIL_r)

        3. (Let (exprIL, exprIL)? be $coerce_binary(exprIL_l, exprIL_r))

        4. If (((exprIL, exprIL)? matches pattern (_))), then

          1. (Let ?((exprIL_l', exprIL_r')) be (exprIL, exprIL)?)

          2. (Let (( typ' ; ctk_l' )) be $annot(exprIL_l'))

          3. (Let (( _typ ; ctk_r' )) be $annot(exprIL_r'))

          4. If ($is_equalable(typ')), then

            1. (Let ctk be $join_ctk(ctk_l', ctk_r'))

            2. Result in (BinE binop exprIL_l' exprIL_r' (( ((BoolT) as typ) ; ctk )))

          4. Else Phantom#771

        4. Else Phantom#772

      6. Case (% is in [(LE), (GE), (LT), (GT)])

        1. (Expr_ok: p' C |- expr_l : exprIL_l)

        2. (Expr_ok: p' C |- expr_r : exprIL_r)

        3. (Let (exprIL, exprIL)? be $coerce_binary(exprIL_l, exprIL_r))

        4. If (((exprIL, exprIL)? matches pattern (_))), then

          1. (Let ?((exprIL_l', exprIL_r')) be (exprIL, exprIL)?)

          2. (Let (exprIL, exprIL)'? be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_compare))

          3. If (((exprIL, exprIL)'? matches pattern (_))), then

            1. (Let ?((exprIL_l'', exprIL_r'')) be (exprIL, exprIL)'?)

            2. (Let (( _typ ; ctk_l'' )) be $annot(exprIL_l''))

            3. (Let (( _typ' ; ctk_r'' )) be $annot(exprIL_r''))

            4. (Let ctk be $join_ctk(ctk_l'', ctk_r''))

            5. Result in (BinE binop exprIL_l'' exprIL_r'' (( ((BoolT) as typ) ; ctk )))

          3. Else Phantom#773

        4. Else Phantom#774

      7. Case (% is in [(BAND), (BXOR), (BOR)])

        1. (Expr_ok: p' C |- expr_l : exprIL_l)

        2. (Expr_ok: p' C |- expr_r : exprIL_r)

        3. (Let (exprIL, exprIL)? be $coerce_binary(exprIL_l, exprIL_r))

        4. If (((exprIL, exprIL)? matches pattern (_))), then

          1. (Let ?((exprIL_l', exprIL_r')) be (exprIL, exprIL)?)

          2. (Let (exprIL, exprIL)'? be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_bitwise))

          3. If (((exprIL, exprIL)'? matches pattern (_))), then

            1. (Let ?((exprIL_l'', exprIL_r'')) be (exprIL, exprIL)'?)

            2. (Let (( typ'' ; ctk_l'' )) be $annot(exprIL_l''))

            3. (Let (( _typ ; ctk_r'' )) be $annot(exprIL_r''))

            4. (Let ctk be $join_ctk(ctk_l'', ctk_r''))

            5. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

          3. Else Phantom#775

        4. Else Phantom#776

      8. Case (% is in [(LAND), (LOR)])

        1. (Expr_ok: p' C |- expr_l : exprIL_l)

        2. (Expr_ok: p' C |- expr_r : exprIL_r)

        3. (Let (exprIL, exprIL)? be $coerce_binary(exprIL_l, exprIL_r))

        4. If (((exprIL, exprIL)? matches pattern (_))), then

          1. (Let ?((exprIL_l', exprIL_r')) be (exprIL, exprIL)?)

          2. (Let (exprIL, exprIL)'? be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_logical))

          3. If (((exprIL, exprIL)'? matches pattern (_))), then

            1. (Let ?((exprIL_l'', exprIL_r'')) be (exprIL, exprIL)'?)

            2. (Let (( _typ ; ctk_l'' )) be $annot(exprIL_l''))

            3. (Let (( _typ' ; ctk_r'' )) be $annot(exprIL_r''))

            4. (Let ctk be $join_ctk(ctk_l'', ctk_r''))

            5. Result in (BinE binop exprIL_l exprIL_r (( ((BoolT) as typ) ; ctk )))

          3. Else Phantom#777

        4. Else Phantom#778

    2. Else Phantom#779

    3. If ((binop matches pattern `CONCAT`)), then

      1. (Expr_ok: p' C |- expr_l : exprIL_l)

      2. (Expr_ok: p' C |- expr_r : exprIL_r)

      3. (Let (exprIL, exprIL)? be $reduce_senums_binary(exprIL_l, exprIL_r, $compatible_concat))

      4. If (((exprIL, exprIL)? matches pattern (_))), then

        1. (Let ?((exprIL_l', exprIL_r')) be (exprIL, exprIL)?)

        2. (Let (( typ_l' ; ctk_l' )) be $annot(exprIL_l'))

        3. (Let (( typ_r' ; ctk_r' )) be $annot(exprIL_r'))

        4. (Let w be ($get_width(typ_l') + $get_width(typ_r')))

        5. If ($is_fintt(typ_l')), then

          1. (Let typ'' be ((FIntT w) as typ))

          2. (Let ctk be $join_ctk(ctk_l', ctk_r'))

          3. Result in (BinE (CONCAT) exprIL_l' exprIL_r' (( typ'' ; ctk )))

        5. Else Phantom#780

        6. If ($is_fbitt(typ_l')), then

          1. (Let typ'' be ((FBitT w) as typ))

          2. (Let ctk be $join_ctk(ctk_l', ctk_r'))

          3. Result in (BinE (CONCAT) exprIL_l' exprIL_r' (( typ'' ; ctk )))

        6. Else Phantom#781

      4. Else Phantom#782

    3. Else Phantom#783

  13. Case (% matches pattern `TernE%%%`)

    1. (Let (TernE expr_c expr_t expr_f) be expr'')

    2. (Expr_ok: p' C |- expr_c : exprIL_c)

    3. (Let (( typ ; ctk_c )) be $annot(exprIL_c))

    4. If ((typ = ((BoolT) as typ))), then

      1. (Expr_ok: p' C |- expr_t : exprIL_t)

      2. (Expr_ok: p' C |- expr_f : exprIL_f)

      3. (Let (exprIL, exprIL)? be $coerce_binary(exprIL_t, exprIL_f))

      4. If (((exprIL, exprIL)? matches pattern (_))), then

        1. (Let ?((exprIL_t', exprIL_f')) be (exprIL, exprIL)?)

        2. (Let (( typ' ; ctk_t )) be $annot(exprIL_t'))

        3. (Let (( _typ ; ctk_f )) be $annot(exprIL_f'))

        4. If (($is_intt(typ') => ((ctk_c = (CTK)) \/ (ctk_c = (LCTK))))), then

          1. (Let ctk be $joins_ctk([ctk_c, ctk_t, ctk_f]))

          2. Result in (TernE exprIL_c exprIL_t' exprIL_f' (( typ' ; ctk )))

        4. Else Phantom#784

      4. Else Phantom#785

    4. Else Phantom#786

  14. Case (% matches pattern `CastE%%`)

    1. (Let (CastE type expr_b) be expr'')

    2. (Type_ok: p' C |- type : typ tid*)

    3. If ((tid* matches pattern [])), then

      1. If ((Type_wf: $bound_tids(p', C) |- typ holds)), then

        1. (Expr_ok: p' C |- expr_b : exprIL_b)

        2. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

        3. If ((Sub_expl: typ_b <: typ holds)), then

          1. Result in (CastE typ exprIL_b (( typ ; ctk_b )))

        3. Else Phantom#787

      1. Else Phantom#788

    3. Else Phantom#789

  15. Case (% matches pattern `MaskE%%`)

    1. (Let (MaskE expr_b expr_m) be expr'')

    2. (Expr_ok: p' C |- expr_b : exprIL_b)

    3. (Expr_ok: p' C |- expr_m : exprIL_m)

    4. (Let (exprIL, exprIL)? be $coerce_binary(exprIL_b, exprIL_m))

    5. If (((exprIL, exprIL)? matches pattern (_))), then

      1. (Let ?((exprIL_b', exprIL_m')) be (exprIL, exprIL)?)

      2. (Let (exprIL, exprIL)'? be $reduce_senums_binary(exprIL_b', exprIL_m', $compatible_mask))

      3. If (((exprIL, exprIL)'? matches pattern (_))), then

        1. (Let ?((exprIL_b'', exprIL_m'')) be (exprIL, exprIL)'?)

        2. (Let (( typ'' ; _ctk )) be $annot(exprIL_b''))

        3. Result in (MaskE exprIL_b'' exprIL_m'' (( ((SetT typ'') as typ) ; (DYN) )))

      3. Else Phantom#790

    5. Else Phantom#791

  16. Case (% matches pattern `RangeE%%`)

    1. (Let (RangeE expr_lb expr_ub) be expr'')

    2. (Expr_ok: p' C |- expr_lb : exprIL_lb)

    3. (Expr_ok: p' C |- expr_ub : exprIL_ub)

    4. (Let (exprIL, exprIL)? be $coerce_binary(exprIL_lb, exprIL_ub))

    5. If (((exprIL, exprIL)? matches pattern (_))), then

      1. (Let ?((exprIL_ub', exprIL_lb')) be (exprIL, exprIL)?)

      2. (Let (exprIL, exprIL)'? be $reduce_senums_binary(exprIL_lb', exprIL_ub', $compatible_range))

      3. If (((exprIL, exprIL)'? matches pattern (_))), then

        1. (Let ?((exprIL_lb'', exprIL_ub'')) be (exprIL, exprIL)'?)

        2. (Let (( typ'' ; _ctk )) be $annot(exprIL_lb''))

        3. Result in (RangeE exprIL_lb'' exprIL_ub'' (( ((SetT typ'') as typ) ; (DYN) )))

      3. Else Phantom#792

    5. Else Phantom#793

  17. Case (% matches pattern `ArrAccE%%`)

    1. (Let (ArrAccE expr_b expr_i) be expr'')

    2. (Expr_ok: p' C |- expr_b : exprIL_b)

    3. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

    4. (Expr_ok: p' C |- expr_i : exprIL_i)

    5. (Let (( typ_i ; ctk )) be $annot(exprIL_i))

    6. Case analysis on (ctk matches pattern `LCTK`)

      1. Case true

        1. (Let exprIL? be $reduce_senum_unary(exprIL_i, $compatible_arrayindex))

        2. If ((exprIL? matches pattern (_))), then

          1. (Let ?(exprIL_i') be exprIL?)

          2. (Let typ' be $canon_typ(typ_b))

          3. If ((typ' has type datatyp)), then

            1. (Let datatyp be (typ' as datatyp))

            2. Case analysis on datatyp

              1. Case (% matches pattern `TupleT%`)

                1. (Let (TupleT typ_b'*) be datatyp)

                2. (Eval_static: p' C |- exprIL_i' ~> (val_i _exprIL))

                3. (Let int be $get_num(val_i))

                4. If ((int has type nat)), then

                  1. (Let n be (int as nat))

                  2. (Let typ be typ_b'*[n])

                  3. Result in (ArrAccE exprIL_b exprIL_i' (( typ ; (DYN) )))

                4. Else Phantom#794

              2. Case (% matches pattern `StackT%%`)

                1. (Let (StackT typ_b' i_s) be datatyp)

                2. (Eval_static: p' C |- exprIL_i' ~> (val_i _exprIL))

                3. (Let i be $get_num(val_i))

                4. If ((((0 as int) <= i) /\ (i <= i_s))), then

                  1. Result in (ArrAccE exprIL_b exprIL_i' (( typ_b' ; (DYN) )))

                4. Else Phantom#795

            2. Else Phantom#796

          3. Else Phantom#797

        2. Else Phantom#798

      2. Case false

        1. (Let exprIL? be $reduce_senum_unary(exprIL_i, $compatible_arrayindex))

        2. If ((exprIL? matches pattern (_))), then

          1. (Let ?(exprIL_i') be exprIL?)

          2. (Let typ be $canon_typ(typ_b))

          3. If ((typ has type datatyp)), then

            1. (Let datatyp be (typ as datatyp))

            2. If ((datatyp matches pattern `StackT%%`)), then

              1. (Let (StackT typ_b' _int) be datatyp)

              2. Result in (ArrAccE exprIL_b exprIL_i' (( typ_b' ; (DYN) )))

            2. Else Phantom#799

          3. Else Phantom#800

        2. Else Phantom#801

  18. Case (% matches pattern `BitAccE%%%`)

    1. (Let (BitAccE expr_b expr_l expr_h) be expr'')

    2. (Expr_ok: p' C |- expr_b : exprIL_b)

    3. (Let exprIL? be $reduce_senum_unary(exprIL_b, $compatible_bitstringbase))

    4. If ((exprIL? matches pattern (_))), then

      1. (Let ?(exprIL_b') be exprIL?)

      2. (Let (( typ_b' ; ctk_b' )) be $annot(exprIL_b'))

      3. (Expr_ok: p' C |- expr_l : exprIL_l)

      4. (Let (( typ_l ; ctk )) be $annot(exprIL_l))

      5. If ((ctk matches pattern `LCTK`)), then

        1. (Let exprIL'? be $reduce_senum_unary(exprIL_l, $compatible_bitstringindex))

        2. If ((exprIL'? matches pattern (_))), then

          1. (Let ?(exprIL_l') be exprIL'?)

          2. (Eval_static: p' C |- exprIL_l' ~> (val_l _exprIL))

          3. (Let int be $get_num(val_l))

          4. If ((int has type nat)), then

            1. (Let n_l be (int as nat))

            2. (Let exprIL_l'' be (ValueE val_l (( typ_l ; (LCTK) ))))

            3. (Expr_ok: p' C |- expr_h : exprIL_h)

            4. (Let (( typ_h ; ctk' )) be $annot(exprIL_h))

            5. If ((ctk' matches pattern `LCTK`)), then

              1. (Let exprIL''? be $reduce_senum_unary(exprIL_h, $compatible_bitstringindex))

              2. If ((exprIL''? matches pattern (_))), then

                1. (Let ?(exprIL_h') be exprIL''?)

                2. (Eval_static: p' C |- exprIL_h' ~> (val_h _exprIL'))

                3. (Let int' be $get_num(val_h))

                4. If ((int' has type nat)), then

                  1. (Let n_h be (int' as nat))

                  2. (Let exprIL_h'' be (ValueE val_h (( typ_h ; (LCTK) ))))

                  3. If ($is_valid_bitstring_slice(typ_b', n_l, n_h)), then

                    1. (Let typ be ((FBitT ((n_h - n_l) + 1)) as typ))

                    2. Result in (BitAccE exprIL_b' exprIL_l'' exprIL_h'' (( typ ; ctk_b' )))

                  3. Else Phantom#802

                4. Else Phantom#803

              2. Else Phantom#804

            5. Else Phantom#805

          4. Else Phantom#806

        2. Else Phantom#807

      5. Else Phantom#808

    4. Else Phantom#809

  19. Case (% matches pattern `ErrAccE%`)

    1. (Let (ErrAccE member) be expr'')

    2. (Let id be $concat_text(["error.", member]))

    3. (Let val'? be $find_val(p', C, (TOP id)))

    4. If ((val'? matches pattern (_))), then

      1. (Let ?(val) be val'?)

      2. If ((val matches pattern `ErrV%`)), then

        1. (Let (ErrV _member) be val)

        2. Result in (ErrAccE member (( ((ErrT) as typ) ; (LCTK) )))

      2. Else Phantom#810

    4. Else Phantom#811

  20. Case (% matches pattern `TypeAccE%%`)

    1. (Let (TypeAccE name member) be expr'')

    2. (Let typdef'? be $find_typdef(p', C, name))

    3. If ((typdef'? matches pattern (_))), then

      1. (Let ?(typdef) be typdef'?)

      2. If ((typdef has type monotypdef)), then

        1. (Let (MonoD typ) be (typdef as monotypdef))

        2. (Let typ' be $canon_typ(typ))

        3. If ((typ' has type datatyp)), then

          1. (Let datatyp be (typ' as datatyp))

          2. Case analysis on datatyp

            1. Case (% matches pattern `EnumT%%`)

              1. (Let (EnumT id_t member_t*) be datatyp)

              2. If (member is in member_t*), then

                1. Result in (TypeAccE name member (( typ ; (LCTK) )))

              2. Else Phantom#812

            2. Case (% matches pattern `SEnumT%%%`)

              1. (Let (SEnumT id_t typ_t (member_t, val_t)*) be datatyp)

              2. (Let val'? be $assoc_<member, val>(member, (member_t, val_t)*))

              3. If ((val'? matches pattern (_))), then

                1. (Let ?(val) be val'?)

                2. Result in (TypeAccE name member (( typ ; (LCTK) )))

              3. Else Phantom#813

          2. Else Phantom#814

        3. Else Phantom#815

      2. Else Phantom#816

    3. Else Phantom#817

  21. Case (% matches pattern `ExprAccE%%`)

    1. (Let (ExprAccE expr_b text) be expr'')

    2. Case analysis on text

      1. Case (% = "size")

        1. (Expr_ok: p' C |- expr_b : exprIL_b)

        2. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

        3. (Let typ be $canon_typ(typ_b))

        4. If ((typ has type datatyp)), then

          1. (Let datatyp be (typ as datatyp))

          2. If ((datatyp matches pattern `StackT%%`)), then

            1. (Let (StackT typ_s int_s) be datatyp)

            2. Result in (ExprAccE exprIL_b "size" (( ((FBitT 32) as typ) ; (LCTK) )))

          2. Else Phantom#818

        4. Else Phantom#819

      2. Case (% = "lastIndex")

        1. If ((((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE))))), then

          1. (Expr_ok: p' C |- expr_b : exprIL_b)

          2. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

          3. (Let typ be $canon_typ(typ_b))

          4. If ((typ has type datatyp)), then

            1. (Let datatyp be (typ as datatyp))

            2. If ((datatyp matches pattern `StackT%%`)), then

              1. (Let (StackT typ_s int_s) be datatyp)

              2. Result in (ExprAccE exprIL_b "lastIndex" (( ((FBitT 32) as typ) ; (DYN) )))

            2. Else Phantom#820

          4. Else Phantom#821

        1. Else Phantom#822

      3. Case (% = "last")

        1. If ((((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE))))), then

          1. (Expr_ok: p' C |- expr_b : exprIL_b)

          2. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

          3. (Let typ be $canon_typ(typ_b))

          4. If ((typ has type datatyp)), then

            1. (Let datatyp be (typ as datatyp))

            2. If ((datatyp matches pattern `StackT%%`)), then

              1. (Let (StackT typ_s int_s) be datatyp)

              2. Result in (ExprAccE exprIL_b "last" (( typ_s ; (DYN) )))

            2. Else Phantom#823

          4. Else Phantom#824

        1. Else Phantom#825

      4. Case (% = "next")

        1. (Expr_ok: p' C |- expr_b : exprIL_b)

        2. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

        3. (Let typ be $canon_typ(typ_b))

        4. If ((typ has type datatyp)), then

          1. (Let datatyp be (typ as datatyp))

          2. If ((datatyp matches pattern `StackT%%`)), then

            1. (Let (StackT typ_s int_s) be datatyp)

            2. Result in (ExprAccE exprIL_b "next" (( typ_s ; (DYN) )))

          2. Else Phantom#826

        4. Else Phantom#827

    2. Else Phantom#828

    3. (Expr_ok: p' C |- expr_b : exprIL_b)

    4. (Let (( typ_b ; ctk_b )) be $annot(exprIL_b))

    5. (Let typ' be $canon_typ(typ_b))

    6. Case analysis on typ'

      1. Case (% has type datatyp)

        1. (Let datatyp be (typ' as datatyp))

        2. Case analysis on datatyp

          1. Case (% matches pattern `StructT%%`)

            1. (Let (StructT id_s (member_s, typ_s)*) be datatyp)

            2. (Let typ''? be $assoc_<member, typ>(text, (member_s, typ_s)*))

            3. If ((typ''? matches pattern (_))), then

              1. (Let ?(typ) be typ''?)

              2. Result in (ExprAccE exprIL_b text (( typ ; (DYN) )))

            3. Else Phantom#829

          2. Case (% matches pattern `HeaderT%%`)

            1. (Let (HeaderT id_h (member_h, typ_h)*) be datatyp)

            2. (Let typ''? be $assoc_<member, typ>(text, (member_h, typ_h)*))

            3. If ((typ''? matches pattern (_))), then

              1. (Let ?(typ) be typ''?)

              2. Result in (ExprAccE exprIL_b text (( typ ; (DYN) )))

            3. Else Phantom#830

          3. Case (% matches pattern `UnionT%%`)

            1. (Let (UnionT id_u (member_u, typ_u)*) be datatyp)

            2. (Let typ''? be $assoc_<member, typ>(text, (member_u, typ_u)*))

            3. If ((typ''? matches pattern (_))), then

              1. (Let ?(typ) be typ''?)

              2. Result in (ExprAccE exprIL_b text (( typ ; (DYN) )))

            3. Else Phantom#831

        2. Else Phantom#832

      2. Case (% has type synthtyp)

        1. (Let synthtyp be (typ' as synthtyp))

        2. If ((synthtyp matches pattern `TableStructT%%`)), then

          1. (Let (TableStructT id_t (member_t, typ_t)*) be synthtyp)

          2. (Let typ''? be $assoc_<member, typ>(text, (member_t, typ_t)*))

          3. If ((typ''? matches pattern (_))), then

            1. (Let ?(typ) be typ''?)

            2. Result in (ExprAccE exprIL_b text (( typ ; (DYN) )))

          3. Else Phantom#833

        2. Else Phantom#834

    6. Else Phantom#835

  22. Case (% matches pattern `CallFuncE%%%`)

    1. (Let (CallFuncE name targ* arg*) be expr'')

    2. (Type_ok: p' C |- targ : targIL tid_fresh_a*)*

    3. (Let tid_fresh* be $concat_<tid>(tid_fresh_a**))

    4. (FuncType_ok: p' C |- name targIL* arg* : ft tid_fresh_inserted* id_deft*)

    5. (Let tid_fresh'* be $concat_<tid>(tid_fresh* :: [tid_fresh_inserted*]))

    6. (Call_ok: p' C tid_fresh'* |- ft targIL* arg* id_deft* : typ targIL'* argIL'*)

    7. If ((typ =/= ((VoidT) as typ))), then

      1. Result in (CallFuncE name targIL'* argIL'* (( typ ; (DYN) )))

    7. Else Phantom#836

  23. Case (% matches pattern `CallMethodE%%%%`)

    1. (Let (CallMethodE expr_b member targ* arg*) be expr'')

    2. If ((targ* matches pattern [])), then

      1. If ((arg* matches pattern [])), then

        1. If (member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

          1. (MethodType_ok: p' C |- expr_b member [] [] : ft exprIL_b tid_fresh_inserted* id_deft*)

          2. (Call_ok: p' C [] |- ft [] [] [] : typ targIL* argIL*)

          3. If ((typ = ((IntT) as typ))), then

            1. If ((targIL* matches pattern [])), then

              1. If ((argIL* matches pattern [])), then

                1. Result in (CallMethodE exprIL_b member [] [] (( ((IntT) as typ) ; (LCTK) )))

              1. Else Phantom#837

            1. Else Phantom#838

          3. Else Phantom#839

        1. Else Phantom#840

      1. Else Phantom#841

    2. Else Phantom#842

    3. If (~member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. (Type_ok: p' C |- targ : targIL tid_fresh_a*)*

      2. (Let tid_fresh* be $concat_<tid>(tid_fresh_a**))

      3. (MethodType_ok: p' C |- expr_b member targIL* arg* : ft exprIL_b tid_fresh_inserted* id_deft*)

      4. (Let tid_fresh'* be $concat_<tid>([tid_fresh* ++ tid_fresh_inserted*]))

      5. (Call_ok: p' C tid_fresh'* |- ft targIL* arg* id_deft* : typ targIL'* argIL'*)

      6. If ((typ =/= ((VoidT) as typ))), then

        1. Result in (CallMethodE exprIL_b member targIL'* argIL'* (( typ ; (DYN) )))

      6. Else Phantom#843

    3. Else Phantom#844

  24. Case (% matches pattern `CallTypeE%%%%`)

    1. (Let (CallTypeE name member targ* arg*) be expr'')

    2. If ((targ* matches pattern [])), then

      1. If ((arg* matches pattern [])), then

        1. (Let typdef'? be $find_typdef(p', C, name))

        2. If ((typdef'? matches pattern (_))), then

          1. (Let ?(typdef) be typdef'?)

          2. If (member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

            1. (Let ft be (BuiltinMethodT [] ((IntT) as typ)))

            2. (Call_ok: p' C [] |- ft [] [] [] : typ targIL* argIL*)

            3. If ((typ = ((IntT) as typ))), then

              1. If ((targIL* matches pattern [])), then

                1. If ((argIL* matches pattern [])), then

                  1. Result in (CallTypeE name member [] [] (( ((IntT) as typ) ; (LCTK) )))

                1. Else Phantom#845

              1. Else Phantom#846

            3. Else Phantom#847

          2. Else Phantom#848

        2. Else Phantom#849

      1. Else Phantom#850

    2. Else Phantom#851

  25. Case (% matches pattern `InstE%%%`)

    1. (Let (InstE name targ* arg*) be expr'')

    2. (Type_ok: p' C |- targ : targIL tid_fresh_a*)*

    3. (Let tid_fresh* be $concat_<tid>(tid_fresh_a**))

    4. (ConsType_ok: p' C |- name targIL* arg* : ct tid_fresh_inserted* id_deft*)

    5. (Let tid_fresh'* be $concat_<tid>([tid_fresh* ++ tid_fresh_inserted*]))

    6. (Inst_ok: p' C tid_fresh'* |- ct targIL* arg* id_deft* : typ targIL'* targIL_hidden* argIL'*)

    7. If ($not_abstract_extern_object(typ)), then

      1. Result in (InstE name targIL'* targIL_hidden* argIL'* (( typ ; (CTK) )))

    7. Else Phantom#852

1. Else Phantom#853

2. If ((p' matches pattern `LOCAL`)), then

  1. If ((expr'' matches pattern `SelectE%%`)), then

    1. (Let (SelectE expr_k* selectcase*) be expr'')

    2. If ((C.LOCAL.KIND matches pattern `PARSERSTATE`)), then

      1. (Expr_ok: (LOCAL) C |- expr_k : exprIL_k)*

      2. (Let (( typ_k ; ctk_k )) be $annot(exprIL_k))*

      3. If ((Type_wf: $bound_tids((LOCAL), C) |- ((SetT typ_k) as typ) holds))*, then

        1. (Select_case_ok: (LOCAL) C typ_k* |- selectcase : selectcaseIL)*

        2. Result in (SelectE exprIL_k* selectcaseIL* (( ((StateT) as typ) ; (DYN) )))

      3. Else Phantom#854

    2. Else Phantom#855

  1. Else Phantom#856

2. Else Phantom#857

;; ../../../../spec/4b-typing-relation.watsup:87.1-89.23
relation Arg_ok: p, C, arg

1. Case analysis on arg

  1. Case (% matches pattern `ExprA%`)

    1. (Let (ExprA expr) be arg)

    2. (Expr_ok: p C |- expr : exprIL)

    3. (Let (( typ ; _ctk )) be $annot(exprIL))

    4. Result in (ExprA exprIL), typ

  2. Case (% matches pattern `NameA%%`)

    1. (Let (NameA id expr'?) be arg)

    2. Case analysis on expr'?

      1. Case (% matches pattern (_))

        1. (Let ?(expr) be expr'?)

        2. (Expr_ok: p C |- expr : exprIL)

        3. (Let (( typ ; _ctk )) be $annot(exprIL))

        4. Result in (NameA id ?(exprIL)), typ

      2. Case (% matches pattern ())

        1. Result in (NameA id ?()), ((AnyT) as typ)

  3. Case (% matches pattern `AnyA`)

    1. Result in (AnyA), ((AnyT) as typ)

;; ../../../../spec/4b-typing-relation.watsup:92.1-94.23
relation Lval_ok: p, C, exprIL

1. Case analysis on exprIL

  1. Case (% matches pattern `NameE%%`)

    1. (Let (NameE name _annotIL) be exprIL)

    2. (Let styp? be $find_styp(p, C, name))

    3. If ((styp? matches pattern (_))), then

      1. (Let ?((typ dir _ctk _val?)) be styp?)

      2. If (((dir = (OUT)) \/ (dir = (INOUT)))), then

        1. If ($is_assignable(typ)), then

          1. The relation holds

        1. Else Phantom#858

      2. Else Phantom#859

    3. Else Phantom#860

  2. Case (% matches pattern `ArrAccE%%%`)

    1. (Let (ArrAccE exprIL_b exprIL_i _annotIL) be exprIL)

    2. If ((Lval_ok: p C |- exprIL_b holds)), then

      1. The relation holds

    2. Else Phantom#861

  3. Case (% matches pattern `BitAccE%%%%`)

    1. (Let (BitAccE exprIL_b exprIL_l exprIL_h _annotIL) be exprIL)

    2. If ((Lval_ok: p C |- exprIL_b holds)), then

      1. The relation holds

    2. Else Phantom#862

  4. Case (% matches pattern `ExprAccE%%%`)

    1. (Let (ExprAccE exprIL_b member _annotIL) be exprIL)

    2. If ((Lval_ok: p C |- exprIL_b holds)), then

      1. The relation holds

    2. Else Phantom#863

1. Else Phantom#864

;; ../../../../spec/4b-typing-relation.watsup:99.18-99.31
syntax blkctxt = 
   | `INIT`()
   | `NOINIT`()

;; ../../../../spec/4b-typing-relation.watsup:100.1-102.29
relation Block_ok: cursor, C, f, blkctxt, (BlockB stmt*)

1. If ((cursor matches pattern `LOCAL`)), then

  1. Case analysis on blkctxt

    1. Case (% matches pattern `INIT`)

      1. (Stmts_ok: (LOCAL) C f |- stmt* : C' f' stmtIL*)

      2. Result in C', f', (BlockB stmtIL*)

    2. Case (% matches pattern `NOINIT`)

      1. (Let C' be $enter(C))

      2. (Stmts_ok: (LOCAL) C' f |- stmt* : C'' f' stmtIL*)

      3. (Let C''' be $exit(C''))

      4. Result in C''', f', (BlockB stmtIL*)

1. Else Phantom#865

;; ../../../../spec/4b-typing-relation.watsup:103.1-105.26
relation Stmt_ok: p', C, f, stmt

1. Case analysis on stmt

  1. Case (% matches pattern `EmptyS`)

    1. Result in C, f, (EmptyS)

  2. Case (% matches pattern `AssignS%%`)

    1. (Let (AssignS expr_l expr_r) be stmt)

    2. (Expr_ok: p' C |- expr_l : exprIL_l)

    3. (Let (( typ_l ; ctk )) be $annot(exprIL_l))

    4. If ((ctk matches pattern `DYN`)), then

      1. If ((Lval_ok: p' C |- exprIL_l holds)), then

        1. (Expr_ok: p' C |- expr_r : exprIL_r)

        2. (Let (( typ_r ; _ctk )) be $annot(exprIL_r))

        3. (Let exprIL? be $coerce_assign(exprIL_r, typ_l))

        4. If ((exprIL? matches pattern (_))), then

          1. (Let ?(exprIL_r') be exprIL?)

          2. Result in C, f, (AssignS exprIL_l exprIL_r')

        4. Else Phantom#866

      1. Else Phantom#867

    4. Else Phantom#868

  3. Case (% matches pattern `IfS%%%`)

    1. (Let (IfS expr_c stmt_t stmt_f) be stmt)

    2. (Expr_ok: p' C |- expr_c : exprIL_c)

    3. (Let (( typ ; _ctk )) be $annot(exprIL_c))

    4. If ((typ = ((BoolT) as typ))), then

      1. (Stmt_ok: p' C f |- stmt_t : C_t f_t stmtIL_t)

      2. (Stmt_ok: p' C f |- stmt_f : C_f f_f stmtIL_f)

      3. (Let f' be $join_flow(f_t, f_f))

      4. Result in C, f', (IfS exprIL_c stmtIL_t stmtIL_f)

    4. Else Phantom#869

  4. Case (% matches pattern `ExitS`)

    1. Result in C, f, (ExitS)

  5. Case (% matches pattern `CallFuncS%%%`)

    1. (Let (CallFuncS name targ* arg*) be stmt)

    2. If (((name = (CURRENT "verify")) => (((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE)))))), then

      1. (Type_ok: p' C |- targ : targIL tid_fresh_a*)*

      2. (Let tid_fresh* be $concat_<tid>(tid_fresh_a**))

      3. (FuncType_ok: p' C |- name targIL* arg* : ft tid_fresh_inserted* id_deft*)

      4. (Let tid_fresh'* be $concat_<tid>([tid_fresh* ++ tid_fresh_inserted*]))

      5. (Call_ok: p' C tid_fresh'* |- ft targIL* arg* id_deft* : typ targIL'* argIL'*)

      6. Result in C, f, (CallFuncS name targIL'* argIL'*)

    2. Else Phantom#870

  6. Case (% matches pattern `CallMethodS%%%%`)

    1. (Let (CallMethodS expr_b member targ* arg*) be stmt)

    2. (Arg_ok: p' C |- arg : argIL typ_arg)*

    3. (Type_ok: p' C |- targ : targIL tid_fresh_a*)*

    4. (Let tid_fresh* be $concat_<tid>(tid_fresh_a**))

    5. (MethodType_ok: p' C |- expr_b member targIL* arg* : ft exprIL_b tid_fresh_inserted* id_deft*)

    6. (Let tid_fresh'* be $concat_<tid>([tid_fresh* ++ tid_fresh_inserted*]))

    7. (Call_ok: p' C tid_fresh'* |- ft targIL* arg* id_deft* : typ targIL'* argIL'*)

    8. Result in C, f, (CallMethodS exprIL_b member targIL'* argIL'*)

  7. Case (% matches pattern `CallInstS%%%`)

    1. (Let (CallInstS name targ* arg*) be stmt)

    2. (ConsType_ok: p' C |- name [] [] : ct tid* id'*)

    3. If ((tid* matches pattern [])), then

      1. If ((id'* matches pattern [])), then

        1. (Inst_ok: p' C [] |- ct [] [] [] : typ targIL* targIL''* argIL*)

        2. If ((targIL* matches pattern [])), then

          1. If ((targIL''* matches pattern [])), then

            1. If ((argIL* matches pattern [])), then

              1. (Let typ' be $canon_typ(typ))

              2. If (($is_parsert(typ') \/ $is_controlt(typ'))), then

                1. (Let id be $id_of_name(name))

                2. (Let C' be $add_styp(p', C, id, (typ (NO) (CTK) ?())))

                3. (Stmt_ok: p' C' f |- (CallMethodS (NameE (CURRENT id)) "apply" targ* arg*) : C'' f' stmtIL)

                4. (Let stmtIL' be stmtIL)

                5. If ((stmtIL' matches pattern `CallMethodS%%%%`)), then

                  1. (Let (CallMethodS exprIL text targIL'* argIL'*) be stmtIL')

                  2. If ((exprIL matches pattern `NameE%%`)), then

                    1. (Let (NameE name' _annotIL) be exprIL)

                    2. If ((name' = (CURRENT id))), then

                      1. If ((text = "apply")), then

                        1. Result in C, f, (CallInstS typ name targIL'* argIL'*)

                      1. Else Phantom#871

                    2. Else Phantom#872

                  2. Else Phantom#873

                5. Else Phantom#874

              2. Else Phantom#875

            1. Else Phantom#876

          1. Else Phantom#877

        2. Else Phantom#878

      1. Else Phantom#879

    3. Else Phantom#880

  8. Case (% matches pattern `TransS%`)

    1. (Let (TransS expr) be stmt)

    2. (Expr_ok: p' C |- expr : exprIL)

    3. (Let (( typ ; _ctk )) be $annot(exprIL))

    4. If ((typ = ((StateT) as typ))), then

      1. Result in C, f, (TransS exprIL)

    4. Else Phantom#881

  9. Case (% matches pattern `DeclS%`)

    1. (Let (DeclS decl) be stmt)

    2. (Decl_ok: p' C |- decl : C' declIL)

    3. Result in C', f, (DeclS declIL)

1. Else Phantom#882

2. If ((p' matches pattern `LOCAL`)), then

  1. Case analysis on stmt

    1. Case (% matches pattern `SwitchS%%`)

      1. (Let (SwitchS expr switchcase*) be stmt)

      2. If ((C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`)), then

        1. (Expr_ok: (LOCAL) C |- expr : exprIL)

        2. (Let (( typ ; _ctk )) be $annot(exprIL))

        3. If ((typ has type synthtyp)), then

          1. (Let synthtyp be (typ as synthtyp))

          2. If ((synthtyp matches pattern `TableEnumT%%`)), then

            1. (Let (TableEnumT id _member*) be synthtyp)

            2. (Let id_t be $strip_prefix($strip_suffix(id, ")"), "action_list("))

            3. (Switch_tbl_cases_ok: (LOCAL) C f id_t |- switchcase* : f' switchcaseIL* switchlabel*)

            4. If ($distinct_<switchlabel>(switchlabel*)), then

              1. Result in C, f', (SwitchS exprIL switchcaseIL*)

            4. Else Phantom#883

          2. Else Phantom#884

        3. Else Phantom#885

        4. (Let typ' be $canon_typ(typ))

        5. If ((((($is_errt(typ') \/ $is_fintt(typ')) \/ $is_fbitt(typ')) \/ $is_enumt(typ')) \/ $is_senumt(typ'))), then

          1. (Switch_gen_cases_ok: (LOCAL) C f typ |- switchcase* : f' switchcaseIL* switchlabel*)

          2. If ($distinct_<switchlabel>(switchlabel*)), then

            1. Result in C, f', (SwitchS exprIL switchcaseIL*)

          2. Else Phantom#886

        5. Else Phantom#887

      2. Else Phantom#888

    2. Case (% matches pattern `BlockS%`)

      1. (Let (BlockS block) be stmt)

      2. (Block_ok: (LOCAL) C f (NOINIT) |- block : C' f' blockIL)

      3. Result in C', f', (BlockS blockIL)

    3. Case (% matches pattern `RetS%`)

      1. (Let (RetS expr'?) be stmt)

      2. If ((expr'? matches pattern (_))), then

        1. (Let ?(expr) be expr'?)

        2. (Expr_ok: (LOCAL) C |- expr : exprIL)

        3. (Let typ_r be $get_typ_ret_lkind(C.LOCAL.KIND))

        4. (Let exprIL''? be $coerce_assign(exprIL, typ_r))

        5. If ((exprIL''? matches pattern (_))), then

          1. (Let ?(exprIL') be exprIL''?)

          2. Result in C, (RET), (RetS ?(exprIL'))

        5. Else Phantom#889

      2. Else Phantom#890

  1. Else Phantom#891

  2. If ((stmt = (RetS ?()))), then

    1. If ((((VoidT) as typ) = $get_typ_ret_lkind(C.LOCAL.KIND))), then

      1. Result in C, (RET), (RetS ?())

    1. Else Phantom#892

  2. Else Phantom#893

2. Else Phantom#894

;; ../../../../spec/4b-typing-relation.watsup:106.1-108.26
relation Stmts_ok: p, C, f, stmt*

1. Case analysis on stmt*

  1. Case (% matches pattern [])

    1. Result in C, f, []

  2. Case (% matches pattern _ :: _)

    1. (Let stmt_h :: stmt_t* be stmt*)

    2. (Stmt_ok: p C f |- stmt_h : C' f' stmtIL_h)

    3. (Stmts_ok: p C' f' |- stmt_t* : C'' f'' stmtIL_t*)

    4. Result in C'', f'', stmtIL_h :: stmtIL_t*

;; ../../../../spec/4b-typing-relation.watsup:113.1-115.23
relation Param_ok: p, C, (id dir type expr''?)

1. Case analysis on expr''?

  1. Case (% matches pattern (_))

    1. (Let ?(expr) be expr''?)

    2. (Type_ok: p C |- type : typ_p tid_fresh*)

    3. (Let tidset be $union_set<tid>($bound_tids(p, C), ({ tid_fresh* })))

    4. If ((Type_wf: tidset |- typ_p holds)), then

      1. (Expr_ok: p C |- expr : exprIL_e)

      2. (Let (( typ_e ; ctk )) be $annot(exprIL_e))

      3. If ((ctk matches pattern `LCTK`)), then

        1. If ((Sub_impl: typ_e << typ_p holds)), then

          1. (Eval_static: p C |- exprIL_e ~> (val exprIL))

          2. Result in (id dir typ_p ?(exprIL)), tid_fresh*

        1. Else Phantom#895

      3. Else Phantom#896

    4. Else Phantom#897

  2. Case (% matches pattern ())

    1. (Type_ok: p C |- type : typ_p tid_fresh*)

    2. (Let tidset be $union_set<tid>($bound_tids(p, C), ({ tid_fresh* })))

    3. If ((Type_wf: tidset |- typ_p holds)), then

      1. Result in (id dir typ_p ?()), tid_fresh*

    3. Else Phantom#898

;; ../../../../spec/4b-typing-relation.watsup:116.1-118.23
relation CParam_ok: p, C, (id dir type expr''?)

1. Case analysis on expr''?

  1. Case (% matches pattern (_))

    1. (Let ?(expr) be expr''?)

    2. (Type_ok: p C |- type : typ_p tid_fresh*)

    3. (Let tidset be $union_set<tid>($bound_tids(p, C), ({ tid_fresh* })))

    4. If ((Type_wf: tidset |- typ_p holds)), then

      1. (Expr_ok: p C |- expr : exprIL_e)

      2. (Let (( typ_e ; ctk )) be $annot(exprIL_e))

      3. If ((ctk matches pattern `LCTK`)), then

        1. If ((Sub_impl: typ_e << typ_p holds)), then

          1. (Eval_static: p C |- exprIL_e ~> (val exprIL))

          2. Result in (id dir typ_p ?(exprIL)), tid_fresh*

        1. Else Phantom#899

      3. Else Phantom#900

    4. Else Phantom#901

  2. Case (% matches pattern ())

    1. (Type_ok: p C |- type : typ_p tid_fresh*)

    2. (Let tidset be $union_set<tid>($bound_tids(p, C), ({ tid_fresh* })))

    3. If ((Type_wf: tidset |- typ_p holds)), then

      1. Result in (id dir typ_p ?()), tid_fresh*

    3. Else Phantom#902

;; ../../../../spec/4b-typing-relation.watsup:122.1-124.23
relation Decl_ok: p', C'''', decl''

1. Case analysis on decl''

  1. Case (% matches pattern `ConstD%%%`)

    1. (Let (ConstD id type expr) be decl'')

    2. (Type_ok: p' C'''' |- type : typ_c tid*)

    3. If ((tid* matches pattern [])), then

      1. If ((Type_wf: $bound_tids(p', C'''') |- typ_c holds)), then

        1. (Expr_ok: p' C'''' |- expr : exprIL)

        2. (Let (( _typ ; ctk )) be $annot(exprIL))

        3. If ((ctk matches pattern `LCTK`)), then

          1. (Let exprIL''? be $coerce_assign(exprIL, typ_c))

          2. If ((exprIL''? matches pattern (_))), then

            1. (Let ?(exprIL') be exprIL''?)

            2. (Eval_static: p' C'''' |- exprIL' ~> (val _exprIL))

            3. (Let C' be $add_styp(p', C'''', id, (typ_c (NO) (LCTK) ?(val))))

            4. Result in C', (ConstD id typ_c val)

          2. Else Phantom#903

        3. Else Phantom#904

      1. Else Phantom#905

    3. Else Phantom#906

  2. Case (% matches pattern `VarD%%%`)

    1. (Let (VarD id type expr?) be decl'')

    2. Case analysis on expr?

      1. Case (% matches pattern ())

        1. (Type_ok: p' C'''' |- type : typ tid*)

        2. If ((tid* matches pattern [])), then

          1. If ((Type_wf: $bound_tids(p', C'''') |- typ holds)), then

            1. If ($is_assignable(typ)), then

              1. (Let C' be $add_styp(p', C'''', id, (typ (INOUT) (DYN) ?())))

              2. Result in C', (VarD id typ ?())

            1. Else Phantom#907

          1. Else Phantom#908

        2. Else Phantom#909

      2. Case (% matches pattern (_))

        1. (Let ?(expr) be expr?)

        2. (Type_ok: p' C'''' |- type : typ tid*)

        3. If ((tid* matches pattern [])), then

          1. If ((Type_wf: $bound_tids(p', C'''') |- typ holds)), then

            1. If ($is_assignable(typ)), then

              1. (Expr_ok: p' C'''' |- expr : exprIL)

              2. (Let exprIL''? be $coerce_assign(exprIL, typ))

              3. If ((exprIL''? matches pattern (_))), then

                1. (Let ?(exprIL') be exprIL''?)

                2. (Let C' be $add_styp(p', C'''', id, (typ (INOUT) (DYN) ?())))

                3. Result in C', (VarD id typ ?(exprIL'))

              3. Else Phantom#910

            1. Else Phantom#911

          1. Else Phantom#912

        3. Else Phantom#913

  3. Case (% matches pattern `InstD%%%%%`)

    1. (Let (InstD id name_inst targ* arg* decl''*) be decl'')

    2. If ((|decl''*| > 0)), then

      1. (Type_ok: p' C'''' |- targ : targIL tid_fresh_a*)*

      2. (Let tid_fresh* be $concat_<tid>(tid_fresh_a**))

      3. (ConsType_ok: p' C'''' |- name_inst targIL* arg* : ct tid_fresh_inserted* id_deft*)

      4. (Inst_ok: p' C'''' tid_fresh* ++ tid_fresh_inserted* |- ct targIL* arg* id_deft* : typ targIL'* targIL_hidden* argIL'*)

      5. (Let typ''' be typ)

      6. If ((typ''' has type abstyp)), then

        1. (Let abstyp be (typ''' as abstyp))

        2. If ((abstyp matches pattern `SpecT%%`)), then

          1. (Let (SpecT (PolyD (tparam*, tparam_hidden*) -> typ'') typ_a*) be abstyp)

          2. If ((typ'' has type objtyp)), then

            1. (Let objtyp be (typ'' as objtyp))

            2. If ((objtyp matches pattern `ExternT%%`)), then

              1. (Let (ExternT id_ext fdenv_ext) be objtyp)

              2. (Let C' be $add_styp((LOCAL), C'''', "this", (typ (NO) (CTK) ?())))

              3. (Inst_init_decls_ok: C' $empty_frame $empty_fdenv |- decl''* : frame_abs fdenv_abs declIL*)

              4. (Let ({ (fid_abs -> fd_abs)* }) be fdenv_abs)

              5. (Let tparam'* be tparam* ++ tparam_hidden*)

              6. (Let theta be ({ (tparam' -> typ_a)* }))

              7. (Let fdenv_ext' be $update_fdenv_extern(fdenv_ext, theta, fid_abs*, fd_abs*))

              8. (Let ({ (fid_ext -> fd_ext)* }) be fdenv_ext')

              9. (Let funcdef* be fd_ext*)

              10. If ((funcdef has type polyfuncdef))*, then

                1. (Let (PolyFD _(tparam*, tparam*) -> ft) be (funcdef as polyfuncdef))*

                2. If (~$is_externabstractmethodt(ft))*, then

                  1. (Let typ' be ((SpecT (PolyD (tparam*, tparam_hidden*) -> ((ExternT id_ext fdenv_ext') as typ)) typ_a*) as typ))

                  2. (Let C'' be $add_styp(p', C'''', id, (typ' (NO) (CTK) ?())))

                  3. Result in C'', (InstD id typ name_inst targIL'* targIL_hidden* argIL'* declIL*)

                2. Else Phantom#914

              10. Else Phantom#915

            2. Else Phantom#916

          2. Else Phantom#917

        2. Else Phantom#918

      6. Else Phantom#919

    2. Else Phantom#920

    3. If ((decl''* matches pattern [])), then

      1. (Type_ok: p' C'''' |- targ : targIL tid_fresh_a*)*

      2. (Let tid_fresh* be $concat_<tid>(tid_fresh_a**))

      3. (ConsType_ok: p' C'''' |- name_inst targIL* arg* : ct tid_fresh_inserted* id_deft*)

      4. (Inst_ok: p' C'''' tid_fresh* ++ tid_fresh_inserted* |- ct targIL* arg* id_deft* : typ targIL'* targIL_hidden* argIL'*)

      5. (Let C' be $add_styp(p', C'''', id, (typ (NO) (CTK) ?())))

      6. Result in C', (InstD id typ name_inst targIL'* targIL_hidden* argIL'* [])

    3. Else Phantom#921

  4. Case (% matches pattern `ActionD%%%`)

    1. (Let (ActionD id param* block) be decl'')

    2. If (((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (CONTROL))))), then

      1. (Let fid be $to_fid(id, param*))

      2. (Let C_1 be $set_localkind(C'''', (ACTION)))

      3. (Param_ok: (LOCAL) C_1 |- param : paramIL tid*)*

      4. If ((tid* matches pattern []))*, then

        1. (Let C_2 be $add_params((LOCAL), C_1, (paramIL* as paramtyp*)))

        2. (Block_ok: (LOCAL) C_2 (CONT) (INIT) |- block : _context _flow blockIL)

        3. (Let fd be ((MonoFD (ActionT (paramIL* as paramtyp*))) as funcdef))

        4. If ((FuncDef_wf: $bound_tids(p', C'''') |- fd holds)), then

          1. (Let C_4 be $add_funcdef_non_overload(p', C'''', fid, fd))

          2. Result in C_4, (ActionD id paramIL* blockIL)

        4. Else Phantom#922

      4. Else Phantom#923

    2. Else Phantom#924

  5. Case (% matches pattern `ValueSetD%%%`)

    1. (Let (ValueSetD id type expr) be decl'')

    2. If (((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (PARSER))))), then

      1. (Type_ok: p' C'''' |- type : typ_s tid*)

      2. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound_tids(p', C'''') |- ((SetT typ_s) as typ) holds)), then

          1. (Expr_ok: p' C'''' |- expr : exprIL)

          2. (Let (( typ ; ctk )) be $annot(exprIL))

          3. If (((ctk = (CTK)) \/ (ctk = (LCTK)))), then

            1. (Let C' be $add_styp(p', C'''', id, (((SetT typ_s) as typ) (NO) (CTK) ?())))

            2. Result in C', (ValueSetD id typ exprIL)

          3. Else Phantom#925

        1. Else Phantom#926

      2. Else Phantom#927

    2. Else Phantom#928

1. Else Phantom#929

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. Case analysis on decl''

      1. Case (% matches pattern `ErrD%`)

        1. (Let (ErrD member*) be decl'')

        2. If ($distinct_<member>(member*)), then

          1. (Let id_e be $concat_text(["error.", member]))*

          2. (Let val_e be (ErrV member))*

          3. (Let styp_e be (((ErrT) as typ) (NO) (LCTK) ?(val_e)))*

          4. (Let C' be $add_styps((GLOBAL), C'''', id_e*, styp_e*))

          5. Result in C', (ErrD member*)

        2. Else Phantom#930

      2. Case (% matches pattern `MatchKindD%`)

        1. (Let (MatchKindD member*) be decl'')

        2. If ($distinct_<member>(member*)), then

          1. (Let id_m be member)*

          2. (Let val_m be (MatchKindV member))*

          3. (Let styp_m be (((MatchKindT) as typ) (NO) (LCTK) ?(val_m)))*

          4. (Let C' be $add_styps((GLOBAL), C'''', id_m*, styp_m*))

          5. Result in C', (MatchKindD member*)

        2. Else Phantom#931

      3. Case (% matches pattern `StructD%%%`)

        1. (Let (StructD id tparam* (member_f, type_f)*) be decl'')

        2. (Let C' be $add_tparams((BLOCK), C'''', tparam*))

        3. (Type_ok: (BLOCK) C' |- type_f : typ_f tid_fresh_f*)*

        4. (Let tparam_hidden* be $concat_<tid>(tid_fresh_f**))

        5. (Let typ_s be ((StructT id (member_f, typ_f)*) as typ))

        6. (Let td be ((PolyD (tparam*, tparam_hidden*) -> typ_s) as typdef))

        7. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

          1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

          2. Result in C'', (StructD id tparam* tparam_hidden* (member_f, typ_f)*)

        7. Else Phantom#932

      4. Case (% matches pattern `HeaderD%%%`)

        1. (Let (HeaderD id tparam* (member_f, type_f)*) be decl'')

        2. (Let C' be $add_tparams((BLOCK), C'''', tparam*))

        3. (Type_ok: (BLOCK) C' |- type_f : typ_f tid_fresh_f*)*

        4. (Let tparam_hidden* be $concat_<tid>(tid_fresh_f**))

        5. (Let typ_s be ((HeaderT id (member_f, typ_f)*) as typ))

        6. (Let td be ((PolyD (tparam*, tparam_hidden*) -> typ_s) as typdef))

        7. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

          1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

          2. Result in C'', (HeaderD id tparam* tparam_hidden* (member_f, typ_f)*)

        7. Else Phantom#933

      5. Case (% matches pattern `UnionD%%%`)

        1. (Let (UnionD id tparam* (member_f, type_f)*) be decl'')

        2. (Let C' be $add_tparams((BLOCK), C'''', tparam*))

        3. (Type_ok: (BLOCK) C' |- type_f : typ_f tid_fresh_f*)*

        4. (Let tparam_hidden* be $concat_<tid>(tid_fresh_f**))

        5. (Let typ_s be ((UnionT id (member_f, typ_f)*) as typ))

        6. (Let td be ((PolyD (tparam*, tparam_hidden*) -> typ_s) as typdef))

        7. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

          1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

          2. Result in C'', (UnionD id tparam* tparam_hidden* (member_f, typ_f)*)

        7. Else Phantom#934

      6. Case (% matches pattern `EnumD%%`)

        1. (Let (EnumD id member*) be decl'')

        2. If ($distinct_<member>(member*)), then

          1. (Let id_e be $concat_text([id, ".", member]))*

          2. (Let val_e be (EnumFieldV id member))*

          3. (Let typ_e be ((EnumT id member*) as typ))

          4. (Let styp_e be (typ_e (NO) (LCTK) ?(val_e)))*

          5. (Let C' be $add_styps((GLOBAL), C'''', id_e*, styp_e*))

          6. (Let td be ((MonoD typ_e) as typdef))

          7. (Let tidset be $bound_tids((GLOBAL), C''''))

          8. If ((TypeDef_wf: tidset |- td holds)), then

            1. (Let C'' be $add_typdef((GLOBAL), C', id, td))

            2. Result in C'', (EnumD id member*)

          8. Else Phantom#935

        2. Else Phantom#936

      7. Case (% matches pattern `SEnumD%%%`)

        1. (Let (SEnumD id type (member, expr)*) be decl'')

        2. If ($distinct_<member>(member*)), then

          1. (Type_ok: (GLOBAL) C'''' |- type : typ tid*)

          2. If ((tid* matches pattern [])), then

            1. If ((Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds)), then

              1. (SEnum_fields_ok: C'''' id typ [] |- (member, expr)* : C_1 (member', val_s)*)

              2. If ((member' = member))*, then

                1. (Let id_s be $concat_text([id, ".", member]))*

                2. (Let typ_s be ((SEnumT id typ (member, val_s)*) as typ))

                3. (Let styp_s be (typ_s (NO) (LCTK) ?(val_s)))*

                4. (Let C_2 be $add_styps((GLOBAL), C_1, id_s*, styp_s*))

                5. (Let td be ((MonoD typ_s) as typdef))

                6. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

                  1. (Let C_3 be $add_typdef((GLOBAL), C_2, id, td))

                  2. Result in C_3, (SEnumD id typ (member, val_s)*)

                6. Else Phantom#937

              2. Else Phantom#938

            1. Else Phantom#939

          2. Else Phantom#940

        2. Else Phantom#941

      8. Case (% matches pattern `NewTypeD%%`)

        1. (Let (NewTypeD id typedef) be decl'')

        2. Case analysis on typedef

          1. Case (% matches pattern `TypeD%`)

            1. (Let (TypeD type) be typedef)

            2. (Type_ok: (GLOBAL) C'''' |- type : typ tid*)

            3. If ((tid* matches pattern [])), then

              1. If ((Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds)), then

                1. (Let typ_n be ((NewT id typ) as typ))

                2. (Let td be ((MonoD typ_n) as typdef))

                3. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

                  1. (Let C' be $add_typdef((GLOBAL), C'''', id, td))

                  2. Result in C', (NewTypeD id (TypeD typ))

                3. Else Phantom#942

              1. Else Phantom#943

            3. Else Phantom#944

          2. Case (% matches pattern `DeclD%`)

            1. (Let (DeclD decl'') be typedef)

            2. (Decl_ok: (GLOBAL) C'''' |- decl'' : C' declIL)

            3. (Let ({ tid* }) be $diff_set<tid>($dom_map<tid, typdef>(C'.GLOBAL.TDENV), $dom_map<tid, typdef>(C''''.GLOBAL.TDENV)))

            4. If ((tid* matches pattern [ _/1 ])), then

              1. (Let [tid_n] be tid*)

              2. (Let typdef'? be $find_typdef((GLOBAL), C', (CURRENT tid_n)))

              3. If ((typdef'? matches pattern (_))), then

                1. (Let ?(typdef) be typdef'?)

                2. Case analysis on typdef

                  1. Case (% has type monotypdef)

                    1. (Let (MonoD typ_n) be (typdef as monotypdef))

                    2. (Let td be ((MonoD ((NewT id typ_n) as typ)) as typdef))

                    3. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

                      1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

                      2. Result in C'', (NewTypeD id (DeclD declIL))

                    3. Else Phantom#945

                  2. Case (% has type polytypdef)

                    1. (Let ptd be (typdef as polytypdef))

                    2. (Let td be ((MonoD ((NewT id ((SpecT ptd []) as typ)) as typ)) as typdef))

                    3. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

                      1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

                      2. Result in C'', (NewTypeD id (DeclD declIL))

                    3. Else Phantom#946

              3. Else Phantom#947

            4. Else Phantom#948

      9. Case (% matches pattern `TypeDefD%%`)

        1. (Let (TypeDefD id typedef) be decl'')

        2. Case analysis on typedef

          1. Case (% matches pattern `TypeD%`)

            1. (Let (TypeD type) be typedef)

            2. (Type_ok: (GLOBAL) C'''' |- type : typ tid*)

            3. If ((tid* matches pattern [])), then

              1. If ((Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds)), then

                1. (Let typ_d be ((DefT id typ) as typ))

                2. (Let td be ((MonoD typ_d) as typdef))

                3. (Let tidset be $bound_tids((GLOBAL), C''''))

                4. If ((TypeDef_wf: tidset |- td holds)), then

                  1. (Let C' be $add_typdef((GLOBAL), C'''', id, td))

                  2. Result in C', (TypeDefD id (TypeD typ))

                4. Else Phantom#949

              1. Else Phantom#950

            3. Else Phantom#951

          2. Case (% matches pattern `DeclD%`)

            1. (Let (DeclD decl'') be typedef)

            2. (Decl_ok: (GLOBAL) C'''' |- decl'' : C' declIL)

            3. (Let ({ tid* }) be $diff_set<tid>($dom_map<tid, typdef>(C'.GLOBAL.TDENV), $dom_map<tid, typdef>(C''''.GLOBAL.TDENV)))

            4. If ((tid* matches pattern [ _/1 ])), then

              1. (Let [tid_d] be tid*)

              2. (Let typdef'? be $find_typdef((GLOBAL), C', (CURRENT tid_d)))

              3. If ((typdef'? matches pattern (_))), then

                1. (Let ?(typdef) be typdef'?)

                2. Case analysis on typdef

                  1. Case (% has type monotypdef)

                    1. (Let (MonoD typ_d) be (typdef as monotypdef))

                    2. (Let td be ((MonoD ((DefT id typ_d) as typ)) as typdef))

                    3. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

                      1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

                      2. Result in C'', (TypeDefD id (DeclD declIL))

                    3. Else Phantom#952

                  2. Case (% has type polytypdef)

                    1. (Let ptd be (typdef as polytypdef))

                    2. (Let td be ((MonoD ((DefT id ((SpecT ptd []) as typ)) as typ)) as typdef))

                    3. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

                      1. (Let C'' be $add_typdef((GLOBAL), C'''', id, td))

                      2. Result in C'', (TypeDefD id (DeclD declIL))

                    3. Else Phantom#953

              3. Else Phantom#954

            4. Else Phantom#955

      10. Case (% matches pattern `FuncD%%%%%`)

        1. (Let (FuncD id type_r tparam* param* block) be decl'')

        2. (Let fid be $to_fid(id, param*))

        3. (Let C_1 be $add_typdefs((LOCAL), C'''', tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*))

        4. (Type_ok: (LOCAL) C_1 |- type_r : typ_r tid*)

        5. If ((tid* matches pattern [])), then

          1. (Let C_2 be $set_localkind(C_1, (FUNC typ_r)))

          2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*)*

          3. (Let tparam_hidden* be $concat_<tid>(tid_fresh_p**))

          4. (Let C_3 be $add_params((LOCAL), C_2, (paramIL* as paramtyp*)))

          5. (Block_ok: (LOCAL) C_3 (CONT) (INIT) |- block : C_4 f blockIL)

          6. If (((f = (RET)) \/ ((f = (CONT)) /\ (typ_r = ((VoidT) as typ))))), then

            1. (Let fd be ((PolyFD (tparam*, tparam_hidden*) -> (FuncT (paramIL* as paramtyp*) typ_r)) as funcdef))

            2. If ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- fd holds)), then

              1. (Let C_5 be $add_funcdef((GLOBAL), C'''', fid, fd))

              2. Result in C_5, (FuncD id typ_r tparam* tparam_hidden* paramIL* blockIL)

            2. Else Phantom#956

          6. Else Phantom#957

        5. Else Phantom#958

      11. Case (% matches pattern `ExternFuncD%%%%`)

        1. (Let (ExternFuncD id type_r tparam* param*) be decl'')

        2. (Let fid be $to_fid(id, param*))

        3. (Let C_1 be $add_typdefs((LOCAL), C'''', tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*))

        4. (Type_ok: (LOCAL) C_1 |- type_r : typ_r tid*)

        5. If ((tid* matches pattern [])), then

          1. (Let C_2 be $set_localkind(C_1, (EXTERNFUNC)))

          2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*)*

          3. (Let tparam_hidden* be $concat_<tid>(tid_fresh_p**))

          4. (Let C_3 be $add_params((LOCAL), C_2, (paramIL* as paramtyp*)))

          5. (Let fd be ((PolyFD (tparam*, tparam_hidden*) -> (ExternFuncT (paramIL* as paramtyp*) typ_r)) as funcdef))

          6. If ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- fd holds)), then

            1. (Let C_4 be $add_funcdef((GLOBAL), C'''', fid, fd))

            2. Result in C_4, (ExternFuncD id typ_r tparam* tparam_hidden* paramIL*)

          6. Else Phantom#959

        5. Else Phantom#960

      12. Case (% matches pattern `ExternObjectD%%%`)

        1. (Let (ExternObjectD id tparam* method*) be decl'')

        2. (Let (method_c*, method_m*) be $split_methods(method*))

        3. (Let C_1 be $set_blockkind(C'''', (EXTERN)))

        4. (Let C_2 be $add_typdefs((BLOCK), C_1, tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*))

        5. (Methods_ok: C_2 id |- method_m* : C_3 methodIL_m*)

        6. (Let td be ((PolyD (tparam*, []) -> ((ExternT id C_3.BLOCK.FDENV) as typ)) as typdef))

        7. (Let C_4 be $add_typdef((GLOBAL), C'''', id, td))

        8. (Let C_5 be $set_blockkind(C_4, (EXTERN)))

        9. (Let C_6 be $add_typdefs((BLOCK), C_5, tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*))

        10. (Methods_ok: C_6 id |- method_c* : C_7 methodIL_c*)

        11. (Let C_8 be C_4[GLOBAL.CDENV = C_7.GLOBAL.CDENV])

        12. Result in C_8, (ExternObjectD id tparam* methodIL_c* ++ methodIL_m*)

      13. Case (% matches pattern `ParserTypeD%%%`)

        1. (Let (ParserTypeD id tparam* param*) be decl'')

        2. (Let C_1 be $set_blockkind(C'''', (PARSER)))

        3. (Let C_2 be $add_typdefs((BLOCK), C_1, tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*))

        4. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*)*

        5. (Let (id_p dir_p typ_p exprIL_p?) be paramIL)*

        6. (Let tparam_hidden* be $concat_<tid>(tid_fresh_p**))

        7. (Let td be ((PolyD (tparam*, tparam_hidden*) -> ((ParserT id (id_p dir_p typ_p exprIL_p?)*) as typ)) as typdef))

        8. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

          1. (Let C_3 be $add_typdef((GLOBAL), C'''', id, td))

          2. Result in C_3, (ParserTypeD id tparam* tparam_hidden* paramIL*)

        8. Else Phantom#961

      14. Case (% matches pattern `ParserD%%%%%`)

        1. (Let (ParserD id param* cparam* decl''* parserstate*) be decl'')

        2. (Let cid be $to_fid(id, cparam*))

        3. (Let C_1 be $set_blockkind(C'''', (PARSER)))

        4. (Param_ok: (LOCAL) C_1 |- cparam : cparamIL tid*)*

        5. If ((tid* matches pattern []))*, then

          1. (Let C_2 be $add_params((BLOCK), C_1, (cparamIL* as paramtyp*)))

          2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid'*)*

          3. If ((tid'* matches pattern []))*, then

            1. (Let funcdef_apply be ((MonoFD (ParserApplyMethodT (paramIL* as paramtyp*))) as funcdef))

            2. If ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds)), then

              1. (Let C_3 be $add_params((BLOCK), C_2, (paramIL* as paramtyp*)))

              2. (Decls_ok: (BLOCK) C_3 |- decl''* : C_4 declIL*)

              3. (Let (statelabel block) be parserstate)*

              4. If ($distinct_<statelabel>(statelabel*)), then

                1. If ("start" is in statelabel*), then

                  1. If (~"accept" is in statelabel*), then

                    1. If (~"reject " is in statelabel*), then

                      1. (Let statelabel'* be "accept" :: "reject" :: statelabel*)

                      2. (Let C_5 be $set_localkind(C_4, (PARSERSTATE)))

                      3. (Let styp* be $repeat_<styp>((((StateT) as typ) (NO) (DYN) ?()), |statelabel'*|))

                      4. (Let C_6 be $add_styps((BLOCK), C_5, statelabel'*, styp*))

                      5. (ParserState_ok: C_6 |- parserstate : parserstateIL)*

                      6. (Let ptd be (PolyD ([], []) -> ((ParserT id (paramIL* as paramtyp*)) as typ)))

                      7. (Let typ be ((SpecT ptd []) as typ))

                      8. (Let cd be (ConsD ([], []) -> (ConsT (cparamIL* as paramtyp*) typ)))

                      9. If ((ConsDef_wf: $bound_tids((GLOBAL), C'''') |- cd holds)), then

                        1. (Let C_8 be $add_consdef((GLOBAL), C'''', cid, cd))

                        2. Result in C_8, (ParserD id paramIL* cparamIL* declIL* parserstateIL*)

                      9. Else Phantom#962

                    1. Else Phantom#963

                  1. Else Phantom#964

                1. Else Phantom#965

              4. Else Phantom#966

            2. Else Phantom#967

          3. Else Phantom#968

        5. Else Phantom#969

      15. Case (% matches pattern `ControlTypeD%%%`)

        1. (Let (ControlTypeD id tparam* param*) be decl'')

        2. (Let C' be $add_typdefs((BLOCK), C'''', tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*))

        3. (Let C'' be $set_blockkind(C'''', (CONTROL)))

        4. (Param_ok: (LOCAL) C' |- param : paramIL tid_fresh_p*)*

        5. (Let (id_p dir_p typ_p exprIL_p?) be paramIL)*

        6. (Let tparam_hidden* be $concat_<tid>(tid_fresh_p**))

        7. (Let td be ((PolyD (tparam*, tparam_hidden*) -> ((ControlT id (id_p dir_p typ_p exprIL_p?)*) as typ)) as typdef))

        8. If ((TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds)), then

          1. (Let C''' be $add_typdef((GLOBAL), C'''', id, td))

          2. Result in C''', (ControlTypeD id tparam* tparam_hidden* paramIL*)

        8. Else Phantom#970

      16. Case (% matches pattern `ControlD%%%%%`)

        1. (Let (ControlD id param* cparam* decl''* block) be decl'')

        2. (Let cid be $to_fid(id, cparam*))

        3. (Let C_1 be $set_blockkind(C'''', (CONTROL)))

        4. (Param_ok: (LOCAL) C_1 |- cparam : cparamIL tid*)*

        5. If ((tid* matches pattern []))*, then

          1. (Let C_2 be $add_params((BLOCK), C_1, (cparamIL* as paramtyp*)))

          2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid'*)*

          3. If ((tid'* matches pattern []))*, then

            1. (Let funcdef_apply be ((MonoFD (ControlApplyMethodT (paramIL* as paramtyp*))) as funcdef))

            2. If ((FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds)), then

              1. (Let C_3 be $add_params((BLOCK), C_2, (paramIL* as paramtyp*)))

              2. (Decls_ok: (BLOCK) C_3 |- decl''* : C_4 declIL*)

              3. (Let C_5 be $set_localkind(C_4, (CONTROLAPPLYMETHOD)))

              4. (Block_ok: (LOCAL) C_5 (CONT) (INIT) |- block : C_6 f blockIL)

              5. (Let ptd be (PolyD ([], []) -> ((ControlT id (paramIL* as paramtyp*)) as typ)))

              6. (Let typ be ((SpecT ptd []) as typ))

              7. (Let cd be (ConsD ([], []) -> (ConsT (cparamIL* as paramtyp*) typ)))

              8. If ((ConsDef_wf: $bound_tids((GLOBAL), C'''') |- cd holds)), then

                1. (Let C_7 be $add_consdef((GLOBAL), C'''', cid, cd))

                2. Result in C_7, (ControlD id paramIL* cparamIL* declIL* blockIL)

              8. Else Phantom#971

            2. Else Phantom#972

          3. Else Phantom#973

        5. Else Phantom#974

      17. Case (% matches pattern `PackageTypeD%%%`)

        1. (Let (PackageTypeD id tparam* cparam*) be decl'')

        2. (Let cid be $to_fid(id, cparam*))

        3. (Let C_1 be $add_typdefs((BLOCK), C'''', tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*))

        4. (Let C_2 be $set_blockkind(C_1, (PACKAGE)))

        5. (CParam_ok: (BLOCK) C_2 |- cparam : cparamIL tid_fresh_c*)*

        6. (Let tparam_hidden* be $concat_<tid>(tid_fresh_c**))

        7. (Let (_idIL _dirIL typ_c _exprIL?) be cparamIL)*

        8. (Let ptd be (PolyD (tparam*, tparam_hidden*) -> ((PackageT id typ_c*) as typ)))

        9. If ((TypeDef_wf: $bound_tids((BLOCK), C_2) |- (ptd as typdef) holds)), then

          1. (Let tparam'* be tparam* ++ tparam_hidden*)

          2. (Let typ be ((SpecT ptd ((VarT tparam') as typ)*) as typ))

          3. (Let cd be (ConsD (tparam*, tparam_hidden*) -> (ConsT (cparamIL* as paramtyp*) typ)))

          4. If ((ConsDef_wf: $bound_tids((BLOCK), C_2) |- cd holds)), then

            1. (Let C_3 be $add_typdef((GLOBAL), C'''', id, (ptd as typdef)))

            2. (Let C_4 be $add_consdef((GLOBAL), C_3, cid, cd))

            3. Result in C_4, (PackageTypeD id tparam* tparam_hidden* cparamIL*)

          4. Else Phantom#975

        9. Else Phantom#976

    1. Else Phantom#977

  2. Case (% matches pattern `BLOCK`)

    1. If ((decl'' matches pattern `TableD%%`)), then

      1. (Let (TableD id tbl) be decl'')

      2. If ((C''''.BLOCK.KIND matches pattern `CONTROL`)), then

        1. If ((|$keys_of_table(tbl)| <= 1)), then

          1. If ((|$actions_of_table(tbl)| = 1)), then

            1. (Let C_1 be $set_localkind(C'''', (TABLEAPPLYMETHOD)))

            2. (Table_props_ok: (LOCAL) C_1 $empty_tblctx |- tbl : tblctx' tblIL)

            3. (Table_type_decl_ok: (BLOCK) C_1 tblctx' |- id : C_2 typ_tbl)

            4. (Let typ be ((TableT id typ_tbl) as typ))

            5. If ((Type_wf: $bound_tids((BLOCK), C_2) |- typ holds)), then

              1. (Let C_3 be $add_styp((BLOCK), C_2, id, (typ (NO) (DYN) ?())))

              2. Result in C_3, (TableD id typ tblIL)

            5. Else Phantom#978

          1. Else Phantom#979

        1. Else Phantom#980

      2. Else Phantom#981

    1. Else Phantom#982

2. Else Phantom#983

;; ../../../../spec/4b-typing-relation.watsup:125.1-127.23
relation Decls_ok: p, C, decl*

1. Case analysis on decl*

  1. Case (% matches pattern [])

    1. Result in C, []

  2. Case (% matches pattern _ :: _)

    1. (Let decl_h :: decl_t* be decl*)

    2. (Decl_ok: p C |- decl_h : C' declIL_h)

    3. (Decls_ok: p C' |- decl_t* : C'' declIL_t*)

    4. Result in C'', declIL_h :: declIL_t*

;; ../../../../spec/4b-typing-relation.watsup:131.1-133.17
relation Prog_ok: decl*

1. (Let C be $empty_context)

2. (Decls_ok: (GLOBAL) C |- decl* : C' declIL*)

3. Result in C', declIL*

;; ../../../../spec/4b-typing-relation.watsup:137.18-137.29
syntax actctxt = 
   | `ACT`()
   | `NOACT`()

;; ../../../../spec/4b-typing-relation.watsup:138.1-140.29
relation Call_convention_ok: p, C, actctxt, (id dir typ_p' exprIL_deft?), (exprIL, typ_a')

1. Case analysis on dir

  1. Case (% matches pattern `IN`)

    1. (Let exprIL''? be $coerce_assign(exprIL, typ_p'))

    2. If ((exprIL''? matches pattern (_))), then

      1. (Let ?(exprIL') be exprIL''?)

      2. Result in exprIL'

    2. Else Phantom#984

  2. Case (% matches pattern `OUT`)

    1. If ((Type_alpha: typ_a' ~~ typ_p' holds)), then

      1. If ((Lval_ok: p C |- exprIL holds)), then

        1. Result in exprIL

      1. Else Phantom#985

    1. Else Phantom#986

  3. Case (% matches pattern `INOUT`)

    1. If ((Type_alpha: typ_a' ~~ typ_p' holds)), then

      1. If ((Lval_ok: p C |- exprIL holds)), then

        1. Result in exprIL

      1. Else Phantom#987

    1. Else Phantom#988

1. Else Phantom#989

2. Case analysis on actctxt

  1. Case (% matches pattern `ACT`)

    1. If ((dir matches pattern `NO`)), then

      1. (Let exprIL''? be $coerce_assign(exprIL, typ_p'))

      2. If ((exprIL''? matches pattern (_))), then

        1. (Let ?(exprIL') be exprIL''?)

        2. Result in exprIL'

      2. Else Phantom#990

    1. Else Phantom#991

  2. Case (% matches pattern `NOACT`)

    1. If ((dir matches pattern `NO`)), then

      1. (Let (( _typ ; ctk )) be $annot(exprIL))

      2. If (((ctk = (LCTK)) \/ (ctk = (CTK)))), then

        1. If ((Type_alpha: typ_a' ~~ typ_p' holds)), then

          1. Result in exprIL

        1. Else Phantom#992

      2. Else Phantom#993

    1. Else Phantom#994

;; ../../../../spec/4b-typing-relation.watsup:141.1-143.29
relation Call_convention_arg_ok: p, C, actctxt, pt', (argIL, typ')

1. Case analysis on argIL

  1. Case (% matches pattern `ExprA%`)

    1. (Let (ExprA exprIL) be argIL)

    2. (Call_convention_ok: p C actctxt |- pt' ~~ (exprIL, typ') : exprIL')

    3. Result in (ExprA exprIL')

  2. Case (% matches pattern `NameA%%`)

    1. (Let (NameA id exprIL''?) be argIL)

    2. If ((exprIL''? matches pattern (_))), then

      1. (Let ?(exprIL) be exprIL''?)

      2. (Call_convention_ok: p C actctxt |- pt' ~~ (exprIL, typ') : exprIL')

      3. Result in (NameA id ?(exprIL'))

    2. Else Phantom#995

1. Else Phantom#996

2. (Let (_id dir _typ _exprIL?) be pt')

3. If ((dir matches pattern `OUT`)), then

  1. Case analysis on argIL

    1. Case (% matches pattern `NameA%%`)

      1. (Let (NameA id exprIL?) be argIL)

      2. If ((exprIL? matches pattern ())), then

        1. Result in (NameA id ?())

      2. Else Phantom#997

    2. Case (% matches pattern `AnyA`)

      1. Result in (AnyA)

  1. Else Phantom#998

3. Else Phantom#999

;; ../../../../spec/4b-typing-relation.watsup:149.1-151.23
relation Call_site_ok: cursor, C, functyp

1. Case analysis on cursor

  1. Case (% matches pattern `BLOCK`)

    1. Case analysis on functyp

      1. Case (% matches pattern `ExternFuncT%%`)

        1. (Let (ExternFuncT _paramtyp* _typ) be functyp)

        2. If (((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL)))), then

          1. The relation holds

        2. Else Phantom#1000

      2. Case (% matches pattern `BuiltinMethodT%%`)

        1. (Let (BuiltinMethodT _paramtyp* _typ) be functyp)

        2. If (((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL)))), then

          1. The relation holds

        2. Else Phantom#1001

      3. Case (% matches pattern `ExternMethodT%%`)

        1. (Let (ExternMethodT _paramtyp* _typ) be functyp)

        2. If (((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL)))), then

          1. The relation holds

        2. Else Phantom#1002

      4. Case (% matches pattern `ExternAbstractMethodT%%`)

        1. (Let (ExternAbstractMethodT _paramtyp* _typ) be functyp)

        2. If (((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL)))), then

          1. The relation holds

        2. Else Phantom#1003

    1. Else Phantom#1004

  2. Case (% matches pattern `LOCAL`)

    1. Case analysis on functyp

      1. Case (% matches pattern `ActionT%`)

        1. (Let (ActionT _paramtyp*) be functyp)

        2. If ((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        2. Else Phantom#1005

      2. Case (% matches pattern `FuncT%%`)

        1. (Let (FuncT _paramtyp* _typ) be functyp)

        2. (Let lkind be C.LOCAL.KIND)

        3. If ((lkind matches pattern `FUNC%`)), then

          1. (Let (FUNC typ) be lkind)

          2. The relation holds

        3. Else Phantom#1006

        4. If (((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        4. Else Phantom#1007

      3. Case (% matches pattern `ExternFuncT%%`)

        1. (Let (ExternFuncT _paramtyp* _typ) be functyp)

        2. (Let lkind be C.LOCAL.KIND)

        3. If ((lkind matches pattern `EXTERNABSTRACTMETHOD%`)), then

          1. (Let (EXTERNABSTRACTMETHOD typ) be lkind)

          2. The relation holds

        3. Else Phantom#1008

        4. If (((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        4. Else Phantom#1009

      4. Case (% matches pattern `BuiltinMethodT%%`)

        1. (Let (BuiltinMethodT _paramtyp* _typ) be functyp)

        2. (Let lkind be C.LOCAL.KIND)

        3. Case analysis on lkind

          1. Case (% matches pattern `FUNC%`)

            1. (Let (FUNC typ) be lkind)

            2. The relation holds

          2. Case (% matches pattern `EXTERNABSTRACTMETHOD%`)

            1. (Let (EXTERNABSTRACTMETHOD typ) be lkind)

            2. The relation holds

        3. Else Phantom#1010

        4. If (((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        4. Else Phantom#1011

      5. Case (% matches pattern `ExternMethodT%%`)

        1. (Let (ExternMethodT _paramtyp* _typ) be functyp)

        2. (Let lkind be C.LOCAL.KIND)

        3. If ((lkind matches pattern `EXTERNABSTRACTMETHOD%`)), then

          1. (Let (EXTERNABSTRACTMETHOD typ) be lkind)

          2. The relation holds

        3. Else Phantom#1012

        4. If (((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        4. Else Phantom#1013

      6. Case (% matches pattern `ExternAbstractMethodT%%`)

        1. (Let (ExternAbstractMethodT _paramtyp* _typ) be functyp)

        2. (Let lkind be C.LOCAL.KIND)

        3. If ((lkind matches pattern `EXTERNABSTRACTMETHOD%`)), then

          1. (Let (EXTERNABSTRACTMETHOD typ) be lkind)

          2. The relation holds

        3. Else Phantom#1014

        4. If (((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        4. Else Phantom#1015

      7. Case (% matches pattern `ParserApplyMethodT%`)

        1. (Let (ParserApplyMethodT _paramtyp*) be functyp)

        2. If ((C.LOCAL.KIND matches pattern `PARSERSTATE`)), then

          1. The relation holds

        2. Else Phantom#1016

      8. Case (% matches pattern `ControlApplyMethodT%`)

        1. (Let (ControlApplyMethodT _paramtyp*) be functyp)

        2. If ((C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`)), then

          1. The relation holds

        2. Else Phantom#1017

      9. Case (% matches pattern `TableApplyMethodT%`)

        1. (Let (TableApplyMethodT _typ) be functyp)

        2. If (((C.LOCAL.KIND = (CONTROLAPPLYMETHOD)) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD)))), then

          1. The relation holds

        2. Else Phantom#1018

1. Else Phantom#1019

;; ../../../../spec/4b-typing-relation.watsup:152.1-154.35
relation Call_ok: p, C, tid'*, functyp, targIL*, arg*, id_deft'*

1. If ((tid'* matches pattern [])), then

  1. Case analysis on functyp

    1. Case (% matches pattern `ActionT%`)

      1. (Let (ActionT pt*) be functyp)

      2. (Let pt'* be $filter_default_args(pt*, id_deft'*))

      3. (Arg_ok: p C |- arg : argIL typ_a)*

      4. If ((|pt'*| = |argIL*|)), then

        1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

        2. If ((FuncType_wf: $bound_tids(p, C) |- (ActionT pt*) holds)), then

          1. If ((Call_site_ok: p C |- (ActionT pt*) :CALLSITE_OK holds)), then

            1. If (~$is_table_apply_in_action_arg(argIL))*, then

              1. (Call_convention_arg_ok: p C (ACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

              2. Result in ((VoidT) as typ), [], argIL*

            1. Else Phantom#1020

          1. Else Phantom#1021

        2. Else Phantom#1022

      4. Else Phantom#1023

    2. Case (% matches pattern `ExternFuncT%%`)

      1. (Let (ExternFuncT pt* typ_r) be functyp)

      2. (Let pt'* be $filter_default_args(pt*, id_deft'*))

      3. (Arg_ok: p C |- arg : argIL typ_a)*

      4. If ((|pt'*| = |argIL*|)), then

        1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

        2. If ((FuncType_wf: $bound_tids(p, C) |- (ExternFuncT pt* typ_r) holds)), then

          1. If ((Call_site_ok: p C |- (ExternFuncT pt* typ_r) :CALLSITE_OK holds)), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

            2. Result in typ_r, targIL*, argIL''*

          1. Else Phantom#1024

        2. Else Phantom#1025

      4. Else Phantom#1026

    3. Case (% matches pattern `FuncT%%`)

      1. (Let (FuncT pt* typ_r) be functyp)

      2. (Let pt'* be $filter_default_args(pt*, id_deft'*))

      3. (Arg_ok: p C |- arg : argIL typ_a)*

      4. If ((|pt'*| = |argIL*|)), then

        1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

        2. If ((FuncType_wf: $bound_tids(p, C) |- (FuncT pt* typ_r) holds)), then

          1. If ((Call_site_ok: p C |- (FuncT pt* typ_r) :CALLSITE_OK holds)), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

            2. Result in typ_r, targIL*, argIL''*

          1. Else Phantom#1027

        2. Else Phantom#1028

      4. Else Phantom#1029

    4. Case (% matches pattern `BuiltinMethodT%%`)

      1. (Let (BuiltinMethodT pt* typ_r) be functyp)

      2. If ((targIL* matches pattern [])), then

        1. (Let pt'* be $filter_default_args(pt*, id_deft'*))

        2. (Arg_ok: p C |- arg : argIL typ_a)*

        3. If ((|pt'*| = |argIL*|)), then

          1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

          2. If ((FuncType_wf: $bound_tids(p, C) |- (BuiltinMethodT pt* typ_r) holds)), then

            1. If ((Call_site_ok: p C |- (BuiltinMethodT pt* typ_r) :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

              2. Result in typ_r, [], argIL''*

            1. Else Phantom#1030

          2. Else Phantom#1031

        3. Else Phantom#1032

      2. Else Phantom#1033

    5. Case (% matches pattern `ExternMethodT%%`)

      1. (Let (ExternMethodT pt* typ_r) be functyp)

      2. (Let pt'* be $filter_default_args(pt*, id_deft'*))

      3. (Arg_ok: p C |- arg : argIL typ_a)*

      4. If ((|pt'*| = |argIL*|)), then

        1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

        2. If ((FuncType_wf: $bound_tids(p, C) |- (ExternMethodT pt* typ_r) holds)), then

          1. If ((Call_site_ok: p C |- (ExternMethodT pt* typ_r) :CALLSITE_OK holds)), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

            2. Result in typ_r, targIL*, argIL''*

          1. Else Phantom#1034

        2. Else Phantom#1035

      4. Else Phantom#1036

    6. Case (% matches pattern `ExternAbstractMethodT%%`)

      1. (Let (ExternAbstractMethodT pt* typ_r) be functyp)

      2. (Let pt'* be $filter_default_args(pt*, id_deft'*))

      3. (Arg_ok: p C |- arg : argIL typ_a)*

      4. If ((|pt'*| = |argIL*|)), then

        1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

        2. If ((FuncType_wf: $bound_tids(p, C) |- (ExternAbstractMethodT pt* typ_r) holds)), then

          1. If ((Call_site_ok: p C |- (ExternAbstractMethodT pt* typ_r) :CALLSITE_OK holds)), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

            2. Result in typ_r, targIL*, argIL''*

          1. Else Phantom#1037

        2. Else Phantom#1038

      4. Else Phantom#1039

    7. Case (% matches pattern `ParserApplyMethodT%`)

      1. (Let (ParserApplyMethodT pt*) be functyp)

      2. If ((targIL* matches pattern [])), then

        1. (Let pt'* be $filter_default_args(pt*, id_deft'*))

        2. (Arg_ok: p C |- arg : argIL typ_a)*

        3. If ((|pt'*| = |argIL*|)), then

          1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

          2. If ((FuncType_wf: $bound_tids(p, C) |- (ParserApplyMethodT pt*) holds)), then

            1. If ((Call_site_ok: p C |- (ParserApplyMethodT pt*) :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

              2. Result in ((VoidT) as typ), [], argIL''*

            1. Else Phantom#1040

          2. Else Phantom#1041

        3. Else Phantom#1042

      2. Else Phantom#1043

    8. Case (% matches pattern `ControlApplyMethodT%`)

      1. (Let (ControlApplyMethodT pt*) be functyp)

      2. If ((targIL* matches pattern [])), then

        1. (Let pt'* be $filter_default_args(pt*, id_deft'*))

        2. (Arg_ok: p C |- arg : argIL typ_a)*

        3. If ((|pt'*| = |argIL*|)), then

          1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

          2. If ((FuncType_wf: $bound_tids(p, C) |- (ControlApplyMethodT pt*) holds)), then

            1. If ((Call_site_ok: p C |- (ControlApplyMethodT pt*) :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

              2. Result in ((VoidT) as typ), [], argIL''*

            1. Else Phantom#1044

          2. Else Phantom#1045

        3. Else Phantom#1046

      2. Else Phantom#1047

    9. Case (% matches pattern `TableApplyMethodT%`)

      1. (Let (TableApplyMethodT typ_r) be functyp)

      2. If ((targIL* matches pattern [])), then

        1. If ((arg* matches pattern [])), then

          1. If ((id_deft'* matches pattern [])), then

            1. If ((FuncType_wf: $bound_tids(p, C) |- (TableApplyMethodT typ_r) holds)), then

              1. If ((Call_site_ok: p C |- (TableApplyMethodT typ_r) :CALLSITE_OK holds)), then

                1. Result in typ_r, [], []

              1. Else Phantom#1048

            1. Else Phantom#1049

          1. Else Phantom#1050

        1. Else Phantom#1051

      2. Else Phantom#1052

1. Else Phantom#1053

2. Case analysis on functyp

  1. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT pt* typ_r) be functyp)

    2. (Let pt'* be $filter_default_args(pt*, id_deft'*))

    3. (Arg_ok: p C |- arg : argIL typ_a)*

    4. If ((|pt'*| = |argIL*|)), then

      1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

      2. (Let theta be $infer_targs(tid'*, pt''*, typ_a*))

      3. (Let typ? be $find_map<tid, typ>(theta, tid'))*

      4. If ((typ? matches pattern (_)))*, then

        1. (Let ?(targIL') be typ?)*

        2. (Let targIL''* be targIL* ++ targIL'*)

        3. (Let functyp' be $subst_functyp(theta, (ExternFuncT pt''* typ_r)))

        4. If ((functyp' matches pattern `ExternFuncT%%`)), then

          1. (Let (ExternFuncT pt'''* typ_r') be functyp')

          2. If ((FuncType_wf: $bound_tids(p, C) |- (ExternFuncT pt'''* typ_r') holds)), then

            1. If ((Call_site_ok: p C |- (ExternFuncT pt'''* typ_r') :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*

              2. Result in typ_r', targIL''*, argIL''*

            1. Else Phantom#1054

          2. Else Phantom#1055

        4. Else Phantom#1056

      4. Else Phantom#1057

    4. Else Phantom#1058

  2. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT pt* typ_r) be functyp)

    2. (Let pt'* be $filter_default_args(pt*, id_deft'*))

    3. (Arg_ok: p C |- arg : argIL typ_a)*

    4. If ((|pt'*| = |argIL*|)), then

      1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

      2. (Let theta be $infer_targs(tid'*, pt''*, typ_a*))

      3. (Let typ? be $find_map<tid, typ>(theta, tid'))*

      4. If ((typ? matches pattern (_)))*, then

        1. (Let ?(targIL') be typ?)*

        2. (Let targIL''* be targIL* ++ targIL'*)

        3. (Let functyp' be $subst_functyp(theta, (FuncT pt''* typ_r)))

        4. If ((functyp' matches pattern `FuncT%%`)), then

          1. (Let (FuncT pt'''* typ_r') be functyp')

          2. If ((FuncType_wf: $bound_tids(p, C) |- (FuncT pt'''* typ_r') holds)), then

            1. If ((Call_site_ok: p C |- (FuncT pt'''* typ_r') :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*

              2. Result in typ_r', targIL''*, argIL''*

            1. Else Phantom#1059

          2. Else Phantom#1060

        4. Else Phantom#1061

      4. Else Phantom#1062

    4. Else Phantom#1063

  3. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT pt* typ_r) be functyp)

    2. (Let pt'* be $filter_default_args(pt*, id_deft'*))

    3. (Arg_ok: p C |- arg : argIL typ_a)*

    4. If ((|pt'*| = |argIL*|)), then

      1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

      2. (Let theta be $infer_targs(tid'*, pt''*, typ_a*))

      3. (Let typ? be $find_map<tid, typ>(theta, tid'))*

      4. If ((typ? matches pattern (_)))*, then

        1. (Let ?(targIL') be typ?)*

        2. (Let targIL''* be targIL* ++ targIL'*)

        3. (Let functyp' be $subst_functyp(theta, (ExternMethodT pt''* typ_r)))

        4. If ((functyp' matches pattern `ExternMethodT%%`)), then

          1. (Let (ExternMethodT pt'''* typ_r') be functyp')

          2. If ((FuncType_wf: $bound_tids(p, C) |- (ExternMethodT pt'''* typ_r') holds)), then

            1. If ((Call_site_ok: p C |- (ExternMethodT pt'''* typ_r') :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*

              2. Result in typ_r', targIL''*, argIL''*

            1. Else Phantom#1064

          2. Else Phantom#1065

        4. Else Phantom#1066

      4. Else Phantom#1067

    4. Else Phantom#1068

  4. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT pt* typ_r) be functyp)

    2. (Let pt'* be $filter_default_args(pt*, id_deft'*))

    3. (Arg_ok: p C |- arg : argIL typ_a)*

    4. If ((|pt'*| = |argIL*|)), then

      1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

      2. (Let theta be $infer_targs(tid'*, pt''*, typ_a*))

      3. (Let typ? be $find_map<tid, typ>(theta, tid'))*

      4. If ((typ? matches pattern (_)))*, then

        1. (Let ?(targIL') be typ?)*

        2. (Let targIL''* be targIL* ++ targIL'*)

        3. (Let functyp' be $subst_functyp(theta, (ExternAbstractMethodT pt''* typ_r)))

        4. If ((functyp' matches pattern `ExternAbstractMethodT%%`)), then

          1. (Let (ExternAbstractMethodT pt'''* typ_r') be functyp')

          2. If ((FuncType_wf: $bound_tids(p, C) |- (ExternAbstractMethodT pt'''* typ_r') holds)), then

            1. If ((Call_site_ok: p C |- (ExternAbstractMethodT pt'''* typ_r') :CALLSITE_OK holds)), then

              1. (Call_convention_arg_ok: p C (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*

              2. Result in typ_r', targIL''*, argIL''*

            1. Else Phantom#1069

          2. Else Phantom#1070

        4. Else Phantom#1071

      4. Else Phantom#1072

    4. Else Phantom#1073

2. Else Phantom#1074

;; ../../../../spec/4b-typing-relation.watsup:159.1-161.29
relation FuncType_ok: p, C, name, targIL*, arg*

1. (Let (fid, funcdef, id*)? be $find_funcdef(p, C, name, arg*))

2. If (((fid, funcdef, id*)? matches pattern (_))), then

  1. (Let ?((fid, fd, id_deft*)) be (fid, funcdef, id*)?)

  2. (Let (ft, tid_fresh*) be $specialize_funcdef(fd, targIL*))

  3. Result in ft, tid_fresh*, id_deft*

2. Else Phantom#1075

;; ../../../../spec/4b-typing-relation.watsup:162.1-164.32
relation MethodType_ok: p, C, expr_b, member', targIL*, arg*

1. If ((targIL* matches pattern [])), then

  1. If ((arg* matches pattern [])), then

    1. (Expr_ok: p C |- expr_b : exprIL_b)

    2. If (member' is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. Result in (BuiltinMethodT [] ((IntT) as typ)), exprIL_b, [], []

    2. Else Phantom#1076

  1. Else Phantom#1077

  2. Case analysis on member'

    1. Case (% is in ["push_front", "pop_front"])

      1. (Expr_ok: p C |- expr_b : exprIL_b)

      2. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

      3. (Let typ be $canon_typ(typ_b))

      4. If ((typ has type datatyp)), then

        1. (Let datatyp be (typ as datatyp))

        2. If ((datatyp matches pattern `StackT%%`)), then

          1. (Let (StackT typ_b_in int_b) be datatyp)

          2. (Let pt be ("count" (NO) ((IntT) as typ) ?()))

          3. Result in (BuiltinMethodT [pt] ((IntT) as typ)), exprIL_b, [], []

        2. Else Phantom#1078

      4. Else Phantom#1079

    2. Case (% is in ["setValid", "setInvalid"])

      1. (Expr_ok: p C |- expr_b : exprIL_b)

      2. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

      3. (Let typ be $canon_typ(typ_b))

      4. If ((typ has type datatyp)), then

        1. (Let datatyp be (typ as datatyp))

        2. If ((datatyp matches pattern `HeaderT%%`)), then

          1. (Let (HeaderT id_b (member_b, typ_b_in)*) be datatyp)

          2. Result in (BuiltinMethodT [] ((VoidT) as typ)), exprIL_b, [], []

        2. Else Phantom#1080

      4. Else Phantom#1081

  2. Else Phantom#1082

1. Else Phantom#1083

2. If ((member' = "isValid")), then

  1. If ((targIL* matches pattern [])), then

    1. (Expr_ok: p C |- expr_b : exprIL_b)

    2. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

    3. (Let typ be $canon_typ(typ_b))

    4. If ((typ has type datatyp)), then

      1. (Let datatyp be (typ as datatyp))

      2. Case analysis on datatyp

        1. Case (% matches pattern `HeaderT%%`)

          1. (Let (HeaderT id_b (member', typ_b_in)*) be datatyp)

          2. Result in (BuiltinMethodT [] ((BoolT) as typ)), exprIL_b, [], []

        2. Case (% matches pattern `UnionT%%`)

          1. (Let (UnionT id_b (member', typ_b_in)*) be datatyp)

          2. Result in (BuiltinMethodT [] ((BoolT) as typ)), exprIL_b, [], []

      2. Else Phantom#1084

    4. Else Phantom#1085

  1. Else Phantom#1086

2. Else Phantom#1087

3. (Expr_ok: p C |- expr_b : exprIL_b)

4. (Let (( typ_b ; _ctk )) be $annot(exprIL_b))

5. (Let typ be $canon_typ(typ_b))

6. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `ExternT%%`)), then

    1. (Let (ExternT id_b fmap_b) be objtyp)

    2. (Let (fid, funcdef, id*)? be $find_func<funcdef>(member', $to_fkey(arg*), fmap_b))

    3. If (((fid, funcdef, id*)? matches pattern (_))), then

      1. (Let ?((fid, fd, id_deft*)) be (fid, funcdef, id*)?)

      2. (Let (ft, tid_fresh*) be $specialize_funcdef(fd, targIL*))

      3. Result in ft, exprIL_b, tid_fresh*, id_deft*

    3. Else Phantom#1088

  2. Else Phantom#1089

6. Else Phantom#1090

7. If ((member' = "apply")), then

  1. If ((targIL* matches pattern [])), then

    1. If ((typ has type objtyp)), then

      1. (Let objtyp be (typ as objtyp))

      2. Case analysis on objtyp

        1. Case (% matches pattern `ParserT%%`)

          1. (Let (ParserT _id pt*) be objtyp)

          2. (Let ft be (ParserApplyMethodT pt*))

          3. (Let fd be ((MonoFD ft) as funcdef))

          4. (Let (id_p _dir _typ exprIL_deft?) be pt)*

          5. (Let b_deft be (exprIL_deft? =/= ?()))*

          6. (Let fid be ("apply" (id_p, b_deft)*))

          7. (Let (fid, funcdef, id*)? be $find_func<funcdef>("apply", $to_fkey(arg*), ({ [(fid -> fd)] })))

          8. If (((fid, funcdef, id*)? matches pattern (_))), then

            1. (Let ?((fid', funcdef, id_deft*)) be (fid, funcdef, id*)?)

            2. If ((fid' = fid)), then

              1. If ((funcdef = ((MonoFD ft) as funcdef))), then

                1. Result in ft, exprIL_b, [], id_deft*

              1. Else Phantom#1091

            2. Else Phantom#1092

          8. Else Phantom#1093

        2. Case (% matches pattern `ControlT%%`)

          1. (Let (ControlT _id pt*) be objtyp)

          2. (Let ft be (ControlApplyMethodT pt*))

          3. (Let fd be ((MonoFD ft) as funcdef))

          4. (Let (id_p _dir _typ exprIL_deft?) be pt)*

          5. (Let b_deft be (exprIL_deft? =/= ?()))*

          6. (Let fid be ("apply" (id_p, b_deft)*))

          7. (Let (fid, funcdef, id*)? be $find_func<funcdef>("apply", $to_fkey(arg*), ({ [(fid -> fd)] })))

          8. If (((fid, funcdef, id*)? matches pattern (_))), then

            1. (Let ?((fid', funcdef, id_deft*)) be (fid, funcdef, id*)?)

            2. If ((fid' = fid)), then

              1. If ((funcdef = ((MonoFD ft) as funcdef))), then

                1. Result in ft, exprIL_b, [], id_deft*

              1. Else Phantom#1094

            2. Else Phantom#1095

          8. Else Phantom#1096

      2. Else Phantom#1097

    1. Else Phantom#1098

    2. If ((arg* matches pattern [])), then

      1. If ((typ has type objtyp)), then

        1. (Let objtyp be (typ as objtyp))

        2. If ((objtyp matches pattern `TableT%%`)), then

          1. (Let (TableT id typ_t) be objtyp)

          2. (Let functyp be (TableApplyMethodT typ_t))

          3. Result in functyp, exprIL_b, [], []

        2. Else Phantom#1099

      1. Else Phantom#1100

    2. Else Phantom#1101

  1. Else Phantom#1102

7. Else Phantom#1103

;; ../../../../spec/4b-typing-relation.watsup:169.1-171.29
relation ConsType_ok: p, C, name, targIL*, arg*

1. (Let (cid, consdef, id*)? be $find_consdef((GLOBAL), C, name, arg*))

2. If (((cid, consdef, id*)? matches pattern (_))), then

  1. (Let ?((cid, cd, id_deft*)) be (cid, consdef, id*)?)

  2. (Let (ct, tid_fresh*) be $specialize_consdef(cd, targIL*))

  3. Result in ct, tid_fresh*, id_deft*

2. Else Phantom#1104

;; ../../../../spec/4b-typing-relation.watsup:177.1-179.23
relation Inst_site_ok: cursor, C, (ConsT pt* typ_i)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let typ_i' be $canon_typ(typ_i))

    2. If (($is_externt(typ_i') \/ $is_packaget(typ_i'))), then

      1. The relation holds

    2. Else Phantom#1105

  2. Case (% matches pattern `BLOCK`)

    1. (Let typ_i' be $canon_typ(typ_i))

    2. Case analysis on C.BLOCK.KIND

      1. Case (% matches pattern `PACKAGE`)

        1. If (((($is_externt(typ_i') \/ $is_parsert(typ_i')) \/ $is_controlt(typ_i')) \/ $is_packaget(typ_i'))), then

          1. The relation holds

        1. Else Phantom#1106

      2. Case (% matches pattern `PARSER`)

        1. If (($is_externt(typ_i') \/ $is_parsert(typ_i'))), then

          1. The relation holds

        1. Else Phantom#1107

      3. Case (% matches pattern `CONTROL`)

        1. If ((($is_externt(typ_i') \/ $is_controlt(typ_i')) \/ $is_tablet(typ_i'))), then

          1. The relation holds

        1. Else Phantom#1108

    2. Else Phantom#1109

  3. Case (% matches pattern `LOCAL`)

    1. (Let typ_i' be $canon_typ(typ_i))

    2. Case analysis on C.LOCAL.KIND

      1. Case (% matches pattern `PARSERSTATE`)

        1. If (($is_externt(typ_i') \/ $is_parsert(typ_i'))), then

          1. The relation holds

        1. Else Phantom#1110

      2. Case (% matches pattern `CONTROLAPPLYMETHOD`)

        1. If (($is_externt(typ_i') \/ $is_controlt(typ_i'))), then

          1. The relation holds

        1. Else Phantom#1111

    2. Else Phantom#1112

;; ../../../../spec/4b-typing-relation.watsup:180.1-182.35
relation Inst_ok: cursor', C_0', tid'*, ct, targIL*, arg*, id_deft*

1. If ((cursor' matches pattern `GLOBAL`)), then

  1. If ((tid'* matches pattern [])), then

    1. (Let (ConsT pt* typ_i) be ct)

    2. If ($is_packaget($canon_typ(typ_i))), then

      1. (Let C_1 be $set_blockkind(C_0', (PACKAGE)))

      2. (Arg_ok: (BLOCK) C_1 |- arg : argIL typ_a)*

      3. (Let pt'* be $filter_default_args(pt*, id_deft*))

      4. If ((|pt'*| = |argIL*|)), then

        1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

        2. If ((ConsType_wf: $bound_tids((GLOBAL), C_0') |- (ConsT pt* typ_i) holds)), then

          1. If ((Inst_site_ok: (GLOBAL) C_0' |- (ConsT pt* typ_i) :INSTSITE_OK holds)), then

            1. (Call_convention_arg_ok: (BLOCK) C_1 (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

            2. Result in typ_i, targIL*, [], argIL''*

          1. Else Phantom#1113

        2. Else Phantom#1114

      4. Else Phantom#1115

    2. Else Phantom#1116

  1. Else Phantom#1117

  2. (Let (ConsT pt* typ_i) be ct)

  3. If ($is_packaget($canon_typ(typ_i))), then

    1. If ((|tid'*| > 0)), then

      1. (Let C_1 be $set_blockkind(C_0', (PACKAGE)))

      2. (Arg_ok: (BLOCK) C_1 |- arg : argIL typ_a)*

      3. (Let pt'* be $filter_default_args(pt*, id_deft*))

      4. If ((|pt'*| = |argIL*|)), then

        1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

        2. (Let theta be $infer_targs(tid'*, pt''*, typ_a*))

        3. (Let typ? be $find_map<tid, typ>(theta, tid'))*

        4. If ((typ? matches pattern (_)))*, then

          1. (Let ?(targIL_hidden) be typ?)*

          2. (Let (ConsT pt'''* typ_i') be $subst_constyp(theta, (ConsT pt''* typ_i)))

          3. If ((ConsType_wf: $bound_tids((GLOBAL), C_0') |- (ConsT pt'''* typ_i') holds)), then

            1. If ((Inst_site_ok: (GLOBAL) C_0' |- (ConsT pt'''* typ_i') :INSTSITE_OK holds)), then

              1. (Call_convention_arg_ok: (BLOCK) C_1 (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*

              2. Result in typ_i', targIL*, targIL_hidden*, argIL''*

            1. Else Phantom#1118

          3. Else Phantom#1119

        4. Else Phantom#1120

      4. Else Phantom#1121

    1. Else Phantom#1122

  3. Else Phantom#1123

1. Else Phantom#1124

2. If ((tid'* matches pattern [])), then

  1. (Let (ConsT pt* typ_i) be ct)

  2. If (~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i)))), then

    1. (Arg_ok: cursor' C_0' |- arg : argIL typ_a)*

    2. (Let pt'* be $filter_default_args(pt*, id_deft*))

    3. If ((|pt'*| = |argIL*|)), then

      1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

      2. If ((ConsType_wf: $bound_tids(cursor', C_0') |- (ConsT pt* typ_i) holds)), then

        1. If ((Inst_site_ok: cursor' C_0' |- (ConsT pt* typ_i) :INSTSITE_OK holds)), then

          1. (Call_convention_arg_ok: cursor' C_0' (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

          2. Result in typ_i, targIL*, [], argIL''*

        1. Else Phantom#1125

      2. Else Phantom#1126

    3. Else Phantom#1127

  2. Else Phantom#1128

2. Else Phantom#1129

3. (Let (ConsT pt* typ_i) be ct)

4. If (~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i)))), then

  1. (Arg_ok: cursor' C_0' |- arg : argIL typ_a)*

  2. (Let pt'* be $filter_default_args(pt*, id_deft*))

  3. If ((|pt'*| = |argIL*|)), then

    1. (Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*))

    2. (Let theta be $infer_targs(tid'*, pt''*, typ_a*))

    3. (Let typ? be $find_map<tid, typ>(theta, tid'))*

    4. If ((typ? matches pattern (_)))*, then

      1. (Let ?(targIL_hidden) be typ?)*

      2. (Let (ConsT pt'''* typ_i') be $subst_constyp(theta, (ConsT pt''* typ_i)))

      3. If ((ConsType_wf: $bound_tids(cursor', C_0') |- (ConsT pt'''* typ_i') holds)), then

        1. If ((Inst_site_ok: cursor' C_0' |- (ConsT pt'''* typ_i') :INSTSITE_OK holds)), then

          1. (Call_convention_arg_ok: cursor' C_0' (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*

          2. Result in typ_i', targIL*, targIL_hidden*, argIL''*

        1. Else Phantom#1130

      3. Else Phantom#1131

    4. Else Phantom#1132

  3. Else Phantom#1133

4. Else Phantom#1134

;; ../../../../spec/4d2-typing-subtyping.watsup:312.1-313.34
def $reduce_senum_unary(exprIL, $check_unary)

1. (Let (( typ ; _ctk )) be $annot(exprIL))

2. Case analysis on $check_unary(typ)

  1. Case true

    1. Return ?(exprIL)

  2. Case false

    1. (Let typ'' be typ)

    2. If ((typ'' has type datatyp)), then

      1. (Let datatyp be (typ'' as datatyp))

      2. If ((datatyp matches pattern `SEnumT%%%`)), then

        1. (Let (SEnumT _id typ' _(member, val)*) be datatyp)

        2. (Let exprIL' be (CastE typ' exprIL (( typ' ; _ctk ))))

        3. (Let exprIL'''? be $reduce_senum_unary(exprIL', $check_unary))

        4. If ((exprIL'''? matches pattern (_))), then

          1. (Let ?(exprIL'') be exprIL'''?)

          2. Return ?(exprIL'')

3. Otherwise

  1. Return ?()

;; ../../../../spec/4d2-typing-subtyping.watsup:330.1-331.41
def $reduce_senums_binary(exprIL_a, exprIL_b, $check_binary)

1. (Let (( typ_a ; _ctk )) be $annot(exprIL_a))

2. (Let (( typ_b ; _ctk' )) be $annot(exprIL_b))

3. Case analysis on $check_binary(typ_a, typ_b)

  1. Case true

    1. Return ?((exprIL_a, exprIL_b))

  2. Case false

    1. (Let typ be typ_a)

    2. If ((typ has type datatyp)), then

      1. (Let datatyp be (typ as datatyp))

      2. If ((datatyp matches pattern `SEnumT%%%`)), then

        1. (Let (SEnumT _id typ_a' _(member, val)*) be datatyp)

        2. (Let exprIL_a' be (CastE typ_a' exprIL_a (( typ_a' ; _ctk' ))))

        3. (Let (exprIL, exprIL)? be $reduce_senums_binary(exprIL_a', exprIL_b, $check_binary))

        4. If (((exprIL, exprIL)? matches pattern (_))), then

          1. (Let ?((exprIL_a'', exprIL_b'')) be (exprIL, exprIL)?)

          2. Return ?((exprIL_a'', exprIL_b''))

    3. (Let typ be typ_b)

    4. If ((typ has type datatyp)), then

      1. (Let datatyp be (typ as datatyp))

      2. If ((datatyp matches pattern `SEnumT%%%`)), then

        1. (Let (SEnumT _id typ_b' _(member, val)*) be datatyp)

        2. (Let exprIL_b' be (CastE typ_b' exprIL_b (( typ_b' ; _ctk' ))))

        3. (Let (exprIL, exprIL)? be $reduce_senums_binary(exprIL_a, exprIL_b', $check_binary))

        4. If (((exprIL, exprIL)? matches pattern (_))), then

          1. (Let ?((exprIL_a'', exprIL_b'')) be (exprIL, exprIL)?)

          2. Return ?((exprIL_a'', exprIL_b''))

4. Otherwise

  1. Return ?()

;; ../../../../spec/4d2-typing-subtyping.watsup:358.1-359.32
def $coerce_binary(exprIL_a, exprIL_b)

1. (Let (( typ_a ; _ctk )) be $annot(exprIL_a))

2. (Let (( typ_b ; _ctk' )) be $annot(exprIL_b))

3. Case analysis on (Type_alpha: typ_a ~~ typ_b holds)

  1. Case true

    1. Return ?((exprIL_a, exprIL_b))

  2. Case false

    1. Case analysis on (Sub_impl: typ_a << typ_b holds)

      1. Case true

        1. (Let exprIL_a' be (CastE typ_b exprIL_a (( typ_b ; _ctk' ))))

        2. Return ?((exprIL_a', exprIL_b))

      2. Case false

        1. If ((Sub_impl: typ_b << typ_a holds)), then

          1. (Let exprIL_b' be (CastE typ_a exprIL_b (( typ_a ; _ctk' ))))

          2. Return ?((exprIL_a, exprIL_b'))

4. Otherwise

  1. Return ?()

;; ../../../../spec/4d2-typing-subtyping.watsup:385.1-386.31
def $coerce_assign(exprIL, typ_t)

1. (Let (( typ_f ; _ctk )) be $annot(exprIL))

2. Case analysis on (Type_alpha: typ_f ~~ typ_t holds)

  1. Case true

    1. Return ?(exprIL)

  2. Case false

    1. If ((Sub_impl: typ_f << typ_t holds)), then

      1. Return ?((CastE typ_t exprIL (( typ_t ; _ctk ))))

3. Otherwise

  1. Return ?()

;; ../../../../spec/4e-typing-expr.watsup:88.1-88.33
def $compatible_bnot(typ)

1. Return $compatible'_bnot($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:89.1-89.34
def $compatible'_bnot(typ)

1. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:103.1-103.33
def $compatible_lnot(typ)

1. Return $compatible'_lnot($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:104.1-104.34
def $compatible'_lnot(typ)

1. If ((typ = ((BoolT) as typ))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:117.1-117.34
def $compatible_uplus(typ)

1. Return $compatible'_uplus($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:118.1-118.35
def $compatible'_uplus(typ)

1. If ((typ = ((IntT) as typ))), then

  1. Return true

2. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:133.1-133.35
def $compatible_uminus(typ)

1. Return $compatible'_uminus($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:134.1-134.36
def $compatible'_uminus(typ)

1. If ((typ = ((IntT) as typ))), then

  1. Return true

2. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:153.1-153.47
def $compatible_plusminusmult(typ_l, typ_r)

1. Return $compatible'_plusminusmult($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:154.1-154.48
def $compatible'_plusminusmult(typ'', typ''')

1. If ((typ'' = ((IntT) as typ))), then

  1. If ((typ''' = ((IntT) as typ))), then

    1. Return true

2. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:179.1-179.46
def $compatible_satplusminus(typ_l, typ_r)

1. Return $compatible'_satplusminus($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:180.1-180.47
def $compatible'_satplusminus(typ'', typ''')

1. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:204.1-204.40
def $compatible_divmod(typ_l, typ_r)

1. Return $compatible'_divmod($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:205.1-205.41
def $compatible'_divmod(typ'', typ''')

1. If ((typ'' = ((IntT) as typ))), then

  1. If ((typ''' = ((IntT) as typ))), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:249.1-249.39
def $compatible_shift(typ_l, typ_r)

1. Return $compatible'_shift($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:250.1-250.40
def $compatible'_shift(typ'', typ''')

1. If ((typ'' = ((IntT) as typ))), then

  1. If ((typ''' = ((IntT) as typ))), then

    1. Return true

  2. If ((typ''' has type numtyp)), then

    1. (Let numtyp be (typ''' as numtyp))

    2. Case analysis on numtyp

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _width) be numtyp)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _width) be numtyp)

        2. Return true

2. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. If ((typ''' = ((IntT) as typ))), then

        1. Return true

      3. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. Case analysis on numtyp'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _width') be numtyp')

            2. Return true

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _width') be numtyp')

            2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. If ((typ''' = ((IntT) as typ))), then

        1. Return true

      3. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. Case analysis on numtyp'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _width') be numtyp')

            2. Return true

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _width') be numtyp')

            2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:314.1-314.41
def $compatible_compare(typ_l, typ_r)

1. Return $compatible'_compare($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:315.1-315.42
def $compatible'_compare(typ'', typ''')

1. If ((typ'' = ((IntT) as typ))), then

  1. If ((typ''' = ((IntT) as typ))), then

    1. Return true

2. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:340.1-340.41
def $compatible_bitwise(typ_l, typ_r)

1. Return $compatible'_bitwise($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:341.1-341.42
def $compatible'_bitwise(typ'', typ''')

1. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:365.1-365.40
def $compatible_concat(typ_l, typ_r)

1. Return $compatible'_concat($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:366.1-366.41
def $compatible'_concat(typ'', typ''')

1. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. Case analysis on numtyp'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _width') be numtyp')

            2. Return true

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _width') be numtyp')

            2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. Case analysis on numtyp'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _width') be numtyp')

            2. Return true

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _width') be numtyp')

            2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:409.1-409.41
def $compatible_logical(typ_l, typ_r)

1. Return $compatible'_logical($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:410.1-410.42
def $compatible'_logical(typ'', typ''')

1. If ((typ'' = ((BoolT) as typ))), then

  1. If ((typ''' = ((BoolT) as typ))), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:471.1-471.38
def $compatible_mask(typ_l, typ_r)

1. Return $compatible'_mask($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:472.1-472.39
def $compatible'_mask(typ'', typ''')

1. If ((typ'' = ((IntT) as typ))), then

  1. If ((typ''' = ((IntT) as typ))), then

    1. Return true

2. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:499.1-499.39
def $compatible_range(typ_l, typ_r)

1. Return $compatible'_range($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:500.1-500.40
def $compatible'_range(typ'', typ''')

1. If ((typ'' = ((IntT) as typ))), then

  1. If ((typ''' = ((IntT) as typ))), then

    1. Return true

2. If ((typ'' has type numtyp)), then

  1. (Let numtyp be (typ'' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. If ((typ''' has type numtyp)), then

        1. (Let numtyp' be (typ''' as numtyp))

        2. If ((numtyp' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numtyp')

          2. If ((w = w')), then

            1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:526.1-528.26
relation Select_case_keyset_ok: cursor, C, typ_k, keyset

1. If ((cursor matches pattern `LOCAL`)), then

  1. Case analysis on keyset

    1. Case (% matches pattern `ExprK%`)

      1. (Let (ExprK expr) be keyset)

      2. (Expr_ok: (LOCAL) C |- expr : exprIL)

      3. (Let (( typ' ; _ctk )) be $annot(exprIL))

      4. If ((typ' has type synthtyp)), then

        1. (Let synthtyp be (typ' as synthtyp))

        2. If ((synthtyp matches pattern `SetT%`)), then

          1. (Let (SetT typ) be synthtyp)

          2. Case analysis on (Type_alpha: typ ~~ typ_k holds)

            1. Case true

              1. Result in (ExprK exprIL)

            2. Case false

              1. If ((Sub_impl: typ << typ_k holds)), then

                1. (Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; (DYN) ))))

                2. Result in (ExprK exprIL')

              1. Else Phantom#1135

        2. Else Phantom#1136

      4. Else Phantom#1137

      5. If ((Sub_impl: typ' << typ_k holds)), then

        1. (Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; (DYN) ))))

        2. Result in (ExprK exprIL')

      5. Else Phantom#1138

    2. Case (% matches pattern `DefaultK`)

      1. Result in (DefaultK)

    3. Case (% matches pattern `AnyK`)

      1. Result in (AnyK)

1. Else Phantom#1139

;; ../../../../spec/4e-typing-expr.watsup:561.1-563.26
relation Select_case_keysets_ok: p, C, typ'*, keyset''*

1. If ((typ'* matches pattern [ _/1 ])), then

  1. (Let [typ_k] be typ'*)

  2. If ((keyset''* matches pattern [ _/1 ])), then

    1. (Let [keyset] be keyset''*)

    2. (Select_case_keyset_ok: p C typ_k |- keyset : keysetIL)

    3. Result in [keysetIL]

  2. Else Phantom#1140

1. Else Phantom#1141

2. If ((keyset''* matches pattern [ _/1 ])), then

  1. (Let [keyset] be keyset''*)

  2. (Select_case_keyset_ok: p C ((SeqT typ'*) as typ) |- keyset : keysetIL)

  3. Result in [keysetIL]

2. Else Phantom#1142

3. If ((|typ'*| = |keyset''*|)), then

  1. (Select_case_keyset_ok: p C typ' |- keyset'' : keysetIL)*

  2. Result in keysetIL*

3. Else Phantom#1143

;; ../../../../spec/4e-typing-expr.watsup:579.1-581.26
relation Select_case_ok: cursor, C, typ_k*, (keyset* statelabel)

1. If ((cursor matches pattern `LOCAL`)), then

  1. (Select_case_keysets_ok: (LOCAL) C |- typ_k* keyset* : keysetIL*)

  2. (Let styp? be $find_styp((LOCAL), C, (CURRENT statelabel)))

  3. If ((styp? matches pattern (_))), then

    1. (Let ?((typ dir'' ctk'' val?)) be styp?)

    2. If ((typ = ((StateT) as typ))), then

      1. If ((val? matches pattern ())), then

        1. Result in (keysetIL* statelabel)

      1. Else Phantom#1144

    2. Else Phantom#1145

  3. Else Phantom#1146

1. Else Phantom#1147

;; ../../../../spec/4e-typing-expr.watsup:603.1-603.39
def $compatible_arrayindex(typ)

1. Return $compatible'_arrayindex($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:604.1-604.40
def $compatible'_arrayindex(typ)

1. If ((typ = ((IntT) as typ))), then

  1. Return true

2. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:660.1-660.42
def $compatible_bitstringbase(typ)

1. Return $compatible'_bitstringbase($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:661.1-661.43
def $compatible'_bitstringbase(typ)

1. If ((typ = ((IntT) as typ))), then

  1. Return true

2. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. Return (w > 0)

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:670.1-670.43
def $compatible_bitstringindex(typ)

1. Return $compatible'_bitstringindex($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:671.1-671.44
def $compatible'_bitstringindex(typ)

1. If ((typ = ((IntT) as typ))), then

  1. Return true

2. If ((typ has type numtyp)), then

  1. (Let numtyp be (typ as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _width) be numtyp)

      2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _width) be numtyp)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:680.1-680.52
def $is_valid_bitstring_slice(typ, n_l, n_h)

1. Return ((n_l <= n_h) /\ $is_valid_bitstring_slice'($canon_typ(typ), n_l, n_h))

;; ../../../../spec/4e-typing-expr.watsup:681.1-681.53
def $is_valid_bitstring_slice'(typ', _nat'', _nat''')

1. If ((typ' = ((IntT) as typ))), then

  1. Return true

2. If ((typ' has type numtyp)), then

  1. (Let numtyp be (typ' as numtyp))

  2. Case analysis on numtyp

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numtyp)

      2. (Let w_slice be ((_nat''' - _nat'') + 1))

      3. Return ((_nat''' <= w) /\ (w_slice <= w))

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numtyp)

      2. (Let w_slice be ((_nat''' - _nat'') + 1))

      3. Return ((_nat''' <= w) /\ (w_slice <= w))

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:873.1-873.44
def $not_abstract_extern_object(typ)

1. Return $not_abstract_extern_object'($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:874.1-874.45
def $not_abstract_extern_object'(typ)

1. If (~$is_externt(typ)), then

  1. Return true

2. If ((typ has type objtyp)), then

  1. (Let objtyp be (typ as objtyp))

  2. If ((objtyp matches pattern `ExternT%%`)), then

    1. (Let (ExternT _id fmap) be objtyp)

    2. (Let ({ fid* }) be $dom_map<fid, funcdef>(fmap))

    3. (Let funcdef? be $find_map<fid, funcdef>(fmap, fid))*

    4. If ((funcdef? matches pattern (_)))*, then

      1. (Let ?(fd) be funcdef?)*

      2. If ($not_abstract_extern_object''(fd))*, then

        1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:875.1-875.50
def $not_abstract_extern_object''(funcdef')

1. If ((funcdef' has type polyfuncdef)), then

  1. (Let (PolyFD (_tparam*, _tparam'*) -> functyp) be (funcdef' as polyfuncdef))

  2. If ((functyp matches pattern `ExternAbstractMethodT%%`)), then

    1. (Let (ExternAbstractMethodT _paramtyp* _typ) be functyp)

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec/4f-typing-stmt.watsup:45.1-47.29
relation Switch_tbl_label_ok: p, C, id_t, b_last', switchlabel

1. If ((switchlabel matches pattern `ExprL%`)), then

  1. (Let (ExprL expr) be switchlabel)

  2. If ((expr matches pattern `NameE%`)), then

    1. (Let (NameE name) be expr)

    2. If ((name matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id_a) be name)

      2. (Let id_e be $concat_text(["action_list(", id_t, ")"]))

      3. (Let id be $concat_text([id_e, ".", id_a]))

      4. If ((?((TableEnumFieldV id_e id_a)) = $find_val(p, C, (CURRENT id)))), then

        1. (Let styp? be $find_styp(p, C, (CURRENT id)))

        2. If ((styp? matches pattern (_))), then

          1. (Let ?((typ_e _dir ctk_e _val?)) be styp?)

          2. Result in (ExprL (NameE (CURRENT id_a) (( typ_e ; ctk_e ))))

        2. Else Phantom#1148

      4. Else Phantom#1149

    2. Else Phantom#1150

  2. Else Phantom#1151

1. Else Phantom#1152

2. If ((b_last' = true)), then

  1. If ((switchlabel matches pattern `DefaultL`)), then

    1. Result in (DefaultL)

  1. Else Phantom#1153

2. Else Phantom#1154

;; ../../../../spec/4f-typing-stmt.watsup:60.1-62.32
relation Switch_tbl_case_ok: p, C, f, id_t, b_last, switchcase

1. Case analysis on switchcase

  1. Case (% matches pattern `MatchC%%`)

    1. (Let (MatchC switchlabel block) be switchcase)

    2. (Switch_tbl_label_ok: p C id_t b_last |- switchlabel : switchlabelIL)

    3. (Block_ok: p C f (NOINIT) |- block : C' f' blockIL)

    4. Result in f', (MatchC switchlabelIL blockIL), switchlabel

  2. Case (% matches pattern `FallC%`)

    1. (Let (FallC switchlabel) be switchcase)

    2. (Switch_tbl_label_ok: p C id_t b_last |- switchlabel : switchlabelIL)

    3. Result in f, (FallC switchlabelIL), switchlabel

;; ../../../../spec/4f-typing-stmt.watsup:74.1-76.29
relation Switch_tbl_cases_ok: p, C, f, id_t, switchcase*

1. Case analysis on switchcase*

  1. Case (% matches pattern [])

    1. Result in f, [], []

  2. Case (% matches pattern _ :: _)

    1. (Let switchcase_h :: switchcase_t* be switchcase*)

    2. (Let b_last be (switchcase_t* = []))

    3. (Switch_tbl_case_ok: p C f id_t b_last |- switchcase_h : f' switchcaseIL_h switchlabel_h)

    4. (Switch_tbl_cases_ok: p C f' id_t |- switchcase_t* : f'' switchcaseIL_t* switchlabel_t*)

    5. Result in f'', switchcaseIL_h :: switchcaseIL_t*, switchlabel_h :: switchlabel_t*

;; ../../../../spec/4f-typing-stmt.watsup:98.1-100.29
relation Switch_gen_label_ok: p, C, typ_s, b_last', switchlabel

1. If ((switchlabel matches pattern `ExprL%`)), then

  1. (Let (ExprL expr) be switchlabel)

  2. (Expr_ok: p C |- expr : exprIL)

  3. (Let (( _typ ; ctk )) be $annot(exprIL))

  4. If ((ctk matches pattern `LCTK`)), then

    1. (Let exprIL''? be $coerce_assign(exprIL, typ_s))

    2. If ((exprIL''? matches pattern (_))), then

      1. (Let ?(exprIL') be exprIL''?)

      2. Result in (ExprL exprIL')

    2. Else Phantom#1155

  4. Else Phantom#1156

1. Else Phantom#1157

2. If ((b_last' = true)), then

  1. If ((switchlabel matches pattern `DefaultL`)), then

    1. Result in (DefaultL)

  1. Else Phantom#1158

2. Else Phantom#1159

;; ../../../../spec/4f-typing-stmt.watsup:112.1-114.32
relation Switch_gen_case_ok: p, C, f, typ_s, b_last, switchcase

1. Case analysis on switchcase

  1. Case (% matches pattern `MatchC%%`)

    1. (Let (MatchC switchlabel block) be switchcase)

    2. (Switch_gen_label_ok: p C typ_s b_last |- switchlabel : switchlabelIL)

    3. (Block_ok: p C f (NOINIT) |- block : C' f' blockIL)

    4. Result in f', (MatchC switchlabelIL blockIL), switchlabel

  2. Case (% matches pattern `FallC%`)

    1. (Let (FallC switchlabel) be switchcase)

    2. (Switch_gen_label_ok: p C typ_s b_last |- switchlabel : switchlabelIL)

    3. Result in f, (FallC switchlabelIL), switchlabel

;; ../../../../spec/4f-typing-stmt.watsup:126.1-128.29
relation Switch_gen_cases_ok: p, C, f, typ_s, switchcase*

1. Case analysis on switchcase*

  1. Case (% matches pattern [])

    1. Result in f, [], []

  2. Case (% matches pattern _ :: _)

    1. (Let switchcase_h :: switchcase_t* be switchcase*)

    2. (Let b_last be (switchcase_t* = []))

    3. (Switch_gen_case_ok: p C f typ_s b_last |- switchcase_h : f' switchcaseIL_h switchlabel_h)

    4. (Switch_gen_cases_ok: p C f' typ_s |- switchcase_t* : f'' switchcaseIL_t* switchlabel_t*)

    5. Result in f'', switchcaseIL_h :: switchcaseIL_t*, switchlabel_h :: switchlabel_t*

;; ../../../../spec/4g-typing-decl.watsup:88.1-90.29
relation Inst_init_decl_ok: p, C'', frame, fdenv, decl''

1. Case analysis on decl''

  1. Case (% matches pattern `InstD%%%%%`)

    1. (Let (InstD id' name targ* arg* decl*) be decl'')

    2. (Decl_ok: p C'' |- (InstD id' name targ* arg* decl*) : C' declIL)

    3. (Let styp? be $find_styp(p, C', (CURRENT id')))

    4. If ((styp? matches pattern (_))), then

      1. (Let ?(styp') be styp?)

      2. (Let frame' be $update_map<id, styp>(frame, id', styp'))

      3. Result in frame', fdenv, declIL

    4. Else Phantom#1160

  2. Case (% matches pattern `FuncD%%%%%`)

    1. (Let (FuncD id type_r tparam* param* block) be decl'')

    2. (Let fid be $to_fid(id, param*))

    3. (Let C_1 be $set_blockkind(C'', (EXTERN)))

    4. (Let C_2 be C_1[BLOCK.FRAME = frame])

    5. (Let C_3 be $add_tparams((LOCAL), C_2, tparam*))

    6. (Type_ok: (LOCAL) C_3 |- type_r : typ_r tid*)

    7. If ((tid* matches pattern [])), then

      1. (Let C_4 be $set_localkind(C_3, (EXTERNABSTRACTMETHOD typ_r)))

      2. (Param_ok: (LOCAL) C_4 |- param : paramIL tid_fresh_p*)*

      3. (Let tparam_hidden* be $concat_<tid>(tid_fresh_p**))

      4. (Let C_5 be $add_params((LOCAL), C_4, (paramIL* as paramtyp*)))

      5. (Let C_6 be $add_tparams((LOCAL), C_5, tparam_hidden*))

      6. (Block_ok: (LOCAL) C_6 (CONT) (INIT) |- block : C_7 f blockIL)

      7. If (((f = (RET)) \/ (typ_r = ((VoidT) as typ)))), then

        1. (Let fd be ((PolyFD (tparam*, tparam_hidden*) -> (ExternMethodT (paramIL* as paramtyp*) typ_r)) as funcdef))

        2. If ((FuncDef_wf: $bound_tids(p, C'') |- fd holds)), then

          1. (Let fdenv' be $update_map<fid, funcdef>(fdenv, fid, fd))

          2. Result in frame, fdenv', (FuncD id typ_r tparam* tparam_hidden* paramIL* blockIL)

        2. Else Phantom#1161

      7. Else Phantom#1162

    7. Else Phantom#1163

1. Else Phantom#1164

;; ../../../../spec/4g-typing-decl.watsup:128.1-130.26
relation Inst_init_decls_ok: C, frame, fdenv, decl*

1. Case analysis on decl*

  1. Case (% matches pattern [])

    1. Result in frame, fdenv, []

  2. Case (% matches pattern _ :: _)

    1. (Let decl_h :: decl_t* be decl*)

    2. (Inst_init_decl_ok: (GLOBAL) C frame fdenv |- decl_h : frame' fdenv' declIL_h)

    3. (Inst_init_decls_ok: C frame' fdenv' |- decl_t* : frame'' fdenv'' declIL_t*)

    4. Result in frame'', fdenv'', declIL_h :: declIL_t*

;; ../../../../spec/4g-typing-decl.watsup:141.1-142.109
def $update_fdenv_extern(fdenv_ext, theta, fid*, funcdef*)

1. Case analysis on fid*

  1. Case (% matches pattern [])

    1. If ((funcdef* matches pattern [])), then

      1. Return fdenv_ext

    1. Else Phantom#1165

  2. Case (% matches pattern _ :: _)

    1. (Let fid_h :: fid_t* be fid*)

    2. If ((funcdef* matches pattern _ :: _)), then

      1. (Let fd_h :: fd_t* be funcdef*)

      2. (Let funcdef''? be $find_map<fid, funcdef>(fdenv_ext, fid_h))

      3. If ((funcdef''? matches pattern (_))), then

        1. (Let ?(funcdef') be funcdef''?)

        2. If ((funcdef' has type polyfuncdef)), then

          1. (Let (PolyFD (tparam*, tparam_hidden*) -> functyp) be (funcdef' as polyfuncdef))

          2. If ((functyp matches pattern `ExternAbstractMethodT%%`)), then

            1. (Let (ExternAbstractMethodT pt* typ_r) be functyp)

            2. (Let fd_ext be ((PolyFD (tparam*, tparam_hidden*) -> (ExternMethodT pt* typ_r)) as funcdef))

            3. (Let fd_ext' be $subst_funcdef(theta, fd_ext))

            4. If ((FuncDef_alpha: fd_ext' ~~ fd_h holds)), then

              1. (Let fdenv_ext' be $update_map<fid, funcdef>(fdenv_ext, fid_h, fd_ext'))

              2. Return $update_fdenv_extern(fdenv_ext', theta, fid_t*, fd_t*)

            4. Else Phantom#1166

          2. Else Phantom#1167

        2. Else Phantom#1168

      3. Else Phantom#1169

    2. Else Phantom#1170

;; ../../../../spec/4g-typing-decl.watsup:291.1-293.32
relation SEnum_field_ok: C, id_s, typ_s, (member_s, val_s)*, member, expr

1. (Expr_ok: (BLOCK) C |- expr : exprIL)

2. (Let (( _typ ; ctk )) be $annot(exprIL))

3. If ((ctk matches pattern `LCTK`)), then

  1. (Let exprIL''? be $coerce_assign(exprIL, typ_s))

  2. If ((exprIL''? matches pattern (_))), then

    1. (Let ?(exprIL') be exprIL''?)

    2. (Eval_static: (BLOCK) C |- exprIL' ~> (val_e _exprIL))

    3. (Let val be (SEnumFieldV id_s member val_e))

    4. (Let member_s'* be member_s* ++ [member])

    5. (Let val_s'* be val_s* ++ [val])

    6. (Let typ_f be ((SEnumT id_s typ_s (member_s', val_s')*) as typ))

    7. (Let C' be $add_styp((BLOCK), C, member, (typ_f (NO) (LCTK) ?(val))))

    8. Result in C', (member_s', val_s')*

  2. Else Phantom#1171

3. Else Phantom#1172

;; ../../../../spec/4g-typing-decl.watsup:311.1-313.29
relation SEnum_fields_ok: C, id, typ, (member, val)*, (member, expr)*

1. Case analysis on (member, expr)*

  1. Case (% matches pattern [])

    1. Result in C, (member, val)*

  2. Case (% matches pattern _ :: _)

    1. (Let (member_h, expr_h) :: (member_t, expr_t)* be (member, expr)*)

    2. (SEnum_field_ok: C id typ (member, val)* |- member_h expr_h : C' (member', val')*)

    3. (SEnum_fields_ok: C' id typ (member', val')* |- (member_t, expr_t)* : C'' (member'', val'')*)

    4. Result in C'', (member'', val'')*

;; ../../../../spec/4g-typing-decl.watsup:500.1-500.49
def $split_methods(method*)

1. Case analysis on method*

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let method_h :: method_t* be method*)

    2. (Let method' be method_h)

    3. Case analysis on method'

      1. Case (% matches pattern `ExternConsM%%`)

        1. (Let (ExternConsM _id _cparam*) be method')

        2. (Let (method_c*, method_m*) be $split_methods(method_t*))

        3. Return (method_h :: method_c*, method_m*)

      2. Case (% matches pattern `ExternM%%%%`)

        1. (Let (ExternM _id _type _tparam* _param*) be method')

        2. (Let (method_c*, method_m*) be $split_methods(method_t*))

        3. Return (method_c*, method_h :: method_m*)

      3. Case (% matches pattern `ExternAbstractM%%%%`)

        1. (Let (ExternAbstractM _id _type _tparam* _param*) be method')

        2. (Let (method_c*, method_m*) be $split_methods(method_t*))

        3. Return (method_c*, method_h :: method_m*)

    3. Else Phantom#1173

;; ../../../../spec/4g-typing-decl.watsup:514.1-516.23
relation Method_ok: C'', id_e, method

1. Case analysis on method

  1. Case (% matches pattern `ExternConsM%%`)

    1. (Let (ExternConsM id_e' cparam*) be method)

    2. If ((id_e = id_e')), then

      1. (Let cid be $to_fid(id_e, cparam*))

      2. (CParam_ok: (BLOCK) C'' |- cparam : cparamIL tid_fresh_c*)*

      3. (Let (id_c dir_c typ_c exprIL_c?) be cparamIL)*

      4. (Let tparam_hidden* be $concat_<tid>(tid_fresh_c**))

      5. (Let typdef'? be $find_typdef((GLOBAL), C'', (CURRENT id_e)))

      6. If ((typdef'? matches pattern (_))), then

        1. (Let ?(typdef) be typdef'?)

        2. If ((typdef has type polytypdef)), then

          1. (Let (PolyD (tparam_e*, tparam*) -> typ_e) be (typdef as polytypdef))

          2. If ((tparam* matches pattern [])), then

            1. (Let typ be ((SpecT (PolyD (tparam_e*, []) -> typ_e) ((VarT tparam_e) as typ)*) as typ))

            2. (Let cd be (ConsD (tparam_e*, tparam_hidden*) -> (ConsT (id_c dir_c typ_c exprIL_c?)* typ)))

            3. If ((ConsDef_wf: $bound_tids((BLOCK), C'') |- cd holds)), then

              1. (Let C' be $add_consdef((GLOBAL), C'', cid, cd))

              2. Result in C', (ExternConsM id_e tparam_hidden* cparamIL*)

            3. Else Phantom#1174

          2. Else Phantom#1175

        2. Else Phantom#1176

      6. Else Phantom#1177

    2. Else Phantom#1178

  2. Case (% matches pattern `ExternAbstractM%%%%`)

    1. (Let (ExternAbstractM id type_r tparam* param*) be method)

    2. If ((id_e =/= id)), then

      1. (Let fid be $to_fid(id, param*))

      2. (Let C_1 be $add_typdefs((LOCAL), C'', tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*))

      3. (Type_ok: (LOCAL) C_1 |- type_r : typ_r tid*)

      4. If ((tid* matches pattern [])), then

        1. (Let C_2 be $set_localkind(C_1, (EXTERNABSTRACTMETHOD typ_r)))

        2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*)*

        3. (Let tparam_hidden* be $concat_<tid>(tid_fresh_p**))

        4. (Let C_3 be $add_params((LOCAL), C_2, (paramIL* as paramtyp*)))

        5. (Let fd be ((PolyFD (tparam*, tparam_hidden*) -> (ExternAbstractMethodT (paramIL* as paramtyp*) typ_r)) as funcdef))

        6. If ((FuncDef_wf: $bound_tids((BLOCK), C'') |- fd holds)), then

          1. (Let C_4 be $add_funcdef((BLOCK), C'', fid, fd))

          2. Result in C_4, (ExternAbstractM id typ_r tparam* tparam_hidden* paramIL*)

        6. Else Phantom#1179

      4. Else Phantom#1180

    2. Else Phantom#1181

  3. Case (% matches pattern `ExternM%%%%`)

    1. (Let (ExternM id type_r tparam* param*) be method)

    2. If ((id_e =/= id)), then

      1. (Let fid be $to_fid(id, param*))

      2. (Let C_1 be $add_typdefs((LOCAL), C'', tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*))

      3. (Type_ok: (LOCAL) C_1 |- type_r : typ_r tid*)

      4. If ((tid* matches pattern [])), then

        1. (Let C_2 be $set_localkind(C_1, (EXTERNMETHOD)))

        2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*)*

        3. (Let (id_p dir_p typ_p exprIL_p?) be paramIL)*

        4. (Let tparam_hidden* be $concat_<tid>(tid_fresh_p**))

        5. (Let C_3 be $add_params((LOCAL), C_2, (paramIL* as paramtyp*)))

        6. (Let fd be ((PolyFD (tparam*, tparam_hidden*) -> (ExternMethodT (paramIL* as paramtyp*) typ_r)) as funcdef))

        7. If ((FuncDef_wf: $bound_tids((BLOCK), C'') |- fd holds)), then

          1. (Let C_4 be $add_funcdef((BLOCK), C'', fid, fd))

          2. Result in C_4, (ExternM id typ_r tparam* tparam_hidden* paramIL*)

        7. Else Phantom#1182

      4. Else Phantom#1183

    2. Else Phantom#1184

;; ../../../../spec/4g-typing-decl.watsup:580.1-582.23
relation Methods_ok: C, id_e, method*

1. Case analysis on method*

  1. Case (% matches pattern [])

    1. Result in C, []

  2. Case (% matches pattern _ :: _)

    1. (Let method_h :: method_t* be method*)

    2. (Method_ok: C id_e |- method_h : C' methodIL_h)

    3. (Methods_ok: C' id_e |- method_t* : C'' methodIL_t*)

    4. Result in C'', methodIL_h :: methodIL_t*

;; ../../../../spec/4g-typing-decl.watsup:652.1-654.20
relation ParserState_ok: C, (statelabel block)

1. (Block_ok: (LOCAL) C (CONT) (INIT) |- block : C' flow blockIL)

2. If ((flow matches pattern `CONT`)), then

  1. Result in (statelabel blockIL)

2. Else Phantom#1185

;; ../../../../spec/4g-typing-decl.watsup:713.1-715.26
relation Table_key_ok: p, C, tblctx, (expr matchkind)

1. (Expr_ok: p C |- expr : exprIL)

2. (Let (( typ ; _ctk )) be $annot(exprIL))

3. If ((Type_wf: $bound_tids(p, C) |- ((SetT typ) as typ) holds)), then

  1. If ((?((MatchKindV matchkind)) = $find_val(p, C, (CURRENT matchkind)))), then

    1. If ($check_table_key(matchkind, typ)), then

      1. (Let tblctx' be $update_mode(matchkind, typ, tblctx))

      2. (Let tblctx'' be $add_key((typ, matchkind), tblctx'))

      3. Result in tblctx'', (exprIL matchkind)

    1. Else Phantom#1186

  1. Else Phantom#1187

3. Else Phantom#1188

;; ../../../../spec/4g-typing-decl.watsup:717.1-717.44
def $check_table_key(matchkind, typ)

1. Case analysis on matchkind

  1. Case (% = "exact")

    1. (Let typ' be $canon_typ(typ))

    2. If ($is_errt(typ')), then

      1. Return true

    3. If ($is_boolt(typ')), then

      1. Return true

    4. If ($is_intt(typ')), then

      1. Return true

    5. If ($is_fintt(typ')), then

      1. Return true

    6. If ($is_fbitt(typ')), then

      1. Return true

    7. If ($is_vbitt(typ')), then

      1. Return true

    8. If ($is_enumt(typ')), then

      1. Return true

    9. If ((typ' has type datatyp)), then

      1. (Let datatyp be (typ' as datatyp))

      2. Case analysis on datatyp

        1. Case (% matches pattern `SEnumT%%%`)

          1. (Let (SEnumT _id typ' _(member, val)*) be datatyp)

          2. Return $check_table_key(matchkind, typ')

        2. Case (% matches pattern `NewT%%`)

          1. (Let (NewT _id typ') be datatyp)

          2. Return $check_table_key(matchkind, typ')

  2. Case (% = "optional")

    1. (Let typ' be $canon_typ(typ))

    2. If ($is_errt(typ')), then

      1. Return true

    3. If ($is_boolt(typ')), then

      1. Return true

    4. If ($is_intt(typ')), then

      1. Return true

    5. If ($is_fintt(typ')), then

      1. Return true

    6. If ($is_fbitt(typ')), then

      1. Return true

    7. If ($is_vbitt(typ')), then

      1. Return true

    8. If ($is_enumt(typ')), then

      1. Return true

    9. If ((typ' has type datatyp)), then

      1. (Let datatyp be (typ' as datatyp))

      2. Case analysis on datatyp

        1. Case (% matches pattern `SEnumT%%%`)

          1. (Let (SEnumT _id typ' _(member, val)*) be datatyp)

          2. Return $check_table_key(matchkind, typ')

        2. Case (% matches pattern `NewT%%`)

          1. (Let (NewT _id typ') be datatyp)

          2. Return $check_table_key(matchkind, typ')

  3. Case (% = "lpm")

    1. (Let typ' be $canon_typ(typ))

    2. If ($is_intt(typ')), then

      1. Return true

    3. If ($is_fintt(typ')), then

      1. Return true

    4. If ($is_fbitt(typ')), then

      1. Return true

    5. If ((typ' has type datatyp)), then

      1. (Let datatyp be (typ' as datatyp))

      2. Case analysis on datatyp

        1. Case (% matches pattern `SEnumT%%%`)

          1. (Let (SEnumT _id typ' _(member, val)*) be datatyp)

          2. Return $check_table_key(matchkind, typ')

        2. Case (% matches pattern `NewT%%`)

          1. (Let (NewT _id typ') be datatyp)

          2. Return $check_table_key(matchkind, typ')

  4. Case (% = "ternary")

    1. (Let typ' be $canon_typ(typ))

    2. If ($is_intt(typ')), then

      1. Return true

    3. If ($is_fintt(typ')), then

      1. Return true

    4. If ($is_fbitt(typ')), then

      1. Return true

    5. If ((typ' has type datatyp)), then

      1. (Let datatyp be (typ' as datatyp))

      2. Case analysis on datatyp

        1. Case (% matches pattern `SEnumT%%%`)

          1. (Let (SEnumT _id typ' _(member, val)*) be datatyp)

          2. Return $check_table_key(matchkind, typ')

        2. Case (% matches pattern `NewT%%`)

          1. (Let (NewT _id typ') be datatyp)

          2. Return $check_table_key(matchkind, typ')

  5. Case (% = "range")

    1. (Let typ' be $canon_typ(typ))

    2. If ($is_intt(typ')), then

      1. Return true

    3. If ($is_fintt(typ')), then

      1. Return true

    4. If ($is_fbitt(typ')), then

      1. Return true

    5. If ((typ' has type datatyp)), then

      1. (Let datatyp be (typ' as datatyp))

      2. Case analysis on datatyp

        1. Case (% matches pattern `SEnumT%%%`)

          1. (Let (SEnumT _id typ' _(member, val)*) be datatyp)

          2. Return $check_table_key(matchkind, typ')

        2. Case (% matches pattern `NewT%%`)

          1. (Let (NewT _id typ') be datatyp)

          2. Return $check_table_key(matchkind, typ')

2. Otherwise

  1. Return false

;; ../../../../spec/4g-typing-decl.watsup:767.1-769.26
relation Table_keys_ok: p, C, tblctx, tblkey*

1. Case analysis on tblkey*

  1. Case (% matches pattern [])

    1. Result in tblctx, []

  2. Case (% matches pattern _ :: _)

    1. (Let tblkey_h :: tblkey_t* be tblkey*)

    2. (Table_key_ok: p C tblctx |- tblkey_h : tblctx' tblkeyIL_h)

    3. (Table_keys_ok: p C tblctx' |- tblkey_t* : tblctx'' tblkeyIL_t*)

    4. Result in tblctx'', tblkeyIL_h :: tblkeyIL_t*

;; ../../../../spec/4g-typing-decl.watsup:783.1-785.26
relation Call_action_partial_ok: p, C, pt*, (argIL, typ_a)*

1. (Let (paramIL_d*, paramIL_c*) be $split_directionless_params((pt* as paramIL*)))

2. If ((|paramIL_d*| = |argIL*|)), then

  1. (Call_convention_arg_ok: p C (ACT) |- (paramIL_d as paramtyp) ~~ (argIL, typ_a) : argIL')*

  2. Result in paramIL_d*, paramIL_c*, argIL'*

2. Else Phantom#1189

;; ../../../../spec/4g-typing-decl.watsup:787.1-788.46
def $split_directionless_params(paramIL*)

1. Case analysis on paramIL*

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let paramIL_h :: paramIL_t* be paramIL*)

    2. (Let (_idIL dir _typeIL _exprIL?) be paramIL_h)

    3. Case analysis on (dir matches pattern `NO`)

      1. Case true

        1. (Let (paramIL_d*, paramIL_c*) be $split_directionless_params(paramIL_t*))

        2. Return (paramIL_d*, paramIL_h :: paramIL_c*)

      2. Case false

        1. (Let (paramIL_d*, paramIL_c*) be $split_directionless_params(paramIL_t*))

        2. Return (paramIL_h :: paramIL_d*, paramIL_c*)

;; ../../../../spec/4g-typing-decl.watsup:807.1-809.26
relation Table_action_ok: p, C, tblctx, (name arg*)

1. (Arg_ok: p C |- arg : argIL typ_a)*

2. (Let funcdef'? be $find_funcdef_by_name(p, C, name))

3. If ((funcdef'? matches pattern (_))), then

  1. (Let ?(funcdef) be funcdef'?)

  2. If ((funcdef has type monofuncdef)), then

    1. (Let (MonoFD functyp) be (funcdef as monofuncdef))

    2. If ((functyp matches pattern `ActionT%`)), then

      1. (Let (ActionT pt*) be functyp)

      2. (Call_action_partial_ok: p C |- pt* (argIL, typ_a)* : paramIL_d* paramIL_c* argIL'*)

      3. (Let tblctx' be $add_action((name, pt*, argIL*), tblctx))

      4. Result in tblctx', (name argIL'* paramIL_d* paramIL_c*)

    2. Else Phantom#1190

  2. Else Phantom#1191

3. Else Phantom#1192

;; ../../../../spec/4g-typing-decl.watsup:821.1-823.26
relation Table_actions_ok: p, C, tblctx, tblaction*

1. Case analysis on tblaction*

  1. Case (% matches pattern [])

    1. Result in tblctx, []

  2. Case (% matches pattern _ :: _)

    1. (Let tblaction_h :: tblaction_t* be tblaction*)

    2. (Table_action_ok: p C tblctx |- tblaction_h : tblctx' tblactionIL_h)

    3. (Table_actions_ok: p C tblctx' |- tblaction_t* : tblctx'' tblactionIL_t*)

    4. (Let tblactionIL* be tblactionIL_h :: tblactionIL_t*)

    5. (Let (name argIL* paramIL_d* paramIL_c*) be tblactionIL)*

    6. If ($distinct_<name>(name*)), then

      1. Result in tblctx'', tblactionIL_h :: tblactionIL_t*

    6. Else Phantom#1193

;; ../../../../spec/4g-typing-decl.watsup:841.1-843.29
relation Table_entry_keyset_ok: p, C, tblctx, (typ_k, text'), keyset

1. Case analysis on text'

  1. Case (% = "lpm")

    1. Case analysis on keyset

      1. Case (% matches pattern `ExprK%`)

        1. (Let (ExprK expr) be keyset)

        2. If ((expr matches pattern `MaskE%%`)), then

          1. (Let (MaskE expr_b expr_m) be expr)

          2. (Expr_ok: p C |- (MaskE expr_b expr_m) : exprIL)

          3. (Let (( typ' ; _ctk )) be $annot(exprIL))

          4. If ((typ' has type synthtyp)), then

            1. (Let synthtyp be (typ' as synthtyp))

            2. If ((synthtyp matches pattern `SetT%`)), then

              1. (Let (SetT typ) be synthtyp)

              2. (Let exprIL' be exprIL)

              3. If ((exprIL' matches pattern `MaskE%%%`)), then

                1. (Let (MaskE exprIL_b exprIL_m _annotIL) be exprIL')

                2. (Let mode be tblctx.MODE)

                3. If ((mode matches pattern `NOPRILPM%`)), then

                  1. (Let (NOPRILPM n_w) be mode)

                  2. (Eval_static: p C |- exprIL_m ~> (val_m _exprIL))

                  3. (Let i_m be $get_num(val_m))

                  4. (Let tblstate_e be $get_lpm_prefix((FBitV n_w $to_bitstr((n_w as int), i_m))))

                  5. If ((Sub_impl: typ << typ_k holds)), then

                    1. Result in tblstate_e, (ExprK exprIL)

                  5. Else Phantom#1194

                3. Else Phantom#1195

              3. Else Phantom#1196

            2. Else Phantom#1197

          4. Else Phantom#1198

        2. Else Phantom#1199

        3. If (~($is_maske(expr) \/ $is_rangee(expr))), then

          1. (Expr_ok: p C |- expr : exprIL)

          2. (Let (( typ ; ctk )) be $annot(exprIL))

          3. (Let mode be tblctx.MODE)

          4. If ((mode matches pattern `NOPRILPM%`)), then

            1. (Let (NOPRILPM n_w) be mode)

            2. If ((Sub_impl: typ << typ_k holds)), then

              1. (Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; ctk ))))

              2. Result in (LPM n_w), (ExprK exprIL')

            2. Else Phantom#1200

          4. Else Phantom#1201

        3. Else Phantom#1202

      2. Case (% matches pattern `DefaultK`)

        1. (Let mode be tblctx.MODE)

        2. If ((mode matches pattern `NOPRILPM%`)), then

          1. (Let (NOPRILPM n_w) be mode)

          2. Result in (LPM n_w), (DefaultK)

        2. Else Phantom#1203

      3. Case (% matches pattern `AnyK`)

        1. (Let mode be tblctx.MODE)

        2. If ((mode matches pattern `NOPRILPM%`)), then

          1. (Let (NOPRILPM _nat) be mode)

          2. Result in (LPM 0), (AnyK)

        2. Else Phantom#1204

  2. Case (% = "ternary")

    1. If ((keyset matches pattern `ExprK%`)), then

      1. (Let (ExprK expr) be keyset)

      2. If ((expr matches pattern `MaskE%%`)), then

        1. (Let (MaskE expr_b expr_m) be expr)

        2. (Expr_ok: p C |- (MaskE expr_b expr_m) : exprIL)

        3. (Let (( typ' ; _ctk )) be $annot(exprIL))

        4. If ((typ' has type synthtyp)), then

          1. (Let synthtyp be (typ' as synthtyp))

          2. If ((synthtyp matches pattern `SetT%`)), then

            1. (Let (SetT typ) be synthtyp)

            2. If ((Sub_impl: typ << typ_k holds)), then

              1. Result in (NOLPM), (ExprK exprIL)

            2. Else Phantom#1205

          2. Else Phantom#1206

        4. Else Phantom#1207

      2. Else Phantom#1208

      3. If (~($is_maske(expr) \/ $is_rangee(expr))), then

        1. (Expr_ok: p C |- expr : exprIL)

        2. (Let (( typ ; ctk )) be $annot(exprIL))

        3. If ((Sub_impl: typ << typ_k holds)), then

          1. (Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; ctk ))))

          2. Result in (NOLPM), (ExprK exprIL')

        3. Else Phantom#1209

      3. Else Phantom#1210

    1. Else Phantom#1211

  3. Case (% = "range")

    1. If ((keyset matches pattern `ExprK%`)), then

      1. (Let (ExprK expr) be keyset)

      2. If ((expr matches pattern `RangeE%%`)), then

        1. (Let (RangeE expr_l expr_r) be expr)

        2. (Expr_ok: p C |- (RangeE expr_l expr_r) : exprIL)

        3. (Let (( typ' ; _ctk )) be $annot(exprIL))

        4. If ((typ' has type synthtyp)), then

          1. (Let synthtyp be (typ' as synthtyp))

          2. If ((synthtyp matches pattern `SetT%`)), then

            1. (Let (SetT typ) be synthtyp)

            2. If ((Sub_impl: typ << typ_k holds)), then

              1. Result in (NOLPM), (ExprK exprIL)

            2. Else Phantom#1212

          2. Else Phantom#1213

        4. Else Phantom#1214

      2. Else Phantom#1215

      3. If (~($is_maske(expr) \/ $is_rangee(expr))), then

        1. (Expr_ok: p C |- expr : exprIL)

        2. (Let (( typ ; ctk )) be $annot(exprIL))

        3. If ((Sub_impl: typ << typ_k holds)), then

          1. (Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; ctk ))))

          2. Result in (NOLPM), (ExprK exprIL')

        3. Else Phantom#1216

      3. Else Phantom#1217

    1. Else Phantom#1218

1. Else Phantom#1219

2. Case analysis on keyset

  1. Case (% matches pattern `ExprK%`)

    1. (Let (ExprK expr) be keyset)

    2. If ((((text' =/= "lpm") /\ (text' =/= "ternary")) /\ (text' =/= "range"))), then

      1. If (~($is_maske(expr) \/ $is_rangee(expr))), then

        1. (Expr_ok: p C |- expr : exprIL)

        2. (Let (( typ ; ctk )) be $annot(exprIL))

        3. If ((Sub_impl: typ << typ_k holds)), then

          1. (Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; ctk ))))

          2. Result in (NOLPM), (ExprK exprIL')

        3. Else Phantom#1220

      1. Else Phantom#1221

    2. Else Phantom#1222

  2. Case (% matches pattern `DefaultK`)

    1. If ((text' =/= "exact")), then

      1. Result in (NOLPM), (DefaultK)

    1. Else Phantom#1223

  3. Case (% matches pattern `AnyK`)

    1. If ((text' =/= "exact")), then

      1. Result in (NOLPM), (AnyK)

    1. Else Phantom#1224

;; ../../../../spec/4g-typing-decl.watsup:935.1-937.32
relation Table_entry_keysets_state_ok: p, C, tblctx, tblstate', key*, keyset*

1. Case analysis on key*

  1. Case (% matches pattern [])

    1. If ((keyset* matches pattern [])), then

      1. Result in tblstate', []

    1. Else Phantom#1225

  2. Case (% matches pattern _ :: _)

    1. (Let key_h :: key_t* be key*)

    2. If ((keyset* matches pattern _ :: _)), then

      1. (Let keyset_h :: keyset_t* be keyset*)

      2. (Table_entry_keyset_ok: p C tblctx |- key_h keyset_h : tblstate_1 keysetIL_h)

      3. (Let tblstate_2 be $update_state(tblstate', tblstate_1))

      4. (Table_entry_keysets_state_ok: p C tblctx tblstate_2 |- key_t* keyset_t* : tblstate_3 keysetIL_t*)

      5. Result in tblstate_3, keysetIL_h :: keysetIL_t*

    2. Else Phantom#1226

;; ../../../../spec/4g-typing-decl.watsup:949.1-951.26
relation Table_entry_keysets_ok: p, C, tblctx, keyset*

1. Case analysis on keyset*

  1. Case (% = [(DefaultK)])

    1. (Let mode be tblctx.MODE)

    2. If ((mode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM nat) be mode)

      2. Result in (LPM nat), [(DefaultK)]

    2. Else Phantom#1227

    3. If ((((tblctx.MODE = (NOPRI)) \/ (tblctx.MODE = (PRI))) \/ (tblctx.MODE = (PRILPM)))), then

      1. Result in (NOLPM), [(DefaultK)]

    3. Else Phantom#1228

  2. Case (% = [(AnyK)])

    1. (Let mode be tblctx.MODE)

    2. If ((mode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM nat) be mode)

      2. Result in (LPM 0), [(AnyK)]

    2. Else Phantom#1229

    3. If ((((tblctx.MODE = (NOPRI)) \/ (tblctx.MODE = (PRI))) \/ (tblctx.MODE = (PRILPM)))), then

      1. Result in (NOLPM), [(AnyK)]

    3. Else Phantom#1230

1. Else Phantom#1231

2. If ((|tblctx.KEYS| = |keyset*|)), then

  1. (Table_entry_keysets_state_ok: p C tblctx (NOLPM) |- tblctx.KEYS keyset* : tblstate keysetIL*)

  2. Result in tblstate, keysetIL*

2. Else Phantom#1232

;; ../../../../spec/4g-typing-decl.watsup:975.1-977.29
relation Call_default_action_ok: p, C, pt*, (argIL, typ)*, argIL_a*

1. If ((|pt*| = |argIL*|)), then

  1. (Let argIL_d* be $filter_directionless_args(pt*, argIL*))

  2. If ((argIL_a = argIL_d))*, then

    1. (Call_convention_arg_ok: p C (ACT) |- pt ~~ (argIL, typ) : argIL')*

    2. Result in argIL'*

  2. Else Phantom#1233

1. Else Phantom#1234

;; ../../../../spec/4g-typing-decl.watsup:979.1-979.59
def $filter_directionless_args(paramtyp*, argIL*)

1. Case analysis on paramtyp*

  1. Case (% matches pattern [])

    1. If ((argIL* matches pattern [])), then

      1. Return []

    1. Else Phantom#1235

  2. Case (% matches pattern _ :: _)

    1. (Let pt_h :: pt_t* be paramtyp*)

    2. If ((argIL* matches pattern _ :: _)), then

      1. (Let argIL_h :: argIL_t* be argIL*)

      2. (Let (id dir typ exprIL?) be pt_h)

      3. If ((dir matches pattern `NO`)), then

        1. Return $filter_directionless_args(pt_t*, argIL_t*)

      3. Else Phantom#1236

      4. Otherwise

        1. Return argIL_h :: $filter_directionless_args(pt_t*, argIL_t*)

    2. Else Phantom#1237

;; ../../../../spec/4g-typing-decl.watsup:997.1-999.26
relation Table_entry_action_ok: p, C, tblctx, (name arg*)

1. (Let (paramtyp*, argIL*)? be $find_action(tblctx, name))

2. If (((paramtyp*, argIL*)? matches pattern (_))), then

  1. (Let ?((pt*, argIL_a*)) be (paramtyp*, argIL*)?)

  2. (Arg_ok: p C |- arg : argIL typ_arg)*

  3. (Call_default_action_ok: p C |- pt* (argIL, typ_arg)* argIL_a* : argIL'*)

  4. (Let tblactionIL be (name argIL'* (pt* as paramIL*) []))

  5. Result in tblactionIL

2. Else Phantom#1238

;; ../../../../spec/4g-typing-decl.watsup:1012.1-1014.29
relation Table_entry_priority_ok: cursor, C, tblctx, tblstate, expr''?

1. If ((cursor matches pattern `LOCAL`)), then

  1. Case analysis on expr''?

    1. Case (% matches pattern ())

      1. If ((tblctx.MODE matches pattern `NOPRI`)), then

        1. Result in tblctx, ?()

      1. Else Phantom#1239

      2. If (((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM)))), then

        1. Case analysis on tblctx.PRIORITIES.VALUES

          1. Case (% = [])

            1. Case analysis on tblctx.PRIORITIES.LARGEST_WINS

              1. Case true

                1. (Let i_size be tblctx.ENTRIES.SIZE)

                2. (Let i_delta be tblctx.PRIORITIES.DELTA)

                3. (Let i be (((i_size - (1 as int)) * i_delta) + (1 as int)))

                4. If ((i >= (0 as int))), then

                  1. (Let tblctx' be $add_priority(i, tblctx))

                  2. Result in tblctx', ?((IntV i))

                4. Else Phantom#1240

              2. Case false

                1. (Let tblctx' be $add_priority((1 as int), tblctx))

                2. Result in tblctx', ?((IntV (1 as int)))

          2. Case (% =/= [])

            1. (Let i_delta be tblctx.PRIORITIES.DELTA)

            2. (Let i be $find_last_priority(tblctx))

            3. Case analysis on tblctx.PRIORITIES.LARGEST_WINS

              1. Case true

                1. (Let i' be (i - i_delta))

                2. If ((i' >= (0 as int))), then

                  1. (Let tblctx' be $add_priority(i', tblctx))

                  2. Result in tblctx', ?((IntV i'))

                2. Else Phantom#1241

              2. Case false

                1. (Let i' be (i + i_delta))

                2. If ((i' >= (0 as int))), then

                  1. (Let tblctx' be $add_priority(i', tblctx))

                  2. Result in tblctx', ?((IntV i'))

                2. Else Phantom#1242

      2. Else Phantom#1243

    2. Case (% matches pattern (_))

      1. (Let ?(expr'') be expr''?)

      2. If (((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM)))), then

        1. If (~tblctx.ENTRIES.CONST), then

          1. Case analysis on tblctx.PRIORITIES.VALUES

            1. Case (% = [])

              1. (Expr_ok: (LOCAL) C |- expr'' : exprIL)

              2. (Eval_static: (LOCAL) C |- exprIL ~> (val _exprIL))

              3. (Let i be $get_num(val))

              4. If ((i >= (0 as int))), then

                1. (Let tblctx' be tblctx[PRIORITIES.INIT = true])

                2. (Let tblctx'' be $add_priority(i, tblctx'))

                3. Result in tblctx'', ?((IntV i))

              4. Else Phantom#1244

            2. Case (% =/= [])

              1. If (tblctx.PRIORITIES.INIT), then

                1. (Expr_ok: (LOCAL) C |- expr'' : exprIL)

                2. (Eval_static: (LOCAL) C |- exprIL ~> (val _exprIL))

                3. (Let i be $get_num(val))

                4. If ((i >= (0 as int))), then

                  1. (Let tblctx' be $add_priority(i, tblctx))

                  2. Result in tblctx', ?((IntV i))

                4. Else Phantom#1245

              1. Else Phantom#1246

        1. Else Phantom#1247

      2. Else Phantom#1248

  2. If ((tblstate matches pattern `LPM%`)), then

    1. (Let (LPM nat_prefix) be tblstate)

    2. If ((expr''? matches pattern ())), then

      1. (Let mode be tblctx.MODE)

      2. If ((mode matches pattern `NOPRILPM%`)), then

        1. (Let (NOPRILPM nat) be mode)

        2. Result in tblctx, ?()

      2. Else Phantom#1249

    2. Else Phantom#1250

  2. Else Phantom#1251

1. Else Phantom#1252

;; ../../../../spec/4g-typing-decl.watsup:1105.1-1107.26
relation Table_entry_ok: p, C, tblctx, (bool keyset* tblaction expr?)

1. (Table_entry_keysets_ok: p C tblctx |- keyset* : tblstate keysetIL*)

2. (Table_entry_action_ok: p C tblctx |- tblaction : tblactionIL)

3. (Table_entry_priority_ok: p C tblctx tblstate |- expr? : tblctx' val?)

4. Result in tblctx', (bool keysetIL* tblactionIL val?)

;; ../../../../spec/4g-typing-decl.watsup:1118.1-1120.26
relation Table_entries_fold_ok: p, C, tblctx, tblentry*

1. Case analysis on tblentry*

  1. Case (% matches pattern [])

    1. Result in tblctx, []

  2. Case (% matches pattern _ :: _)

    1. (Let tblentry_h :: tblentry_t* be tblentry*)

    2. (Table_entry_ok: p C tblctx |- tblentry_h : tblctx' tblentryIL_h)

    3. (Table_entries_fold_ok: p C tblctx' |- tblentry_t* : tblctx'' tblentryIL_t*)

    4. Result in tblctx'', tblentryIL_h :: tblentryIL_t*

;; ../../../../spec/4g-typing-decl.watsup:1131.1-1133.26
relation Table_entries_ok: p, C, tblctx_0, (b tblentry*)

1. If (((|tblctx_0.KEYS| = 0) => (|tblentry*| = 0))), then

  1. (Let tblctx_1 be tblctx_0[ENTRIES.SIZE = (|tblentry*| as int)])

  2. (Let tblctx_2 be tblctx_1[ENTRIES.CONST = b])

  3. (Table_entries_fold_ok: p C tblctx_2 |- tblentry* : tblctx_3 tblentryIL*)

  4. Result in tblctx_3, (b tblentryIL*)

1. Else Phantom#1253

;; ../../../../spec/4g-typing-decl.watsup:1148.1-1150.26
relation Table_default_ok: p, C, tblctx, (bool (name arg*))

1. (Let (paramtyp*, argIL*)? be $find_action(tblctx, name))

2. If (((paramtyp*, argIL*)? matches pattern (_))), then

  1. (Let ?((pt*, argIL_a*)) be (paramtyp*, argIL*)?)

  2. (Arg_ok: p C |- arg : argIL typ_a)*

  3. (Call_default_action_ok: p C |- pt* (argIL, typ_a)* argIL_a* : argIL'*)

  4. (Let tblactionIL be (name argIL'* (pt* as paramIL*) []))

  5. Result in (bool tblactionIL)

2. Else Phantom#1254

;; ../../../../spec/4g-typing-decl.watsup:1166.1-1168.26
relation Table_custom_ok: p, C, tblctx, (b text' expr)

1. Case analysis on text'

  1. Case (% = "size")

    1. (Expr_ok: p C |- expr : exprIL)

    2. (Let (( typ ; _ctk )) be $annot(exprIL))

    3. If ((($is_intt(typ) \/ $is_fintt(typ)) \/ $is_fbitt(typ))), then

      1. Result in tblctx, (b "size" exprIL)

    3. Else Phantom#1255

  2. Case (% = "largest_priority_wins")

    1. (Expr_ok: p C |- expr : exprIL)

    2. (Let (( typ ; _ctk )) be $annot(exprIL))

    3. If ((typ = ((BoolT) as typ))), then

      1. (Eval_static: p C |- exprIL ~> (val _exprIL))

      2. If ((val matches pattern `BoolV%`)), then

        1. (Let (BoolV b_lw) be val)

        2. (Let tblctx' be tblctx[PRIORITIES.LARGEST_WINS = b_lw])

        3. Result in tblctx', (b "largest_priority_wins" exprIL)

      2. Else Phantom#1256

    3. Else Phantom#1257

  3. Case (% = "priority_delta")

    1. (Expr_ok: p C |- expr : exprIL)

    2. (Let (( typ ; _ctk )) be $annot(exprIL))

    3. If ((($is_intt(typ) \/ $is_fintt(typ)) \/ $is_fbitt(typ))), then

      1. (Eval_static: p C |- exprIL ~> (val _exprIL))

      2. (Let i_delta be $get_num(val))

      3. If ((i_delta > (0 as int))), then

        1. (Let tblctx' be tblctx[PRIORITIES.DELTA = i_delta])

        2. Result in tblctx', (b "priority_delta" exprIL)

      3. Else Phantom#1258

    3. Else Phantom#1259

1. Else Phantom#1260

2. If ((((text' =/= "size") /\ (text' =/= "largest_priority_wins")) /\ (text' =/= "priority_delta"))), then

  1. (Expr_ok: p C |- expr : exprIL)

  2. Result in tblctx, (b text' exprIL)

2. Else Phantom#1261

;; ../../../../spec/4g-typing-decl.watsup:1203.1-1205.26
relation Table_prop_ok: p, C, tblctx, tblprop

1. Case analysis on tblprop

  1. Case (% matches pattern `KeyP%`)

    1. (Let (KeyP tblkeyprop) be tblprop)

    2. (Table_keys_ok: p C tblctx |- tblkeyprop : tblctx' tblkeypropIL)

    3. Result in tblctx', (KeyP tblkeypropIL)

  2. Case (% matches pattern `ActionP%`)

    1. (Let (ActionP tblactionprop) be tblprop)

    2. (Table_actions_ok: p C tblctx |- tblactionprop : tblctx' tblactionpropIL)

    3. Result in tblctx', (ActionP tblactionpropIL)

  3. Case (% matches pattern `EntryP%`)

    1. (Let (EntryP tblentryprop) be tblprop)

    2. (Table_entries_ok: p C tblctx |- tblentryprop : tblctx' tblentrypropIL)

    3. Result in tblctx', (EntryP tblentrypropIL)

  4. Case (% matches pattern `DefaultP%`)

    1. (Let (DefaultP tbldefaultprop) be tblprop)

    2. (Table_default_ok: p C tblctx |- tbldefaultprop : tbldefaultpropIL)

    3. Result in tblctx, (DefaultP tbldefaultpropIL)

  5. Case (% matches pattern `CustomP%`)

    1. (Let (CustomP tblcustomprop) be tblprop)

    2. (Table_custom_ok: p C tblctx |- tblcustomprop : tblctx' tblcustompropIL)

    3. Result in tblctx', (CustomP tblcustompropIL)

;; ../../../../spec/4g-typing-decl.watsup:1228.1-1230.26
relation Table_props_ok: p, C, tblctx, tblprop*

1. Case analysis on tblprop*

  1. Case (% matches pattern [])

    1. Result in tblctx, []

  2. Case (% matches pattern _ :: _)

    1. (Let tblprop_h :: tblprop_t* be tblprop*)

    2. (Table_prop_ok: p C tblctx |- tblprop_h : tblctx' tblpropIL_h)

    3. (Table_props_ok: p C tblctx' |- tblprop_t* : tblctx'' tblpropIL_t*)

    4. Result in tblctx'', tblpropIL_h :: tblpropIL_t*

;; ../../../../spec/4g-typing-decl.watsup:1244.1-1246.26
relation Table_type_decl_ok: cursor, C, tblctx, id

1. If ((cursor matches pattern `BLOCK`)), then

  1. (Let id_e be $concat_text(["action_list(", id, ")"]))

  2. (Let (name, pt*, argIL*)* be tblctx.ACTIONS)

  3. (Let member be $string_of_name(name))*

  4. (Let typ_e be ((TableEnumT id_e member*) as typ))

  5. (Let val_e be (TableEnumFieldV id_e member))*

  6. (Let id_f be $concat_text([id_e, ".", member]))*

  7. (Let C' be $add_styps((BLOCK), C, id_f*, (typ_e (NO) (LCTK) ?(val_e))*))

  8. (Let id_s be $concat_text(["apply_result(", id, ")"]))

  9. (Let typ_s be ((TableStructT id_s [("hit", ((BoolT) as typ)), ("miss", ((BoolT) as typ)), ("action_run", typ_e)]) as typ))

  10. Result in C', typ_s

1. Else Phantom#1262

;; ../../../../spec/4h-typing-call.watsup:149.1-150.77
def $filter_default_args(paramtyp*, id_deft*)

1. Case analysis on paramtyp*

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let pt_h :: pt_t* be paramtyp*)

    2. (Let (id_p _dir _typ _exprIL?) be pt_h)

    3. If (id_p is in id_deft*), then

      1. Return $filter_default_args(pt_t*, id_deft*)

    3. Else Phantom#1263

    4. Otherwise

      1. Return pt_h :: $filter_default_args(pt_t*, id_deft*)

;; ../../../../spec/4h-typing-call.watsup:161.15-161.32
syntax pmap = map<id, paramtyp>

;; ../../../../spec/4h-typing-call.watsup:163.1-164.80
def $align_params_with_args(pt*, (argIL, typ)*)

1. (Let (id _dir _typ _exprIL?) be pt)*

2. (Let pmap be ({ (id -> pt)* }))

3. (Let pt' be $align_params_with_args'(pmap, pt, (argIL, typ)))*

4. Return pt'*

;; ../../../../spec/4h-typing-call.watsup:165.1-166.97
def $align_params_with_args'(pmap, pt, (argIL, _typ))

1. Case analysis on argIL

  1. Case (% matches pattern `ExprA%`)

    1. (Let (ExprA _exprIL) be argIL)

    2. Return pt

  2. Case (% matches pattern `NameA%%`)

    1. (Let (NameA id _exprIL?) be argIL)

    2. (Let paramtyp? be $find_map<id, paramtyp>(pmap, id))

    3. If ((paramtyp? matches pattern (_))), then

      1. (Let ?(pt') be paramtyp?)

      2. Return pt'

    3. Else Phantom#1264

  3. Case (% matches pattern `AnyA`)

    1. Return pt

;; ../../../../spec/4h-typing-call.watsup:183.1-184.12
syntax typcstr = 
   | `KNOWN%`(typ)
   | `UNKNOWN`()

;; ../../../../spec/4h-typing-call.watsup:188.1-188.42
def $empty_cstr(tid*)

1. Return ({ (tid -> (UNKNOWN))* })

;; ../../../../spec/4h-typing-call.watsup:194.1-194.63
def $gen_cstr(cstr, typ'', typ_a''')

1. Case analysis on typ''

  1. Case (% has type abstyp)

    1. (Let abstyp be (typ'' as abstyp))

    2. Case analysis on abstyp

      1. Case (% matches pattern `VarT%`)

        1. (Let (VarT tid) be abstyp)

        2. If ($in_set<tid>(tid, $dom_map<tid, typcstr>(cstr))), then

          1. Return $update_map<tid, typcstr>(cstr, tid, (KNOWN typ_a'''))

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT ptd_p typ_p'*) be abstyp)

        2. If ((typ_a''' has type abstyp)), then

          1. (Let abstyp' be (typ_a''' as abstyp))

          2. If ((abstyp' matches pattern `SpecT%%`)), then

            1. (Let (SpecT ptd_a typ_a'*) be abstyp')

            2. (Let typ_p'' be $specialize_typdef((ptd_p as typdef), typ_p'*))

            3. (Let typ_a'' be $specialize_typdef((ptd_a as typdef), typ_a'*))

            4. Case analysis on ($is_nominal(typ_p'') /\ $is_nominal(typ_a''))

              1. Case true

                1. (Let cstr' be $gen_cstr(cstr, typ_p'', typ_a''))

                2. Return $gen_cstrs(cstr', typ_p'*, typ_a'*)

              2. Case false

                1. (Let cstr' be $gen_cstr(cstr, typ_p'', typ_a''))

                2. Return cstr'

  2. Case (% has type aliastyp)

    1. (Let (DefT _id typ_p') be (typ'' as aliastyp))

    2. Return $gen_cstr(cstr, typ_p', typ_a''')

  3. Case (% has type datatyp)

    1. (Let datatyp be (typ'' as datatyp))

    2. Case analysis on datatyp

      1. Case (% matches pattern `NewT%%`)

        1. (Let (NewT id typ_p') be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `NewT%%`)), then

            1. (Let (NewT id' typ_a') be datatyp')

            2. If ((id = id')), then

              1. Return $gen_cstr(cstr, typ_p', typ_a')

      2. Case (% matches pattern `ListT%`)

        1. (Let (ListT typ'') be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `ListT%`)), then

            1. (Let (ListT typ_a''') be datatyp')

            2. Return $gen_cstr(cstr, typ'', typ_a''')

      3. Case (% matches pattern `TupleT%`)

        1. (Let (TupleT typ''*) be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `TupleT%`)), then

            1. (Let (TupleT typ_a'''*) be datatyp')

            2. Return $gen_cstrs(cstr, typ''*, typ_a'''*)

      4. Case (% matches pattern `StackT%%`)

        1. (Let (StackT typ_p' i_p) be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `StackT%%`)), then

            1. (Let (StackT typ_a' i_a) be datatyp')

            2. Return $gen_cstr(cstr, typ_p', typ_a')

      5. Case (% matches pattern `StructT%%`)

        1. (Let (StructT id (member_p, typ_p')*) be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `StructT%%`)), then

            1. (Let (StructT id' (member_a, typ_a')*) be datatyp')

            2. If ((id = id')), then

              1. Return $gen_cstrs(cstr, typ_p'*, typ_a'*)

      6. Case (% matches pattern `HeaderT%%`)

        1. (Let (HeaderT id (member_p, typ_p')*) be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `HeaderT%%`)), then

            1. (Let (HeaderT id' (member_a, typ_a')*) be datatyp')

            2. If ((id = id')), then

              1. Return $gen_cstrs(cstr, typ_p'*, typ_a'*)

      7. Case (% matches pattern `UnionT%%`)

        1. (Let (UnionT id (member_p, typ_p')*) be datatyp)

        2. If ((typ_a''' has type datatyp)), then

          1. (Let datatyp' be (typ_a''' as datatyp))

          2. If ((datatyp' matches pattern `UnionT%%`)), then

            1. (Let (UnionT id' (member_a, typ_a')*) be datatyp')

            2. If ((id = id')), then

              1. Return $gen_cstrs(cstr, typ_p'*, typ_a'*)

  4. Case (% has type objtyp)

    1. (Let objtyp be (typ'' as objtyp))

    2. Case analysis on objtyp

      1. Case (% matches pattern `ExternT%%`)

        1. (Let (ExternT id fdenv_p) be objtyp)

        2. If ((typ_a''' has type objtyp)), then

          1. (Let objtyp' be (typ_a''' as objtyp))

          2. If ((objtyp' matches pattern `ExternT%%`)), then

            1. (Let (ExternT id' fdenv_a) be objtyp')

            2. If ((id = id')), then

              1. (Let ({ (fid_p -> fd_p)* }) be fdenv_p)

              2. (Let ({ (fid_a -> fd_a)* }) be fdenv_a)

              3. If ($eq_set<fid>(({ fid_p* }), ({ fid_a* }))), then

                1. Return $gen_cstr_fd'(cstr, fid_p*, fdenv_p, fdenv_a)

      2. Case (% matches pattern `ParserT%%`)

        1. (Let (ParserT _id pt_p*) be objtyp)

        2. If ((typ_a''' has type objtyp)), then

          1. (Let objtyp' be (typ_a''' as objtyp))

          2. If ((objtyp' matches pattern `ParserT%%`)), then

            1. (Let (ParserT _id' pt_a*) be objtyp')

            2. (Let (_id'' dir typ_p' _exprIL?) be pt_p)*

            3. (Let (_id''' dir' typ_a' _exprIL'?) be pt_a)*

            4. If ((dir' = dir))*, then

              1. Return $gen_cstrs(cstr, typ_p'*, typ_a'*)

      3. Case (% matches pattern `ControlT%%`)

        1. (Let (ControlT _id pt_p*) be objtyp)

        2. If ((typ_a''' has type objtyp)), then

          1. (Let objtyp' be (typ_a''' as objtyp))

          2. If ((objtyp' matches pattern `ControlT%%`)), then

            1. (Let (ControlT _id' pt_a*) be objtyp')

            2. (Let (_id'' dir typ_p' _exprIL?) be pt_p)*

            3. (Let (_id''' dir' typ_a' _exprIL'?) be pt_a)*

            4. If ((dir' = dir))*, then

              1. Return $gen_cstrs(cstr, typ_p'*, typ_a'*)

      4. Case (% matches pattern `PackageT%%`)

        1. (Let (PackageT _id typ''*) be objtyp)

        2. If ((typ_a''' has type objtyp)), then

          1. (Let objtyp' be (typ_a''' as objtyp))

          2. If ((objtyp' matches pattern `PackageT%%`)), then

            1. (Let (PackageT _id' typ_a'''*) be objtyp')

            2. Return $gen_cstrs(cstr, typ''*, typ_a'''*)

2. If ((typ_a''' has type aliastyp)), then

  1. (Let (DefT _id typ_a') be (typ_a''' as aliastyp))

  2. Return $gen_cstr(cstr, typ'', typ_a')

3. Otherwise

  1. Return cstr

;; ../../../../spec/4h-typing-call.watsup:196.1-196.66
def $gen_cstrs(cstr, typ_p*, typ_a*)

1. If ((|typ_p*| = |typ_a*|)), then

  1. (Let cstr' be $gen_cstr(cstr, typ_p, typ_a))*

  2. Return $merge_cstrs(cstr, cstr'*)

1. Else Phantom#1265

;; ../../../../spec/4h-typing-call.watsup:198.1-198.74
def $gen_cstr_fd(cstr, fd_p, fd_a)

1. (Let (_id _dir typ_p _exprIL?)* be $get_params_funcdef(fd_p))

2. (Let (_id' _dir' typ_a _exprIL'?)* be $get_params_funcdef(fd_a))

3. (Let cstr' be $gen_cstrs(cstr, typ_p*, typ_a*))

4. (Let cstr'' be $gen_cstr(cstr', $get_typ_ret_funcdef(fd_p), $get_typ_ret_funcdef(fd_a)))

5. Return cstr''

;; ../../../../spec/4h-typing-call.watsup:200.1-200.77
def $gen_cstr_fd'(cstr, fid*, fdenv_p, fdenv_a)

1. Case analysis on fid*

  1. Case (% matches pattern [])

    1. Return cstr

  2. Case (% matches pattern _ :: _)

    1. (Let fid_h :: fid_t* be fid*)

    2. (Let funcdef? be $find_map<fid, funcdef>(fdenv_p, fid_h))

    3. If ((funcdef? matches pattern (_))), then

      1. (Let ?(fd_p) be funcdef?)

      2. (Let funcdef'? be $find_map<fid, funcdef>(fdenv_a, fid_h))

      3. If ((funcdef'? matches pattern (_))), then

        1. (Let ?(fd_a) be funcdef'?)

        2. (Let cstr' be $gen_cstr_fd(cstr, fd_p, fd_a))

        3. Return $gen_cstr_fd'(cstr', fid_t*, fdenv_p, fdenv_a)

      3. Else Phantom#1266

    3. Else Phantom#1267

;; ../../../../spec/4h-typing-call.watsup:202.1-202.74
def $merge_cstr(cstr_o, cstr_n)

1. (Let ({ tid_o* }) be $dom_map<tid, typcstr>(cstr_o))

2. If ($eq_set<tid>($dom_map<tid, typcstr>(cstr_o), $dom_map<tid, typcstr>(cstr_n))), then

  1. Return $merge_cstr'(cstr_o, cstr_n, tid_o*, ({ [] }))

2. Else Phantom#1268

;; ../../../../spec/4h-typing-call.watsup:204.1-204.100
def $merge_cstr'(cstr_o, cstr_n, tid*, cstr)

1. Case analysis on tid*

  1. Case (% matches pattern [])

    1. Return cstr

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t* be tid*)

    2. If (($find_map<tid, typcstr>(cstr_o, tid_h) = ?((UNKNOWN)))), then

      1. If (($find_map<tid, typcstr>(cstr_n, tid_h) = ?((UNKNOWN)))), then

        1. (Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (UNKNOWN)))

        2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')

      1. Else Phantom#1269

      2. (Let typcstr'? be $find_map<tid, typcstr>(cstr_n, tid_h))

      3. If ((typcstr'? matches pattern (_))), then

        1. (Let ?(typcstr) be typcstr'?)

        2. If ((typcstr matches pattern `KNOWN%`)), then

          1. (Let (KNOWN typ_n) be typcstr)

          2. (Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (KNOWN typ_n)))

          3. Return $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')

        2. Else Phantom#1270

      3. Else Phantom#1271

    2. Else Phantom#1272

    3. (Let typcstr'? be $find_map<tid, typcstr>(cstr_o, tid_h))

    4. If ((typcstr'? matches pattern (_))), then

      1. (Let ?(typcstr) be typcstr'?)

      2. If ((typcstr matches pattern `KNOWN%`)), then

        1. (Let (KNOWN typ_o) be typcstr)

        2. If (($find_map<tid, typcstr>(cstr_n, tid_h) = ?((UNKNOWN)))), then

          1. (Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (KNOWN typ_o)))

          2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')

        2. Else Phantom#1273

        3. (Let typcstr'''? be $find_map<tid, typcstr>(cstr_n, tid_h))

        4. If ((typcstr'''? matches pattern (_))), then

          1. (Let ?(typcstr'') be typcstr'''?)

          2. If ((typcstr'' matches pattern `KNOWN%`)), then

            1. (Let (KNOWN typ_n) be typcstr'')

            2. Case analysis on (Sub_impl: typ_o << typ_n holds)

              1. Case true

                1. (Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (KNOWN typ_n)))

                2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')

              2. Case false

                1. If ((Sub_impl: typ_n << typ_o holds)), then

                  1. (Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (KNOWN typ_o)))

                  2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')

                1. Else Phantom#1274

          2. Else Phantom#1275

        4. Else Phantom#1276

      2. Else Phantom#1277

    4. Else Phantom#1278

;; ../../../../spec/4h-typing-call.watsup:206.1-206.76
def $merge_cstrs(cstr, map<tid, typcstr>*)

1. Case analysis on map<tid, typcstr>*

  1. Case (% matches pattern [])

    1. Return cstr

  2. Case (% matches pattern _ :: _)

    1. (Let cstr_h :: cstr_t* be map<tid, typcstr>*)

    2. (Let cstr' be $merge_cstr(cstr, cstr_h))

    3. (Let cstr'' be $merge_cstrs(cstr', cstr_t*))

    4. Return cstr''

;; ../../../../spec/4h-typing-call.watsup:208.1-208.54
def $resolve_cstrs(set<pair<tid, typcstr>>')

1. If ((set<pair<tid, typcstr>>' = ({ [] }))), then

  1. Return ({ [] })

1. Else Phantom#1279

2. (Let ({ pair<tid, typcstr>* }) be set<pair<tid, typcstr>>')

3. If ((pair<tid, typcstr>* matches pattern _ :: _)), then

  1. (Let (tid_h -> typcstr) :: (tid_t -> typcstr_t)* be pair<tid, typcstr>*)

  2. If ((typcstr matches pattern `KNOWN%`)), then

    1. (Let (KNOWN typ_h) be typcstr)

    2. (Let typ be typ_h)

    3. If ((typ has type synthtyp)), then

      1. (Let synthtyp be (typ as synthtyp))

      2. If ((synthtyp matches pattern `SeqT%`)), then

        1. (Let (SeqT typ_inner*) be synthtyp)

        2. (Let tparamIL be $gen_tparam(typ_inner))*

        3. (Let typ_inner' be ((VarT tparamIL) as typ))*

        4. (Let typ_h' be ((SpecT (PolyD (tparamIL*, []) -> ((TupleT typ_inner*) as typ)) typ_inner'*) as typ))

        5. (Let ({ (tid_t' -> typ_t')* }) be $resolve_cstrs(({ (tid_t -> typcstr_t)* })))

        6. Return $add_map<tid, typ>(({ (tid_t' -> typ_t')* }), tid_h, typ_h')

      2. Else Phantom#1280

    3. Else Phantom#1281

    4. If ((typ_h =/= ((AnyT) as typ))), then

      1. (Let ({ (tid_t' -> typ_t')* }) be $resolve_cstrs(({ (tid_t -> typcstr_t)* })))

      2. Return $add_map<tid, typ>(({ (tid_t' -> typ_t')* }), tid_h, typ_h)

    4. Else Phantom#1282

  2. Else Phantom#1283

3. Else Phantom#1284

;; ../../../../spec/4h-typing-call.watsup:323.1-323.32
def $gen_tparam(typ)

1. Return $fresh_tid

;; ../../../../spec/4h-typing-call.watsup:343.1-343.56
def $infer_targs(tid*, (id dir typ_p exprIL_deft?)*, typ_a*)

1. (Let cstr be $empty_cstr(tid*))

2. (Let cstr' be $gen_cstrs(cstr, typ_p*, typ_a*))

3. Return $resolve_cstrs(cstr')

;; ../../../../spec/4h-typing-call.watsup:449.1-450.43
def $is_table_apply_in_action_arg(argIL)

1. Return false
