;; ../../../../spec-concrete/0-aux.watsup:18.1-18.21
def $sum



;; ../../../../spec-concrete/0-aux.watsup:20.1-20.21
def $max



;; ../../../../spec-concrete/0-aux.watsup:22.1-22.21
def $min



;; ../../../../spec-concrete/0-aux.watsup:28.1-28.29
def $int_to_text



;; ../../../../spec-concrete/0-aux.watsup:30.1-30.31
def $concat_text(text*)

1. Case analysis on text*

  1. Case (% matches pattern [])

    1. Return ""

  2. Case (% matches pattern _ :: _)

    1. (Let t_h :: t_t* be text*)

    2. Return t_h ++ $concat_text(t_t*)

;; ../../../../spec-concrete/0-aux.watsup:34.1-34.37
def $strip_prefix



;; ../../../../spec-concrete/0-aux.watsup:35.1-35.37
def $strip_suffix



;; ../../../../spec-concrete/0-aux.watsup:41.1-41.23
def $init_(nat')

1. If ((nat' = 0)), then

  1. Return []

2. Otherwise

  1. Return (nat' - 1) :: $init_((nat' - 1))

;; ../../../../spec-concrete/0-aux.watsup:46.1-46.29
def $repeat_<X>(X, nat')

1. If ((nat' = 0)), then

  1. Return []

2. Otherwise

  1. Return [X] ++ $repeat_<X>(X, (nat' - 1))

;; ../../../../spec-concrete/0-aux.watsup:51.1-51.22
def $rev_<X>



;; ../../../../spec-concrete/0-aux.watsup:53.1-53.28
def $concat_<X>



;; ../../../../spec-concrete/0-aux.watsup:55.1-55.39
def $partition_<X>



;; ../../../../spec-concrete/0-aux.watsup:57.1-57.35
def $assoc_<X, Y>



;; ../../../../spec-concrete/0-aux.watsup:59.1-59.29
def $distinct_<K>



;; ../../../../spec-concrete/0-aux.watsup:65.17-65.24
syntax set<K> = 
   | { K* }

;; ../../../../spec-concrete/0-aux.watsup:67.1-67.27
def $empty_set<K>

1. Return ({ [] })

;; ../../../../spec-concrete/0-aux.watsup:70.1-70.33
def $in_set<K>(K, ({ K_e* }))

1. Return K is in K_e*

;; ../../../../spec-concrete/0-aux.watsup:73.1-73.47
def $intersect_set<K>



;; ../../../../spec-concrete/0-aux.watsup:75.1-75.43
def $union_set<K>



;; ../../../../spec-concrete/0-aux.watsup:77.1-77.37
def $unions_set<K>



;; ../../../../spec-concrete/0-aux.watsup:79.1-79.42
def $diff_set<K>



;; ../../../../spec-concrete/0-aux.watsup:81.1-81.39
def $sub_set<K>



;; ../../../../spec-concrete/0-aux.watsup:83.1-83.38
def $eq_set<K>



;; ../../../../spec-concrete/0-aux.watsup:89.21-89.27
syntax pair<K, V> = 
   | K : V

;; ../../../../spec-concrete/0-aux.watsup:91.20-91.35
syntax map<K, V> = set<pair<K, V>>

;; ../../../../spec-concrete/0-aux.watsup:93.1-93.33
def $empty_map<K, V>

1. Return ({ [] })

;; ../../../../spec-concrete/0-aux.watsup:96.1-96.39
def $dom_map<K, V>(({ (K : V)* }))

1. Return ({ K* })

;; ../../../../spec-concrete/0-aux.watsup:99.1-99.39
def $find_map<K, V>



;; ../../../../spec-concrete/0-aux.watsup:101.1-101.41
def $find_maps<K, V>



;; ../../../../spec-concrete/0-aux.watsup:103.1-103.48
def $add_map<K, V>



;; ../../../../spec-concrete/0-aux.watsup:105.1-105.51
def $adds_map<K, V>



;; ../../../../spec-concrete/0-aux.watsup:107.1-107.51
def $update_map<K, V>



;; ../../../../spec-concrete/1-syntax.watsup:6.1-7.7
syntax trailingCommaOpt = 
   | 
   | ,

;; ../../../../spec-concrete/1-syntax.watsup:14.1-15.10
syntax booleanLiteral = 
   | true
   | false

;; ../../../../spec-concrete/1-syntax.watsup:22.1-24.35
syntax numberLiteral = 
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)

;; ../../../../spec-concrete/1-syntax.watsup:30.24-30.57
syntax stringLiteral = 
   | " text " hint(print "#%#")

;; ../../../../spec-concrete/1-syntax.watsup:43.21-43.29
syntax identifier = 
   | text

;; ../../../../spec-concrete/1-syntax.watsup:44.25-44.34
syntax typeIdentifier = 
   | text

;; ../../../../spec-concrete/1-syntax.watsup:51.1-53.30
syntax nonTypeName = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority

;; ../../../../spec-concrete/1-syntax.watsup:56.1-57.23
syntax prefixedNonTypeName = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName

;; ../../../../spec-concrete/1-syntax.watsup:63.19-63.33
syntax typeName = typeIdentifier

;; ../../../../spec-concrete/1-syntax.watsup:66.1-67.21
syntax prefixedTypeName = 
   | text
   | . typeName

;; ../../../../spec-concrete/1-syntax.watsup:74.1-76.36
syntax tableCustomName = 
   | text
   | text
   | apply
   | state
   | type
   | priority

;; ../../../../spec-concrete/1-syntax.watsup:83.1-85.9
syntax name = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list

;; ../../../../spec-concrete/1-syntax.watsup:88.1-89.21
syntax nameList = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list
   | nameList , name

;; ../../../../spec-concrete/1-syntax.watsup:91.1-91.40
def $flatten_nameList(nameList'')

1. If ((nameList'' has type name)), then

  1. (Let name be (nameList'' as name))

  2. Return [name]

2. If ((nameList'' matches pattern `%,%`)), then

  1. (Let (nameList'' , name) be nameList'')

  2. Return $flatten_nameList(nameList'') ++ [name]

;; ../../../../spec-concrete/1-syntax.watsup:96.17-96.21
syntax member = name

;; ../../../../spec-concrete/1-syntax.watsup:102.20-102.45
syntax direction = 
   | 
   | in
   | out
   | inout

;; ../../../../spec-concrete/1-syntax.watsup:115.1-126.32
syntax baseType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>

;; ../../../../spec-concrete/1-syntax.watsup:134.26-134.64
syntax specializedType = 
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:137.1-138.20
syntax namedType = 
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:144.26-144.51
syntax headerStackType = 
   | namedType [ expression ]

;; ../../../../spec-concrete/1-syntax.watsup:152.19-152.41
syntax listType = 
   | list< typeArgument >

;; ../../../../spec-concrete/1-syntax.watsup:158.20-158.47
syntax tupleType = 
   | tuple< typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:165.1-169.14
syntax type = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:172.1-174.15
syntax typeOrVoid = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | text

;; ../../../../spec-concrete/1-syntax.watsup:180.24-180.28
syntax typeParameter = name

;; ../../../../spec-concrete/1-syntax.watsup:183.1-184.39
syntax typeParameterList = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list
   | typeParameterList , typeParameter

;; ../../../../spec-concrete/1-syntax.watsup:186.1-186.67
def $flatten_typeParameterList(typeParameterList'')

1. If ((typeParameterList'' has type typeParameter)), then

  1. (Let typeParameter be (typeParameterList'' as typeParameter))

  2. Return [typeParameter]

2. If ((typeParameterList'' matches pattern `%,%`)), then

  1. (Let (typeParameterList'' , typeParameter) be typeParameterList'')

  2. Return $flatten_typeParameterList(typeParameterList'') ++ [typeParameter]

;; ../../../../spec-concrete/1-syntax.watsup:192.1-193.27
syntax typeParameterListOpt = 
   | 
   | < typeParameterList >

;; ../../../../spec-concrete/1-syntax.watsup:195.1-195.73
def $flatten_typeParameterListOpt(typeParameterListOpt)

1. Case analysis on typeParameterListOpt

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `<%>`)

    1. (Let (< typeParameterList >) be typeParameterListOpt)

    2. Return $flatten_typeParameterList(typeParameterList)

;; ../../../../spec-concrete/1-syntax.watsup:207.3-207.52
syntax parameter = 
   | annotationList direction type name initializerOpt

;; ../../../../spec-concrete/1-syntax.watsup:210.1-211.39
syntax nonEmptyParameterList = 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList , parameter

;; ../../../../spec-concrete/1-syntax.watsup:214.1-215.26
syntax parameterList = 
   | 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList , parameter

;; ../../../../spec-concrete/1-syntax.watsup:217.1-217.55
def $flatten_parameterList(parameterList)

1. If ((parameterList matches pattern ``EMPTY`)), then

  1. Return []

2. If ((parameterList has type parameter)), then

  1. (Let parameter be (parameterList as parameter))

  2. Return [parameter]

3. If ((parameterList has type nonEmptyParameterList)), then

  1. (Let nonEmptyParameterList' be (parameterList as nonEmptyParameterList))

  2. If ((nonEmptyParameterList' matches pattern `%,%`)), then

    1. (Let (nonEmptyParameterList , parameter) be nonEmptyParameterList')

    2. Return $flatten_parameterList((nonEmptyParameterList as parameterList)) ++ [parameter]

;; ../../../../spec-concrete/1-syntax.watsup:227.31-227.40
syntax constructorParameter = parameter

;; ../../../../spec-concrete/1-syntax.watsup:229.35-229.48
syntax constructorParameterList = parameterList

;; ../../../../spec-concrete/1-syntax.watsup:232.1-233.23
syntax constructorParameterListOpt = 
   | 
   | ( parameterList )

;; ../../../../spec-concrete/1-syntax.watsup:235.1-236.26
def $flatten_constructorParameterListOpt(constructorParameterListOpt)

1. Case analysis on constructorParameterListOpt

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `(%)`)

    1. (Let (( parameterList )) be constructorParameterListOpt)

    2. Return $flatten_parameterList(parameterList)

;; ../../../../spec-concrete/1-syntax.watsup:246.26-246.44
syntax namedExpression = 
   | name = expression

;; ../../../../spec-concrete/1-syntax.watsup:249.1-250.43
syntax namedExpressionList = 
   | name = expression
   | namedExpressionList , namedExpression

;; ../../../../spec-concrete/1-syntax.watsup:252.1-252.73
def $flatten_namedExpressionList(namedExpressionList'')

1. If ((namedExpressionList'' has type namedExpression)), then

  1. (Let namedExpression be (namedExpressionList'' as namedExpression))

  2. Return [namedExpression]

2. If ((namedExpressionList'' matches pattern `%,%`)), then

  1. (Let (namedExpressionList'' , namedExpression) be namedExpressionList'')

  2. Return $flatten_namedExpressionList(namedExpressionList'') ++ [namedExpression]

;; ../../../../spec-concrete/1-syntax.watsup:266.1-268.18
syntax literalExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")

;; ../../../../spec-concrete/1-syntax.watsup:275.1-276.9
syntax referenceExpression = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this

;; ../../../../spec-concrete/1-syntax.watsup:282.28-282.32
syntax defaultExpression = 
   | ...

;; ../../../../spec-concrete/1-syntax.watsup:290.15-290.32
syntax unop = 
   | !
   | ~
   | -
   | +

;; ../../../../spec-concrete/1-syntax.watsup:292.26-292.41
syntax unaryExpression = 
   | unop expression

;; ../../../../spec-concrete/1-syntax.watsup:295.1-297.35
syntax binop = 
   | *
   | /
   | %
   | +
   | -
   | |+|
   | |-|
   | <<
   | >>
   | <=
   | >=
   | <
   | >
   | !=
   | ==
   | &
   | ^
   | |
   | ++
   | &&
   | ||

;; ../../../../spec-concrete/1-syntax.watsup:299.27-299.54
syntax binaryExpression = 
   | expression binop expression

;; ../../../../spec-concrete/1-syntax.watsup:302.3-302.38
syntax binaryExpressionNonBrace = 
   | expressionNonBrace binop expression

;; ../../../../spec-concrete/1-syntax.watsup:305.3-305.41
syntax ternaryExpression = 
   | expression ? expression : expression

;; ../../../../spec-concrete/1-syntax.watsup:308.3-308.49
syntax ternaryExpressionNonBrace = 
   | expressionNonBrace ? expression : expression

;; ../../../../spec-concrete/1-syntax.watsup:314.25-314.45
syntax castExpression = 
   | ( type ) expression

;; ../../../../spec-concrete/1-syntax.watsup:323.1-324.48
syntax dataExpression = 
   | {#}
   | { dataElementExpression trailingCommaOpt }

;; ../../../../spec-concrete/1-syntax.watsup:333.3-333.18
syntax errorAccessExpression = 
   | error. member

;; ../../../../spec-concrete/1-syntax.watsup:336.3-336.29
syntax memberAccessExpression = 
   | memberAccessBase . member

;; ../../../../spec-concrete/1-syntax.watsup:339.1-340.45
syntax indexAccessExpression = 
   | expression [ expression ]
   | expression [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:343.1-345.26
syntax accessExpression = 
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:348.3-348.37
syntax memberAccessExpressionNonBrace = 
   | memberAccessBaseNonBrace . member

;; ../../../../spec-concrete/1-syntax.watsup:351.1-352.53
syntax indexAccessExpressionNonBrace = 
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:355.1-357.34
syntax accessExpressionNonBrace = 
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:371.1-372.62
syntax callExpression = 
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )

;; ../../../../spec-concrete/1-syntax.watsup:375.1-376.70
syntax callExpressionNonBrace = 
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )

;; ../../../../spec-concrete/1-syntax.watsup:382.34-382.49
syntax parenthesizedExpression = 
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:389.1-399.28
syntax expression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:403.1-405.33
syntax expressionList = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expressionList , expression

;; ../../../../spec-concrete/1-syntax.watsup:407.1-407.58
def $flatten_expressionList(expressionList'')

1. Case analysis on expressionList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%,%`)

    1. (Let (expressionList'' , expression) be expressionList'')

    2. Return $flatten_expressionList(expressionList'') ++ [expression]

2. If ((expressionList'' has type expression)), then

  1. (Let expression be (expressionList'' as expression))

  2. Return [expression]

;; ../../../../spec-concrete/1-syntax.watsup:414.1-415.15
syntax memberAccessBase = 
   | text
   | . typeName
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:417.36-417.50
syntax sequenceElementExpression = expressionList

;; ../../../../spec-concrete/1-syntax.watsup:420.1-423.54
syntax recordElementExpression = 
   | name = expression
   | name = expression ,...
   | name = expression , namedExpressionList
   | name = expression , namedExpressionList ,...

;; ../../../../spec-concrete/1-syntax.watsup:426.1-427.28
syntax dataElementExpression = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expressionList , expression
   | name = expression
   | name = expression ,...
   | name = expression , namedExpressionList
   | name = expression , namedExpressionList ,...

;; ../../../../spec-concrete/1-syntax.watsup:429.24-429.34
syntax routineTarget = expression

;; ../../../../spec-concrete/1-syntax.watsup:430.28-430.37
syntax constructorTarget = namedType

;; ../../../../spec-concrete/1-syntax.watsup:433.1-434.22
syntax callTarget = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:441.1-449.28
syntax expressionNonBrace = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:452.1-453.23
syntax memberAccessBaseNonBrace = 
   | text
   | . typeName
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:455.32-455.50
syntax routineTargetNonBrace = expressionNonBrace

;; ../../../../spec-concrete/1-syntax.watsup:458.1-459.22
syntax callTargetNonBrace = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:461.1-461.57
def $expressionNonBrace(expressionNonBrace'')

1. Case analysis on expressionNonBrace''

  1. Case (% has type literalExpression)

    1. (Let literalExpression be (expressionNonBrace'' as literalExpression))

    2. Return (literalExpression as expression)

  2. Case (% has type referenceExpression)

    1. (Let referenceExpression be (expressionNonBrace'' as referenceExpression))

    2. Return (referenceExpression as expression)

  3. Case (% has type unaryExpression)

    1. (Let unaryExpression be (expressionNonBrace'' as unaryExpression))

    2. Return (unaryExpression as expression)

  4. Case (% has type binaryExpressionNonBrace)

    1. (Let (expressionNonBrace_l binop expression_r) be (expressionNonBrace'' as binaryExpressionNonBrace))

    2. (Let expression_l be $expressionNonBrace(expressionNonBrace_l))

    3. Return ((expression_l binop expression_r) as expression)

  5. Case (% has type ternaryExpressionNonBrace)

    1. (Let (expressionNonBrace_cond ? expression_true : expression_false) be (expressionNonBrace'' as ternaryExpressionNonBrace))

    2. (Let expression_cond be $expressionNonBrace(expressionNonBrace_cond))

    3. Return ((expression_cond ? expression_true : expression_false) as expression)

  6. Case (% has type castExpression)

    1. (Let castExpression be (expressionNonBrace'' as castExpression))

    2. Return (castExpression as expression)

  7. Case (% has type errorAccessExpression)

    1. (Let errorAccessExpression be (expressionNonBrace'' as errorAccessExpression))

    2. Return (errorAccessExpression as expression)

  8. Case (% has type memberAccessExpressionNonBrace)

    1. (Let (memberAccessBaseNonBrace . member) be (expressionNonBrace'' as memberAccessExpressionNonBrace))

    2. Case analysis on memberAccessBaseNonBrace

      1. Case (% has type prefixedTypeName)

        1. (Let prefixedTypeName be (memberAccessBaseNonBrace as prefixedTypeName))

        2. Return (((prefixedTypeName as memberAccessBase) . member) as expression)

      2. Case (% has type expressionNonBrace)

        1. (Let expressionNonBrace_base be (memberAccessBaseNonBrace as expressionNonBrace))

        2. (Let expression_base be $expressionNonBrace(expressionNonBrace_base))

        3. Return (((expression_base as memberAccessBase) . member) as expression)

  9. Case (% has type indexAccessExpressionNonBrace)

    1. (Let indexAccessExpressionNonBrace be (expressionNonBrace'' as indexAccessExpressionNonBrace))

    2. Case analysis on indexAccessExpressionNonBrace

      1. Case (% matches pattern `%[%]`)

        1. (Let (expressionNonBrace_base [ expression_index ]) be indexAccessExpressionNonBrace)

        2. (Let expression_base be $expressionNonBrace(expressionNonBrace_base))

        3. Return ((expression_base [ expression_index ]) as expression)

      2. Case (% matches pattern `%[%:%]`)

        1. (Let (expressionNonBrace_base [ expression_hi : expression_lo ]) be indexAccessExpressionNonBrace)

        2. (Let expression_base be $expressionNonBrace(expressionNonBrace_base))

        3. Return ((expression_base [ expression_hi : expression_lo ]) as expression)

  10. Case (% has type callExpressionNonBrace)

    1. (Let callExpressionNonBrace be (expressionNonBrace'' as callExpressionNonBrace))

    2. Case analysis on callExpressionNonBrace

      1. Case (% matches pattern `%(%)`)

        1. (Let (callTargetNonBrace ( argumentList )) be callExpressionNonBrace)

        2. Case analysis on callTargetNonBrace

          1. Case (% has type expressionNonBrace)

            1. (Let expressionNonBrace'' be (callTargetNonBrace as expressionNonBrace))

            2. (Let expression be $expressionNonBrace(expressionNonBrace''))

            3. Return (((expression as callTarget) ( argumentList )) as expression)

          2. Case (% has type constructorTarget)

            1. (Let constructorTarget be (callTargetNonBrace as constructorTarget))

            2. Return (((constructorTarget as callTarget) ( argumentList )) as expression)

      2. Case (% matches pattern `%<%>(%)`)

        1. (Let (expressionNonBrace'' < realTypeArgumentList >( argumentList )) be callExpressionNonBrace)

        2. (Let expression be $expressionNonBrace(expressionNonBrace''))

        3. Return ((expression < realTypeArgumentList >( argumentList )) as expression)

  11. Case (% has type parenthesizedExpression)

    1. (Let parenthesizedExpression be (expressionNonBrace'' as parenthesizedExpression))

    2. Return (parenthesizedExpression as expression)

;; ../../../../spec-concrete/1-syntax.watsup:513.1-517.7
syntax simpleKeysetExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _

;; ../../../../spec-concrete/1-syntax.watsup:520.1-521.57
syntax simpleKeysetExpressionList = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _
   | simpleKeysetExpressionList , simpleKeysetExpression

;; ../../../../spec-concrete/1-syntax.watsup:523.1-524.28
def $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList'')

1. If ((simpleKeysetExpressionList'' has type simpleKeysetExpression)), then

  1. (Let simpleKeysetExpression be (simpleKeysetExpressionList'' as simpleKeysetExpression))

  2. Return [simpleKeysetExpression]

2. If ((simpleKeysetExpressionList'' matches pattern `%,%`)), then

  1. (Let (simpleKeysetExpressionList'' , simpleKeysetExpression) be simpleKeysetExpressionList'')

  2. Return $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList'') ++ [simpleKeysetExpression]

;; ../../../../spec-concrete/1-syntax.watsup:534.1-538.62
syntax tupleKeysetExpression = 
   | ( expression &&& expression )
   | ( expression .. expression )
   | (default)
   | (_)
   | ( simpleKeysetExpression , simpleKeysetExpressionList )

;; ../../../../spec-concrete/1-syntax.watsup:541.1-542.26
syntax keysetExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _
   | ( expression &&& expression )
   | ( expression .. expression )
   | (default)
   | (_)
   | ( simpleKeysetExpression , simpleKeysetExpressionList )

;; ../../../../spec-concrete/1-syntax.watsup:549.1-551.7
syntax realTypeArgument = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _

;; ../../../../spec-concrete/1-syntax.watsup:554.1-555.45
syntax realTypeArgumentList = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | realTypeArgumentList , realTypeArgument

;; ../../../../spec-concrete/1-syntax.watsup:557.1-557.76
def $flatten_realTypeArgumentList(realTypeArgumentList'')

1. If ((realTypeArgumentList'' has type realTypeArgument)), then

  1. (Let realTypeArgument be (realTypeArgumentList'' as realTypeArgument))

  2. Return [realTypeArgument]

2. If ((realTypeArgumentList'' matches pattern `%,%`)), then

  1. (Let (realTypeArgumentList'' , realTypeArgument) be realTypeArgumentList'')

  2. Return $flatten_realTypeArgumentList(realTypeArgumentList'') ++ [realTypeArgument]

;; ../../../../spec-concrete/1-syntax.watsup:563.1-564.16
syntax typeArgument = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority

;; ../../../../spec-concrete/1-syntax.watsup:568.1-570.37
syntax typeArgumentList = 
   | 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | typeArgumentList , typeArgument

;; ../../../../spec-concrete/1-syntax.watsup:572.1-572.64
def $flatten_typeArgumentList(typeArgumentList'')

1. Case analysis on typeArgumentList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%,%`)

    1. (Let (typeArgumentList'' , typeArgument) be typeArgumentList'')

    2. Return $flatten_typeArgumentList(typeArgumentList'') ++ [typeArgument]

2. If ((typeArgumentList'' has type typeArgument)), then

  1. (Let typeArgument be (typeArgumentList'' as typeArgument))

  2. Return [typeArgument]

;; ../../../../spec-concrete/1-syntax.watsup:583.1-586.7
syntax argument = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _

;; ../../../../spec-concrete/1-syntax.watsup:589.1-590.37
syntax argumentListNonEmpty = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _
   | argumentListNonEmpty , argument

;; ../../../../spec-concrete/1-syntax.watsup:593.1-594.25
syntax argumentList = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _
   | argumentListNonEmpty , argument

;; ../../../../spec-concrete/1-syntax.watsup:596.1-596.52
def $flatten_argumentList(argumentList)

1. If ((argumentList matches pattern ``EMPTY`)), then

  1. Return []

2. If ((argumentList has type argument)), then

  1. (Let argument be (argumentList as argument))

  2. Return [argument]

3. If ((argumentList has type argumentListNonEmpty)), then

  1. (Let argumentListNonEmpty' be (argumentList as argumentListNonEmpty))

  2. If ((argumentListNonEmpty' matches pattern `%,%`)), then

    1. (Let (argumentListNonEmpty , argument) be argumentListNonEmpty')

    2. Return $flatten_argumentList((argumentListNonEmpty as argumentList)) ++ [argument]

;; ../../../../spec-concrete/1-syntax.watsup:607.1-611.16
syntax lvalue = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | lvalue . member
   | lvalue [ expression ]
   | lvalue [ expression : expression ]
   | ( lvalue )

;; ../../../../spec-concrete/1-syntax.watsup:621.25-621.27
syntax emptyStatement = 
   | ;

;; ../../../../spec-concrete/1-syntax.watsup:628.1-630.34
syntax assignop = 
   | =
   | +=
   | -=
   | |+|=
   | |-|=
   | *=
   | /=
   | %=
   | <<=
   | >>=
   | &=
   | ^=
   | |=

;; ../../../../spec-concrete/1-syntax.watsup:632.30-632.59
syntax assignmentStatement = 
   | lvalue assignop expression ;

;; ../../../../spec-concrete/1-syntax.watsup:639.1-640.54
syntax callStatement = 
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );

;; ../../../../spec-concrete/1-syntax.watsup:646.37-646.76
syntax directApplicationStatement = 
   | namedType .apply( argumentList );

;; ../../../../spec-concrete/1-syntax.watsup:653.1-654.25
syntax returnStatement = 
   | return;
   | return expression ;

;; ../../../../spec-concrete/1-syntax.watsup:660.24-660.31
syntax exitStatement = 
   | exit;

;; ../../../../spec-concrete/1-syntax.watsup:668.25-668.70
syntax blockStatement = 
   | annotationList { blockElementStatementList }

;; ../../../../spec-concrete/1-syntax.watsup:677.1-678.48
syntax conditionalStatement = 
   | if( expression ) statement
   | if( expression ) statement else statement

;; ../../../../spec-concrete/1-syntax.watsup:687.1-690.31
syntax forInitStatement = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression

;; ../../../../spec-concrete/1-syntax.watsup:693.1-694.53
syntax forInitStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forInitStatementListNonEmpty , forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:697.1-698.33
syntax forInitStatementList = 
   | 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forInitStatementListNonEmpty , forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:700.29-700.45
syntax forUpdateStatement = forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:703.1-704.57
syntax forUpdateStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty , forUpdateStatement

;; ../../../../spec-concrete/1-syntax.watsup:707.1-708.35
syntax forUpdateStatementList = 
   | 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty , forUpdateStatement

;; ../../../../spec-concrete/1-syntax.watsup:711.1-712.30
syntax forCollectionExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression .. expression

;; ../../../../spec-concrete/1-syntax.watsup:715.1-720.81
syntax forStatement = 
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement

;; ../../../../spec-concrete/1-syntax.watsup:727.1-728.23
syntax switchLabel = 
   | default
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:731.1-732.19
syntax switchCase = 
   | switchLabel : blockStatement
   | switchLabel :

;; ../../../../spec-concrete/1-syntax.watsup:735.1-736.30
syntax switchCaseList = 
   | 
   | switchCaseList switchCase

;; ../../../../spec-concrete/1-syntax.watsup:738.1-738.58
def $flatten_switchCaseList(switchCaseList'')

1. Case analysis on switchCaseList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (switchCaseList'' switchCase) be switchCaseList'')

    2. Return $flatten_switchCaseList(switchCaseList'') ++ [switchCase]

;; ../../../../spec-concrete/1-syntax.watsup:743.26-743.68
syntax switchStatement = 
   | switch( expression ){ switchCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:749.25-749.33
syntax breakStatement = 
   | break;

;; ../../../../spec-concrete/1-syntax.watsup:751.28-751.39
syntax continueStatement = 
   | continue;

;; ../../../../spec-concrete/1-syntax.watsup:758.1-769.20
syntax statement = 
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | return;
   | return expression ;
   | exit;
   | annotationList { blockElementStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement
   | break;
   | continue;
   | switch( expression ){ switchCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:779.22-779.35
syntax initializer = 
   | = expression

;; ../../../../spec-concrete/1-syntax.watsup:782.3-782.48
syntax constantDeclaration = 
   | annotationList const type name initializer ;

;; ../../../../spec-concrete/1-syntax.watsup:785.1-786.16
syntax initializerOpt = 
   | 
   | = expression

;; ../../../../spec-concrete/1-syntax.watsup:789.3-789.45
syntax variableDeclaration = 
   | annotationList type name initializerOpt ;

;; ../../../../spec-concrete/1-syntax.watsup:792.1-794.14
syntax blockElementStatement = 
   | annotationList const type name initializer ;
   | annotationList type name initializerOpt ;
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | return;
   | return expression ;
   | exit;
   | annotationList { blockElementStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement
   | break;
   | continue;
   | switch( expression ){ switchCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:797.1-798.52
syntax blockElementStatementList = 
   | 
   | blockElementStatementList blockElementStatement

;; ../../../../spec-concrete/1-syntax.watsup:800.1-801.27
def $flatten_blockElementStatementList(blockElementStatementList'')

1. Case analysis on blockElementStatementList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (blockElementStatementList'' blockElementStatement) be blockElementStatementList'')

    2. Return $flatten_blockElementStatementList(blockElementStatementList'') ++ [blockElementStatement]

;; ../../../../spec-concrete/1-syntax.watsup:814.3-814.58
syntax functionPrototype = 
   | typeOrVoid name typeParameterListOpt ( parameterList )

;; ../../../../spec-concrete/1-syntax.watsup:817.3-817.50
syntax functionDeclaration = 
   | annotationList functionPrototype blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:824.3-824.63
syntax actionDeclaration = 
   | annotationList action name ( parameterList ) blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:832.28-832.57
syntax objectInitializer = 
   | ={ objectDeclarationList }

;; ../../../../spec-concrete/1-syntax.watsup:836.1-837.68
syntax instantiation = 
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;

;; ../../../../spec-concrete/1-syntax.watsup:840.1-841.18
syntax objectDeclaration = 
   | annotationList functionPrototype blockStatement
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;

;; ../../../../spec-concrete/1-syntax.watsup:844.1-845.44
syntax objectDeclarationList = 
   | 
   | objectDeclarationList objectDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:847.1-847.79
def $flatten_objectDeclarationList(objectDeclarationList'')

1. Case analysis on objectDeclarationList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (objectDeclarationList'' objectDeclaration) be objectDeclarationList'')

    2. Return $flatten_objectDeclarationList(objectDeclarationList'') ++ [objectDeclaration]

;; ../../../../spec-concrete/1-syntax.watsup:859.27-859.46
syntax errorDeclaration = 
   | error{ nameList }

;; ../../../../spec-concrete/1-syntax.watsup:865.31-865.72
syntax matchKindDeclaration = 
   | match_kind{ nameList trailingCommaOpt }

;; ../../../../spec-concrete/1-syntax.watsup:876.1-877.76
syntax enumTypeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }

;; ../../../../spec-concrete/1-syntax.watsup:883.20-883.47
syntax typeField = 
   | annotationList type name ;

;; ../../../../spec-concrete/1-syntax.watsup:886.1-887.28
syntax typeFieldList = 
   | 
   | typeFieldList typeField

;; ../../../../spec-concrete/1-syntax.watsup:889.1-889.55
def $flatten_typeFieldList(typeFieldList'')

1. Case analysis on typeFieldList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (typeFieldList'' typeField) be typeFieldList'')

    2. Return $flatten_typeFieldList(typeFieldList'') ++ [typeField]

;; ../../../../spec-concrete/1-syntax.watsup:895.3-895.69
syntax structTypeDeclaration = 
   | annotationList struct name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:898.3-898.69
syntax headerTypeDeclaration = 
   | annotationList header name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:901.3-901.75
syntax headerUnionTypeDeclaration = 
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:904.1-907.31
syntax derivedTypeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:914.1-915.27
syntax typedefType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:918.1-919.37
syntax typedefDeclaration = 
   | annotationList typedef typedefType name ;
   | annotationList type type name ;

;; ../../../../spec-concrete/1-syntax.watsup:926.3-926.45
syntax externFunctionDeclaration = 
   | annotationList extern functionPrototype ;

;; ../../../../spec-concrete/1-syntax.watsup:929.1-931.49
syntax methodPrototype = 
   | annotationList typeIdentifier ( parameterList );
   | annotationList functionPrototype ;
   | annotationList abstract functionPrototype ;

;; ../../../../spec-concrete/1-syntax.watsup:934.1-935.40
syntax methodPrototypeList = 
   | 
   | methodPrototypeList methodPrototype

;; ../../../../spec-concrete/1-syntax.watsup:937.1-937.73
def $flatten_methodPrototypeList(methodPrototypeList'')

1. Case analysis on methodPrototypeList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (methodPrototypeList'' methodPrototype) be methodPrototypeList'')

    2. Return $flatten_methodPrototypeList(methodPrototypeList'') ++ [methodPrototype]

;; ../../../../spec-concrete/1-syntax.watsup:945.3-945.82
syntax externObjectDeclaration = 
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }

;; ../../../../spec-concrete/1-syntax.watsup:948.1-949.28
syntax externDeclaration = 
   | annotationList extern functionPrototype ;
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }

;; ../../../../spec-concrete/1-syntax.watsup:959.21-959.48
syntax selectCase = 
   | keysetExpression : name ;

;; ../../../../spec-concrete/1-syntax.watsup:962.1-963.30
syntax selectCaseList = 
   | 
   | selectCaseList selectCase

;; ../../../../spec-concrete/1-syntax.watsup:965.1-965.58
def $flatten_selectCaseList(selectCaseList'')

1. Case analysis on selectCaseList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (selectCaseList'' selectCase) be selectCaseList'')

    2. Return $flatten_selectCaseList(selectCaseList'') ++ [selectCase]

;; ../../../../spec-concrete/1-syntax.watsup:970.27-970.73
syntax selectExpression = 
   | select( expressionList ){ selectCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:977.1-978.21
syntax stateExpression = 
   | name ;
   | select( expressionList ){ selectCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:981.1-982.31
syntax transitionStatement = 
   | 
   | transition stateExpression

;; ../../../../spec-concrete/1-syntax.watsup:989.1-991.21
syntax valueSetType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | tuple< typeArgumentList >
   | text
   | . typeName

;; ../../../../spec-concrete/1-syntax.watsup:994.3-994.69
syntax valueSetDeclaration = 
   | annotationList value_set< valueSetType >( expression ) name ;

;; ../../../../spec-concrete/1-syntax.watsup:1001.3-1001.72
syntax parserTypeDeclaration = 
   | annotationList parser name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1009.31-1009.70
syntax parserBlockStatement = 
   | annotationList { parserStatementList }

;; ../../../../spec-concrete/1-syntax.watsup:1012.1-1019.25
syntax parserStatement = 
   | annotationList const type name initializer ;
   | annotationList type name initializerOpt ;
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | annotationList { parserStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement

;; ../../../../spec-concrete/1-syntax.watsup:1022.1-1023.40
syntax parserStatementList = 
   | 
   | parserStatementList parserStatement

;; ../../../../spec-concrete/1-syntax.watsup:1025.1-1025.73
def $flatten_parserStatementList(parserStatementList'')

1. Case analysis on parserStatementList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (parserStatementList'' parserStatement) be parserStatementList'')

    2. Return $flatten_parserStatementList(parserStatementList'') ++ [parserStatement]

;; ../../../../spec-concrete/1-syntax.watsup:1031.3-1031.73
syntax parserState = 
   | annotationList state name { parserStatementList transitionStatement }

;; ../../../../spec-concrete/1-syntax.watsup:1034.1-1035.32
syntax parserStateList = 
   | annotationList state name { parserStatementList transitionStatement }
   | parserStateList parserState

;; ../../../../spec-concrete/1-syntax.watsup:1037.1-1037.61
def $flatten_parserStateList(parserStateList'')

1. If ((parserStateList'' has type parserState)), then

  1. (Let parserState be (parserStateList'' as parserState))

  2. Return [parserState]

2. If ((parserStateList'' matches pattern `%%`)), then

  1. (Let (parserStateList'' parserState) be parserStateList'')

  2. Return $flatten_parserStateList(parserStateList'') ++ [parserState]

;; ../../../../spec-concrete/1-syntax.watsup:1043.1-1046.24
syntax parserLocalDeclaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList type name initializerOpt ;
   | annotationList value_set< valueSetType >( expression ) name ;

;; ../../../../spec-concrete/1-syntax.watsup:1049.1-1050.54
syntax parserLocalDeclarationList = 
   | 
   | parserLocalDeclarationList parserLocalDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:1052.1-1053.28
def $flatten_parserLocalDeclarationList(parserLocalDeclarationList'')

1. Case analysis on parserLocalDeclarationList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (parserLocalDeclarationList'' parserLocalDeclaration) be parserLocalDeclarationList'')

    2. Return $flatten_parserLocalDeclarationList(parserLocalDeclarationList'') ++ [parserLocalDeclaration]

;; ../../../../spec-concrete/1-syntax.watsup:1062.3-1064.52
syntax parserDeclaration = 
   | annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }

;; ../../../../spec-concrete/1-syntax.watsup:1074.16-1074.21
syntax const = 
   | const

;; ../../../../spec-concrete/1-syntax.watsup:1077.1-1078.10
syntax constOpt = 
   | 
   | const

;; ../../../../spec-concrete/1-syntax.watsup:1080.1-1080.41
def $flatten_constOpt(constOpt)

1. If ((constOpt matches pattern ``EMPTY`)), then

  1. Return ?()

2. If ((constOpt has type const)), then

  1. (Let const be (constOpt as const))

  2. Return ?(const)

;; ../../../../spec-concrete/1-syntax.watsup:1088.19-1088.55
syntax tableKey = 
   | expression : name annotationList ;

;; ../../../../spec-concrete/1-syntax.watsup:1091.1-1092.26
syntax tableKeyList = 
   | 
   | tableKeyList tableKey

;; ../../../../spec-concrete/1-syntax.watsup:1094.1-1094.52
def $flatten_tableKeyList(tableKeyList'')

1. Case analysis on tableKeyList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (tableKeyList'' tableKey) be tableKeyList'')

    2. Return $flatten_tableKeyList(tableKeyList'') ++ [tableKey]

;; ../../../../spec-concrete/1-syntax.watsup:1104.1-1105.42
syntax tableActionReference = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | prefixedNonTypeName ( argumentList )

;; ../../../../spec-concrete/1-syntax.watsup:1107.22-1107.60
syntax tableAction = 
   | annotationList tableActionReference ;

;; ../../../../spec-concrete/1-syntax.watsup:1110.1-1111.32
syntax tableActionList = 
   | 
   | tableActionList tableAction

;; ../../../../spec-concrete/1-syntax.watsup:1113.1-1113.61
def $flatten_tableActionList(tableActionList'')

1. Case analysis on tableActionList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (tableActionList'' tableAction) be tableActionList'')

    2. Return $flatten_tableActionList(tableActionList'') ++ [tableAction]

;; ../../../../spec-concrete/1-syntax.watsup:1123.1-1124.35
syntax tableEntryPriority = 
   | priority= numberLiteral :
   | priority=( expression ):

;; ../../../../spec-concrete/1-syntax.watsup:1127.1-1128.72
syntax tableEntry = 
   | constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ;
   | constOpt keysetExpression : tableActionReference annotationList ;

;; ../../../../spec-concrete/1-syntax.watsup:1131.1-1132.30
syntax tableEntryList = 
   | 
   | tableEntryList tableEntry

;; ../../../../spec-concrete/1-syntax.watsup:1134.1-1134.58
def $flatten_tableEntryList(tableEntryList'')

1. Case analysis on tableEntryList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (tableEntryList'' tableEntry) be tableEntryList'')

    2. Return $flatten_tableEntryList(tableEntryList'') ++ [tableEntry]

;; ../../../../spec-concrete/1-syntax.watsup:1144.1-1147.59
syntax tableProperty = 
   | key={ tableKeyList }
   | actions={ tableActionList }
   | annotationList constOpt entries={ tableEntryList }
   | annotationList constOpt tableCustomName initializer ;

;; ../../../../spec-concrete/1-syntax.watsup:1150.1-1151.36
syntax tablePropertyList = 
   | 
   | tablePropertyList tableProperty

;; ../../../../spec-concrete/1-syntax.watsup:1153.1-1153.67
def $flatten_tablePropertyList(tablePropertyList'')

1. Case analysis on tablePropertyList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (tablePropertyList'' tableProperty) be tablePropertyList'')

    2. Return $flatten_tablePropertyList(tablePropertyList'') ++ [tableProperty]

;; ../../../../spec-concrete/1-syntax.watsup:1159.3-1159.51
syntax tableDeclaration = 
   | annotationList table name { tablePropertyList }

;; ../../../../spec-concrete/1-syntax.watsup:1166.3-1166.73
syntax controlTypeDeclaration = 
   | annotationList control name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1172.22-1172.36
syntax controlBody = blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:1175.1-1179.21
syntax controlLocalDeclaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList type name initializerOpt ;
   | annotationList action name ( parameterList ) blockStatement
   | annotationList table name { tablePropertyList }

;; ../../../../spec-concrete/1-syntax.watsup:1182.1-1183.56
syntax controlLocalDeclarationList = 
   | 
   | controlLocalDeclarationList controlLocalDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:1185.1-1186.29
def $flatten_controlLocalDeclarationList(controlLocalDeclarationList'')

1. Case analysis on controlLocalDeclarationList''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (controlLocalDeclarationList'' controlLocalDeclaration) be controlLocalDeclarationList'')

    2. Return $flatten_controlLocalDeclarationList(controlLocalDeclarationList'') ++ [controlLocalDeclaration]

;; ../../../../spec-concrete/1-syntax.watsup:1196.3-1198.55
syntax controlDeclaration = 
   | annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }

;; ../../../../spec-concrete/1-syntax.watsup:1205.3-1205.73
syntax packageTypeDeclaration = 
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1212.1-1216.27
syntax typeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }
   | annotationList typedef typedefType name ;
   | annotationList type type name ;
   | annotationList parser name typeParameterListOpt ( parameterList );
   | annotationList control name typeParameterListOpt ( parameterList );
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1223.1-1232.20
syntax declaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList functionPrototype blockStatement
   | annotationList action name ( parameterList ) blockStatement
   | error{ nameList }
   | match_kind{ nameList trailingCommaOpt }
   | annotationList extern functionPrototype ;
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }
   | annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }
   | annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }
   | annotationList typedef typedefType name ;
   | annotationList type type name ;
   | annotationList parser name typeParameterListOpt ( parameterList );
   | annotationList control name typeParameterListOpt ( parameterList );
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1239.1-1256.27
syntax annotationToken = 
   | unexpected_token
   | abstract
   | action
   | actions
   | apply
   | bool
   | bit
   | break
   | const
   | continue
   | control
   | default
   | else
   | entries
   | enum
   | error
   | exit
   | extern
   | false
   | for
   | header
   | header_union
   | if
   | in
   | inout
   | int
   | key
   | match_kind
   | type
   | out
   | parser
   | package
   | pragma
   | return
   | select
   | state
   | string
   | struct
   | switch
   | table
   | this
   | transition
   | true
   | tuple
   | typedef
   | varbit
   | value_set
   | list
   | void
   | _
   | text
   | text
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | &&&
   | ..
   | <<
   | &&
   | ||
   | ==
   | !=
   | >=
   | <=
   | ++
   | +
   | |+|
   | -
   | |-|
   | *
   | /
   | %
   | |
   | &
   | ^
   | ~
   | [
   | ]
   | {
   | }
   | <
   | >
   | !
   | :
   | ,
   | ?
   | .
   | =
   | ;
   | @

;; ../../../../spec-concrete/1-syntax.watsup:1259.1-1261.35
syntax annotationBody = 
   | 
   | annotationBody ( annotationBody )
   | annotationBody annotationToken

;; ../../../../spec-concrete/1-syntax.watsup:1264.3-1264.41
syntax structuredAnnotationBody = 
   | dataElementExpression trailingCommaOpt

;; ../../../../spec-concrete/1-syntax.watsup:1267.1-1269.42
syntax annotation = 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]

;; ../../../../spec-concrete/1-syntax.watsup:1272.1-1273.38
syntax annotationListNonEmpty = 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]
   | annotationListNonEmpty annotation

;; ../../../../spec-concrete/1-syntax.watsup:1276.1-1277.27
syntax annotationList = 
   | 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]
   | annotationListNonEmpty annotation

;; ../../../../spec-concrete/1-syntax.watsup:1284.1-1286.17
syntax p4program = 
   | 
   | p4program declaration
   | p4program ;

;; ../../../../spec-concrete/1-syntax.watsup:1288.1-1288.49
def $flatten_p4program(p4program'')

1. Case analysis on p4program''

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `%%`)

    1. (Let (p4program'' declaration) be p4program'')

    2. Return $flatten_p4program(p4program'') ++ [declaration]

  3. Case (% matches pattern `%;`)

    1. (Let (p4program'' ;) be p4program'')

    2. Return $flatten_p4program(p4program'')

;; ../../../../spec-concrete/2.0-domain.watsup:5.17-5.21
syntax nameIR = text

;; ../../../../spec-concrete/2.0-domain.watsup:7.1-7.25
def $name(name)

1. Case analysis on name

  1. Case (% has type identifier)

    1. (Let (t) be (name as identifier))

    2. Return t

  2. Case (% has type typeIdentifier)

    1. (Let (t) be (name as typeIdentifier))

    2. Return t

2. If ((name = ((apply) as name))), then

  1. Return "apply"

3. If ((name = ((key) as name))), then

  1. Return "key"

4. If ((name = ((actions) as name))), then

  1. Return "actions"

5. If ((name = ((state) as name))), then

  1. Return "state"

6. If ((name = ((entries) as name))), then

  1. Return "entries"

7. If ((name = ((type) as name))), then

  1. Return "type"

8. If ((name = ((priority) as name))), then

  1. Return "priority"

9. If ((name matches pattern `LIST`)), then

  1. Return "list"

;; ../../../../spec-concrete/2.0-domain.watsup:20.1-20.47
def $tableCustomName(tableCustomName)

1. Case analysis on tableCustomName

  1. Case (% has type identifier)

    1. (Let (t) be (tableCustomName as identifier))

    2. Return t

  2. Case (% has type typeIdentifier)

    1. (Let (t) be (tableCustomName as typeIdentifier))

    2. Return t

2. Case analysis on tableCustomName

  1. Case (% matches pattern `APPLY`)

    1. Return "apply"

  2. Case (% matches pattern `STATE`)

    1. Return "state"

  3. Case (% matches pattern `TYPE`)

    1. Return "type"

  4. Case (% matches pattern `PRIORITY`)

    1. Return "priority"

;; ../../../../spec-concrete/2.0-domain.watsup:33.13-33.17
syntax id = text

;; ../../../../spec-concrete/2.0-domain.watsup:39.14-39.16
syntax tid = id

;; ../../../../spec-concrete/2.0-domain.watsup:41.1-41.23
def $fresh_tid



;; ../../../../spec-concrete/2.0-domain.watsup:42.1-42.28
def $fresh_tids(nat')

1. If ((nat' = 0)), then

  1. Return []

2. Otherwise

  1. Return $fresh_tid :: $fresh_tids((nat' - 1))

;; ../../../../spec-concrete/2.0-domain.watsup:56.14-56.24
syntax pid = 
   | id # bool

;; ../../../../spec-concrete/2.0-domain.watsup:57.14-57.26
syntax rid = 
   | id ( pid* )

;; ../../../../spec-concrete/2.0-domain.watsup:59.1-59.36
def $rid(name, parameterList)

1. Return ($name(name) ( $pids(parameterList) ))

;; ../../../../spec-concrete/2.0-domain.watsup:60.1-60.32
def $pids(parameterList)

1. If ((parameterList matches pattern ``EMPTY`)), then

  1. Return []

2. If ((parameterList has type parameter)), then

  1. (Let parameter be (parameterList as parameter))

  2. Return [$pid(parameter)]

3. If ((parameterList has type nonEmptyParameterList)), then

  1. (Let nonEmptyParameterList' be (parameterList as nonEmptyParameterList))

  2. If ((nonEmptyParameterList' matches pattern `%,%`)), then

    1. (Let (nonEmptyParameterList , parameter) be nonEmptyParameterList')

    2. Return $pids((nonEmptyParameterList as parameterList)) ++ [$pid(parameter)]

;; ../../../../spec-concrete/2.0-domain.watsup:61.1-61.26
def $pid((_annotationList _direction _type name initializerOpt))

1. If ((initializerOpt matches pattern ``EMPTY`)), then

  1. Return ($name(name) # false)

2. If ((initializerOpt has type initializer)), then

  1. (Let initializer be (initializerOpt as initializer))

  2. Return ($name(name) # true)

;; ../../../../spec-concrete/2.0-domain.watsup:78.14-78.17
syntax cid = rid

;; ../../../../spec-concrete/2.0-domain.watsup:80.1-80.50
def $cid(name, constructorParameterListOpt)

1. Case analysis on constructorParameterListOpt

  1. Case (% matches pattern ``EMPTY`)

    1. Return ($name(name) ( [] ))

  2. Case (% matches pattern `(%)`)

    1. (Let (( parameterList )) be constructorParameterListOpt)

    2. Return ($name(name) ( $pids(parameterList) ))

;; ../../../../spec-concrete/2.0-domain.watsup:88.1-88.48
def $expression_as_lvalue(expression'')

1. Case analysis on expression''

  1. Case (% has type referenceExpression)

    1. (Let referenceExpression be (expression'' as referenceExpression))

    2. Return ?((referenceExpression as lvalue))

  2. Case (% has type memberAccessExpression)

    1. (Let (memberAccessBase . member) be (expression'' as memberAccessExpression))

    2. If ((memberAccessBase has type expression)), then

      1. (Let expression'' be (memberAccessBase as expression))

      2. (Let lvalue'? be $expression_as_lvalue(expression''))

      3. If ((lvalue'? matches pattern (_))), then

        1. (Let ?(lvalue) be lvalue'?)

        2. Return ?((lvalue . member))

  3. Case (% has type parenthesizedExpression)

    1. (Let (( expression'' )) be (expression'' as parenthesizedExpression))

    2. (Let lvalue'? be $expression_as_lvalue(expression''))

    3. If ((lvalue'? matches pattern (_))), then

      1. (Let ?(lvalue) be lvalue'?)

      2. Return ?((( lvalue )))

;; ../../../../spec-concrete/2.0-domain.watsup:99.14-99.17
syntax oid = id*

;; ../../../../spec-concrete/2.1.1-value.watsup:14.1-17.18
syntax primitiveValue = 
   | b bool
   | error. id
   | match_kind. id
   | " text " hint(print "#%#")

;; ../../../../spec-concrete/2.1.1-value.watsup:24.1-25.21
syntax numberValue = 
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat

;; ../../../../spec-concrete/2.1.1-value.watsup:27.20-27.50
syntax baseValue = 
   | b bool
   | error. id
   | match_kind. id
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat

;; ../../../../spec-concrete/2.1.1-value.watsup:35.20-35.31
syntax listValue = 
   | [ value* ]

;; ../../../../spec-concrete/2.1.1-value.watsup:36.21-36.32
syntax tupleValue = 
   | ( value* )

;; ../../../../spec-concrete/2.1.1-value.watsup:37.27-37.55
syntax headerStackValue = 
   | [ value* #( nat ; nat )]

;; ../../../../spec-concrete/2.1.1-value.watsup:39.21-39.32
syntax fieldValue = 
   | value id ;

;; ../../../../spec-concrete/2.1.1-value.watsup:41.22-41.49
syntax structValue = 
   | struct tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:42.22-42.49
syntax headerValue = 
   | header tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:43.27-43.60
syntax headerUnionValue = 
   | header_union tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:46.1-47.23
syntax enumValue = 
   | tid . id
   | tid . id # value

;; ../../../../spec-concrete/2.1.1-value.watsup:50.1-56.14
syntax dataValue = 
   | [ value* ]
   | ( value* )
   | [ value* #( nat ; nat )]
   | struct tid { fieldValue* }
   | header tid { fieldValue* }
   | header_union tid { fieldValue* }
   | tid . id
   | tid . id # value

;; ../../../../spec-concrete/2.1.1-value.watsup:62.23-62.30
syntax defaultValue = 
   | default

;; ../../../../spec-concrete/2.1.1-value.watsup:64.29-64.33
syntax invalidHeaderValue = 
   | {#}

;; ../../../../spec-concrete/2.1.1-value.watsup:67.1-68.28
syntax sequenceValue = 
   | seq( value* )
   | seq( value* ,...)

;; ../../../../spec-concrete/2.1.1-value.watsup:71.1-72.36
syntax recordValue = 
   | record{ fieldValue* }
   | record{ fieldValue* ,...}

;; ../../../../spec-concrete/2.1.1-value.watsup:75.1-77.29
syntax setValue = 
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }

;; ../../../../spec-concrete/2.1.1-value.watsup:80.1-81.38
syntax tableValue = 
   | table_enum tid . id
   | table_struct tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:84.1-89.15
syntax synthesizedValue = 
   | default
   | {#}
   | seq( value* )
   | seq( value* ,...)
   | record{ fieldValue* }
   | record{ fieldValue* ,...}
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }
   | table_enum tid . id
   | table_struct tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:95.31-95.37
syntax objectReferenceValue = 
   | ! oid

;; ../../../../spec-concrete/2.1.1-value.watsup:102.1-105.25
syntax value = 
   | b bool
   | error. id
   | match_kind. id
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat
   | [ value* ]
   | ( value* )
   | [ value* #( nat ; nat )]
   | struct tid { fieldValue* }
   | header tid { fieldValue* }
   | header_union tid { fieldValue* }
   | tid . id
   | tid . id # value
   | default
   | {#}
   | seq( value* )
   | seq( value* ,...)
   | record{ fieldValue* }
   | record{ fieldValue* ,...}
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }
   | table_enum tid . id
   | table_struct tid { fieldValue* }
   | ! oid

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:5.1-5.28
def $to_int



;; ../../../../spec-concrete/2.1.2-value-aux.watsup:12.1-12.31
def $to_bitstr



;; ../../../../spec-concrete/2.1.2-value-aux.watsup:18.1-18.28
def $to_number(value)

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i) be numberLiteral)

      2. Return i

    2. Case (% matches pattern `%S%`)

      1. (Let (w s i) be numberLiteral)

      2. Return $to_int((w as int), i)

    3. Case (% matches pattern `%W%`)

      1. (Let (w w i) be numberLiteral)

      2. Return i

2. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. If ((numberValue matches pattern `%V%#%`)), then

    1. (Let (w v i # _nat) be numberValue)

    2. Return i

;; ../../../../spec-concrete/2.2.1-type.watsup:14.1-18.11
syntax primitiveTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string

;; ../../../../spec-concrete/2.2.1-type.watsup:25.1-28.20
syntax numberTypeIR = 
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >

;; ../../../../spec-concrete/2.2.1-type.watsup:30.21-30.51
syntax baseTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >

;; ../../../../spec-concrete/2.2.1-type.watsup:40.1-41.31
syntax namedTypeIR = 
   | tid tid
   | polyTypeDefIR < typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:52.1-53.20
syntax aliasTypeIR = 
   | typedef tid typeIR
   | type tid typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:59.21-59.37
syntax listTypeIR = 
   | list< typeIR >

;; ../../../../spec-concrete/2.2.1-type.watsup:60.22-60.40
syntax tupleTypeIR = 
   | tuple< typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:61.28-61.43
syntax headerStackTypeIR = 
   | typeIR [ nat ]

;; ../../../../spec-concrete/2.2.1-type.watsup:63.22-63.34
syntax fieldTypeIR = 
   | typeIR id ;

;; ../../../../spec-concrete/2.2.1-type.watsup:65.23-65.51
syntax structTypeIR = 
   | struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:66.23-66.51
syntax headerTypeIR = 
   | header tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:67.28-67.62
syntax headerUnionTypeIR = 
   | header_union tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:69.23-69.37
syntax valueFieldIR = 
   | id = value ;

;; ../../../../spec-concrete/2.2.1-type.watsup:72.1-73.42
syntax enumTypeIR = 
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:76.1-82.15
syntax dataTypeIR = 
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:92.3-92.40
syntax externObjectTypeIR = 
   | extern tid map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/2.2.1-type.watsup:93.29-93.57
syntax parserObjectTypeIR = 
   | parser( parameterTypeIR* )

;; ../../../../spec-concrete/2.2.1-type.watsup:94.30-94.59
syntax controlObjectTypeIR = 
   | control( parameterTypeIR* )

;; ../../../../spec-concrete/2.2.1-type.watsup:95.30-95.50
syntax packageObjectTypeIR = 
   | package< typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:96.28-96.47
syntax tableObjectTypeIR = 
   | table tid # typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:99.1-103.22
syntax objectTypeIR = 
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:106.1-108.17
syntax definedTypeIR = 
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:114.24-114.31
syntax defaultTypeIR = 
   | default

;; ../../../../spec-concrete/2.2.1-type.watsup:116.30-116.44
syntax invalidHeaderTypeIR = 
   | header_invalid

;; ../../../../spec-concrete/2.2.1-type.watsup:119.1-120.29
syntax sequenceTypeIR = 
   | seq< typeIR* >
   | seq< typeIR* ,...>

;; ../../../../spec-concrete/2.2.1-type.watsup:123.1-124.37
syntax recordTypeIR = 
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}

;; ../../../../spec-concrete/2.2.1-type.watsup:126.20-126.36
syntax setTypeIR = 
   | set< typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:129.1-130.39
syntax tableTypeIR = 
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:133.1-138.16
syntax synthesizedTypeIR = 
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:145.1-148.22
syntax typeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:154.24-154.30
syntax monoTypeDefIR = typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:156.24-156.48
syntax polyTypeDefIR = 
   | typeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:158.20-158.49
syntax typeDefIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }
   | typeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:164.26-164.52
syntax parameterTypeIR = 
   | direction typeIR id value?

;; ../../../../spec-concrete/2.2.1-type.watsup:171.1-174.33
syntax functionTypeIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )

;; ../../../../spec-concrete/2.2.1-type.watsup:177.1-182.27
syntax methodTypeIR = 
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:185.1-186.17
syntax routineTypeIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:192.31-192.44
syntax monoRoutineTypeDefIR = routineTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:194.31-194.62
syntax polyRoutineTypeDefIR = 
   | routineTypeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:197.1-198.25
syntax routineTypeDefIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR
   | routineTypeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:204.37-204.52
syntax constructorParameterTypeIR = parameterTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:211.3-211.58
syntax constructorTypeIR = 
   | constructor( constructorParameterTypeIR* )-> typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:217.31-217.66
syntax constructorTypeDefIR = 
   | constructorTypeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:9.1-9.34
def $is_baseTypeIR(typeIR)

1. If ((typeIR has type baseTypeIR)), then

  1. (Let baseTypeIR be (typeIR as baseTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:16.1-16.39
def $is_primitiveTypeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:21.1-21.35
def $is_void_typeIR(typeIR)

1. If ((typeIR = ((void) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:26.1-26.35
def $is_bool_typeIR(typeIR)

1. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:31.1-31.36
def $is_error_typeIR(typeIR)

1. If ((typeIR = ((error) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:36.1-36.40
def $is_matchkind_typeIR(typeIR)

1. If ((typeIR = ((match_kind) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:41.1-41.37
def $is_string_typeIR(typeIR)

1. If ((typeIR = ((string) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:48.1-48.36
def $is_numberTypeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:53.1-53.44
def $is_arbitrary_int_typeIR(typeIR)

1. If ((typeIR = ((int) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:58.1-58.40
def $is_fixed_int_typeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:63.1-63.40
def $is_fixed_bit_typeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:76.1-76.34
def $is_dataTypeIR(typeIR)

1. If ((typeIR has type dataTypeIR)), then

  1. (Let dataTypeIR be (typeIR as dataTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:81.1-81.41
def $is_headerStackTypeIR(typeIR)

1. If ((typeIR has type headerStackTypeIR)), then

  1. (Let headerStackTypeIR be (typeIR as headerStackTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:88.1-88.36
def $is_objectTypeIR(typeIR)

1. If ((typeIR has type objectTypeIR)), then

  1. (Let objectTypeIR be (typeIR as objectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:93.1-93.44
def $is_extern_object_typeIR(typeIR)

1. If ((typeIR has type externObjectTypeIR)), then

  1. (Let externObjectTypeIR be (typeIR as externObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:98.1-98.44
def $is_parser_object_typeIR(typeIR)

1. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let parserObjectTypeIR be (typeIR as parserObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:103.1-103.45
def $is_control_object_typeIR(typeIR)

1. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let controlObjectTypeIR be (typeIR as controlObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:108.1-108.45
def $is_package_object_typeIR(typeIR)

1. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let packageObjectTypeIR be (typeIR as packageObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:113.1-113.43
def $is_table_object_typeIR(typeIR)

1. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let controlObjectTypeIR be (typeIR as controlObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:120.1-120.41
def $is_synthesizedTypeIR(typeIR)

1. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let tableObjectTypeIR be (typeIR as tableObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:125.1-125.34
def $is_set_typeIR(typeIR)

1. If ((typeIR has type setTypeIR)), then

  1. (Let (set< _typeIR* >) be (typeIR as setTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:5.16-5.24
syntax bound = set<tid>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:6.16-6.32
syntax theta = map<tid, typeIR>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:8.1-8.31
def $free_type(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type baseTypeIR)

    1. (Let baseTypeIR be (typeIR'' as baseTypeIR))

    2. Return ({ [] })

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `TID%`)

        1. (Let (tid tid) be namedTypeIR)

        2. Return ({ [tid] })

      2. Case (% matches pattern `%<%>`)

        1. (Let (polyTypeDefIR < typeIR''* >) be namedTypeIR)

        2. (Let bound_base be $free_typeDef((polyTypeDefIR as typeDefIR)))

        3. (Let bound_args be $unions_set<tid>($free_type(typeIR'')*))

        4. Return $union_set<tid>(bound_base, bound_args)

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `TYPEDEF%%`)

        1. (Let (typedef _tid typeIR'') be aliasTypeIR)

        2. Return $free_type(typeIR'')

      2. Case (% matches pattern `TYPE%%`)

        1. (Let (type _tid typeIR'') be aliasTypeIR)

        2. Return $free_type(typeIR'')

  4. Case (% has type listTypeIR)

    1. (Let (list< typeIR'' >) be (typeIR'' as listTypeIR))

    2. Return $free_type(typeIR'')

  5. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR'')*)

  6. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ _nat ]) be (typeIR'' as headerStackTypeIR))

    2. Return $free_type(typeIR'')

  7. Case (% has type headerTypeIR)

    1. (Let (header _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR'')*)

  8. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerUnionTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR'')*)

  9. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR'' _id ;)* }) be (typeIR'' as structTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR'')*)

  10. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return ({ [] })

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # typeIR'' { _valueFieldIR* }) be enumTypeIR)

        2. Return $free_type(typeIR'')

  11. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid ({ (_rid : routineTypeDefIR)* })) be (typeIR'' as externObjectTypeIR))

    2. Return $unions_set<tid>($free_routineTypeDef(routineTypeDefIR)*)

  12. Case (% has type parserObjectTypeIR)

    1. (Let (parser( parameterTypeIR* )) be (typeIR'' as parserObjectTypeIR))

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

    3. Return bound_params

  13. Case (% has type controlObjectTypeIR)

    1. (Let (control( parameterTypeIR* )) be (typeIR'' as controlObjectTypeIR))

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

    3. Return bound_params

  14. Case (% has type packageObjectTypeIR)

    1. (Let (package< typeIR''* >) be (typeIR'' as packageObjectTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR'')*)

  15. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # typeIR'') be (typeIR'' as tableObjectTypeIR))

    2. Return $free_type(typeIR'')

  16. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR'' as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SEQ<%>`)

        1. (Let (seq< typeIR''* >) be sequenceTypeIR)

        2. Return $unions_set<tid>($free_type(typeIR'')*)

      2. Case (% matches pattern `SEQ<%,...>`)

        1. (Let (seq< typeIR''* ,...>) be sequenceTypeIR)

        2. Return $unions_set<tid>($free_type(typeIR'')*)

  17. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR'' as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RECORD{%}`)

        1. (Let (record{ (typeIR'' _id ;)* }) be recordTypeIR)

        2. Return $unions_set<tid>($free_type(typeIR'')*)

      2. Case (% matches pattern `RECORD{%,...}`)

        1. (Let (record{ (typeIR'' _id ;)* ,...}) be recordTypeIR)

        2. Return $unions_set<tid>($free_type(typeIR'')*)

  18. Case (% has type setTypeIR)

    1. (Let (set< typeIR''* >) be (typeIR'' as setTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR'')*)

  19. Case (% has type tableTypeIR)

    1. (Let tableTypeIR be (typeIR'' as tableTypeIR))

    2. Case analysis on tableTypeIR

      1. Case (% matches pattern `TABLE_ENUM%{%}`)

        1. (Let (table_enum _tid { _id* }) be tableTypeIR)

        2. Return ({ [] })

      2. Case (% matches pattern `TABLE_STRUCT%{%}`)

        1. (Let (table_struct _tid { _fieldTypeIR* }) be tableTypeIR)

        2. Return ({ [] })

2. If ((typeIR'' = ((default) as typeIR))), then

  1. Return ({ [] })

3. If ((typeIR'' = ((header_invalid) as typeIR))), then

  1. Return ({ [] })

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:9.1-9.37
def $free_typeDef(typeDefIR)

1. Case analysis on typeDefIR

  1. Case (% has type typeIR)

    1. (Let typeIR be (typeDefIR as typeIR))

    2. Return $free_type(typeIR)

  2. Case (% has type polyTypeDefIR)

    1. (Let (typeIR_base < tid* , tid_hidden* >) be (typeDefIR as polyTypeDefIR))

    2. (Let bound_base be $free_typeDef((typeIR_base as typeDefIR)))

    3. (Let bound_tparams be ({ tid* ++ tid_hidden* }))

    4. Return $diff_set<tid>(bound_base, bound_tparams)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:10.1-10.49
def $free_parameterType((_direction typeIR _id _value?))

1. Return $free_type(typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:11.1-11.45
def $free_routineType(routineTypeIR)

1. Case analysis on routineTypeIR

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

        1. (Let (builtin_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      2. Case (% matches pattern `FUNCTION(%)->%`)

        1. (Let (function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      3. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

        1. (Let (extern_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      4. Case (% matches pattern `ACTION(%)`)

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. Return bound_params

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

        1. (Let (builtin_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      2. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      3. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      4. Case (% matches pattern `PARSER_APPLY(%)`)

        1. (Let (parser_apply( parameterTypeIR* )) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. Return bound_params

      5. Case (% matches pattern `CONTROL_APPLY(%)`)

        1. (Let (control_apply( parameterTypeIR* )) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. Return bound_params

      6. Case (% matches pattern `TABLE_APPLY->%`)

        1. (Let (table_apply-> typeIR_ret) be methodTypeIR)

        2. (Let bound_ret be $free_type(typeIR_ret))

        3. Return bound_ret

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:12.1-12.51
def $free_routineTypeDef(routineTypeDefIR)

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

    2. Return $free_routineType(routineTypeIR)

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR < tid* , tid_hidden* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. (Let bound_base be $free_routineTypeDef((routineTypeIR as routineTypeDefIR)))

    3. (Let bound_tparams be ({ tid* ++ tid_hidden* }))

    4. Return $diff_set<tid>(bound_base, bound_tparams)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:14.1-14.40
def $subst_type(set<pair<tid, typeIR>>', typeIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return typeIR

2. Otherwise

  1. Return $subst_type'(set<pair<tid, typeIR>>', typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:15.1-15.41
def $subst_type'(theta, typeIR''')

1. Case analysis on typeIR'''

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR''' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `TID%`)

        1. (Let (tid tid) be namedTypeIR)

        2. (Let typeIR''? be $find_map<tid, typeIR>(theta, tid))

        3. If ((typeIR''? matches pattern (_))), then

          1. (Let ?(typeIR) be typeIR''?)

          2. Return typeIR

      2. Case (% matches pattern `%<%>`)

        1. (Let (polyTypeDefIR < typeIR* >) be namedTypeIR)

        2. (Let typeDefIR be $subst_typeDef'(theta, (polyTypeDefIR as typeDefIR)))

        3. If ((typeDefIR has type polyTypeDefIR)), then

          1. (Let polyTypeDefIR_subst be (typeDefIR as polyTypeDefIR))

          2. (Let typeIR_subst be $subst_type'(theta, typeIR))*

          3. Return ((polyTypeDefIR_subst < typeIR_subst* >) as typeIR)

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `TYPEDEF%%`)

        1. (Let (typedef tid typeIR) be aliasTypeIR)

        2. (Let typeIR_subst be $subst_type'(theta, typeIR))

        3. Return ((typedef tid typeIR_subst) as typeIR)

      2. Case (% matches pattern `TYPE%%`)

        1. (Let (type tid typeIR) be aliasTypeIR)

        2. (Let typeIR_subst be $subst_type'(theta, typeIR))

        3. Return ((type tid typeIR_subst) as typeIR)

  3. Case (% has type listTypeIR)

    1. (Let (list< typeIR >) be (typeIR''' as listTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))

    3. Return ((list< typeIR_subst >) as typeIR)

  4. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR* >) be (typeIR''' as tupleTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))*

    3. Return ((tuple< typeIR_subst* >) as typeIR)

  5. Case (% has type headerStackTypeIR)

    1. (Let (typeIR [ n ]) be (typeIR''' as headerStackTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))

    3. Return ((typeIR_subst [ n ]) as typeIR)

  6. Case (% has type structTypeIR)

    1. (Let (struct tid { (typeIR_f id_f ;)* }) be (typeIR''' as structTypeIR))

    2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

    3. Return ((struct tid { (typeIR_f_subst id_f ;)* }) as typeIR)

  7. Case (% has type headerTypeIR)

    1. (Let (header tid { (typeIR_f id_f ;)* }) be (typeIR''' as headerTypeIR))

    2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

    3. Return ((header tid { (typeIR_f_subst id_f ;)* }) as typeIR)

  8. Case (% has type headerUnionTypeIR)

    1. (Let (header_union tid { (typeIR_f id_f ;)* }) be (typeIR''' as headerUnionTypeIR))

    2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

    3. Return ((header_union tid { (typeIR_f_subst id_f ;)* }) as typeIR)

  9. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR''' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum tid # typeIR''' { valueFieldIR* }) be enumTypeIR)

      2. (Let typeIR_subst be $subst_type'(theta, typeIR'''))

      3. Return ((enum tid # typeIR_subst { valueFieldIR* }) as typeIR)

  10. Case (% has type externObjectTypeIR)

    1. (Let (extern tid ({ (rid : routineTypeDefIR)* })) be (typeIR''' as externObjectTypeIR))

    2. (Let routineTypeDefIR_subst be $subst_routineTypeDef'(theta, routineTypeDefIR))*

    3. Return ((extern tid ({ (rid : routineTypeDefIR_subst)* })) as typeIR)

  11. Case (% has type parserObjectTypeIR)

    1. (Let (parser( parameterTypeIR* )) be (typeIR''' as parserObjectTypeIR))

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

    3. Return ((parser( parameterTypeIR_subst* )) as typeIR)

  12. Case (% has type controlObjectTypeIR)

    1. (Let (control( parameterTypeIR* )) be (typeIR''' as controlObjectTypeIR))

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

    3. Return ((control( parameterTypeIR_subst* )) as typeIR)

  13. Case (% has type packageObjectTypeIR)

    1. (Let (package< typeIR'''* >) be (typeIR''' as packageObjectTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR'''))*

    3. Return ((package< typeIR_subst* >) as typeIR)

  14. Case (% has type tableObjectTypeIR)

    1. (Let (table tid # typeIR''') be (typeIR''' as tableObjectTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR'''))

    3. Return ((table tid # typeIR_subst) as typeIR)

  15. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR''' as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SEQ<%>`)

        1. (Let (seq< typeIR'''* >) be sequenceTypeIR)

        2. (Let typeIR_subst be $subst_type'(theta, typeIR'''))*

        3. Return ((seq< typeIR_subst* >) as typeIR)

      2. Case (% matches pattern `SEQ<%,...>`)

        1. (Let (seq< typeIR'''* ,...>) be sequenceTypeIR)

        2. (Let typeIR_subst be $subst_type'(theta, typeIR'''))*

        3. Return ((seq< typeIR_subst* ,...>) as typeIR)

  16. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR''' as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RECORD{%}`)

        1. (Let (record{ (typeIR_f id_f ;)* }) be recordTypeIR)

        2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

        3. Return ((record{ (typeIR_f_subst id_f ;)* }) as typeIR)

      2. Case (% matches pattern `RECORD{%,...}`)

        1. (Let (record{ (typeIR_f id_f ;)* ,...}) be recordTypeIR)

        2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

        3. Return ((record{ (typeIR_f_subst id_f ;)* ,...}) as typeIR)

  17. Case (% has type setTypeIR)

    1. (Let (set< typeIR'''* >) be (typeIR''' as setTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR'''))*

    3. Return ((set< typeIR_subst* >) as typeIR)

2. Otherwise

  1. Return typeIR'''

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:16.1-16.49
def $subst_typeDef(set<pair<tid, typeIR>>', typeDefIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return typeDefIR

2. Otherwise

  1. Return $subst_typeDef'(set<pair<tid, typeIR>>', typeDefIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:17.1-17.50
def $subst_typeDef'(theta, typeDefIR)

1. Case analysis on typeDefIR

  1. Case (% has type typeIR)

    1. (Let typeIR be (typeDefIR as typeIR))

    2. Return ($subst_type'(theta, typeIR) as typeDefIR)

  2. Case (% has type polyTypeDefIR)

    1. (Let (typeIR_base < tid* , tid_hidden* >) be (typeDefIR as polyTypeDefIR))

    2. (Let ({ tid_free* }) be $diff_set<tid>($free_type(typeIR_base), ({ tid* ++ tid_hidden* })))

    3. (Let typeIR? be $find_map<tid, typeIR>(theta, tid_free))*

    4. If ((typeIR? matches pattern (_)))*, then

      1. (Let ?(typeIR_free) be typeIR?)*

      2. (Let bound_capture be $unions_set<tid>($free_type(typeIR_free)*))

      3. (Let tid_fresh* be $fresh_tids(|tid* ++ tid_hidden*|))

      4. If (~$in_set<tid>(tid_fresh, bound_capture))*, then

        1. (Let tid_fresh_spec* be tid_fresh*[0 : |tid*|])

        2. (Let tid_fresh_hidden* be tid_fresh*[|tid*| : |tid_hidden*|])

        3. (Let theta' be $adds_map<tid, typeIR>(theta, tid*, ((tid tid_fresh_spec) as typeIR)*))

        4. (Let theta'' be $adds_map<tid, typeIR>(theta', tid_hidden*, ((tid tid_fresh_hidden) as typeIR)*))

        5. (Let typeIR_base_subst be $subst_type(theta'', typeIR_base))

        6. Return ((typeIR_base_subst < tid_fresh_spec* , tid_fresh_hidden* >) as typeDefIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:18.1-18.67
def $subst_parameterType(set<pair<tid, typeIR>>', parameterTypeIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return parameterTypeIR

2. Otherwise

  1. Return $subst_parameterType'(set<pair<tid, typeIR>>', parameterTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:19.1-19.68
def $subst_parameterType'(theta, (direction typeIR id value?))

1. (Let typeIR_subst be $subst_type'(theta, typeIR))

2. Return (direction typeIR_subst id value?)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:20.1-20.61
def $subst_routineType(set<pair<tid, typeIR>>', routineTypeIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return routineTypeIR

2. Otherwise

  1. Return $subst_routineType'(set<pair<tid, typeIR>>', routineTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:21.1-21.62
def $subst_routineType'(theta, routineTypeIR)

1. Case analysis on routineTypeIR

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

        1. (Let (builtin_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((builtin_function( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      2. Case (% matches pattern `FUNCTION(%)->%`)

        1. (Let (function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((function( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      3. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

        1. (Let (extern_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((extern_function( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      4. Case (% matches pattern `ACTION(%)`)

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. Return ((action( parameterTypeIR_subst* )) as routineTypeIR)

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

        1. (Let (builtin_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((builtin_method( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      2. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((extern_method( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      3. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((extern_methodabstract( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      4. Case (% matches pattern `PARSER_APPLY(%)`)

        1. (Let (parser_apply( parameterTypeIR* )) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. Return ((parser_apply( parameterTypeIR_subst* )) as routineTypeIR)

      5. Case (% matches pattern `CONTROL_APPLY(%)`)

        1. (Let (control_apply( parameterTypeIR* )) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. Return ((control_apply( parameterTypeIR_subst* )) as routineTypeIR)

      6. Case (% matches pattern `TABLE_APPLY->%`)

        1. (Let (table_apply-> typeIR_ret) be methodTypeIR)

        2. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        3. Return ((table_apply-> typeIR_ret_subst) as routineTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:22.1-22.70
def $subst_routineTypeDef(set<pair<tid, typeIR>>', routineTypeDefIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return routineTypeDefIR

2. Otherwise

  1. Return $subst_routineTypeDef'(set<pair<tid, typeIR>>', routineTypeDefIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:23.1-23.71
def $subst_routineTypeDef'(theta, routineTypeDefIR)

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

    2. Return ($subst_routineType'(theta, routineTypeIR) as routineTypeDefIR)

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR < tid* , tid_hidden* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. (Let ({ tid_free* }) be $diff_set<tid>($free_routineType(routineTypeIR), ({ tid* ++ tid_hidden* })))

    3. (Let typeIR? be $find_map<tid, typeIR>(theta, tid_free))*

    4. If ((typeIR? matches pattern (_)))*, then

      1. (Let ?(typeIR_free) be typeIR?)*

      2. (Let bound_capture be $unions_set<tid>($free_type(typeIR_free)*))

      3. (Let tid_fresh* be $fresh_tids(|tid* ++ tid_hidden*|))

      4. If (~$in_set<tid>(tid_fresh, bound_capture))*, then

        1. (Let tid_fresh_spec* be tid_fresh*[0 : |tid*|])

        2. (Let tid_fresh_hidden* be tid_fresh*[|tid*| : |tid_hidden*|])

        3. (Let theta' be $adds_map<tid, typeIR>(theta, tid*, ((tid tid_fresh_spec) as typeIR)*))

        4. (Let theta'' be $adds_map<tid, typeIR>(theta', tid_hidden*, ((tid tid_fresh_hidden) as typeIR)*))

        5. (Let routineTypeIR_subst be $subst_routineType(theta'', routineTypeIR))

        6. Return ((routineTypeIR_subst < tid_fresh_spec* , tid_fresh_hidden* >) as routineTypeDefIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:24.1-24.73
def $subst_constructorType(set<pair<tid, typeIR>>', constructorTypeIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return constructorTypeIR

2. Otherwise

  1. Return $subst_constructorType'(set<pair<tid, typeIR>>', constructorTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:25.1-25.74
def $subst_constructorType'(theta, (constructor( parameterTypeIR* )-> typeIR_obj))

1. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

2. (Let typeIR_obj_subst be $subst_type'(theta, typeIR_obj))

3. Return (constructor( parameterTypeIR_subst* )-> typeIR_obj_subst)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:561.1-561.53
def $specialize_typeDef(typeDefIR, typeIR''*)

1. Case analysis on typeDefIR

  1. Case (% has type typeIR)

    1. (Let typeIR be (typeDefIR as typeIR))

    2. If ((typeIR''* matches pattern [])), then

      1. Return typeIR

  2. Case (% has type polyTypeDefIR)

    1. (Let (typeIR_base < tid* , tid_hidden* >) be (typeDefIR as polyTypeDefIR))

    2. (Let tid_tparam* be tid* ++ tid_hidden*)

    3. (Let theta be ({ (tid_tparam : typeIR'')* }))

    4. Return $subst_type(theta, typeIR_base)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:574.1-575.29
def $specialize_routineTypeDef(routineTypeDefIR, typeIR'*)

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

    2. If ((typeIR'* matches pattern [])), then

      1. Return ((routineTypeIR as routineTypeDefIR), [])

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR < tid* , tid_hidden* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. (Let tid_tparam* be tid* ++ tid_hidden*)

    3. If ((|tid_tparam*| = |typeIR'*|)), then

      1. (Let theta be ({ (tid_tparam : typeIR')* }))

      2. Return (($subst_routineType(theta, routineTypeIR) as routineTypeDefIR), [])

    4. If (((|tid_tparam*| > 0) /\ (|typeIR'*| = 0))), then

      1. (Let tid_fresh* be $fresh_tids(|tid_tparam*|))

      2. (Let theta be ({ (tid_tparam : ((tid tid_fresh) as typeIR))* }))

      3. Return (($subst_routineType(theta, routineTypeIR), tid_fresh*) as (routineTypeDefIR, tid*))

    5. If ((((|tid_hidden*| > 0) /\ (|tid*| = |typeIR'*|)) /\ (|typeIR'*| > 0))), then

      1. (Let tid_fresh* be $fresh_tids(|tid_hidden*|))

      2. (Let typeIR_arg_new* be typeIR'* ++ ((tid tid_fresh) as typeIR)*)

      3. (Let theta be ({ (tid_tparam : typeIR_arg_new)* }))

      4. Return (($subst_routineType(theta, routineTypeIR), tid_fresh*) as (routineTypeDefIR, tid*))

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:616.1-617.30
def $specialize_constructorTypeDef((constructorTypeIR < tid* , tid_hidden* >), typeIR_arg*)

1. (Let tid_tparam* be tid* ++ tid_hidden*)

2. If ((|tid_tparam*| = |typeIR_arg*|)), then

  1. (Let theta be ({ (tid_tparam : typeIR_arg)* }))

  2. (Let constructorTypeIR_subst be $subst_constructorType(theta, constructorTypeIR))

  3. Return (constructorTypeIR_subst, [])

3. If (((|tid_tparam*| > 0) /\ (|typeIR_arg*| = 0))), then

  1. (Let tid_fresh* be $fresh_tids(|tid_tparam*|))

  2. (Let theta be ({ (tid_tparam : ((tid tid_fresh) as typeIR))* }))

  3. (Let constructorTypeIR_subst be $subst_constructorType(theta, constructorTypeIR))

  4. Return (constructorTypeIR_subst, tid_fresh*)

4. If ((((|tid_hidden*| > 0) /\ (|tid*| = |typeIR_arg*|)) /\ (|typeIR_arg*| > 0))), then

  1. (Let tid_fresh* be $fresh_tids(|tid_hidden*|))

  2. (Let typeIR_arg_new* be typeIR_arg* ++ ((tid tid_fresh) as typeIR)*)

  3. (Let theta be ({ (tid_tparam : typeIR_arg_new)* }))

  4. (Let constructorTypeIR_subst be $subst_constructorType(theta, constructorTypeIR))

  5. Return (constructorTypeIR_subst, tid_fresh*)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:662.1-662.28
def $canon(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `%<%>`)), then

      1. (Let (polyTypeDefIR < typeIR_arg* >) be namedTypeIR)

      2. (Let typeIR be $specialize_typeDef((polyTypeDefIR as typeDefIR), typeIR_arg*))

      3. Return $canon(typeIR)

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

      1. (Let (typedef _tid typeIR) be aliasTypeIR)

      2. Return $canon(typeIR)

2. Otherwise

  1. Return typeIR''

;; ../../../../spec-concrete/2.2.4-type-util.watsup:7.1-7.38
def $is_nominal_typeIR(typeIR)

1. Return $is_nominal_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:8.1-8.39
def $is_nominal_typeIR'(typeIR)

1. Case analysis on typeIR

  1. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  2. Case (% has type structTypeIR)

    1. (Let (struct _tid { _fieldTypeIR* }) be (typeIR as structTypeIR))

    2. Return true

  3. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

    2. Return true

  4. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR as headerUnionTypeIR))

    2. Return true

  5. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

  6. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR as externObjectTypeIR))

    2. Return true

  7. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.4-type-util.watsup:25.1-25.42
def $is_defaultable_typeIR(typeIR)

1. Return $is_defaultable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:26.1-26.43
def $is_defaultable_typeIR'(typeIR'')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return true

2. If ((typeIR'' = ((error) as typeIR))), then

  1. Return true

3. If ((typeIR'' = ((string) as typeIR))), then

  1. Return true

4. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Return true

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $is_defaultable_typeIR(typeIR'')

  3. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. If ($is_defaultable_typeIR(typeIR''))*, then

      1. Return true

  4. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ _nat ]) be (typeIR'' as headerStackTypeIR))

    2. Return $is_defaultable_typeIR(typeIR'')

  5. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR'' _id ;)* }) be (typeIR'' as structTypeIR))

    2. If ($is_defaultable_typeIR(typeIR''))*, then

      1. Return true

  6. Case (% has type headerTypeIR)

    1. (Let (header _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerTypeIR))

    2. If ($is_defaultable_typeIR(typeIR''))*, then

      1. Return true

  7. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerUnionTypeIR))

    2. If ($is_defaultable_typeIR(typeIR''))*, then

      1. Return true

  8. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # typeIR'' { _valueFieldIR* }) be enumTypeIR)

        2. Return $is_defaultable_typeIR(typeIR'')

5. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.4-type-util.watsup:54.1-54.40
def $is_equalable_typeIR(typeIR)

1. Return $is_equalable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:55.1-55.41
def $is_equalable_typeIR'(typeIR)

1. If ((typeIR = ((void) as typeIR))), then

  1. Return false

2. Case analysis on typeIR

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid tid) be namedTypeIR)

      2. Return false

  2. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR as externObjectTypeIR))

    2. Return false

  3. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

    2. Return false

  4. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

    2. Return false

  5. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

    2. Return false

  6. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

    2. Return false

  7. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

    2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

      1. (Let (seq< _typeIR* ,...>) be sequenceTypeIR)

      2. Return false

  8. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR as recordTypeIR))

    2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

      1. (Let (record{ _fieldTypeIR* ,...}) be recordTypeIR)

      2. Return false

  9. Case (% has type setTypeIR)

    1. (Let (set< _typeIR* >) be (typeIR as setTypeIR))

    2. Return false

  10. Case (% has type tableTypeIR)

    1. (Let tableTypeIR be (typeIR as tableTypeIR))

    2. Case analysis on tableTypeIR

      1. Case (% matches pattern `TABLE_ENUM%{%}`)

        1. (Let (table_enum _tid { _id* }) be tableTypeIR)

        2. Return false

      2. Case (% matches pattern `TABLE_STRUCT%{%}`)

        1. (Let (table_struct _tid { _fieldTypeIR* }) be tableTypeIR)

        2. Return false

3. If ((typeIR = ((default) as typeIR))), then

  1. Return false

4. If ((typeIR = ((header_invalid) as typeIR))), then

  1. Return false

5. Otherwise

  1. Return true

;; ../../../../spec-concrete/2.2.4-type-util.watsup:78.1-78.41
def $is_assignable_typeIR(typeIR)

1. Return $is_assignable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:79.1-79.42
def $is_assignable_typeIR'(typeIR)

1. If ((typeIR = ((void) as typeIR))), then

  1. Return false

2. If ((typeIR = ((string) as typeIR))), then

  1. Return false

3. If ((typeIR = ((int) as typeIR))), then

  1. Return false

4. Case analysis on typeIR

  1. Case (% has type objectTypeIR)

    1. (Let objectTypeIR be (typeIR as objectTypeIR))

    2. Return false

  2. Case (% has type synthesizedTypeIR)

    1. (Let synthesizedTypeIR be (typeIR as synthesizedTypeIR))

    2. Return false

5. Otherwise

  1. Return true

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:5.1-7.20
relation Type_alpha: 

  basetype: typeIR ~~ typeIR' {

    1. If ((typeIR has type baseTypeIR)), then

      1. (Let baseTypeIR be (typeIR as baseTypeIR))

      2. If ((typeIR' has type baseTypeIR)), then

        1. (Let baseTypeIR' be (typeIR' as baseTypeIR))

        2. If ((baseTypeIR = baseTypeIR')), then

          1. The relation holds

  }

  nametype: typeIR ~~ typeIR' {

    1. If ((typeIR has type namedTypeIR)), then

      1. (Let namedTypeIR be (typeIR as namedTypeIR))

      2. If ((namedTypeIR matches pattern `TID%`)), then

        1. (Let (tid tid) be namedTypeIR)

        2. If ((typeIR' has type namedTypeIR)), then

          1. (Let namedTypeIR' be (typeIR' as namedTypeIR))

          2. If ((namedTypeIR' matches pattern `TID%`)), then

            1. (Let (tid tid') be namedTypeIR')

            2. If ((tid = tid')), then

              1. The relation holds

  }

  spectype: typeIR ~~ typeIR' {

    1. If ((typeIR has type namedTypeIR)), then

      1. (Let namedTypeIR be (typeIR as namedTypeIR))

      2. If ((namedTypeIR matches pattern `%<%>`)), then

        1. (Let (polyTypeDefIR_a < typeIR_a* >) be namedTypeIR)

        2. If ((typeIR' has type namedTypeIR)), then

          1. (Let namedTypeIR' be (typeIR' as namedTypeIR))

          2. If ((namedTypeIR' matches pattern `%<%>`)), then

            1. (Let (polyTypeDefIR_b < typeIR_b* >) be namedTypeIR')

            2. (Let typeIR_a_spec be $specialize_typeDef((polyTypeDefIR_a as typeDefIR), typeIR_a*))

            3. (Let typeIR_b_spec be $specialize_typeDef((polyTypeDefIR_b as typeDefIR), typeIR_b*))

            4. If ((Type_alpha: typeIR_a_spec ~~ typeIR_b_spec holds)), then

              1. If (($is_nominal_typeIR(typeIR_a_spec) /\ $is_nominal_typeIR(typeIR_b_spec))), then

                1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

                  1. The relation holds

              2. If ((~$is_nominal_typeIR(typeIR_a_spec) /\ ~$is_nominal_typeIR(typeIR_b_spec))), then

                1. The relation holds

  }

  typedeftype: typeIR' ~~ typeIR_b' {

    1. If ((typeIR' has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

        1. (Let (typedef _tid typeIR_a) be aliasTypeIR)

        2. If ((Type_alpha: typeIR_a ~~ typeIR_b' holds)), then

          1. The relation holds

    2. If ((typeIR_b' has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR_b' as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

        1. (Let (typedef _tid typeIR_b') be aliasTypeIR)

        2. If ((Type_alpha: typeIR' ~~ typeIR_b' holds)), then

          1. The relation holds

  }

  newtype: typeIR ~~ typeIR' {

    1. If ((typeIR has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

        1. (Let (type tid typeIR_a) be aliasTypeIR)

        2. If ((typeIR' has type aliasTypeIR)), then

          1. (Let aliasTypeIR' be (typeIR' as aliasTypeIR))

          2. If ((aliasTypeIR' matches pattern `TYPE%%`)), then

            1. (Let (type tid' typeIR_b) be aliasTypeIR')

            2. If ((tid = tid')), then

              1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

                1. The relation holds

  }

  listtype: typeIR ~~ typeIR' {

    1. If ((typeIR has type listTypeIR)), then

      1. (Let (list< typeIR_a >) be (typeIR as listTypeIR))

      2. If ((typeIR' has type listTypeIR)), then

        1. (Let (list< typeIR_b >) be (typeIR' as listTypeIR))

        2. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

          1. The relation holds

  }

  tupletype: typeIR ~~ typeIR' {

    1. If ((typeIR has type tupleTypeIR)), then

      1. (Let (tuple< typeIR_a* >) be (typeIR as tupleTypeIR))

      2. If ((typeIR' has type tupleTypeIR)), then

        1. (Let (tuple< typeIR_b* >) be (typeIR' as tupleTypeIR))

        2. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

          1. The relation holds

  }

  stacktype: typeIR ~~ typeIR' {

    1. If ((typeIR has type headerStackTypeIR)), then

      1. (Let (typeIR_a [ n_s ]) be (typeIR as headerStackTypeIR))

      2. If ((typeIR' has type headerStackTypeIR)), then

        1. (Let (typeIR_b [ n_s' ]) be (typeIR' as headerStackTypeIR))

        2. If ((n_s = n_s')), then

          1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

            1. The relation holds

  }

  structtype: typeIR ~~ typeIR' {

    1. If ((typeIR has type structTypeIR)), then

      1. (Let (struct tid { (typeIR_f_a id_f ;)* }) be (typeIR as structTypeIR))

      2. If ((typeIR' has type structTypeIR)), then

        1. (Let (struct tid' { (typeIR_f_b id_f' ;)* }) be (typeIR' as structTypeIR))

        2. If ((id_f = id_f'))*, then

          1. If ((tid = tid')), then

            1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*, then

              1. The relation holds

  }

  headertype: typeIR ~~ typeIR' {

    1. If ((typeIR has type headerTypeIR)), then

      1. (Let (header tid { (typeIR_f_a id_f ;)* }) be (typeIR as headerTypeIR))

      2. If ((typeIR' has type headerTypeIR)), then

        1. (Let (header tid' { (typeIR_f_b id_f' ;)* }) be (typeIR' as headerTypeIR))

        2. If ((id_f = id_f'))*, then

          1. If ((tid = tid')), then

            1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*, then

              1. The relation holds

  }

  headeruniontype: typeIR ~~ typeIR' {

    1. If ((typeIR has type headerUnionTypeIR)), then

      1. (Let (header_union tid { (typeIR_f_a id_f ;)* }) be (typeIR as headerUnionTypeIR))

      2. If ((typeIR' has type headerUnionTypeIR)), then

        1. (Let (header_union tid' { (typeIR_f_b id_f' ;)* }) be (typeIR' as headerUnionTypeIR))

        2. If ((id_f = id_f'))*, then

          1. If ((tid = tid')), then

            1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*, then

              1. The relation holds

  }

  enumtype: typeIR ~~ typeIR' {

    1. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

        1. (Let (enum tid { id_f* }) be enumTypeIR)

        2. If ((typeIR' has type enumTypeIR)), then

          1. (Let enumTypeIR' be (typeIR' as enumTypeIR))

          2. If ((enumTypeIR' matches pattern `ENUM%{%}`)), then

            1. (Let (enum tid' { id_f'* }) be enumTypeIR')

            2. If ((id_f = id_f'))*, then

              1. If ((tid = tid')), then

                1. The relation holds

  }

  serenumtype: typeIR ~~ typeIR' {

    1. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum tid # typeIR_a { (id_f = value_f ;)* }) be enumTypeIR)

        2. If ((typeIR' has type enumTypeIR)), then

          1. (Let enumTypeIR' be (typeIR' as enumTypeIR))

          2. If ((enumTypeIR' matches pattern `ENUM%#%{%}`)), then

            1. (Let (enum tid' # typeIR_b { (id_f' = value_f' ;)* }) be enumTypeIR')

            2. If ((id_f = id_f'))*, then

              1. If ((tid = tid')), then

                1. If ((value_f = value_f'))*, then

                  1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

                    1. The relation holds

  }

  externtype: typeIR ~~ typeIR' {

    1. If ((typeIR has type externObjectTypeIR)), then

      1. (Let (extern tid ({ (rid_a : routineTypeDefIR_a)* })) be (typeIR as externObjectTypeIR))

      2. If ((typeIR' has type externObjectTypeIR)), then

        1. (Let (extern tid' ({ (rid_b : routineTypeDefIR_b)* })) be (typeIR' as externObjectTypeIR))

        2. If ((tid = tid')), then

          1. If ($eq_set<rid>(({ rid_a* }), ({ rid_b* }))), then

            1. (Let routineTypeDefIR? be $find_map<rid, routineTypeDefIR>(({ (rid_a : routineTypeDefIR_a)* }), rid_a))*

            2. If ((routineTypeDefIR? matches pattern (_)))*, then

              1. (Let ?(routineTypeDefIR_a') be routineTypeDefIR?)*

              2. (Let routineTypeDefIR'? be $find_map<rid, routineTypeDefIR>(({ (rid_b : routineTypeDefIR_b)* }), rid_a))*

              3. If ((routineTypeDefIR'? matches pattern (_)))*, then

                1. (Let ?(routineTypeDefIR_b') be routineTypeDefIR'?)*

                2. If ((RoutineTypeDef_alpha: routineTypeDefIR_a' ~~ routineTypeDefIR_b' holds))*, then

                  1. The relation holds

  }

  parsertype: typeIR ~~ typeIR' {

    1. If ((typeIR has type parserObjectTypeIR)), then

      1. (Let (parser( parameterTypeIR_a* )) be (typeIR as parserObjectTypeIR))

      2. If ((typeIR' has type parserObjectTypeIR)), then

        1. (Let (parser( parameterTypeIR_b* )) be (typeIR' as parserObjectTypeIR))

        2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

          1. The relation holds

  }

  controltype: typeIR ~~ typeIR' {

    1. If ((typeIR has type controlObjectTypeIR)), then

      1. (Let (control( parameterTypeIR_a* )) be (typeIR as controlObjectTypeIR))

      2. If ((typeIR' has type controlObjectTypeIR)), then

        1. (Let (control( parameterTypeIR_b* )) be (typeIR' as controlObjectTypeIR))

        2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

          1. The relation holds

  }

  packagetype: typeIR ~~ typeIR' {

    1. If ((typeIR has type packageObjectTypeIR)), then

      1. (Let (package< typeIR_a* >) be (typeIR as packageObjectTypeIR))

      2. If ((typeIR' has type packageObjectTypeIR)), then

        1. (Let (package< typeIR_b* >) be (typeIR' as packageObjectTypeIR))

        2. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

          1. The relation holds

  }

  tabletype: typeIR ~~ typeIR' {

    1. If ((typeIR has type tableObjectTypeIR)), then

      1. (Let (table tid # typeIR_a) be (typeIR as tableObjectTypeIR))

      2. If ((typeIR' has type tableObjectTypeIR)), then

        1. (Let (table tid' # typeIR_b) be (typeIR' as tableObjectTypeIR))

        2. If ((tid = tid')), then

          1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

            1. The relation holds

  }

  defaulttype: typeIR ~~ typeIR' {

    1. If ((typeIR = ((default) as typeIR))), then

      1. If ((typeIR' = ((default) as typeIR))), then

        1. The relation holds

  }

  sequencetype: typeIR ~~ typeIR' {

    1. If ((typeIR has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

        1. (Let (seq< typeIR_a* >) be sequenceTypeIR)

        2. If ((typeIR' has type sequenceTypeIR)), then

          1. (Let sequenceTypeIR' be (typeIR' as sequenceTypeIR))

          2. If ((sequenceTypeIR' matches pattern `SEQ<%>`)), then

            1. (Let (seq< typeIR_b* >) be sequenceTypeIR')

            2. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

              1. The relation holds

  }

  sequencedefaulttype: typeIR ~~ typeIR' {

    1. If ((typeIR has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

        1. (Let (seq< typeIR_a* ,...>) be sequenceTypeIR)

        2. If ((typeIR' has type sequenceTypeIR)), then

          1. (Let sequenceTypeIR' be (typeIR' as sequenceTypeIR))

          2. If ((sequenceTypeIR' matches pattern `SEQ<%,...>`)), then

            1. (Let (seq< typeIR_b* ,...>) be sequenceTypeIR')

            2. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

              1. The relation holds

  }

  recordtype: typeIR ~~ typeIR' {

    1. If ((typeIR has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%}`)), then

        1. (Let (record{ (typeIR_a id ;)* }) be recordTypeIR)

        2. If ((typeIR' has type recordTypeIR)), then

          1. (Let recordTypeIR' be (typeIR' as recordTypeIR))

          2. If ((recordTypeIR' matches pattern `RECORD{%}`)), then

            1. (Let (record{ (typeIR_b id' ;)* }) be recordTypeIR')

            2. If ((id = id'))*, then

              1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

                1. The relation holds

  }

  recorddefaulttype: typeIR ~~ typeIR' {

    1. If ((typeIR has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

        1. (Let (record{ (typeIR_a id ;)* ,...}) be recordTypeIR)

        2. If ((typeIR' has type recordTypeIR)), then

          1. (Let recordTypeIR' be (typeIR' as recordTypeIR))

          2. If ((recordTypeIR' matches pattern `RECORD{%,...}`)), then

            1. (Let (record{ (typeIR_b id' ;)* ,...}) be recordTypeIR')

            2. If ((id = id'))*, then

              1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

                1. The relation holds

  }

  invalidtype: typeIR ~~ typeIR' {

    1. If ((typeIR = ((header_invalid) as typeIR))), then

      1. If ((typeIR' = ((header_invalid) as typeIR))), then

        1. The relation holds

  }

  settype: typeIR' ~~ typeIR''' {

    1. If ((typeIR' has type setTypeIR)), then

      1. (Let (set< typeIR* >) be (typeIR' as setTypeIR))

      2. If ((typeIR* matches pattern [ _/1 ])), then

        1. (Let [typeIR_a] be typeIR*)

        2. If ((typeIR''' has type setTypeIR)), then

          1. (Let (set< typeIR''* >) be (typeIR''' as setTypeIR))

          2. If ((typeIR''* matches pattern [ _/1 ])), then

            1. (Let [typeIR_b] be typeIR''*)

            2. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

              1. The relation holds

  }

  tableenumtype: typeIR ~~ typeIR' {

    1. If ((typeIR has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TABLE_ENUM%{%}`)), then

        1. (Let (table_enum tid { id_f* }) be tableTypeIR)

        2. If ((typeIR' has type tableTypeIR)), then

          1. (Let tableTypeIR' be (typeIR' as tableTypeIR))

          2. If ((tableTypeIR' matches pattern `TABLE_ENUM%{%}`)), then

            1. (Let (table_enum tid' { id_f'* }) be tableTypeIR')

            2. If ((id_f = id_f'))*, then

              1. If ((tid = tid')), then

                1. The relation holds

  }

  tablestructtype: typeIR ~~ typeIR' {

    1. If ((typeIR has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

        1. (Let (table_struct tid { (typeIR_f_a id_f ;)* }) be tableTypeIR)

        2. If ((typeIR' has type tableTypeIR)), then

          1. (Let tableTypeIR' be (typeIR' as tableTypeIR))

          2. If ((tableTypeIR' matches pattern `TABLE_STRUCT%{%}`)), then

            1. (Let (table_struct tid' { (typeIR_f_b id_f' ;)* }) be tableTypeIR')

            2. If ((id_f = id_f'))*, then

              1. If ((tid = tid')), then

                1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*, then

                  1. The relation holds

  }

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:9.1-11.20
relation ParameterType_alpha: 

  : _direction typeIR_a _id _value?{_value <- _value?} ~~ _direction' typeIR_b _id' _value'?{_value' <- _value'?} {

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. The relation holds

  }

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:13.1-15.20
relation RoutineType_alpha: 

  builtinfunction: routineTypeIR ~~ routineTypeIR' {

    1. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `BUILTIN_FUNCTION(%)->%`)), then

        1. (Let (builtin_function( parameterTypeIR_a* )-> typeIR_ret_a) be functionTypeIR)

        2. If ((routineTypeIR' has type functionTypeIR)), then

          1. (Let functionTypeIR' be (routineTypeIR' as functionTypeIR))

          2. If ((functionTypeIR' matches pattern `BUILTIN_FUNCTION(%)->%`)), then

            1. (Let (builtin_function( parameterTypeIR_b* )-> typeIR_ret_b) be functionTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

                1. The relation holds

  }

  function: routineTypeIR ~~ routineTypeIR' {

    1. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `FUNCTION(%)->%`)), then

        1. (Let (function( parameterTypeIR_a* )-> typeIR_ret_a) be functionTypeIR)

        2. If ((routineTypeIR' has type functionTypeIR)), then

          1. (Let functionTypeIR' be (routineTypeIR' as functionTypeIR))

          2. If ((functionTypeIR' matches pattern `FUNCTION(%)->%`)), then

            1. (Let (function( parameterTypeIR_b* )-> typeIR_ret_b) be functionTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

                1. The relation holds

  }

  action: routineTypeIR ~~ routineTypeIR' {

    1. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `ACTION(%)`)), then

        1. (Let (action( parameterTypeIR_a* )) be functionTypeIR)

        2. If ((routineTypeIR' has type functionTypeIR)), then

          1. (Let functionTypeIR' be (routineTypeIR' as functionTypeIR))

          2. If ((functionTypeIR' matches pattern `ACTION(%)`)), then

            1. (Let (action( parameterTypeIR_b* )) be functionTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. The relation holds

  }

  externfunction: routineTypeIR ~~ routineTypeIR' {

    1. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `EXTERN_FUNCTION(%)->%`)), then

        1. (Let (extern_function( parameterTypeIR_a* )-> typeIR_ret_a) be functionTypeIR)

        2. If ((routineTypeIR' has type functionTypeIR)), then

          1. (Let functionTypeIR' be (routineTypeIR' as functionTypeIR))

          2. If ((functionTypeIR' matches pattern `EXTERN_FUNCTION(%)->%`)), then

            1. (Let (extern_function( parameterTypeIR_b* )-> typeIR_ret_b) be functionTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

                1. The relation holds

  }

  builtinmethod: routineTypeIR ~~ routineTypeIR' {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `BUILTIN_METHOD(%)->%`)), then

        1. (Let (builtin_method( parameterTypeIR_a* )-> typeIR_ret_a) be methodTypeIR)

        2. If ((routineTypeIR' has type methodTypeIR)), then

          1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

          2. If ((methodTypeIR' matches pattern `BUILTIN_METHOD(%)->%`)), then

            1. (Let (builtin_method( parameterTypeIR_b* )-> typeIR_ret_b) be methodTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

                1. The relation holds

  }

  externmethod: routineTypeIR ~~ routineTypeIR' {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `EXTERN_METHOD(%)->%`)), then

        1. (Let (extern_method( parameterTypeIR_a* )-> typeIR_ret_a) be methodTypeIR)

        2. If ((routineTypeIR' has type methodTypeIR)), then

          1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

          2. If ((methodTypeIR' matches pattern `EXTERN_METHOD(%)->%`)), then

            1. (Let (extern_method( parameterTypeIR_b* )-> typeIR_ret_b) be methodTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

                1. The relation holds

  }

  externmethod-abstract: routineTypeIR ~~ routineTypeIR' {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

        1. (Let (extern_methodabstract( parameterTypeIR_a* )-> typeIR_ret_a) be methodTypeIR)

        2. If ((routineTypeIR' has type methodTypeIR)), then

          1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

          2. If ((methodTypeIR' matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

            1. (Let (extern_methodabstract( parameterTypeIR_b* )-> typeIR_ret_b) be methodTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

                1. The relation holds

  }

  parserapply: routineTypeIR ~~ routineTypeIR' {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `PARSER_APPLY(%)`)), then

        1. (Let (parser_apply( parameterTypeIR_a* )) be methodTypeIR)

        2. If ((routineTypeIR' has type methodTypeIR)), then

          1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

          2. If ((methodTypeIR' matches pattern `PARSER_APPLY(%)`)), then

            1. (Let (parser_apply( parameterTypeIR_b* )) be methodTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. The relation holds

  }

  controlapply: routineTypeIR ~~ routineTypeIR' {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `CONTROL_APPLY(%)`)), then

        1. (Let (control_apply( parameterTypeIR_a* )) be methodTypeIR)

        2. If ((routineTypeIR' has type methodTypeIR)), then

          1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

          2. If ((methodTypeIR' matches pattern `CONTROL_APPLY(%)`)), then

            1. (Let (control_apply( parameterTypeIR_b* )) be methodTypeIR')

            2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

              1. The relation holds

  }

  tableapply: routineTypeIR ~~ routineTypeIR' {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `TABLE_APPLY->%`)), then

        1. (Let (table_apply-> typeIR_ret_a) be methodTypeIR)

        2. If ((routineTypeIR' has type methodTypeIR)), then

          1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

          2. If ((methodTypeIR' matches pattern `TABLE_APPLY->%`)), then

            1. (Let (table_apply-> typeIR_ret_b) be methodTypeIR')

            2. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

              1. The relation holds

  }

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:17.1-19.20
relation RoutineTypeDef_alpha: 

  mono: routineTypeDefIR ~~ routineTypeDefIR' {

    1. If ((routineTypeDefIR has type routineTypeIR)), then

      1. (Let routineTypeIR_a be (routineTypeDefIR as routineTypeIR))

      2. If ((routineTypeDefIR' has type routineTypeIR)), then

        1. (Let routineTypeIR_b be (routineTypeDefIR' as routineTypeIR))

        2. If ((RoutineType_alpha: routineTypeIR_a ~~ routineTypeIR_b holds)), then

          1. The relation holds

  }

  poly: routineTypeDefIR ~~ routineTypeDefIR' {

    1. If ((routineTypeDefIR has type polyRoutineTypeDefIR)), then

      1. (Let (routineTypeIR_a < tid_a* , tid_hidden_a* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

      2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

        1. (Let (routineTypeIR_b < tid_b* , tid_hidden_b* >) be (routineTypeDefIR' as polyRoutineTypeDefIR))

        2. If ((|tid_a*| = |tid_b*|)), then

          1. If ((|tid_hidden_a*| = |tid_hidden_b*|)), then

            1. (Let tid_fresh* be $fresh_tids((|tid_a*| + |tid_hidden_a*|)))

            2. (Let tid_a'* be tid_a* ++ tid_hidden_a*)

            3. (Let theta_a be ({ (tid_a' : ((tid tid_fresh) as typeIR))* }))

            4. (Let routineTypeIR_a_subst be $subst_routineType(theta_a, routineTypeIR_a))

            5. (Let tid_b'* be tid_b* ++ tid_hidden_b*)

            6. (Let theta_b be ({ (tid_b' : ((tid tid_fresh) as typeIR))* }))

            7. (Let routineTypeIR_b_subst be $subst_routineType(theta_b, routineTypeIR_b))

            8. If ((RoutineType_alpha: routineTypeIR_a_subst ~~ routineTypeIR_b_subst holds)), then

              1. The relation holds

  }

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:5.14-5.30
syntax ctk = 
   | lctk
   | ctk
   | dyn

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:7.1-7.30
def $join_ctk(ctk'', ctk''')

1. Case analysis on ctk''

  1. Case (% matches pattern `LCTK`)

    1. Case analysis on ctk'''

      1. Case (% matches pattern `LCTK`)

        1. Return (lctk)

      2. Case (% matches pattern `CTK`)

        1. Return (ctk)

  2. Case (% matches pattern `CTK`)

    1. Case analysis on ctk'''

      1. Case (% matches pattern `LCTK`)

        1. Return (ctk)

      2. Case (% matches pattern `CTK`)

        1. Return (ctk)

2. Otherwise

  1. Return (dyn)

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:16.1-16.27
def $joins_ctk(ctk''*)

1. Case analysis on ctk''*

  1. Case (% matches pattern [])

    1. Return (dyn)

  2. Case (% matches pattern [ _/1 ])

    1. (Let [ctk''] be ctk''*)

    2. Return ctk''

  3. Case (% matches pattern _ :: _)

    1. (Let ctk_a :: ctk''* be ctk''*)

    2. Case analysis on ctk''*

      1. Case (% matches pattern [ _/1 ])

        1. (Let [ctk_b] be ctk''*)

        2. Return $join_ctk(ctk_a, ctk_b)

      2. Case (% matches pattern _ :: _)

        1. (Let ctk_b :: ctk_c* be ctk''*)

        2. (Let ctk_d be $join_ctk(ctk_a, ctk_b))

        3. Return $joins_ctk(ctk_d :: ctk_c*)

;; ../../../../spec-concrete/3-numerics.watsup:5.1-5.21
def $pow2



;; ../../../../spec-concrete/3-numerics.watsup:7.1-7.25
def $shl



;; ../../../../spec-concrete/3-numerics.watsup:8.1-8.25
def $shr



;; ../../../../spec-concrete/3-numerics.watsup:9.1-9.36
def $shr_arith



;; ../../../../spec-concrete/3-numerics.watsup:11.1-11.21
def $bneg



;; ../../../../spec-concrete/3-numerics.watsup:12.1-12.26
def $band



;; ../../../../spec-concrete/3-numerics.watsup:13.1-13.26
def $bxor



;; ../../../../spec-concrete/3-numerics.watsup:14.1-14.25
def $bor



;; ../../../../spec-concrete/3-numerics.watsup:16.1-16.33
def $bitacc



;; ../../../../spec-concrete/3-numerics.watsup:24.1-24.28
def $un_bnot(value)

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `%W%`)), then

    1. (Let (w w i) be numberLiteral)

    2. (Let i' be $bneg(i))

    3. Return ((w w i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:31.1-31.28
def $un_lnot(value)

1. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `B%`)), then

    1. (Let (b b) be primitiveValue)

    2. Return ((b ~b) as value)

;; ../../../../spec-concrete/3-numerics.watsup:37.1-37.28
def $un_plus(value)

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i) be numberLiteral)

      2. Return ((d i) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i) be numberLiteral)

      2. Return ((w w i) as value)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i) be numberLiteral)

      2. Return ((w s i) as value)

;; ../../../../spec-concrete/3-numerics.watsup:45.1-45.29
def $un_minus(value)

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i) be numberLiteral)

      2. Return ((d -i) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i) be numberLiteral)

      2. (Let i' be ($pow2(w) - i))

      3. Return ((w w i') as value)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i) be numberLiteral)

      2. (Let i' be $to_bitstr((w as int), $to_int((w as int), -i)))

      3. Return ((w s i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:59.1-59.36
def $bin_plus(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `D%`)), then

          1. (Let (d i_r) be numberLiteral')

          2. Return ((d (i_l + i_r)) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), (i_l' + i_r')))

            4. Return ((w w i') as value)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), (i_l' + i_r')))

            4. Return ((w s i') as value)

            5. (Let i' be $to_bitstr((w as int), (i_l' - i_r')))

            6. Return ((w s i') as value)

            7. (Let i' be $to_bitstr((w as int), (i_l' * i_r')))

            8. Return ((w s i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:73.1-73.39
def $bin_satplus



;; ../../../../spec-concrete/3-numerics.watsup:77.1-77.37
def $bin_minus(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `D%`)), then

          1. (Let (d i_r) be numberLiteral')

          2. Return ((d (i_l - i_r)) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), (i_l' - i_r')))

            4. Return ((w w i') as value)

            5. (Let i' be $to_bitstr((w as int), (i_l' * i_r')))

            6. Return ((w w i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:91.1-91.40
def $bin_satminus



;; ../../../../spec-concrete/3-numerics.watsup:95.1-95.35
def $bin_mul(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `D%`)), then

    1. (Let (d i_l) be numberLiteral)

    2. If ((value' has type numberLiteral)), then

      1. (Let numberLiteral' be (value' as numberLiteral))

      2. If ((numberLiteral' matches pattern `D%`)), then

        1. (Let (d i_r) be numberLiteral')

        2. Return ((d (i_l * i_r)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:109.1-109.35
def $bin_div(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `D%`)), then

    1. (Let (d i_l) be numberLiteral)

    2. If ((value' has type numberLiteral)), then

      1. (Let numberLiteral' be (value' as numberLiteral))

      2. If ((numberLiteral' matches pattern `D%`)), then

        1. (Let (d i_r) be numberLiteral')

        2. Return ((d (i_l / i_r)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:115.1-115.35
def $bin_mod(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `D%`)), then

    1. (Let (d i_l) be numberLiteral)

    2. If ((value' has type numberLiteral)), then

      1. (Let numberLiteral' be (value' as numberLiteral))

      2. If ((numberLiteral' matches pattern `D%`)), then

        1. (Let (d i_r) be numberLiteral')

        2. Return ((d (i_l \ i_r)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:121.1-121.35
def $bin_shl(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be numberLiteral')

            2. Return ((d $shl(i_l, i_r)) as value)

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. Return ((d $shl(i_l, i_r)) as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. Return ((d $shl(i_l, i_r')) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w_l w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be numberLiteral')

            2. Return $bin_shl(((w_l w i_l) as value), ((w_l w $to_int((w_l as int), i_r)) as value))

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. (Let i' be $to_bitstr((w_l as int), $shl(i_l, i_r)))

            3. Return ((w_l w i') as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. (Let i' be $to_bitstr((w_l as int), $shl(i_l, i_r')))

            4. Return ((w_l w i') as value)

    3. Case (% matches pattern `%S%`)

      1. (Let (w_l s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be numberLiteral')

            2. Return $bin_shl(((w_l s i_l) as value), ((w_l s $to_int((w_l as int), i_r)) as value))

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i' be $to_bitstr((w_l as int), $shl(i_l', i_r)))

            4. Return ((w_l s i') as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_r' be $to_int((w_r as int), i_r))

            4. (Let i' be $to_bitstr((w_l as int), $shl(i_l', i_r')))

            5. Return ((w_l s i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:148.1-148.35
def $bin_shr(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be numberLiteral')

            2. Return ((d $shr(i_l, i_r)) as value)

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. Return ((d $shr(i_l, i_r)) as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. Return ((d $shr(i_l, i_r')) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w_l w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be numberLiteral')

            2. Return $bin_shr(((w_l w i_l) as value), ((w_l w $to_int((w_l as int), i_r)) as value))

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. (Let i' be $to_bitstr((w_l as int), $shr(i_l, i_r)))

            3. Return ((w_l w i') as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. (Let i' be $to_bitstr((w_l as int), $shr(i_l, i_r')))

            4. Return ((w_l w i') as value)

    3. Case (% matches pattern `%S%`)

      1. (Let (w_l s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. If ((i_l' < (0 as int))), then

              1. (Let i' be $shr_arith(i_l, i_r, ($pow2(w_l) - (1 as int))))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

            4. If ((i_l' >= (0 as int))), then

              1. (Let i' be $shr(i_l, i_r))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. If ((i_l' < (0 as int))), then

              1. (Let i' be $shr_arith(i_l, i_r, ($pow2(w_l) - (1 as int))))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

            4. If ((i_l' >= (0 as int))), then

              1. (Let i' be $shr(i_l, i_r))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_r' be $to_int((w_r as int), i_r))

            4. If ((i_l' < (0 as int))), then

              1. (Let i' be $shr_arith(i_l, i_r, ($pow2(w_l) - (1 as int))))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

            5. If ((i_l' >= (0 as int))), then

              1. (Let i' be $shr(i_l, i_r))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

;; ../../../../spec-concrete/3-numerics.watsup:198.1-198.33
def $bin_le(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `D%`)), then

          1. (Let (d i_r) be numberLiteral')

          2. Return (i_l <= i_r)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. Return (i_l <= i_r)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' <= i_r')

;; ../../../../spec-concrete/3-numerics.watsup:208.1-208.33
def $bin_ge(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `D%`)), then

          1. (Let (d i_r) be numberLiteral')

          2. Return (i_l >= i_r)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. Return (i_l >= i_r)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' >= i_r')

;; ../../../../spec-concrete/3-numerics.watsup:218.1-218.33
def $bin_lt(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `D%`)), then

          1. (Let (d i_r) be numberLiteral')

          2. Return (i_l < i_r)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. Return (i_l < i_r)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' < i_r')

;; ../../../../spec-concrete/3-numerics.watsup:228.1-228.33
def $bin_gt(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `D%`)), then

          1. (Let (d i_r) be numberLiteral')

          2. Return (i_l > i_r)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. Return (i_l > i_r)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' > i_r')

;; ../../../../spec-concrete/3-numerics.watsup:238.1-238.33
def $bin_eq(value, value')

1. Case analysis on value

  1. Case (% has type primitiveValue)

    1. (Let primitiveValue_a be (value as primitiveValue))

    2. If ((value' has type primitiveValue)), then

      1. (Let primitiveValue_b be (value' as primitiveValue))

      2. Return (primitiveValue_a = primitiveValue_b)

  2. Case (% has type numberLiteral)

    1. (Let numberLiteral be (value as numberLiteral))

    2. Case analysis on numberLiteral

      1. Case (% matches pattern `D%`)

        1. (Let (d i_a) be numberLiteral)

        2. If ((value' has type numberLiteral)), then

          1. (Let numberLiteral' be (value' as numberLiteral))

          2. If ((numberLiteral' matches pattern `D%`)), then

            1. (Let (d i_b) be numberLiteral')

            2. Return (i_a = i_b)

      2. Case (% matches pattern `%W%`)

        1. (Let (w_a w i_a) be numberLiteral)

        2. If ((value' has type numberLiteral)), then

          1. (Let numberLiteral' be (value' as numberLiteral))

          2. If ((numberLiteral' matches pattern `%W%`)), then

            1. (Let (w_b w i_b) be numberLiteral')

            2. Return ((w_a = w_b) /\ (i_a = i_b))

      3. Case (% matches pattern `%S%`)

        1. (Let (w_a s i_a) be numberLiteral)

        2. If ((value' has type numberLiteral)), then

          1. (Let numberLiteral' be (value' as numberLiteral))

          2. If ((numberLiteral' matches pattern `%S%`)), then

            1. (Let (w_b s i_b) be numberLiteral')

            2. Return ((w_a = w_b) /\ (i_a = i_b))

  3. Case (% has type listValue)

    1. (Let ([ value_a* ]) be (value as listValue))

    2. If ((value' has type listValue)), then

      1. (Let ([ value_b* ]) be (value' as listValue))

      2. Return $bin_eqs(value_a*, value_b*)

  4. Case (% has type tupleValue)

    1. (Let (( value_a* )) be (value as tupleValue))

    2. If ((value' has type tupleValue)), then

      1. (Let (( value_b* )) be (value' as tupleValue))

      2. Return $bin_eqs(value_a*, value_b*)

  5. Case (% has type headerStackValue)

    1. (Let ([ value_a* #( _nat ; n_s_a )]) be (value as headerStackValue))

    2. If ((value' has type headerStackValue)), then

      1. (Let ([ value_b* #( _nat' ; n_s_b )]) be (value' as headerStackValue))

      2. Return ($bin_eqs(value_a*, value_b*) /\ (n_s_a = n_s_b))

  6. Case (% has type structValue)

    1. (Let (struct tid_a { (value_f_a id_f_a ;)* }) be (value as structValue))

    2. If ((value' has type structValue)), then

      1. (Let (struct tid_b { (value_f_b id_f_b ;)* }) be (value' as structValue))

      2. Return ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*, (value_f_b, id_f_b)*))

  7. Case (% has type headerValue)

    1. (Let (header tid_a { (value_f_a id_f_a ;)* }) be (value as headerValue))

    2. If ((value' has type headerValue)), then

      1. (Let (header tid_b { (value_f_b id_f_b ;)* }) be (value' as headerValue))

      2. Return ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*, (value_f_b, id_f_b)*))

  8. Case (% has type headerUnionValue)

    1. (Let (header_union tid_a { (value_f_a id_f_a ;)* }) be (value as headerUnionValue))

    2. If ((value' has type headerUnionValue)), then

      1. (Let (header_union tid_b { (value_f_b id_f_b ;)* }) be (value' as headerUnionValue))

      2. Return ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*, (value_f_b, id_f_b)*))

  9. Case (% has type enumValue)

    1. (Let enumValue be (value as enumValue))

    2. Case analysis on enumValue

      1. Case (% matches pattern `%.%`)

        1. (Let (tid_a . id_f_a) be enumValue)

        2. If ((value' has type enumValue)), then

          1. (Let enumValue' be (value' as enumValue))

          2. If ((enumValue' matches pattern `%.%`)), then

            1. (Let (tid_b . id_f_b) be enumValue')

            2. Return ((tid_a = tid_b) /\ (id_f_a = id_f_b))

      2. Case (% matches pattern `%.%#%`)

        1. (Let (tid_a . id_f_a # value_f_a) be enumValue)

        2. If ((value' has type enumValue)), then

          1. (Let enumValue' be (value' as enumValue))

          2. If ((enumValue' matches pattern `%.%#%`)), then

            1. (Let (tid_b . id_f_b # value_f_b) be enumValue')

            2. Return (((tid_a = tid_b) /\ (id_f_a = id_f_b)) /\ $bin_eq(value_f_a, value_f_b))

2. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. If ((numberValue matches pattern `%V%#%`)), then

    1. (Let (w_a v i_a # _nat) be numberValue)

    2. If ((value' has type numberValue)), then

      1. (Let numberValue' be (value' as numberValue))

      2. If ((numberValue' matches pattern `%V%#%`)), then

        1. (Let (w_b v i_b # _nat') be numberValue')

        2. Return ((w_a = w_b) /\ (i_a = i_b))

3. If ((value = (({#}) as value))), then

  1. If ((value' = (({#}) as value))), then

    1. Return true

;; ../../../../spec-concrete/3-numerics.watsup:239.1-239.36
def $bin_eqs(value*, value'*)

1. Case analysis on value*

  1. Case (% matches pattern [])

    1. Case analysis on value'*

      1. Case (% matches pattern [])

        1. Return true

      2. Case (% matches pattern _ :: _)

        1. (Let _value :: _value'* be value'*)

        2. Return false

  2. Case (% matches pattern _ :: _)

    1. (Let _value :: _value'* be value*)

    2. If ((value'* matches pattern [])), then

      1. Return false

    3. (Let value_a_h :: value_a_t* be value*)

    4. If ((value'* matches pattern _ :: _)), then

      1. (Let value_b_h :: value_b_t* be value'*)

      2. Return ($bin_eq(value_a_h, value_b_h) /\ $bin_eqs(value_a_t*, value_b_t*))

;; ../../../../spec-concrete/3-numerics.watsup:240.1-240.55
def $bin_eqs_fields((value, id)*, (value, id)'*)

1. Case analysis on (value, id)*

  1. Case (% matches pattern [])

    1. Case analysis on (value, id)'*

      1. Case (% matches pattern [])

        1. Return true

      2. Case (% matches pattern _ :: _)

        1. (Let _(value, id) :: _(value, id)'* be (value, id)'*)

        2. Return false

  2. Case (% matches pattern _ :: _)

    1. (Let _(value, id) :: _(value, id)'* be (value, id)*)

    2. If (((value, id)'* matches pattern [])), then

      1. Return false

    3. (Let (value_a_h, id_a_h) :: (value_a_t, id_a_t)* be (value, id)*)

    4. If (((value, id)'* matches pattern _ :: _)), then

      1. (Let (value_b_h, id_b_h) :: (value_b_t, id_b_t)* be (value, id)'*)

      2. Return (((id_a_h = id_b_h) /\ $bin_eq(value_a_h, value_b_h)) /\ $bin_eqs_fields((value_a_t, id_a_t)*, (value_b_t, id_b_t)*))

;; ../../../../spec-concrete/3-numerics.watsup:297.1-297.33
def $bin_ne(value_l, value_r)

1. Return ~$bin_eq(value_l, value_r)

;; ../../../../spec-concrete/3-numerics.watsup:303.1-303.36
def $bin_band(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i' be $to_bitstr((w as int), $band(i_l, i_r)))

            2. Return ((w w i') as value)

    2. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), $band(i_l', i_r')))

            4. Return ((w s i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:315.1-315.36
def $bin_bxor(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i' be $to_bitstr((w as int), $bxor(i_l, i_r)))

            2. Return ((w w i') as value)

    2. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), $bxor(i_l', i_r')))

            4. Return ((w s i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:327.1-327.35
def $bin_bor(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i' be $to_bitstr((w as int), $bor(i_l, i_r)))

            2. Return ((w w i') as value)

    2. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), $bor(i_l', i_r')))

            4. Return ((w s i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:339.1-339.38
def $bin_concat(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `%W%`)

      1. (Let (w_l w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. (Let i_l' be $shl(i_l, (w_r as int)))

            3. (Let i_l'' be (i_l' + i_r))

            4. (Let w be (w_l + w_r))

            5. (Let i'' be $to_bitstr((w as int), i_l''))

            6. Return ((w w i'') as value)

          2. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_l' be $shl(i_l, (w_r as int)))

            3. (Let i_l'' be (i_l' + i_r))

            4. (Let w be (w_l + w_r))

            5. (Let i'' be $to_bitstr((w as int), i_l''))

            6. Return ((w w i'') as value)

    2. Case (% matches pattern `%S%`)

      1. (Let (w_l s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_l'' be $shl(i_l', (w_r as int)))

            4. (Let i_l''' be (i_l'' + i_r))

            5. (Let w be (w_l + w_r))

            6. (Let i''' be $to_bitstr((w as int), i_l'''))

            7. Return ((w s i''') as value)

          2. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_l'' be $shl(i_l', (w_r as int)))

            4. (Let i_l''' be (i_l'' + i_r))

            5. (Let w be (w_l + w_r))

            6. (Let i''' be $to_bitstr((w as int), i_l'''))

            7. Return ((w s i''') as value)

;; ../../../../spec-concrete/3-numerics.watsup:367.1-367.36
def $bin_land(value, value')

1. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `B%`)), then

    1. (Let (b b_l) be primitiveValue)

    2. If ((value' has type primitiveValue)), then

      1. (Let primitiveValue' be (value' as primitiveValue))

      2. If ((primitiveValue' matches pattern `B%`)), then

        1. (Let (b b_r) be primitiveValue')

        2. Return ((b (b_l /\ b_r)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:373.1-373.35
def $bin_lor(value, value')

1. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `B%`)), then

    1. (Let (b b_l) be primitiveValue)

    2. If ((value' has type primitiveValue)), then

      1. (Let primitiveValue' be (value' as primitiveValue))

      2. If ((primitiveValue' matches pattern `B%`)), then

        1. (Let (b b_r) be primitiveValue')

        2. Return ((b (b_l \/ b_r)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:381.1-381.36
def $cast_op(typeIR, value'')

1. Case analysis on value''

  1. Case (% has type primitiveValue)

    1. (Let primitiveValue be (value'' as primitiveValue))

    2. If ((primitiveValue matches pattern `B%`)), then

      1. (Let (b b) be primitiveValue)

      2. Return $cast_bool(typeIR, b)

  2. Case (% has type numberLiteral)

    1. (Let numberLiteral be (value'' as numberLiteral))

    2. Case analysis on numberLiteral

      1. Case (% matches pattern `D%`)

        1. (Let (d i) be numberLiteral)

        2. Return $cast_arbint(typeIR, i)

      2. Case (% matches pattern `%W%`)

        1. (Let (w w i) be numberLiteral)

        2. Return $cast_fixbit(typeIR, w, i)

      3. Case (% matches pattern `%S%`)

        1. (Let (w s i) be numberLiteral)

        2. Return $cast_fixint(typeIR, w, i)

  3. Case (% has type structValue)

    1. (Let (struct tid { (value_f id_f ;)* }) be (value'' as structValue))

    2. Return $cast_struct(typeIR, tid, (value_f, id_f)*)

  4. Case (% has type headerValue)

    1. (Let (header tid { (value_f id_f ;)* }) be (value'' as headerValue))

    2. Return $cast_header(typeIR, tid, (value_f, id_f)*)

  5. Case (% has type enumValue)

    1. (Let enumValue be (value'' as enumValue))

    2. If ((enumValue matches pattern `%.%#%`)), then

      1. (Let (_tid . _id # value'') be enumValue)

      2. Return $cast_op(typeIR, value'')

  6. Case (% has type sequenceValue)

    1. (Let sequenceValue be (value'' as sequenceValue))

    2. If ((sequenceValue matches pattern `SEQ(%)`)), then

      1. (Let (seq( value''* )) be sequenceValue)

      2. Return $cast_sequence(typeIR, value''*)

  7. Case (% has type recordValue)

    1. (Let recordValue be (value'' as recordValue))

    2. If ((recordValue matches pattern `RECORD{%}`)), then

      1. (Let (record{ (value'' id ;)* }) be recordValue)

      2. Return $cast_record(typeIR, (value'', id)*)

  8. Case (% has type setValue)

    1. (Let setValue be (value'' as setValue))

    2. Case analysis on setValue

      1. Case (% matches pattern `SET{%}`)

        1. (Let (set{ value'' }) be setValue)

        2. Return $cast_set_singleton(typeIR, value'')

      2. Case (% matches pattern `SET{%&&&%}`)

        1. (Let (set{ value_b &&& value_m }) be setValue)

        2. Return $cast_set_mask(typeIR, value_b, value_m)

      3. Case (% matches pattern `SET{%..%}`)

        1. (Let (set{ value_l .. value_u }) be setValue)

        2. Return $cast_set_range(typeIR, value_l, value_u)

2. If ((value'' = ((default) as value))), then

  1. Return $default(typeIR)

;; ../../../../spec-concrete/3-numerics.watsup:383.1-383.29
def $default(typeIR)

1. Return $default'($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:384.1-384.30
def $default'(typeIR'')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return ((b false) as value)

2. If ((typeIR'' = ((error) as typeIR))), then

  1. Return ((error. "NoError") as value)

3. If ((typeIR'' = ((string) as typeIR))), then

  1. (Let text_empty be "")

  2. Return ((" text_empty ") as value)

4. If ((typeIR'' = ((int) as typeIR))), then

  1. Return ((d (0 as int)) as value)

5. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< w >) be numberTypeIR)

        2. Return ((w w (0 as int)) as value)

      2. Case (% matches pattern `INT<%>`)

        1. (Let (int< w >) be numberTypeIR)

        2. Return ((w s (0 as int)) as value)

      3. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< w >) be numberTypeIR)

        2. Return ((w v (0 as int) # 0) as value)

  2. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. Return (([ $default(typeIR'')* ]) as value)

  3. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ n_s ]) be (typeIR'' as headerStackTypeIR))

    2. (Let value* be $repeat_<value>($default(typeIR''), n_s))

    3. Return (([ value* #( 0 ; n_s )]) as value)

  4. Case (% has type structTypeIR)

    1. (Let (struct tid { (typeIR_f id_f ;)* }) be (typeIR'' as structTypeIR))

    2. Return ((struct tid { ($default(typeIR_f) id_f ;)* }) as value)

  5. Case (% has type headerTypeIR)

    1. (Let (header tid { (typeIR_f id_f ;)* }) be (typeIR'' as headerTypeIR))

    2. Return ((header tid { ($default(typeIR_f) id_f ;)* }) as value)

  6. Case (% has type headerUnionTypeIR)

    1. (Let (header_union tid { (typeIR_f id_f ;)* }) be (typeIR'' as headerUnionTypeIR))

    2. Return ((header_union tid { ($default(typeIR_f) id_f ;)* }) as value)

  7. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum tid { id* }) be enumTypeIR)

        2. If ((id* matches pattern _ :: _)), then

          1. (Let id_f_h :: _id* be id*)

          2. Return ((tid . id_f_h) as value)

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum tid # typeIR'' { (id_f = value_f ;)* }) be enumTypeIR)

        2. (Let value_zero be $cast_arbint(typeIR'', (0 as int)))

        3. (Let id? be $assoc_<value, id>(value_zero, (value_f, id_f)*))

        4. If ((id? matches pattern (_))), then

          1. (Let ?(id_zero) be id?)

          2. Return ((tid . id_zero # value_zero) as value)

        5. If ((?() = $assoc_<value, id>(value_zero, (value_f, id_f)*))), then

          1. (Let id_zero be "__UNSPECIFIED")

          2. Return ((tid . id_zero # value_zero) as value)

;; ../../../../spec-concrete/3-numerics.watsup:388.1-388.37
def $cast_bool(typeIR, b)

1. Return $cast_bool'($canon(typeIR), b)

;; ../../../../spec-concrete/3-numerics.watsup:389.1-389.38
def $cast_bool'(typeIR'', b')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return ((b b') as value)

2. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `BIT<%>`)), then

      1. (Let (bit< w >) be numberTypeIR)

      2. Case analysis on b'

        1. Case (% = true)

          1. Return ((w w (1 as int)) as value)

        2. Case (% = false)

          1. Return ((w w (0 as int)) as value)

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $cast_bool(typeIR'', b')

;; ../../../../spec-concrete/3-numerics.watsup:402.1-402.38
def $cast_arbint(typeIR, i)

1. Return $cast_arbint'($canon(typeIR), i)

;; ../../../../spec-concrete/3-numerics.watsup:403.1-403.39
def $cast_arbint'(typeIR''', i)

1. If ((typeIR''' = ((bool) as typeIR))), then

  1. Return ((b (i = (0 as int))) as value)

2. If ((typeIR''' = ((int) as typeIR))), then

  1. Return ((d i) as value)

3. Case analysis on typeIR'''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR''' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< w >) be numberTypeIR)

        2. Return ((w w $to_bitstr((w as int), i)) as value)

      2. Case (% matches pattern `INT<%>`)

        1. (Let (int< w >) be numberTypeIR)

        2. Return ((w s $to_bitstr((w as int), i)) as value)

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR''') be aliasTypeIR)

      2. Return $cast_arbint(typeIR''', i)

  3. Case (% has type setTypeIR)

    1. (Let (set< typeIR'''* >) be (typeIR''' as setTypeIR))

    2. If ((typeIR'''* matches pattern [ _/1 ])), then

      1. (Let [typeIR'''] be typeIR'''*)

      2. Return ((set{ $cast_arbint(typeIR''', i) }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:418.1-418.43
def $cast_fixbit(typeIR, w, i)

1. Return $cast_fixbit'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:419.1-419.44
def $cast_fixbit'(typeIR''', w', i)

1. If ((typeIR''' = ((bool) as typeIR))), then

  1. Return ((b (i = (1 as int))) as value)

2. If ((typeIR''' = ((int) as typeIR))), then

  1. Return ((d i) as value)

3. Case analysis on typeIR'''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR''' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< w_to >) be numberTypeIR)

        2. (Let i' be $to_bitstr((w_to as int), i))

        3. Return ((w_to w i') as value)

      2. Case (% matches pattern `INT<%>`)

        1. (Let (int< w_to >) be numberTypeIR)

        2. (Let i' be $to_bitstr((w_to as int), i))

        3. Return ((w_to s i') as value)

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR''') be aliasTypeIR)

      2. Return $cast_fixbit(typeIR''', w', i)

  3. Case (% has type setTypeIR)

    1. (Let (set< typeIR'''* >) be (typeIR''' as setTypeIR))

    2. If ((typeIR'''* matches pattern [ _/1 ])), then

      1. (Let [typeIR'''] be typeIR'''*)

      2. Return ((set{ $cast_fixbit(typeIR''', w', i) }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:436.1-436.43
def $cast_fixint(typeIR, w, i)

1. Return $cast_fixint'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:437.1-437.44
def $cast_fixint'(typeIR''', w', i)

1. If ((typeIR''' = ((int) as typeIR))), then

  1. Return ((d $to_int((w' as int), i)) as value)

2. Case analysis on typeIR'''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR''' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< w_to >) be numberTypeIR)

        2. (Let i' be $to_bitstr((w_to as int), $to_int((w' as int), i)))

        3. Return ((w_to w i') as value)

      2. Case (% matches pattern `INT<%>`)

        1. (Let (int< w_to >) be numberTypeIR)

        2. (Let i' be $to_bitstr((w_to as int), $to_int((w' as int), i)))

        3. Return ((w_to s i') as value)

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR''') be aliasTypeIR)

      2. Return $cast_fixint(typeIR''', w', i)

  3. Case (% has type setTypeIR)

    1. (Let (set< typeIR'''* >) be (typeIR''' as setTypeIR))

    2. If ((typeIR'''* matches pattern [ _/1 ])), then

      1. (Let [typeIR'''] be typeIR'''*)

      2. Return ((set{ $cast_fixint(typeIR''', w', i) }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:453.1-453.52
def $cast_struct(typeIR, tid, (value_f, id_f)*)

1. Return $cast_struct'($canon(typeIR), tid, (value_f, id_f)*)

;; ../../../../spec-concrete/3-numerics.watsup:454.1-454.53
def $cast_struct'(typeIR, tid', (value_f, id_f)*)

1. If ((typeIR has type structTypeIR)), then

  1. (Let (struct tid { _fieldTypeIR* }) be (typeIR as structTypeIR))

  2. If ((tid = tid')), then

    1. Return ((struct tid { (value_f id_f ;)* }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:467.1-467.52
def $cast_header(typeIR, tid, (value_f, id_f)*)

1. Return $cast_header'($canon(typeIR), tid, (value_f, id_f)*)

;; ../../../../spec-concrete/3-numerics.watsup:468.1-468.53
def $cast_header'(typeIR, tid', (value_f, id_f)*)

1. If ((typeIR has type headerTypeIR)), then

  1. (Let (header tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

  2. If ((tid = tid')), then

    1. Return ((header tid { (value_f id_f ;)* }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:485.1-485.43
def $cast_sequence(typeIR, value*)

1. Return $cast_sequence'($canon(typeIR), value*)

;; ../../../../spec-concrete/3-numerics.watsup:486.1-486.44
def $cast_sequence'(typeIR'', value*)

1. Case analysis on typeIR''

  1. Case (% has type listTypeIR)

    1. (Let (list< typeIR >) be (typeIR'' as listTypeIR))

    2. Return (([ $cast_op(typeIR, value)* ]) as value)

  2. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR* >) be (typeIR'' as tupleTypeIR))

    2. Return ((( $cast_op(typeIR, value)* )) as value)

  3. Case (% has type headerStackTypeIR)

    1. (Let (typeIR [ n_s ]) be (typeIR'' as headerStackTypeIR))

    2. (Let value_cast be $cast_op(typeIR, value))*

    3. (Let n_idx be |value*|)

    4. Return (([ value_cast* #( n_idx ; n_s )]) as value)

  4. Case (% has type structTypeIR)

    1. (Let (struct tid { (typeIR_f id_f ;)* }) be (typeIR'' as structTypeIR))

    2. (Let value_cast be $cast_op(typeIR_f, value))*

    3. Return ((struct tid { (value_cast id_f ;)* }) as value)

  5. Case (% has type headerTypeIR)

    1. (Let (header tid { (typeIR_f id_f ;)* }) be (typeIR'' as headerTypeIR))

    2. (Let value_cast be $cast_op(typeIR_f, value))*

    3. Return ((header tid { (value_cast id_f ;)* }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:516.1-516.47
def $cast_record(typeIR, (value, id)*)

1. Return $cast_record'($canon(typeIR), (value, id)*)

;; ../../../../spec-concrete/3-numerics.watsup:517.1-517.48
def $cast_record'(typeIR, (value_f, id_f)*)

1. Case analysis on typeIR

  1. Case (% has type structTypeIR)

    1. (Let (struct tid { (typeIR_t_f id_t_f ;)* }) be (typeIR as structTypeIR))

    2. (Let value? be $find_map<id, value>(({ (id_f : value_f)* }), id_t_f))*

    3. If ((value? matches pattern (_)))*, then

      1. (Let ?(value_f') be value?)*

      2. (Let value_f_cast be $cast_op(typeIR_t_f, value_f'))*

      3. Return ((struct tid { (value_f_cast id_f ;)* }) as value)

  2. Case (% has type headerTypeIR)

    1. (Let (header tid { (typeIR_t_f id_t_f ;)* }) be (typeIR as headerTypeIR))

    2. (Let value? be $find_map<id, value>(({ (id_f : value_f)* }), id_t_f))*

    3. If ((value? matches pattern (_)))*, then

      1. (Let ?(value_f') be value?)*

      2. (Let value_f_cast be $cast_op(typeIR_t_f, value_f'))*

      3. Return ((header tid { (value_f_cast id_f ;)* }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:551.1-551.47
def $cast_set_singleton(typeIR, value)

1. Return $cast_set_singleton'($canon(typeIR), value)

;; ../../../../spec-concrete/3-numerics.watsup:552.1-552.48
def $cast_set_singleton'(typeIR'', value)

1. If ((typeIR'' has type setTypeIR)), then

  1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

  2. If ((typeIR'* matches pattern [ _/1 ])), then

    1. (Let [typeIR] be typeIR'*)

    2. Return ((set{ $cast_op(typeIR, value) }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:560.1-560.49
def $cast_set_mask(typeIR, value_b, value_m)

1. Return $cast_set_mask'($canon(typeIR), value_b, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:561.1-561.50
def $cast_set_mask'(typeIR'', value_b, value_m)

1. If ((typeIR'' has type setTypeIR)), then

  1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

  2. If ((typeIR'* matches pattern [ _/1 ])), then

    1. (Let [typeIR] be typeIR'*)

    2. (Let value_b_cast be $cast_op(typeIR, value_b))

    3. (Let value_m_cast be $cast_op(typeIR, value_m))

    4. Return ((set{ value_b_cast &&& value_m_cast }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:571.1-571.50
def $cast_set_range(typeIR, value_l, value_u)

1. Return $cast_set_range'($canon(typeIR), value_l, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:572.1-572.51
def $cast_set_range'(typeIR'', value_l, value_u)

1. If ((typeIR'' has type setTypeIR)), then

  1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

  2. If ((typeIR'* matches pattern [ _/1 ])), then

    1. (Let [typeIR] be typeIR'*)

    2. (Let value_l_cast be $cast_op(typeIR, value_l))

    3. (Let value_u_cast be $cast_op(typeIR, value_u))

    4. Return ((set{ value_l_cast .. value_u_cast }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:637.1-637.44
def $bitacc_op(value_b, value_h, value_l)

1. (Let i_b be $to_number(value_b))

2. (Let i_h be $to_number(value_h))

3. (Let i_l be $to_number(value_l))

4. (Let int be ((i_h + (1 as int)) - i_l))

5. If ((int has type nat)), then

  1. (Let w be (int as nat))

  2. (Let i be $bitacc(i_b, i_h, i_l))

  3. Return ((w w i) as value)

;; ../../../../spec-concrete/3-numerics.watsup:650.1-650.32
def $sizeof(typeIR, text)

1. Case analysis on text

  1. Case (% = "minSizeInBits")

    1. Return $sizeof_minSizeInBits(typeIR)

  2. Case (% = "minSizeInBytes")

    1. Return $sizeof_minSizeInBytes(typeIR)

  3. Case (% = "maxSizeInBits")

    1. Return $sizeof_maxSizeInBits(typeIR)

  4. Case (% = "maxSizeInBytes")

    1. Return $sizeof_maxSizeInBytes(typeIR)

;; ../../../../spec-concrete/3-numerics.watsup:652.1-652.42
def $sizeof_minSizeInBits(typeIR)

1. Return ((d ($sizeof_minSizeInBits'(typeIR) as int)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:653.1-653.41
def $sizeof_minSizeInBits'(typeIR)

1. Return $sizeof_minSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:654.1-654.42
def $sizeof_minSizeInBits''(typeIR'')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return 1

2. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< w >) be numberTypeIR)

        2. Return w

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< w >) be numberTypeIR)

        2. Return w

      3. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< _nat >) be numberTypeIR)

        2. Return 0

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $sizeof_minSizeInBits'(typeIR'')

  3. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # typeIR'' { _valueFieldIR* }) be enumTypeIR)

      2. Return $sizeof_minSizeInBits'(typeIR'')

  4. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. Return $sum($sizeof_minSizeInBits'(typeIR'')*)

  5. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ n_size ]) be (typeIR'' as headerStackTypeIR))

    2. Return ($sizeof_minSizeInBits'(typeIR'') * n_size)

  6. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR'' _id ;)* }) be (typeIR'' as structTypeIR))

    2. Return $sum($sizeof_minSizeInBits'(typeIR'')*)

  7. Case (% has type headerTypeIR)

    1. (Let (header _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerTypeIR))

    2. Return $sum($sizeof_minSizeInBits'(typeIR'')*)

  8. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerUnionTypeIR))

    2. Return $min($sizeof_minSizeInBits'(typeIR'')*)

;; ../../../../spec-concrete/3-numerics.watsup:656.1-656.43
def $sizeof_minSizeInBytes(typeIR)

1. (Let n_size be $sizeof_minSizeInBits'(typeIR))

2. Return ((d ((n_size / 8) as int)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:658.1-658.42
def $sizeof_maxSizeInBits(typeIR)

1. Return ((d ($sizeof_maxSizeInBits'(typeIR) as int)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:659.1-659.41
def $sizeof_maxSizeInBits'(typeIR)

1. Return $sizeof_maxSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:660.1-660.42
def $sizeof_maxSizeInBits''(typeIR'')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return 1

2. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< w >) be numberTypeIR)

        2. Return w

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< w >) be numberTypeIR)

        2. Return w

      3. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< w >) be numberTypeIR)

        2. Return w

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $sizeof_maxSizeInBits'(typeIR'')

  3. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # typeIR'' { _valueFieldIR* }) be enumTypeIR)

      2. Return $sizeof_maxSizeInBits'(typeIR'')

  4. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. Return $sum($sizeof_maxSizeInBits'(typeIR'')*)

  5. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ n_size ]) be (typeIR'' as headerStackTypeIR))

    2. Return ($sizeof_maxSizeInBits'(typeIR'') * n_size)

  6. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR'' _id ;)* }) be (typeIR'' as structTypeIR))

    2. Return $sum($sizeof_maxSizeInBits'(typeIR'')*)

  7. Case (% has type headerTypeIR)

    1. (Let (header _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerTypeIR))

    2. Return $sum($sizeof_maxSizeInBits'(typeIR'')*)

  8. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { (typeIR'' _id ;)* }) be (typeIR'' as headerUnionTypeIR))

    2. Return $max($sizeof_maxSizeInBits'(typeIR'')*)

;; ../../../../spec-concrete/3-numerics.watsup:662.1-662.43
def $sizeof_maxSizeInBytes(typeIR)

1. (Let n_size be $sizeof_maxSizeInBits'(typeIR))

2. Return ((d ((n_size / 8) as int)) as value)

;; ../../../../spec-concrete/4-ir-syntax.watsup:6.1-7.14
syntax prefixedNameIR = 
   | ` nameIR
   | . nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:9.1-9.63
def $prefixedNonTypeName(prefixedNonTypeName)

1. If ((prefixedNonTypeName has type nonTypeName)), then

  1. (Let nonTypeName be (prefixedNonTypeName as nonTypeName))

  2. Return (` $name((nonTypeName as name)))

2. If ((prefixedNonTypeName matches pattern ``ID.%`)), then

  1. (Let (. nonTypeName) be prefixedNonTypeName)

  2. Return (. $name((nonTypeName as name)))

;; ../../../../spec-concrete/4-ir-syntax.watsup:13.1-13.57
def $prefixedTypeName(prefixedTypeName)

1. If ((prefixedTypeName has type typeName)), then

  1. (Let typeName be (prefixedTypeName as typeName))

  2. Return (` $name((typeName as name)))

2. If ((prefixedTypeName matches pattern ``TID.%`)), then

  1. (Let (. typeName) be prefixedTypeName)

  2. Return (. $name((typeName as name)))

;; ../../../../spec-concrete/4-ir-syntax.watsup:17.1-17.53
def $flatten_prefixedNameIR(prefixedNameIR)

1. Case analysis on prefixedNameIR

  1. Case (% matches pattern ``%`)

    1. (Let (` nameIR) be prefixedNameIR)

    2. Return nameIR

  2. Case (% matches pattern `.%`)

    1. (Let (. nameIR) be prefixedNameIR)

    2. Return "." ++ nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:21.21-21.28
syntax nameListIR = nameIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:27.26-27.29
syntax typeParameterIR = tid

;; ../../../../spec-concrete/4-ir-syntax.watsup:29.30-29.46
syntax typeParameterListIR = typeParameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:38.3-38.66
syntax parameterIR = 
   | annotationList direction typeIR nameIR constantInitializerOptIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:40.26-40.38
syntax parameterListIR = parameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:46.33-46.44
syntax constructorParameterIR = parameterIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:48.37-48.49
syntax constructorParameterListIR = parameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:56.28-56.55
syntax namedExpressionIR = 
   | nameIR = typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:58.32-58.50
syntax namedExpressionListIR = namedExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:68.30-68.47
syntax literalExpressionIR = literalExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:74.32-74.46
syntax referenceExpressionIR = prefixedNameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:80.30-80.47
syntax defaultExpressionIR = defaultExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:86.28-86.50
syntax unaryExpressionIR = 
   | unop typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:89.3-89.44
syntax binaryExpressionIR = 
   | typedExpressionIR binop typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:92.3-92.62
syntax ternaryExpressionIR = 
   | typedExpressionIR ? typedExpressionIR : typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:98.27-98.56
syntax castExpressionIR = 
   | ( typeIR ) typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:107.1-111.46
syntax dataExpressionIR = 
   | {#}
   | seq{ typedExpressionListIR }
   | seq{ typedExpressionListIR ,...}
   | record{ namedExpressionListIR }
   | record{ namedExpressionListIR ,...}

;; ../../../../spec-concrete/4-ir-syntax.watsup:120.3-120.18
syntax errorAccessExpressionIR = 
   | error. nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:123.3-123.31
syntax memberAccessExpressionIR = 
   | memberAccessBaseIR . nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:126.1-127.66
syntax indexAccessExpressionIR = 
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]

;; ../../../../spec-concrete/4-ir-syntax.watsup:130.1-132.28
syntax accessExpressionIR = 
   | error. nameIR
   | memberAccessBaseIR . nameIR
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]

;; ../../../../spec-concrete/4-ir-syntax.watsup:143.1-146.25
syntax routineTargetIR = 
   | ` nameIR
   | . nameIR
   | typedExpressionIR . nameIR
   | type prefixedNameIR . nameIR
   | ( routineTargetIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:148.30-148.68
syntax constructorTargetIR = 
   | prefixedNameIR < typeArgumentListIR >

;; ../../../../spec-concrete/4-ir-syntax.watsup:151.1-152.64
syntax callExpressionIR = 
   | constructorTargetIR ( argumentListIR )
   | routineTargetIR < typeArgumentListIR >( argumentListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:158.36-158.58
syntax parenthesizedExpressionIR = 
   | ( typedExpressionIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:165.1-175.30
syntax expressionIR = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | ` nameIR
   | . nameIR
   | ...
   | unop typedExpressionIR
   | typedExpressionIR binop typedExpressionIR
   | typedExpressionIR ? typedExpressionIR : typedExpressionIR
   | ( typeIR ) typedExpressionIR
   | {#}
   | seq{ typedExpressionListIR }
   | seq{ typedExpressionListIR ,...}
   | record{ namedExpressionListIR }
   | record{ namedExpressionListIR ,...}
   | error. nameIR
   | memberAccessBaseIR . nameIR
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]
   | constructorTargetIR ( argumentListIR )
   | routineTargetIR < typeArgumentListIR >( argumentListIR )
   | ( typedExpressionIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:177.27-177.42
syntax expressionNoteIR = 
   | ( typeIR ctk )

;; ../../../../spec-concrete/4-ir-syntax.watsup:180.3-180.35
syntax typedExpressionIR = 
   | expressionIR # expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:182.32-182.50
syntax typedExpressionListIR = typedExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:185.1-186.22
syntax memberAccessBaseIR = 
   | type prefixedNameIR
   | expressionIR # expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:193.1-197.7
syntax simpleKeysetExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR &&& typedExpressionIR
   | typedExpressionIR .. typedExpressionIR
   | default
   | _

;; ../../../../spec-concrete/4-ir-syntax.watsup:199.39-199.64
syntax simpleKeysetExpressionListIR = simpleKeysetExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:201.34-201.67
syntax tupleKeysetExpressionIR = 
   | ( simpleKeysetExpressionListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:204.1-205.28
syntax keysetExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR &&& typedExpressionIR
   | typedExpressionIR .. typedExpressionIR
   | default
   | _
   | ( simpleKeysetExpressionListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:211.25-211.31
syntax typeArgumentIR = typeIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:213.29-213.44
syntax typeArgumentListIR = typeArgumentIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:220.1-223.7
syntax argumentIR = 
   | expressionIR # expressionNoteIR
   | nameIR = typedExpressionIR
   | nameIR =_
   | _

;; ../../../../spec-concrete/4-ir-syntax.watsup:225.25-225.36
syntax argumentListIR = argumentIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:232.1-236.23
syntax lvalueIR = 
   | ` nameIR
   | . nameIR
   | typedLvalueIR . nameIR
   | typedLvalueIR [ typedExpressionIR ]
   | typedLvalueIR [ typedExpressionIR : typedExpressionIR ]
   | ( typedLvalueIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:238.24-238.47
syntax typedLvalueIR = 
   | lvalueIR #( typeIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:248.27-248.41
syntax emptyStatementIR = emptyStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:255.3-255.46
syntax assignmentStatementIR = 
   | typedLvalueIR assignop typedExpressionIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:262.3-262.65
syntax callStatementIR = 
   | routineTargetIR < typeArgumentListIR >( argumentListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:269.3-269.49
syntax directApplicationStatementIR = 
   | prefixedNameIR .apply( argumentListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:276.1-277.32
syntax returnStatementIR = 
   | return;
   | return typedExpressionIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:283.26-283.39
syntax exitStatementIR = exitStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:292.3-292.50
syntax blockStatementIR = 
   | annotationList { blockElementStatementListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:301.1-302.59
syntax conditionalStatementIR = 
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:311.1-314.35
syntax forInitStatementIR = 
   | annotationList typeIR nameIR initializerOptIR
   | lvalueIR ( argumentListIR )
   | lvalueIR < typeArgumentListIR >( argumentListIR )
   | lvalueIR assignop expressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:316.33-316.52
syntax forInitStatementListIR = forInitStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:318.31-318.49
syntax forUpdateStatementIR = forInitStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:320.35-320.56
syntax forUpdateStatementListIR = forUpdateStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:323.1-324.44
syntax forCollectionExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR .. typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:327.1-335.18
syntax forStatementIR = 
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:342.1-343.22
syntax switchLabelIR = 
   | default
   | expressionIR # expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:346.1-347.21
syntax switchCaseIR = 
   | switchLabelIR : blockStatementIR
   | switchLabelIR :

;; ../../../../spec-concrete/4-ir-syntax.watsup:349.27-349.40
syntax switchCaseListIR = switchCaseIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:352.3-352.54
syntax switchStatementIR = 
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:358.27-358.41
syntax breakStatementIR = breakStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:360.30-360.47
syntax continueStatementIR = continueStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:367.1-378.22
syntax statementIR = 
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | return;
   | return typedExpressionIR ;
   | exit;
   | annotationList { blockElementStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR
   | break;
   | continue;
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:388.32-388.40
syntax constantInitializerIR = 
   | = value

;; ../../../../spec-concrete/4-ir-syntax.watsup:390.35-390.57
syntax constantInitializerOptIR = constantInitializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:393.3-393.62
syntax constantDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:395.24-395.44
syntax initializerIR = 
   | = typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:397.27-397.41
syntax initializerOptIR = initializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:400.3-400.51
syntax variableDeclarationIR = 
   | annotationList typeIR nameIR initializerOptIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:403.1-405.16
syntax blockElementStatementIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | return;
   | return typedExpressionIR ;
   | exit;
   | annotationList { blockElementStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR
   | break;
   | continue;
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:407.38-407.62
syntax blockElementStatementListIR = blockElementStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:414.3-415.73
syntax functionPrototypeIR = 
   | typeIR nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:418.3-418.54
syntax functionDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:425.3-425.69
syntax actionDeclarationIR = 
   | annotationList action nameIR ( parameterListIR ) blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:433.30-433.61
syntax objectInitializerIR = 
   | ={ objectDeclarationListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:435.33-435.53
syntax objectInitializerOptIR = objectInitializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:438.3-440.30
syntax instantiationIR = 
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:443.1-444.20
syntax objectDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:446.34-446.54
syntax objectDeclarationListIR = objectDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:452.29-452.50
syntax errorDeclarationIR = 
   | error{ nameListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:458.33-458.59
syntax matchKindDeclarationIR = 
   | match_kind{ nameListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:469.1-470.65
syntax enumTypeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:476.22-476.53
syntax typeFieldIR = 
   | annotationList typeIR nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:478.26-478.38
syntax typeFieldListIR = typeFieldIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:481.3-482.73
syntax structTypeDeclarationIR = 
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:485.3-486.73
syntax headerTypeDeclarationIR = 
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:489.3-490.73
syntax headerUnionTypeDeclarationIR = 
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:493.1-496.33
syntax derivedTypeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:503.1-504.29
syntax typedefTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:507.1-508.41
syntax typedefDeclarationIR = 
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:515.3-515.47
syntax externFunctionDeclarationIR = 
   | annotationList extern functionPrototypeIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:518.1-520.51
syntax methodPrototypeIR = 
   | annotationList nameIR <, typeParameterListIR >( parameterListIR );
   | annotationList functionPrototypeIR ;
   | annotationList abstract functionPrototypeIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:522.32-522.50
syntax methodPrototypeListIR = methodPrototypeIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:525.3-527.31
syntax externObjectDeclarationIR = 
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:530.1-531.30
syntax externDeclarationIR = 
   | annotationList extern functionPrototypeIR ;
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:541.23-541.54
syntax selectCaseIR = 
   | keysetExpressionIR : nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:543.27-543.40
syntax selectCaseListIR = selectCaseIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:546.3-546.58
syntax selectExpressionIR = 
   | select( typedExpressionListIR ){ selectCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:553.1-554.23
syntax stateExpressionIR = 
   | nameIR ;
   | select( typedExpressionListIR ){ selectCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:556.32-556.60
syntax transitionStatementIR = 
   | transition stateExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:563.3-563.72
syntax valueSetDeclarationIR = 
   | annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:570.3-571.76
syntax parserTypeDeclarationIR = 
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:580.3-580.44
syntax parserBlockStatementIR = 
   | annotationList { parserStatementListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:583.1-590.27
syntax parserStatementIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | annotationList { parserStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:592.32-592.50
syntax parserStatementListIR = parserStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:595.3-596.53
syntax parserStateIR = 
   | annotationList state nameIR { parserStatementListIR transitionStatementIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:598.28-598.42
syntax parserStateListIR = parserStateIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:601.1-604.26
syntax parserLocalDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:607.3-607.28
syntax parserLocalDeclarationListIR = parserLocalDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:610.3-613.56
syntax parserDeclarationIR = 
   | annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:623.18-623.23
syntax constIR = const

;; ../../../../spec-concrete/4-ir-syntax.watsup:625.21-625.29
syntax constOptIR = constIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:631.21-631.66
syntax tableKeyIR = 
   | typedExpressionIR : nameIR annotationList ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:633.25-633.36
syntax tableKeyListIR = tableKeyIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:639.33-639.67
syntax tableActionReferenceIR = 
   | prefixedNameIR ( argumentListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:641.24-641.64
syntax tableActionIR = 
   | annotationList tableActionReferenceIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:643.28-643.42
syntax tableActionListIR = tableActionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:650.1-651.42
syntax tableEntryPriorityIR = 
   | priority= numberLiteral :
   | priority=( typedExpressionIR ):

;; ../../../../spec-concrete/4-ir-syntax.watsup:653.34-653.55
syntax tableEntryPriorityOptIR = tableEntryPriorityIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:656.3-657.67
syntax tableEntryIR = 
   | constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:659.27-659.40
syntax tableEntryListIR = tableEntryIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:666.1-672.75
syntax tablePropertyIR = 
   | key={ tableKeyListIR }
   | actions={ tableActionListIR }
   | annotationList constOptIR entries={ tableEntryListIR }
   | annotationList constOptIR default_action= tableActionReferenceIR ;
   | annotationList constOptIR custom nameIR initializerIR ;
   | annotationList constOptIR custom_const nameIR constantInitializerIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:674.30-674.46
syntax tablePropertyListIR = tablePropertyIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:677.3-677.62
syntax tableDeclarationIR = 
   | annotationList table typeIR nameIR { tablePropertyListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:684.3-686.28
syntax controlTypeDeclarationIR = 
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:692.24-692.40
syntax controlBodyIR = blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:695.1-699.23
syntax controlLocalDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | annotationList action nameIR ( parameterListIR ) blockStatementIR
   | annotationList table typeIR nameIR { tablePropertyListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:702.3-702.29
syntax controlLocalDeclarationListIR = controlLocalDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:705.3-708.59
syntax controlDeclarationIR = 
   | annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:715.3-717.28
syntax packageTypeDeclarationIR = 
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:724.1-728.29
syntax typeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:735.1-744.22
syntax declarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList action nameIR ( parameterListIR ) blockStatementIR
   | error{ nameListIR }
   | match_kind{ nameListIR }
   | annotationList extern functionPrototypeIR ;
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }
   | annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
   | annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:750.22-750.39
syntax p4programIR = 
   | declarationIR* ;

;; ../../../../spec-concrete/5.0-flow.watsup:5.15-5.25
syntax flow = 
   | cont
   | ret

;; ../../../../spec-concrete/5.0-flow.watsup:9.1-9.34
def $join_flow(flow'', flow''')

1. If ((flow'' matches pattern `RET`)), then

  1. If ((flow''' matches pattern `RET`)), then

    1. Return (ret)

2. Otherwise

  1. Return (cont)

;; ../../../../spec-concrete/5.01-env.watsup:5.20-5.47
syntax varTypeIR = 
   | direction typeIR ctk value?

;; ../../../../spec-concrete/5.01-env.watsup:12.16-12.34
syntax frame = map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:14.1-14.27
def $empty_frame

1. Return $empty_map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:18.16-18.35
syntax tdenv = map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:20.1-20.27
def $empty_tdenv

1. Return $empty_map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:24.16-24.42
syntax rdenv = map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:26.1-26.27
def $empty_rdenv

1. Return $empty_map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:30.16-30.46
syntax cdenv = map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:32.1-32.27
def $empty_cdenv

1. Return $empty_map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:39.1-39.39
def $check_routine_name(id_l, id_r)

1. Return (id_l = id_r)

;; ../../../../spec-concrete/5.01-env.watsup:42.1-42.37
def $check_arity(id_arg?*, id_param*)

1. Return (|id_arg?*| = |id_param*|)

;; ../../../../spec-concrete/5.01-env.watsup:45.1-45.42
def $check_arity_more(id_arg?*, id_param*)

1. Return (|id_arg?*| > |id_param*|)

;; ../../../../spec-concrete/5.01-env.watsup:48.1-48.42
def $check_arity_less(id_arg?*, id_param*)

1. Return (|id_arg?*| < |id_param*|)

;; ../../../../spec-concrete/5.01-env.watsup:51.1-51.44
def $get_missing_parameters(id*, id_arg*)

1. Case analysis on id*

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let id_param_h :: id_param_t* be id*)

    2. If (~$in_set<id>(id_param_h, ({ id_arg* }))), then

      1. Return id_param_h :: $get_missing_parameters(id_param_t*, id_arg*)

    3. Otherwise

      1. Return $get_missing_parameters(id_param_t*, id_arg*)

;; ../../../../spec-concrete/5.01-env.watsup:68.1-68.61
def $find_match_named<V>(rid, V, id_arg*, pid'*)

1. (Let (id_param # bool_param) be pid')*

2. If ($eq_set<id>(({ id_arg* }), ({ id_param* }))), then

  1. Return ?((rid, V, []))

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:77.1-77.69
def $find_match_named_default<V>(rid, V, id_arg*, pid'*)

1. (Let (id_param # bool_param) be pid')*

2. (Let id_default* be $get_missing_parameters(id_param*, id_arg*))

3. If (($find_match_named<V>(rid, V, id_arg* ++ id_default*, (id_param # bool_param)*) =/= ?())), then

  1. Return ?((rid, V, id_default*))

4. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:91.1-91.74
def $find_match_unnamed_default<V>(rid, V, id_arg?*, pid*)

1. (Let (_pid*, (id_default # bool)*) be $partition_<pid>(pid*, |id_arg?*|))

2. If ((bool = true))*, then

  1. Return ?((rid, V, id_default*))

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:100.1-100.64
def $find_matching<V>(id_r, id_arg?*, id_arg''*, (id_r' ( pid_r''* )), V)

1. If (~$check_routine_name(id_r, id_r')), then

  1. Return ?()

2. (Let (id_param' # bool_param') be pid_r'')*

3. If ($check_routine_name(id_r, id_r')), then

  1. If ($check_arity_more(id_arg?*, id_param'*)), then

    1. Return ?()

4. If ((|id_arg''*| > 0)), then

  1. If ($check_routine_name(id_r, id_r')), then

    1. If ($check_arity(id_arg?*, id_param'*)), then

      1. Return $find_match_named<V>((id_r' ( (id_param' # bool_param')* )), V, id_arg''*, (id_param' # bool_param')*)

    2. If ($check_arity_less(id_arg?*, id_param'*)), then

      1. Return $find_match_named_default<V>((id_r' ( (id_param' # bool_param')* )), V, id_arg''*, (id_param' # bool_param')*)

5. If ((id_arg''* matches pattern [])), then

  1. If ($check_routine_name(id_r, id_r')), then

    1. If ($check_arity(id_arg?*, id_param'*)), then

      1. Return ?(((id_r' ( (id_param' # bool_param')* )), V, []))

    2. If ($check_arity_less(id_arg?*, id_param'*)), then

      1. Return $find_match_unnamed_default<V>((id_r' ( (id_param' # bool_param')* )), V, id_arg?*, (id_param' # bool_param')*)

;; ../../../../spec-concrete/5.01-env.watsup:159.1-159.67
def $find_matchings<V>(id_r, id_arg?*, id_arg'*, rid''*, V''*)

1. Case analysis on rid''*

  1. Case (% matches pattern [])

    1. If ((V''* matches pattern [])), then

      1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let rid_h :: rid_t* be rid''*)

    2. If ((V''* matches pattern _ :: _)), then

      1. (Let V_h :: V_t* be V''*)

      2. If (($find_matching<V>(id_r, id_arg?*, id_arg'*, rid_h, V_h) = ?())), then

        1. Return $find_matchings<V>(id_r, id_arg?*, id_arg'*, rid_t*, V_t*)

      3. (Let (rid, V, id*)? be $find_matching<V>(id_r, id_arg?*, id_arg'*, rid_h, V_h))

      4. If (((rid, V, id*)? matches pattern (_))), then

        1. (Let ?((rid'', V'', id_default*)) be (rid, V, id*)?)

        2. Return (rid'', V'', id_default*) :: $find_matchings<V>(id_r, id_arg?*, id_arg'*, rid_t*, V_t*)

;; ../../../../spec-concrete/5.01-env.watsup:181.1-181.66
def $find_overloaded<V>(({ (rid : V)* }), id_r, id_arg?*)

1. If ((|id_arg?*| > 0)), then

  1. (Let id? be id_arg?)*

  2. If ((id? matches pattern (_)))*, then

    1. (Let ?(id_arg') be id?)*

    2. If (($find_matchings<V>(id_r, id_arg?*, id_arg'*, rid*, V*) = [])), then

      1. Return ?()

    3. (Let (rid, V, id*)* be $find_matchings<V>(id_r, id_arg?*, id_arg'*, rid*, V*))

    4. If (((rid, V, id*)* matches pattern [ _/1 ])), then

      1. (Let [(rid', V', id_default*)] be (rid, V, id*)*)

      2. Return ?((rid', V', id_default*))

2. If ((id_arg? = ?()))*, then

  1. If (($find_matchings<V>(id_r, id_arg?*, [], rid*, V*) = [])), then

    1. Return ?()

  2. (Let (rid, V, id*)* be $find_matchings<V>(id_r, id_arg?*, [], rid*, V*))

  3. If (((rid, V, id*)* matches pattern [ _/1 ])), then

    1. (Let [(rid', V', id_default*)] be (rid, V, id*)*)

    2. Return ?((rid', V', id_default*))

;; ../../../../spec-concrete/5.01-env.watsup:218.1-218.50
def $find_non_overloaded<V>(({ (rid : V)* }), id)

1. (Let V''* be $find_non_overloaded'<V>(({ (rid : V)* }), id))

2. If ((V''* matches pattern [ _/1 ])), then

  1. (Let [V'] be V''*)

  2. Return ?(V')

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:219.1-219.51
def $find_non_overloaded'<V>(set<pair<rid, V>>', id)

1. If ((set<pair<rid, V>>' = ({ [] }))), then

  1. Return []

2. (Let ({ pair<rid, V>* }) be set<pair<rid, V>>')

3. If ((pair<rid, V>* matches pattern _ :: _)), then

  1. (Let (rid_h : V_h) :: (rid_t : V_t)* be pair<rid, V>*)

  2. (Let (id' ( _pid* )) be rid_h)

  3. Case analysis on id'

    1. Case (% = id)

      1. (Let V_t_found* be $find_non_overloaded'<V>(({ (rid_t : V_t)* }), id))

      2. Return V_h :: V_t_found*

    2. Case (% =/= id)

      1. (Let V_t_found* be $find_non_overloaded'<V>(({ (rid_t : V_t)* }), id))

      2. Return V_t_found*

;; ../../../../spec-concrete/5.02-context.watsup:5.17-5.39
syntax cursor = 
   | global
   | block
   | local

;; ../../../../spec-concrete/5.02-context.watsup:16.3-19.18
syntax globalTypingLayer = {cdenv cdenv, tdenv tdenv, rdenv rdenv, frame frame}

;; ../../../../spec-concrete/5.02-context.watsup:24.1-28.12
syntax blockKind = 
   | 
   | extern
   | parser
   | control
   | package

;; ../../../../spec-concrete/5.02-context.watsup:30.1-30.43
def $is_extern_blockKind(blockKind)

1. Return (blockKind = (extern))

;; ../../../../spec-concrete/5.02-context.watsup:33.1-33.43
def $is_parser_blockKind(blockKind)

1. Return (blockKind = (parser))

;; ../../../../spec-concrete/5.02-context.watsup:36.1-36.44
def $is_control_blockKind(blockKind)

1. Return (blockKind = (control))

;; ../../../../spec-concrete/5.02-context.watsup:39.1-39.44
def $is_package_blockKind(blockKind)

1. Return (blockKind = (package))

;; ../../../../spec-concrete/5.02-context.watsup:43.3-47.18
syntax blockTypingLayer = {id id, kind blockKind, tdenv tdenv, rdenv rdenv, frame frame}

;; ../../../../spec-concrete/5.02-context.watsup:52.1-60.23
syntax localKind = 
   | 
   | function-> typeIR
   | extern_function-> typeIR
   | action
   | extern_method-> typeIR
   | extern_methodabstract-> typeIR
   | parser_state
   | control_apply_method
   | table_apply_method

;; ../../../../spec-concrete/5.02-context.watsup:62.1-62.45
def $is_function_localKind(localKind')

1. If ((localKind' matches pattern `FUNCTION->%`)), then

  1. (Let (function-> _typeIR) be localKind')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:67.1-67.52
def $is_extern_function_localKind(localKind')

1. If ((localKind' matches pattern `EXTERN_FUNCTION->%`)), then

  1. (Let (extern_function-> _typeIR) be localKind')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:74.1-74.43
def $is_action_localKind(localKind')

1. If ((localKind' matches pattern `ACTION`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:79.1-79.50
def $is_extern_method_localKind(localKind')

1. If ((localKind' matches pattern `EXTERN_METHOD->%`)), then

  1. (Let (extern_method-> _typeIR) be localKind')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:86.1-86.59
def $is_extern_abstract_method_localKind(localKind')

1. If ((localKind' matches pattern `EXTERN_METHODABSTRACT->%`)), then

  1. (Let (extern_methodabstract-> _typeIR) be localKind')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:93.1-93.49
def $is_parser_state_localKind(localKind')

1. If ((localKind' matches pattern `PARSER_STATE`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:98.1-98.57
def $is_control_apply_method_localKind(localKind')

1. If ((localKind' matches pattern `CONTROL_APPLY_METHOD`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:105.1-105.55
def $is_table_apply_method_localKind(localKind')

1. If ((localKind' matches pattern `TABLE_APPLY_METHOD`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:113.3-116.20
syntax localTypingLayer = {id id, kind localKind, tdenv tdenv, frames frame*}

;; ../../../../spec-concrete/5.02-context.watsup:123.3-125.29
syntax typingContext = {global globalTypingLayer, block blockTypingLayer, local localTypingLayer}

;; ../../../../spec-concrete/5.02-context.watsup:133.1-133.41
def $empty_typingContext

1. (Let globalTypingLayer be {cdenv $empty_cdenv, tdenv $empty_tdenv, rdenv $empty_rdenv, frame $empty_frame})

2. (Let blockTypingLayer be {id "", kind (), tdenv $empty_tdenv, rdenv $empty_rdenv, frame $empty_frame})

3. (Let localTypingLayer be {id "", kind (), tdenv $empty_tdenv, frames [$empty_frame]})

4. (Let TC be {global globalTypingLayer, block blockTypingLayer, local localTypingLayer})

5. Return TC

;; ../../../../spec-concrete/5.02-context.watsup:161.1-161.42
def $bound(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return ({ [] })

  2. Case (% matches pattern `BLOCK`)

    1. Return $dom_map<tid, typeDefIR>(TC.block.tdenv)

  3. Case (% matches pattern `LOCAL`)

    1. (Let bound_block be $bound((block), TC))

    2. (Let bound_local be $dom_map<tid, typeDefIR>(TC.local.tdenv))

    3. Return $union_set<tid>(bound_block, bound_local)

;; ../../../../spec-concrete/5.02-context.watsup:173.1-173.42
def $enter(TC)

1. Return TC[local.frames = $empty_frame :: TC.local.frames]

;; ../../../../spec-concrete/5.02-context.watsup:177.1-177.41
def $exit(TC)

1. (Let frame* be TC.local.frames)

2. If ((frame* matches pattern _ :: _)), then

  1. (Let frame_h :: frame_t* be frame*)

  2. Return TC[local.frames = frame_t*]

;; ../../../../spec-concrete/5.02-context.watsup:188.1-188.67
def $add_var(cursor, TC, id, varTypeIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let frame be TC.global.frame)

    2. If (~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))), then

      1. (Let (_direction typeIR _ctk _value?) be varTypeIR)

      2. If (((id = "main") => $is_package_object_typeIR($canon(typeIR)))), then

        1. (Let frame_update be $add_map<id, varTypeIR>(frame, id, varTypeIR))

        2. (Let TC' be TC[global.frame = frame_update])

        3. Return TC'

  2. Case (% matches pattern `BLOCK`)

    1. (Let frame be TC.block.frame)

    2. If (~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))), then

      1. If ((id =/= "main")), then

        1. (Let frame_update be $add_map<id, varTypeIR>(TC.block.frame, id, varTypeIR))

        2. (Let TC' be TC[block.frame = frame_update])

        3. Return TC'

  3. Case (% matches pattern `LOCAL`)

    1. (Let frame'* be TC.local.frames)

    2. If ((frame'* matches pattern _ :: _)), then

      1. (Let frame_h :: frame_t* be frame'*)

      2. If (~$in_set<id>(id, $dom_map<id, varTypeIR>(frame_h))), then

        1. If ((id =/= "main")), then

          1. (Let frame_h_update be $add_map<id, varTypeIR>(frame_h, id, varTypeIR))

          2. (Let frame* be frame_h_update :: frame_t*)

          3. (Let TC' be TC[local.frames = frame*])

          4. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:189.1-189.70
def $add_vars(p, TC, id*, varTypeIR*)

1. Case analysis on id*

  1. Case (% matches pattern [])

    1. If ((varTypeIR* matches pattern [])), then

      1. Return TC

  2. Case (% matches pattern _ :: _)

    1. (Let id_h :: id_t* be id*)

    2. If ((varTypeIR* matches pattern _ :: _)), then

      1. (Let varTypeIR_h :: varTypeIR_t* be varTypeIR*)

      2. (Let TC' be $add_var(p, TC, id_h, varTypeIR_h))

      3. (Let TC'' be $add_vars(p, TC', id_t*, varTypeIR_t*))

      4. Return TC''

;; ../../../../spec-concrete/5.02-context.watsup:219.1-219.75
def $add_parameter(cursor, TC, (direction typeIR id value?))

1. Case analysis on direction

  1. Case (% matches pattern ``EMPTY`)

    1. (Let varTypeIR be (() typeIR (ctk) value?))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

  2. Case (% matches pattern `IN`)

    1. (Let varTypeIR be (direction typeIR (dyn) value?))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

  3. Case (% matches pattern `OUT`)

    1. (Let varTypeIR be (direction typeIR (dyn) value?))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

  4. Case (% matches pattern `INOUT`)

    1. (Let varTypeIR be (direction typeIR (dyn) value?))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:220.1-220.77
def $add_parameters(cursor, TC, parameterTypeIR*)

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. Return TC

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. (Let TC' be $add_parameter(cursor, TC, parameterTypeIR_h))

    3. (Let TC'' be $add_parameters(cursor, TC', parameterTypeIR_t*))

    4. Return TC''

;; ../../../../spec-concrete/5.02-context.watsup:237.1-237.78
def $add_constructorParameter(TC, (direction typeIR id value''?))

1. Case analysis on value''?

  1. Case (% matches pattern ())

    1. (Let varTypeIR be (direction typeIR (ctk) ?()))

    2. (Let TC' be $add_var((block), TC, id, varTypeIR))

    3. Return TC'

  2. Case (% matches pattern (_))

    1. (Let ?(value'') be value''?)

    2. (Let varTypeIR be (direction typeIR (ctk) ?(value'')))

    3. (Let TC' be $add_var((block), TC, id, varTypeIR))

    4. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:238.1-238.80
def $add_constructorParameters(TC, parameterTypeIR*)

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. Return TC

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. (Let TC' be $add_constructorParameter(TC, parameterTypeIR_h))

    3. (Let TC'' be $add_constructorParameters(TC', parameterTypeIR_t*))

    4. Return TC''

;; ../../../../spec-concrete/5.02-context.watsup:254.1-254.69
def $add_type(cursor, TC, tid, typeDefIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let tdenv be TC.global.tdenv)

    2. If (~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))), then

      1. (Let tdenv_update be $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR))

      2. (Let TC' be TC[global.tdenv = tdenv_update])

      3. Return TC'

  2. Case (% matches pattern `BLOCK`)

    1. (Let tdenv be TC.block.tdenv)

    2. If (~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))), then

      1. (Let tdenv_update be $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR))

      2. (Let TC' be TC[block.tdenv = tdenv_update])

      3. Return TC'

  3. Case (% matches pattern `LOCAL`)

    1. (Let tdenv be TC.local.tdenv)

    2. If (~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))), then

      1. (Let tdenv_update be $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR))

      2. (Let TC' be TC[local.tdenv = tdenv_update])

      3. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:274.1-274.72
def $add_types(p, TC, tid*, typeDefIR*)

1. Case analysis on tid*

  1. Case (% matches pattern [])

    1. If ((typeDefIR* matches pattern [])), then

      1. Return TC

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t* be tid*)

    2. If ((typeDefIR* matches pattern _ :: _)), then

      1. (Let typeDefIR_h :: typeDefIR_t* be typeDefIR*)

      2. (Let TC' be $add_type(p, TC, tid_h, typeDefIR_h))

      3. (Let TC'' be $add_types(p, TC', tid_t*, typeDefIR_t*))

      4. Return TC''

;; ../../../../spec-concrete/5.02-context.watsup:282.1-282.88
def $add_routine_overload(cursor, TC, rid, routineTypeDefIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let rdenv be TC.global.rdenv)

    2. If (~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[global.rdenv = rdenv_update])

      3. Return TC'

  2. Case (% matches pattern `BLOCK`)

    1. (Let rdenv be TC.block.rdenv)

    2. If (~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[block.rdenv = rdenv_update])

      3. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:297.1-297.92
def $add_routine_non_overload(cursor, TC, rid, routineTypeDefIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let rdenv be TC.global.rdenv)

    2. (Let (id ( _pid* )) be rid)

    3. (Let ({ (id_k ( _pid'* ))* }) be $dom_map<rid, routineTypeDefIR>(rdenv))

    4. If (~$in_set<id>(id, ({ id_k* }))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[global.rdenv = rdenv_update])

      3. Return TC'

  2. Case (% matches pattern `BLOCK`)

    1. (Let rdenv be TC.block.rdenv)

    2. (Let (id ( _pid* )) be rid)

    3. (Let ({ (id_k ( _pid'* ))* }) be $dom_map<rid, routineTypeDefIR>(rdenv))

    4. If (~$in_set<id>(id, ({ id_k* }))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[block.rdenv = rdenv_update])

      3. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:318.1-318.79
def $add_constructor(TC, cid, constructorTypeDefIR)

1. (Let cdenv be TC.global.cdenv)

2. If (~$in_set<cid>(cid, $dom_map<cid, constructorTypeDefIR>(cdenv))), then

  1. (Let cdenv_update be $add_map<cid, constructorTypeDefIR>(cdenv, cid, constructorTypeDefIR))

  2. (Let TC' be TC[global.cdenv = cdenv_update])

  3. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:333.1-333.66
def $find_var(p', TC, prefixedNameIR)

1. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. id) be prefixedNameIR)

  2. (Let frame be TC.global.frame)

  3. Return $find_map<id, varTypeIR>(frame, id)

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let frame be TC.global.frame)

      3. Return $find_map<id, varTypeIR>(frame, id)

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let frame be TC.block.frame)

      3. (Let varTypeIR'? be $find_map<id, varTypeIR>(frame, id))

      4. If ((varTypeIR'? matches pattern (_))), then

        1. (Let ?(varTypeIR) be varTypeIR'?)

        2. Return ?(varTypeIR)

      5. If ((?() = $find_map<id, varTypeIR>(frame, id))), then

        1. Return $find_var((global), TC, (` id))

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let frame* be TC.local.frames)

      3. (Let varTypeIR'? be $find_maps<id, varTypeIR>(frame*, id))

      4. If ((varTypeIR'? matches pattern (_))), then

        1. (Let ?(varTypeIR) be varTypeIR'?)

        2. Return ?(varTypeIR)

      5. If ((?() = $find_maps<id, varTypeIR>(frame*, id))), then

        1. Return $find_var((block), TC, (` id))

;; ../../../../spec-concrete/5.02-context.watsup:354.1-354.63
def $find_value(p', TC, prefixedNameIR)

1. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. id) be prefixedNameIR)

  2. (Let frame be TC.global.frame)

  3. (Let varTypeIR? be $find_map<id, varTypeIR>(frame, id))

  4. If ((varTypeIR? matches pattern (_))), then

    1. (Let ?((_direction _typeIR _ctk value'?)) be varTypeIR?)

    2. If ((value'? matches pattern (_))), then

      1. (Let ?(value) be value'?)

      2. Return value

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let frame be TC.global.frame)

      3. (Let varTypeIR? be $find_map<id, varTypeIR>(frame, id))

      4. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((_direction _typeIR _ctk value'?)) be varTypeIR?)

        2. If ((value'? matches pattern (_))), then

          1. (Let ?(value) be value'?)

          2. Return value

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let frame be TC.block.frame)

      3. (Let varTypeIR? be $find_map<id, varTypeIR>(frame, id))

      4. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((_direction _typeIR _ctk value'?)) be varTypeIR?)

        2. If ((value'? matches pattern (_))), then

          1. (Let ?(value) be value'?)

          2. Return value

      5. If ((?() = $find_map<id, varTypeIR>(frame, id))), then

        1. Return $find_value((global), TC, (` id))

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let frame* be TC.local.frames)

      3. (Let varTypeIR? be $find_maps<id, varTypeIR>(frame*, id))

      4. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((_direction _typeIR _ctk value'?)) be varTypeIR?)

        2. If ((value'? matches pattern (_))), then

          1. (Let ?(value) be value'?)

          2. Return value

      5. If ((?() = $find_maps<id, varTypeIR>(frame*, id))), then

        1. Return $find_value((block), TC, (` id))

;; ../../../../spec-concrete/5.02-context.watsup:377.1-377.67
def $find_type(p', TC, prefixedNameIR)

1. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. tid) be prefixedNameIR)

  2. (Let tdenv be TC.global.tdenv)

  3. Return $find_map<tid, typeDefIR>(tdenv, tid)

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` tid) be prefixedNameIR)

      2. (Let tdenv be TC.global.tdenv)

      3. Return $find_map<tid, typeDefIR>(tdenv, tid)

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` tid) be prefixedNameIR)

      2. (Let tdenv be TC.block.tdenv)

      3. (Let typeDefIR'? be $find_map<tid, typeDefIR>(tdenv, tid))

      4. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. Return ?(typeDefIR)

      5. If ((?() = $find_map<tid, typeDefIR>(tdenv, tid))), then

        1. Return $find_type((global), TC, (` tid))

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` tid) be prefixedNameIR)

      2. (Let tdenv* be [TC.local.tdenv])

      3. (Let typeDefIR'? be $find_maps<tid, typeDefIR>(tdenv*, tid))

      4. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. Return ?(typeDefIR)

      5. If ((?() = $find_maps<tid, typeDefIR>(tdenv*, tid))), then

        1. Return $find_type((block), TC, (` tid))

;; ../../../../spec-concrete/5.02-context.watsup:400.1-400.41
def $ids_arguments(argumentIR*)

1. Return $id_argument(argumentIR)*

;; ../../../../spec-concrete/5.02-context.watsup:401.1-401.35
def $id_argument(argumentIR)

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. Return ?()

2. Case analysis on argumentIR

  1. Case (% matches pattern `%=%`)

    1. (Let (nameIR = _typedExpressionIR) be argumentIR)

    2. Return ?(nameIR)

  2. Case (% matches pattern `%=_`)

    1. (Let (nameIR =_) be argumentIR)

    2. Return ?(nameIR)

  3. Case (% matches pattern `_`)

    1. Return ?()

;; ../../../../spec-concrete/5.02-context.watsup:409.1-410.34
def $find_routine_overloaded(cursor, TC, prefixedNameIR, argumentIR*)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Case analysis on prefixedNameIR

      1. Case (% matches pattern `.%`)

        1. (Let (. id) be prefixedNameIR)

        2. (Let rdenv be TC.global.rdenv)

        3. (Let id_arg?* be $ids_arguments(argumentIR*))

        4. Return $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?*)

      2. Case (% matches pattern ``%`)

        1. (Let (` id) be prefixedNameIR)

        2. (Let rdenv be TC.global.rdenv)

        3. (Let id_arg?* be $ids_arguments(argumentIR*))

        4. Return $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?*)

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let rdenv be TC.block.rdenv)

      3. (Let id_arg?* be $ids_arguments(argumentIR*))

      4. (Let (rid, routineTypeDefIR, id*)? be $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?*))

      5. If (((rid, routineTypeDefIR, id*)? matches pattern (_))), then

        1. (Let ?((rid, routineTypeDefIR, id_default*)) be (rid, routineTypeDefIR, id*)?)

        2. Return ?((rid, routineTypeDefIR, id_default*))

      6. If ((?() = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?*))), then

        1. Return $find_routine_overloaded((global), TC, (` id), argumentIR*)

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. Return $find_routine_overloaded((block), TC, (` id), argumentIR*)

;; ../../../../spec-concrete/5.02-context.watsup:435.1-436.22
def $find_routine_non_overloaded(p', TC, prefixedNameIR)

1. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. id) be prefixedNameIR)

  2. Return $find_non_overloaded<routineTypeDefIR>(TC.global.rdenv, id)

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. Return $find_non_overloaded<routineTypeDefIR>(TC.global.rdenv, id)

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let routineTypeDefIR'? be $find_non_overloaded<routineTypeDefIR>(TC.block.rdenv, id))

      3. If ((routineTypeDefIR'? matches pattern (_))), then

        1. (Let ?(routineTypeDefIR) be routineTypeDefIR'?)

        2. Return ?(routineTypeDefIR)

      4. If ((?() = $find_non_overloaded<routineTypeDefIR>(TC.block.rdenv, id))), then

        1. Return $find_routine_non_overloaded((global), TC, (` id))

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. Return $find_routine_non_overloaded((block), TC, (` id))

;; ../../../../spec-concrete/5.02-context.watsup:454.1-455.38
def $find_constructor_overloaded(TC, prefixedNameIR, argumentIR*)

1. Case analysis on prefixedNameIR

  1. Case (% matches pattern `.%`)

    1. (Let (. id) be prefixedNameIR)

    2. (Let cdenv be TC.global.cdenv)

    3. (Let id_arg?* be $ids_arguments(argumentIR*))

    4. Return $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?*)

  2. Case (% matches pattern ``%`)

    1. (Let (` id) be prefixedNameIR)

    2. (Let cdenv be TC.global.cdenv)

    3. (Let id_arg?* be $ids_arguments(argumentIR*))

    4. Return $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?*)

;; ../../../../spec-concrete/5.02-context.watsup:468.1-468.47
def $find_return_type(TC)

1. (Let localKind be TC.local.kind)

2. Case analysis on localKind

  1. Case (% matches pattern `FUNCTION->%`)

    1. (Let (function-> typeIR_ret) be localKind)

    2. Return ?(typeIR_ret)

  2. Case (% matches pattern `EXTERN_FUNCTION->%`)

    1. (Let (extern_function-> typeIR_ret) be localKind)

    2. Return ?(typeIR_ret)

  3. Case (% matches pattern `EXTERN_METHOD->%`)

    1. (Let (extern_method-> typeIR_ret) be localKind)

    2. Return ?(typeIR_ret)

  4. Case (% matches pattern `EXTERN_METHODABSTRACT->%`)

    1. (Let (extern_methodabstract-> typeIR_ret) be localKind)

    2. Return ?(typeIR_ret)

3. If (((action) = TC.local.kind)), then

  1. Return ?(((void) as typeIR))

4. If (((control_apply_method) = TC.local.kind)), then

  1. Return ?(((void) as typeIR))

5. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.03-table-context.watsup:5.19-5.31
syntax matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.03-table-context.watsup:7.22-7.72
syntax matchAction = (prefixedNameIR, parameterTypeIR*, argumentListIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:10.3-13.24
syntax matchPriority = {values nat*, init bool, delta nat, largest_wins bool}

;; ../../../../spec-concrete/5.03-table-context.watsup:16.3-17.17
syntax matchEntry = {size nat, const bool}

;; ../../../../spec-concrete/5.03-table-context.watsup:21.1-27.11
syntax matchMode = 
   | nopri
   | noprilpm nat
   | pri
   | prilpm

;; ../../../../spec-concrete/5.03-table-context.watsup:30.3-34.21
syntax tableContext = {keys matchKey*, actions matchAction*, priorities matchPriority, entries matchEntry, mode matchMode}

;; ../../../../spec-concrete/5.03-table-context.watsup:44.1-46.10
syntax tableEntryState = 
   | lpm nat
   | nolpm

;; ../../../../spec-concrete/5.03-table-context.watsup:54.1-54.38
def $empty_tableContext

1. (Let matchPriority be {values [], init false, delta 1, largest_wins true})

2. (Let matchEntry be {size 0, const true})

3. Return {keys [], actions [], priorities matchPriority, entries matchEntry, mode (nopri)}

;; ../../../../spec-concrete/5.03-table-context.watsup:76.1-76.54
def $add_key(TBLC, id, typeIR)

1. (Let matchKey be (typeIR, id))

2. Return TBLC[keys = TBLC.keys ++ [matchKey]]

;; ../../../../spec-concrete/5.03-table-context.watsup:84.1-84.95
def $add_action(TBLC, prefixedNameIR, parameterTypeIR*, argumentListIR)

1. (Let matchAction be (prefixedNameIR, parameterTypeIR*, argumentListIR))

2. Return TBLC[actions = TBLC.actions ++ [matchAction]]

;; ../../../../spec-concrete/5.03-table-context.watsup:92.1-92.58
def $add_table_priority(TBLC, n)

1. Return TBLC[priorities.values = TBLC.priorities.values ++ [n]]

;; ../../../../spec-concrete/5.03-table-context.watsup:103.1-103.58
def $update_mode(TBLC, id, typeIR)

1. Return $update_mode'(TBLC, id, $canon(typeIR))

;; ../../../../spec-concrete/5.03-table-context.watsup:104.1-104.59
def $update_mode'(TBLC, text', typeIR'')

1. Case analysis on text'

  1. Case (% = "lpm")

    1. Case analysis on typeIR''

      1. Case (% has type numberTypeIR)

        1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

        2. Case analysis on numberTypeIR

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< n >) be numberTypeIR)

            2. If ((TBLC.mode matches pattern `NOPRI`)), then

              1. Return TBLC[mode = (noprilpm n)]

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< n >) be numberTypeIR)

            2. If ((TBLC.mode matches pattern `NOPRI`)), then

              1. Return TBLC[mode = (noprilpm n)]

          3. Case (% matches pattern `VARBIT<%>`)

            1. (Let (varbit< n >) be numberTypeIR)

            2. If ((TBLC.mode matches pattern `NOPRI`)), then

              1. Return TBLC[mode = (noprilpm n)]

      2. Case (% has type aliasTypeIR)

        1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

        2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

          1. (Let (type _tid typeIR'') be aliasTypeIR)

          2. Return $update_mode(TBLC, "lpm", typeIR'')

    2. If ((TBLC.mode matches pattern `PRI`)), then

      1. Return TBLC[mode = (prilpm)]

  2. Case (% = "range")

    1. If ((TBLC.mode matches pattern `NOPRI`)), then

      1. Return TBLC[mode = (pri)]

    2. (Let matchMode be TBLC.mode)

    3. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (noprilpm _nat) be matchMode)

      2. Return TBLC[mode = (prilpm)]

  3. Case (% = "ternary")

    1. If ((TBLC.mode matches pattern `NOPRI`)), then

      1. Return TBLC[mode = (pri)]

    2. (Let matchMode be TBLC.mode)

    3. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (noprilpm _nat) be matchMode)

      2. Return TBLC[mode = (prilpm)]

  4. Case (% = "optional")

    1. If ((TBLC.mode matches pattern `NOPRI`)), then

      1. Return TBLC[mode = (pri)]

    2. (Let matchMode be TBLC.mode)

    3. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (noprilpm _nat) be matchMode)

      2. Return TBLC[mode = (prilpm)]

2. Otherwise

  1. Return TBLC

;; ../../../../spec-concrete/5.03-table-context.watsup:138.1-138.85
def $find_action(TBLC, prefixedNameIR)

1. Return $find_action'(TBLC.actions, prefixedNameIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:139.1-139.86
def $find_action'(matchAction*, prefixedNameIR)

1. Case analysis on matchAction*

  1. Case (% matches pattern [])

    1. Return ?()

  2. Case (% matches pattern _ :: _)

    1. (Let matchAction_h :: matchAction_t* be matchAction*)

    2. (Let (prefixedNameIR', parameterTypeIR*, argumentListIR) be matchAction_h)

    3. Case analysis on prefixedNameIR'

      1. Case (% = prefixedNameIR)

        1. Return ?((parameterTypeIR*, argumentListIR))

      2. Case (% =/= prefixedNameIR)

        1. Return $find_action'(matchAction_t*, prefixedNameIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:156.1-156.50
def $find_table_priority_last(TBLC)

1. (Let n* be TBLC.priorities.values)

2. Return n*[(|n*| - 1)]

;; ../../../../spec-concrete/5.03-table-context.watsup:165.1-165.78
def $join_tableEntryState(tableEntryState, tableEntryState')

1. Case analysis on tableEntryState

  1. Case (% matches pattern `NOLPM`)

    1. Case analysis on tableEntryState'

      1. Case (% matches pattern `LPM%`)

        1. (Let (lpm n) be tableEntryState')

        2. Return (lpm n)

      2. Case (% matches pattern `NOLPM`)

        1. Return (nolpm)

  2. Case (% matches pattern `LPM%`)

    1. (Let (lpm n) be tableEntryState)

    2. If ((tableEntryState' matches pattern `NOLPM`)), then

      1. Return (lpm n)

;; ../../../../spec-concrete/5.03-table-context.watsup:171.1-171.40
def $tableEntry_lpm_prefix(value)

1. Return $tableEntry_lpm_prefix'(value, 0)

;; ../../../../spec-concrete/5.03-table-context.watsup:172.1-172.46
def $tableEntry_lpm_prefix'(value, n_prefix')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `%W%`)), then

    1. (Let (nat w _int) be numberLiteral)

    2. If ((nat = 0)), then

      1. Return n_prefix'

    3. If ((_int has type nat)), then

      1. (Let n be (_int as nat))

      2. If ((nat > 0)), then

        1. If (((n \ 2) =/= 0)), then

          1. (Let value' be (((nat - 1) w (((n - 1) / 2) as int)) as value))

          2. Return $tableEntry_lpm_prefix'(value', (n_prefix' + 1))

      3. If ((n_prefix' = 0)), then

        1. If ((nat > 0)), then

          1. If (((n \ 2) = 0)), then

            1. (Let value' be (((nat - 1) w ((n / 2) as int)) as value))

            2. Return $tableEntry_lpm_prefix'(value', 0)

;; ../../../../spec-concrete/5.03-wellformed.watsup:5.1-7.20
relation Type_wf: 

  basetype: bound |- typeIR {

    1. If ((typeIR has type baseTypeIR)), then

      1. (Let baseTypeIR be (typeIR as baseTypeIR))

      2. The relation holds

  }

  tid: bound |- typeIR {

    1. If ((typeIR has type namedTypeIR)), then

      1. (Let namedTypeIR be (typeIR as namedTypeIR))

      2. If ((namedTypeIR matches pattern `TID%`)), then

        1. (Let (tid tid) be namedTypeIR)

        2. If ($in_set<tid>(tid, bound)), then

          1. The relation holds

  }

  spectype: bound |- typeIR' {

    1. If ((typeIR' has type namedTypeIR)), then

      1. (Let namedTypeIR be (typeIR' as namedTypeIR))

      2. If ((namedTypeIR matches pattern `%<%>`)), then

        1. (Let (polyTypeDefIR < typeIR_arg* >) be namedTypeIR)

        2. (Let typeIR be $specialize_typeDef((polyTypeDefIR as typeDefIR), typeIR_arg*))

        3. If ((Type_wf: bound |- typeIR holds)), then

          1. The relation holds

  }

  typedeftype: bound |- typeIR' {

    1. If ((typeIR' has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

        1. (Let (typedef _tid typeIR) be aliasTypeIR)

        2. If ($nestable_typedef(typeIR)), then

          1. If ((Type_wf: bound |- typeIR holds)), then

            1. The relation holds

  }

  newtype: bound |- typeIR' {

    1. If ((typeIR' has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

        1. (Let (type _tid typeIR) be aliasTypeIR)

        2. If ($nestable_new(typeIR)), then

          1. If ((Type_wf: bound |- typeIR holds)), then

            1. The relation holds

  }

  listttype: bound |- typeIR' {

    1. If ((typeIR' has type listTypeIR)), then

      1. (Let (list< typeIR >) be (typeIR' as listTypeIR))

      2. If ($nestable_list(typeIR)), then

        1. If ((Type_wf: bound |- typeIR holds)), then

          1. The relation holds

  }

  tupletype: bound |- typeIR' {

    1. If ((typeIR' has type tupleTypeIR)), then

      1. (Let (tuple< typeIR* >) be (typeIR' as tupleTypeIR))

      2. If ($nestable_tuple(typeIR))*, then

        1. If ((Type_wf: bound |- typeIR holds))*, then

          1. The relation holds

  }

  stacktype: bound |- typeIR' {

    1. If ((typeIR' has type headerStackTypeIR)), then

      1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

      2. If ($nestable_stack(typeIR)), then

        1. If ((Type_wf: bound |- typeIR holds)), then

          1. The relation holds

  }

  structtype: bound |- typeIR' {

    1. If ((typeIR' has type structTypeIR)), then

      1. (Let (struct _tid { (typeIR id ;)* }) be (typeIR' as structTypeIR))

      2. If ($distinct_<id>(id*)), then

        1. If ($nestable_struct(typeIR))*, then

          1. If ((Type_wf: bound |- typeIR holds))*, then

            1. The relation holds

  }

  headertype: bound |- typeIR' {

    1. If ((typeIR' has type headerTypeIR)), then

      1. (Let (header _tid { (typeIR id ;)* }) be (typeIR' as headerTypeIR))

      2. If ($distinct_<id>(id*)), then

        1. If ($nestable_header(typeIR))*, then

          1. If ((Type_wf: bound |- typeIR holds))*, then

            1. The relation holds

  }

  headeruniontype: bound |- typeIR' {

    1. If ((typeIR' has type headerUnionTypeIR)), then

      1. (Let (header_union _tid { (typeIR id ;)* }) be (typeIR' as headerUnionTypeIR))

      2. If ($distinct_<id>(id*)), then

        1. If ($nestable_headerunion(typeIR))*, then

          1. If ((Type_wf: bound |- typeIR holds))*, then

            1. The relation holds

  }

  enumtype: bound |- typeIR {

    1. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

        1. (Let (enum _tid { id* }) be enumTypeIR)

        2. If ($distinct_<id>(id*)), then

          1. The relation holds

  }

  serenumtype: bound |- typeIR' {

    1. If ((typeIR' has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR' as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR { (id = _value ;)* }) be enumTypeIR)

        2. If ($distinct_<id>(id*)), then

          1. If ($nestable_serenum(typeIR)), then

            1. If ((Type_wf: bound |- typeIR holds)), then

              1. The relation holds

  }

  externtype: bound |- typeIR {

    1. If ((typeIR has type externObjectTypeIR)), then

      1. (Let (extern _tid ({ (_rid : routineTypeDefIR)* })) be (typeIR as externObjectTypeIR))

      2. If ((RoutineTypeDef_wf: bound |- routineTypeDefIR holds))*, then

        1. The relation holds

  }

  parsertype: bound |- typeIR {

    1. If ((typeIR has type parserObjectTypeIR)), then

      1. (Let (parser( parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

      2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

        1. The relation holds

  }

  controltype: bound |- typeIR {

    1. If ((typeIR has type controlObjectTypeIR)), then

      1. (Let (control( parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

      2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

        1. The relation holds

  }

  packagetype: bound |- typeIR' {

    1. If ((typeIR' has type packageObjectTypeIR)), then

      1. (Let (package< typeIR* >) be (typeIR' as packageObjectTypeIR))

      2. If ((Type_wf: bound |- typeIR holds))*, then

        1. The relation holds

  }

  tabletype: bound |- typeIR' {

    1. If ((typeIR' has type tableObjectTypeIR)), then

      1. (Let (table _tid # typeIR) be (typeIR' as tableObjectTypeIR))

      2. (Let typeIR'' be $canon(typeIR))

      3. If ((typeIR'' has type tableTypeIR)), then

        1. (Let tableTypeIR be (typeIR'' as tableTypeIR))

        2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

          1. (Let (table_struct _tid' { _fieldTypeIR* }) be tableTypeIR)

          2. If ((Type_wf: bound |- typeIR holds)), then

            1. The relation holds

  }

  defaulttype: bound |- typeIR {

    1. If ((typeIR = ((default) as typeIR))), then

      1. The relation holds

  }

  sequencetype: bound |- typeIR' {

    1. If ((typeIR' has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

        1. (Let (seq< typeIR* >) be sequenceTypeIR)

        2. If ((Type_wf: bound |- typeIR holds))*, then

          1. The relation holds

  }

  sequencedefaulttype: bound |- typeIR' {

    1. If ((typeIR' has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

        1. (Let (seq< typeIR* ,...>) be sequenceTypeIR)

        2. If ((Type_wf: bound |- typeIR holds))*, then

          1. The relation holds

  }

  recordtype: bound |- typeIR' {

    1. If ((typeIR' has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR' as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%}`)), then

        1. (Let (record{ (typeIR id ;)* }) be recordTypeIR)

        2. If ($distinct_<id>(id*)), then

          1. If ((Type_wf: bound |- typeIR holds))*, then

            1. The relation holds

  }

  recorddefaulttype: bound |- typeIR' {

    1. If ((typeIR' has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR' as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

        1. (Let (record{ (typeIR id ;)* ,...}) be recordTypeIR)

        2. If ($distinct_<id>(id*)), then

          1. If ((Type_wf: bound |- typeIR holds))*, then

            1. The relation holds

  }

  invalidtype: bound |- typeIR {

    1. If ((typeIR = ((header_invalid) as typeIR))), then

      1. The relation holds

  }

  settype: bound |- typeIR'' {

    1. If ((typeIR'' has type setTypeIR)), then

      1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

      2. If ((typeIR'* matches pattern [ _/1 ])), then

        1. (Let [typeIR] be typeIR'*)

        2. If ($nestable_set(typeIR)), then

          1. If ((Type_wf: bound |- typeIR holds)), then

            1. The relation holds

  }

  tableenumtype: bound |- typeIR {

    1. If ((typeIR has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TABLE_ENUM%{%}`)), then

        1. (Let (table_enum _tid { id* }) be tableTypeIR)

        2. If ($distinct_<id>(id*)), then

          1. The relation holds

  }

  tablestructtype: bound |- typeIR {

    1. If ((typeIR has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

        1. (Let (table_struct _tid { _fieldTypeIR* }) be tableTypeIR)

        2. The relation holds

  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:9.1-11.20
relation TypeDef_wf: 

  mono: bound |- typeDefIR {

    1. If ((typeDefIR has type typeIR)), then

      1. (Let typeIR be (typeDefIR as typeIR))

      2. If ($definable_type_mono(typeIR)), then

        1. If ((Type_wf: bound |- typeIR holds)), then

          1. The relation holds

  }

  poly: bound |- typeDefIR {

    1. If ((typeDefIR has type polyTypeDefIR)), then

      1. (Let (typeIR < tid_expl* , tid_impl* >) be (typeDefIR as polyTypeDefIR))

      2. If ($definable_type_poly(typeIR)), then

        1. If ($distinct_<tid>(tid_expl* ++ tid_impl*)), then

          1. (Let bound_inner be $union_set<tid>(bound, ({ tid_expl* ++ tid_impl* })))

          2. If ((Type_wf: bound_inner |- typeIR holds)), then

            1. The relation holds

  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:13.1-15.20
relation ParameterType_wf: 

  default-empty-extern: bound |- direction typeIR _id value?{value <- value?} {

    1. If ((direction matches pattern ``EMPTY`)), then

      1. If ((value? matches pattern ())), then

        1. If ((Type_wf: bound |- typeIR holds)), then

          1. If ($is_extern_object_typeIR($canon(typeIR))), then

            1. The relation holds

  }

  default-none-not-extern: bound |- direction typeIR _id value?{value <- value?} {

    1. If ((value? matches pattern ())), then

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. If (~$is_extern_object_typeIR($canon(typeIR))), then

          1. The relation holds

  }

  default-some-extern: bound |- direction typeIR _id value'?{value' <- value'?} {

    1. If ((direction matches pattern ``EMPTY`)), then

      1. If ((value'? matches pattern (_))), then

        1. (Let ?(value) be value'?)

        2. If ((Type_wf: bound |- typeIR holds)), then

          1. If ($is_extern_object_typeIR($canon(typeIR))), then

            1. The relation holds

  }

  default-some-not-extern: bound |- direction typeIR _id value'?{value' <- value'?} {

    1. If ((value'? matches pattern (_))), then

      1. (Let ?(value) be value'?)

      2. If ((Type_wf: bound |- typeIR holds)), then

        1. If (~$is_extern_object_typeIR($canon(typeIR))), then

          1. If (((direction = (in)) \/ (direction = ()))), then

            1. The relation holds

  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:17.1-19.20
relation ParameterTypes_wf: 

  : bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} {

    1. (Let (_direction _typeIR id _value?) be parameterTypeIR)*

    2. If ($distinct_<id>(id*)), then

      1. If ((ParameterType_wf: bound |- parameterTypeIR holds))*, then

        1. The relation holds

  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:21.1-23.20
relation RoutineType_wf: 

  builtinfunction: bound |- routineTypeIR {

    1. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `BUILTIN_FUNCTION(%)->%`)), then

        1. (Let (builtin_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. If ((Type_wf: bound |- typeIR_ret holds)), then

            1. The relation holds

  }

  functiontype: bound |- routineTypeIR {

    1. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `FUNCTION(%)->%`)), then

        1. (Let (function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($nestable_function(direction, typeIR))*, then

            1. If ((Type_wf: bound |- typeIR_ret holds)), then

              1. The relation holds

  }

  actiontype: bound |- routineTypeIR {

    1. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `ACTION(%)`)), then

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($directionless_trailing(direction*)), then

            1. If ($nestable_action(direction, typeIR))*, then

              1. The relation holds

  }

  externfunctiontype: bound |- routineTypeIR {

    1. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `EXTERN_FUNCTION(%)->%`)), then

        1. (Let (extern_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($nestable_externfunction(direction, typeIR))*, then

            1. If ((Type_wf: bound |- typeIR_ret holds)), then

              1. The relation holds

  }

  builtinmethod: bound |- routineTypeIR {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `BUILTIN_METHOD(%)->%`)), then

        1. (Let (builtin_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. If ((Type_wf: bound |- typeIR_ret holds)), then

            1. The relation holds

  }

  externmethod: bound |- routineTypeIR {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `EXTERN_METHOD(%)->%`)), then

        1. (Let (extern_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($nestable_externmethod(direction, typeIR))*, then

            1. If ((Type_wf: bound |- typeIR_ret holds)), then

              1. The relation holds

  }

  externabstractmethod: bound |- routineTypeIR {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

        1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($nestable_externabstractmethod(direction, typeIR))*, then

            1. If ((Type_wf: bound |- typeIR_ret holds)), then

              1. The relation holds

  }

  parserapplymethod: bound |- routineTypeIR {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `PARSER_APPLY(%)`)), then

        1. (Let (parser_apply( parameterTypeIR* )) be methodTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($nestable_parserapplymethod(direction, typeIR))*, then

            1. The relation holds

  }

  controlapplymethod: bound |- routineTypeIR {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `CONTROL_APPLY(%)`)), then

        1. (Let (control_apply( parameterTypeIR* )) be methodTypeIR)

        2. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

          1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

          2. If ($nestable_controlapplymethod(direction, typeIR))*, then

            1. The relation holds

  }

  tableapplymethod: bound |- routineTypeIR {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `TABLE_APPLY->%`)), then

        1. (Let (table_apply-> typeIR) be methodTypeIR)

        2. If ((typeIR has type tableTypeIR)), then

          1. (Let tableTypeIR be (typeIR as tableTypeIR))

          2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

            1. (Let (table_struct _tid { _fieldTypeIR* }) be tableTypeIR)

            2. The relation holds

  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:25.1-27.20
relation RoutineTypeDef_wf: 

  mono: bound |- routineTypeDefIR {

    1. If ((routineTypeDefIR has type routineTypeIR)), then

      1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

      2. If ($definable_routine_mono(routineTypeIR)), then

        1. If ((RoutineType_wf: bound |- routineTypeIR holds)), then

          1. The relation holds

  }

  poly: bound |- routineTypeDefIR {

    1. If ((routineTypeDefIR has type polyRoutineTypeDefIR)), then

      1. (Let (routineTypeIR < tid_expl* , tid_impl* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

      2. If ($definable_routine_poly(routineTypeIR)), then

        1. If ($distinct_<tid>(tid_expl* ++ tid_impl*)), then

          1. (Let bound_inner be $union_set<tid>(bound, ({ tid_expl* ++ tid_impl* })))

          2. If ((RoutineType_wf: bound_inner |- routineTypeIR holds)), then

            1. The relation holds

  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:29.1-31.20
relation ConstructorParameterType_wf: 

  : bound |- direction typeIR _id _value?{_value <- _value?} {

    1. If ((direction matches pattern ``EMPTY`)), then

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. The relation holds

  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:33.1-35.20
relation ConstructorParameterTypes_wf: 

  : bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} {

    1. (Let (_direction _typeIR id _value?) be parameterTypeIR)*

    2. If ($distinct_<id>(id*)), then

      1. If ((ConstructorParameterType_wf: bound |- parameterTypeIR holds))*, then

        1. The relation holds

  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:37.1-39.20
relation ConstructorType_wf: 

  externtype: bound |- constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object {

    1. If ((ConstructorParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. If ((Type_wf: bound |- typeIR_object holds)), then

        1. (Let typeIR' be $canon(typeIR_object))

        2. If ((typeIR' has type externObjectTypeIR)), then

          1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR' as externObjectTypeIR))

          2. (Let (_direction typeIR _id _value?) be parameterTypeIR)*

          3. If ($nestable_constructor_extern(typeIR))*, then

            1. The relation holds

  }

  parsertype: bound |- constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object {

    1. If ((ConstructorParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. If ((Type_wf: bound |- typeIR_object holds)), then

        1. (Let typeIR' be $canon(typeIR_object))

        2. If ((typeIR' has type parserObjectTypeIR)), then

          1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

          2. (Let (_direction typeIR _id _value?) be parameterTypeIR)*

          3. If ($nestable_constructor_parser(typeIR))*, then

            1. The relation holds

  }

  controltype: bound |- constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object {

    1. If ((ConstructorParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. If ((Type_wf: bound |- typeIR_object holds)), then

        1. (Let typeIR' be $canon(typeIR_object))

        2. If ((typeIR' has type controlObjectTypeIR)), then

          1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

          2. (Let (_direction typeIR _id _value?) be parameterTypeIR)*

          3. If ($nestable_constructor_control(typeIR))*, then

            1. The relation holds

  }

  packagetype: bound |- constructor( parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} )-> typeIR_object {

    1. If ((ConstructorParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. If ((Type_wf: bound |- typeIR_object holds)), then

        1. (Let typeIR' be $canon(typeIR_object))

        2. If ((typeIR' has type packageObjectTypeIR)), then

          1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

          2. (Let (_direction typeIR _id _value?) be parameterTypeIR)*

          3. If ($nestable_constructor_package(typeIR))*, then

            1. The relation holds

  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:41.1-43.20
relation ConstructorTypeDef_wf: 

  : bound |- constructorTypeIR < tid_expl*{tid_expl <- tid_expl*} , tid_impl*{tid_impl <- tid_impl*} > {

    1. (Let (constructor( _constructorParameterTypeIR* )-> typeIR_object) be constructorTypeIR)

    2. If ($definable_constructor(typeIR_object)), then

      1. If ($distinct_<tid>(tid_expl* ++ tid_impl*)), then

        1. (Let bound_inner be $union_set<tid>(bound, ({ tid_expl* ++ tid_impl* })))

        2. If ((ConstructorType_wf: bound_inner |- constructorTypeIR holds)), then

          1. The relation holds

  }

;; ../../../../spec-concrete/5.03-wellformed.watsup:98.1-98.37
def $nestable_typedef(typeIR)

1. Return $nestable'_typedef($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:99.1-99.38
def $nestable'_typedef(typeIR')

1. If ((typeIR' = ((bool) as typeIR))), then

  1. Return true

2. If ((typeIR' = ((error) as typeIR))), then

  1. Return true

3. If ((typeIR' = ((string) as typeIR))), then

  1. Return true

4. Case analysis on typeIR'

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  4. Case (% has type dataTypeIR)

    1. (Let dataTypeIR be (typeIR' as dataTypeIR))

    2. Return true

5. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:117.1-117.33
def $nestable_new(typeIR)

1. Return $nestable'_new($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:118.1-118.34
def $nestable'_new(typeIR')

1. If ((typeIR' = ((bool) as typeIR))), then

  1. Return true

2. Case analysis on typeIR'

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:136.1-136.34
def $nestable_list(typeIR)

1. Return $nestable'_list($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:137.1-137.35
def $nestable'_list(typeIR')

1. If ((typeIR' = ((bool) as typeIR))), then

  1. Return true

2. If ((typeIR' = ((error) as typeIR))), then

  1. Return true

3. If ((typeIR' = ((match_kind) as typeIR))), then

  1. Return true

4. If ((typeIR' = ((string) as typeIR))), then

  1. Return true

5. Case analysis on typeIR'

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  4. Case (% has type dataTypeIR)

    1. (Let dataTypeIR be (typeIR' as dataTypeIR))

    2. Return true

6. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:156.1-156.35
def $nestable_tuple(typeIR)

1. Return $nestable'_tuple($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:157.1-157.36
def $nestable'_tuple(typeIR'')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return true

2. If ((typeIR'' = ((error) as typeIR))), then

  1. Return true

3. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      3. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  4. Case (% has type tupleTypeIR)

    1. (Let (tuple< _typeIR* >) be (typeIR'' as tupleTypeIR))

    2. Return true

  5. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ _nat ]) be (typeIR'' as headerStackTypeIR))

    2. Return true

  6. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR'' as headerTypeIR))

    2. Return true

  7. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR'' as headerUnionTypeIR))

    2. Return true

  8. Case (% has type structTypeIR)

    1. (Let (struct _tid { _fieldTypeIR* }) be (typeIR'' as structTypeIR))

    2. Return true

  9. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

4. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:182.1-182.35
def $nestable_stack(typeIR)

1. Return $nestable'_stack($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:183.1-183.36
def $nestable'_stack(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  2. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR' as headerTypeIR))

    2. Return true

  3. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR' as headerUnionTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:197.1-197.36
def $nestable_struct(typeIR)

1. Return $nestable'_struct($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:198.1-198.37
def $nestable'_struct(typeIR'')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return true

2. If ((typeIR'' = ((error) as typeIR))), then

  1. Return true

3. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

      3. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  4. Case (% has type tupleTypeIR)

    1. (Let (tuple< _typeIR* >) be (typeIR'' as tupleTypeIR))

    2. Return true

  5. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ _nat ]) be (typeIR'' as headerStackTypeIR))

    2. Return true

  6. Case (% has type structTypeIR)

    1. (Let (struct _tid { _fieldTypeIR* }) be (typeIR'' as structTypeIR))

    2. Return true

  7. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR'' as headerTypeIR))

    2. Return true

  8. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR'' as headerUnionTypeIR))

    2. Return true

  9. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

4. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:224.1-224.36
def $nestable_header(typeIR)

1. Return $nestable'_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:225.1-225.37
def $nestable'_header(typeIR'')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return true

2. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

      3. Case (% matches pattern `VARBIT<%>`)

        1. (Let (varbit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  4. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

      2. Return true

  5. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR'' _id ;)* }) be (typeIR'' as structTypeIR))

    2. If ($nestable_struct_in_header(typeIR''))*, then

      1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:226.1-226.46
def $nestable_struct_in_header(typeIR)

1. Return $nestable'_struct_in_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:227.1-227.47
def $nestable'_struct_in_header(typeIR'')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return true

2. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  4. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

      2. Return true

  5. Case (% has type structTypeIR)

    1. (Let (struct _tid { (typeIR'' _id ;)* }) be (typeIR'' as structTypeIR))

    2. If ($nestable_struct_in_header(typeIR''))*, then

      1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:261.1-261.41
def $nestable_headerunion(typeIR)

1. Return $nestable'_headerunion($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:262.1-262.42
def $nestable'_headerunion(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  3. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR' as headerTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:282.1-282.37
def $nestable_serenum(typeIR)

1. Return $nestable'_serenum($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:283.1-283.38
def $nestable'_serenum(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $nestable_new_in_serenum(typeIR'')

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:284.1-284.44
def $nestable_new_in_serenum(typeIR)

1. Return $nestable_new_in_serenum'($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:285.1-285.45
def $nestable_new_in_serenum'(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:361.1-361.33
def $nestable_set(typeIR)

1. Return $nestable'_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:362.1-362.34
def $nestable'_set(typeIR'')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return true

2. If ((typeIR'' = ((error) as typeIR))), then

  1. Return true

3. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  4. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. If ($nestable_tuple_in_set(typeIR''))*, then

      1. Return true

  5. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

  6. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR'' as sequenceTypeIR))

    2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

      1. (Let (seq< typeIR''* >) be sequenceTypeIR)

      2. If ($nestable_sequence_in_set(typeIR''))*, then

        1. Return true

4. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:363.1-363.42
def $nestable_tuple_in_set(typeIR)

1. Return $nestable'_tuple_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:364.1-364.43
def $nestable'_tuple_in_set(typeIR'')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return true

2. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  4. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. If ($nestable_tuple_in_set(typeIR''))*, then

      1. Return true

  5. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:365.1-365.45
def $nestable_sequence_in_set(typeIR)

1. Return $nestable'_sequence_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:366.1-366.46
def $nestable'_sequence_in_set(typeIR'')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return true

2. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  4. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. If ($nestable_sequence_in_set(typeIR''))*, then

      1. Return true

  5. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

  6. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR'' as sequenceTypeIR))

    2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

      1. (Let (seq< typeIR''* >) be sequenceTypeIR)

      2. If ($nestable_sequence_in_set(typeIR''))*, then

        1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:430.1-430.40
def $definable_type_mono(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid _tid) be namedTypeIR)

      2. Return true

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. Return true

  3. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

  4. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:445.1-445.40
def $definable_type_poly(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type tupleTypeIR)

    1. (Let (tuple< _typeIR* >) be (typeIR' as tupleTypeIR))

    2. Return true

  2. Case (% has type headerStackTypeIR)

    1. (Let (_typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

    2. Return true

  3. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR' as headerTypeIR))

    2. Return true

  4. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR' as headerUnionTypeIR))

    2. Return true

  5. Case (% has type structTypeIR)

    1. (Let (struct _tid { _fieldTypeIR* }) be (typeIR' as structTypeIR))

    2. Return true

  6. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR' as externObjectTypeIR))

    2. Return true

  7. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return true

  8. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return true

  9. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:478.1-478.49
def $nestable_function(direction, typeIR)

1. Return $nestable_function'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:479.1-479.50
def $nestable_function'(direction', typeIR')

1. If ((typeIR' = ((string) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

2. If ((typeIR' = ((int) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

3. If ((typeIR' has type objectTypeIR)), then

  1. (Let objectTypeIR be (typeIR' as objectTypeIR))

  2. Return false

4. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:498.1-498.47
def $directionless_trailing(direction*)

1. Return $directionless_trailing'(true, $rev_<direction>(direction*))

;; ../../../../spec-concrete/5.03-wellformed.watsup:499.1-499.54
def $directionless_trailing'(_bool', direction''*)

1. Case analysis on direction''*

  1. Case (% matches pattern [])

    1. Return true

  2. Case (% matches pattern _ :: _)

    1. (Let direction_h :: direction_t* be direction''*)

    2. If (~(direction_h matches pattern ``EMPTY`)), then

      1. Return $directionless_trailing'(false, direction_t*)

2. Case analysis on _bool'

  1. Case (% = true)

    1. If ((direction''* matches pattern _ :: _)), then

      1. (Let direction'' :: direction_t* be direction''*)

      2. If ((direction'' matches pattern ``EMPTY`)), then

        1. Return $directionless_trailing'(true, direction_t*)

  2. Case (% = false)

    1. If ((direction''* matches pattern _ :: _)), then

      1. (Let direction'' :: direction_t* be direction''*)

      2. If ((direction'' matches pattern ``EMPTY`)), then

        1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:512.1-512.47
def $nestable_action(direction, typeIR)

1. Return $nestable_action'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:513.1-513.48
def $nestable_action'(direction', typeIR')

1. If ((typeIR' = ((string) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

2. If ((typeIR' = ((int) as typeIR))), then

  1. Return false

3. If ((typeIR' has type objectTypeIR)), then

  1. (Let objectTypeIR be (typeIR' as objectTypeIR))

  2. Return false

4. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:531.1-531.55
def $nestable_externfunction(direction, typeIR)

1. Return $nestable_externfunction'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:532.1-532.56
def $nestable_externfunction'(direction', typeIR')

1. If ((typeIR' = ((string) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

2. If ((typeIR' = ((int) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

3. Case analysis on typeIR'

  1. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return false

  2. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return false

  3. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  4. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

4. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:561.1-561.53
def $nestable_externmethod(direction, typeIR)

1. Return $nestable_externmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:562.1-562.54
def $nestable_externmethod'(direction', typeIR')

1. If ((typeIR' = ((string) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

2. If ((typeIR' = ((int) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

3. Case analysis on typeIR'

  1. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return false

  2. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return false

  3. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  4. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

4. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:584.1-584.61
def $nestable_externabstractmethod(direction, typeIR)

1. Return $nestable_externabstractmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:585.1-585.62
def $nestable_externabstractmethod'(direction', typeIR')

1. If ((typeIR' = ((string) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

2. If ((typeIR' = ((int) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

3. Case analysis on typeIR'

  1. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return false

  2. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return false

  3. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  4. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

4. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:607.1-607.58
def $nestable_parserapplymethod(direction, typeIR)

1. Return $nestable_parserapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:608.1-608.59
def $nestable_parserapplymethod'(direction', typeIR')

1. If ((typeIR' = ((string) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

2. If ((typeIR' = ((int) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

3. Case analysis on typeIR'

  1. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return false

  2. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return false

  3. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  4. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

4. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:629.1-629.59
def $nestable_controlapplymethod(direction, typeIR)

1. Return $nestable_controlapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:630.1-630.60
def $nestable_controlapplymethod'(direction', typeIR')

1. If ((typeIR' = ((string) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

2. If ((typeIR' = ((int) as typeIR))), then

  1. If (~(direction' matches pattern ``EMPTY`)), then

    1. Return false

3. Case analysis on typeIR'

  1. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return false

  2. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  3. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

4. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:657.1-657.50
def $definable_routine_mono(routineTypeIR')

1. Case analysis on routineTypeIR'

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR' as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

        1. (Let (builtin_function( _parameterTypeIR* )-> _typeIR) be functionTypeIR)

        2. Return true

      2. Case (% matches pattern `ACTION(%)`)

        1. (Let (action( _parameterTypeIR* )) be functionTypeIR)

        2. Return true

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR' as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

        1. (Let (builtin_method( _parameterTypeIR* )-> _typeIR) be methodTypeIR)

        2. Return true

      2. Case (% matches pattern `PARSER_APPLY(%)`)

        1. (Let (parser_apply( _parameterTypeIR* )) be methodTypeIR)

        2. Return true

      3. Case (% matches pattern `CONTROL_APPLY(%)`)

        1. (Let (control_apply( _parameterTypeIR* )) be methodTypeIR)

        2. Return true

      4. Case (% matches pattern `TABLE_APPLY->%`)

        1. (Let (table_apply-> _typeIR) be methodTypeIR)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:673.1-673.50
def $definable_routine_poly(routineTypeIR')

1. Case analysis on routineTypeIR'

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR' as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `FUNCTION(%)->%`)

        1. (Let (function( _parameterTypeIR* )-> _typeIR) be functionTypeIR)

        2. Return true

      2. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

        1. (Let (extern_function( _parameterTypeIR* )-> _typeIR) be functionTypeIR)

        2. Return true

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR' as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( _parameterTypeIR* )-> _typeIR) be methodTypeIR)

        2. Return true

      2. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( _parameterTypeIR* )-> _typeIR) be methodTypeIR)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:708.1-708.48
def $nestable_constructor_extern(typeIR)

1. Return $nestable'_constructor_extern($canon(typeIR))

2. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:709.1-709.49
def $nestable'_constructor_extern(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return false

  2. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  3. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:728.1-728.48
def $nestable_constructor_parser(typeIR)

1. Return $nestable'_constructor_parser($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:729.1-729.49
def $nestable'_constructor_parser(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return false

  2. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  3. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:747.1-747.49
def $nestable_constructor_control(typeIR)

1. Return $nestable'_constructor_control($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:748.1-748.50
def $nestable'_constructor_control(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return false

  2. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return false

  3. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:766.1-766.49
def $nestable_constructor_package(typeIR)

1. Return $nestable'_constructor_package($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:767.1-767.50
def $nestable'_constructor_package(typeIR')

1. If ((typeIR' has type tableObjectTypeIR)), then

  1. (Let (table _tid # _typeIR) be (typeIR' as tableObjectTypeIR))

  2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:787.1-787.42
def $definable_constructor(typeIR)

1. Return $definable'_constructor($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:788.1-788.43
def $definable'_constructor(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR' as externObjectTypeIR))

    2. Return true

  2. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

    2. Return true

  3. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

    2. Return true

  4. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.04-typing-relation.watsup:6.1-8.23
relation Eval_static: 

  literalExpressionIR-boolean: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR = ((true) as expressionIR))), then

      1. Result in ((b true) as value)

    2. If ((expressionIR = ((false) as expressionIR))), then

      1. Result in ((b false) as value)

  }

  literalExpressionIR-number: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type numberLiteral)), then

      1. (Let numberLiteral be (expressionIR as numberLiteral))

      2. Case analysis on numberLiteral

        1. Case (% matches pattern `D%`)

          1. (Let (d i) be numberLiteral)

          2. Result in ((d i) as value)

        2. Case (% matches pattern `%W%`)

          1. (Let (n w i) be numberLiteral)

          2. Result in ((n w i) as value)

        3. Case (% matches pattern `%S%`)

          1. (Let (n s i) be numberLiteral)

          2. Result in ((n s i) as value)

  }

  literalExpressionIR-stringliteral: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type stringLiteral)), then

      1. (Let (" text ") be (expressionIR as stringLiteral))

      2. Result in ((" text ") as value)

  }

  referenceExpression: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type prefixedNameIR)), then

      1. (Let prefixedNameIR be (expressionIR as prefixedNameIR))

      2. (Let value be $find_value(p, TC, prefixedNameIR))

      3. Result in value

  }

  defaultExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR = ((...) as expressionIR))), then

      1. Result in ((default) as value)

  }

  unaryExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type unaryExpressionIR)), then

      1. (Let (unop typedExpressionIR) be (expressionIR as unaryExpressionIR))

      2. Case analysis on unop

        1. Case (% matches pattern `~`)

          1. (Eval_static: p TC |- typedExpressionIR ~> value)

          2. Result in $un_bnot(value)

        2. Case (% matches pattern `!`)

          1. (Eval_static: p TC |- typedExpressionIR ~> value)

          2. Result in $un_lnot(value)

        3. Case (% matches pattern `+`)

          1. (Eval_static: p TC |- typedExpressionIR ~> value)

          2. Result in $un_plus(value)

        4. Case (% matches pattern `-`)

          1. (Eval_static: p TC |- typedExpressionIR ~> value)

          2. Result in $un_minus(value)

  }

  binaryExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. Case analysis on binop

        1. Case (% matches pattern `+`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_plus(value_l, value_r)

        2. Case (% matches pattern `|+|`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_satplus(value_l, value_r)

        3. Case (% matches pattern `-`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_minus(value_l, value_r)

        4. Case (% matches pattern `|-|`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_satminus(value_l, value_r)

        5. Case (% matches pattern `*`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_mul(value_l, value_r)

        6. Case (% matches pattern `/`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_div(value_l, value_r)

        7. Case (% matches pattern `<<`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_shl(value_l, value_r)

        8. Case (% matches pattern `>>`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_shr(value_l, value_r)

        9. Case (% matches pattern `<=`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in ((b $bin_le(value_l, value_r)) as value)

        10. Case (% matches pattern `>=`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in ((b $bin_ge(value_l, value_r)) as value)

        11. Case (% matches pattern `<`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in ((b $bin_lt(value_l, value_r)) as value)

        12. Case (% matches pattern `>`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in ((b $bin_gt(value_l, value_r)) as value)

        13. Case (% matches pattern `==`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in ((b $bin_eq(value_l, value_r)) as value)

        14. Case (% matches pattern `!=`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in ((b $bin_ne(value_l, value_r)) as value)

        15. Case (% matches pattern `&`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_band(value_l, value_r)

        16. Case (% matches pattern `^`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_bxor(value_l, value_r)

        17. Case (% matches pattern `|`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_bor(value_l, value_r)

        18. Case (% matches pattern `++`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_concat(value_l, value_r)

        19. Case (% matches pattern `&&`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_land(value_l, value_r)

        20. Case (% matches pattern `||`)

          1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

          2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

          3. Result in $bin_lor(value_l, value_r)

  }

  ternaryExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type ternaryExpressionIR)), then

      1. (Let (typedExpressionIR_cond ? typedExpressionIR_true : typedExpressionIR_false) be (expressionIR as ternaryExpressionIR))

      2. (Eval_static: p TC |- typedExpressionIR_cond ~> value)

      3. If ((value = ((b true) as value))), then

        1. (Eval_static: p TC |- typedExpressionIR_true ~> value_true)

        2. Result in value_true

      4. If ((value = ((b false) as value))), then

        1. (Eval_static: p TC |- typedExpressionIR_false ~> value_false)

        2. Result in value_false

  }

  castExpression: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type castExpressionIR)), then

      1. (Let (( typeIR ) typedExpressionIR) be (expressionIR as castExpressionIR))

      2. (Eval_static: p TC |- typedExpressionIR ~> value)

      3. (Let value_cast be $cast_op(typeIR, value))

      4. Result in value_cast

  }

  dataExpressionIR-invalid: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR = (({#}) as expressionIR))), then

      1. Result in (({#}) as value)

  }

  dataExpressionIR-sequence: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type dataExpressionIR)), then

      1. (Let dataExpressionIR be (expressionIR as dataExpressionIR))

      2. Case analysis on dataExpressionIR

        1. Case (% matches pattern `SEQ{%}`)

          1. (Let (seq{ typedExpressionIR* }) be dataExpressionIR)

          2. (Eval_static: p TC |- typedExpressionIR ~> value)*

          3. Result in ((seq( value* )) as value)

        2. Case (% matches pattern `SEQ{%,...}`)

          1. (Let (seq{ typedExpressionIR* ,...}) be dataExpressionIR)

          2. (Eval_static: p TC |- typedExpressionIR ~> value)*

          3. Result in ((seq( value* ,...)) as value)

  }

  dataExpressionIR-record: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type dataExpressionIR)), then

      1. (Let dataExpressionIR be (expressionIR as dataExpressionIR))

      2. Case analysis on dataExpressionIR

        1. Case (% matches pattern `RECORD{%}`)

          1. (Let (record{ (nameIR = typedExpressionIR)* }) be dataExpressionIR)

          2. (Eval_static: p TC |- typedExpressionIR ~> value)*

          3. Result in ((record{ (value nameIR ;)* }) as value)

        2. Case (% matches pattern `RECORD{%,...}`)

          1. (Let (record{ (nameIR = typedExpressionIR)* ,...}) be dataExpressionIR)

          2. (Eval_static: p TC |- typedExpressionIR ~> value)*

          3. Result in ((record{ (value nameIR ;)* ,...}) as value)

  }

  errorAccessExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type errorAccessExpressionIR)), then

      1. (Let (error. nameIR) be (expressionIR as errorAccessExpressionIR))

      2. (Let nameIR_error be "error." ++ nameIR)

      3. (Let value_error be $find_value(p, TC, (` nameIR_error)))

      4. Result in value_error

  }

  memberAccessExpressionIR-type: p TC |- expressionIR # ( typeIR_base _ctk ) ~> % {

    1. If ((expressionIR has type memberAccessExpressionIR)), then

      1. (Let (memberAccessBaseIR . nameIR) be (expressionIR as memberAccessExpressionIR))

      2. If ((memberAccessBaseIR matches pattern `TYPE%`)), then

        1. (Let (type prefixedNameIR) be memberAccessBaseIR)

        2. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

        3. If ((typeDefIR'? matches pattern (_))), then

          1. (Let ?(typeDefIR) be typeDefIR'?)

          2. If ((typeDefIR has type enumTypeIR)), then

            1. (Let enumTypeIR be (typeDefIR as enumTypeIR))

            2. Case analysis on enumTypeIR

              1. Case (% matches pattern `ENUM%{%}`)

                1. (Let (enum tid { id_member* }) be enumTypeIR)

                2. If (nameIR is in id_member*), then

                  1. Result in ((tid . nameIR) as value)

              2. Case (% matches pattern `ENUM%#%{%}`)

                1. (Let (enum tid # typeIR { (id_member = value_member ;)* }) be enumTypeIR)

                2. (Let value'? be $assoc_<id, value>(nameIR, (id_member, value_member)*))

                3. If ((value'? matches pattern (_))), then

                  1. (Let ?(value) be value'?)

                  2. Result in ((tid . nameIR # value) as value)

  }

  memberAccessExpressionIR-typedExpressionIR-stack-size: p TC |- expressionIR # ( typeIR_base _ctk ) ~> % {

    1. If ((expressionIR has type memberAccessExpressionIR)), then

      1. (Let (memberAccessBaseIR . text) be (expressionIR as memberAccessExpressionIR))

      2. If ((memberAccessBaseIR has type typedExpressionIR)), then

        1. (Let typedExpressionIR_base be (memberAccessBaseIR as typedExpressionIR))

        2. If ((text = "size")), then

          1. (Let typeIR be typeIR_base)

          2. If ((typeIR has type headerStackTypeIR)), then

            1. (Let (_typeIR [ n_size ]) be (typeIR as headerStackTypeIR))

            2. Result in ((d (n_size as int)) as value)

  }

  indexAccessExpressionIR-bitslice: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type indexAccessExpressionIR)), then

      1. (Let indexAccessExpressionIR be (expressionIR as indexAccessExpressionIR))

      2. If ((indexAccessExpressionIR matches pattern `%[%:%]`)), then

        1. (Let (typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ]) be indexAccessExpressionIR)

        2. (Eval_static: p TC |- typedExpressionIR_base ~> value_base)

        3. (Eval_static: p TC |- typedExpressionIR_hi ~> value_hi)

        4. (Eval_static: p TC |- typedExpressionIR_lo ~> value_lo)

        5. Result in $bitacc_op(value_base, value_hi, value_lo)

  }

  callExpressionIR-typedLvalueIR-size: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type callExpressionIR)), then

      1. (Let callExpressionIR be (expressionIR as callExpressionIR))

      2. If ((callExpressionIR matches pattern `%<%>(%)`)), then

        1. (Let (routineTargetIR < typeArgumentIR* >( argumentIR* )) be callExpressionIR)

        2. If ((routineTargetIR matches pattern `%.%`)), then

          1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

          2. If ((typeArgumentIR* matches pattern [])), then

            1. If ((argumentIR* matches pattern [])), then

              1. (Let (_expressionIR # (( typeIR_base _ctk' ))) be typedExpressionIR_base)

              2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                1. Result in $sizeof(typeIR_base, nameIR)

  }

  callExpressionIR-type: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type callExpressionIR)), then

      1. (Let callExpressionIR be (expressionIR as callExpressionIR))

      2. If ((callExpressionIR matches pattern `%<%>(%)`)), then

        1. (Let (routineTargetIR < typeArgumentIR* >( argumentIR* )) be callExpressionIR)

        2. If ((routineTargetIR matches pattern `TYPE%.%`)), then

          1. (Let (type prefixedNameIR . nameIR) be routineTargetIR)

          2. If ((typeArgumentIR* matches pattern [])), then

            1. If ((argumentIR* matches pattern [])), then

              1. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

              2. If ((typeDefIR'? matches pattern (_))), then

                1. (Let ?(typeDefIR) be typeDefIR'?)

                2. Case analysis on typeDefIR

                  1. Case (% has type typeIR)

                    1. (Let typeIR_base be (typeDefIR as typeIR))

                    2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                      1. Result in $sizeof(typeIR_base, nameIR)

                  2. Case (% has type polyTypeDefIR)

                    1. (Let (typeIR_base < tid* , tid'* >) be (typeDefIR as polyTypeDefIR))

                    2. If ((tid* matches pattern [])), then

                      1. If ((tid'* matches pattern [])), then

                        1. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                          1. Result in $sizeof(typeIR_base, nameIR)

  }

  callExpressionIR-parenthesized: p TC |- expressionIR # ( typeIR ctk ) ~> % {

    1. If ((expressionIR has type callExpressionIR)), then

      1. (Let callExpressionIR be (expressionIR as callExpressionIR))

      2. If ((callExpressionIR matches pattern `%<%>(%)`)), then

        1. (Let (routineTargetIR' < typeArgumentIR* >( argumentIR* )) be callExpressionIR)

        2. If ((routineTargetIR' matches pattern `(%)`)), then

          1. (Let (( routineTargetIR )) be routineTargetIR')

          2. (Eval_static: p TC |- (((routineTargetIR < typeArgumentIR* >( argumentIR* )) as expressionIR) # (( typeIR ctk ))) ~> value)

          3. Result in value

  }

  parenthesizedExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) ~> % {

    1. If ((expressionIR has type parenthesizedExpressionIR)), then

      1. (Let (( typedExpressionIR )) be (expressionIR as parenthesizedExpressionIR))

      2. (Eval_static: p TC |- typedExpressionIR ~> value)

      3. Result in value

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:15.1-17.23
relation Type_ok: 

  boolean: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid = ((bool) as typeOrVoid))), then

      1. Result in ((bool) as typeIR), []

  }

  error: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid = ((error) as typeOrVoid))), then

      1. Result in ((error) as typeIR), []

  }

  matchkind: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid = ((match_kind) as typeOrVoid))), then

      1. Result in ((match_kind) as typeIR), []

  }

  string: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid = ((string) as typeOrVoid))), then

      1. Result in ((string) as typeIR), []

  }

  arbint: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid = ((int) as typeOrVoid))), then

      1. Result in ((int) as typeIR), []

  }

  fixint: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid has type baseType)), then

      1. (Let baseType be (typeOrVoid as baseType))

      2. Case analysis on baseType

        1. Case (% matches pattern `INT<%>`)

          1. (Let (int< int >) be baseType)

          2. If ((int has type nat)), then

            1. (Let n be (int as nat))

            2. Result in ((int< n >) as typeIR), []

        2. Case (% matches pattern `INT<(%)>`)

          1. (Let (int<( expression )>) be baseType)

          2. (Expr_ok: p TC |- expression : typedExpressionIR)

          3. (Eval_static: p TC |- typedExpressionIR ~> value)

          4. (Let int be $to_number(value))

          5. If ((int has type nat)), then

            1. (Let n be (int as nat))

            2. Result in ((int< n >) as typeIR), []

  }

  fixbit: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid = ((bit) as typeOrVoid))), then

      1. Result in ((bit< 1 >) as typeIR), []

    2. If ((typeOrVoid has type baseType)), then

      1. (Let baseType be (typeOrVoid as baseType))

      2. Case analysis on baseType

        1. Case (% matches pattern `BIT<%>`)

          1. (Let (bit< int >) be baseType)

          2. If ((int has type nat)), then

            1. (Let n be (int as nat))

            2. Result in ((bit< n >) as typeIR), []

        2. Case (% matches pattern `BIT<(%)>`)

          1. (Let (bit<( expression )>) be baseType)

          2. (Expr_ok: p TC |- expression : typedExpressionIR)

          3. (Eval_static: p TC |- typedExpressionIR ~> value)

          4. (Let int be $to_number(value))

          5. If ((int has type nat)), then

            1. (Let n be (int as nat))

            2. Result in ((bit< n >) as typeIR), []

  }

  varbit: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid has type baseType)), then

      1. (Let baseType be (typeOrVoid as baseType))

      2. Case analysis on baseType

        1. Case (% matches pattern `VARBIT<%>`)

          1. (Let (varbit< int >) be baseType)

          2. If ((int has type nat)), then

            1. (Let n be (int as nat))

            2. Result in ((varbit< n >) as typeIR), []

        2. Case (% matches pattern `VARBIT<(%)>`)

          1. (Let (varbit<( expression )>) be baseType)

          2. (Expr_ok: p TC |- expression : typedExpressionIR)

          3. (Eval_static: p TC |- typedExpressionIR ~> value)

          4. (Let int be $to_number(value))

          5. If ((int has type nat)), then

            1. (Let n be (int as nat))

            2. Result in ((varbit< n >) as typeIR), []

  }

  prefixedTypeName: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid has type prefixedTypeName)), then

      1. (Let prefixedTypeName be (typeOrVoid as prefixedTypeName))

      2. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

      3. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

      4. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. Case analysis on typeDefIR

          1. Case (% has type typeIR)

            1. (Let typeIR be (typeDefIR as typeIR))

            2. Result in typeIR, []

          2. Case (% has type polyTypeDefIR)

            1. (Let polyTypeDefIR be (typeDefIR as polyTypeDefIR))

            2. Result in ((polyTypeDefIR < [] >) as typeIR), []

  }

  specializedType: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid has type specializedType)), then

      1. (Let (prefixedTypeName < typeArgumentList >) be (typeOrVoid as specializedType))

      2. If ((typeArgumentList matches pattern ``EMPTY`)), then

        1. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

        2. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

        3. If ((typeDefIR'? matches pattern (_))), then

          1. (Let ?(typeDefIR) be typeDefIR'?)

          2. If ((typeDefIR has type typeIR)), then

            1. (Let typeIR be (typeDefIR as typeIR))

            2. Result in typeIR, []

      3. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

      4. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

      5. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. If ((typeDefIR has type polyTypeDefIR)), then

          1. (Let polyTypeDefIR be (typeDefIR as polyTypeDefIR))

          2. (Let (typeIR < tid_expl* , tid_impl* >) be polyTypeDefIR)

          3. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

          4. (TypeArguments_ok: p TC |- typeArgument* : typeIR_arg* # tid_fresh*)

          5. Result in ((polyTypeDefIR < typeIR_arg* >) as typeIR), tid_fresh*

  }

  headerStackType: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid has type headerStackType)), then

      1. (Let (namedType [ expression_size ]) be (typeOrVoid as headerStackType))

      2. Case analysis on namedType

        1. Case (% has type prefixedTypeName)

          1. (Let prefixedTypeName be (namedType as prefixedTypeName))

          2. (Type_ok: p TC |- (prefixedTypeName as typeOrVoid) : typeIR_base # tid*)

          3. If ((tid* matches pattern [])), then

            1. (Expr_ok: p TC |- expression_size : typedExpressionIR_size)

            2. (Eval_static: p TC |- typedExpressionIR_size ~> value_size)

            3. (Let int be $to_number(value_size))

            4. If ((int has type nat)), then

              1. (Let n_size be (int as nat))

              2. (Let typeIR_stack be ((((tid "T") as typeIR) [ n_size ]) as typeIR))

              3. (Let polyTypeDefIR_stack be (typeIR_stack < ["T"] , [] >))

              4. Result in ((polyTypeDefIR_stack < [typeIR_base] >) as typeIR), []

        2. Case (% has type specializedType)

          1. (Let specializedType be (namedType as specializedType))

          2. (Type_ok: p TC |- (specializedType as typeOrVoid) : typeIR_base # tid_fresh*)

          3. (Expr_ok: p TC |- expression_size : typedExpressionIR_size)

          4. (Eval_static: p TC |- typedExpressionIR_size ~> value_size)

          5. (Let int be $to_number(value_size))

          6. If ((int has type nat)), then

            1. (Let n_size be (int as nat))

            2. (Let typeIR_stack be ((((tid "T") as typeIR) [ n_size ]) as typeIR))

            3. (Let polyTypeDefIR_stack be (typeIR_stack < ["T"] , [] >))

            4. Result in ((polyTypeDefIR_stack < [typeIR_base] >) as typeIR), tid_fresh*

  }

  listType: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid has type listType)), then

      1. (Let (list< typeArgument >) be (typeOrVoid as listType))

      2. (TypeArgument_ok: p TC |- typeArgument : typeIR_arg # tid_fresh*)

      3. (Let typeIR_list be ((list< ((tid "T") as typeIR) >) as typeIR))

      4. (Let polyTypeDefIR_list be (typeIR_list < ["T"] , [] >))

      5. Result in ((polyTypeDefIR_list < [typeIR_arg] >) as typeIR), tid_fresh*

  }

  tupleType: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid has type tupleType)), then

      1. (Let (tuple< typeArgumentList >) be (typeOrVoid as tupleType))

      2. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

      3. (TypeArguments_ok: p TC |- typeArgument* : typeIR_arg* # tid_fresh*)

      4. (Let i_idx* be ($init_(|typeIR_arg*|) as int*))

      5. (Let tid_tparam be "T" ++ $int_to_text(i_idx))*

      6. (Let typeIR_tuple be ((tuple< ((tid tid_tparam) as typeIR)* >) as typeIR))

      7. (Let polyTypeDefIR_tuple be (typeIR_tuple < tid_tparam* , [] >))

      8. Result in ((polyTypeDefIR_tuple < typeIR_arg* >) as typeIR), tid_fresh*

  }

  void: p TC |- typeOrVoid : % # % {

    1. If ((typeOrVoid matches pattern `VOID`)), then

      1. Result in ((void) as typeIR), []

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:19.1-21.23
relation TypeArgument_ok: 

  type: p TC |- typeArgument : % # % {

    1. If ((typeArgument has type type)), then

      1. (Let type be (typeArgument as type))

      2. (Type_ok: p TC |- (type as typeOrVoid) : typeIR # tid_impl*)

      3. Result in typeIR, tid_impl*

  }

  void: p TC |- typeArgument : % # % {

    1. If ((typeArgument = ((void) as typeArgument))), then

      1. Result in ((void) as typeArgumentIR), []

  }

  dontcare: p TC |- typeArgument : % # % {

    1. If ((typeArgument = ((_) as typeArgument))), then

      1. (Let tid_impl be $fresh_tid)

      2. Result in ((tid tid_impl) as typeArgumentIR), [tid_impl]

  }

  nonTypeName: p TC |- typeArgument : % # % {

    1. If ((typeArgument has type nonTypeName)), then

      1. (Let nonTypeName be (typeArgument as nonTypeName))

      2. (Let tid be $name((nonTypeName as name)))

      3. Result in ((tid tid) as typeArgumentIR), []

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:23.1-25.23
relation TypeArguments_ok: 

  nil: p TC |- typeArgument*{typeArgument <- typeArgument*} : % # % {

    1. If ((typeArgument* matches pattern [])), then

      1. Result in [], []

  }

  cons: p TC |- typeArgument*{typeArgument <- typeArgument*} : % # % {

    1. If ((typeArgument* matches pattern _ :: _)), then

      1. (Let typeArgument_h :: typeArgument_t* be typeArgument*)

      2. (TypeArgument_ok: p TC |- typeArgument_h : typeArgumentIR_h # tid_impl_h*)

      3. (TypeArguments_ok: p TC |- typeArgument_t* : typeArgumentIR_t* # tid_impl_t*)

      4. (Let tid_impl* be tid_impl_h* ++ tid_impl_t*)

      5. Result in typeArgumentIR_h :: typeArgumentIR_t*, tid_impl*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:31.1-31.54
relation Sub_expl: 

  : typeIR_a <: typeIR_b {

    1. (Let typeIR_a_canon be $canon(typeIR_a))

    2. (Let typeIR_b_canon be $canon(typeIR_b))

    3. If ((Sub_expl_canon: typeIR_a_canon <: typeIR_b_canon holds)), then

      1. The relation holds

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:32.1-32.60
relation Sub_expl_canon: 

  equals: typeIR_a <: typeIR_b {

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. The relation holds

  }

  not-equals: typeIR_a <: typeIR_b {

    1. If (~(Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. If ((Sub_expl_canon_neq: typeIR_a <: typeIR_b holds)), then

        1. The relation holds

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:33.1-33.64
relation Sub_expl_canon_neq: 

  boolean-fixbit: typeIR <: typeIR' {

    1. If ((typeIR = ((bool) as typeIR))), then

      1. If ((typeIR' = ((bit< 1 >) as typeIR))), then

        1. The relation holds

  }

  arbint: typeIR <: typeIR' {

    1. If ((typeIR = ((int) as typeIR))), then

      1. If ((typeIR' = ((bool) as typeIR))), then

        1. The relation holds

      2. If ((typeIR' has type numberTypeIR)), then

        1. (Let numberTypeIR be (typeIR' as numberTypeIR))

        2. Case analysis on numberTypeIR

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< _nat >) be numberTypeIR)

            2. The relation holds

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< _nat >) be numberTypeIR)

            2. The relation holds

  }

  fixint: typeIR <: typeIR' {

    1. If ((typeIR has type numberTypeIR)), then

      1. (Let numberTypeIR be (typeIR as numberTypeIR))

      2. If ((numberTypeIR matches pattern `INT<%>`)), then

        1. (Let (int< _nat >) be numberTypeIR)

        2. If ((typeIR' = ((int) as typeIR))), then

          1. The relation holds

        3. If ((typeIR' has type numberTypeIR)), then

          1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

          2. Case analysis on numberTypeIR'

            1. Case (% matches pattern `INT<%>`)

              1. (Let (int< w_b >) be numberTypeIR')

              2. The relation holds

            2. Case (% matches pattern `BIT<%>`)

              1. (Let (bit< w' >) be numberTypeIR')

              2. If ((_nat = w')), then

                1. The relation holds

  }

  fixbit: typeIR <: typeIR' {

    1. If ((typeIR = ((bit< 1 >) as typeIR))), then

      1. If ((typeIR' = ((bool) as typeIR))), then

        1. The relation holds

    2. If ((typeIR has type numberTypeIR)), then

      1. (Let numberTypeIR be (typeIR as numberTypeIR))

      2. If ((numberTypeIR matches pattern `BIT<%>`)), then

        1. (Let (bit< _nat >) be numberTypeIR)

        2. If ((typeIR' = ((int) as typeIR))), then

          1. The relation holds

        3. If ((typeIR' has type numberTypeIR)), then

          1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

          2. Case analysis on numberTypeIR'

            1. Case (% matches pattern `INT<%>`)

              1. (Let (int< w' >) be numberTypeIR')

              2. If ((_nat = w')), then

                1. The relation holds

            2. Case (% matches pattern `BIT<%>`)

              1. (Let (bit< w_b >) be numberTypeIR')

              2. The relation holds

  }

  newtype: typeIR' <: typeIR_b' {

    1. If ((typeIR' has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

        1. (Let (type _tid typeIR_a) be aliasTypeIR)

        2. If ((Sub_impl: typeIR_a <: typeIR_b' holds)), then

          1. The relation holds

    2. If ((typeIR_b' has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR_b' as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

        1. (Let (type _tid typeIR_b') be aliasTypeIR)

        2. If ((Sub_impl: typeIR' <: typeIR_b' holds)), then

          1. The relation holds

  }

  serenum: typeIR' <: typeIR_b' {

    1. If ((typeIR' has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR' as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR_a { _valueFieldIR* }) be enumTypeIR)

        2. If ((Sub_impl: typeIR_a <: typeIR_b' holds)), then

          1. The relation holds

    2. If ((typeIR_b' has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR_b' as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR_b' { _valueFieldIR* }) be enumTypeIR)

        2. If ((Sub_impl: typeIR' <: typeIR_b' holds)), then

          1. The relation holds

  }

  default: typeIR <: typeIR_b {

    1. If ((typeIR = ((default) as typeIR))), then

      1. If ($is_defaultable_typeIR(typeIR_b)), then

        1. The relation holds

  }

  invalidheader: typeIR <: typeIR' {

    1. If ((typeIR = ((header_invalid) as typeIR))), then

      1. Case analysis on typeIR'

        1. Case (% has type headerTypeIR)

          1. (Let (header _tid { _fieldTypeIR* }) be (typeIR' as headerTypeIR))

          2. The relation holds

        2. Case (% has type headerUnionTypeIR)

          1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR' as headerUnionTypeIR))

          2. The relation holds

  }

  seq: typeIR <: typeIR' {

    1. If ((typeIR has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

        1. (Let (seq< typeIR_a* >) be sequenceTypeIR)

        2. Case analysis on typeIR'

          1. Case (% has type listTypeIR)

            1. (Let (list< typeIR_b >) be (typeIR' as listTypeIR))

            2. If ((Sub_expl: typeIR_a <: typeIR_b holds))*, then

              1. The relation holds

          2. Case (% has type tupleTypeIR)

            1. (Let (tuple< typeIR_b* >) be (typeIR' as tupleTypeIR))

            2. If ((Sub_expl: typeIR_a <: typeIR_b holds))*, then

              1. The relation holds

          3. Case (% has type headerStackTypeIR)

            1. (Let (typeIR_b [ n_size ]) be (typeIR' as headerStackTypeIR))

            2. If ((|typeIR_a*| <= n_size)), then

              1. If ((Sub_expl: typeIR_a <: typeIR_b holds))*, then

                1. The relation holds

          4. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR_b _id ;)* }) be (typeIR' as structTypeIR))

            2. If ((Sub_expl: typeIR_a <: typeIR_b holds))*, then

              1. The relation holds

          5. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR_b _id ;)* }) be (typeIR' as headerTypeIR))

            2. If ((Sub_expl: typeIR_a <: typeIR_b holds))*, then

              1. The relation holds

  }

  seqdefault: typeIR <: typeIR' {

    1. If ((typeIR has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

        1. (Let (seq< typeIR_a* ,...>) be sequenceTypeIR)

        2. Case analysis on typeIR'

          1. Case (% has type tupleTypeIR)

            1. (Let (tuple< typeIR_b* >) be (typeIR' as tupleTypeIR))

            2. If ((|typeIR_a*| < |typeIR_b*|)), then

              1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR_b*, |typeIR_a*|))

              2. If ((Sub_expl: typeIR_a <: typeIR_b_non_default holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

          2. Case (% has type headerStackTypeIR)

            1. (Let (typeIR_b [ n_size ]) be (typeIR' as headerStackTypeIR))

            2. If ((|typeIR_a*| < n_size)), then

              1. If ((Sub_expl: typeIR_a <: typeIR_b holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b)), then

                  1. The relation holds

          3. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR_b _id ;)* }) be (typeIR' as structTypeIR))

            2. If ((|typeIR_a*| < |typeIR_b*|)), then

              1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR_b*, |typeIR_a*|))

              2. If ((Sub_expl: typeIR_a <: typeIR_b_non_default holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

          4. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR_b _id ;)* }) be (typeIR' as headerTypeIR))

            2. If ((|typeIR_a*| < |typeIR_b*|)), then

              1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR_b*, |typeIR_a*|))

              2. If ((Sub_expl: typeIR_a <: typeIR_b_non_default holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

  }

  record: typeIR <: typeIR' {

    1. If ((typeIR has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%}`)), then

        1. (Let (record{ (typeIR_a id_a ;)* }) be recordTypeIR)

        2. Case analysis on typeIR'

          1. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR_b id_b ;)* }) be (typeIR' as structTypeIR))

            2. If ($eq_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_aligned) be typeIR'''?)*

                  2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds))*, then

                    1. The relation holds

          2. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR_b id_b ;)* }) be (typeIR' as headerTypeIR))

            2. If ($eq_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_aligned) be typeIR'''?)*

                  2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds))*, then

                    1. The relation holds

  }

  recorddefault: typeIR <: typeIR' {

    1. If ((typeIR has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

        1. (Let (record{ (typeIR_a id_a ;)* ,...}) be recordTypeIR)

        2. Case analysis on typeIR'

          1. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR_b id_b ;)* }) be (typeIR' as structTypeIR))

            2. If ($sub_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_non_default_aligned) be typeIR'''?)*

                  2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*, then

                    1. (Let ({ id_default* }) be $diff_set<id>(({ id_b* }), ({ id_a* })))

                    2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_default))*

                    3. If ((typeIR''''? matches pattern (_)))*, then

                      1. (Let ?(typeIR_b_default) be typeIR''''?)*

                      2. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                        1. The relation holds

          2. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR_b id_b ;)* }) be (typeIR' as headerTypeIR))

            2. If ($sub_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_non_default_aligned) be typeIR'''?)*

                  2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*, then

                    1. (Let ({ id_default* }) be $diff_set<id>(({ id_b* }), ({ id_a* })))

                    2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_default))*

                    3. If ((typeIR''''? matches pattern (_)))*, then

                      1. (Let ?(typeIR_b_default) be typeIR''''?)*

                      2. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                        1. The relation holds

  }

  set: typeIR'''' <: typeIR''''' {

    1. If ((typeIR'''' has type setTypeIR)), then

      1. (Let (set< typeIR* >) be (typeIR'''' as setTypeIR))

      2. If ((typeIR* matches pattern [ _/1 ])), then

        1. (Let [typeIR_a] be typeIR*)

        2. If ((typeIR''''' has type setTypeIR)), then

          1. (Let (set< typeIR''* >) be (typeIR''''' as setTypeIR))

          2. If ((typeIR''* matches pattern [ _/1 ])), then

            1. (Let [typeIR_b] be typeIR''*)

            2. If ((Sub_expl: typeIR_a <: typeIR_b holds)), then

              1. The relation holds

    2. If ((typeIR''''' has type setTypeIR)), then

      1. (Let (set< typeIR* >) be (typeIR''''' as setTypeIR))

      2. If ((typeIR* matches pattern [ _/1 ])), then

        1. (Let [typeIR_b] be typeIR*)

        2. If (~$is_set_typeIR(typeIR'''')), then

          1. If ((Sub_expl: typeIR'''' <: typeIR_b holds)), then

            1. The relation holds

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:35.1-35.54
relation Sub_impl: 

  : typeIR_a <: typeIR_b {

    1. (Let typeIR_a_canon be $canon(typeIR_a))

    2. (Let typeIR_b_canon be $canon(typeIR_b))

    3. If ((Sub_impl_canon: typeIR_a_canon <: typeIR_b_canon holds)), then

      1. The relation holds

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:36.1-36.60
relation Sub_impl_canon: 

  equals: typeIR_a <: typeIR_b {

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. The relation holds

  }

  not-equals: typeIR_a <: typeIR_b {

    1. If (~(Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. If ((Sub_impl_canon_neq: typeIR_a <: typeIR_b holds)), then

        1. The relation holds

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:37.1-37.64
relation Sub_impl_canon_neq: 

  arbint: typeIR <: typeIR' {

    1. If ((typeIR = ((int) as typeIR))), then

      1. If ((typeIR' has type numberTypeIR)), then

        1. (Let numberTypeIR be (typeIR' as numberTypeIR))

        2. Case analysis on numberTypeIR

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< _nat >) be numberTypeIR)

            2. The relation holds

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< _nat >) be numberTypeIR)

            2. The relation holds

  }

  serenum-left: typeIR <: typeIR_b {

    1. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR_a { _valueFieldIR* }) be enumTypeIR)

        2. If ((Sub_impl: typeIR_a <: typeIR_b holds)), then

          1. The relation holds

  }

  default: typeIR <: typeIR_b {

    1. If ((typeIR = ((default) as typeIR))), then

      1. If ($is_defaultable_typeIR(typeIR_b)), then

        1. The relation holds

  }

  invalidheader: typeIR <: typeIR' {

    1. If ((typeIR = ((header_invalid) as typeIR))), then

      1. Case analysis on typeIR'

        1. Case (% has type headerTypeIR)

          1. (Let (header _tid { _fieldTypeIR* }) be (typeIR' as headerTypeIR))

          2. The relation holds

        2. Case (% has type headerUnionTypeIR)

          1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR' as headerUnionTypeIR))

          2. The relation holds

  }

  seq: typeIR <: typeIR' {

    1. If ((typeIR has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

        1. (Let (seq< typeIR_a* >) be sequenceTypeIR)

        2. Case analysis on typeIR'

          1. Case (% has type listTypeIR)

            1. (Let (list< typeIR_b >) be (typeIR' as listTypeIR))

            2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

              1. The relation holds

          2. Case (% has type tupleTypeIR)

            1. (Let (tuple< typeIR_b* >) be (typeIR' as tupleTypeIR))

            2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

              1. The relation holds

          3. Case (% has type headerStackTypeIR)

            1. (Let (typeIR_b [ n_size ]) be (typeIR' as headerStackTypeIR))

            2. If ((|typeIR_a*| <= n_size)), then

              1. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

                1. The relation holds

          4. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR_b _id ;)* }) be (typeIR' as structTypeIR))

            2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

              1. The relation holds

          5. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR_b _id ;)* }) be (typeIR' as headerTypeIR))

            2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

              1. The relation holds

          6. Case (% has type sequenceTypeIR)

            1. (Let sequenceTypeIR' be (typeIR' as sequenceTypeIR))

            2. If ((sequenceTypeIR' matches pattern `SEQ<%>`)), then

              1. (Let (seq< typeIR_b* >) be sequenceTypeIR')

              2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

                1. The relation holds

  }

  seqdefault: typeIR <: typeIR' {

    1. If ((typeIR has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

        1. (Let (seq< typeIR_a* ,...>) be sequenceTypeIR)

        2. Case analysis on typeIR'

          1. Case (% has type tupleTypeIR)

            1. (Let (tuple< typeIR_b* >) be (typeIR' as tupleTypeIR))

            2. If ((|typeIR_a*| < |typeIR_b*|)), then

              1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR_b*, |typeIR_a*|))

              2. If ((Sub_impl: typeIR_a <: typeIR_b_non_default holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

          2. Case (% has type headerStackTypeIR)

            1. (Let (typeIR_b [ n_size ]) be (typeIR' as headerStackTypeIR))

            2. If ((|typeIR_a*| < n_size)), then

              1. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b)), then

                  1. The relation holds

          3. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR_b _id ;)* }) be (typeIR' as structTypeIR))

            2. If ((|typeIR_a*| < |typeIR_b*|)), then

              1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR_b*, |typeIR_a*|))

              2. If ((Sub_impl: typeIR_a <: typeIR_b_non_default holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

          4. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR_b _id ;)* }) be (typeIR' as headerTypeIR))

            2. If ((|typeIR_a*| < |typeIR_b*|)), then

              1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR_b*, |typeIR_a*|))

              2. If ((Sub_impl: typeIR_a <: typeIR_b_non_default holds))*, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

  }

  record: typeIR <: typeIR' {

    1. If ((typeIR has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%}`)), then

        1. (Let (record{ (typeIR_a id_a ;)* }) be recordTypeIR)

        2. Case analysis on typeIR'

          1. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR_b id_b ;)* }) be (typeIR' as structTypeIR))

            2. If ($eq_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_aligned) be typeIR'''?)*

                  2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds))*, then

                    1. The relation holds

          2. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR_b id_b ;)* }) be (typeIR' as headerTypeIR))

            2. If ($eq_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_aligned) be typeIR'''?)*

                  2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds))*, then

                    1. The relation holds

  }

  recorddefault: typeIR <: typeIR' {

    1. If ((typeIR has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

        1. (Let (record{ (typeIR_a id_a ;)* ,...}) be recordTypeIR)

        2. Case analysis on typeIR'

          1. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR_b id_b ;)* }) be (typeIR' as structTypeIR))

            2. If ($sub_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_non_default_aligned) be typeIR'''?)*

                  2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*, then

                    1. (Let ({ id_default* }) be $diff_set<id>(({ id_b* }), ({ id_a* })))

                    2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_default))*

                    3. If ((typeIR''''? matches pattern (_)))*, then

                      1. (Let ?(typeIR_b_default) be typeIR''''?)*

                      2. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                        1. The relation holds

          2. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR_b id_b ;)* }) be (typeIR' as headerTypeIR))

            2. If ($sub_set<id>(({ id_a* }), ({ id_b* }))), then

              1. (Let typeIR''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

              2. If ((typeIR''? matches pattern (_)))*, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?)*

                2. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

                3. If ((typeIR'''? matches pattern (_)))*, then

                  1. (Let ?(typeIR_b_non_default_aligned) be typeIR'''?)*

                  2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*, then

                    1. (Let ({ id_default* }) be $diff_set<id>(({ id_b* }), ({ id_a* })))

                    2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_default))*

                    3. If ((typeIR''''? matches pattern (_)))*, then

                      1. (Let ?(typeIR_b_default) be typeIR''''?)*

                      2. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                        1. The relation holds

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:43.1-45.23
relation Expr_ok: 

  literalExpression-boolean: p TC |- expression : % {

    1. If ((expression = ((true) as expression))), then

      1. (Let expressionNoteIR be (( ((bool) as typeIR) (lctk) )))

      2. Result in (((true) as expressionIR) # expressionNoteIR)

    2. If ((expression = ((false) as expression))), then

      1. (Let expressionNoteIR be (( ((bool) as typeIR) (lctk) )))

      2. Result in (((false) as expressionIR) # expressionNoteIR)

  }

  literalExpression-number: p TC |- expression : % {

    1. If ((expression has type numberLiteral)), then

      1. (Let numberLiteral be (expression as numberLiteral))

      2. Case analysis on numberLiteral

        1. Case (% matches pattern `D%`)

          1. (Let (d i) be numberLiteral)

          2. (Let expressionNoteIR be (( ((int) as typeIR) (lctk) )))

          3. Result in (((d i) as expressionIR) # expressionNoteIR)

        2. Case (% matches pattern `%S%`)

          1. (Let (n s i) be numberLiteral)

          2. (Let expressionNoteIR be (( ((int< n >) as typeIR) (lctk) )))

          3. Result in (((n s i) as expressionIR) # expressionNoteIR)

        3. Case (% matches pattern `%W%`)

          1. (Let (n w i) be numberLiteral)

          2. (Let expressionNoteIR be (( ((bit< n >) as typeIR) (lctk) )))

          3. Result in (((n w i) as expressionIR) # expressionNoteIR)

  }

  literalExpression-stringliteral: p TC |- expression : % {

    1. If ((expression has type stringLiteral)), then

      1. (Let (" text ") be (expression as stringLiteral))

      2. (Let expressionNoteIR be (( ((string) as typeIR) (lctk) )))

      3. Result in (((" text ") as expressionIR) # expressionNoteIR)

  }

  referenceExpression: p TC |- expression : % {

    1. If ((expression has type prefixedNonTypeName)), then

      1. (Let prefixedNonTypeName be (expression as prefixedNonTypeName))

      2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

      3. (Let varTypeIR? be $find_var(p, TC, prefixedNameIR))

      4. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((_direction typeIR ctk _value?)) be varTypeIR?)

        2. (Let expressionNoteIR be (( typeIR ctk )))

        3. Result in ((prefixedNameIR as expressionIR) # expressionNoteIR)

    2. If ((expression = ((this) as expression))), then

      1. (Let prefixedNameIR be (` "this"))

      2. (Let varTypeIR? be $find_var(p, TC, prefixedNameIR))

      3. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((_direction typeIR ctk _value?)) be varTypeIR?)

        2. (Let expressionNoteIR be (( typeIR ctk )))

        3. Result in ((prefixedNameIR as expressionIR) # expressionNoteIR)

  }

  defaultExpression: p TC |- expression : % {

    1. If ((expression = ((...) as expression))), then

      1. (Let expressionNoteIR be (( ((default) as typeIR) (lctk) )))

      2. Result in (((...) as expressionIR) # expressionNoteIR)

  }

  unaryExpression-lnot: p TC |- expression' : % {

    1. If ((expression' has type unaryExpression)), then

      1. (Let (unop expression) be (expression' as unaryExpression))

      2. If ((unop matches pattern `!`)), then

        1. (Expr_ok: p TC |- expression : typedExpressionIR)

        2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR, $compat_lnot))

        3. If ((typedExpressionIR'? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?)

          2. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR_reduced)

          3. Result in ((((!) typedExpressionIR_reduced) as expressionIR) # expressionNoteIR)

  }

  unaryExpression-bnot: p TC |- expression' : % {

    1. If ((expression' has type unaryExpression)), then

      1. (Let (unop expression) be (expression' as unaryExpression))

      2. If ((unop matches pattern `~`)), then

        1. (Expr_ok: p TC |- expression : typedExpressionIR)

        2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR, $compat_bnot))

        3. If ((typedExpressionIR'? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?)

          2. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR_reduced)

          3. Result in ((((~) typedExpressionIR_reduced) as expressionIR) # expressionNoteIR)

  }

  unaryExpression-uplusminus: p TC |- expression' : % {

    1. If ((expression' has type unaryExpression)), then

      1. (Let (unop expression) be (expression' as unaryExpression))

      2. If (((unop = (+)) \/ (unop = (-)))), then

        1. (Expr_ok: p TC |- expression : typedExpressionIR)

        2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR, $compat_uplusminus))

        3. If ((typedExpressionIR'? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?)

          2. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR_reduced)

          3. Result in (((unop typedExpressionIR_reduced) as expressionIR) # expressionNoteIR)

  }

  binaryExpression-plusminusmult: p TC |- expression : % {

    1. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. If (binop is in [(+), (-), (*)]), then

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_plusminusmult))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  }

  binaryExpression-satplusminus: p TC |- expression : % {

    1. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. If (binop is in [(|+|), (|-|)]), then

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_satplusminus))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  }

  binaryExpression-divmod: p TC |- expression : % {

    1. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. If (binop is in [(/), (%)]), then

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. Case analysis on (ctk_r_reduced matches pattern `LCTK`)

              1. Case true

                1. (Eval_static: p TC |- typedExpressionIR_r_reduced ~> value_r)

                2. (Let int be $to_number(value_r))

                3. If ((int has type nat)), then

                  1. (Let n_r be (int as nat))

                  2. If ((n_r > 0)), then

                    1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

                    2. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

                    3. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

              2. Case false

                1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

                2. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

                3. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  }

  binaryExpression-shift: p TC |- expression : % {

    1. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. If (binop is in [(<<), (>>)]), then

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (_expressionIR # (( typeIR_l_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

          3. (Let (_expressionIR' # (( typeIR_r_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          4. If ($is_fixed_bit_typeIR(typeIR_r_reduced)), then

            1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            2. (Let expressionNoteIR be (( typeIR_l_reduced ctk_reduced )))

            3. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

          5. If ((ctk_r_reduced matches pattern `LCTK`)), then

            1. If (($is_arbitrary_int_typeIR(typeIR_r_reduced) \/ $is_fixed_int_typeIR(typeIR_r_reduced))), then

              1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

              2. (Let expressionNoteIR be (( typeIR_l_reduced ctk_reduced )))

              3. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  }

  binaryExpression-eq: p TC |- expression : % {

    1. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. If (binop is in [(==), (!=)]), then

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (_expressionIR # (( typeIR_cast ctk_l_cast ))) be typedExpressionIR_l_cast)

          3. (Let (_expressionIR' # (( _typeIR ctk_r_cast ))) be typedExpressionIR_r_cast)

          4. If ($is_equalable_typeIR(typeIR_cast)), then

            1. (Let ctk_cast be $join_ctk(ctk_l_cast, ctk_r_cast))

            2. (Let expressionNoteIR be (( ((bool) as typeIR) ctk_cast )))

            3. Result in (((typedExpressionIR_l_cast binop typedExpressionIR_r_cast) as expressionIR) # expressionNoteIR)

  }

  binaryExpression-compare: p TC |- expression : % {

    1. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. If (binop is in [(<=), (>=), (<), (>)]), then

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_compare))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( ((bool) as typeIR) ctk_reduced )))

            6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  }

  binaryExpression-bitwise: p TC |- expression : % {

    1. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. If (binop is in [(&), (^), (|)]), then

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_bitwise))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  }

  binaryExpression-concat: p TC |- expression : % {

    1. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. If ((binop matches pattern `++`)), then

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_concat))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (_expressionIR # (( typeIR_l_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

          3. (Let (_expressionIR' # (( typeIR_r_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          4. (Let typeIR? be $result_concat(typeIR_l_reduced, typeIR_r_reduced))

          5. If ((typeIR? matches pattern (_))), then

            1. (Let ?(typeIR_reduced) be typeIR?)

            2. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            3. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            4. Result in (((typedExpressionIR_l_reduced (++) typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  }

  binaryExpression-logical: p TC |- expression : % {

    1. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. If (binop is in [(&&), (||)]), then

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_logical))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  }

  ternaryExpression: p TC |- expression : % {

    1. If ((expression has type ternaryExpression)), then

      1. (Let (expression_cond ? expression_true : expression_false) be (expression as ternaryExpression))

      2. (Expr_ok: p TC |- expression_cond : typedExpressionIR_cond)

      3. (Let (_expressionIR # (( typeIR ctk_cond ))) be typedExpressionIR_cond)

      4. If ((typeIR = ((bool) as typeIR))), then

        1. (Expr_ok: p TC |- expression_true : typedExpressionIR_true)

        2. (Expr_ok: p TC |- expression_false : typedExpressionIR_false)

        3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_true, typedExpressionIR_false))

        4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_true_cast, typedExpressionIR_false_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (_expressionIR' # (( typeIR_cast ctk_true_cast ))) be typedExpressionIR_true_cast)

          3. (Let (_expressionIR'' # (( _typeIR ctk_false_cast ))) be typedExpressionIR_false_cast)

          4. If (($is_arbitrary_int_typeIR(typeIR_cast) => (ctk_cond =/= (dyn)))), then

            1. (Let ctk be $joins_ctk([ctk_cond, ctk_true_cast, ctk_false_cast]))

            2. (Let expressionNoteIR be (( typeIR_cast ctk )))

            3. Result in (((typedExpressionIR_cond ? typedExpressionIR_true_cast : typedExpressionIR_false_cast) as expressionIR) # expressionNoteIR)

  }

  castExpression: p TC |- expression' : % {

    1. If ((expression' has type castExpression)), then

      1. (Let (( type_t ) expression) be (expression' as castExpression))

      2. (Type_ok: p TC |- (type_t as typeOrVoid) : typeIR_t # tid*)

      3. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound(p, TC) |- typeIR_t holds)), then

          1. (Expr_ok: p TC |- expression : typedExpressionIR)

          2. (Let (_expressionIR # (( typeIR ctk ))) be typedExpressionIR)

          3. If ((Sub_expl: typeIR <: typeIR_t holds)), then

            1. (Let expressionNoteIR be (( typeIR_t ctk )))

            2. Result in (((( typeIR_t ) typedExpressionIR) as expressionIR) # expressionNoteIR)

  }

  dataExpression-invalid: p TC |- expression : % {

    1. If ((expression = (({#}) as expression))), then

      1. (Let expressionNoteIR be (( ((header_invalid) as typeIR) (lctk) )))

      2. Result in ((({#}) as expressionIR) # expressionNoteIR)

  }

  dataExpression-sequenceElementExpression: p TC |- expression : % {

    1. If ((expression has type dataExpression)), then

      1. (Let dataExpression be (expression as dataExpression))

      2. If ((dataExpression matches pattern `{%%}`)), then

        1. (Let ({ dataElementExpression _trailingCommaOpt }) be dataExpression)

        2. If ((dataElementExpression has type expressionList)), then

          1. (Let expressionList be (dataElementExpression as expressionList))

          2. (Let expression_e* be $flatten_expressionList(expressionList))

          3. Case analysis on ((...) as expression) is in expression_e*

            1. Case false

              1. If ((expression_e* = $flatten_expressionList(expressionList))), then

                1. (Expr_ok: p TC |- expression_e : typedExpressionIR_e)*

                2. (Let (_expressionIR # (( typeIR_e ctk_e ))) be typedExpressionIR_e)*

                3. (Let typeIR be ((seq< typeIR_e* >) as typeIR))

                4. (Let ctk be $joins_ctk(ctk_e*))

                5. (Let expressionNoteIR be (( typeIR ctk )))

                6. Result in (((seq{ typedExpressionIR_e* }) as expressionIR) # expressionNoteIR)

            2. Case true

              1. (Let expression''* be $rev_<expression>(expression_e*))

              2. If ((expression''* matches pattern _ :: _)), then

                1. (Let expression' :: expression_e_h_rev* be expression''*)

                2. If ((expression' = ((...) as expression))), then

                  1. (Let expression_e_h* be $rev_<expression>(expression_e_h_rev*))

                  2. If (~((...) as expression) is in expression_e_h*), then

                    1. (Expr_ok: p TC |- expression_e_h : typedExpressionIR_e_h)*

                    2. (Let (_expressionIR # (( typeIR_e_h ctk_e_h ))) be typedExpressionIR_e_h)*

                    3. (Let typeIR be ((seq< typeIR_e_h* ,...>) as typeIR))

                    4. (Let ctk be $joins_ctk(ctk_e_h*))

                    5. (Let expressionNoteIR be (( typeIR ctk )))

                    6. Result in (((seq{ typedExpressionIR_e_h* ,...}) as expressionIR) # expressionNoteIR)

  }

  dataExpression-recordElementExpression: p TC |- expression : % {

    1. If ((expression has type dataExpression)), then

      1. (Let dataExpression be (expression as dataExpression))

      2. If ((dataExpression matches pattern `{%%}`)), then

        1. (Let ({ dataElementExpression _trailingCommaOpt }) be dataExpression)

        2. If ((dataElementExpression has type recordElementExpression)), then

          1. (Let recordElementExpression be (dataElementExpression as recordElementExpression))

          2. Case analysis on recordElementExpression

            1. Case (% matches pattern `%=%`)

              1. (Let (name_f = expression_f) be recordElementExpression)

              2. (Let nameIR_f be $name(name_f))

              3. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)

              4. (Let (_expressionIR # (( typeIR_f ctk_f ))) be typedExpressionIR_f)

              5. (Let typeIR be ((record{ [(typeIR_f nameIR_f ;)] }) as typeIR))

              6. (Let expressionNoteIR be (( typeIR ctk_f )))

              7. Result in (((record{ [(nameIR_f = typedExpressionIR_f)] }) as expressionIR) # expressionNoteIR)

            2. Case (% matches pattern `%=%,...`)

              1. (Let (name_f = expression_f ,...) be recordElementExpression)

              2. (Let nameIR_f be $name(name_f))

              3. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)

              4. (Let (_expressionIR # (( typeIR_f ctk_f ))) be typedExpressionIR_f)

              5. (Let typeIR be ((record{ [(typeIR_f nameIR_f ;)] ,...}) as typeIR))

              6. (Let expressionNoteIR be (( typeIR ctk_f )))

              7. Result in (((record{ [(nameIR_f = typedExpressionIR_f)] ,...}) as expressionIR) # expressionNoteIR)

            3. Case (% matches pattern `%=%,%`)

              1. (Let (name_f_h = expression_f_h , namedExpressionList_t) be recordElementExpression)

              2. (Let (name_f_t = expression_f_t)* be $flatten_namedExpressionList(namedExpressionList_t))

              3. (Let name_f* be name_f_h :: name_f_t*)

              4. (Let nameIR_f be $name(name_f))*

              5. (Let expression_f* be expression_f_h :: expression_f_t*)

              6. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*

              7. (Let (_expressionIR # (( typeIR_f ctk_f ))) be typedExpressionIR_f)*

              8. (Let typeIR be ((record{ (typeIR_f nameIR_f ;)* }) as typeIR))

              9. (Let ctk be $joins_ctk(ctk_f*))

              10. (Let expressionNoteIR be (( typeIR ctk )))

              11. Result in (((record{ (nameIR_f = typedExpressionIR_f)* }) as expressionIR) # expressionNoteIR)

            4. Case (% matches pattern `%=%,%,...`)

              1. (Let (name_f_h = expression_f_h , namedExpressionList_t ,...) be recordElementExpression)

              2. (Let (name_f_t = expression_f_t)* be $flatten_namedExpressionList(namedExpressionList_t))

              3. (Let name_f* be name_f_h :: name_f_t*)

              4. (Let nameIR_f be $name(name_f))*

              5. (Let expression_f* be expression_f_h :: expression_f_t*)

              6. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*

              7. (Let (_expressionIR # (( typeIR_f ctk_f ))) be typedExpressionIR_f)*

              8. (Let typeIR be ((record{ (typeIR_f nameIR_f ;)* ,...}) as typeIR))

              9. (Let ctk be $joins_ctk(ctk_f*))

              10. (Let expressionNoteIR be (( typeIR ctk )))

              11. Result in (((record{ (nameIR_f = typedExpressionIR_f)* ,...}) as expressionIR) # expressionNoteIR)

  }

  accessExpression-errorAccessExpression: p TC |- expression : % {

    1. If ((expression has type errorAccessExpression)), then

      1. (Let (error. member) be (expression as errorAccessExpression))

      2. (Let nameIR be $name(member))

      3. (Let nameIR_error be "error." ++ nameIR)

      4. If ((((error. nameIR) as value) = $find_value(p, TC, (` nameIR_error)))), then

        1. (Let expressionNoteIR be (( ((error) as typeIR) (lctk) )))

        2. Result in (((error. nameIR) as expressionIR) # expressionNoteIR)

  }

  accessExpression-memberAccessExpression-prefixedTypeName: p TC |- expression : % {

    1. If ((expression has type memberAccessExpression)), then

      1. (Let (memberAccessBase . member) be (expression as memberAccessExpression))

      2. If ((memberAccessBase has type prefixedTypeName)), then

        1. (Let prefixedTypeName_base be (memberAccessBase as prefixedTypeName))

        2. (Let prefixedNameIR_base be $prefixedTypeName(prefixedTypeName_base))

        3. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR_base))

        4. If ((typeDefIR'? matches pattern (_))), then

          1. (Let ?(typeDefIR) be typeDefIR'?)

          2. If ((typeDefIR has type typeIR)), then

            1. (Let typeIR_base be (typeDefIR as typeIR))

            2. (Let typeIR be $canon(typeIR_base))

            3. If ((typeIR has type enumTypeIR)), then

              1. (Let enumTypeIR be (typeIR as enumTypeIR))

              2. Case analysis on enumTypeIR

                1. Case (% matches pattern `ENUM%{%}`)

                  1. (Let (enum _tid { nameIR_f* }) be enumTypeIR)

                  2. (Let nameIR be $name(member))

                  3. If (nameIR is in nameIR_f*), then

                    1. (Let expressionNoteIR be (( typeIR_base (lctk) )))

                    2. Result in ((((type prefixedNameIR_base) . nameIR) as expressionIR) # expressionNoteIR)

                2. Case (% matches pattern `ENUM%#%{%}`)

                  1. (Let (enum _tid # _typeIR { (nameIR_f = _value ;)* }) be enumTypeIR)

                  2. (Let nameIR be $name(member))

                  3. If (nameIR is in nameIR_f*), then

                    1. (Let expressionNoteIR be (( typeIR_base (lctk) )))

                    2. Result in ((((type prefixedNameIR_base) . nameIR) as expressionIR) # expressionNoteIR)

  }

  accessExpression-memberAccessExpression-expression: p TC |- expression : % {

    1. If ((expression has type memberAccessExpression)), then

      1. (Let (memberAccessBase . member) be (expression as memberAccessExpression))

      2. If ((memberAccessBase has type expression)), then

        1. (Let expression_base be (memberAccessBase as expression))

        2. If (("size" = $name(member))), then

          1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

          2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

          3. (Let typeIR' be $canon(typeIR_base))

          4. If ((typeIR' has type headerStackTypeIR)), then

            1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

            2. (Let expressionNoteIR be (( ((bit< 32 >) as typeIR) (lctk) )))

            3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . "size") as expressionIR) # expressionNoteIR)

        3. If (("lastIndex" = $name(member))), then

          1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

            1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

            2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

            3. (Let typeIR' be $canon(typeIR_base))

            4. If ((typeIR' has type headerStackTypeIR)), then

              1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

              2. (Let expressionNoteIR be (( ((bit< 32 >) as typeIR) (dyn) )))

              3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . "lastIndex") as expressionIR) # expressionNoteIR)

        4. If (("last" = $name(member))), then

          1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

            1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

            2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

            3. (Let typeIR' be $canon(typeIR_base))

            4. If ((typeIR' has type headerStackTypeIR)), then

              1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

              2. (Let expressionNoteIR be (( typeIR (dyn) )))

              3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . "last") as expressionIR) # expressionNoteIR)

        5. If (("next" = $name(member))), then

          1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

            1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

            2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

            3. (Let typeIR' be $canon(typeIR_base))

            4. If ((typeIR' has type headerStackTypeIR)), then

              1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

              2. (Let expressionNoteIR be (( typeIR (dyn) )))

              3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . "next") as expressionIR) # expressionNoteIR)

        6. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        7. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

        8. (Let typeIR' be $canon(typeIR_base))

        9. Case analysis on typeIR'

          1. Case (% has type structTypeIR)

            1. (Let (struct _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as structTypeIR))

            2. (Let nameIR be $name(member))

            3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

            4. If ((typeIR''? matches pattern (_))), then

              1. (Let ?(typeIR) be typeIR''?)

              2. (Let expressionNoteIR be (( typeIR (dyn) )))

              3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # expressionNoteIR)

          2. Case (% has type headerTypeIR)

            1. (Let (header _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as headerTypeIR))

            2. (Let nameIR be $name(member))

            3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

            4. If ((typeIR''? matches pattern (_))), then

              1. (Let ?(typeIR) be typeIR''?)

              2. (Let expressionNoteIR be (( typeIR (dyn) )))

              3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # expressionNoteIR)

          3. Case (% has type headerUnionTypeIR)

            1. (Let (header_union _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as headerUnionTypeIR))

            2. (Let nameIR be $name(member))

            3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

            4. If ((typeIR''? matches pattern (_))), then

              1. (Let ?(typeIR) be typeIR''?)

              2. (Let expressionNoteIR be (( typeIR (dyn) )))

              3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # expressionNoteIR)

          4. Case (% has type tableTypeIR)

            1. (Let tableTypeIR be (typeIR' as tableTypeIR))

            2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

              1. (Let (table_struct _tid { (typeIR_f nameIR_f ;)* }) be tableTypeIR)

              2. (Let nameIR be $name(member))

              3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

              4. If ((typeIR''? matches pattern (_))), then

                1. (Let ?(typeIR) be typeIR''?)

                2. (Let expressionNoteIR be (( typeIR (dyn) )))

                3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # expressionNoteIR)

  }

  indexAccessExpression-index: p TC |- expression : % {

    1. If ((expression has type indexAccessExpression)), then

      1. (Let indexAccessExpression be (expression as indexAccessExpression))

      2. If ((indexAccessExpression matches pattern `%[%]`)), then

        1. (Let (expression_base [ expression_index ]) be indexAccessExpression)

        2. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        3. (Expr_ok: p TC |- expression_index : typedExpressionIR_index)

        4. (Let (_expressionIR # (( typeIR_base ctk_base ))) be typedExpressionIR_base)

        5. (Let (_expressionIR' # (( typeIR_index ctk_index ))) be typedExpressionIR_index)

        6. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index))

        7. If ((typedExpressionIR? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_index_reduced) be typedExpressionIR?)

          2. (Let typeIR be $canon(typeIR_base))

          3. Case analysis on typeIR

            1. Case (% has type tupleTypeIR)

              1. (Let (tuple< typeIR_e* >) be (typeIR as tupleTypeIR))

              2. If ((ctk_index matches pattern `LCTK`)), then

                1. (Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index)

                2. (Let int be $to_number(value_index))

                3. If ((int has type nat)), then

                  1. (Let n_index be (int as nat))

                  2. If ((n_index < |typeIR_e*|)), then

                    1. (Let expressionNoteIR be (( typeIR_e*[n_index] (dyn) )))

                    2. Result in (((typedExpressionIR_base [ typedExpressionIR_index_reduced ]) as expressionIR) # expressionNoteIR)

            2. Case (% has type headerStackTypeIR)

              1. (Let (typeIR [ n_size ]) be (typeIR as headerStackTypeIR))

              2. Case analysis on (ctk_index matches pattern `LCTK`)

                1. Case true

                  1. (Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index)

                  2. (Let int be $to_number(value_index))

                  3. If ((int has type nat)), then

                    1. (Let n_index be (int as nat))

                    2. If ((n_index < n_size)), then

                      1. (Let expressionNoteIR be (( typeIR (dyn) )))

                      2. Result in (((typedExpressionIR_base [ typedExpressionIR_index_reduced ]) as expressionIR) # expressionNoteIR)

                2. Case false

                  1. (Let expressionNoteIR be (( typeIR (dyn) )))

                  2. Result in (((typedExpressionIR_base [ typedExpressionIR_index_reduced ]) as expressionIR) # expressionNoteIR)

  }

  indexAccessExpression-bitslice: p TC |- expression : % {

    1. If ((expression has type indexAccessExpression)), then

      1. (Let indexAccessExpression be (expression as indexAccessExpression))

      2. If ((indexAccessExpression matches pattern `%[%:%]`)), then

        1. (Let (expression_base [ expression_hi : expression_lo ]) be indexAccessExpression)

        2. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        3. (Expr_ok: p TC |- expression_hi : typedExpressionIR_hi)

        4. (Expr_ok: p TC |- expression_lo : typedExpressionIR_lo)

        5. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_base, $compat_bitslice_base))

        6. If ((typedExpressionIR? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_base_reduced) be typedExpressionIR?)

          2. (Let (_expressionIR # (( typeIR_base_reduced ctk_base_reduced ))) be typedExpressionIR_base_reduced)

          3. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index))

          4. If ((typedExpressionIR'? matches pattern (_))), then

            1. (Let ?(typedExpressionIR_hi_reduced) be typedExpressionIR'?)

            2. (Let typedExpressionIR''? be $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index))

            3. If ((typedExpressionIR''? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_lo_reduced) be typedExpressionIR''?)

              2. (Let (_expressionIR' # (( typeIR_hi_reduced ctk_hi_reduced ))) be typedExpressionIR_hi_reduced)

              3. (Let (_expressionIR'' # (( typeIR_lo_reduced ctk_lo_reduced ))) be typedExpressionIR_lo_reduced)

              4. If ((ctk_hi_reduced matches pattern `LCTK`)), then

                1. (Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi)

                2. (Let int be $to_number(value_hi))

                3. If ((int has type nat)), then

                  1. (Let n_hi be (int as nat))

                  2. If ((ctk_lo_reduced matches pattern `LCTK`)), then

                    1. (Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo)

                    2. (Let int' be $to_number(value_lo))

                    3. If ((int' has type nat)), then

                      1. (Let n_lo be (int' as nat))

                      2. If ($is_valid_bitslice(typeIR_base_reduced, n_lo, n_hi)), then

                        1. (Let typeIR be ((bit< ((n_hi - n_lo) + 1) >) as typeIR))

                        2. (Let expressionNoteIR be (( typeIR ctk_base_reduced )))

                        3. Result in (((typedExpressionIR_base [ typedExpressionIR_hi_reduced : typedExpressionIR_lo_reduced ]) as expressionIR) # expressionNoteIR)

  }

  callExpression-routineTarget: p TC |- expression : % {

    1. If ((expression has type callExpression)), then

      1. (Let callExpression be (expression as callExpression))

      2. Case analysis on callExpression

        1. Case (% matches pattern `%(%)`)

          1. (Let (callTarget ( argumentList )) be callExpression)

          2. If ((callTarget has type routineTarget)), then

            1. (Let routineTarget be (callTarget as routineTarget))

            2. (RoutineTarget_ok: p TC |- routineTarget : routineTargetIR)

            3. (Let argument* be $flatten_argumentList(argumentList))

            4. (Argument_ok: p TC |- argument : argumentIR)*

            5. (RoutineType_ok: p TC |- routineTargetIR < [] >( argumentIR* ): routineTypeIR <# tid_inserted* >(# id_default* ))

            6. (Let tid_infer* be tid_inserted*)

            7. (Call_ok: p TC |- routineTypeIR < [] # tid_infer* >( argumentIR* # id_default* ): typeIR_ret < typeArgumentIR_inferred* >( argumentIR_cast* ))

            8. If ((typeIR_ret =/= ((void) as typeIR))), then

              1. (Let ctk be $is_static_routineTarget(routineTargetIR))

              2. (Let callExpressionIR be (routineTargetIR < typeArgumentIR_inferred* >( argumentIR_cast* )))

              3. (Let expressionNoteIR be (( typeIR_ret ctk )))

              4. Result in ((callExpressionIR as expressionIR) # expressionNoteIR)

        2. Case (% matches pattern `%<%>(%)`)

          1. (Let (routineTarget < realTypeArgumentList >( argumentList )) be callExpression)

          2. (RoutineTarget_ok: p TC |- routineTarget : routineTargetIR)

          3. (Let realTypeArgument* be $flatten_realTypeArgumentList(realTypeArgumentList))

          4. (TypeArguments_ok: p TC |- (realTypeArgument* as typeArgument*) : typeArgumentIR* # tid_impl*)

          5. (Let argument* be $flatten_argumentList(argumentList))

          6. (Argument_ok: p TC |- argument : argumentIR)*

          7. (RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR* >( argumentIR* ): routineTypeIR <# tid_inserted* >(# id_default* ))

          8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

          9. (Call_ok: p TC |- routineTypeIR < typeArgumentIR* # tid_infer* >( argumentIR* # id_default* ): typeIR_ret < typeArgumentIR_inferred* >( argumentIR_cast* ))

          10. If ((typeIR_ret =/= ((void) as typeIR))), then

            1. (Let ctk be $is_static_routineTarget(routineTargetIR))

            2. (Let callExpressionIR be (routineTargetIR < typeArgumentIR_inferred* >( argumentIR_cast* )))

            3. (Let expressionNoteIR be (( typeIR_ret ctk )))

            4. Result in ((callExpressionIR as expressionIR) # expressionNoteIR)

  }

  callExpression-constructorTarget: p TC |- expression : % {

    1. If ((expression has type callExpression)), then

      1. (Let callExpression be (expression as callExpression))

      2. If ((callExpression matches pattern `%(%)`)), then

        1. (Let (callTarget ( argumentList )) be callExpression)

        2. Case analysis on callTarget

          1. Case (% has type prefixedTypeName)

            1. (Let prefixedTypeName be (callTarget as prefixedTypeName))

            2. (Let argument* be $flatten_argumentList(argumentList))

            3. (Argument_ok: p TC |- argument : argumentIR)*

            4. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

            5. (ConstructorType_ok: p TC |- prefixedNameIR < [] >( argumentIR* ): constructorTypeIR <# tid_impl* >(# id_default* ))

            6. (Inst_ok: p TC (anon) |- constructorTypeIR < [] # tid_impl* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

            7. If ($is_concrete_extern_object(typeIR_object)), then

              1. (Let callExpressionIR be ((prefixedNameIR < typeArgumentIR_inferred* >) ( argumentIR_cast* )))

              2. (Let expressionNoteIR be (( typeIR_object (ctk) )))

              3. Result in ((callExpressionIR as expressionIR) # expressionNoteIR)

          2. Case (% has type specializedType)

            1. (Let (prefixedTypeName < typeArgumentList >) be (callTarget as specializedType))

            2. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

            3. (TypeArguments_ok: p TC |- typeArgument* : typeArgumentIR* # tid_impl*)

            4. (Let argument* be $flatten_argumentList(argumentList))

            5. (Argument_ok: p TC |- argument : argumentIR)*

            6. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

            7. (ConstructorType_ok: p TC |- prefixedNameIR < typeArgumentIR* >( argumentIR* ): constructorTypeIR <# tid_inserted* >(# id_default* ))

            8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

            9. (Inst_ok: p TC (anon) |- constructorTypeIR < typeArgumentIR* # tid_infer* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

            10. If ($is_concrete_extern_object(typeIR_object)), then

              1. (Let callExpressionIR be ((prefixedNameIR < typeArgumentIR_inferred* >) ( argumentIR_cast* )))

              2. (Let expressionNoteIR be (( typeIR_object (ctk) )))

              3. Result in ((callExpressionIR as expressionIR) # expressionNoteIR)

  }

  parenthesizedExpression: p TC |- expression' : % {

    1. If ((expression' has type parenthesizedExpression)), then

      1. (Let (( expression )) be (expression' as parenthesizedExpression))

      2. (Expr_ok: p TC |- expression : typedExpressionIR)

      3. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR)

      4. Result in (((( typedExpressionIR )) as expressionIR) # expressionNoteIR)

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:51.1-53.23
relation Argument_ok: 

  expression: p TC |- argument : % {

    1. If ((argument has type expression)), then

      1. (Let expression be (argument as expression))

      2. (Expr_ok: p TC |- expression : typedExpressionIR)

      3. Result in (typedExpressionIR as argumentIR)

  }

  name-expression: p TC |- argument : % {

    1. If ((argument matches pattern `%=%`)), then

      1. (Let (name = expression) be argument)

      2. (Let nameIR be $name(name))

      3. (Expr_ok: p TC |- expression : typedExpressionIR)

      4. Result in (nameIR = typedExpressionIR)

  }

  name-dontcare: p TC |- argument : % {

    1. If ((argument matches pattern `%=_`)), then

      1. (Let (name =_) be argument)

      2. (Let nameIR be $name(name))

      3. Result in (nameIR =_)

  }

  dontcare: p TC |- argument : % {

    1. If ((argument matches pattern `_`)), then

      1. Result in (_)

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:59.1-61.23
relation Lvalue_ok: 

  referenceExpression-prefixedNonTypeName: p TC |- lvalue : % {

    1. If ((lvalue has type prefixedNonTypeName)), then

      1. (Let prefixedNonTypeName be (lvalue as prefixedNonTypeName))

      2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

      3. (Let varTypeIR? be $find_var(p, TC, prefixedNameIR))

      4. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((direction typeIR ctk value?)) be varTypeIR?)

        2. If ((ctk matches pattern `DYN`)), then

          1. If ((value? matches pattern ())), then

            1. If (((direction = (out)) \/ (direction = (inout)))), then

              1. Result in ((prefixedNameIR as lvalueIR) #( typeIR ))

  }

  lvalue-member: p TC |- lvalue : % {

    1. If ((lvalue matches pattern `%.%`)), then

      1. (Let (lvalue_base . member) be lvalue)

      2. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

      3. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

      4. (Let typeIR' be $canon(typeIR_base))

      5. Case analysis on typeIR'

        1. Case (% has type headerStackTypeIR)

          1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

          2. (Let nameIR be $name(member))

          3. If (((nameIR = "next") \/ (nameIR = "last"))), then

            1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

              1. (Let typedLvalueIR be ((typedLvalueIR_base . nameIR) #( typeIR )))

              2. Result in typedLvalueIR

        2. Case (% has type structTypeIR)

          1. (Let (struct _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as structTypeIR))

          2. (Let nameIR be $name(member))

          3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

          4. If ((typeIR''? matches pattern (_))), then

            1. (Let ?(typeIR) be typeIR''?)

            2. (Let typedLvalueIR be ((typedLvalueIR_base . nameIR) #( typeIR )))

            3. Result in typedLvalueIR

        3. Case (% has type headerTypeIR)

          1. (Let (header _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as headerTypeIR))

          2. (Let nameIR be $name(member))

          3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

          4. If ((typeIR''? matches pattern (_))), then

            1. (Let ?(typeIR) be typeIR''?)

            2. (Let typedLvalueIR be ((typedLvalueIR_base . nameIR) #( typeIR )))

            3. Result in typedLvalueIR

        4. Case (% has type headerUnionTypeIR)

          1. (Let (header_union _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as headerUnionTypeIR))

          2. (Let nameIR be $name(member))

          3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

          4. If ((typeIR''? matches pattern (_))), then

            1. (Let ?(typeIR) be typeIR''?)

            2. (Let typedLvalueIR be ((typedLvalueIR_base . nameIR) #( typeIR )))

            3. Result in typedLvalueIR

  }

  lvalue-expression: p TC |- lvalue : % {

    1. If ((lvalue matches pattern `%[%]`)), then

      1. (Let (lvalue_base [ expression_index ]) be lvalue)

      2. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

      3. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

      4. (Let typeIR' be $canon(typeIR_base))

      5. If ((typeIR' has type headerStackTypeIR)), then

        1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

        2. (Expr_ok: p TC |- expression_index : typedExpressionIR_index)

        3. (Let (_expressionIR # (( typeIR_index ctk_index ))) be typedExpressionIR_index)

        4. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index))

        5. If ((typedExpressionIR? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_index_reduced) be typedExpressionIR?)

          2. Case analysis on (ctk_index matches pattern `LCTK`)

            1. Case true

              1. (Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index)

              2. (Let int be $to_number(value_index))

              3. If ((int has type nat)), then

                1. (Let n_index be (int as nat))

                2. If ((n_index < n_size)), then

                  1. (Let typedLvalueIR be ((typedLvalueIR_base [ typedExpressionIR_index_reduced ]) #( typeIR )))

                  2. Result in typedLvalueIR

            2. Case false

              1. (Let typedLvalueIR be ((typedLvalueIR_base [ typedExpressionIR_index_reduced ]) #( typeIR )))

              2. Result in typedLvalueIR

  }

  lvalue-expression-expression: p TC |- lvalue : % {

    1. If ((lvalue matches pattern `%[%:%]`)), then

      1. (Let (lvalue_base [ expression_hi : expression_lo ]) be lvalue)

      2. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

      3. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

      4. If ($compat_bitslice_base(typeIR_base)), then

        1. (Expr_ok: p TC |- expression_hi : typedExpressionIR_hi)

        2. (Expr_ok: p TC |- expression_lo : typedExpressionIR_lo)

        3. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index))

        4. If ((typedExpressionIR? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_hi_reduced) be typedExpressionIR?)

          2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index))

          3. If ((typedExpressionIR'? matches pattern (_))), then

            1. (Let ?(typedExpressionIR_lo_reduced) be typedExpressionIR'?)

            2. (Let (_expressionIR # (( typeIR_hi_reduced ctk_hi_reduced ))) be typedExpressionIR_hi_reduced)

            3. (Let (_expressionIR' # (( typeIR_lo_reduced ctk_lo_reduced ))) be typedExpressionIR_lo_reduced)

            4. If ((ctk_hi_reduced matches pattern `LCTK`)), then

              1. (Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi)

              2. (Let int be $to_number(value_hi))

              3. If ((int has type nat)), then

                1. (Let n_hi be (int as nat))

                2. If ((ctk_lo_reduced matches pattern `LCTK`)), then

                  1. (Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo)

                  2. (Let int' be $to_number(value_lo))

                  3. If ((int' has type nat)), then

                    1. (Let n_lo be (int' as nat))

                    2. If ($is_valid_bitslice(typeIR_base, n_lo, n_hi)), then

                      1. (Let typeIR be ((bit< ((n_hi - n_lo) + 1) >) as typeIR))

                      2. (Let typedLvalueIR be ((typedLvalueIR_base [ typedExpressionIR_hi_reduced : typedExpressionIR_lo_reduced ]) #( typeIR )))

                      3. Result in typedLvalueIR

  }

  parenthesized: p TC |- lvalue : % {

    1. If ((lvalue matches pattern `(%)`)), then

      1. (Let (( lvalue_base )) be lvalue)

      2. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

      3. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

      4. (Let typedLvalueIR be ((( typedLvalueIR_base )) #( typeIR_base )))

      5. Result in typedLvalueIR

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:67.1-69.26
relation Stmt_ok: 

  emptyStatement: p TC f |- statement : % % % {

    1. If ((statement = ((;) as statement))), then

      1. Result in TC, f, ((;) as statementIR)

  }

  assignmentStatement-eq: p TC f |- statement : % % % {

    1. If ((statement has type assignmentStatement)), then

      1. (Let (lvalue assignop expression ;) be (statement as assignmentStatement))

      2. If ((assignop matches pattern `=`)), then

        1. (Lvalue_ok: p TC |- lvalue : typedLvalueIR)

        2. (Expr_ok: p TC |- expression : typedExpressionIR)

        3. (Let (_lvalueIR #( typeIR_l )) be typedLvalueIR)

        4. (Let (_expressionIR # (( typeIR_r _ctk ))) be typedExpressionIR)

        5. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR, typeIR_l))

        6. If ((typedExpressionIR'? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_cast) be typedExpressionIR'?)

          2. Result in TC, f, ((typedLvalueIR (=) typedExpressionIR ;) as statementIR)

  }

  callStatement: p TC f |- statement : % % % {

    1. If ((statement has type callStatement)), then

      1. (Let callStatement be (statement as callStatement))

      2. Case analysis on callStatement

        1. Case (% matches pattern `%(%);`)

          1. (Let (lvalue_routine ( argumentList );) be callStatement)

          2. (RoutineTarget_lvalue_ok: p TC |- lvalue_routine : routineTargetIR)

          3. (Let argument* be $flatten_argumentList(argumentList))

          4. (Argument_ok: p TC |- argument : argumentIR)*

          5. (RoutineType_ok: p TC |- routineTargetIR < [] >( argumentIR* ): routineTypeIR <# tid_impl* >(# id_default* ))

          6. (Call_ok: p TC |- routineTypeIR < [] # tid_impl* >( argumentIR* # id_default* ): typeIR_ret < typeArgumentIR_inferred* >( argumentIR_cast* ))

          7. (Let callStatementIR be (routineTargetIR < typeArgumentIR_inferred* >( argumentIR_cast* );))

          8. Result in TC, f, (callStatementIR as statementIR)

        2. Case (% matches pattern `%<%>(%);`)

          1. (Let (lvalue_routine < typeArgumentList >( argumentList );) be callStatement)

          2. (RoutineTarget_lvalue_ok: p TC |- lvalue_routine : routineTargetIR)

          3. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

          4. (TypeArguments_ok: p TC |- typeArgument* : typeArgumentIR* # tid_impl*)

          5. (Let argument* be $flatten_argumentList(argumentList))

          6. (Argument_ok: p TC |- argument : argumentIR)*

          7. (RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR* >( argumentIR* ): routineTypeIR <# tid_inserted* >(# id_default* ))

          8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

          9. (Call_ok: p TC |- routineTypeIR < [] # tid_infer* >( argumentIR* # id_default* ): typeIR_ret < typeArgumentIR_inferred* >( argumentIR_cast* ))

          10. (Let callStatementIR be (routineTargetIR < typeArgumentIR_inferred* >( argumentIR_cast* );))

          11. Result in TC, f, (callStatementIR as statementIR)

  }

  directApplicationStatement-prefixedTypeName: p TC_0 f |- statement : % % % {

    1. If ((statement has type directApplicationStatement)), then

      1. (Let (namedType .apply( argumentList );) be (statement as directApplicationStatement))

      2. (Expr_ok: p TC_0 |- (((namedType as callTarget) ( () )) as expression) : (expressionIR # (( typeIR_object _ctk ))))

      3. If ((expressionIR has type callExpressionIR)), then

        1. (Let callExpressionIR be (expressionIR as callExpressionIR))

        2. If ((callExpressionIR matches pattern `%(%)`)), then

          1. (Let ((prefixedNameIR < typeArgumentIR* >) ( argumentIR* )) be callExpressionIR)

          2. If ((typeArgumentIR* matches pattern [])), then

            1. If ((argumentIR* matches pattern [])), then

              1. If ($compat_direct_application(typeIR_object)), then

                1. (Let nameIR_object be "__direct_application")

                2. (Let TC_1 be $add_var(p, TC_0, nameIR_object, (() typeIR_object (ctk) ?())))

                3. (Let lvalue be (((nameIR_object) as lvalue) . (("apply") as member)))

                4. (Stmt_ok: p TC_1 f |- ((lvalue ( argumentList );) as statement) : _typingContext _flow statementIR)

                5. If ((statementIR has type callStatementIR)), then

                  1. (Let callStatementIR be (statementIR as callStatementIR))

                  2. (Let (routineTargetIR < typeArgumentIR'* >( argumentIR_cast* );) be callStatementIR)

                  3. If ((routineTargetIR = ((((` nameIR_object) as expressionIR) # (( typeIR_object (ctk) ))) . "apply"))), then

                    1. If ((typeArgumentIR'* matches pattern [])), then

                      1. (Let directApplicationStatementIR be (prefixedNameIR .apply( argumentIR_cast* );))

                      2. Result in TC_0, f, (directApplicationStatementIR as statementIR)

  }

  returnStatement: cursor TC f |- statement : % % % {

    1. If ((cursor matches pattern `LOCAL`)), then

      1. If ((statement = ((return;) as statement))), then

        1. If ((?(((void) as typeIR)) = $find_return_type(TC))), then

          1. Result in TC, (ret), ((return;) as statementIR)

      2. If ((statement has type returnStatement)), then

        1. (Let returnStatement be (statement as returnStatement))

        2. If ((returnStatement matches pattern `RETURN%;`)), then

          1. (Let (return expression ;) be returnStatement)

          2. (Expr_ok: (local) TC |- expression : typedExpressionIR)

          3. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

          4. (Let typeIR'? be $find_return_type(TC))

          5. If ((typeIR'? matches pattern (_))), then

            1. (Let ?(typeIR_ret) be typeIR'?)

            2. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR, typeIR_ret))

            3. If ((typedExpressionIR'? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_cast) be typedExpressionIR'?)

              2. Result in TC, (ret), ((return typedExpressionIR_cast ;) as statementIR)

  }

  exitStatement: p TC f |- statement : % % % {

    1. If ((statement = ((exit;) as statement))), then

      1. Result in TC, f, ((exit;) as statementIR)

  }

  blockStatement: cursor TC_0 f_0 |- statement : % % % {

    1. If ((cursor matches pattern `LOCAL`)), then

      1. If ((statement has type blockStatement)), then

        1. (Let blockStatement be (statement as blockStatement))

        2. (Block_ok: TC_0 f_0 |- blockStatement : TC_1 f_1 blockStatementIR)

        3. Result in TC_1, f_1, (blockStatementIR as statementIR)

  }

  conditionalStatement: p TC f |- statement : % % % {

    1. If ((statement has type conditionalStatement)), then

      1. (Let conditionalStatement be (statement as conditionalStatement))

      2. Case analysis on conditionalStatement

        1. Case (% matches pattern `IF(%)%`)

          1. (Let (if( expression_cond ) statement_then) be conditionalStatement)

          2. (Expr_ok: p TC |- expression_cond : typedExpressionIR_cond)

          3. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR_cond)

          4. If ((typeIR = ((bool) as typeIR))), then

            1. (Stmt_ok: p TC f |- statement_then : TC_then f_then statementIR_then)

            2. Result in TC, f, ((if( typedExpressionIR_cond ) statementIR_then) as statementIR)

        2. Case (% matches pattern `IF(%)%ELSE%`)

          1. (Let (if( expression_cond ) statement_then else statement_else) be conditionalStatement)

          2. (Expr_ok: p TC |- expression_cond : typedExpressionIR_cond)

          3. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR_cond)

          4. If ((typeIR = ((bool) as typeIR))), then

            1. (Stmt_ok: p TC f |- statement_then : TC_then f_then statementIR_then)

            2. (Stmt_ok: p TC f |- statement_else : TC_else f_else statementIR_else)

            3. (Let f_post be $join_flow(f_then, f_else))

            4. Result in TC, f_post, ((if( typedExpressionIR_cond ) statementIR_then else statementIR_else) as statementIR)

  }

  switch-table-apply: cursor TC f |- statement : % % % {

    1. If ((cursor matches pattern `LOCAL`)), then

      1. If ((statement has type switchStatement)), then

        1. (Let (switch( expression_switch ){ switchCaseList }) be (statement as switchStatement))

        2. (Expr_ok: (local) TC |- expression_switch : typedExpressionIR_switch)

        3. (Let (_expressionIR # (( typeIR_switch _ctk ))) be typedExpressionIR_switch)

        4. (Let typeIR be $canon(typeIR_switch))

        5. If ((typeIR has type tableTypeIR)), then

          1. (Let tableTypeIR be (typeIR as tableTypeIR))

          2. If ((tableTypeIR matches pattern `TABLE_ENUM%{%}`)), then

            1. (Let (table_enum tid_table_enum { _id* }) be tableTypeIR)

            2. (Let tid_table be $strip_prefix($strip_suffix(tid_table_enum, ")"), "action_list("))

            3. (Let switchCase* be $flatten_switchCaseList(switchCaseList))

            4. (SwitchCases_table_ok: TC f tid_table |- switchCase* : f_post switchCaseIR* # switchLabel*)

            5. If ($distinct_<switchLabel>(switchLabel*)), then

              1. (Let switchStatementIR be (switch( typedExpressionIR_switch ){ switchCaseIR* }))

              2. Result in TC, f_post, (switchStatementIR as statementIR)

  }

  switch-general: cursor TC f |- statement : % % % {

    1. If ((cursor matches pattern `LOCAL`)), then

      1. If ((statement has type switchStatement)), then

        1. (Let (switch( expression_switch ){ switchCaseList }) be (statement as switchStatement))

        2. (Expr_ok: (local) TC |- expression_switch : typedExpressionIR_switch)

        3. (Let (_expressionIR # (( typeIR_switch _ctk ))) be typedExpressionIR_switch)

        4. If ($compat_switch(typeIR_switch)), then

          1. (Let switchCase* be $flatten_switchCaseList(switchCaseList))

          2. (SwitchCases_general_ok: TC f typeIR_switch |- switchCase* : f_post switchCaseIR* # switchLabel*)

          3. If ($distinct_<switchLabel>(switchLabel*)), then

            1. (Let switchStatementIR be (switch( typedExpressionIR_switch ){ switchCaseIR* }))

            2. Result in TC, f_post, (switchStatementIR as statementIR)

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:71.1-73.26
relation Stmts_ok: 



;; ../../../../spec-concrete/5.04-typing-relation.watsup:75.1-78.23
relation BlockElementStmt_ok: 

  constantDeclaration: TC_0 f |- blockElementStatement : % % % {

    1. If ((blockElementStatement has type constantDeclaration)), then

      1. (Let constantDeclaration be (blockElementStatement as constantDeclaration))

      2. (Decl_ok: (local) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

      3. If ((declarationIR has type constantDeclarationIR)), then

        1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

        2. Result in TC_1, f, (constantDeclarationIR as blockElementStatementIR)

  }

  variableDeclaration: TC_0 f |- blockElementStatement : % % % {

    1. If ((blockElementStatement has type variableDeclaration)), then

      1. (Let (annotationList type name initializerOpt ;) be (blockElementStatement as variableDeclaration))

      2. If ((initializerOpt matches pattern ``EMPTY`)), then

        1. (Type_ok: (local) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

        2. If ((tid* matches pattern [])), then

          1. If ((Type_wf: $bound((local), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Let nameIR be $name(name))

              2. (Let TC_1 be $add_var((local), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

              3. (Let variableDeclarationIR be (annotationList typeIR nameIR ?() ;))

              4. Result in TC_1, f, (variableDeclarationIR as blockElementStatementIR)

      3. If ((initializerOpt has type initializer)), then

        1. (Let (= expression_init) be (initializerOpt as initializer))

        2. (Type_ok: (local) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

        3. If ((tid* matches pattern [])), then

          1. If ((Type_wf: $bound((local), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Expr_ok: (local) TC_0 |- expression_init : typedExpressionIR_init)

              2. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

              3. If ((typedExpressionIR? matches pattern (_))), then

                1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

                2. (Let nameIR be $name(name))

                3. (Let TC_1 be $add_var((local), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

                4. (Let variableDeclarationIR be (annotationList typeIR nameIR ?((= typedExpressionIR_init_cast)) ;))

                5. Result in TC_1, f, (variableDeclarationIR as blockElementStatementIR)

  }

  statement: TC_0 f |- blockElementStatement : % % % {

    1. If ((blockElementStatement has type statement)), then

      1. (Let statement be (blockElementStatement as statement))

      2. (Stmt_ok: (local) TC_0 f |- statement : TC_1 f_post statementIR)

      3. Result in TC_1, f_post, (statementIR as blockElementStatementIR)

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:80.1-83.23
relation BlockElementStmts_ok: 

  nil: TC f |- blockElementStatement*{blockElementStatement <- blockElementStatement*} : % % % {

    1. If ((blockElementStatement* matches pattern [])), then

      1. Result in TC, f, []

  }

  cons: TC_0 f_0 |- blockElementStatement*{blockElementStatement <- blockElementStatement*} : % % % {

    1. If ((blockElementStatement* matches pattern _ :: _)), then

      1. (Let blockElementStatement_h :: blockElementStatement_t* be blockElementStatement*)

      2. (BlockElementStmt_ok: TC_0 f_0 |- blockElementStatement_h : TC_1 f_1 blockElementStatementIR_h)

      3. (BlockElementStmts_ok: TC_1 f_1 |- blockElementStatement_t* : TC_2 f_2 blockElementStatementIR_t*)

      4. Result in TC_2, f_2, blockElementStatementIR_h :: blockElementStatementIR_t*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:85.1-88.23
relation Block_ok: 

  : TC_0 f |- annotationList { blockElementStatementList } : % % % {

    1. (Let blockElementStatement* be $flatten_blockElementStatementList(blockElementStatementList))

    2. (Let TC_1 be $enter(TC_0))

    3. (BlockElementStmts_ok: TC_1 f |- blockElementStatement* : TC_2 f_post blockElementStatementIR*)

    4. (Let TC_3 be $exit(TC_2))

    5. (Let blockStatementIR be (annotationList { blockElementStatementIR* }))

    6. Result in TC_3, f_post, blockStatementIR

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:95.1-97.23
relation Parameter_ok: 

  empty: p TC |- annotationList direction type name initializerOpt : % # % {

    1. If ((initializerOpt matches pattern ``EMPTY`)), then

      1. (Type_ok: p TC |- (type as typeOrVoid) : typeIR # tid_fresh*)

      2. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_fresh* })))

      3. If ((Type_wf: bound |- typeIR holds)), then

        1. (Let nameIR be $name(name))

        2. Result in (annotationList direction typeIR nameIR ?()), tid_fresh*

  }

  initializer: p TC |- annotationList direction type name initializerOpt : % # % {

    1. If ((initializerOpt has type initializer)), then

      1. (Let (= expression_init) be (initializerOpt as initializer))

      2. (Type_ok: p TC |- (type as typeOrVoid) : typeIR # tid_fresh*)

      3. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_fresh* })))

      4. If ((Type_wf: bound |- typeIR holds)), then

        1. (Expr_ok: p TC |- expression_init : typedExpressionIR_init)

        2. (Let (_expressionIR # (( typeIR_init ctk ))) be typedExpressionIR_init)

        3. If ((ctk matches pattern `LCTK`)), then

          1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

          2. If ((typedExpressionIR? matches pattern (_))), then

            1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

            2. (Let nameIR be $name(name))

            3. (Eval_static: p TC |- typedExpressionIR_init_cast ~> value_init)

            4. Result in (annotationList direction typeIR nameIR ?((= value_init))), tid_fresh*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:99.1-101.23
relation Parameters_ok: 

  nil: p TC |- parameter*{parameter <- parameter*} : % # % {

    1. If ((parameter* matches pattern [])), then

      1. Result in [], []

  }

  cons: p TC |- parameter*{parameter <- parameter*} : % # % {

    1. If ((parameter* matches pattern _ :: _)), then

      1. (Let parameter_h :: parameter_t* be parameter*)

      2. (Parameter_ok: p TC |- parameter_h : parameterIR_h # tid_fresh_h*)

      3. (Parameters_ok: p TC |- parameter_t* : parameterIR_t* # tid_fresh_t*)

      4. Result in parameterIR_h :: parameterIR_t*, tid_fresh_h* ++ tid_fresh_t*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:103.1-103.48
def $parameterIR((_annotationList direction typeIR nameIR constantInitializerOptIR'))

1. (Let constantInitializerIR? be constantInitializerOptIR')

2. If ((constantInitializerIR? matches pattern ())), then

  1. Return (direction typeIR nameIR ?())

3. If ((constantInitializerOptIR' matches pattern (_))), then

  1. (Let ?((= value)) be constantInitializerOptIR')

  2. Return (direction typeIR nameIR ?(value))

;; ../../../../spec-concrete/5.04-typing-relation.watsup:109.1-112.23
relation ConstructorParameter_ok: 

  : p TC |- constructorParameter : % # % {

    1. (Parameter_ok: p TC |- constructorParameter : constructorParameterIR # tid_fresh*)

    2. Result in constructorParameterIR, tid_fresh*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:114.1-117.23
relation ConstructorParameters_ok: 

  : p TC |- constructorParameter*{constructorParameter <- constructorParameter*} : % # % {

    1. (Parameters_ok: p TC |- constructorParameter* : constructorParameterIR* # tid_fresh*)

    2. Result in constructorParameterIR*, tid_fresh*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:119.1-119.81
def $constructorParameterIR(constructorParameterIR)

1. Return $parameterIR(constructorParameterIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:127.1-129.23
relation ExternMethod_ok: 

  non-abstract: TC_0 tid_extern |- methodPrototype : % % {

    1. If ((methodPrototype matches pattern `%%;`)), then

      1. (Let (annotationList (typeOrVoid name typeParameterListOpt ( parameterList )) ;) be methodPrototype)

      2. (Let nameIR be $name(name))

      3. If ((nameIR =/= tid_extern)), then

        1. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

        2. (Let tid_expl be $name(typeParameter))*

        3. (Let TC_1 be $add_types((local), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

        4. (Type_ok: (local) TC_1 |- typeOrVoid : typeIR_ret # tid*)

        5. If ((tid* matches pattern [])), then

          1. (Let TC_2 be TC_1[local.kind = (extern_method-> typeIR_ret)])

          2. (Let parameter* be $flatten_parameterList(parameterList))

          3. (Parameters_ok: (local) TC_2 |- parameter* : parameterIR* # tid_impl*)

          4. (Let parameterTypeIR be $parameterIR(parameterIR))*

          5. (Let TC_3 be $add_parameters((local), TC_2, parameterTypeIR*))

          6. (Let rid be $rid(name, parameterList))

          7. (Let methodTypeIR be (extern_method( parameterTypeIR* )-> typeIR_ret))

          8. (Let routineTypeDefIR be (((methodTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

          9. If ((RoutineTypeDef_wf: $bound((block), TC_0) |- routineTypeDefIR holds)), then

            1. (Let TC_4 be $add_routine_overload((block), TC_0, rid, routineTypeDefIR))

            2. (Let methodPrototypeIR be (annotationList (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) ;))

            3. Result in TC_4, methodPrototypeIR

  }

  abstract: TC_0 tid_extern |- methodPrototype : % % {

    1. If ((methodPrototype matches pattern `%ABSTRACT%;`)), then

      1. (Let (annotationList abstract (typeOrVoid name typeParameterListOpt ( parameterList )) ;) be methodPrototype)

      2. (Let nameIR be $name(name))

      3. If ((nameIR =/= tid_extern)), then

        1. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

        2. (Let tid_expl be $name(typeParameter))*

        3. (Let TC_1 be $add_types((local), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

        4. (Type_ok: (local) TC_1 |- typeOrVoid : typeIR_ret # tid*)

        5. If ((tid* matches pattern [])), then

          1. (Let TC_2 be TC_1[local.kind = (extern_methodabstract-> typeIR_ret)])

          2. (Let parameter* be $flatten_parameterList(parameterList))

          3. (Parameters_ok: (local) TC_2 |- parameter* : parameterIR* # tid_impl*)

          4. (Let parameterTypeIR be $parameterIR(parameterIR))*

          5. (Let TC_3 be $add_parameters((local), TC_2, parameterTypeIR*))

          6. (Let rid be $rid(name, parameterList))

          7. (Let methodTypeIR be (extern_methodabstract( parameterTypeIR* )-> typeIR_ret))

          8. (Let routineTypeDefIR be (((methodTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

          9. If ((RoutineTypeDef_wf: $bound((block), TC_0) |- routineTypeDefIR holds)), then

            1. (Let TC_4 be $add_routine_overload((block), TC_0, rid, routineTypeDefIR))

            2. (Let methodPrototypeIR be (annotationList abstract (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) ;))

            3. Result in TC_4, methodPrototypeIR

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:131.1-133.23
relation ExternMethods_ok: 

  nil: TC tid_extern |- methodPrototype*{methodPrototype <- methodPrototype*} : % % {

    1. If ((methodPrototype* matches pattern [])), then

      1. Result in TC, []

  }

  cons: TC_0 tid_extern |- methodPrototype*{methodPrototype <- methodPrototype*} : % % {

    1. If ((methodPrototype* matches pattern _ :: _)), then

      1. (Let methodPrototype_h :: methodPrototype_t* be methodPrototype*)

      2. (ExternMethod_ok: TC_0 tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h)

      3. (ExternMethods_ok: TC_1 tid_extern |- methodPrototype_t* : TC_2 methodPrototypeIR_t*)

      4. Result in TC_2, methodPrototypeIR_h :: methodPrototypeIR_t*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:135.1-137.23
relation ExternConstructor_ok: 

  : TC_0 tid_extern |- methodPrototype : % % {

    1. If ((methodPrototype matches pattern `%%(%);`)), then

      1. (Let (annotationList typeIdentifier ( parameterList );) be methodPrototype)

      2. (Let nameIR be $name((typeIdentifier as name)))

      3. If ((nameIR = tid_extern)), then

        1. (Let constructorParameter* be $flatten_parameterList(parameterList))

        2. (ConstructorParameters_ok: (block) TC_0 |- constructorParameter* : constructorParameterIR* # tid_impl*)

        3. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*

        4. (Let typeDefIR'? be $find_type((global), TC_0, (` nameIR)))

        5. If ((typeDefIR'? matches pattern (_))), then

          1. (Let ?(typeDefIR) be typeDefIR'?)

          2. If ((typeDefIR has type polyTypeDefIR)), then

            1. (Let (typeIR_extern < tid_expl* , tid* >) be (typeDefIR as polyTypeDefIR))

            2. If ((tid* matches pattern [])), then

              1. (Let cid be $cid((typeIdentifier as name), (( parameterList ))))

              2. (Let typeIR_extern_spec be (((typeIR_extern < tid_expl* , [] >) < ((tid tid_expl) as typeIR)* >) as typeIR))

              3. (Let constructorTypeIR be (constructor( constructorParameterTypeIR* )-> typeIR_extern_spec))

              4. (Let constructorTypeDefIR be (constructorTypeIR < tid_expl* , tid_impl* >))

              5. If ((ConstructorTypeDef_wf: $bound((block), TC_0) |- constructorTypeDefIR holds)), then

                1. (Let TC_1 be $add_constructor(TC_0, cid, constructorTypeDefIR))

                2. (Let methodPrototypeIR be (annotationList nameIR <, tid_impl* >( constructorParameterIR* );))

                3. Result in TC_1, methodPrototypeIR

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:139.1-141.23
relation ExternConstructors_ok: 

  nil: TC tid_extern |- methodPrototype*{methodPrototype <- methodPrototype*} : % % {

    1. If ((methodPrototype* matches pattern [])), then

      1. Result in TC, []

  }

  cons: TC_0 tid_extern |- methodPrototype*{methodPrototype <- methodPrototype*} : % % {

    1. If ((methodPrototype* matches pattern _ :: _)), then

      1. (Let methodPrototype_h :: methodPrototype_t* be methodPrototype*)

      2. (ExternConstructor_ok: TC_0 tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h)

      3. (ExternConstructors_ok: TC_1 tid_extern |- methodPrototype_t* : TC_2 methodPrototypeIR_t*)

      4. Result in TC_2, methodPrototypeIR_h :: methodPrototypeIR_t*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:147.1-149.23
relation ParserTransition_ok: 

  empty: TC_0 nameIR_state*{nameIR_state <- nameIR_state*} |- transitionStatement : % {

    1. If ((transitionStatement matches pattern ``EMPTY`)), then

      1. Result in (transition ("reject" ;))

  }

  name: TC_0 nameIR_state*{nameIR_state <- nameIR_state*} |- transitionStatement : % {

    1. If ((transitionStatement matches pattern `TRANSITION%`)), then

      1. (Let (transition stateExpression) be transitionStatement)

      2. If ((stateExpression matches pattern `%;`)), then

        1. (Let (name ;) be stateExpression)

        2. (Let nameIR be $name(name))

        3. If (nameIR is in nameIR_state*), then

          1. (Let transitionStatementIR be (transition (nameIR ;)))

          2. Result in transitionStatementIR

  }

  switch: TC_0 nameIR_state*{nameIR_state <- nameIR_state*} |- transitionStatement : % {

    1. If ((transitionStatement matches pattern `TRANSITION%`)), then

      1. (Let (transition stateExpression) be transitionStatement)

      2. If ((stateExpression has type selectExpression)), then

        1. (Let (select( expressionList_key ){ selectCaseList }) be (stateExpression as selectExpression))

        2. (Let expression_key* be $flatten_expressionList(expressionList_key))

        3. (Expr_ok: (local) TC_0 |- expression_key : typedExpressionIR_key)*

        4. (Let (_expressionIR # (( typeIR_key _ctk ))) be typedExpressionIR_key)*

        5. If ((Type_wf: $bound((local), TC_0) |- ((set< [typeIR_key] >) as typeIR) holds))*, then

          1. (Let selectCase* be $flatten_selectCaseList(selectCaseList))

          2. (SelectCase_ok: TC_0 nameIR_state* typeIR_key* |- selectCase : selectCaseIR)*

          3. (Let transitionStatementIR be (transition ((select( typedExpressionIR_key* ){ selectCaseIR* }) as stateExpressionIR)))

          4. Result in transitionStatementIR

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:151.1-153.20
relation ParserStmt_ok: 

  constantDeclaration: TC_0 |- parserStatement : % % {

    1. If ((parserStatement has type constantDeclaration)), then

      1. (Let constantDeclaration be (parserStatement as constantDeclaration))

      2. (Decl_ok: (local) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

      3. If ((declarationIR has type constantDeclarationIR)), then

        1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

        2. Result in TC_1, (constantDeclarationIR as parserStatementIR)

  }

  variableDeclaration: TC_0 |- parserStatement : % % {

    1. If ((parserStatement has type variableDeclaration)), then

      1. (Let (annotationList type name initializerOpt ;) be (parserStatement as variableDeclaration))

      2. If ((initializerOpt matches pattern ``EMPTY`)), then

        1. (Type_ok: (local) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

        2. If ((tid* matches pattern [])), then

          1. If ((Type_wf: $bound((local), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Let nameIR be $name(name))

              2. (Let TC_1 be $add_var((local), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

              3. (Let variableDeclarationIR be (annotationList typeIR nameIR ?() ;))

              4. Result in TC_1, (variableDeclarationIR as parserStatementIR)

      3. If ((initializerOpt has type initializer)), then

        1. (Let (= expression_init) be (initializerOpt as initializer))

        2. (Type_ok: (local) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

        3. If ((tid* matches pattern [])), then

          1. If ((Type_wf: $bound((local), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Expr_ok: (local) TC_0 |- expression_init : typedExpressionIR_init)

              2. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

              3. If ((typedExpressionIR? matches pattern (_))), then

                1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

                2. (Let nameIR be $name(name))

                3. (Let TC_1 be $add_var((local), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

                4. (Let variableDeclarationIR be (annotationList typeIR nameIR ?((= typedExpressionIR_init_cast)) ;))

                5. Result in TC_1, (variableDeclarationIR as parserStatementIR)

  }

  emptyStatement: TC |- parserStatement : % % {

    1. If ((parserStatement has type emptyStatement)), then

      1. (Let emptyStatement be (parserStatement as emptyStatement))

      2. (Stmt_ok: (local) TC (cont) |- (emptyStatement as statement) : typingContext flow statementIR)

      3. If ((typingContext = TC)), then

        1. If ((flow matches pattern `CONT`)), then

          1. If ((statementIR has type emptyStatementIR)), then

            1. (Let emptyStatementIR be (statementIR as emptyStatementIR))

            2. Result in TC, (emptyStatementIR as parserStatementIR)

  }

  assignmentStatement: TC_0 |- parserStatement : % % {

    1. If ((parserStatement has type assignmentStatement)), then

      1. (Let assignmentStatement be (parserStatement as assignmentStatement))

      2. (Stmt_ok: (local) TC_0 (cont) |- (assignmentStatement as statement) : TC_1 flow statementIR)

      3. If ((flow matches pattern `CONT`)), then

        1. If ((statementIR has type assignmentStatementIR)), then

          1. (Let assignmentStatementIR be (statementIR as assignmentStatementIR))

          2. Result in TC_1, (assignmentStatementIR as parserStatementIR)

  }

  callStatement: TC_0 |- parserStatement : % % {

    1. If ((parserStatement has type callStatement)), then

      1. (Let callStatement be (parserStatement as callStatement))

      2. (Stmt_ok: (local) TC_0 (cont) |- (callStatement as statement) : TC_1 flow statementIR)

      3. If ((flow matches pattern `CONT`)), then

        1. If ((statementIR has type callStatementIR)), then

          1. (Let callStatementIR be (statementIR as callStatementIR))

          2. Result in TC_1, (callStatementIR as parserStatementIR)

  }

  directApplicationStatement: TC_0 |- parserStatement : % % {

    1. If ((parserStatement has type directApplicationStatement)), then

      1. (Let directApplicationStatement be (parserStatement as directApplicationStatement))

      2. (Stmt_ok: (local) TC_0 (cont) |- (directApplicationStatement as statement) : TC_1 flow statementIR)

      3. If ((flow matches pattern `CONT`)), then

        1. If ((statementIR has type directApplicationStatementIR)), then

          1. (Let directApplicationStatementIR be (statementIR as directApplicationStatementIR))

          2. Result in TC_1, (directApplicationStatementIR as parserStatementIR)

  }

  parserBlockStatement: TC_0 |- parserStatement' : % % {

    1. If ((parserStatement' has type parserBlockStatement)), then

      1. (Let (annotationList { parserStatementList }) be (parserStatement' as parserBlockStatement))

      2. (Let parserStatement* be $flatten_parserStatementList(parserStatementList))

      3. (Let TC_1 be $enter(TC_0))

      4. (ParserStmts_ok: TC_1 |- parserStatement* : TC_2 parserStatementIR*)

      5. (Let TC_3 be $exit(TC_2))

      6. (Let parserBlockStatementIR be (annotationList { parserStatementIR* }))

      7. Result in TC_1, (parserBlockStatementIR as parserStatementIR)

  }

  conditionalStatement: TC_0 |- parserStatement : % % {

    1. If ((parserStatement has type conditionalStatement)), then

      1. (Let conditionalStatement be (parserStatement as conditionalStatement))

      2. (Stmt_ok: (local) TC_0 (cont) |- (conditionalStatement as statement) : TC_1 flow statementIR)

      3. If ((flow matches pattern `CONT`)), then

        1. If ((statementIR has type conditionalStatementIR)), then

          1. (Let conditionalStatementIR be (statementIR as conditionalStatementIR))

          2. Result in TC_1, (conditionalStatementIR as parserStatementIR)

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:155.1-157.20
relation ParserStmts_ok: 

  nil: TC |- parserStatement*{parserStatement <- parserStatement*} : % % {

    1. If ((parserStatement* matches pattern [])), then

      1. Result in TC, []

  }

  cons: TC_0 |- parserStatement*{parserStatement <- parserStatement*} : % % {

    1. If ((parserStatement* matches pattern _ :: _)), then

      1. (Let parserStatement_h :: parserStatement_t* be parserStatement*)

      2. (ParserStmt_ok: TC_0 |- parserStatement_h : TC_1 parserStatementIR_h)

      3. (ParserStmts_ok: TC_1 |- parserStatement_t* : TC_2 parserStatementIR_t*)

      4. Result in TC_2, parserStatementIR_h :: parserStatementIR_t*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:159.1-161.23
relation ParserState_ok: 

  : TC_0 nameIR_state*{nameIR_state <- nameIR_state*} |- annotationList state name { parserStatementList transitionStatement } : % {

    1. (Let nameIR be $name(name))

    2. (Let TC_1 be $enter(TC_0))

    3. (Let parserStatement* be $flatten_parserStatementList(parserStatementList))

    4. (ParserStmts_ok: TC_1 |- parserStatement* : TC_2 parserStatementIR*)

    5. (ParserTransition_ok: TC_2 nameIR_state* |- transitionStatement : transitionStatementIR)

    6. (Let TC_3 be $exit(TC_2))

    7. (Let parserStateIR be (annotationList state nameIR { parserStatementIR* transitionStatementIR }))

    8. Result in parserStateIR

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:163.1-165.20
relation ParserStates_ok: 

  : TC |- parserState*{parserState <- parserState*} : % {

    1. (Let (_annotationList state name_state { _parserStatementList _transitionStatement }) be parserState)*

    2. (Let nameIR_state be $name(name_state))*

    3. If ($distinct_<nameIR>(nameIR_state*)), then

      1. If ("start" is in nameIR_state*), then

        1. If ((~"accept" is in nameIR_state* /\ ~"reject" is in nameIR_state*)), then

          1. (Let nameIR_state_impl* be "accept" :: "reject" :: nameIR_state*)

          2. (ParserState_ok: TC nameIR_state_impl* |- parserState : parserStateIR)*

          3. Result in parserStateIR*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:167.1-170.20
relation ParserLocalDecl_ok: 

  constantDeclaration: TC_0 |- parserLocalDeclaration : % % {

    1. If ((parserLocalDeclaration has type constantDeclaration)), then

      1. (Let constantDeclaration be (parserLocalDeclaration as constantDeclaration))

      2. (Decl_ok: (block) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

      3. If ((declarationIR has type constantDeclarationIR)), then

        1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

        2. Result in TC_1, (constantDeclarationIR as parserLocalDeclarationIR)

  }

  instantiation: TC_0 |- parserLocalDeclaration : % % {

    1. If ((parserLocalDeclaration has type instantiation)), then

      1. (Let instantiation be (parserLocalDeclaration as instantiation))

      2. (Decl_ok: (block) TC_0 |- (instantiation as declaration) : TC_1 declarationIR)

      3. If ((declarationIR has type instantiationIR)), then

        1. (Let instantiationIR be (declarationIR as instantiationIR))

        2. Result in TC_1, (instantiationIR as parserLocalDeclarationIR)

  }

  variableDeclaration: TC_0 |- parserLocalDeclaration : % % {

    1. If ((parserLocalDeclaration has type variableDeclaration)), then

      1. (Let (annotationList type name initializerOpt ;) be (parserLocalDeclaration as variableDeclaration))

      2. If ((initializerOpt matches pattern ``EMPTY`)), then

        1. (Type_ok: (block) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

        2. If ((tid* matches pattern [])), then

          1. If ((Type_wf: $bound((block), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Let nameIR be $name(name))

              2. (Let TC_1 be $add_var((block), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

              3. (Let variableDeclarationIR be (annotationList typeIR nameIR ?() ;))

              4. Result in TC_1, (variableDeclarationIR as parserLocalDeclarationIR)

      3. If ((initializerOpt has type initializer)), then

        1. (Let (= expression_init) be (initializerOpt as initializer))

        2. (Type_ok: (block) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

        3. If ((tid* matches pattern [])), then

          1. If ((Type_wf: $bound((block), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Expr_ok: (block) TC_0 |- expression_init : typedExpressionIR_init)

              2. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

              3. If ((typedExpressionIR? matches pattern (_))), then

                1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

                2. (Let nameIR be $name(name))

                3. (Let TC_1 be $add_var((block), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

                4. (Let variableDeclarationIR be (annotationList typeIR nameIR ?((= typedExpressionIR_init_cast)) ;))

                5. Result in TC_1, (variableDeclarationIR as parserLocalDeclarationIR)

  }

  valueSetDeclaration: TC_0 |- parserLocalDeclaration : % % {

    1. If ((parserLocalDeclaration has type valueSetDeclaration)), then

      1. (Let (annotationList value_set< valueSetType >( expression ) name ;) be (parserLocalDeclaration as valueSetDeclaration))

      2. (Type_ok: (block) TC_0 |- (valueSetType as typeOrVoid) : typeIR # tid*)

      3. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((block), TC_0) |- ((set< [typeIR] >) as typeIR) holds)), then

          1. (Expr_ok: (block) TC_0 |- expression : typedExpressionIR)

          2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR)

          3. If (~(ctk matches pattern `DYN`)), then

            1. (Let nameIR be $name(name))

            2. (Let TC_1 be $add_var((block), TC_0, nameIR, (() ((set< [typeIR] >) as typeIR) (ctk) ?())))

            3. (Let valueSetDeclarationIR be (annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;))

            4. Result in TC_1, (valueSetDeclarationIR as parserLocalDeclarationIR)

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:172.1-175.20
relation ParserLocalDecls_ok: 

  nil: TC |- parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} : % % {

    1. If ((parserLocalDeclaration* matches pattern [])), then

      1. Result in TC, []

  }

  cons: TC_0 |- parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} : % % {

    1. If ((parserLocalDeclaration* matches pattern _ :: _)), then

      1. (Let parserLocalDeclaration_h :: parserLocalDeclaration_t* be parserLocalDeclaration*)

      2. (ParserLocalDecl_ok: TC_0 |- parserLocalDeclaration_h : TC_1 parserLocalDeclarationIR_h)

      3. (ParserLocalDecls_ok: TC_1 |- parserLocalDeclaration_t* : TC_2 parserLocalDeclarationIR_t*)

      4. Result in TC_2, parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:181.1-183.23
relation TableKey_ok: 

  : TC TBLC_0 |- expression : name_matchkind annotationList ; : % % {

    1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

    2. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

    3. If ((Type_wf: $bound((local), TC) |- ((set< [typeIR] >) as typeIR) holds)), then

      1. (Let nameIR_matchkind be $name(name_matchkind))

      2. If ((((match_kind. nameIR_matchkind) as value) = $find_value((local), TC, (` nameIR_matchkind)))), then

        1. If ($compat_table_key(nameIR_matchkind, typeIR)), then

          1. (Let TBLC_1 be $update_mode(TBLC_0, nameIR_matchkind, typeIR))

          2. (Let TBLC_2 be $add_key(TBLC_1, nameIR_matchkind, typeIR))

          3. (Let tableKeyIR be (typedExpressionIR : nameIR_matchkind annotationList ;))

          4. Result in TBLC_2, tableKeyIR

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:185.1-187.23
relation TableKeys_ok: 

  nil: TC TBLC |- tableKey*{tableKey <- tableKey*} : % % {

    1. If ((tableKey* matches pattern [])), then

      1. Result in TBLC, []

  }

  cons: TC TBLC_0 |- tableKey*{tableKey <- tableKey*} : % % {

    1. If ((tableKey* matches pattern _ :: _)), then

      1. (Let tableKey_h :: tableKey_t* be tableKey*)

      2. (TableKey_ok: TC TBLC_0 |- tableKey_h : TBLC_1 tableKeyIR_h)

      3. (TableKeys_ok: TC TBLC_1 |- tableKey_t* : TBLC_2 tableKeyIR_t*)

      4. Result in TBLC_2, tableKeyIR_h :: tableKeyIR_t*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:189.1-192.23
relation Call_action_partial_ok: 

  : TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : % , % @ % {

    1. (Let (parameterTypeIR_data*, parameterTypeIR_control*) be $split_dataplane_parameters(parameterTypeIR*))

    2. If ((|parameterTypeIR_data*| = |argumentIR*|)), then

      1. (Call_convention_ok: (local) TC (action) |- parameterTypeIR_data* @ argumentIR* : argumentIR_cast*)

      2. Result in parameterTypeIR_data*, parameterTypeIR_control*, argumentIR_cast*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:194.1-196.23
relation TableAction_ok: 

  prefixedNonTypeName: TC TBLC_0 |- annotationList tableActionReference ; : % % {

    1. If ((tableActionReference has type prefixedNonTypeName)), then

      1. (Let prefixedNonTypeName be (tableActionReference as prefixedNonTypeName))

      2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

      3. (Let routineTypeDefIR'? be $find_routine_non_overloaded((local), TC, prefixedNameIR))

      4. If ((routineTypeDefIR'? matches pattern (_))), then

        1. (Let ?(routineTypeDefIR) be routineTypeDefIR'?)

        2. If ((routineTypeDefIR has type functionTypeIR)), then

          1. (Let functionTypeIR be (routineTypeDefIR as functionTypeIR))

          2. If ((functionTypeIR matches pattern `ACTION(%)`)), then

            1. (Let (action( parameterTypeIR* )) be functionTypeIR)

            2. (Call_action_partial_ok: TC |- parameterTypeIR* @ [] : parameterTypeIR_data* , parameterTypeIR_control* @ argumentIR*)

            3. If ((argumentIR* matches pattern [])), then

              1. (Let TBLC_1 be $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*, []))

              2. (Let tableActionIR be (annotationList (prefixedNameIR ( [] )) ;))

              3. Result in TBLC_1, tableActionIR

  }

  prefixedNonTypeName-argumentList: TC TBLC_0 |- annotationList tableActionReference ; : % % {

    1. If ((tableActionReference matches pattern `%(%)`)), then

      1. (Let (prefixedNonTypeName ( argumentList )) be tableActionReference)

      2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

      3. (Let routineTypeDefIR'? be $find_routine_non_overloaded((local), TC, prefixedNameIR))

      4. If ((routineTypeDefIR'? matches pattern (_))), then

        1. (Let ?(routineTypeDefIR) be routineTypeDefIR'?)

        2. If ((routineTypeDefIR has type functionTypeIR)), then

          1. (Let functionTypeIR be (routineTypeDefIR as functionTypeIR))

          2. If ((functionTypeIR matches pattern `ACTION(%)`)), then

            1. (Let (action( parameterTypeIR* )) be functionTypeIR)

            2. (Let argument* be $flatten_argumentList(argumentList))

            3. (Argument_ok: (local) TC |- argument : argumentIR)*

            4. (Call_action_partial_ok: TC |- parameterTypeIR* @ argumentIR* : parameterTypeIR_data* , parameterTypeIR_control* @ argumentIR_cast*)

            5. (Let TBLC_1 be $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*, argumentIR_cast*))

            6. (Let tableActionIR be (annotationList (prefixedNameIR ( argumentIR_cast* )) ;))

            7. Result in TBLC_1, tableActionIR

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:198.1-200.23
relation TableActions_ok: 

  nil: TC TBLC |- tableAction*{tableAction <- tableAction*} : % % {

    1. If ((tableAction* matches pattern [])), then

      1. Result in TBLC, []

  }

  cons: TC TBLC_0 |- tableAction*{tableAction <- tableAction*} : % % {

    1. If ((tableAction* matches pattern _ :: _)), then

      1. (Let tableAction_h :: tableAction_t* be tableAction*)

      2. (TableAction_ok: TC TBLC_0 |- tableAction_h : TBLC_1 tableActionIR_h)

      3. (TableActions_ok: TC TBLC_1 |- tableAction_t* : TBLC_2 tableActionIR_t*)

      4. Result in TBLC_2, tableActionIR_h :: tableActionIR_t*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:202.1-205.23
relation Call_action_default_ok: 

  : TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : % , % @ % {

    1. (Let (parameterTypeIR_data*, parameterTypeIR_control*) be $split_dataplane_parameters(parameterTypeIR*))

    2. (Call_convention_ok: (local) TC (action) |- parameterTypeIR* @ argumentIR* : argumentIR_cast*)

    3. Result in parameterTypeIR_data*, parameterTypeIR_control*, argumentIR_cast*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:207.1-209.23
relation TableDefaultAction_ok: 

  prefixedNonTypeName: TC TBLC |- = expression : % {

    1. If ((expression has type prefixedNonTypeName)), then

      1. (Let prefixedNonTypeName be (expression as prefixedNonTypeName))

      2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

      3. If ((?(([], [])) = $find_action(TBLC, prefixedNameIR))), then

        1. Result in (prefixedNameIR ( [] ))

  }

  prefixedNonTypeName-argumentList: TC TBLC |- = expression : % {

    1. If ((expression has type callExpression)), then

      1. (Let callExpression be (expression as callExpression))

      2. If ((callExpression matches pattern `%(%)`)), then

        1. (Let (callTarget ( argumentList )) be callExpression)

        2. If ((callTarget has type prefixedNonTypeName)), then

          1. (Let prefixedNonTypeName be (callTarget as prefixedNonTypeName))

          2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

          3. (Let (parameterTypeIR*, argumentListIR)? be $find_action(TBLC, prefixedNameIR))

          4. If (((parameterTypeIR*, argumentListIR)? matches pattern (_))), then

            1. (Let ?((parameterTypeIR_action*, argumentIR_action*)) be (parameterTypeIR*, argumentListIR)?)

            2. (Let argument* be $flatten_argumentList(argumentList))

            3. (Argument_ok: (local) TC |- argument : argumentIR)*

            4. (Call_action_default_ok: TC |- parameterTypeIR_action* @ argumentIR* : parameterTypeIR_action_data* , parameterTypeIR_action_control* @ argumentIR_cast*)

            5. (Let argumentIR_action_data* be argumentIR_action*[0 : |parameterTypeIR_action_data*|])

            6. (Let argumentIR_cast_data* be argumentIR_cast*[0 : |parameterTypeIR_action_data*|])

            7. If ((argumentIR_action_data = argumentIR_cast_data))*, then

              1. Result in (prefixedNameIR ( argumentIR_cast* ))

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:211.1-213.23
relation TableEntry_keyset_ok: 

  simpleKeysetExpression-expression: TC TBLC |- keysetExpression : % % {

    1. If ((keysetExpression has type expression)), then

      1. (Let expression be (keysetExpression as expression))

      2. If ((|TBLC.keys| = 1)), then

        1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression as simpleKeysetExpression)] : TBLS simpleKeysetExpressionIR'*)

        2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

          1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

          2. Result in TBLS, (simpleKeysetExpressionIR as keysetExpressionIR)

  }

  simpleKeysetExpression-mask: TC TBLC |- keysetExpression : % % {

    1. If ((keysetExpression has type simpleKeysetExpression)), then

      1. (Let simpleKeysetExpression be (keysetExpression as simpleKeysetExpression))

      2. If ((simpleKeysetExpression matches pattern `%&&&%`)), then

        1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

        2. If ((|TBLC.keys| = 1)), then

          1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression_l &&& expression_r)] : TBLS simpleKeysetExpressionIR'*)

          2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

            1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

            2. Result in TBLS, (simpleKeysetExpressionIR as keysetExpressionIR)

  }

  simpleKeysetExpression-range: TC TBLC |- keysetExpression : % % {

    1. If ((keysetExpression has type simpleKeysetExpression)), then

      1. (Let simpleKeysetExpression be (keysetExpression as simpleKeysetExpression))

      2. If ((simpleKeysetExpression matches pattern `%..%`)), then

        1. (Let (expression_l .. expression_r) be simpleKeysetExpression)

        2. If ((|TBLC.keys| = 1)), then

          1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression_l .. expression_r)] : TBLS simpleKeysetExpressionIR'*)

          2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

            1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

            2. Result in TBLS, (simpleKeysetExpressionIR as keysetExpressionIR)

  }

  simpleKeysetExpression-default: TC TBLC |- keysetExpression : % % {

    1. If ((keysetExpression = ((default) as keysetExpression))), then

      1. (Let matchMode be TBLC.mode)

      2. If ((matchMode matches pattern `NOPRILPM%`)), then

        1. (Let (noprilpm n) be matchMode)

        2. (Let TBLS be (lpm n))

        3. Result in TBLS, ((default) as keysetExpressionIR)

      3. If ((((TBLC.mode = (nopri)) \/ (TBLC.mode = (pri))) \/ (TBLC.mode = (prilpm)))), then

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((default) as keysetExpressionIR)

  }

  simpleKeysetExpression-dontcare: TC TBLC |- keysetExpression : % % {

    1. If ((keysetExpression = ((_) as keysetExpression))), then

      1. (Let matchMode be TBLC.mode)

      2. If ((matchMode matches pattern `NOPRILPM%`)), then

        1. (Let (noprilpm n) be matchMode)

        2. (Let TBLS be (lpm 0))

        3. Result in TBLS, ((_) as keysetExpressionIR)

      3. If ((((TBLC.mode = (nopri)) \/ (TBLC.mode = (pri))) \/ (TBLC.mode = (prilpm)))), then

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((_) as keysetExpressionIR)

  }

  tupleKeysetExpression-mask: TC TBLC |- keysetExpression : % % {

    1. If ((keysetExpression has type tupleKeysetExpression)), then

      1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

      2. If ((tupleKeysetExpression matches pattern `(%&&&%)`)), then

        1. (Let (( expression_l &&& expression_r )) be tupleKeysetExpression)

        2. If ((|TBLC.keys| = 1)), then

          1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression_l &&& expression_r)] : TBLS simpleKeysetExpressionIR'*)

          2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

            1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

            2. Result in TBLS, ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

  }

  tupleKeysetExpression-range: TC TBLC |- keysetExpression : % % {

    1. If ((keysetExpression has type tupleKeysetExpression)), then

      1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

      2. If ((tupleKeysetExpression matches pattern `(%..%)`)), then

        1. (Let (( expression_l .. expression_r )) be tupleKeysetExpression)

        2. If ((|TBLC.keys| = 1)), then

          1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression_l .. expression_r)] : TBLS simpleKeysetExpressionIR'*)

          2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

            1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

            2. Result in TBLS, ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

  }

  tupleKeysetExpression-default: TC TBLC |- keysetExpression : % % {

    1. If ((keysetExpression = (((default)) as keysetExpression))), then

      1. (Let matchMode be TBLC.mode)

      2. If ((matchMode matches pattern `NOPRILPM%`)), then

        1. (Let (noprilpm n) be matchMode)

        2. (Let TBLS be (lpm n))

        3. Result in TBLS, ((( [(default)] )) as keysetExpressionIR)

      3. If ((((TBLC.mode = (nopri)) \/ (TBLC.mode = (pri))) \/ (TBLC.mode = (prilpm)))), then

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((( [(default)] )) as keysetExpressionIR)

  }

  tupleKeysetExpression-dontcare: TC TBLC |- keysetExpression : % % {

    1. If ((keysetExpression = (((_)) as keysetExpression))), then

      1. (Let matchMode be TBLC.mode)

      2. If ((matchMode matches pattern `NOPRILPM%`)), then

        1. (Let (noprilpm n) be matchMode)

        2. (Let TBLS be (lpm 0))

        3. Result in TBLS, ((( [(_)] )) as keysetExpressionIR)

      3. If ((((TBLC.mode = (nopri)) \/ (TBLC.mode = (pri))) \/ (TBLC.mode = (prilpm)))), then

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((( [(_)] )) as keysetExpressionIR)

  }

  tupleKeysetExpression-list: TC TBLC |- keysetExpression : % % {

    1. If ((keysetExpression has type tupleKeysetExpression)), then

      1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

      2. If ((tupleKeysetExpression matches pattern `(%,%)`)), then

        1. (Let (( simpleKeysetExpression_h , simpleKeysetExpressionList_t )) be tupleKeysetExpression)

        2. (Let simpleKeysetExpression_t* be $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t))

        3. (Let simpleKeysetExpression* be simpleKeysetExpression_h :: simpleKeysetExpression_t*)

        4. If ((|TBLC.keys| = |simpleKeysetExpression*|)), then

          1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ simpleKeysetExpression* : TBLS simpleKeysetExpressionIR*)

          2. Result in TBLS, ((( simpleKeysetExpressionIR* )) as keysetExpressionIR)

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:215.1-217.23
relation TableEntry_action_ok: 

  prefixedNonTypeName: TC TBLC |- tableActionReference : % {

    1. If ((tableActionReference has type prefixedNonTypeName)), then

      1. (Let prefixedNonTypeName be (tableActionReference as prefixedNonTypeName))

      2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

      3. If ((?(([], [])) = $find_action(TBLC, prefixedNameIR))), then

        1. Result in (prefixedNameIR ( [] ))

  }

  prefixedNonTypeName-argumentList: TC TBLC |- tableActionReference : % {

    1. If ((tableActionReference matches pattern `%(%)`)), then

      1. (Let (prefixedNonTypeName ( argumentList )) be tableActionReference)

      2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

      3. (Let (parameterTypeIR*, argumentListIR)? be $find_action(TBLC, prefixedNameIR))

      4. If (((parameterTypeIR*, argumentListIR)? matches pattern (_))), then

        1. (Let ?((parameterTypeIR_action*, argumentIR_action*)) be (parameterTypeIR*, argumentListIR)?)

        2. (Let argument* be $flatten_argumentList(argumentList))

        3. (Argument_ok: (local) TC |- argument : argumentIR)*

        4. (Call_action_default_ok: TC |- parameterTypeIR_action* @ argumentIR* : parameterTypeIR_action_data* , parameterTypeIR_action_control* @ argumentIR_cast*)

        5. (Let argumentIR_action_data* be argumentIR_action*[0 : |parameterTypeIR_action_data*|])

        6. (Let argumentIR_cast_data* be argumentIR_cast*[0 : |parameterTypeIR_action_data*|])

        7. If ((argumentIR_action_data = argumentIR_cast_data))*, then

          1. Result in (prefixedNameIR ( argumentIR_cast* ))

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:219.1-222.26
relation TableEntry_priority_ok: 

  non-specified: TC TBLC' TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : % % {

    1. If ((tableEntryPriority? matches pattern ())), then

      1. If ((TBLC'.mode matches pattern `NOPRI`)), then

        1. Result in TBLC', ?()

      2. (Let matchMode be TBLC'.mode)

      3. If ((matchMode matches pattern `NOPRILPM%`)), then

        1. (Let (noprilpm n) be matchMode)

        2. (Let tableEntryState be TBLS)

        3. If ((tableEntryState matches pattern `LPM%`)), then

          1. (Let (lpm n_prefix) be tableEntryState)

          2. Result in TBLC', ?()

      4. If (((TBLC'.mode = (pri)) \/ (TBLC'.mode = (prilpm)))), then

        1. Case analysis on TBLC'.priorities.values

          1. Case (% = [])

            1. Case analysis on TBLC'.priorities.largest_wins

              1. Case true

                1. (Let n_size be TBLC'.entries.size)

                2. (Let n_delta be TBLC'.priorities.delta)

                3. (Let n be (((n_size - 1) * n_delta) + 1))

                4. (Let TBLC_1 be $add_table_priority(TBLC', n))

                5. Result in TBLC_1, ?((priority= (d (n as int)) :))

              2. Case false

                1. (Let TBLC_1 be $add_table_priority(TBLC', 1))

                2. Result in TBLC_1, ?((priority= (d (1 as int)) :))

          2. Case (% =/= [])

            1. Case analysis on TBLC'.priorities.largest_wins

              1. Case true

                1. (Let n_last be $find_table_priority_last(TBLC'))

                2. (Let n_delta be TBLC'.priorities.delta)

                3. (Let n be (n_last - n_delta))

                4. (Let TBLC_1 be $add_table_priority(TBLC', n))

                5. Result in TBLC_1, ?((priority= (d (n as int)) :))

              2. Case false

                1. (Let n_last be $find_table_priority_last(TBLC'))

                2. (Let n_delta be TBLC'.priorities.delta)

                3. (Let n be (n_last + n_delta))

                4. (Let TBLC_1 be $add_table_priority(TBLC', n))

                5. Result in TBLC_1, ?((priority= (d (n as int)) :))

  }

  specified-number: TC TBLC_0 TBLS |- tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} : % % {

    1. If ((tableEntryPriority'? matches pattern (_))), then

      1. (Let ?(tableEntryPriority) be tableEntryPriority'?)

      2. If ((tableEntryPriority matches pattern `PRIORITY=%:`)), then

        1. (Let (priority= numberLiteral :) be tableEntryPriority)

        2. If (((TBLC_0.mode = (pri)) \/ (TBLC_0.mode = (prilpm)))), then

          1. If (~TBLC_0.entries.const), then

            1. Case analysis on TBLC_0.priorities.values

              1. Case (% = [])

                1. (Let int be $to_number((numberLiteral as value)))

                2. If ((int has type nat)), then

                  1. (Let n be (int as nat))

                  2. (Let TBLC_1 be TBLC_0[priorities.init = true])

                  3. (Let TBLC_2 be $add_table_priority(TBLC_1, n))

                  4. Result in TBLC_2, ?((priority= numberLiteral :))

              2. Case (% =/= [])

                1. If (TBLC_0.priorities.init), then

                  1. (Let int be $to_number((numberLiteral as value)))

                  2. If ((int has type nat)), then

                    1. (Let n be (int as nat))

                    2. (Let TBLC_1 be $add_table_priority(TBLC_0, n))

                    3. Result in TBLC_1, ?((priority= numberLiteral :))

  }

  specified-expression: TC TBLC_0 TBLS |- tableEntryPriority'?{tableEntryPriority' <- tableEntryPriority'?} : % % {

    1. If ((tableEntryPriority'? matches pattern (_))), then

      1. (Let ?(tableEntryPriority) be tableEntryPriority'?)

      2. If ((tableEntryPriority matches pattern `PRIORITY=(%):`)), then

        1. (Let (priority=( expression ):) be tableEntryPriority)

        2. If (((TBLC_0.mode = (pri)) \/ (TBLC_0.mode = (prilpm)))), then

          1. If (~TBLC_0.entries.const), then

            1. Case analysis on TBLC_0.priorities.values

              1. Case (% = [])

                1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

                2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR)

                3. If ((ctk matches pattern `LCTK`)), then

                  1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

                  2. (Let int be $to_number(value))

                  3. If ((int has type nat)), then

                    1. (Let n be (int as nat))

                    2. (Let TBLC_1 be TBLC_0[priorities.init = true])

                    3. (Let TBLC_2 be $add_table_priority(TBLC_1, n))

                    4. Result in TBLC_2, ?((priority=( typedExpressionIR ):))

              2. Case (% =/= [])

                1. If (TBLC_0.priorities.init), then

                  1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

                  2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR)

                  3. If ((ctk matches pattern `LCTK`)), then

                    1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

                    2. (Let int be $to_number(value))

                    3. If ((int has type nat)), then

                      1. (Let n be (int as nat))

                      2. (Let TBLC_1 be $add_table_priority(TBLC_0, n))

                      3. Result in TBLC_1, ?((priority=( typedExpressionIR ):))

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:224.1-226.23
relation TableEntry_ok: 

  priority: TC TBLC_0 |- tableEntry : % % {

    1. If ((tableEntry matches pattern `%%%:%%;`)), then

      1. (Let (constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ;) be tableEntry)

      2. (TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR)

      3. (TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR)

      4. (TableEntry_priority_ok: TC TBLC_0 TBLS |- ?(tableEntryPriority) : TBLC_1 tableEntryPriorityOptIR)

      5. (Let constOptIR be $flatten_constOpt(constOpt))

      6. (Let tableEntryIR be (constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;))

      7. Result in TBLC_1, tableEntryIR

  }

  non-priority: TC TBLC_0 |- tableEntry : % % {

    1. If ((tableEntry matches pattern `%%:%%;`)), then

      1. (Let (constOpt keysetExpression : tableActionReference annotationList ;) be tableEntry)

      2. (TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR)

      3. (TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR)

      4. (TableEntry_priority_ok: TC TBLC_0 TBLS |- ?() : TBLC_1 tableEntryPriorityOptIR)

      5. (Let constOptIR be $flatten_constOpt(constOpt))

      6. (Let tableEntryIR be (constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;))

      7. Result in TBLC_1, tableEntryIR

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:228.1-230.23
relation TableEntries_ok: 

  nil: TC TBLC |- tableEntry*{tableEntry <- tableEntry*} : % % {

    1. If ((tableEntry* matches pattern [])), then

      1. Result in TBLC, []

  }

  cons: TC TBLC_0 |- tableEntry*{tableEntry <- tableEntry*} : % % {

    1. If ((tableEntry* matches pattern _ :: _)), then

      1. (Let tableEntry_h :: tableEntry_t* be tableEntry*)

      2. (TableEntry_ok: TC TBLC_0 |- tableEntry_h : TBLC_1 tableEntryIR_h)

      3. (TableEntries_ok: TC TBLC_1 |- tableEntry_t* : TBLC_2 tableEntryIR_t*)

      4. Result in TBLC_2, tableEntryIR_h :: tableEntryIR_t*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:232.1-234.23
relation TableProperty_ok: 

  key: TC TBLC_0 |- tableProperty : % % {

    1. If ((tableProperty matches pattern `KEY={%}`)), then

      1. (Let (key={ tableKeyList }) be tableProperty)

      2. (Let tableKey* be $flatten_tableKeyList(tableKeyList))

      3. (TableKeys_ok: TC TBLC_0 |- tableKey* : TBLC_1 tableKeyIR*)

      4. Result in TBLC_1, (key={ tableKeyIR* })

  }

  actions: TC TBLC_0 |- tableProperty : % % {

    1. If ((tableProperty matches pattern `ACTIONS={%}`)), then

      1. (Let (actions={ tableActionList }) be tableProperty)

      2. (Let tableAction* be $flatten_tableActionList(tableActionList))

      3. (TableActions_ok: TC TBLC_0 |- tableAction* : TBLC_1 tableActionIR*)

      4. Result in TBLC_1, (actions={ tableActionIR* })

  }

  entries: TC TBLC_0 |- tableProperty : % % {

    1. If ((tableProperty matches pattern `%%ENTRIES={%}`)), then

      1. (Let (annotationList constOpt entries={ tableEntryList }) be tableProperty)

      2. (Let tableEntry* be $flatten_tableEntryList(tableEntryList))

      3. If (((|TBLC_0.keys| = 0) => (|tableEntry*| = 0))), then

        1. (Let TBLC_1 be TBLC_0[entries.size = |tableEntry*|])

        2. (Let constOptIR be $flatten_constOpt(constOpt))

        3. (Let TBLC_2 be TBLC_1[entries.const = (constOptIR = ?((const)))])

        4. (TableEntries_ok: TC TBLC_2 |- tableEntry* : TBLC_3 tableEntryIR*)

        5. Result in TBLC_3, (annotationList constOptIR entries={ tableEntryIR* })

  }

  default-action: TC TBLC |- tableProperty : % % {

    1. If ((tableProperty matches pattern `%%%%;`)), then

      1. (Let (annotationList constOpt tableCustomName initializer ;) be tableProperty)

      2. If (("default_action" = $tableCustomName(tableCustomName))), then

        1. (TableDefaultAction_ok: TC TBLC |- initializer : tableActionReferenceIR)

        2. (Let constOptIR be $flatten_constOpt(constOpt))

        3. (Let tablePropertyIR be (annotationList constOptIR default_action= tableActionReferenceIR ;))

        4. Result in TBLC, tablePropertyIR

  }

  custom: TC TBLC' |- tableProperty : % % {

    1. If ((tableProperty matches pattern `%%%%;`)), then

      1. (Let (annotationList constOpt tableCustomName (= expression) ;) be tableProperty)

      2. If (("size" = $tableCustomName(tableCustomName))), then

        1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

        2. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

        3. If ((($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))), then

          1. (Let constOptIR be $flatten_constOpt(constOpt))

          2. (Let tablePropertyIR be (annotationList constOptIR custom "size" (= typedExpressionIR) ;))

          3. Result in TBLC', tablePropertyIR

      3. If (("largest_priority_wins" = $tableCustomName(tableCustomName))), then

        1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

        2. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

        3. If ((typeIR = ((bool) as typeIR))), then

          1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

          2. If ((value has type primitiveValue)), then

            1. (Let primitiveValue be (value as primitiveValue))

            2. If ((primitiveValue matches pattern `B%`)), then

              1. (Let (b b_largest_priority_wins) be primitiveValue)

              2. (Let TBLC_1 be TBLC'[priorities.largest_wins = b_largest_priority_wins])

              3. (Let constOptIR be $flatten_constOpt(constOpt))

              4. (Let tablePropertyIR be (annotationList constOptIR custom_const "largest_priority_wins" (= ((b b_largest_priority_wins) as value)) ;))

              5. Result in TBLC_1, tablePropertyIR

      4. If (("priority_delta" = $tableCustomName(tableCustomName))), then

        1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

        2. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

        3. If ((($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))), then

          1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

          2. (Let int be $to_number(value))

          3. If ((int has type nat)), then

            1. (Let n_delta be (int as nat))

            2. If ((n_delta > 0)), then

              1. (Let TBLC_1 be TBLC'[priorities.delta = n_delta])

              2. (Let constOptIR be $flatten_constOpt(constOpt))

              3. (Let tablePropertyIR be (annotationList constOptIR custom_const "priority_delta" (= ((d (n_delta as int)) as value)) ;))

              4. Result in TBLC_1, tablePropertyIR

      5. (Let nameIR be $tableCustomName(tableCustomName))

      6. If ((((nameIR =/= "size") /\ (nameIR =/= "largest_priority_wins")) /\ (nameIR =/= "priority_delta"))), then

        1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

        2. (Let constOptIR be $flatten_constOpt(constOpt))

        3. (Let tablePropertyIR be (annotationList constOptIR custom nameIR (= typedExpressionIR) ;))

        4. Result in TBLC', tablePropertyIR

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:236.1-238.23
relation TableProperties_ok: 

  nil: TC TBLC |- tableProperty*{tableProperty <- tableProperty*} : % % {

    1. If ((tableProperty* matches pattern [])), then

      1. Result in TBLC, []

  }

  cons: TC TBLC_0 |- tableProperty*{tableProperty <- tableProperty*} : % % {

    1. If ((tableProperty* matches pattern _ :: _)), then

      1. (Let tableProperty_h :: tableProperty_t* be tableProperty*)

      2. (TableProperty_ok: TC TBLC_0 |- tableProperty_h : TBLC_1 tablePropertyIR_h)

      3. (TableProperties_ok: TC TBLC_1 |- tableProperty_t* : TBLC_2 tablePropertyIR_t*)

      4. Result in TBLC_2, tablePropertyIR_h :: tablePropertyIR_t*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:240.1-242.20
relation Table_ok: 

  : TC |- tableProperty*{tableProperty <- tableProperty*} : % % {

    1. If (($count_table_keys(tableProperty*) <= 1)), then

      1. If (($count_table_actions(tableProperty*) = 1)), then

        1. (Let TBLC_0 be $empty_tableContext)

        2. (TableProperties_ok: TC TBLC_0 |- tableProperty* : TBLC_1 tablePropertyIR*)

        3. Result in TBLC_1, tablePropertyIR*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:244.1-246.23
relation TableType_ok: 

  : TC_0 TBLC |- name : % % {

    1. (Let nameIR be $name(name))

    2. (Let tid_enum be "action_list(" ++ nameIR ++ ")")

    3. (Let (prefixedNameIR_action, _parameterTypeIR*, _argumentListIR)* be TBLC.actions)

    4. (Let id_enum_field be $flatten_prefixedNameIR(prefixedNameIR_action))*

    5. (Let typeIR_table_enum be ((table_enum tid_enum { id_enum_field* }) as typeIR))

    6. (Let value_enum_field be ((table_enum tid_enum . id_enum_field) as value))*

    7. (Let varTypeIR_enum_field be (() typeIR_table_enum (lctk) ?(value_enum_field)))*

    8. (Let TC_1 be $add_vars((block), TC_0, tid_enum ++ "." ++ id_enum_field*, varTypeIR_enum_field*))

    9. (Let tid_struct be "apply_result(" ++ nameIR ++ ")")

    10. (Let typeIR_table_struct be ((table_struct tid_struct { [(((bool) as typeIR) "hit" ;), (((bool) as typeIR) "miss" ;), (typeIR_table_enum "action_run" ;)] }) as typeIR))

    11. (Let typeIR_table be ((table nameIR # typeIR_table_struct) as typeIR))

    12. Result in TC_1, typeIR_table

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:248.1-251.20
relation ControlLocalDecl_ok: 

  constantDeclaration: TC_0 |- controlLocalDeclaration : % % {

    1. If ((controlLocalDeclaration has type constantDeclaration)), then

      1. (Let constantDeclaration be (controlLocalDeclaration as constantDeclaration))

      2. (Decl_ok: (block) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

      3. If ((declarationIR has type constantDeclarationIR)), then

        1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

        2. Result in TC_1, (constantDeclarationIR as controlLocalDeclarationIR)

  }

  instantiation: TC_0 |- controlLocalDeclaration : % % {

    1. If ((controlLocalDeclaration has type instantiation)), then

      1. (Let instantiation be (controlLocalDeclaration as instantiation))

      2. (Decl_ok: (block) TC_0 |- (instantiation as declaration) : TC_1 declarationIR)

      3. If ((declarationIR has type instantiationIR)), then

        1. (Let instantiationIR be (declarationIR as instantiationIR))

        2. Result in TC_1, (instantiationIR as controlLocalDeclarationIR)

  }

  variableDeclaration: TC_0 |- controlLocalDeclaration : % % {

    1. If ((controlLocalDeclaration has type variableDeclaration)), then

      1. (Let (annotationList type name initializerOpt ;) be (controlLocalDeclaration as variableDeclaration))

      2. If ((initializerOpt matches pattern ``EMPTY`)), then

        1. (Type_ok: (block) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

        2. If ((tid* matches pattern [])), then

          1. If ((Type_wf: $bound((block), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Let nameIR be $name(name))

              2. (Let TC_1 be $add_var((block), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

              3. (Let variableDeclarationIR be (annotationList typeIR nameIR ?() ;))

              4. Result in TC_1, (variableDeclarationIR as controlLocalDeclarationIR)

      3. If ((initializerOpt has type initializer)), then

        1. (Let (= expression_init) be (initializerOpt as initializer))

        2. (Type_ok: (block) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

        3. If ((tid* matches pattern [])), then

          1. If ((Type_wf: $bound((block), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Expr_ok: (block) TC_0 |- expression_init : typedExpressionIR_init)

              2. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

              3. If ((typedExpressionIR? matches pattern (_))), then

                1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

                2. (Let nameIR be $name(name))

                3. (Let TC_1 be $add_var((block), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

                4. (Let variableDeclarationIR be (annotationList typeIR nameIR ?((= typedExpressionIR_init_cast)) ;))

                5. Result in TC_1, (variableDeclarationIR as controlLocalDeclarationIR)

  }

  actionDeclaration: TC_0 |- controlLocalDeclaration : % % {

    1. If ((controlLocalDeclaration has type actionDeclaration)), then

      1. (Let actionDeclaration be (controlLocalDeclaration as actionDeclaration))

      2. (Decl_ok: (block) TC_0 |- (actionDeclaration as declaration) : TC_1 declarationIR)

      3. If ((declarationIR has type actionDeclarationIR)), then

        1. (Let actionDeclarationIR be (declarationIR as actionDeclarationIR))

        2. Result in TC_1, (actionDeclarationIR as controlLocalDeclarationIR)

  }

  tableDeclaration: TC_0 |- controlLocalDeclaration : % % {

    1. If ((controlLocalDeclaration has type tableDeclaration)), then

      1. (Let (annotationList table name { tablePropertyList }) be (controlLocalDeclaration as tableDeclaration))

      2. (Let TC_1 be TC_0[local.kind = (table_apply_method)])

      3. (Let tableProperty* be $flatten_tablePropertyList(tablePropertyList))

      4. (Table_ok: TC_1 |- tableProperty* : TBLC tablePropertyIR*)

      5. (Let nameIR be $name(name))

      6. (TableType_ok: TC_1 TBLC |- name : TC_2 typeIR_table)

      7. (Let TC_3 be $add_var((block), TC_2, nameIR, (() typeIR_table (dyn) ?())))

      8. (Let tableDeclarationIR be (annotationList table typeIR_table nameIR { tablePropertyIR* }))

      9. Result in TC_3, (tableDeclarationIR as controlLocalDeclarationIR)

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:253.1-256.20
relation ControlLocalDecls_ok: 

  nil: TC |- controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} : % % {

    1. If ((controlLocalDeclaration* matches pattern [])), then

      1. Result in TC, []

  }

  cons: TC_0 |- controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} : % % {

    1. If ((controlLocalDeclaration* matches pattern _ :: _)), then

      1. (Let controlLocalDeclaration_h :: controlLocalDeclaration_t* be controlLocalDeclaration*)

      2. (ControlLocalDecl_ok: TC_0 |- controlLocalDeclaration_h : TC_1 controlLocalDeclarationIR_h)

      3. (ControlLocalDecls_ok: TC_1 |- controlLocalDeclaration_t* : TC_2 controlLocalDeclarationIR_t*)

      4. Result in TC_2, controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:262.1-264.23
relation Decl_ok: 

  constantDeclaration: p TC_0 |- declaration : % % {

    1. If ((declaration has type constantDeclaration)), then

      1. (Let (annotationList const type name (= expression_value) ;) be (declaration as constantDeclaration))

      2. (Type_ok: p TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      3. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound(p, TC_0) |- typeIR holds)), then

          1. (Expr_ok: p TC_0 |- expression_value : typedExpressionIR_value)

          2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR_value)

          3. If ((ctk matches pattern `LCTK`)), then

            1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_value, typeIR))

            2. If ((typedExpressionIR? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_value_cast) be typedExpressionIR?)

              2. (Eval_static: p TC_0 |- typedExpressionIR_value_cast ~> value)

              3. (Let nameIR be $name(name))

              4. (Let TC_1 be $add_var(p, TC_0, nameIR, (() typeIR (lctk) ?(value))))

              5. (Let constantDeclarationIR be (annotationList const typeIR nameIR (= value) ;))

              6. Result in TC_1, (constantDeclarationIR as declarationIR)

  }

  instantiation-non-objectInitializer: p TC_0 |- declaration : % % {

    1. If ((declaration has type instantiation)), then

      1. (Let instantiation be (declaration as instantiation))

      2. If ((instantiation matches pattern `%%(%)%;`)), then

        1. (Let (annotationList type ( argumentList ) name ;) be instantiation)

        2. Case analysis on type

          1. Case (% has type prefixedTypeName)

            1. (Let prefixedTypeName be (type as prefixedTypeName))

            2. (Let argument* be $flatten_argumentList(argumentList))

            3. (Argument_ok: p TC_0 |- argument : argumentIR)*

            4. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

            5. (ConstructorType_ok: p TC_0 |- prefixedNameIR < [] >( argumentIR* ): constructorTypeIR <# tid_impl* >(# id_default* ))

            6. (Inst_ok: p TC_0 (named) |- constructorTypeIR < [] # tid_impl* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

            7. (Let nameIR be $name(name))

            8. (Let TC_1 be $add_var(p, TC_0, nameIR, (() typeIR_object (ctk) ?())))

            9. (Let instantiationIR be (annotationList prefixedNameIR < typeArgumentIR_inferred* >( argumentIR* ) nameIR ?() ;))

            10. Result in TC_1, (instantiationIR as declarationIR)

          2. Case (% has type specializedType)

            1. (Let (prefixedTypeName < typeArgumentList >) be (type as specializedType))

            2. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

            3. (TypeArguments_ok: p TC_0 |- typeArgument* : typeArgumentIR* # tid_impl*)

            4. (Let argument* be $flatten_argumentList(argumentList))

            5. (Argument_ok: p TC_0 |- argument : argumentIR)*

            6. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

            7. (ConstructorType_ok: p TC_0 |- prefixedNameIR < typeArgumentIR* >( argumentIR* ): constructorTypeIR <# tid_inserted* >(# id_default* ))

            8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

            9. (Inst_ok: p TC_0 (named) |- constructorTypeIR < typeArgumentIR* # tid_infer* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

            10. (Let nameIR be $name(name))

            11. (Let TC_1 be $add_var(p, TC_0, nameIR, (() typeIR_object (ctk) ?())))

            12. (Let instantiationIR be (annotationList prefixedNameIR < typeArgumentIR_inferred* >( argumentIR* ) nameIR ?() ;))

            13. Result in TC_1, (instantiationIR as declarationIR)

  }

  instantiation-objectInitializer: p TC_0 |- declaration : % % {

    1. If ((declaration has type instantiation)), then

      1. (Let instantiation be (declaration as instantiation))

      2. If ((instantiation matches pattern `%%(%)%%;`)), then

        1. (Let (annotationList type ( argumentList ) name (={ objectDeclarationList }) ;) be instantiation)

        2. Case analysis on type

          1. Case (% has type prefixedTypeName)

            1. (Let prefixedTypeName be (type as prefixedTypeName))

            2. (Let argument* be $flatten_argumentList(argumentList))

            3. (Argument_ok: p TC_0 |- argument : argumentIR)*

            4. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

            5. (ConstructorType_ok: p TC_0 |- prefixedNameIR < [] >( argumentIR* ): constructorTypeIR <# tid_impl* >(# id_default* ))

            6. (Inst_ok: p TC_0 (named) |- constructorTypeIR < [] # tid_impl* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

            7. If ($is_extern_object_typeIR($canon(typeIR_object))), then

              1. (Let typeIR' be typeIR_object)

              2. If ((typeIR' has type namedTypeIR)), then

                1. (Let namedTypeIR be (typeIR' as namedTypeIR))

                2. If ((namedTypeIR matches pattern `%<%>`)), then

                  1. (Let ((typeIR < tid_expl* , tid'* >) < typeIR_arg* >) be namedTypeIR)

                  2. If ((typeIR has type externObjectTypeIR)), then

                    1. (Let (extern tid_extern rdenv_extern) be (typeIR as externObjectTypeIR))

                    2. If ((tid'* = tid_impl*)), then

                      1. (Let TC_1 be $add_var((local), TC_0, "this", (() typeIR_object (ctk) ?())))

                      2. (Let objectDeclaration* be $flatten_objectDeclarationList(objectDeclarationList))

                      3. (Decls_object_ok: p TC_1 ({ [] }) ({ [] }) |- objectDeclaration* : frame_init rdenv_init objectDeclarationIR*)

                      4. (Let tid* be tid_expl* ++ tid_impl*)

                      5. (Let theta be ({ (tid : typeIR_arg)* }))

                      6. (Let rdenv_init_subst be $subst_rdenv(theta, rdenv_extern, rdenv_init))

                      7. (Let typeIR_object_init be (((((extern tid_extern rdenv_init_subst) as typeIR) < tid_expl* , tid_impl* >) < typeIR_arg* >) as typeIR))

                      8. If ($is_concrete_extern_object(typeIR_object_init)), then

                        1. (Let nameIR be $name(name))

                        2. (Let TC_2 be $add_var(p, TC_0, nameIR, (() typeIR_object_init (ctk) ?())))

                        3. (Let instantiationIR be (annotationList prefixedNameIR < typeArgumentIR_inferred* >( argumentIR* ) nameIR ?((={ objectDeclarationIR* })) ;))

                        4. Result in TC_2, (instantiationIR as declarationIR)

          2. Case (% has type specializedType)

            1. (Let (prefixedTypeName < typeArgumentList >) be (type as specializedType))

            2. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

            3. (TypeArguments_ok: p TC_0 |- typeArgument* : typeArgumentIR* # tid_impl*)

            4. (Let argument* be $flatten_argumentList(argumentList))

            5. (Argument_ok: p TC_0 |- argument : argumentIR)*

            6. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

            7. (ConstructorType_ok: p TC_0 |- prefixedNameIR < typeArgumentIR* >( argumentIR* ): constructorTypeIR <# tid_inserted* >(# id_default* ))

            8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

            9. (Inst_ok: p TC_0 (named) |- constructorTypeIR < typeArgumentIR* # tid_infer* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

            10. If ($is_extern_object_typeIR($canon(typeIR_object))), then

              1. (Let typeIR' be typeIR_object)

              2. If ((typeIR' has type namedTypeIR)), then

                1. (Let namedTypeIR be (typeIR' as namedTypeIR))

                2. If ((namedTypeIR matches pattern `%<%>`)), then

                  1. (Let ((typeIR < tid_expl* , tid'* >) < typeIR_arg* >) be namedTypeIR)

                  2. If ((typeIR has type externObjectTypeIR)), then

                    1. (Let (extern tid_extern rdenv_extern) be (typeIR as externObjectTypeIR))

                    2. If ((tid'* = tid_impl*)), then

                      1. (Let TC_1 be $add_var((local), TC_0, "this", (() typeIR_object (ctk) ?())))

                      2. (Let objectDeclaration* be $flatten_objectDeclarationList(objectDeclarationList))

                      3. (Decls_object_ok: p TC_1 ({ [] }) ({ [] }) |- objectDeclaration* : frame_init rdenv_init objectDeclarationIR*)

                      4. (Let tid* be tid_expl* ++ tid_impl*)

                      5. (Let theta be ({ (tid : typeIR_arg)* }))

                      6. (Let rdenv_init_subst be $subst_rdenv(theta, rdenv_extern, rdenv_init))

                      7. (Let typeIR_object_init be (((((extern tid_extern rdenv_init_subst) as typeIR) < tid_expl* , tid_impl* >) < typeIR_arg* >) as typeIR))

                      8. If ($is_concrete_extern_object(typeIR_object_init)), then

                        1. (Let nameIR be $name(name))

                        2. (Let TC_2 be $add_var(p, TC_0, nameIR, (() typeIR_object_init (ctk) ?())))

                        3. (Let instantiationIR be (annotationList prefixedNameIR < typeArgumentIR_inferred* >( argumentIR* ) nameIR ?((={ objectDeclarationIR* })) ;))

                        4. Result in TC_2, (instantiationIR as declarationIR)

  }

  functionDeclaration: p TC_0 |- declaration : % % {

    1. If ((declaration has type functionDeclaration)), then

      1. (Let (annotationList (typeOrVoid name typeParameterListOpt ( parameterList )) blockStatement) be (declaration as functionDeclaration))

      2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      3. (Let tid_expl be $name(typeParameter))*

      4. (Let TC_1 be $add_types((local), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      5. (Type_ok: (local) TC_1 |- typeOrVoid : typeIR_ret # tid*)

      6. If ((tid* matches pattern [])), then

        1. (Let parameter* be $flatten_parameterList(parameterList))

        2. (Parameters_ok: (local) TC_1 |- parameter* : parameterIR* # tid_impl*)

        3. (Let parameterTypeIR be $parameterIR(parameterIR))*

        4. (Let TC_2 be $add_parameters((local), TC_1, parameterTypeIR*))

        5. (Let TC_3 be TC_2[local.kind = (function-> typeIR_ret)])

        6. (Block_ok: TC_3 (cont) |- blockStatement : _typingContext f blockStatementIR)

        7. If (((f = (ret)) \/ (typeIR_ret = ((void) as typeIR)))), then

          1. (Let rid be $rid(name, parameterList))

          2. (Let functionTypeIR be (function( parameterTypeIR* )-> typeIR_ret))

          3. (Let routineTypeDefIR be (((functionTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

          4. If ((RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds)), then

            1. (Let TC_4 be $add_routine_overload(p, TC_0, rid, routineTypeDefIR))

            2. (Let nameIR be $name(name))

            3. (Let functionDeclarationIR be (annotationList (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) blockStatementIR))

            4. Result in TC_4, (functionDeclarationIR as declarationIR)

  }

  actionDeclaration: p TC_0 |- declaration : % % {

    1. If ((declaration has type actionDeclaration)), then

      1. (Let (annotationList action name ( parameterList ) blockStatement) be (declaration as actionDeclaration))

      2. (Let TC_1 be TC_0[local.kind = (action)])

      3. (Let parameter* be $flatten_parameterList(parameterList))

      4. (Parameters_ok: (local) TC_1 |- parameter* : parameterIR* # tid*)

      5. If ((tid* matches pattern [])), then

        1. (Let parameterTypeIR be $parameterIR(parameterIR))*

        2. (Let TC_2 be $add_parameters((local), TC_1, parameterTypeIR*))

        3. (Block_ok: TC_2 (cont) |- blockStatement : _typingContext _flow blockStatementIR)

        4. (Let rid be $rid(name, parameterList))

        5. (Let functionTypeIR be (action( parameterTypeIR* )))

        6. If ((RoutineTypeDef_wf: $bound(p, TC_0) |- (functionTypeIR as routineTypeDefIR) holds)), then

          1. (Let TC_3 be $add_routine_non_overload(p, TC_0, rid, (functionTypeIR as routineTypeDefIR)))

          2. (Let nameIR be $name(name))

          3. (Let actionDeclarationIR be (annotationList action nameIR ( parameterIR* ) blockStatementIR))

          4. Result in TC_3, (actionDeclarationIR as declarationIR)

  }

  errorDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type errorDeclaration)), then

        1. (Let (error{ nameList }) be (declaration as errorDeclaration))

        2. (Let name* be $flatten_nameList(nameList))

        3. (Let nameIR be $name(name))*

        4. If ($distinct_<nameIR>(nameIR*)), then

          1. (Let nameIR_error be "error." ++ nameIR)*

          2. (Let value_error be ((error. nameIR) as value))*

          3. (Let TC_1 be $add_vars((global), TC_0, nameIR_error*, (() ((error) as typeIR) (lctk) ?(value_error))*))

          4. Result in TC_1, ((error{ nameIR* }) as declarationIR)

  }

  matchKindDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type matchKindDeclaration)), then

        1. (Let (match_kind{ nameList _trailingCommaOpt }) be (declaration as matchKindDeclaration))

        2. (Let name* be $flatten_nameList(nameList))

        3. (Let nameIR be $name(name))*

        4. If ($distinct_<nameIR>(nameIR*)), then

          1. (Let value_match_kind be ((match_kind. nameIR) as value))*

          2. (Let TC_1 be $add_vars((global), TC_0, nameIR*, (() ((match_kind) as typeIR) (lctk) ?(value_match_kind))*))

          3. Result in TC_1, ((match_kind{ nameIR* }) as declarationIR)

  }

  externDeclaration-externFunctionDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type externFunctionDeclaration)), then

        1. (Let (annotationList extern (typeOrVoid name typeParameterListOpt ( parameterList )) ;) be (declaration as externFunctionDeclaration))

        2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

        3. (Let tid_expl be $name(typeParameter))*

        4. (Let TC_1 be $add_types((local), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

        5. (Type_ok: (local) TC_1 |- typeOrVoid : typeIR_ret # tid*)

        6. If ((tid* matches pattern [])), then

          1. (Let TC_2 be TC_1[local.kind = (extern_function-> typeIR_ret)])

          2. (Let parameter* be $flatten_parameterList(parameterList))

          3. (Parameters_ok: (local) TC_2 |- parameter* : parameterIR* # tid_impl*)

          4. (Let parameterTypeIR be $parameterIR(parameterIR))*

          5. (Let TC_3 be $add_parameters((local), TC_2, parameterTypeIR*))

          6. (Let rid be $rid(name, parameterList))

          7. (Let functionTypeIR be (extern_function( parameterTypeIR* )-> typeIR_ret))

          8. (Let routineTypeDefIR be (((functionTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

          9. If ((RoutineTypeDef_wf: $bound((global), TC_0) |- routineTypeDefIR holds)), then

            1. (Let TC_4 be $add_routine_overload((global), TC_0, rid, routineTypeDefIR))

            2. (Let nameIR be $name(name))

            3. (Let externFunctionDeclarationIR be (annotationList extern (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) ;))

            4. Result in TC_4, (externFunctionDeclarationIR as declarationIR)

  }

  externDeclaration-externObjectDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type externObjectDeclaration)), then

        1. (Let (annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }) be (declaration as externObjectDeclaration))

        2. (Let methodPrototype* be $flatten_methodPrototypeList(methodPrototypeList))

        3. (Let (methodPrototype_constructor*, methodPrototype_method*) be $split_constructors(methodPrototype*))

        4. (Let TC_1 be TC_0[block.kind = (extern)])

        5. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

        6. (Let tid_expl be $name(typeParameter))*

        7. (Let TC_2 be $add_types((block), TC_1, tid_expl*, ((tid tid_expl) as typeDefIR)*))

        8. (Let nameIR be $name((nonTypeName as name)))

        9. (ExternMethods_ok: TC_2 nameIR |- methodPrototype_method* : TC_3 methodPrototypeIR_method*)

        10. (Let typeIR_extern be ((extern nameIR TC_3.block.rdenv) as typeIR))

        11. (Let typeDefIR_extern be ((typeIR_extern < tid_expl* , [] >) as typeDefIR))

        12. (Let TC_4 be $add_type((global), TC_0, nameIR, typeDefIR_extern))

        13. (Let TC_5 be TC_4[block.kind = (extern)])

        14. (Let TC_6 be $add_types((block), TC_5, tid_expl*, ((tid tid_expl) as typeDefIR)*))

        15. (ExternConstructors_ok: TC_6 nameIR |- methodPrototype_constructor* : TC_7 methodPrototypeIR_constructor*)

        16. (Let TC_8 be TC_4[global.cdenv = TC_7.global.cdenv])

        17. (Let externObjectDeclarationIR be (annotationList extern nameIR < tid_expl* , [] >{ methodPrototypeIR_constructor* ++ methodPrototypeIR_method* }))

        18. Result in TC_8, (externObjectDeclarationIR as declarationIR)

  }

  parserDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type parserDeclaration)), then

        1. (Let (annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }) be (declaration as parserDeclaration))

        2. If ((typeParameterListOpt matches pattern ``EMPTY`)), then

          1. (Let TC_1 be TC_0[block.kind = (parser)])

          2. (Let constructorParameter* be $flatten_constructorParameterListOpt(constructorParameterListOpt))

          3. (ConstructorParameters_ok: (block) TC_1 |- constructorParameter* : constructorParameterIR* # tid*)

          4. If ((tid* matches pattern [])), then

            1. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*

            2. (Let TC_2 be $add_parameters((block), TC_1, constructorParameterTypeIR*))

            3. (Let parameter* be $flatten_parameterList(parameterList))

            4. (Parameters_ok: (block) TC_2 |- parameter* : parameterIR* # tid'*)

            5. If ((tid'* matches pattern [])), then

              1. (Let parameterTypeIR be $parameterIR(parameterIR))*

              2. (Let TC_3 be $add_parameters((block), TC_2, parameterTypeIR*))

              3. (Let parserLocalDeclaration* be $flatten_parserLocalDeclarationList(parserLocalDeclarationList))

              4. (ParserLocalDecls_ok: TC_3 |- parserLocalDeclaration* : TC_4 parserLocalDeclarationIR*)

              5. (Let TC_5 be TC_4[local.kind = (parser_state)])

              6. (Let parserState* be $flatten_parserStateList(parserStateList))

              7. (ParserStates_ok: TC_5 |- parserState* : parserStateIR*)

              8. (Let methodTypeIR be (parser_apply( parameterTypeIR* )))

              9. If ((RoutineTypeDef_wf: $bound((global), TC_0) |- (methodTypeIR as routineTypeDefIR) holds)), then

                1. (Let cid be $cid(name, constructorParameterListOpt))

                2. (Let typeIR_parser be ((parser( parameterTypeIR* )) as typeIR))

                3. (Let typeIR_parser_spec be (((typeIR_parser < [] , [] >) < [] >) as typeIR))

                4. (Let constructorTypeIR be (constructor( constructorParameterTypeIR* )-> typeIR_parser_spec))

                5. (Let constructorTypeDefIR be (constructorTypeIR < [] , [] >))

                6. If ((ConstructorTypeDef_wf: $bound((global), TC_0) |- constructorTypeDefIR holds)), then

                  1. (Let TC_6 be $add_constructor(TC_0, cid, constructorTypeDefIR))

                  2. (Let nameIR be $name(name))

                  3. (Let parserDeclarationIR be (annotationList parser nameIR < [] >( parameterIR* )( constructorParameterIR* ){ parserLocalDeclarationIR* parserStateIR* }))

                  4. Result in TC_6, (parserDeclarationIR as declarationIR)

  }

  controlDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type controlDeclaration)), then

        1. (Let (annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }) be (declaration as controlDeclaration))

        2. If ((typeParameterListOpt matches pattern ``EMPTY`)), then

          1. (Let TC_1 be TC_0[block.kind = (control)])

          2. (Let constructorParameter* be $flatten_constructorParameterListOpt(constructorParameterListOpt))

          3. (ConstructorParameters_ok: (block) TC_1 |- constructorParameter* : constructorParameterIR* # tid*)

          4. If ((tid* matches pattern [])), then

            1. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*

            2. (Let TC_2 be $add_parameters((block), TC_1, constructorParameterTypeIR*))

            3. (Let parameter* be $flatten_parameterList(parameterList))

            4. (Parameters_ok: (block) TC_2 |- parameter* : parameterIR* # tid'*)

            5. If ((tid'* matches pattern [])), then

              1. (Let parameterTypeIR be $parameterIR(parameterIR))*

              2. (Let TC_3 be $add_parameters((block), TC_2, parameterTypeIR*))

              3. (Let controlLocalDeclaration* be $flatten_controlLocalDeclarationList(controlLocalDeclarationList))

              4. (ControlLocalDecls_ok: TC_3 |- controlLocalDeclaration* : TC_4 controlLocalDeclarationIR*)

              5. (Let TC_5 be TC_4[local.kind = (control_apply_method)])

              6. (Block_ok: TC_5 (cont) |- controlBody : _typingContext _flow controlBodyIR)

              7. (Let methodTypeIR be (control_apply( parameterTypeIR* )))

              8. If ((RoutineTypeDef_wf: $bound((global), TC_0) |- (methodTypeIR as routineTypeDefIR) holds)), then

                1. (Let cid be $cid(name, constructorParameterListOpt))

                2. (Let typeIR_control be ((control( parameterTypeIR* )) as typeIR))

                3. (Let typeIR_control_spec be (((typeIR_control < [] , [] >) < [] >) as typeIR))

                4. (Let constructorTypeIR be (constructor( constructorParameterTypeIR* )-> typeIR_control_spec))

                5. (Let constructorTypeDefIR be (constructorTypeIR < [] , [] >))

                6. If ((ConstructorTypeDef_wf: $bound((global), TC_0) |- constructorTypeDefIR holds)), then

                  1. (Let TC_6 be $add_constructor(TC_0, cid, constructorTypeDefIR))

                  2. (Let nameIR be $name(name))

                  3. (Let controlDeclarationIR be (annotationList control nameIR < [] >( parameterIR* )( constructorParameterIR* ){ controlLocalDeclarationIR* apply controlBodyIR }))

                  4. Result in TC_6, (controlDeclarationIR as declarationIR)

  }

  typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type enumTypeDeclaration)), then

        1. (Let enumTypeDeclaration be (declaration as enumTypeDeclaration))

        2. If ((enumTypeDeclaration matches pattern `%ENUM%{%%}`)), then

          1. (Let (annotationList enum name { nameList_field _trailingCommaOpt }) be enumTypeDeclaration)

          2. (Let nameIR be $name(name))

          3. (Let name_field* be $flatten_nameList(nameList_field))

          4. (Let nameIR_field be $name(name_field))*

          5. (Let typeIR_enum be ((enum nameIR { nameIR_field* }) as typeIR))

          6. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_enum as typeDefIR) holds)), then

            1. (Let TC_1 be $add_type((global), TC_0, nameIR, (typeIR_enum as typeDefIR)))

            2. (Let id_field be nameIR ++ "." ++ nameIR_field)*

            3. (Let value_field be ((nameIR . nameIR_field) as value))*

            4. (Let TC_2 be $add_vars((global), TC_1, id_field*, (() typeIR_enum (lctk) ?(value_field))*))

            5. (Let enumTypeDeclarationIR be (annotationList enum nameIR { nameIR_field* }))

            6. Result in TC_2, (enumTypeDeclarationIR as declarationIR)

  }

  typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration-serializable: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type enumTypeDeclaration)), then

        1. (Let enumTypeDeclaration be (declaration as enumTypeDeclaration))

        2. If ((enumTypeDeclaration matches pattern `%ENUM%%{%%}`)), then

          1. (Let (annotationList enum type name { namedExpressionList_field _trailingCommaOpt }) be enumTypeDeclaration)

          2. (Type_ok: (global) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

          3. If ((tid* matches pattern [])), then

            1. If ((Type_wf: $bound((global), TC_0) |- typeIR holds)), then

              1. (Let nameIR be $name(name))

              2. (Let namedExpression_field* be $flatten_namedExpressionList(namedExpressionList_field))

              3. (Enum_serializable_fields_ok: TC_0 nameIR typeIR |- namedExpression_field* : TC_1 namedExpressionIR_field* # value_field*)

              4. (Let (nameIR_field = _typedExpressionIR) be namedExpressionIR_field)*

              5. (Let id_field be nameIR ++ "." ++ nameIR_field)*

              6. (Let typeIR_enum be ((enum nameIR # typeIR { (nameIR_field = value_field ;)* }) as typeIR))

              7. (Let TC_2 be $add_vars((global), TC_0, id_field*, (() typeIR_enum (lctk) ?(value_field))*))

              8. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_enum as typeDefIR) holds)), then

                1. (Let TC_3 be $add_type((global), TC_2, nameIR, (typeIR_enum as typeDefIR)))

                2. (Let enumTypeDeclarationIR be (annotationList enum typeIR nameIR { namedExpressionIR_field* }))

                3. Result in TC_3, (enumTypeDeclarationIR as declarationIR)

  }

  typeDeclaration-derivedTypeDeclaration-structTypeDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type structTypeDeclaration)), then

        1. (Let (annotationList struct name typeParameterListOpt { typeFieldList }) be (declaration as structTypeDeclaration))

        2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

        3. (Let tid_expl be $name(typeParameter))*

        4. (Let TC_1 be $add_types((block), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

        5. (Let (annotationList_field type_field name_field ;)* be $flatten_typeFieldList(typeFieldList))

        6. (Type_ok: (block) TC_1 |- (type_field as typeOrVoid) : typeIR_field # tid_impl_field*)*

        7. (Let tid_impl* be $concat_<tid>(tid_impl_field**))

        8. (Let nameIR be $name(name))

        9. (Let nameIR_field be $name(name_field))*

        10. (Let typeIR_struct be ((struct nameIR { (typeIR_field nameIR_field ;)* }) as typeIR))

        11. (Let typeDefIR_struct be ((typeIR_struct < tid_expl* , tid_impl* >) as typeDefIR))

        12. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_struct holds)), then

          1. (Let TC_2 be $add_type((global), TC_0, nameIR, typeDefIR_struct))

          2. (Let structTypeDeclarationIR be (annotationList struct nameIR < tid_expl* , tid_impl* >{ (annotationList_field typeIR_field nameIR_field ;)* }))

          3. Result in TC_2, (structTypeDeclarationIR as declarationIR)

  }

  typeDeclaration-derivedTypeDeclaration-headerTypeDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type headerTypeDeclaration)), then

        1. (Let (annotationList header name typeParameterListOpt { typeFieldList }) be (declaration as headerTypeDeclaration))

        2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

        3. (Let tid_expl be $name(typeParameter))*

        4. (Let TC_1 be $add_types((block), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

        5. (Let (annotationList_f type_f name_f ;)* be $flatten_typeFieldList(typeFieldList))

        6. (Type_ok: (block) TC_1 |- (type_f as typeOrVoid) : typeIR_f # tid_impl_f*)*

        7. (Let tid_impl* be $concat_<tid>(tid_impl_f**))

        8. (Let nameIR be $name(name))

        9. (Let nameIR_f be $name(name_f))*

        10. (Let typeIR_header be ((header nameIR { (typeIR_f nameIR_f ;)* }) as typeIR))

        11. (Let typeDefIR_header be ((typeIR_header < tid_expl* , tid_impl* >) as typeDefIR))

        12. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_header holds)), then

          1. (Let TC_2 be $add_type((global), TC_0, nameIR, typeDefIR_header))

          2. (Let headerTypeDeclarationIR be (annotationList header nameIR < tid_expl* , tid_impl* >{ (annotationList_f typeIR_f nameIR_f ;)* }))

          3. Result in TC_2, (headerTypeDeclarationIR as declarationIR)

  }

  typeDeclaration-derivedTypeDeclaration-headerUnionTypeDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type headerUnionTypeDeclaration)), then

        1. (Let (annotationList header_union name typeParameterListOpt { typeFieldList }) be (declaration as headerUnionTypeDeclaration))

        2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

        3. (Let tid_expl be $name(typeParameter))*

        4. (Let TC_1 be $add_types((block), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

        5. (Let (annotationList_f type_f name_f ;)* be $flatten_typeFieldList(typeFieldList))

        6. (Type_ok: (block) TC_1 |- (type_f as typeOrVoid) : typeIR_f # tid_impl_f*)*

        7. (Let tid_impl* be $concat_<tid>(tid_impl_f**))

        8. (Let nameIR be $name(name))

        9. (Let nameIR_f be $name(name_f))*

        10. (Let typeIR_union be ((header_union nameIR { (typeIR_f nameIR_f ;)* }) as typeIR))

        11. (Let typeDefIR_union be ((typeIR_union < tid_expl* , tid_impl* >) as typeDefIR))

        12. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_union holds)), then

          1. (Let TC_2 be $add_type((global), TC_0, nameIR, typeDefIR_union))

          2. (Let headerUnionTypeDeclarationIR be (annotationList header_union nameIR < tid_expl* , tid_impl* >{ (annotationList_f typeIR_f nameIR_f ;)* }))

          3. Result in TC_2, (headerUnionTypeDeclarationIR as declarationIR)

  }

  typeDeclaration-typedefDeclaration-typedef: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type typedefDeclaration)), then

        1. (Let typedefDeclaration be (declaration as typedefDeclaration))

        2. If ((typedefDeclaration matches pattern `%TYPEDEF%%;`)), then

          1. (Let (annotationList typedef typedefType name ;) be typedefDeclaration)

          2. Case analysis on typedefType

            1. Case (% has type type)

              1. (Let type be (typedefType as type))

              2. (Type_ok: (global) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

              3. If ((tid* matches pattern [])), then

                1. If ((Type_wf: $bound((global), TC_0) |- typeIR holds)), then

                  1. (Let nameIR be $name(name))

                  2. (Let typeIR_typedef be ((typedef nameIR typeIR) as typeIR))

                  3. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_typedef as typeDefIR) holds)), then

                    1. (Let TC_1 be $add_type((global), TC_0, nameIR, (typeIR_typedef as typeDefIR)))

                    2. (Let typedefDeclarationIR be (annotationList typedef (typeIR as typedefTypeIR) nameIR ;))

                    3. Result in TC_1, (typedefDeclarationIR as declarationIR)

            2. Case (% has type derivedTypeDeclaration)

              1. (Let derivedTypeDeclaration be (typedefType as derivedTypeDeclaration))

              2. (Decl_ok: (global) TC_0 |- (derivedTypeDeclaration as declaration) : TC_1 declarationIR)

              3. If ((declarationIR has type derivedTypeDeclarationIR)), then

                1. (Let derivedTypeDeclarationIR be (declarationIR as derivedTypeDeclarationIR))

                2. (Let ({ tid'* }) be $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.global.tdenv), $dom_map<tid, typeDefIR>(TC_0.global.tdenv)))

                3. If ((tid'* matches pattern [ _/1 ])), then

                  1. (Let [tid] be tid'*)

                  2. (Let typeDefIR'? be $find_type((global), TC_1, (` tid)))

                  3. If ((typeDefIR'? matches pattern (_))), then

                    1. (Let ?(typeDefIR) be typeDefIR'?)

                    2. Case analysis on typeDefIR

                      1. Case (% has type typeIR)

                        1. (Let typeIR be (typeDefIR as typeIR))

                        2. (Let nameIR be $name(name))

                        3. (Let typeIR_typedef be ((typedef nameIR typeIR) as typeIR))

                        4. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_typedef as typeDefIR) holds)), then

                          1. (Let TC_2 be $add_type((global), TC_0, nameIR, (typeIR_typedef as typeDefIR)))

                          2. (Let typedefDeclarationIR be (annotationList typedef (derivedTypeDeclarationIR as typedefTypeIR) nameIR ;))

                          3. Result in TC_1, (typedefDeclarationIR as declarationIR)

                      2. Case (% has type polyTypeDefIR)

                        1. (Let (typeIR < tid''* , tid'''* >) be (typeDefIR as polyTypeDefIR))

                        2. If ((tid''* matches pattern [])), then

                          1. If ((tid'''* matches pattern [])), then

                            1. (Let nameIR be $name(name))

                            2. (Let typeIR_typedef be ((typedef nameIR (((typeIR < [] , [] >) < [] >) as typeIR)) as typeIR))

                            3. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_typedef as typeDefIR) holds)), then

                              1. (Let TC_2 be $add_type((global), TC_0, nameIR, (typeIR_typedef as typeDefIR)))

                              2. (Let typedefDeclarationIR be (annotationList typedef (derivedTypeDeclarationIR as typedefTypeIR) nameIR ;))

                              3. Result in TC_1, (typedefDeclarationIR as declarationIR)

  }

  typeDeclaration-typedefDeclaration-newtype: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type typedefDeclaration)), then

        1. (Let typedefDeclaration be (declaration as typedefDeclaration))

        2. If ((typedefDeclaration matches pattern `%TYPE%%;`)), then

          1. (Let (annotationList type type name ;) be typedefDeclaration)

          2. (Type_ok: (global) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

          3. If ((tid* matches pattern [])), then

            1. If ((Type_wf: $bound((global), TC_0) |- typeIR holds)), then

              1. (Let nameIR be $name(name))

              2. (Let typeIR_newtype be ((type nameIR typeIR) as typeIR))

              3. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_newtype as typeDefIR) holds)), then

                1. (Let TC_1 be $add_type((global), TC_0, nameIR, (typeIR_newtype as typeDefIR)))

                2. (Let typedefDeclarationIR be (annotationList type typeIR nameIR ;))

                3. Result in TC_1, (typedefDeclarationIR as declarationIR)

  }

  typeDeclaration-parserTypeDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type parserTypeDeclaration)), then

        1. (Let (annotationList parser name typeParameterListOpt ( parameterList );) be (declaration as parserTypeDeclaration))

        2. (Let TC_1 be TC_0[block.kind = (parser)])

        3. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

        4. (Let tid_expl be $name(typeParameter))*

        5. (Let TC_2 be $add_types((block), TC_1, tid_expl*, ((tid tid_expl) as typeDefIR)*))

        6. (Let parameter* be $flatten_parameterList(parameterList))

        7. (Parameters_ok: (block) TC_2 |- parameter* : parameterIR* # tid_impl*)

        8. (Let parameterTypeIR be $parameterIR(parameterIR))*

        9. (Let nameIR be $name(name))

        10. (Let typeIR_parser be ((parser( parameterTypeIR* )) as typeIR))

        11. (Let typeDefIR_parser be ((typeIR_parser < tid_expl* , tid_impl* >) as typeDefIR))

        12. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_parser holds)), then

          1. (Let TC_3 be $add_type((global), TC_0, nameIR, typeDefIR_parser))

          2. (Let parserTypeDeclarationIR be (annotationList parser nameIR < tid_expl* , tid_impl* >( parameterIR* );))

          3. Result in TC_3, (parserTypeDeclarationIR as declarationIR)

  }

  typeDeclaration-controlTypeDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type controlTypeDeclaration)), then

        1. (Let (annotationList control name typeParameterListOpt ( parameterList );) be (declaration as controlTypeDeclaration))

        2. (Let TC_1 be TC_0[block.kind = (control)])

        3. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

        4. (Let tid_expl be $name(typeParameter))*

        5. (Let TC_2 be $add_types((block), TC_1, tid_expl*, ((tid tid_expl) as typeDefIR)*))

        6. (Let parameter* be $flatten_parameterList(parameterList))

        7. (Parameters_ok: (block) TC_2 |- parameter* : parameterIR* # tid_impl*)

        8. (Let parameterTypeIR be $parameterIR(parameterIR))*

        9. (Let nameIR be $name(name))

        10. (Let typeIR_control be ((control( parameterTypeIR* )) as typeIR))

        11. (Let typeDefIR_control be ((typeIR_control < tid_expl* , tid_impl* >) as typeDefIR))

        12. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_control holds)), then

          1. (Let TC_3 be $add_type((global), TC_0, nameIR, typeDefIR_control))

          2. (Let controlTypeDeclarationIR be (annotationList control nameIR < tid_expl* , tid_impl* >( parameterIR* );))

          3. Result in TC_3, (controlTypeDeclarationIR as declarationIR)

  }

  typeDeclaration-packageTypeDeclaration: cursor TC_0 |- declaration : % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type packageTypeDeclaration)), then

        1. (Let (annotationList package name typeParameterListOpt ( parameterList );) be (declaration as packageTypeDeclaration))

        2. (Let TC_1 be TC_0[block.kind = (package)])

        3. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

        4. (Let tid_expl be $name(typeParameter))*

        5. (Let TC_2 be $add_types((block), TC_1, tid_expl*, ((tid tid_expl) as typeDefIR)*))

        6. (Let constructorParameter* be $flatten_parameterList(parameterList))

        7. (ConstructorParameters_ok: (block) TC_2 |- constructorParameter* : constructorParameterIR* # tid_impl*)

        8. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*

        9. (Let nameIR be $name(name))

        10. (Let (_direction typeIR_package_inner _id _value?) be constructorParameterTypeIR)*

        11. (Let typeIR_package be ((package< typeIR_package_inner* >) as typeIR))

        12. (Let polyTypeDefIR_package be (typeIR_package < tid_expl* , tid_impl* >))

        13. If ((TypeDef_wf: $bound((global), TC_0) |- (polyTypeDefIR_package as typeDefIR) holds)), then

          1. (Let TC_3 be $add_type((global), TC_0, nameIR, (polyTypeDefIR_package as typeDefIR)))

          2. (Let cid be $cid(name, (( parameterList ))))

          3. (Let typeIR_package_spec be ((polyTypeDefIR_package < ((tid tid_expl) as typeIR)* ++ ((tid tid_impl) as typeIR)* >) as typeIR))

          4. (Let constructorTypeIR be (constructor( constructorParameterTypeIR* )-> typeIR_package_spec))

          5. (Let constructorTypeDefIR be (constructorTypeIR < tid_expl* , tid_impl* >))

          6. If ((ConstructorTypeDef_wf: $bound((global), TC_0) |- constructorTypeDefIR holds)), then

            1. (Let TC_4 be $add_constructor(TC_3, cid, constructorTypeDefIR))

            2. (Let packageTypeDeclarationIR be (annotationList package nameIR < tid_expl* , tid_impl* >( constructorParameterIR* );))

            3. Result in TC_4, (packageTypeDeclarationIR as declarationIR)

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:266.1-268.23
relation Decls_ok: 

  nil: p TC |- declaration*{declaration <- declaration*} : % % {

    1. If ((declaration* matches pattern [])), then

      1. Result in TC, []

  }

  cons: p TC_0 |- declaration*{declaration <- declaration*} : % % {

    1. If ((declaration* matches pattern _ :: _)), then

      1. (Let declaration_h :: declaration_t* be declaration*)

      2. (Decl_ok: p TC_0 |- declaration_h : TC_1 declarationIR_h)

      3. (Decls_ok: p TC_1 |- declaration_t* : TC_2 declarationIR_t*)

      4. Result in TC_2, declarationIR_h :: declarationIR_t*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:270.1-272.17
relation Program_ok: 

  : |- p4program : % % {

    1. (Let declaration* be $flatten_p4program(p4program))

    2. (Let TC_0 be $empty_typingContext)

    3. (Decls_ok: (global) TC_0 |- declaration* : TC_1 declarationIR*)

    4. Result in TC_1, (declarationIR* ;)

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:282.18-282.35
syntax actctxt = 
   | action
   | noaction

;; ../../../../spec-concrete/5.04-typing-relation.watsup:284.1-287.29
relation Call_convention_expr_ok: 

  in: p TC actctxt |- direction typeIR_param _id _value?{_value <- _value?} @ typedExpressionIR_arg : % {

    1. If ((direction matches pattern `IN`)), then

      1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_arg, typeIR_param))

      2. If ((typedExpressionIR? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_arg_cast) be typedExpressionIR?)

        2. Result in typedExpressionIR_arg_cast

  }

  out-inout: p TC actctxt |- direction typeIR_param _id _value?{_value <- _value?} @ typedExpressionIR_arg : % {

    1. Case analysis on direction

      1. Case (% matches pattern `OUT`)

        1. (Let (_expressionIR # (( typeIR_arg _ctk ))) be typedExpressionIR_arg)

        2. If ((Type_alpha: typeIR_param ~~ typeIR_arg holds)), then

          1. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_arg holds)), then

            1. Result in typedExpressionIR_arg

      2. Case (% matches pattern `INOUT`)

        1. (Let (_expressionIR # (( typeIR_arg _ctk ))) be typedExpressionIR_arg)

        2. If ((Type_alpha: typeIR_param ~~ typeIR_arg holds)), then

          1. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_arg holds)), then

            1. Result in typedExpressionIR_arg

  }

  empty: p TC actctxt |- direction typeIR_param _id _value?{_value <- _value?} @ typedExpressionIR_arg : % {

    1. Case analysis on actctxt

      1. Case (% matches pattern `ACTION`)

        1. If ((direction matches pattern ``EMPTY`)), then

          1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_arg, typeIR_param))

          2. If ((typedExpressionIR? matches pattern (_))), then

            1. (Let ?(typedExpressionIR_arg_cast) be typedExpressionIR?)

            2. Result in typedExpressionIR_arg_cast

      2. Case (% matches pattern `NOACTION`)

        1. If ((direction matches pattern ``EMPTY`)), then

          1. (Let (_expressionIR # (( typeIR_arg ctk_arg ))) be typedExpressionIR_arg)

          2. If ((Type_alpha: typeIR_param ~~ typeIR_arg holds)), then

            1. If (~(ctk_arg matches pattern `DYN`)), then

              1. Result in typedExpressionIR_arg

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:289.1-292.29
relation Call_convention_argument_ok: 

  typedExpression: p TC actctxt |- parameterTypeIR @ argumentIR : % {

    1. If ((argumentIR has type typedExpressionIR)), then

      1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

      2. (Call_convention_expr_ok: p TC actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR_cast)

      3. Result in (typedExpressionIR_cast as argumentIR)

  }

  nameIR-typedExpression: p TC actctxt |- parameterTypeIR @ argumentIR : % {

    1. If ((argumentIR matches pattern `%=%`)), then

      1. (Let (nameIR = typedExpressionIR) be argumentIR)

      2. (Call_convention_expr_ok: p TC actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR_cast)

      3. Result in (nameIR = typedExpressionIR_cast)

  }

  nameIR-dontcare: p TC actctxt |- parameterTypeIR @ argumentIR : % {

    1. If ((argumentIR matches pattern `%=_`)), then

      1. (Let (nameIR =_) be argumentIR)

      2. (Let (direction _typeIR _id _value?) be parameterTypeIR)

      3. If ((direction matches pattern `OUT`)), then

        1. Result in (nameIR =_)

  }

  dontcare: p TC actctxt |- parameterTypeIR @ argumentIR : % {

    1. If ((argumentIR matches pattern `_`)), then

      1. (Let (direction _typeIR _id _value?) be parameterTypeIR)

      2. If ((direction matches pattern `OUT`)), then

        1. Result in (_)

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:294.1-297.29
relation Call_convention_ok: 

  nil: p TC actctxt |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : % {

    1. If ((parameterTypeIR* matches pattern [])), then

      1. If ((argumentIR* matches pattern [])), then

        1. Result in []

  }

  cons: p TC actctxt |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} @ argumentIR*{argumentIR <- argumentIR*} : % {

    1. If ((parameterTypeIR* matches pattern _ :: _)), then

      1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

      2. If ((argumentIR* matches pattern _ :: _)), then

        1. (Let argumentIR_h :: argumentIR_t* be argumentIR*)

        2. (Call_convention_argument_ok: p TC actctxt |- parameterTypeIR_h @ argumentIR_h : argumentIR_h_cast)

        3. (Call_convention_ok: p TC actctxt |- parameterTypeIR_t* @ argumentIR_t* : argumentIR_t_cast*)

        4. Result in argumentIR_h_cast :: argumentIR_t_cast*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:307.1-307.52
def $is_static_routineTarget(routineTargetIR')

1. Case analysis on routineTargetIR'

  1. Case (% matches pattern `%.%`)

    1. (Let (_typedExpressionIR . nameIR) be routineTargetIR')

    2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. Return (lctk)

  2. Case (% matches pattern `TYPE%.%`)

    1. (Let (type _prefixedNameIR . nameIR) be routineTargetIR')

    2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. Return (lctk)

2. Otherwise

  1. Return (dyn)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:318.1-320.23
relation RoutineTarget_ok: 

  prefixedNonTypeName: p TC |- routineTarget : % {

    1. If ((routineTarget has type prefixedNonTypeName)), then

      1. (Let prefixedNonTypeName be (routineTarget as prefixedNonTypeName))

      2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

      3. If ((((prefixedNameIR = (` "verify")) \/ (prefixedNameIR = (. "verify"))) => (((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind))))), then

        1. Result in (prefixedNameIR as routineTargetIR)

  }

  this: p TC |- routineTarget : % {

    1. If ((routineTarget = ((this) as routineTarget))), then

      1. Result in ((` "this") as routineTargetIR)

  }

  memberAccessExpression-prefixedTypeName: p TC |- routineTarget : % {

    1. If ((routineTarget has type memberAccessExpression)), then

      1. (Let (memberAccessBase . member) be (routineTarget as memberAccessExpression))

      2. If ((memberAccessBase has type prefixedTypeName)), then

        1. (Let prefixedTypeName be (memberAccessBase as prefixedTypeName))

        2. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

        3. (Let nameIR be $name(member))

        4. Result in (type prefixedNameIR . nameIR)

  }

  memberAccessExpression-expression: p TC |- routineTarget : % {

    1. If ((routineTarget has type memberAccessExpression)), then

      1. (Let (memberAccessBase . member) be (routineTarget as memberAccessExpression))

      2. If ((memberAccessBase has type expression)), then

        1. (Let expression_base be (memberAccessBase as expression))

        2. (Let nameIR be $name(member))

        3. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        4. Result in (typedExpressionIR_base . nameIR)

  }

  parenthesizedExpression: p TC |- routineTarget : % {

    1. If ((routineTarget has type parenthesizedExpression)), then

      1. (Let (( expression )) be (routineTarget as parenthesizedExpression))

      2. (RoutineTarget_ok: p TC |- expression : routineTargetIR)

      3. Result in (( routineTargetIR ))

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:322.1-324.23
relation RoutineTarget_lvalue_ok: 

  : p TC |- lvalue : % {

    1. (Let expression be $lvalue(lvalue))

    2. (RoutineTarget_ok: p TC |- expression : routineTargetIR)

    3. Result in routineTargetIR

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:326.1-329.29
relation RoutineType_ok: 

  referenceExpressionIR: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): % <# % >(# % ) {

    1. If ((routineTargetIR has type prefixedNameIR)), then

      1. (Let prefixedNameIR be (routineTargetIR as prefixedNameIR))

      2. (Let (rid, routineTypeDefIR, id*)? be $find_routine_overloaded(p, TC, prefixedNameIR, argumentIR*))

      3. If (((rid, routineTypeDefIR, id*)? matches pattern (_))), then

        1. (Let ?((rid, routineTypeDefIR, id_default*)) be (rid, routineTypeDefIR, id*)?)

        2. (Let (routineTypeDefIR, tid*) be $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*))

        3. If (((routineTypeDefIR, tid*) has type (functionTypeIR, tid*))), then

          1. (Let (functionTypeIR, tid_impl*) be ((routineTypeDefIR, tid*) as (functionTypeIR, tid*)))

          2. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_impl* })))

          3. If ((RoutineType_wf: bound |- (functionTypeIR as routineTypeIR) holds)), then

            1. Result in (functionTypeIR as routineTypeIR), tid_impl*, id_default*

  }

  typedExpressionIR-nameIR-builtin-method-minmax-SizeIn-BitsBytes: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): % <# % >(# % ) {

    1. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

      2. If ((typeArgumentIR* matches pattern [])), then

        1. If ((argumentIR* matches pattern [])), then

          1. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

            1. (Let methodTypeIR be (builtin_method( [] )-> ((int) as typeIR)))

            2. Result in (methodTypeIR as routineTypeIR), [], []

  }

  typedExpressionIR-nameIR-builtin-method-stack-push-pop-front: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR'*{argumentIR' <- argumentIR'*} ): % <# % >(# % ) {

    1. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

      2. If ((typeArgumentIR* matches pattern [])), then

        1. If ((argumentIR'* matches pattern [ _/1 ])), then

          1. (Let [argumentIR] be argumentIR'*)

          2. If (nameIR is in ["push_front", "pop_front"]), then

            1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

            2. (Let typeIR' be $canon(typeIR_base))

            3. If ((typeIR' has type headerStackTypeIR)), then

              1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

              2. (Let parameterTypeIR be (() ((int) as typeIR) "count" ?()))

              3. (Let methodTypeIR be (builtin_method( [parameterTypeIR] )-> ((int) as typeIR)))

              4. Result in (methodTypeIR as routineTypeIR), [], []

  }

  typedExpressionIR-nameIR-builtin-method-header-isValid: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): % <# % >(# % ) {

    1. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

      2. If ((typeArgumentIR* matches pattern [])), then

        1. If ((argumentIR* matches pattern [])), then

          1. If (nameIR is in ["isValid"]), then

            1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

            2. (Let typeIR be $canon(typeIR_base))

            3. If ((typeIR has type headerTypeIR)), then

              1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

              2. (Let methodTypeIR be (builtin_method( [] )-> ((bool) as typeIR)))

              3. Result in (methodTypeIR as routineTypeIR), [], []

  }

  typedExpressionIR-nameIR-builtin-method-union-isValid: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): % <# % >(# % ) {

    1. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

      2. If ((typeArgumentIR* matches pattern [])), then

        1. If ((argumentIR* matches pattern [])), then

          1. If (nameIR is in ["isValid"]), then

            1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

            2. (Let typeIR be $canon(typeIR_base))

            3. If ((typeIR has type headerUnionTypeIR)), then

              1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR as headerUnionTypeIR))

              2. (Let methodTypeIR be (builtin_method( [] )-> ((bool) as typeIR)))

              3. Result in (methodTypeIR as routineTypeIR), [], []

  }

  typedExpressionIR-nameIR-builtin-method-header-set-ValidInvalid: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): % <# % >(# % ) {

    1. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

      2. If ((typeArgumentIR* matches pattern [])), then

        1. If ((argumentIR* matches pattern [])), then

          1. If (nameIR is in ["setValid", "setInvalid"]), then

            1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

            2. (Let typeIR be $canon(typeIR_base))

            3. If ((typeIR has type headerTypeIR)), then

              1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

              2. (Let methodTypeIR be (builtin_method( [] )-> ((void) as typeIR)))

              3. Result in (methodTypeIR as routineTypeIR), [], []

  }

  typedExpressionIR-nameIR-extern-method: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): % <# % >(# % ) {

    1. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

      2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

      3. (Let typeIR be $canon(typeIR_base))

      4. If ((typeIR has type externObjectTypeIR)), then

        1. (Let (extern _tid ({ (rid_f : routineTypeDefIR_f)* })) be (typeIR as externObjectTypeIR))

        2. (Let id_arg?* be $ids_arguments(argumentIR*))

        3. (Let (rid, routineTypeDefIR, id*)? be $find_overloaded<routineTypeDefIR>(({ (rid_f : routineTypeDefIR_f)* }), nameIR, id_arg?*))

        4. If (((rid, routineTypeDefIR, id*)? matches pattern (_))), then

          1. (Let ?((rid, routineTypeDefIR, id_default*)) be (rid, routineTypeDefIR, id*)?)

          2. (Let (routineTypeDefIR, tid*) be $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*))

          3. If (((routineTypeDefIR, tid*) has type (routineTypeIR, tid*))), then

            1. (Let (routineTypeIR, tid_impl*) be ((routineTypeDefIR, tid*) as (routineTypeIR, tid*)))

            2. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_impl* })))

            3. If ((RoutineType_wf: bound |- routineTypeIR holds)), then

              1. Result in routineTypeIR, tid_impl*, id_default*

  }

  typedExpressionIR-nameIR-parser-apply-method: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): % <# % >(# % ) {

    1. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . text) be routineTargetIR)

      2. If ((text = "apply")), then

        1. If ((typeArgumentIR* matches pattern [])), then

          1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

          2. (Let typeIR be $canon(typeIR_base))

          3. If ((typeIR has type parserObjectTypeIR)), then

            1. (Let (parser( parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

            2. (Let methodTypeIR be (parser_apply( parameterTypeIR* )))

            3. (Let (_direction _typeIR id_param value_param?) be parameterTypeIR)*

            4. (Let pid be (id_param # (value_param? =/= ?())))*

            5. (Let rid be ("apply" ( pid* )))

            6. (Let id_arg?* be $ids_arguments(argumentIR*))

            7. (Let (rid, routineTypeDefIR, id*)'? be $find_overloaded<routineTypeDefIR>(({ [(rid : (methodTypeIR as routineTypeDefIR))] }), "apply", id_arg?*))

            8. If (((rid, routineTypeDefIR, id*)'? matches pattern (_))), then

              1. (Let ?((rid, routineTypeDefIR, id*)) be (rid, routineTypeDefIR, id*)'?)

              2. If (((rid, routineTypeDefIR, id*) has type (rid, methodTypeIR, id*))), then

                1. (Let (rid', methodTypeIR', id_default*) be ((rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)))

                2. If ((rid' = rid)), then

                  1. If ((methodTypeIR' = methodTypeIR)), then

                    1. Result in (methodTypeIR as routineTypeIR), [], id_default*

  }

  typedExpressionIR-nameIR-control-apply-method: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): % <# % >(# % ) {

    1. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . text) be routineTargetIR)

      2. If ((text = "apply")), then

        1. If ((typeArgumentIR* matches pattern [])), then

          1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

          2. (Let typeIR be $canon(typeIR_base))

          3. If ((typeIR has type controlObjectTypeIR)), then

            1. (Let (control( parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

            2. (Let methodTypeIR be (control_apply( parameterTypeIR* )))

            3. (Let (_direction _typeIR id_param value_param?) be parameterTypeIR)*

            4. (Let pid be (id_param # (value_param? =/= ?())))*

            5. (Let rid be ("apply" ( pid* )))

            6. (Let id_arg?* be $ids_arguments(argumentIR*))

            7. (Let (rid, routineTypeDefIR, id*)'? be $find_overloaded<routineTypeDefIR>(({ [(rid : (methodTypeIR as routineTypeDefIR))] }), "apply", id_arg?*))

            8. If (((rid, routineTypeDefIR, id*)'? matches pattern (_))), then

              1. (Let ?((rid, routineTypeDefIR, id*)) be (rid, routineTypeDefIR, id*)'?)

              2. If (((rid, routineTypeDefIR, id*) has type (rid, methodTypeIR, id*))), then

                1. (Let (rid', methodTypeIR', id_default*) be ((rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)))

                2. If ((rid' = rid)), then

                  1. If ((methodTypeIR' = methodTypeIR)), then

                    1. Result in (methodTypeIR as routineTypeIR), [], id_default*

  }

  typedExpressionIR-nameIR-table-apply-method: p TC |- routineTargetIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): % <# % >(# % ) {

    1. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . text) be routineTargetIR)

      2. If ((text = "apply")), then

        1. If ((typeArgumentIR* matches pattern [])), then

          1. If ((argumentIR* matches pattern [])), then

            1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

            2. (Let typeIR be $canon(typeIR_base))

            3. If ((typeIR has type tableObjectTypeIR)), then

              1. (Let (table _tid # typeIR_table) be (typeIR as tableObjectTypeIR))

              2. (Let methodTypeIR be (table_apply-> typeIR_table))

              3. Result in (methodTypeIR as routineTypeIR), [], []

  }

  parenthesized: p TC |- routineTargetIR' < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): % <# % >(# % ) {

    1. If ((routineTargetIR' matches pattern `(%)`)), then

      1. (Let (( routineTargetIR )) be routineTargetIR')

      2. (RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR* >( argumentIR* ): routineTypeIR <# tid_inserted* >(# id_default* ))

      3. Result in routineTypeIR, tid_inserted*, id_default*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:336.1-340.35
relation Call_ok: 

  builtin-function: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): % < % >( % ) {

    1. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `BUILTIN_FUNCTION(%)->%`)), then

        1. (Let (builtin_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. If ((tid* matches pattern [])), then

          1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

          2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

            1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

            2. If ($callable_builtin_function(p, TC)), then

              1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

              2. Result in typeIR_ret, typeArgumentIR*, argumentIR_cast*

  }

  function: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): % < % >( % ) {

    1. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `FUNCTION(%)->%`)), then

        1. (Let (function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

        3. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

          1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

          2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

          3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid_infer))*

          4. If ((typeIR? matches pattern (_)))*, then

            1. (Let ?(typeIR_inferred) be typeIR?)*

            2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

            3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

            4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

            5. (Let functionTypeIR_inferred be (function( parameterTypeIR_aligned_inferred* )-> typeIR_ret_inferred))

            6. If ((RoutineType_wf: $bound(p, TC) |- (functionTypeIR_inferred as routineTypeIR) holds)), then

              1. If ($callable_function(p, TC)), then

                1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

                2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*, argumentIR_cast*

  }

  externfunction: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): % < % >( % ) {

    1. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `EXTERN_FUNCTION(%)->%`)), then

        1. (Let (extern_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

        3. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

          1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

          2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

          3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid_infer))*

          4. If ((typeIR? matches pattern (_)))*, then

            1. (Let ?(typeIR_inferred) be typeIR?)*

            2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

            3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

            4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

            5. (Let functionTypeIR_inferred be (extern_function( parameterTypeIR_aligned_inferred* )-> typeIR_ret_inferred))

            6. If ((RoutineType_wf: $bound(p, TC) |- (functionTypeIR_inferred as routineTypeIR) holds)), then

              1. If ($callable_extern_function(p, TC)), then

                1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

                2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*, argumentIR_cast*

  }

  action: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): % < % >( % ) {

    1. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `ACTION(%)`)), then

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((tid* matches pattern [])), then

            1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

            2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

              1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

              2. If ($callable_action(p, TC)), then

                1. (Call_convention_ok: p TC (action) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

                2. Result in ((void) as typeIR), [], argumentIR_cast*

  }

  builtin-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): % < % >( % ) {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `BUILTIN_METHOD(%)->%`)), then

        1. (Let (builtin_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. If ((tid* matches pattern [])), then

          1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

          2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

            1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

            2. If ($callable_builtin_method(p, TC)), then

              1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

              2. Result in typeIR_ret, typeArgumentIR*, argumentIR_cast*

  }

  extern-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): % < % >( % ) {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `EXTERN_METHOD(%)->%`)), then

        1. (Let (extern_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

        3. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

          1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

          2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

          3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid_infer))*

          4. If ((typeIR? matches pattern (_)))*, then

            1. (Let ?(typeIR_inferred) be typeIR?)*

            2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

            3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

            4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

            5. (Let methodTypeIR_inferred be (extern_method( parameterTypeIR_aligned_inferred* )-> typeIR_ret_inferred))

            6. If ((RoutineType_wf: $bound(p, TC) |- (methodTypeIR_inferred as routineTypeIR) holds)), then

              1. If ($callable_extern_method(p, TC)), then

                1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

                2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*, argumentIR_cast*

  }

  extern-abstract-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): % < % >( % ) {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

        1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

        3. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

          1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

          2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

          3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid_infer))*

          4. If ((typeIR? matches pattern (_)))*, then

            1. (Let ?(typeIR_inferred) be typeIR?)*

            2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

            3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

            4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

            5. (Let methodTypeIR_inferred be (extern_methodabstract( parameterTypeIR_aligned_inferred* )-> typeIR_ret_inferred))

            6. If ((RoutineType_wf: $bound(p, TC) |- (methodTypeIR_inferred as routineTypeIR) holds)), then

              1. If ($callable_extern_abstract_method(p, TC)), then

                1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

                2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*, argumentIR_cast*

  }

  parser-apply-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): % < % >( % ) {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `PARSER_APPLY(%)`)), then

        1. (Let (parser_apply( parameterTypeIR* )) be methodTypeIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((tid* matches pattern [])), then

            1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

            2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

              1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

              2. If ($callable_parser_apply_method(p, TC)), then

                1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

                2. Result in ((void) as typeIR), [], argumentIR_cast*

  }

  control-apply-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): % < % >( % ) {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `CONTROL_APPLY(%)`)), then

        1. (Let (control_apply( parameterTypeIR* )) be methodTypeIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((tid* matches pattern [])), then

            1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

            2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

              1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

              2. If ($callable_control_apply_method(p, TC)), then

                1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

                2. Result in ((void) as typeIR), [], argumentIR_cast*

  }

  table-apply-method: p TC |- routineTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid*{tid <- tid*} >( argumentIR*{argumentIR <- argumentIR*} # id*{id <- id*} ): % < % >( % ) {

    1. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `TABLE_APPLY->%`)), then

        1. (Let (table_apply-> typeIR_table) be methodTypeIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((tid* matches pattern [])), then

            1. If ((argumentIR* matches pattern [])), then

              1. If ((id* matches pattern [])), then

                1. If ($callable_table_apply_method(p, TC)), then

                  1. Result in typeIR_table, [], []

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:350.1-353.29
relation ConstructorType_ok: 

  : p TC |- prefixedNameIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} ): % <# % >(# % ) {

    1. (Let (rid, constructorTypeDefIR, id*)? be $find_constructor_overloaded(TC, prefixedNameIR, argumentIR*))

    2. If (((rid, constructorTypeDefIR, id*)? matches pattern (_))), then

      1. (Let ?((cid, constructorTypeDefIR, id_default*)) be (rid, constructorTypeDefIR, id*)?)

      2. (Let (constructorTypeIR, tid_impl*) be $specialize_constructorTypeDef(constructorTypeDefIR, typeArgumentIR*))

      3. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_impl* })))

      4. If ((ConstructorType_wf: bound |- constructorTypeIR holds)), then

        1. Result in constructorTypeIR, tid_impl*, id_default*

  }

;; ../../../../spec-concrete/5.04-typing-relation.watsup:360.19-360.31
syntax instctxt = 
   | named
   | anon

;; ../../../../spec-concrete/5.04-typing-relation.watsup:362.1-369.38
relation Inst_ok: 

  package: cursor TC instctxt |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): % < % >( % ) {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. (Let (constructor( parameterTypeIR* )-> typeIR_object) be constructorTypeIR)

      2. (Let typeIR be $canon(typeIR_object))

      3. If ((typeIR has type packageObjectTypeIR)), then

        1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

        2. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

        3. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

          1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

          2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

          3. (Let typeIR'? be $find_map<tid, typeIR>(inference, tid_infer))*

          4. If ((typeIR'? matches pattern (_)))*, then

            1. (Let ?(typeIR_inferred) be typeIR'?)*

            2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

            3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

            4. (Let typeIR_object_inferred be $subst_type(inference, typeIR_object))

            5. (Let constructorTypeIR_inferred be (constructor( parameterTypeIR_aligned_inferred* )-> typeIR_object_inferred))

            6. If ((ConstructorType_wf: $bound((global), TC) |- constructorTypeIR_inferred holds)), then

              1. If ($instantiable((global), TC, instctxt, typeIR_object_inferred)), then

                1. (Call_convention_ok: (block) TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

                2. Result in typeIR_object_inferred, typeArgumentIR_inferred*, argumentIR_cast*

  }

  non-package: p TC instctxt |- constructorTypeIR < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} # tid_infer*{tid_infer <- tid_infer*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} ): % < % >( % ) {

    1. (Let (constructor( parameterTypeIR* )-> typeIR_object) be constructorTypeIR)

    2. If (~$is_package_object_typeIR($canon(typeIR_object))), then

      1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

      2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

        1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

        2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

        3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid_infer))*

        4. If ((typeIR? matches pattern (_)))*, then

          1. (Let ?(typeIR_inferred) be typeIR?)*

          2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

          3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

          4. (Let typeIR_object_inferred be $subst_type(inference, typeIR_object))

          5. (Let constructorTypeIR_inferred be (constructor( parameterTypeIR_aligned_inferred* )-> typeIR_object_inferred))

          6. If ((ConstructorType_wf: $bound(p, TC) |- constructorTypeIR_inferred holds)), then

            1. If ($instantiable(p, TC, instctxt, typeIR_object_inferred)), then

              1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

              2. Result in typeIR_object_inferred, typeArgumentIR_inferred*, argumentIR_cast*

  }

;; ../../../../spec-concrete/5.05.2-subtype.watsup:412.1-416.23
def $reduce_serenum_unary(typedExpressionIR, $check)

1. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

2. Case analysis on $check(typeIR)

  1. Case true

    1. Return ?(typedExpressionIR)

  2. Case false

    1. (Let typeIR' be typeIR)

    2. If ((typeIR' has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR' as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR_underlying { _valueFieldIR* }) be enumTypeIR)

        2. (Let typedExpressionIR_cast be (((( typeIR_underlying ) typedExpressionIR) as expressionIR) # (( typeIR_underlying _ctk ))))

        3. Return $reduce_serenum_unary(typedExpressionIR_cast, $check)

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.05.2-subtype.watsup:437.1-442.44
def $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $check)

1. (Let (_expressionIR # (( typeIR_l _ctk ))) be typedExpressionIR_l)

2. (Let (_expressionIR' # (( typeIR_r _ctk' ))) be typedExpressionIR_r)

3. Case analysis on $check(typeIR_l, typeIR_r)

  1. Case true

    1. Return ?((typedExpressionIR_l, typedExpressionIR_r))

  2. Case false

    1. (Let typeIR be typeIR_l)

    2. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR_l_underlying { _valueFieldIR* }) be enumTypeIR)

        2. (Let typedExpressionIR_l_cast be (((( typeIR_l_underlying ) typedExpressionIR_l) as expressionIR) # (( typeIR_l_underlying _ctk' ))))

        3. Return $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r, $check)

    3. (Let typeIR be typeIR_r)

    4. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR_r_underlying { _valueFieldIR* }) be enumTypeIR)

        2. (Let typedExpressionIR_r_cast be (((( typeIR_r_underlying ) typedExpressionIR_r) as expressionIR) # (( typeIR_r_underlying _ctk' ))))

        3. Return $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r_cast, $check)

4. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.05.2-subtype.watsup:482.1-482.66
def $coerce_unary(typedExpressionIR, typeIR_to)

1. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

2. Case analysis on (Type_alpha: typeIR ~~ typeIR_to holds)

  1. Case true

    1. Return ?(typedExpressionIR)

  2. Case false

    1. If ((Sub_impl: typeIR <: typeIR_to holds)), then

      1. (Let typedExpressionIR_cast be (((( typeIR_to ) typedExpressionIR) as expressionIR) # (( typeIR_to _ctk ))))

      2. Return ?(typedExpressionIR_cast)

;; ../../../../spec-concrete/5.05.2-subtype.watsup:497.1-498.44
def $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)

1. (Let (_expressionIR # (( typeIR_l _ctk ))) be typedExpressionIR_l)

2. (Let (_expressionIR' # (( typeIR_r _ctk' ))) be typedExpressionIR_r)

3. Case analysis on (Type_alpha: typeIR_l ~~ typeIR_r holds)

  1. Case true

    1. Return ?((typedExpressionIR_l, typedExpressionIR_r))

  2. Case false

    1. Case analysis on (Sub_impl: typeIR_l <: typeIR_r holds)

      1. Case true

        1. (Let typedExpressionIR_l_cast be (((( typeIR_r ) typedExpressionIR_l) as expressionIR) # (( typeIR_r _ctk' ))))

        2. Return ?((typedExpressionIR_l_cast, typedExpressionIR_r))

      2. Case false

        1. If ((Sub_impl: typeIR_r <: typeIR_l holds)), then

          1. (Let typedExpressionIR_r_cast be (((( typeIR_l ) typedExpressionIR_r) as expressionIR) # (( typeIR_l _ctk' ))))

          2. Return ?((typedExpressionIR_l, typedExpressionIR_r_cast))

4. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:80.1-80.32
def $compat_lnot(typeIR)

1. Return $compat'_lnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:81.1-81.33
def $compat'_lnot(typeIR)

1. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:101.1-101.32
def $compat_bnot(typeIR)

1. Return $compat'_bnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:102.1-102.33
def $compat'_bnot(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:123.1-123.38
def $compat_uplusminus(typeIR)

1. Return $compat'_uplusminus($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:124.1-124.39
def $compat'_uplusminus(typeIR)

1. If ((typeIR = ((int) as typeIR))), then

  1. Return true

2. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:149.1-149.49
def $compat_plusminusmult(typeIR_l, typeIR_r)

1. Return $compat'_plusminusmult($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:150.1-150.50
def $compat'_plusminusmult(typeIR'', typeIR''')

1. If ((typeIR'' = ((int) as typeIR))), then

  1. If ((typeIR''' = ((int) as typeIR))), then

    1. Return true

2. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT<%>`)), then

          1. (Let (int< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

          1. (Let (bit< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:186.1-186.48
def $compat_satplusminus(typeIR_l, typeIR_r)

1. Return $compat'_satplusminus($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:187.1-187.49
def $compat'_satplusminus(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT<%>`)), then

          1. (Let (int< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

          1. (Let (bit< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:222.1-222.42
def $compat_divmod(typeIR_l, typeIR_r)

1. Return $compat'_divmod($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:223.1-223.43
def $compat'_divmod(typeIR'', typeIR''')

1. If ((typeIR'' = ((int) as typeIR))), then

  1. If ((typeIR''' = ((int) as typeIR))), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:293.1-293.41
def $compat_shift(typeIR_l, typeIR_r)

1. Return $compat'_shift($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:294.1-294.42
def $compat'_shift(typeIR'', typeIR''')

1. If ((typeIR'' = ((int) as typeIR))), then

  1. If ((typeIR''' = ((int) as typeIR))), then

    1. Return true

  2. If ((typeIR''' has type numberTypeIR)), then

    1. (Let numberTypeIR be (typeIR''' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

2. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. If ((typeIR''' = ((int) as typeIR))), then

        1. Return true

      3. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< _nat' >) be numberTypeIR')

            2. Return true

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< _nat' >) be numberTypeIR')

            2. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. If ((typeIR''' = ((int) as typeIR))), then

        1. Return true

      3. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< _nat' >) be numberTypeIR')

            2. Return true

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< _nat' >) be numberTypeIR')

            2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:388.1-388.43
def $compat_compare(typeIR_l, typeIR_r)

1. Return $compat'_compare($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:389.1-389.44
def $compat'_compare(typeIR'', typeIR''')

1. If ((typeIR'' = ((int) as typeIR))), then

  1. If ((typeIR''' = ((int) as typeIR))), then

    1. Return true

2. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT<%>`)), then

          1. (Let (int< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

          1. (Let (bit< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:425.1-425.43
def $compat_bitwise(typeIR_l, typeIR_r)

1. Return $compat'_bitwise($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:426.1-426.44
def $compat'_bitwise(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT<%>`)), then

          1. (Let (int< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

          1. (Let (bit< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:461.1-461.42
def $compat_concat(typeIR_l, typeIR_r)

1. Return $compat'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:462.1-462.43
def $compat'_concat(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< _nat' >) be numberTypeIR')

            2. Return true

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< _nat' >) be numberTypeIR')

            2. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< _nat' >) be numberTypeIR')

            2. Return true

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< _nat' >) be numberTypeIR')

            2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:473.1-473.45
def $result_concat(typeIR_l, typeIR_r)

1. Return $result'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:474.1-474.46
def $result'_concat(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w_a >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< w_b >) be numberTypeIR')

            2. Return ?(((int< (w_a + w_b) >) as typeIR))

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< w_b >) be numberTypeIR')

            2. Return ?(((int< (w_a + w_b) >) as typeIR))

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w_a >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `INT<%>`)

            1. (Let (int< w_b >) be numberTypeIR')

            2. Return ?(((bit< (w_a + w_b) >) as typeIR))

          2. Case (% matches pattern `BIT<%>`)

            1. (Let (bit< w_b >) be numberTypeIR')

            2. Return ?(((bit< (w_a + w_b) >) as typeIR))

2. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:511.1-511.43
def $compat_logical(typeIR_l, typeIR_r)

1. Return $compat'_logical($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:512.1-512.44
def $compat'_logical(typeIR'', typeIR''')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. If ((typeIR''' = ((bool) as typeIR))), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:905.1-905.39
def $compat_array_index(typeIR)

1. Return $compat'_arrayindex($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:906.1-906.39
def $compat'_arrayindex(typeIR)

1. If ((typeIR = ((int) as typeIR))), then

  1. Return true

2. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1000.1-1000.41
def $compat_bitslice_base(typeIR)

1. Return $compat'_bitslice_base($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1001.1-1001.42
def $compat'_bitslice_base(typeIR)

1. If ((typeIR = ((int) as typeIR))), then

  1. Return true

2. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. Return (w > 0)

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1011.1-1011.42
def $compat_bitslice_index(typeIR)

1. Return $compat'_bitslice_index($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1012.1-1012.43
def $compat'_bitslice_index(typeIR)

1. If ((typeIR = ((int) as typeIR))), then

  1. Return true

2. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1022.1-1022.48
def $is_valid_bitslice(typeIR, n_lo, n_hi)

1. Return ((n_lo <= n_hi) /\ $is_valid_bitslice'($canon(typeIR), n_lo, n_hi))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1023.1-1023.49
def $is_valid_bitslice'(typeIR', _nat'', _nat''')

1. If ((typeIR' = ((int) as typeIR))), then

  1. Return true

2. If ((typeIR' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. (Let w_slice be ((_nat''' - _nat'') + 1))

      3. Return ((_nat''' <= w) /\ (w_slice <= w))

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. (Let w_slice be ((_nat''' - _nat'') + 1))

      3. Return ((_nat''' <= w) /\ (w_slice <= w))

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1154.1-1154.46
def $is_concrete_extern_object(typeIR)

1. Return $is_concrete_extern_object'($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1155.1-1155.47
def $is_concrete_extern_object'(typeIR)

1. If (~$is_extern_object_typeIR(typeIR)), then

  1. Return true

2. If ((typeIR has type externObjectTypeIR)), then

  1. (Let (extern _tid ({ (_rid : routineTypeDefIR)* })) be (typeIR as externObjectTypeIR))

  2. If ($is_concrete_extern_object''(routineTypeDefIR))*, then

    1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1156.1-1156.58
def $is_concrete_extern_object''(routineTypeDefIR)

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

    2. Return $is_concrete_extern_object'''(routineTypeIR)

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR < _tid* , _tid'* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. Return (true = $is_concrete_extern_object'''(routineTypeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1157.1-1157.56
def $is_concrete_extern_object'''(routineTypeIR')

1. If ((routineTypeIR' has type methodTypeIR)), then

  1. (Let methodTypeIR be (routineTypeIR' as methodTypeIR))

  2. If ((methodTypeIR matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

    1. (Let (extern_methodabstract( _parameterTypeIR* )-> _typeIR) be methodTypeIR)

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.10-typing-statement.watsup:91.1-91.46
def $compat_direct_application(typeIR)

1. Return $compat'_direct_application($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:92.1-92.47
def $compat'_direct_application(typeIR)

1. Case analysis on typeIR

  1. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

    2. Return true

  2. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.10-typing-statement.watsup:213.1-215.26
relation SwitchLabel_table_ok: 

  default: TC tid_table bool |- switchLabel : % {

    1. If ((bool = true)), then

      1. If ((switchLabel matches pattern `DEFAULT`)), then

        1. Result in (default)

  }

  expressionNonBrace-prefixedNonTypeName: TC tid_table _bool |- switchLabel : % {

    1. If ((switchLabel has type prefixedNonTypeName)), then

      1. (Let prefixedNonTypeName be (switchLabel as prefixedNonTypeName))

      2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

      3. If ((prefixedNameIR matches pattern ``%`)), then

        1. (Let (` nameIR_label) be prefixedNameIR)

        2. (Let tid_table_enum be "action_list(" ++ tid_table ++ ")")

        3. (Let id_label be tid_table_enum ++ "." ++ nameIR_label)

        4. (Let varTypeIR? be $find_var((local), TC, (` id_label)))

        5. If ((varTypeIR? matches pattern (_))), then

          1. (Let ?((_direction typeIR_label ctk_label value?)) be varTypeIR?)

          2. If ((value? matches pattern (_))), then

            1. (Let ?(value_label) be value?)

            2. If ((value_label = ((table_enum tid_table_enum . nameIR_label) as value))), then

              1. (Let typedExpressionIR_label be (((` nameIR_label) as expressionIR) # (( typeIR_label ctk_label ))))

              2. Result in (typedExpressionIR_label as switchLabelIR)

  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:242.1-244.29
relation SwitchCase_table_ok: 

  switchLabel-blockStatement: TC f tid_table b_last |- switchCase : % % # % {

    1. If ((switchCase matches pattern `%:%`)), then

      1. (Let (switchLabel : blockStatement) be switchCase)

      2. (SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR)

      3. (Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR)

      4. (Let switchCaseIR be (switchLabelIR : blockStatementIR))

      5. Result in f_post, switchCaseIR, switchLabel

  }

  switchLabel: TC f tid_table b_last |- switchCase : % % # % {

    1. If ((switchCase matches pattern `%:`)), then

      1. (Let (switchLabel :) be switchCase)

      2. (SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR)

      3. (Let switchCaseIR be (switchLabelIR :))

      4. Result in f, switchCaseIR, switchLabel

  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:270.1-272.26
relation SwitchCases_table_ok: 

  nil: TC f tid_table |- switchCase*{switchCase <- switchCase*} : % % # % {

    1. If ((switchCase* matches pattern [])), then

      1. Result in f, [], []

  }

  cons: TC f tid_table |- switchCase*{switchCase <- switchCase*} : % % # % {

    1. If ((switchCase* matches pattern _ :: _)), then

      1. (Let switchCase_h :: switchCase_t* be switchCase*)

      2. (Let b_last be (switchCase_t* = []))

      3. (SwitchCase_table_ok: TC f tid_table b_last |- switchCase_h : f_h switchCaseIR_h # switchLabel_h)

      4. (SwitchCases_table_ok: TC f_h tid_table |- switchCase_t* : f_t switchCaseIR_t* # switchLabel_t*)

      5. Result in f_t, switchCaseIR_h :: switchCaseIR_t*, switchLabel_h :: switchLabel_t*

  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:309.1-311.26
relation SwitchLabel_general_ok: 

  default: TC _typeIR bool |- switchLabel : % {

    1. If ((bool = true)), then

      1. If ((switchLabel matches pattern `DEFAULT`)), then

        1. Result in (default)

  }

  expressionNonBrace: TC typeIR_switch _bool |- switchLabel : % {

    1. If ((switchLabel has type expressionNonBrace)), then

      1. (Let expressionNonBrace_label be (switchLabel as expressionNonBrace))

      2. (Let expression_label be $expressionNonBrace(expressionNonBrace_label))

      3. (Expr_ok: (local) TC |- expression_label : typedExpressionIR_label)

      4. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_label, typeIR_switch))

      5. If ((typedExpressionIR? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_label_cast) be typedExpressionIR?)

        2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR_label_cast)

        3. If ((ctk matches pattern `LCTK`)), then

          1. Result in (typedExpressionIR_label_cast as switchLabelIR)

  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:332.1-334.29
relation SwitchCase_general_ok: 

  switchLabel-blockStatement: TC f typeIR_switch b_last |- switchCase : % % # % {

    1. If ((switchCase matches pattern `%:%`)), then

      1. (Let (switchLabel : blockStatement) be switchCase)

      2. (SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR)

      3. (Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR)

      4. (Let switchCaseIR be (switchLabelIR : blockStatementIR))

      5. Result in f_post, switchCaseIR, switchLabel

  }

  switchLabel: TC f typeIR_switch b_last |- switchCase : % % # % {

    1. If ((switchCase matches pattern `%:`)), then

      1. (Let (switchLabel :) be switchCase)

      2. (SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR)

      3. (Let switchCaseIR be (switchLabelIR :))

      4. Result in f, switchCaseIR, switchLabel

  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:360.1-362.26
relation SwitchCases_general_ok: 

  nil: TC f typeIR_switch |- switchCase*{switchCase <- switchCase*} : % % # % {

    1. If ((switchCase* matches pattern [])), then

      1. Result in f, [], []

  }

  cons: TC f typeIR_switch |- switchCase*{switchCase <- switchCase*} : % % # % {

    1. If ((switchCase* matches pattern _ :: _)), then

      1. (Let switchCase_h :: switchCase_t* be switchCase*)

      2. (Let b_last be (switchCase_t* = []))

      3. (SwitchCase_general_ok: TC f typeIR_switch b_last |- switchCase_h : f_h switchCaseIR_h # switchLabel_h)

      4. (SwitchCases_general_ok: TC f_h typeIR_switch |- switchCase_t* : f_t switchCaseIR_t* # switchLabel_t*)

      5. Result in f_t, switchCaseIR_h :: switchCaseIR_t*, switchLabel_h :: switchLabel_t*

  }

;; ../../../../spec-concrete/5.10-typing-statement.watsup:377.1-377.34
def $compat_switch(typeIR)

1. Return $compat'_switch($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:378.1-378.35
def $compat'_switch(typeIR)

1. If ((typeIR = ((error) as typeIR))), then

  1. Return true

2. Case analysis on typeIR

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:92.1-95.29
relation Decl_object_ok: 

  functionDeclaration: p TC_0 frame rdenv |- objectDeclaration : % % % {

    1. If ((objectDeclaration has type functionDeclaration)), then

      1. (Let (annotationList (typeOrVoid name typeParameterListOpt ( parameterList )) blockStatement) be (objectDeclaration as functionDeclaration))

      2. (Let TC_1 be TC_0[block.kind = (extern)])

      3. (Let TC_2 be TC_1[block.frame = frame])

      4. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      5. (Let tid_expl be $name(typeParameter))*

      6. (Let TC_3 be $add_types((local), TC_2, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      7. (Type_ok: (local) TC_3 |- typeOrVoid : typeIR_ret # tid*)

      8. If ((tid* matches pattern [])), then

        1. (Let parameter* be $flatten_parameterList(parameterList))

        2. (Parameters_ok: (local) TC_3 |- parameter* : parameterIR* # tid_impl*)

        3. (Let parameterTypeIR be $parameterIR(parameterIR))*

        4. (Let TC_4 be $add_parameters((local), TC_3, parameterTypeIR*))

        5. (Let TC_5 be TC_4[local.kind = (extern_method-> typeIR_ret)])

        6. (Block_ok: TC_5 (cont) |- blockStatement : _typingContext f blockStatementIR)

        7. If (((f = (ret)) \/ (typeIR_ret = ((void) as typeIR)))), then

          1. (Let rid be $rid(name, parameterList))

          2. (Let methodTypeIR be (extern_method( parameterTypeIR* )-> typeIR_ret))

          3. (Let routineTypeDefIR be (((methodTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

          4. If ((RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds)), then

            1. (Let rdenv_init be $update_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

            2. (Let nameIR be $name(name))

            3. (Let functionDeclarationIR be (annotationList (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) blockStatementIR))

            4. Result in frame, rdenv_init, (functionDeclarationIR as objectDeclarationIR)

  }

  instantiation: p TC_0 frame rdenv |- objectDeclaration : % % % {

    1. If ((objectDeclaration has type instantiation)), then

      1. (Let instantiation be (objectDeclaration as instantiation))

      2. (Decl_ok: p TC_0 |- (instantiation as declaration) : TC_1 declarationIR)

      3. If ((declarationIR has type instantiationIR)), then

        1. (Let instantiationIR be (declarationIR as instantiationIR))

        2. (Let (_annotationList _prefixedNameIR < _typeArgumentListIR >( _argumentListIR ) nameIR _objectInitializerOptIR ;) be instantiationIR)

        3. (Let varTypeIR'? be $find_var(p, TC_1, (` nameIR)))

        4. If ((varTypeIR'? matches pattern (_))), then

          1. (Let ?(varTypeIR) be varTypeIR'?)

          2. (Let frame_init be $update_map<id, varTypeIR>(frame, nameIR, varTypeIR))

          3. Result in frame_init, rdenv, (instantiationIR as objectDeclarationIR)

  }

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:155.1-158.29
relation Decls_object_ok: 

  nil: p TC frame rdenv |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : % % % {

    1. If ((objectDeclaration* matches pattern [])), then

      1. Result in frame, rdenv, []

  }

  cons: p TC frame_0 rdenv_0 |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : % % % {

    1. If ((objectDeclaration* matches pattern _ :: _)), then

      1. (Let objectDeclaration_h :: objectDeclaration_t* be objectDeclaration*)

      2. (Decl_object_ok: p TC frame_0 rdenv_0 |- objectDeclaration_h : frame_1 rdenv_1 objectDeclarationIR_h)

      3. (Decls_object_ok: p TC frame_1 rdenv_1 |- objectDeclaration_t* : frame_2 rdenv_2 objectDeclarationIR_t*)

      4. Result in frame_2, rdenv_2, objectDeclarationIR_h :: objectDeclarationIR_t*

  }

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:173.1-173.46
def $subst_rdenv(theta, rdenv_extern, set<pair<rid, routineTypeDefIR>>')

1. If ((set<pair<rid, routineTypeDefIR>>' = ({ [] }))), then

  1. Return rdenv_extern

2. (Let ({ pair<rid, routineTypeDefIR>* }) be set<pair<rid, routineTypeDefIR>>')

3. If ((pair<rid, routineTypeDefIR>* matches pattern _ :: _)), then

  1. (Let (rid_init_h : routineTypeDefIR_init_h) :: (rid_init_t : routineTypeDefIR_init_t)* be pair<rid, routineTypeDefIR>*)

  2. (Let routineTypeDefIR''? be $find_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h))

  3. If ((routineTypeDefIR''? matches pattern (_))), then

    1. (Let ?(routineTypeDefIR') be routineTypeDefIR''?)

    2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

      1. (Let (routineTypeIR < tid_expl* , tid_impl* >) be (routineTypeDefIR' as polyRoutineTypeDefIR))

      2. If ((routineTypeIR has type methodTypeIR)), then

        1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

        2. If ((methodTypeIR matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

          1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

          2. (Let routineTypeDefIR be ((((extern_method( parameterTypeIR* )-> typeIR_ret) as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

          3. (Let routineTypeDefIR_subst be $subst_routineTypeDef(theta, routineTypeDefIR))

          4. If ((RoutineTypeDef_alpha: routineTypeDefIR_subst ~~ routineTypeDefIR_init_h holds)), then

            1. (Let rdenv_extern_subst be $update_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h, routineTypeDefIR_subst))

            2. Return $subst_rdenv(theta, rdenv_extern_subst, ({ (rid_init_t : routineTypeDefIR_init_t)* }))

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:426.1-426.81
def $split_constructors(methodPrototype*)

1. Case analysis on methodPrototype*

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let methodPrototype_h :: methodPrototype_t* be methodPrototype*)

    2. (Let methodPrototype' be methodPrototype_h)

    3. Case analysis on methodPrototype'

      1. Case (% matches pattern `%%(%);`)

        1. (Let (_annotationList _typeIdentifier ( _parameterList );) be methodPrototype')

        2. (Let (methodPrototype_t_constructor*, methodPrototype_t_method*) be $split_constructors(methodPrototype_t*))

        3. Return (methodPrototype_h :: methodPrototype_t_constructor*, methodPrototype_t_method*)

      2. Case (% matches pattern `%%;`)

        1. (Let (_annotationList _functionPrototype ;) be methodPrototype')

        2. (Let (methodPrototype_t_constructor*, methodPrototype_t_method*) be $split_constructors(methodPrototype_t*))

        3. Return (methodPrototype_t_constructor*, methodPrototype_h :: methodPrototype_t_method*)

      3. Case (% matches pattern `%ABSTRACT%;`)

        1. (Let (_annotationList abstract _functionPrototype ;) be methodPrototype')

        2. (Let (methodPrototype_t_constructor*, methodPrototype_t_method*) be $split_constructors(methodPrototype_t*))

        3. Return (methodPrototype_t_constructor*, methodPrototype_h :: methodPrototype_t_method*)

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:624.1-627.26
relation Enum_serializable_field_ok: 

  : TC_0 nameIR_enum typeIR |- name = expression : % % # % {

    1. (Expr_ok: (block) TC_0 |- expression : typedExpressionIR)

    2. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR, typeIR))

    3. If ((typedExpressionIR'? matches pattern (_))), then

      1. (Let ?(typedExpressionIR_cast) be typedExpressionIR'?)

      2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR_cast)

      3. If ((ctk matches pattern `LCTK`)), then

        1. (Eval_static: (block) TC_0 |- typedExpressionIR_cast ~> value)

        2. (Let nameIR be $name(name))

        3. (Let typeIR_enum be ((enum nameIR_enum # typeIR { [] }) as typeIR))

        4. (Let value_enum be ((nameIR_enum . nameIR # value) as value))

        5. (Let TC_1 be $add_var((block), TC_0, nameIR, (() typeIR_enum (lctk) ?(value_enum))))

        6. Result in TC_1, (nameIR = typedExpressionIR_cast), value

  }

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:646.1-649.26
relation Enum_serializable_fields_ok: 

  nil: TC nameIR_enum typeIR |- namedExpression*{namedExpression <- namedExpression*} : % % # % {

    1. If ((namedExpression* matches pattern [])), then

      1. Result in TC, [], []

  }

  cons: TC_0 nameIR_enum typeIR |- namedExpression*{namedExpression <- namedExpression*} : % % # % {

    1. If ((namedExpression* matches pattern _ :: _)), then

      1. (Let namedExpression_h :: namedExpression_t* be namedExpression*)

      2. (Enum_serializable_field_ok: TC_0 nameIR_enum typeIR |- namedExpression_h : TC_1 namedExpressionIR_h # value_field_h)

      3. (Enum_serializable_fields_ok: TC_1 nameIR_enum typeIR |- namedExpression_t* : TC_2 namedExpressionIR_t* # value_field_t*)

      4. (Let namedExpressionIR* be namedExpressionIR_h :: namedExpressionIR_t*)

      5. (Let value_field* be value_field_h :: value_field_t*)

      6. Result in TC_2, namedExpressionIR*, value_field*

  }

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:33.1-35.23
relation SelectCase_keyset_simple_ok: 

  expression-set-alpha: TC typeIR_key |- simpleKeysetExpression : % {

    1. If ((simpleKeysetExpression has type expression)), then

      1. (Let expression be (simpleKeysetExpression as expression))

      2. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      3. (Let (_expressionIR # (( typeIR'' _ctk ))) be typedExpressionIR)

      4. If ((typeIR'' has type setTypeIR)), then

        1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

        2. If ((typeIR'* matches pattern [ _/1 ])), then

          1. (Let [typeIR] be typeIR'*)

          2. If ((Type_alpha: typeIR ~~ typeIR_key holds)), then

            1. Result in (typedExpressionIR as simpleKeysetExpressionIR)

  }

  expression-set-subtype: TC typeIR_key |- simpleKeysetExpression : % {

    1. If ((simpleKeysetExpression has type expression)), then

      1. (Let expression be (simpleKeysetExpression as expression))

      2. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      3. (Let (_expressionIR # (( typeIR'' _ctk ))) be typedExpressionIR)

      4. If ((typeIR'' has type setTypeIR)), then

        1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

        2. If ((typeIR'* matches pattern [ _/1 ])), then

          1. (Let [typeIR] be typeIR'*)

          2. If (~(Type_alpha: typeIR ~~ typeIR_key holds)), then

            1. If ((Sub_impl: typeIR <: typeIR_key holds)), then

              1. (Let typeIR_cast be ((set< [typeIR_key] >) as typeIR))

              2. (Let typedExpressionIR_cast be (((( typeIR_cast ) typedExpressionIR) as expressionIR) # (( typeIR_cast (dyn) ))))

              3. Result in (typedExpressionIR_cast as simpleKeysetExpressionIR)

  }

  expression-non-set: TC typeIR_key |- simpleKeysetExpression : % {

    1. If ((simpleKeysetExpression has type expression)), then

      1. (Let expression be (simpleKeysetExpression as expression))

      2. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      3. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

      4. If (~$is_set_typeIR(typeIR)), then

        1. If ((Sub_impl: typeIR <: typeIR_key holds)), then

          1. (Let typeIR_cast be ((set< [typeIR_key] >) as typeIR))

          2. (Let typedExpressionIR_cast be (((( typeIR_cast ) typedExpressionIR) as expressionIR) # (( typeIR_cast (dyn) ))))

          3. Result in (typedExpressionIR_cast as simpleKeysetExpressionIR)

  }

  mask: TC typeIR_key |- simpleKeysetExpression : % {

    1. If ((simpleKeysetExpression matches pattern `%&&&%`)), then

      1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

      2. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

      3. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

      4. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      5. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask))

        3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

          2. (Let (_expressionIR # (( typeIR_reduced _ctk ))) be typedExpressionIR_l_reduced)

          3. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_l_reduced, typeIR_key))

          4. If ((typedExpressionIR? matches pattern (_))), then

            1. (Let ?(typedExpressionIR_l_coerced) be typedExpressionIR?)

            2. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR_r_reduced, typeIR_key))

            3. If ((typedExpressionIR'? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_r_coerced) be typedExpressionIR'?)

              2. Result in (typedExpressionIR_l_coerced &&& typedExpressionIR_r_coerced)

  }

  range: TC typeIR_key |- simpleKeysetExpression : % {

    1. If ((simpleKeysetExpression matches pattern `%..%`)), then

      1. (Let (expression_l .. expression_r) be simpleKeysetExpression)

      2. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

      3. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

      4. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      5. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range))

        3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

          2. (Let (_expressionIR # (( typeIR_reduced _ctk ))) be typedExpressionIR_l_reduced)

          3. (Let (_expressionIR' # (( typeIR _ctk' ))) be typedExpressionIR_r_reduced)

          4. If ((typeIR = typeIR_reduced)), then

            1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_l_reduced, typeIR_key))

            2. If ((typedExpressionIR? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_l_coerced) be typedExpressionIR?)

              2. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR_r_reduced, typeIR_key))

              3. If ((typedExpressionIR'? matches pattern (_))), then

                1. (Let ?(typedExpressionIR_r_coerced) be typedExpressionIR'?)

                2. Result in (typedExpressionIR_l_coerced .. typedExpressionIR_r_coerced)

  }

  default: TC typeIR_key |- simpleKeysetExpression : % {

    1. If ((simpleKeysetExpression matches pattern `DEFAULT`)), then

      1. Result in (default)

  }

  dontcare: TC typeIR_key |- simpleKeysetExpression : % {

    1. If ((simpleKeysetExpression matches pattern `_`)), then

      1. Result in (_)

  }

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:76.1-76.40
def $compat_mask(typeIR_l, typeIR_r)

1. Return $compat'_mask($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:77.1-77.41
def $compat'_mask(typeIR'', typeIR''')

1. If ((typeIR'' = ((int) as typeIR))), then

  1. If ((typeIR''' = ((int) as typeIR))), then

    1. Return true

2. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT<%>`)), then

          1. (Let (int< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

          1. (Let (bit< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:113.1-113.41
def $compat_range(typeIR_l, typeIR_r)

1. Return $compat'_range($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:114.1-114.42
def $compat'_range(typeIR'', typeIR''')

1. If ((typeIR'' = ((int) as typeIR))), then

  1. If ((typeIR''' = ((int) as typeIR))), then

    1. Return true

2. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `INT<%>`)), then

          1. (Let (int< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< w >) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

          1. (Let (bit< w' >) be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:161.1-163.23
relation SelectCase_keyset_ok: 

  simpleKeysetExpression-expression: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : % {

    1. If ((typeIR* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR*)

      2. If ((keysetExpression has type expression)), then

        1. (Let expression be (keysetExpression as expression))

        2. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression as simpleKeysetExpression) : simpleKeysetExpressionIR)

        3. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

  }

  simpleKeysetExpression-mask: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : % {

    1. If ((typeIR* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR*)

      2. If ((keysetExpression has type simpleKeysetExpression)), then

        1. (Let simpleKeysetExpression be (keysetExpression as simpleKeysetExpression))

        2. If ((simpleKeysetExpression matches pattern `%&&&%`)), then

          1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

          2. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression_l &&& expression_r) : simpleKeysetExpressionIR)

          3. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

  }

  simpleKeysetExpression-range: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : % {

    1. If ((typeIR* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR*)

      2. If ((keysetExpression has type simpleKeysetExpression)), then

        1. (Let simpleKeysetExpression be (keysetExpression as simpleKeysetExpression))

        2. If ((simpleKeysetExpression matches pattern `%..%`)), then

          1. (Let (expression_l .. expression_r) be simpleKeysetExpression)

          2. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression_l .. expression_r) : simpleKeysetExpressionIR)

          3. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

  }

  simpleKeysetExpression-default: TC typeIR'*{typeIR' <- typeIR'*} |- keysetExpression : % {

    1. Case analysis on typeIR'*

      1. Case (% matches pattern [])

        1. If ((keysetExpression = ((default) as keysetExpression))), then

          1. Result in ((default) as keysetExpressionIR)

      2. Case (% matches pattern [ _/1 ])

        1. (Let [typeIR_key] be typeIR'*)

        2. If ((keysetExpression = ((default) as keysetExpression))), then

          1. (SelectCase_keyset_simple_ok: TC typeIR_key |- (default) : simpleKeysetExpressionIR)

          2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

    2. If ((keysetExpression = ((default) as keysetExpression))), then

      1. If ((|typeIR'*| > 1)), then

        1. (SelectCase_keyset_simple_ok: TC ((seq< typeIR'* >) as typeIR) |- (default) : simpleKeysetExpressionIR)

        2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

  }

  simpleKeysetExpression-dontcare: TC typeIR'*{typeIR' <- typeIR'*} |- keysetExpression : % {

    1. If ((typeIR'* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR'*)

      2. If ((keysetExpression = ((_) as keysetExpression))), then

        1. (SelectCase_keyset_simple_ok: TC typeIR_key |- (_) : simpleKeysetExpressionIR)

        2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

    2. If ((keysetExpression = ((_) as keysetExpression))), then

      1. If ((|typeIR'*| > 1)), then

        1. (SelectCase_keyset_simple_ok: TC ((seq< typeIR'* >) as typeIR) |- (_) : simpleKeysetExpressionIR)

        2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

  }

  tupleKeysetExpression-mask: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : % {

    1. If ((typeIR* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR*)

      2. If ((keysetExpression has type tupleKeysetExpression)), then

        1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

        2. If ((tupleKeysetExpression matches pattern `(%&&&%)`)), then

          1. (Let (( expression_l &&& expression_r )) be tupleKeysetExpression)

          2. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression_l &&& expression_r) : simpleKeysetExpressionIR)

          3. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

  }

  tupleKeysetExpression-range: TC typeIR*{typeIR <- typeIR*} |- keysetExpression : % {

    1. If ((typeIR* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR*)

      2. If ((keysetExpression has type tupleKeysetExpression)), then

        1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

        2. If ((tupleKeysetExpression matches pattern `(%..%)`)), then

          1. (Let (( expression_l .. expression_r )) be tupleKeysetExpression)

          2. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression_l .. expression_r) : simpleKeysetExpressionIR)

          3. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

  }

  tupleKeysetExpression-default: TC typeIR'*{typeIR' <- typeIR'*} |- keysetExpression : % {

    1. If ((typeIR'* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR'*)

      2. If ((keysetExpression = (((default)) as keysetExpression))), then

        1. (SelectCase_keyset_simple_ok: TC typeIR_key |- (default) : simpleKeysetExpressionIR)

        2. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

    2. If ((keysetExpression = (((default)) as keysetExpression))), then

      1. If ((|typeIR'*| > 1)), then

        1. (SelectCase_keyset_simple_ok: TC ((seq< typeIR'* >) as typeIR) |- (default) : simpleKeysetExpressionIR)

        2. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

  }

  tupleKeysetExpression-dontcare: TC typeIR'*{typeIR' <- typeIR'*} |- keysetExpression : % {

    1. If ((typeIR'* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR'*)

      2. If ((keysetExpression = (((_)) as keysetExpression))), then

        1. (SelectCase_keyset_simple_ok: TC typeIR_key |- (_) : simpleKeysetExpressionIR)

        2. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

    2. If ((keysetExpression = (((_)) as keysetExpression))), then

      1. If ((|typeIR'*| > 1)), then

        1. (SelectCase_keyset_simple_ok: TC ((seq< typeIR'* >) as typeIR) |- (_) : simpleKeysetExpressionIR)

        2. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

  }

  tupleKeysetExpression-list: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : % {

    1. If ((keysetExpression has type tupleKeysetExpression)), then

      1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

      2. If ((tupleKeysetExpression matches pattern `(%,%)`)), then

        1. (Let (( simpleKeysetExpression_h , simpleKeysetExpressionList_t )) be tupleKeysetExpression)

        2. (Let simpleKeysetExpression_t* be $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t))

        3. (Let simpleKeysetExpression* be simpleKeysetExpression_h :: simpleKeysetExpression_t*)

        4. If ((|typeIR_key*| = |simpleKeysetExpression*|)), then

          1. (SelectCase_keyset_simple_ok: TC typeIR_key |- simpleKeysetExpression : simpleKeysetExpressionIR)*

          2. Result in ((( simpleKeysetExpressionIR* )) as keysetExpressionIR)

  }

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:294.1-296.26
relation SelectCase_ok: 

  : TC nameIR_state*{nameIR_state <- nameIR_state*} typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression : name ; : % {

    1. (SelectCase_keyset_ok: TC typeIR_key* |- keysetExpression : keysetExpressionIR)

    2. (Let nameIR be $name(name))

    3. If (nameIR is in nameIR_state*), then

      1. Result in (keysetExpressionIR : nameIR ;)

  }

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:7.1-7.52
def $compat_table_exact_optional_key(typeIR)

1. Return $compat'_table_exact_optional_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:8.1-8.53
def $compat'_table_exact_optional_key(typeIR'')

1. If ((typeIR'' = ((bool) as typeIR))), then

  1. Return true

2. If ((typeIR'' = ((error) as typeIR))), then

  1. Return true

3. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Return true

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $compat_table_exact_optional_key(typeIR'')

  3. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # typeIR'' { _valueFieldIR* }) be enumTypeIR)

        2. Return $compat_table_exact_optional_key(typeIR'')

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:21.1-21.55
def $compat_table_lpm_ternary_range_key(typeIR)

1. Return $compat'_table_lpm_ternary_range_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:22.1-22.56
def $compat'_table_lpm_ternary_range_key(typeIR'')

1. If ((typeIR'' = ((int) as typeIR))), then

  1. Return true

2. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR'') be aliasTypeIR)

      2. Return $compat_table_lpm_ternary_range_key(typeIR'')

  3. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # typeIR'' { _valueFieldIR* }) be enumTypeIR)

      2. Return $compat_table_lpm_ternary_range_key(typeIR'')

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:34.1-34.45
def $compat_table_key(nameIR, typeIR)

1. Case analysis on nameIR

  1. Case (% = "exact")

    1. If ($compat_table_exact_optional_key(typeIR)), then

      1. Return true

  2. Case (% = "optional")

    1. If ($compat_table_exact_optional_key(typeIR)), then

      1. Return true

  3. Case (% = "lpm")

    1. If ($compat_table_lpm_ternary_range_key(typeIR)), then

      1. Return true

  4. Case (% = "ternary")

    1. If ($compat_table_lpm_ternary_range_key(typeIR)), then

      1. Return true

  5. Case (% = "range")

    1. If ($compat_table_lpm_ternary_range_key(typeIR)), then

      1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:85.1-86.41
def $split_dataplane_parameters(parameterTypeIR*)

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. (Let (direction _typeIR _id _value?) be parameterTypeIR_h)

    3. Case analysis on (direction matches pattern ``EMPTY`)

      1. Case true

        1. (Let (parameterTypeIR_data*, parameterTypeIR_control*) be $split_dataplane_parameters(parameterTypeIR_t*))

        2. Return (parameterTypeIR_data*, parameterTypeIR_h :: parameterTypeIR_control*)

      2. Case false

        1. (Let (parameterTypeIR_data*, parameterTypeIR_control*) be $split_dataplane_parameters(parameterTypeIR_t*))

        2. Return (parameterTypeIR_h :: parameterTypeIR_data*, parameterTypeIR_control*)

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:236.1-239.26
relation TableEntry_keyset_simple_ok: 

  expression: TC TBLC |- (typeIR_key, text') @ simpleKeysetExpression : % % {

    1. If ((text' = "lpm")), then

      1. If ((simpleKeysetExpression has type expression)), then

        1. (Let expression be (simpleKeysetExpression as expression))

        2. (Let matchMode be TBLC.mode)

        3. If ((matchMode matches pattern `NOPRILPM%`)), then

          1. (Let (noprilpm n) be matchMode)

          2. (Expr_ok: (local) TC |- expression : typedExpressionIR)

          3. (Let (_expressionIR # (( typeIR ctk ))) be typedExpressionIR)

          4. If ((Sub_impl: typeIR <: typeIR_key holds)), then

            1. (Let typeIR_set be ((set< [typeIR_key] >) as typeIR))

            2. (Let typedExpressionIR_set be (((( typeIR_set ) typedExpressionIR) as expressionIR) # (( typeIR_set ctk ))))

            3. Result in (lpm n), (typedExpressionIR_set as simpleKeysetExpressionIR)

    2. If ((simpleKeysetExpression has type expression)), then

      1. (Let expression be (simpleKeysetExpression as expression))

      2. If ((text' =/= "lpm")), then

        1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

        2. (Let (_expressionIR # (( typeIR ctk ))) be typedExpressionIR)

        3. If ((Sub_impl: typeIR <: typeIR_key holds)), then

          1. (Let typeIR_set be ((set< [typeIR_key] >) as typeIR))

          2. (Let typedExpressionIR_set be (((( typeIR_set ) typedExpressionIR) as expressionIR) # (( typeIR_set ctk ))))

          3. Result in (nolpm), (typedExpressionIR_set as simpleKeysetExpressionIR)

  }

  mask: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : % % {

    1. Case analysis on text

      1. Case (% = "lpm")

        1. If ((simpleKeysetExpression matches pattern `%&&&%`)), then

          1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

          2. (Let matchMode be TBLC.mode)

          3. If ((matchMode matches pattern `NOPRILPM%`)), then

            1. (Let (noprilpm n) be matchMode)

            2. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

            3. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

            4. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

            5. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

              1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

              2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask))

              3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

                1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

                2. (Let (_expressionIR # (( typeIR_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

                3. If ((Sub_impl: typeIR_reduced <: typeIR_key holds)), then

                  1. If ((ctk_r_reduced matches pattern `LCTK`)), then

                    1. (Eval_static: (local) TC |- typedExpressionIR_r_reduced ~> value_r)

                    2. (Let i_r be $to_number(value_r))

                    3. (Let n_prefix be $tableEntry_lpm_prefix(((n w $to_bitstr((n as int), i_r)) as value)))

                    4. Result in (lpm n_prefix), (typedExpressionIR_l_reduced &&& typedExpressionIR_r_reduced)

      2. Case (% = "ternary")

        1. If ((simpleKeysetExpression matches pattern `%&&&%`)), then

          1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

          2. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

          3. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

          4. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

          5. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

            2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask))

            3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

              1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

              2. (Let (_expressionIR # (( typeIR_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

              3. If ((Sub_impl: typeIR_reduced <: typeIR_key holds)), then

                1. Result in (nolpm), (typedExpressionIR_l_reduced &&& typedExpressionIR_r_reduced)

  }

  range-range: TC TBLC |- (typeIR_key, text) @ simpleKeysetExpression : % % {

    1. If ((text = "range")), then

      1. If ((simpleKeysetExpression matches pattern `%..%`)), then

        1. (Let (expression_l .. expression_r) be simpleKeysetExpression)

        2. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

        3. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

        4. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        5. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            3. If ((Sub_impl: typeIR_reduced <: typeIR_key holds)), then

              1. Result in (nolpm), (typedExpressionIR_l_reduced .. typedExpressionIR_r_reduced)

  }

  default: TC TBLC |- (typeIR_key, text') @ simpleKeysetExpression : % % {

    1. If ((text' = "lpm")), then

      1. If ((simpleKeysetExpression matches pattern `DEFAULT`)), then

        1. (Let matchMode be TBLC.mode)

        2. If ((matchMode matches pattern `NOPRILPM%`)), then

          1. (Let (noprilpm n) be matchMode)

          2. Result in (lpm n), (default)

    2. If ((simpleKeysetExpression matches pattern `DEFAULT`)), then

      1. If ((text' =/= "lpm")), then

        1. If ((text' =/= "exact")), then

          1. Result in (nolpm), (default)

  }

  dontcare: TC TBLC |- (typeIR_key, text') @ simpleKeysetExpression : % % {

    1. If ((text' = "lpm")), then

      1. If ((simpleKeysetExpression matches pattern `_`)), then

        1. (Let matchMode be TBLC.mode)

        2. If ((matchMode matches pattern `NOPRILPM%`)), then

          1. (Let (noprilpm _nat) be matchMode)

          2. Result in (lpm 0), (_)

    2. If ((simpleKeysetExpression matches pattern `_`)), then

      1. If ((text' =/= "lpm")), then

        1. If ((text' =/= "exact")), then

          1. Result in (nolpm), (_)

  }

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:396.1-399.29
relation TableEntry_keysets_simple_ok: 

  nil: TC TBLC TBLS |- matchKey*{matchKey <- matchKey*} @ simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} : % % {

    1. If ((matchKey* matches pattern [])), then

      1. If ((simpleKeysetExpression* matches pattern [])), then

        1. Result in TBLS, []

  }

  cons: TC TBLC TBLS_0 |- matchKey*{matchKey <- matchKey*} @ simpleKeysetExpression*{simpleKeysetExpression <- simpleKeysetExpression*} : % % {

    1. If ((matchKey* matches pattern _ :: _)), then

      1. (Let matchKey_h :: matchKey_t* be matchKey*)

      2. If ((simpleKeysetExpression* matches pattern _ :: _)), then

        1. (Let simpleKeysetExpression_h :: simpleKeysetExpression_t* be simpleKeysetExpression*)

        2. (TableEntry_keyset_simple_ok: TC TBLC |- matchKey_h @ simpleKeysetExpression_h : TBLS_1 simpleKeysetExpressionIR_h)

        3. (Let TBLS_2 be $join_tableEntryState(TBLS_0, TBLS_1))

        4. (TableEntry_keysets_simple_ok: TC TBLC TBLS_2 |- matchKey_t* @ simpleKeysetExpression_t* : TBLS_3 simpleKeysetExpressionIR_t*)

        5. Result in TBLS_3, simpleKeysetExpressionIR_h :: simpleKeysetExpressionIR_t*

  }

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:948.1-948.44
def $count_table_keys(tableProperty''*)

1. Case analysis on tableProperty''*

  1. Case (% matches pattern [])

    1. Return 0

  2. Case (% matches pattern _ :: _)

    1. (Let tableProperty'' :: tableProperty_t* be tableProperty''*)

    2. If ((tableProperty'' matches pattern `KEY={%}`)), then

      1. (Let (key={ _tableKeyList }) be tableProperty'')

      2. Return (1 + $count_table_keys(tableProperty_t*))

    3. (Let tableProperty_h :: tableProperty_t* be tableProperty''*)

    4. Otherwise

      1. Return $count_table_keys(tableProperty_t*)

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:961.1-961.47
def $count_table_actions(tableProperty''*)

1. Case analysis on tableProperty''*

  1. Case (% matches pattern [])

    1. Return 0

  2. Case (% matches pattern _ :: _)

    1. (Let tableProperty'' :: tableProperty_t* be tableProperty''*)

    2. If ((tableProperty'' matches pattern `ACTIONS={%}`)), then

      1. (Let (actions={ _tableActionList }) be tableProperty'')

      2. Return (1 + $count_table_actions(tableProperty_t*))

    3. (Let tableProperty_h :: tableProperty_t* be tableProperty''*)

    4. Otherwise

      1. Return $count_table_actions(tableProperty_t*)

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:7.1-7.73
def $filter_default_parameters(parameterTypeIR*, id_default*)

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. (Let (_direction _typeIR id_h _value?) be parameterTypeIR_h)

    3. If (id_h is in id_default*), then

      1. Return $filter_default_parameters(parameterTypeIR_t*, id_default*)

    4. Otherwise

      1. Return parameterTypeIR_h :: $filter_default_parameters(parameterTypeIR_t*, id_default*)

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:26.1-26.71
def $align_parameters(parameterTypeIR*, argumentIR*)

1. (Let (_direction _typeIR id _value?) be parameterTypeIR)*

2. (Let parameterTypeIR'? be $align_parameters'(({ (id : parameterTypeIR)* }), parameterTypeIR, argumentIR))*

3. If ((parameterTypeIR'? matches pattern (_)))*, then

  1. (Let ?(parameterTypeIR_aligned) be parameterTypeIR'?)*

  2. Return parameterTypeIR_aligned*

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:27.1-27.96
def $align_parameters'(_map<id, parameterTypeIR>', parameterTypeIR', argumentIR)

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. Return ?(parameterTypeIR')

2. (Let ({ (id_param : parameterTypeIR')* }) be _map<id, parameterTypeIR>')

3. Case analysis on argumentIR

  1. Case (% matches pattern `%=%`)

    1. (Let (nameIR = _typedExpressionIR) be argumentIR)

    2. Return $find_map<id, parameterTypeIR>(({ (id_param : parameterTypeIR')* }), nameIR)

  2. Case (% matches pattern `%=_`)

    1. (Let (nameIR =_) be argumentIR)

    2. Return $find_map<id, parameterTypeIR>(({ (id_param : parameterTypeIR')* }), nameIR)

  3. Case (% matches pattern `_`)

    1. Return ?(parameterTypeIR')

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:60.1-62.23
relation Expr_lvalue_ok: 

  referenceExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) {

    1. If ((expressionIR has type prefixedNameIR)), then

      1. (Let prefixedNameIR be (expressionIR as prefixedNameIR))

      2. (Let varTypeIR? be $find_var(p, TC, prefixedNameIR))

      3. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((direction _typeIR' ctk _value?)) be varTypeIR?)

        2. If ((ctk matches pattern `DYN`)), then

          1. If (((direction = (out)) \/ (direction = (inout)))), then

            1. The relation holds

  }

  accessExpressionIR-memberAccessExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) {

    1. If ((expressionIR has type memberAccessExpressionIR)), then

      1. (Let (memberAccessBaseIR . nameIR) be (expressionIR as memberAccessExpressionIR))

      2. If ((memberAccessBaseIR has type typedExpressionIR)), then

        1. (Let typedExpressionIR_base be (memberAccessBaseIR as typedExpressionIR))

        2. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_base holds)), then

          1. (Let (_expressionIR # (( typeIR_base _ctk' ))) be typedExpressionIR_base)

          2. (Let typeIR' be $canon(typeIR_base))

          3. If ((typeIR' has type headerStackTypeIR)), then

            1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

            2. If (((nameIR = "next") \/ (nameIR = "last"))), then

              1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

                1. The relation holds

          4. If (~$is_headerStackTypeIR($canon(typeIR_base))), then

            1. The relation holds

  }

  accessExpressionIR-indexAccessExpressionIR: p TC |- expressionIR # ( _typeIR _ctk ) {

    1. If ((expressionIR has type indexAccessExpressionIR)), then

      1. (Let indexAccessExpressionIR be (expressionIR as indexAccessExpressionIR))

      2. If ((indexAccessExpressionIR matches pattern `%[%]`)), then

        1. (Let (typedExpressionIR_base [ typedExpressionIR_index ]) be indexAccessExpressionIR)

        2. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_base holds)), then

          1. The relation holds

  }

  accessExpressionIR-indexAccessExpressionIR-bitslice: p TC |- expressionIR # ( _typeIR _ctk ) {

    1. If ((expressionIR has type indexAccessExpressionIR)), then

      1. (Let indexAccessExpressionIR be (expressionIR as indexAccessExpressionIR))

      2. If ((indexAccessExpressionIR matches pattern `%[%:%]`)), then

        1. (Let (typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ]) be indexAccessExpressionIR)

        2. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_base holds)), then

          1. The relation holds

  }

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:6.1-7.12
syntax infer = 
   | knownas typeIR
   | unknown

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:9.21-9.36
syntax constraint = map<tid, infer>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:11.1-11.41
def $empty_constraint(tid*)

1. Return ({ (tid : (unknown))* })

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:14.20-14.36
syntax inference = map<tid, typeIR>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:20.1-20.60
def $infer(tid_infer*, parameterTypeIR*, argumentIR*)

1. (Let constraint_init be $empty_constraint(tid_infer*))

2. (Let constraint_pair be $infer'(constraint_init, parameterTypeIR, argumentIR))*

3. (Let constraint_inferred be $merge_constraints(constraint_init, constraint_pair*))

4. (Let inference be $resolve_constraint(constraint_inferred))

5. Return inference

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:21.1-21.66
def $infer'(constraint, parameterTypeIR, argumentIR)

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. (Let (_direction typeIR_param _id _value?) be parameterTypeIR)

  3. (Let (_expressionIR # (( typeIR_arg _ctk ))) be typedExpressionIR)

  4. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

2. Case analysis on argumentIR

  1. Case (% matches pattern `%=%`)

    1. (Let (nameIR = typedExpressionIR) be argumentIR)

    2. (Let (_direction typeIR_param _id _value?) be parameterTypeIR)

    3. (Let (_expressionIR # (( typeIR_arg _ctk ))) be typedExpressionIR)

    4. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

  2. Case (% matches pattern `%=_`)

    1. (Let (nameIR =_) be argumentIR)

    2. Return constraint

  3. Case (% matches pattern `_`)

    1. Return constraint

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:23.1-23.66
def $gen_constraint_type(constraint', typeIR'', typeIR_arg')

1. Case analysis on typeIR''

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `TID%`)

        1. (Let (tid tid_param) be namedTypeIR)

        2. If ($in_set<tid>(tid_param, $dom_map<tid, infer>(constraint'))), then

          1. Return $update_map<tid, infer>(constraint', tid_param, (knownas typeIR_arg'))

      2. Case (% matches pattern `%<%>`)

        1. (Let (polyTypeDefIR_param < typeIR_param* >) be namedTypeIR)

        2. If ((typeIR_arg' has type namedTypeIR)), then

          1. (Let namedTypeIR' be (typeIR_arg' as namedTypeIR))

          2. If ((namedTypeIR' matches pattern `%<%>`)), then

            1. (Let (polyTypeDefIR_arg < typeIR_arg'* >) be namedTypeIR')

            2. (Let typeIR_specialized_param be $specialize_typeDef((polyTypeDefIR_param as typeDefIR), typeIR_param*))

            3. (Let typeIR_specialized_arg be $specialize_typeDef((polyTypeDefIR_arg as typeDefIR), typeIR_arg'*))

            4. If (($is_nominal_typeIR(typeIR_specialized_param) /\ $is_nominal_typeIR(typeIR_specialized_arg))), then

              1. (Let constraint_1 be $gen_constraint_type(constraint', typeIR_specialized_param, typeIR_specialized_arg))

              2. (Let constraint_2 be $gen_constraint_types(constraint_1, typeIR_param*, typeIR_arg'*))

              3. Return constraint_2

            5. If ((~$is_nominal_typeIR(typeIR_specialized_param) /\ ~$is_nominal_typeIR(typeIR_specialized_arg))), then

              1. (Let constraint_1 be $gen_constraint_type(constraint', typeIR_specialized_param, typeIR_specialized_arg))

              2. Return constraint_1

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `TYPEDEF%%`)

        1. (Let (typedef _tid typeIR_param) be aliasTypeIR)

        2. Return $gen_constraint_type(constraint', typeIR_param, typeIR_arg')

      2. Case (% matches pattern `TYPE%%`)

        1. (Let (type tid typeIR'') be aliasTypeIR)

        2. If ((typeIR_arg' has type aliasTypeIR)), then

          1. (Let aliasTypeIR' be (typeIR_arg' as aliasTypeIR))

          2. If ((aliasTypeIR' matches pattern `TYPE%%`)), then

            1. (Let (type tid' typeIR_arg') be aliasTypeIR')

            2. If ((tid = tid')), then

              1. Return $gen_constraint_type(constraint', typeIR'', typeIR_arg')

  3. Case (% has type listTypeIR)

    1. (Let (list< typeIR'' >) be (typeIR'' as listTypeIR))

    2. If ((typeIR_arg' has type listTypeIR)), then

      1. (Let (list< typeIR_arg' >) be (typeIR_arg' as listTypeIR))

      2. Return $gen_constraint_type(constraint', typeIR'', typeIR_arg')

  4. Case (% has type tupleTypeIR)

    1. (Let (tuple< typeIR''* >) be (typeIR'' as tupleTypeIR))

    2. If ((typeIR_arg' has type tupleTypeIR)), then

      1. (Let (tuple< typeIR_arg'* >) be (typeIR_arg' as tupleTypeIR))

      2. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

  5. Case (% has type headerStackTypeIR)

    1. (Let (typeIR'' [ n_size ]) be (typeIR'' as headerStackTypeIR))

    2. If ((typeIR_arg' has type headerStackTypeIR)), then

      1. (Let (typeIR_arg' [ n_size' ]) be (typeIR_arg' as headerStackTypeIR))

      2. If ((n_size = n_size')), then

        1. Return $gen_constraint_type(constraint', typeIR'', typeIR_arg')

  6. Case (% has type structTypeIR)

    1. (Let (struct tid { (typeIR'' id_field ;)* }) be (typeIR'' as structTypeIR))

    2. If ((typeIR_arg' has type structTypeIR)), then

      1. (Let (struct tid' { (typeIR_arg' id_field' ;)* }) be (typeIR_arg' as structTypeIR))

      2. If ((id_field = id_field'))*, then

        1. If ((tid = tid')), then

          1. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

  7. Case (% has type headerTypeIR)

    1. (Let (header tid { (typeIR'' id_field ;)* }) be (typeIR'' as headerTypeIR))

    2. If ((typeIR_arg' has type headerTypeIR)), then

      1. (Let (header tid' { (typeIR_arg' id_field' ;)* }) be (typeIR_arg' as headerTypeIR))

      2. If ((id_field = id_field'))*, then

        1. If ((tid = tid')), then

          1. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

  8. Case (% has type headerUnionTypeIR)

    1. (Let (header_union tid { (typeIR'' id_field ;)* }) be (typeIR'' as headerUnionTypeIR))

    2. If ((typeIR_arg' has type headerUnionTypeIR)), then

      1. (Let (header_union tid' { (typeIR_arg' id_field' ;)* }) be (typeIR_arg' as headerUnionTypeIR))

      2. If ((id_field = id_field'))*, then

        1. If ((tid = tid')), then

          1. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

  9. Case (% has type externObjectTypeIR)

    1. (Let (extern tid ({ (rid : routineTypeDefIR_param)* })) be (typeIR'' as externObjectTypeIR))

    2. If ((typeIR_arg' has type externObjectTypeIR)), then

      1. (Let (extern tid' ({ (rid' : routineTypeDefIR_arg)* })) be (typeIR_arg' as externObjectTypeIR))

      2. If ((rid = rid'))*, then

        1. If ((tid = tid')), then

          1. Return $gen_constraint_routines(constraint', routineTypeDefIR_param*, routineTypeDefIR_arg*)

  10. Case (% has type parserObjectTypeIR)

    1. (Let (parser( parameterTypeIR_param* )) be (typeIR'' as parserObjectTypeIR))

    2. If ((typeIR_arg' has type parserObjectTypeIR)), then

      1. (Let (parser( parameterTypeIR_arg* )) be (typeIR_arg' as parserObjectTypeIR))

      2. (Let (direction typeIR'' _id _value?) be parameterTypeIR_param)*

      3. (Let (direction' typeIR_arg' _id' _value'?) be parameterTypeIR_arg)*

      4. If ((direction' = direction))*, then

        1. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

  11. Case (% has type controlObjectTypeIR)

    1. (Let (control( parameterTypeIR_param* )) be (typeIR'' as controlObjectTypeIR))

    2. If ((typeIR_arg' has type controlObjectTypeIR)), then

      1. (Let (control( parameterTypeIR_arg* )) be (typeIR_arg' as controlObjectTypeIR))

      2. (Let (direction typeIR'' _id _value?) be parameterTypeIR_param)*

      3. (Let (direction' typeIR_arg' _id' _value'?) be parameterTypeIR_arg)*

      4. If ((direction' = direction))*, then

        1. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

  12. Case (% has type packageObjectTypeIR)

    1. (Let (package< typeIR''* >) be (typeIR'' as packageObjectTypeIR))

    2. If ((typeIR_arg' has type packageObjectTypeIR)), then

      1. (Let (package< typeIR_arg'* >) be (typeIR_arg' as packageObjectTypeIR))

      2. Return $gen_constraint_types(constraint', typeIR''*, typeIR_arg'*)

2. If ((typeIR_arg' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR_arg' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

    1. (Let (typedef _tid typeIR_arg') be aliasTypeIR)

    2. Return $gen_constraint_type(constraint', typeIR'', typeIR_arg')

3. Otherwise

  1. Return constraint'

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:24.1-24.69
def $gen_constraint_types(constraint, typeIR_param*, typeIR_arg*)

1. (Let constraint_pair be $gen_constraint_type(constraint, typeIR_param, typeIR_arg))*

2. Return $merge_constraints(constraint, constraint_pair*)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:25.1-28.15
def $gen_constraint_routine(constraint_0, routineTypeDefIR, routineTypeDefIR')

1. If ((routineTypeDefIR has type polyRoutineTypeDefIR)), then

  1. (Let (routineTypeIR < _tid* , _tid'* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

  2. If ((routineTypeIR has type methodTypeIR)), then

    1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( parameterTypeIR_param* )-> typeIR_ret_param) be methodTypeIR)

        2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

          1. (Let (routineTypeIR' < _tid''* , _tid'''* >) be (routineTypeDefIR' as polyRoutineTypeDefIR))

          2. If ((routineTypeIR' has type methodTypeIR)), then

            1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

            2. If ((methodTypeIR' matches pattern `EXTERN_METHOD(%)->%`)), then

              1. (Let (extern_method( parameterTypeIR_arg* )-> typeIR_ret_arg) be methodTypeIR')

              2. (Let (direction typeIR_param _id _value?) be parameterTypeIR_param)*

              3. (Let (direction' typeIR_arg _id' _value'?) be parameterTypeIR_arg)*

              4. If ((direction' = direction))*, then

                1. (Let constraint_1 be $gen_constraint_types(constraint_0, typeIR_param*, typeIR_arg*))

                2. (Let constraint_2 be $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg))

                3. Return constraint_2

      2. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( parameterTypeIR_param* )-> typeIR_ret_param) be methodTypeIR)

        2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

          1. (Let (routineTypeIR' < _tid''* , _tid'''* >) be (routineTypeDefIR' as polyRoutineTypeDefIR))

          2. If ((routineTypeIR' has type methodTypeIR)), then

            1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

            2. If ((methodTypeIR' matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

              1. (Let (extern_methodabstract( parameterTypeIR_arg* )-> typeIR_ret_arg) be methodTypeIR')

              2. (Let (direction typeIR_param _id _value?) be parameterTypeIR_param)*

              3. (Let (direction' typeIR_arg _id' _value'?) be parameterTypeIR_arg)*

              4. If ((direction' = direction))*, then

                1. (Let constraint_1 be $gen_constraint_types(constraint_0, typeIR_param*, typeIR_arg*))

                2. (Let constraint_2 be $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg))

                3. Return constraint_2

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:29.1-32.15
def $gen_constraint_routines(constraint, routineTypeDefIR_param*, routineTypeDefIR_arg*)

1. (Let constraint_pair be $gen_constraint_routine(constraint, routineTypeDefIR_param, routineTypeDefIR_arg))*

2. Return $merge_constraints(constraint, constraint_pair*)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:34.1-34.59
def $merge_constraint(constraint_pre, constraint_post)

1. (Let ({ tid_pre* }) be $dom_map<tid, infer>(constraint_pre))

2. (Let ({ tid_post* }) be $dom_map<tid, infer>(constraint_post))

3. If ($eq_set<tid>(({ tid_pre* }), ({ tid_post* }))), then

  1. Return $merge_constraint'(constraint_pre, constraint_post, tid_pre*, ({ [] }))

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:35.1-35.78
def $merge_constraint'(constraint_pre, constraint_post, tid*, constraint)

1. Case analysis on tid*

  1. Case (% matches pattern [])

    1. Return constraint

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t* be tid*)

    2. If ((?((unknown)) = $find_map<tid, infer>(constraint_pre, tid_h))), then

      1. If ((?((unknown)) = $find_map<tid, infer>(constraint_post, tid_h))), then

        1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (unknown)))

        2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

      2. (Let infer'? be $find_map<tid, infer>(constraint_post, tid_h))

      3. If ((infer'? matches pattern (_))), then

        1. (Let ?(infer) be infer'?)

        2. If ((infer matches pattern `KNOWNAS%`)), then

          1. (Let (knownas typeIR_post) be infer)

          2. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (knownas typeIR_post)))

          3. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

    3. (Let infer'? be $find_map<tid, infer>(constraint_pre, tid_h))

    4. If ((infer'? matches pattern (_))), then

      1. (Let ?(infer) be infer'?)

      2. If ((infer matches pattern `KNOWNAS%`)), then

        1. (Let (knownas typeIR_pre) be infer)

        2. If ((?((unknown)) = $find_map<tid, infer>(constraint_post, tid_h))), then

          1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (knownas typeIR_pre)))

          2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

        3. (Let infer'''? be $find_map<tid, infer>(constraint_post, tid_h))

        4. If ((infer'''? matches pattern (_))), then

          1. (Let ?(infer'') be infer'''?)

          2. If ((infer'' matches pattern `KNOWNAS%`)), then

            1. (Let (knownas typeIR_post) be infer'')

            2. Case analysis on (Sub_impl: typeIR_pre <: typeIR_post holds)

              1. Case true

                1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (knownas typeIR_post)))

                2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

              2. Case false

                1. If ((Sub_impl: typeIR_post <: typeIR_pre holds)), then

                  1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (knownas typeIR_pre)))

                  2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:36.1-36.61
def $merge_constraints(constraint_pre', constraint*)

1. Case analysis on constraint*

  1. Case (% matches pattern [])

    1. Return constraint_pre'

  2. Case (% matches pattern _ :: _)

    1. (Let constraint_post_h :: constraint_post_t* be constraint*)

    2. (Let constraint_pre_1 be $merge_constraint(constraint_pre', constraint_post_h))

    3. (Let constraint_pre_2 be $merge_constraints(constraint_pre_1, constraint_post_t*))

    4. Return constraint_pre_2

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:38.1-38.48
def $resolve_constraint(({ (tid : infer)* }))

1. If ((infer matches pattern `KNOWNAS%`))*, then

  1. (Let (knownas typeIR) be infer)*

  2. Return ({ (tid : typeIR)* })

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:21.1-21.65
def $instantiable_extern(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return true

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:27.1-27.65
def $instantiable_parser(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return (instctxt = (anon))

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_parser_blockKind(TC.block.kind)

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_parser_state_localKind(TC.local.kind)

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:36.1-36.66
def $instantiable_control(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return (instctxt = (anon))

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_control_blockKind(TC.block.kind)

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_control_apply_method_localKind(TC.local.kind)

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:45.1-45.66
def $instantiable_package(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_package_blockKind(TC.block.kind)

  3. Case (% matches pattern `LOCAL`)

    1. Return false

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:52.1-52.64
def $instantiable_table(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_control_blockKind(TC.block.kind)

  3. Case (% matches pattern `LOCAL`)

    1. Return false

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:59.1-59.66
def $instantiable(p, TC, instctxt, typeIR)

1. If ($is_extern_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_extern(p, TC, instctxt)

2. If ($is_parser_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_parser(p, TC, instctxt)

3. If ($is_control_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_control(p, TC, instctxt)

4. If ($is_package_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_package(p, TC, instctxt)

5. If ($is_table_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_table(p, TC, instctxt)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:55.1-55.33
def $lvalue(lvalue'')

1. If ((lvalue'' has type referenceExpression)), then

  1. (Let referenceExpression be (lvalue'' as referenceExpression))

  2. Return (referenceExpression as expression)

2. Case analysis on lvalue''

  1. Case (% matches pattern `%.%`)

    1. (Let (lvalue_base . member) be lvalue'')

    2. (Let expression_base be $lvalue(lvalue_base))

    3. Return (((expression_base as memberAccessBase) . member) as expression)

  2. Case (% matches pattern `%[%]`)

    1. (Let (lvalue_base [ expression_index ]) be lvalue'')

    2. (Let expression_base be $lvalue(lvalue_base))

    3. Return ((expression_base [ expression_index ]) as expression)

  3. Case (% matches pattern `%[%:%]`)

    1. (Let (lvalue_base [ expression_hi : expression_lo ]) be lvalue'')

    2. (Let expression_base be $lvalue(lvalue_base))

    3. Return ((expression_base [ expression_hi : expression_lo ]) as expression)

  4. Case (% matches pattern `(%)`)

    1. (Let (( lvalue'' )) be lvalue'')

    2. (Let expression be $lvalue(lvalue''))

    3. Return ((( expression )) as expression)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:239.1-239.61
def $callable_builtin_function(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return true

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:266.1-266.53
def $callable_function(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))

  3. Case (% matches pattern `LOCAL`)

    1. Return (~$is_extern_method_localKind(TC.local.kind) /\ ~$is_extern_abstract_method_localKind(TC.local.kind))

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:310.1-310.60
def $callable_extern_function(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:352.1-352.51
def $callable_action(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return ($is_action_localKind(TC.local.kind) \/ $is_control_apply_method_localKind(TC.local.kind))

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:383.1-383.59
def $callable_builtin_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return true

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:410.1-410.58
def $callable_extern_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:452.1-452.67
def $callable_extern_abstract_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:494.1-494.64
def $callable_parser_apply_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_parser_state_localKind(TC.local.kind)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:522.1-522.65
def $callable_control_apply_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_control_apply_method_localKind(TC.local.kind)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:550.1-550.63
def $callable_table_apply_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return ($is_control_apply_method_localKind(TC.local.kind) \/ $is_table_apply_method_localKind(TC.local.kind))

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:5.1-5.27
def $empty_theta

1. Return $empty_map<tid, typeIR>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:8.15-8.29
syntax venv = map<id, value>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:10.1-10.25
def $empty_venv

1. Return $empty_map<id, value>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:13.19-13.41
syntax stateDyn = parserBlockStatementIR

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:15.15-15.34
syntax senv = map<name, stateDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:17.1-17.25
def $empty_senv

1. Return $empty_map<name, stateDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:25.1-28.34
syntax lvalueDyn = 
   | ` nameIR
   | . nameIR
   | lvalueDyn . nameIR
   | lvalueDyn [ value ]
   | lvalueDyn [ value : value ]

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:37.1-40.96
syntax funcDyn = 
   | builtin_function< typeParameterListIR >( parameterListIR ){ blockElementStatementListIR }
   | function< typeParameterListIR >( parameterListIR ) blockStatementIR
   | action( parameterListIR ){ blockStatementIR }
   | extern_function< typeParameterListIR >( parameterListIR ){ blockElementStatementIR? }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:43.1-48.41
syntax methodDyn = 
   | builtin_method( parameterListIR )# lvalueDyn
   | extern_method< typeParameterListIR >( parameterListIR )
   | extern_methodabstract< typeParameterListIR >( parameterListIR )
   | parser_apply( parameterListIR ){ parserLocalDeclarationListIR ; senv }
   | control_apply( parameterListIR ){ controlLocalDeclarationListIR ; renv ; blockElementStatementListIR }
   | table_apply{ tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:51.1-52.14
syntax routineDyn = 
   | builtin_function< typeParameterListIR >( parameterListIR ){ blockElementStatementListIR }
   | function< typeParameterListIR >( parameterListIR ) blockStatementIR
   | action( parameterListIR ){ blockStatementIR }
   | extern_function< typeParameterListIR >( parameterListIR ){ blockElementStatementIR? }
   | builtin_method( parameterListIR )# lvalueDyn
   | extern_method< typeParameterListIR >( parameterListIR )
   | extern_methodabstract< typeParameterListIR >( parameterListIR )
   | parser_apply( parameterListIR ){ parserLocalDeclarationListIR ; senv }
   | control_apply( parameterListIR ){ controlLocalDeclarationListIR ; renv ; blockElementStatementListIR }
   | table_apply{ tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:55.15-55.35
syntax renv = map<rid, routineDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:57.1-57.25
def $empty_renv

1. Return $empty_map<rid, routineDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:65.1-69.42
syntax consDyn = 
   | extern nameIR < typeParameterListIR >( constructorParameterListIR ){ methodPrototypeListIR }
   | parser< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
   | control< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
   | package< typeParameterListIR >( constructorParameterListIR )
   | table nameIR { tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:72.15-72.32
syntax cenv = map<cid, consDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:74.1-74.25
def $empty_cenv

1. Return $empty_map<cid, consDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:82.1-86.44
syntax objDyn = 
   | extern{ tid theta venv renv }
   | parser{ venv parameterListIR parserLocalDeclarationListIR senv }
   | control{ venv parameterListIR controlLocalDeclarationListIR renv controlBodyIR }
   | package{ theta venv }
   | table{ tid venv tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:89.14-89.30
syntax sto = map<oid, objDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:91.1-91.23
def $empty_sto

1. Return $empty_map<oid, objDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:95.1-95.37
def $add_sto(sto, oid, objDyn)

1. Return $add_map<oid, objDyn>(sto, oid, objDyn)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:8.3-11.16
syntax glayerInst = {cenv cenv, tdenv tdenv, renv renv, venv venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:16.3-19.16
syntax blayerInst = {theta theta, renv renv, senv senv, venv venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:24.3-25.18
syntax llayerInst = {theta theta, venvs venv*}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:32.3-35.23
syntax contextInst = {path oid, global glayerInst, block blayerInst, local llayerInst}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:43.1-43.32
def $empty_block

1. Return {theta $empty_theta, renv $empty_renv, senv $empty_senv, venv $empty_venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:51.1-51.32
def $empty_local

1. Return {theta $empty_theta, venvs []}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:57.1-57.40
def $empty_context_inst

1. (Let glayerInst be {cenv $empty_cenv, tdenv $empty_tdenv, renv $empty_renv, venv $empty_venv})

2. (Let blayerInst be $empty_block)

3. (Let llayerInst be $empty_local)

4. (Let Ci be {path [], global glayerInst, block blayerInst, local llayerInst})

5. Return Ci

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:74.1-74.43
def $enter_inst(Ci)

1. Return Ci[local.venvs = $empty_venv :: Ci.local.venvs]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:78.1-78.42
def $exit_inst(Ci)

1. (Let venv* be Ci.local.venvs)

2. If ((venv* matches pattern _ :: _)), then

  1. (Let venv_h :: venv_t* be venv*)

  2. Return Ci[local.venvs = venv_t*]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:87.1-87.47
def $enter_path(Ci, id)

1. Return Ci[path = Ci.path ++ [id]]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:95.1-95.58
def $copy_context_inst(cursor, Ci)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return Ci[block = $empty_block][local = $empty_local]

  2. Case (% matches pattern `BLOCK`)

    1. Return Ci[local = $empty_local]

  3. Case (% matches pattern `LOCAL`)

    1. Return Ci

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:107.1-107.65
def $add_value_inst(cursor, Ci, id, value)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let venv be $add_map<id, value>(Ci.global.venv, id, value))

    2. Return Ci[global.venv = venv]

  2. Case (% matches pattern `BLOCK`)

    1. (Let venv be $add_map<id, value>(Ci.block.venv, id, value))

    2. Return Ci[block.venv = venv]

  3. Case (% matches pattern `LOCAL`)

    1. (Let venv* be Ci.local.venvs)

    2. If ((venv* matches pattern _ :: _)), then

      1. (Let venv_h :: venv_t* be venv*)

      2. (Let venv_h' be $add_map<id, value>(venv_h, id, value))

      3. Return Ci[local.venvs = venv_h :: venv_t*]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:108.1-108.68
def $add_values_inst(p, Ci, id*, value*)

1. Case analysis on id*

  1. Case (% matches pattern [])

    1. If ((value* matches pattern [])), then

      1. Return Ci

  2. Case (% matches pattern _ :: _)

    1. (Let id_h :: id_t* be id*)

    2. If ((value* matches pattern _ :: _)), then

      1. (Let value_h :: value_t* be value*)

      2. (Let Ci' be $add_value_inst(p, Ci, id_h, value_h))

      3. (Let Ci'' be $add_values_inst(p, Ci', id_t*, value_t*))

      4. Return Ci''

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:125.1-125.83
def $add_routine_overload_inst



;; ../../../../spec-concrete/6.02-context-instantiation.watsup:127.1-127.87
def $add_routine_non_overload_inst(cursor, Ci, rid, routineDyn)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. If (~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.global.renv))), then

      1. (Let renv be $add_map<rid, routineDyn>(Ci.global.renv, rid, routineDyn))

      2. Return Ci[global.renv = renv]

  2. Case (% matches pattern `BLOCK`)

    1. If (~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.block.renv))), then

      1. (Let renv be $add_map<rid, routineDyn>(Ci.block.renv, rid, routineDyn))

      2. Return Ci[block.renv = renv]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:137.1-137.84
def $add_tparams_inst(p, Ci, typeParameterIR*, typeIR*)

1. Case analysis on typeParameterIR*

  1. Case (% matches pattern [])

    1. If ((typeIR* matches pattern [])), then

      1. Return Ci

  2. Case (% matches pattern _ :: _)

    1. (Let typeParameterIR_h :: typeParameterIR_t* be typeParameterIR*)

    2. If ((typeIR* matches pattern _ :: _)), then

      1. (Let typeIR_h :: typeIR_t* be typeIR*)

      2. (Let Ci' be $add_tparam_inst(p, Ci, typeParameterIR_h, typeIR_h))

      3. Return $add_tparams_inst(p, Ci', typeParameterIR_t*, typeIR_t*)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:138.1-138.81
def $add_tparam_inst(cursor, Ci, typeParameterIR, typeIR)

1. Case analysis on cursor

  1. Case (% matches pattern `BLOCK`)

    1. (Let theta be $add_map<tid, typeIR>(Ci.block.theta, typeParameterIR, typeIR))

    2. Return Ci[block.theta = theta]

  2. Case (% matches pattern `LOCAL`)

    1. (Let theta be $add_map<tid, typeIR>(Ci.local.theta, typeParameterIR, typeIR))

    2. Return Ci[local.theta = theta]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:152.1-152.75
def $add_constructor_inst(cursor, Ci, cid, consDyn)

1. If ((cursor matches pattern `GLOBAL`)), then

  1. (Let cenv be $add_map<cid, consDyn>(Ci.global.cenv, cid, consDyn))

  2. Return Ci[global.cenv = cenv]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:158.1-158.73
def $add_typedef_inst(cursor, Ci, tid, typeDefIR)

1. If ((cursor matches pattern `GLOBAL`)), then

  1. (Let tdenv be $add_map<tid, typeDefIR>(Ci.global.tdenv, tid, typeDefIR))

  2. Return Ci[global.tdenv = tdenv]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:169.1-169.59
def $find_value_inst



;; ../../../../spec-concrete/6.02-context-instantiation.watsup:172.1-172.66
def $find_type_inst



;; ../../../../spec-concrete/6.02-context-instantiation.watsup:176.1-176.65
def $find_typedef_inst



;; ../../../../spec-concrete/6.02-context-instantiation.watsup:180.1-180.44
def $ids_arguments_IR(argumentIR*)

1. Return $id_argument_IR(argumentIR)*

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:181.1-181.38
def $id_argument_IR(argumentIR)

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. Return ?()

2. Case analysis on argumentIR

  1. Case (% matches pattern `%=%`)

    1. (Let (nameIR = _typedExpressionIR) be argumentIR)

    2. Return ?(nameIR)

  2. Case (% matches pattern `%=_`)

    1. (Let (nameIR =_) be argumentIR)

    2. Return ?(nameIR)

  3. Case (% matches pattern `_`)

    1. Return ?()

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:189.1-189.103
def $find_constructor_overloaded_inst(Ci, prefixedNameIR, argumentIR*)

1. Case analysis on prefixedNameIR

  1. Case (% matches pattern ``%`)

    1. (Let (` id) be prefixedNameIR)

    2. (Let id_arg?* be $ids_arguments_IR(argumentIR*))

    3. Return $find_overloaded<consDyn>(Ci.global.cenv, id, id_arg?*)

  2. Case (% matches pattern `.%`)

    1. (Let (. id) be prefixedNameIR)

    2. (Let id_arg?* be $ids_arguments_IR(argumentIR*))

    3. Return $find_overloaded<consDyn>(Ci.global.cenv, id, id_arg?*)

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:3.1-5.17
relation Program_inst: 

  : |- declarationIR*{declarationIR <- declarationIR*} ; ==> % % % % % {

    1. (Let Ci_0 be $empty_context_inst)

    2. (Let sto_0 be $empty_sto)

    3. (Decls_inst: (global) Ci_0 sto_0 |- declarationIR* ==> Ci_1 sto_1 declarationIR'*)

    4. If ((declarationIR'* matches pattern [])), then

      1. Result in Ci_1.global.cenv, Ci_1.global.tdenv, Ci_1.global.renv, Ci_1.global.venv, sto_1

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:7.1-9.35
relation Constructor_inst: 

  extern: p Ci sto |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> % % {

    1. If ((consDyn matches pattern `EXTERN%<%>(%){%}`)), then

      1. (Let (extern nameIR < typeParameterIR* >( constructorParameterIR* ){ methodPrototypeIR* }) be consDyn)

      2. (Let p_callee be (block))

      3. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

      4. (Let Ci_callee_1 be $add_tparams_inst((global), Ci_callee_0, typeParameterIR*, typeArgumentIR*))

      5. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*))

      6. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

      7. (Eval_args: p p_callee Ci_callee_1 sto |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto')

      8. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

      9. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

      10. (Methods_inst: (block) Ci_callee_3 |- methodPrototypeIR* ==> Ci_callee_4)

      11. Result in sto', (extern{ nameIR Ci_callee_4.block.theta Ci_callee_4.block.venv Ci_callee_4.block.renv })

  }

  parser: p Ci sto |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> % % {

    1. If ((consDyn matches pattern `PARSER<%>(%)(%){%%}`)), then

      1. (Let (parser< typeParameterIR* >( parameterIR* )( constructorParameterIR* ){ parserLocalDeclarationIR* parserStateIR* }) be consDyn)

      2. (Let p_callee be (block))

      3. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

      4. (Let Ci_callee_1 be $add_tparams_inst((global), Ci_callee_0, typeParameterIR*, typeArgumentIR*))

      5. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*))

      6. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

      7. (Eval_args: p p_callee Ci_callee_1 sto |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto')

      8. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

      9. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

      10. (ParserLocalDecls_inst: (block) Ci_callee_3 sto' |- parserLocalDeclarationIR* ==> Ci_local sto'' parserLocalDeclarationIR'*)

      11. (ParserStates_inst: Ci_local sto'' |- parserStateIR* ==> Ci_state sto''')

      12. Result in sto''', (parser{ Ci_callee_3.block.venv parameterIR* parserLocalDeclarationIR'* Ci_state.block.senv })

  }

  control: p Ci sto |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> % % {

    1. If ((consDyn matches pattern `CONTROL<%>(%)(%){%APPLY%}`)), then

      1. (Let (control< typeParameterIR* >( parameterIR* )( constructorParameterIR* ){ controlLocalDeclarationIR* apply controlBodyIR }) be consDyn)

      2. (Let p_callee be (block))

      3. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

      4. (Let Ci_callee_1 be $add_tparams_inst((global), Ci_callee_0, typeParameterIR*, typeArgumentIR*))

      5. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*))

      6. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

      7. (Eval_args: p p_callee Ci_callee_1 sto |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto')

      8. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

      9. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

      10. (ControlLocalDecls_inst: Ci_callee_3 sto' |- controlLocalDeclarationIR* ==> Ci_local sto'' controlLocalDeclarationIR'*)

      11. (Block_inst: Ci_local sto'' true |- controlBodyIR ==> _contextInst sto''' controlBodyIR')

      12. Result in sto''', (control{ Ci_callee_3.block.venv parameterIR* controlLocalDeclarationIR'* Ci_local.block.renv controlBodyIR' })

  }

  package: p Ci sto_0 |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> % % {

    1. If ((consDyn matches pattern `PACKAGE<%>(%)`)), then

      1. (Let (package< typeParameterIR* >( constructorParameterIR* )) be consDyn)

      2. (Let p_callee be (block))

      3. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

      4. (Let Ci_callee_1 be $add_tparams_inst((global), Ci_callee_0, typeParameterIR*, typeArgumentIR*))

      5. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*))

      6. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

      7. (Eval_args: p p_callee Ci_callee_1 sto_0 |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto_1)

      8. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

      9. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

      10. Result in sto_1, (package{ Ci_callee_3.block.theta Ci_callee_3.block.venv })

  }

  table: p Ci sto |- consDyn < typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} >( argumentIR*{argumentIR <- argumentIR*} # id_default*{id_default <- id_default*} )==> % % {

    1. If ((consDyn matches pattern `TABLE%{%}`)), then

      1. (Let (table nameIR { tablePropertyListIR }) be consDyn)

      2. (Let p_callee be (local))

      3. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

      4. (Let Ci_callee_1 be $add_tparams_inst((global), Ci_callee_0, [], typeArgumentIR*))

      5. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args([], argumentIR*, id_default*))

      6. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

      7. (Eval_args: p p_callee Ci_callee_1 sto |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto')

      8. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

      9. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

      10. (Let Ci_frame be $enter_inst(Ci_callee_3))

      11. (TableProperties_inst: Ci_frame sto' |- tablePropertyListIR ==> Ci_table sto'' tablePropertyListIR_inst)

      12. (Let venv'* be Ci_table.local.venvs)

      13. If ((venv'* matches pattern _ :: _)), then

        1. (Let venv :: _venv* be venv'*)

        2. Result in sto', (table{ nameIR venv tablePropertyListIR_inst })

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:19.1-21.26
relation Exprs_inst: 



;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:23.1-25.26
relation Expr_inst: 

  literalExpressionIR-true: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR = ((true) as expressionIR))), then

      1. Result in sto, ((b true) as value)

  }

  literalExpressionIR-false: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR = ((false) as expressionIR))), then

      1. Result in sto, ((b false) as value)

  }

  literalExpressionIR-number-arbint: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type numberLiteral)), then

      1. (Let numberLiteral be (expressionIR as numberLiteral))

      2. If ((numberLiteral matches pattern `D%`)), then

        1. (Let (d i) be numberLiteral)

        2. Result in sto, ((d i) as value)

  }

  literalExpressionIR-number-fixint: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type numberLiteral)), then

      1. (Let numberLiteral be (expressionIR as numberLiteral))

      2. If ((numberLiteral matches pattern `%S%`)), then

        1. (Let (n s i) be numberLiteral)

        2. Result in sto, ((n s i) as value)

  }

  literalExpressionIR-number-fixbit: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type numberLiteral)), then

      1. (Let numberLiteral be (expressionIR as numberLiteral))

      2. If ((numberLiteral matches pattern `%W%`)), then

        1. (Let (n w i) be numberLiteral)

        2. Result in sto, ((n w i) as value)

  }

  literalExpressionIR-stringLiteral: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type stringLiteral)), then

      1. (Let (" text ") be (expressionIR as stringLiteral))

      2. Result in sto, ((" text ") as value)

  }

  referenceExpressionIR-id: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type prefixedNameIR)), then

      1. (Let prefixedNameIR be (expressionIR as prefixedNameIR))

      2. If ((prefixedNameIR matches pattern ``%`)), then

        1. (Let (` nameIR) be prefixedNameIR)

        2. (Let value'? be $find_value_inst(p, Ci, nameIR))

        3. If ((value'? matches pattern (_))), then

          1. (Let ?(value) be value'?)

          2. Result in sto, value

  }

  referenceExpressionIR-dotName: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type prefixedNameIR)), then

      1. (Let prefixedNameIR be (expressionIR as prefixedNameIR))

      2. If ((prefixedNameIR matches pattern `.%`)), then

        1. (Let (. nameIR) be prefixedNameIR)

        2. (Let value'? be $find_value_inst(p, Ci, nameIR))

        3. If ((value'? matches pattern (_))), then

          1. (Let ?(value) be value'?)

          2. Result in sto, value

  }

  defaultExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR = ((...) as expressionIR))), then

      1. Result in sto, ((default) as value)

  }

  unaryExpressionIR-lnot: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type unaryExpressionIR)), then

      1. (Let (unop typedExpressionIR) be (expressionIR as unaryExpressionIR))

      2. If ((unop matches pattern `!`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

        2. If (($un_lnot(value) = value)), then

          1. Result in sto', value

  }

  unaryExpressionIR-bnot: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type unaryExpressionIR)), then

      1. (Let (unop typedExpressionIR) be (expressionIR as unaryExpressionIR))

      2. If ((unop matches pattern `~`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

        2. If (($un_bnot(value) = value)), then

          1. Result in sto', value

  }

  unaryExpressionIR-plus: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type unaryExpressionIR)), then

      1. (Let (unop typedExpressionIR) be (expressionIR as unaryExpressionIR))

      2. If ((unop matches pattern `+`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

        2. Result in sto', value

  }

  unaryExpressionIR-minus: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type unaryExpressionIR)), then

      1. (Let (unop typedExpressionIR) be (expressionIR as unaryExpressionIR))

      2. If ((unop matches pattern `-`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

        2. If (($un_minus(value) = value)), then

          1. Result in sto', value

  }

  binaryExpressionIR-mul: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `*`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_mul(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-div: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `/`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_div(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-mod: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `%`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_mod(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-plus: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `+`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_plus(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-minus: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `-`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_minus(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-satplus: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `|+|`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_satplus(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-satminus: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `|-|`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_satminus(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-shl: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `<<`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_shl(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-shr: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `>>`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_shr(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-le: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `<=`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let bool be $bin_le(value_l, value_r))

        4. Result in sto'', ((b bool) as value)

  }

  binaryExpressionIR-ge: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `>=`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let bool be $bin_ge(value_l, value_r))

        4. Result in sto'', ((b bool) as value)

  }

  binaryExpressionIR-lt: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `<`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let bool be $bin_lt(value_l, value_r))

        4. Result in sto'', ((b bool) as value)

  }

  binaryExpressionIR-gt: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `>`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let bool be $bin_gt(value_l, value_r))

        4. Result in sto'', ((b bool) as value)

  }

  binaryExpressionIR-ne: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `!=`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let bool be $bin_ne(value_l, value_r))

        4. Result in sto'', ((b bool) as value)

  }

  binaryExpressionIR-eq: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `==`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let bool be $bin_eq(value_l, value_r))

        4. Result in sto'', ((b bool) as value)

  }

  binaryExpressionIR-band: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `&`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_band(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-bxor: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `^`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_bxor(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-bor: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `|`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_bor(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-concat: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `++`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_concat(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-land: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `&&`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_land(value_l, value_r))

        4. Result in sto'', value

  }

  binaryExpressionIR-lor: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. If ((binop matches pattern `||`)), then

        1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

        2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

        3. (Let value be $bin_lor(value_l, value_r))

        4. Result in sto'', value

  }

  ternaryExpressionIR-then: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type ternaryExpressionIR)), then

      1. (Let (typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e) be (expressionIR as ternaryExpressionIR))

      2. (Expr_inst: p Ci sto |- typedExpressionIR_c ==> sto' value_c)

      3. If ((value_c = ((b true) as value))), then

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_t ==> sto'' value_t)

        2. Result in sto'', value_t

  }

  ternaryExpressionIR-else: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type ternaryExpressionIR)), then

      1. (Let (typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e) be (expressionIR as ternaryExpressionIR))

      2. (Expr_inst: p Ci sto |- typedExpressionIR_c ==> sto' value_c)

      3. If ((value_c = ((b false) as value))), then

        1. (Expr_inst: p Ci sto' |- typedExpressionIR_e ==> sto'' value_e)

        2. Result in sto'', value_e

  }

  castExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type castExpressionIR)), then

      1. (Let (( typeIR ) typedExpressionIR) be (expressionIR as castExpressionIR))

      2. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

      3. (Let value_c be $cast_op(typeIR, value))

      4. Result in sto', value_c

  }

  dataExpressionIR-invalid: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR = (({#}) as expressionIR))), then

      1. Result in sto, (({#}) as value)

  }

  dataExpressionIR-sequence: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type dataExpressionIR)), then

      1. (Let dataExpressionIR be (expressionIR as dataExpressionIR))

      2. If ((dataExpressionIR matches pattern `SEQ{%}`)), then

        1. (Let (seq{ typedExpressionListIR }) be dataExpressionIR)

        2. (Exprs_inst: p Ci sto |- typedExpressionListIR ==> sto' value*)

        3. Result in sto', ((seq( value* )) as value)

  }

  dataExpressionIR-sequencedefault: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type dataExpressionIR)), then

      1. (Let dataExpressionIR be (expressionIR as dataExpressionIR))

      2. If ((dataExpressionIR matches pattern `SEQ{%,...}`)), then

        1. (Let (seq{ typedExpressionListIR ,...}) be dataExpressionIR)

        2. (Exprs_inst: p Ci sto |- typedExpressionListIR ==> sto' value*)

        3. Result in sto', ((seq( value* ,...)) as value)

  }

  dataExpressionIR-record: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type dataExpressionIR)), then

      1. (Let dataExpressionIR be (expressionIR as dataExpressionIR))

      2. If ((dataExpressionIR matches pattern `RECORD{%}`)), then

        1. (Let (record{ (nameIR = typedExpressionIR)* }) be dataExpressionIR)

        2. (Exprs_inst: p Ci sto |- typedExpressionIR* ==> sto' value*)

        3. Result in sto', ((record{ (value nameIR ;)* }) as value)

  }

  dataExpressionIR-recorddefault: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type dataExpressionIR)), then

      1. (Let dataExpressionIR be (expressionIR as dataExpressionIR))

      2. If ((dataExpressionIR matches pattern `RECORD{%,...}`)), then

        1. (Let (record{ (nameIR = typedExpressionIR)* ,...}) be dataExpressionIR)

        2. (Exprs_inst: p Ci sto |- typedExpressionIR* ==> sto' value*)

        3. Result in sto', ((record{ (value nameIR ;)* ,...}) as value)

  }

  accessExpressionIR-errorAccessExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type errorAccessExpressionIR)), then

      1. (Let (error. nameIR) be (expressionIR as errorAccessExpressionIR))

      2. (Let nameIR' be $concat_text(["error.", nameIR]))

      3. (Let value'? be $find_value_inst(p, Ci, nameIR'))

      4. If ((value'? matches pattern (_))), then

        1. (Let ?(value) be value'?)

        2. Result in sto, value

  }

  accessExpressionIR-memberAccessExpressionIR-typeaccess-enum: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type memberAccessExpressionIR)), then

      1. (Let (memberAccessBaseIR . nameIR) be (expressionIR as memberAccessExpressionIR))

      2. If ((memberAccessBaseIR matches pattern `TYPE%`)), then

        1. (Let (type prefixedNameIR) be memberAccessBaseIR)

        2. (Let nameIR_type be $flatten_prefixedNameIR(prefixedNameIR))

        3. (Let typeDefIR'? be $find_typedef_inst(p, Ci, nameIR_type))

        4. If ((typeDefIR'? matches pattern (_))), then

          1. (Let ?(typeDefIR) be typeDefIR'?)

          2. If ((typeDefIR has type typeIR)), then

            1. (Let typeIR be (typeDefIR as typeIR))

            2. (Let typeIR' be $canon(typeIR))

            3. If ((typeIR' has type enumTypeIR)), then

              1. (Let enumTypeIR be (typeIR' as enumTypeIR))

              2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

                1. (Let (enum tid { _id* }) be enumTypeIR)

                2. Result in sto, ((tid . nameIR) as value)

  }

  accessExpressionIR-memberAccessExpressionIR-senum: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type memberAccessExpressionIR)), then

      1. (Let (memberAccessBaseIR . nameIR) be (expressionIR as memberAccessExpressionIR))

      2. If ((memberAccessBaseIR matches pattern `TYPE%`)), then

        1. (Let (type prefixedNameIR) be memberAccessBaseIR)

        2. (Let nameIR_type be $flatten_prefixedNameIR(prefixedNameIR))

        3. (Let typeDefIR'? be $find_typedef_inst(p, Ci, nameIR_type))

        4. If ((typeDefIR'? matches pattern (_))), then

          1. (Let ?(typeDefIR) be typeDefIR'?)

          2. If ((typeDefIR has type typeIR)), then

            1. (Let typeIR be (typeDefIR as typeIR))

            2. (Let typeIR' be $canon(typeIR))

            3. If ((typeIR' has type enumTypeIR)), then

              1. (Let enumTypeIR be (typeIR' as enumTypeIR))

              2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

                1. (Let (enum tid # _typeIR { (id_f = value_f ;)* }) be enumTypeIR)

                2. (Let value'? be $assoc_<nameIR, value>(nameIR, (id_f, value_f)*))

                3. If ((value'? matches pattern (_))), then

                  1. (Let ?(value) be value'?)

                  2. Result in sto, ((tid . nameIR # value) as value)

  }

  accessExpressionIR-memberAccessExpressionIR-typedExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type memberAccessExpressionIR)), then

      1. (Let (memberAccessBaseIR . text) be (expressionIR as memberAccessExpressionIR))

      2. If ((memberAccessBaseIR has type typedExpressionIR)), then

        1. (Let typedExpressionIR be (memberAccessBaseIR as typedExpressionIR))

        2. If ((text = "size")), then

          1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

          2. (Let value' be value)

          3. If ((value' has type headerStackValue)), then

            1. (Let ([ _value* #( _nat ; nat_s )]) be (value' as headerStackValue))

            2. Result in sto', ((d (nat_s as int)) as value)

  }

  indexAccessExpressionIR-bitslice: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type indexAccessExpressionIR)), then

      1. (Let indexAccessExpressionIR be (expressionIR as indexAccessExpressionIR))

      2. If ((indexAccessExpressionIR matches pattern `%[%:%]`)), then

        1. (Let (typedExpressionIR_b [ typedExpressionIR_l : typedExpressionIR_h ]) be indexAccessExpressionIR)

        2. (Expr_inst: p Ci sto |- typedExpressionIR_b ==> sto' value_b)

        3. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto'' value_l)

        4. (Expr_inst: p Ci sto'' |- typedExpressionIR_h ==> sto''' value_h)

        5. (Let value be $bitacc_op(value_b, value_l, value_h))

        6. Result in sto''', value

  }

  callExpressionIR-instantiation: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type callExpressionIR)), then

      1. (Let callExpressionIR be (expressionIR as callExpressionIR))

      2. If ((callExpressionIR matches pattern `%(%)`)), then

        1. (Let ((prefixedNameIR < typeArgumentListIR >) ( argumentListIR )) be callExpressionIR)

        2. (Let (rid, consDyn, id*)? be $find_constructor_overloaded_inst(Ci, prefixedNameIR, argumentListIR))

        3. If (((rid, consDyn, id*)? matches pattern (_))), then

          1. (Let ?((_rid, consDyn, id_default*)) be (rid, consDyn, id*)?)

          2. (Constructor_inst: p Ci sto |- consDyn < typeArgumentListIR >( argumentListIR # id_default* )==> sto' objDyn)

          3. (Let sto'' be $add_sto(sto', Ci.path, objDyn))

          4. Result in sto'', ((! Ci.path) as value)

  }

  callExpressionIR-methodTarget-generic: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type callExpressionIR)), then

      1. (Let callExpressionIR be (expressionIR as callExpressionIR))

      2. If ((callExpressionIR matches pattern `%<%>(%)`)), then

        1. (Let (routineTargetIR < typeArgumentIR* >( argumentIR* )) be callExpressionIR)

        2. If ((routineTargetIR matches pattern `%.%`)), then

          1. (Let (typedExpressionIR . nameIR) be routineTargetIR)

          2. If ((typeArgumentIR* matches pattern [])), then

            1. If ((argumentIR* matches pattern [])), then

              1. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

              2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                1. (Let value be $size(typeIR, nameIR))

                2. Result in sto, value

  }

  callExpressionIR-methodTarget-non-generic: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type callExpressionIR)), then

      1. (Let callExpressionIR be (expressionIR as callExpressionIR))

      2. If ((callExpressionIR matches pattern `%<%>(%)`)), then

        1. (Let (routineTargetIR < typeArgumentIR* >( argumentIR* )) be callExpressionIR)

        2. If ((routineTargetIR matches pattern `TYPE%.%`)), then

          1. (Let (type prefixedNameIR . nameIR) be routineTargetIR)

          2. If ((typeArgumentIR* matches pattern [])), then

            1. If ((argumentIR* matches pattern [])), then

              1. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                1. (Let typeIR be $find_type_inst(p, Ci, prefixedNameIR))

                2. (Let value be $size(typeIR, nameIR))

                3. Result in sto, value

  }

  parenthesizedExpressionIR: p Ci sto |- expressionIR # _expressionNoteIR ==> % % {

    1. If ((expressionIR has type parenthesizedExpressionIR)), then

      1. (Let (( typedExpressionIR )) be (expressionIR as parenthesizedExpressionIR))

      2. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

      3. Result in sto', value

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:27.1-29.26
relation Argument_inst: 

  expression: p Ci sto |- argumentIR ==> % % {

    1. If ((argumentIR has type typedExpressionIR)), then

      1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

      2. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

      3. Result in sto', value

  }

  namedexpression: p Ci sto |- argumentIR ==> % % {

    1. If ((argumentIR matches pattern `%=%`)), then

      1. (Let (nameIR = typedExpressionIR) be argumentIR)

      2. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

      3. Result in sto', value

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:35.1-37.26
relation Decls_inst: 

  nil: p Ci sto |- declarationIR*{declarationIR <- declarationIR*} ==> % % % {

    1. If ((declarationIR* matches pattern [])), then

      1. Result in Ci, sto, []

  }

  cons-none: p Ci_0 sto_0 |- declarationIR*{declarationIR <- declarationIR*} ==> % % % {

    1. If ((declarationIR* matches pattern _ :: _)), then

      1. (Let declarationIR_h :: declarationIR_t* be declarationIR*)

      2. (Decl_inst: p Ci_0 sto_0 |- declarationIR_h ==> Ci_1 sto_1 declarationIR'?)

      3. If ((declarationIR'? matches pattern ())), then

        1. (Decls_inst: p Ci_1 sto_1 |- declarationIR_t* ==> Ci_2 sto_2 declarationIR_t'*)

        2. Result in Ci_2, sto_2, declarationIR_t'*

  }

  cons-some: p Ci_0 sto_0 |- declarationIR*{declarationIR <- declarationIR*} ==> % % % {

    1. If ((declarationIR* matches pattern _ :: _)), then

      1. (Let declarationIR_h :: declarationIR_t* be declarationIR*)

      2. (Decl_inst: p Ci_0 sto_0 |- declarationIR_h ==> Ci_1 sto_1 declarationIR'?)

      3. If ((declarationIR'? matches pattern (_))), then

        1. (Let ?(declarationIR_h') be declarationIR'?)

        2. (Decls_inst: p Ci_1 sto_1 |- declarationIR_t* ==> Ci_2 sto_2 declarationIR_t'*)

        3. Result in Ci_2, sto_2, declarationIR_h' :: declarationIR_t'*

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:39.1-41.26
relation Decl_inst: 

  constantDeclarationIR-global: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type constantDeclarationIR)), then

        1. (Let (_annotationList const typeIR nameIR (= value) ;) be (declarationIR as constantDeclarationIR))

        2. (Let Ci_1 be $add_value_inst((global), Ci_0, nameIR, value))

        3. Result in Ci_1, sto, ?()

  }

  constantDeclarationIR-non-global: p Ci_0 sto |- declarationIR ==> % % % {

    1. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let (annotationList const typeIR nameIR (= value) ;) be (declarationIR as constantDeclarationIR))

      2. (Let Ci_1 be $add_value_inst(p, Ci_0, nameIR, value))

      3. Result in Ci_1, sto, ?(((annotationList const typeIR nameIR (= value) ;) as declarationIR))

  }

  instantiationIR-extern: p Ci_0 sto_0 |- declarationIR ==> % % % {

    1. If ((declarationIR has type instantiationIR)), then

      1. (Let (_annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;) be (declarationIR as instantiationIR))

      2. (Let (rid, consDyn, id*)? be $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR))

      3. If (((rid, consDyn, id*)? matches pattern (_))), then

        1. (Let ?((_rid, consDyn, id_default*)) be (rid, consDyn, id*)?)

        2. (Let Ci_1 be $enter_path(Ci_0, nameIR))

        3. (Constructor_inst: p Ci_1 sto_0 |- consDyn < typeArgumentListIR >( argumentListIR # id_default* )==> sto_1 objDyn)

        4. (Let objDyn' be objDyn)

        5. If ((objDyn' matches pattern `EXTERN{%%%%}`)), then

          1. (Let (extern{ tid theta venv renv }) be objDyn')

          2. (Let Ci_init be $empty_context_inst[path = Ci_1.path ++ [nameIR]][global = Ci_1.global])

          3. (Let objectDeclarationListIR be $get_init_decls(objectInitializerOptIR))

          4. (ObjectDecls_inst: (block) Ci_init sto_1 |- objectDeclarationListIR ==> Ci_init_2 sto_2 _objectDeclarationListIR)

          5. Result in Ci_0, sto_2, ?()

  }

  instantiationIR-non-extern: p Ci_0 sto_0 |- declarationIR ==> % % % {

    1. If ((declarationIR has type instantiationIR)), then

      1. (Let (_annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;) be (declarationIR as instantiationIR))

      2. (Let (rid, consDyn, id*)? be $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR))

      3. If (((rid, consDyn, id*)? matches pattern (_))), then

        1. (Let ?((_rid, consDyn, id_default*)) be (rid, consDyn, id*)?)

        2. (Let Ci_1 be $enter_path(Ci_0, nameIR))

        3. (Constructor_inst: p Ci_1 sto_0 |- consDyn < typeArgumentListIR >( argumentListIR # id_default* )==> sto_1 objDyn)

        4. If (~$is_extern_object(objDyn)), then

          1. (Let tid be $flatten_prefixedNameIR(prefixedNameIR))

          2. (Let typeIR be ((tid tid) as typeIR))

          3. (Let oid be Ci_1.path ++ [nameIR])

          4. (Let sto_2 be $add_sto(sto_1, oid, objDyn))

          5. (Let Ci_2 be $add_value_inst(p, Ci_1, nameIR, ((! oid) as value)))

          6. (Let constantDeclarationIR be (() const typeIR nameIR (= ((! oid) as value)) ;))

          7. Result in Ci_0, sto_1, ?()

  }

  functionDeclarationIR: p Ci_0 sto |- declarationIR ==> % % % {

    1. If ((declarationIR has type functionDeclarationIR)), then

      1. (Let (_annotationList (typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR )) blockStatementIR) be (declarationIR as functionDeclarationIR))

      2. (Let rid be $rid_IR(nameIR, parameterListIR))

      3. (Let funcDyn be (function< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ) blockStatementIR))

      4. (Let Ci_1 be $add_routine_overload_inst(p, Ci_0, rid, (funcDyn as routineDyn)))

      5. Result in Ci_1, sto, ?()

  }

  actionDeclarationIR: p Ci_0 sto |- declarationIR ==> % % % {

    1. If ((declarationIR has type actionDeclarationIR)), then

      1. (Let (_annotationList action nameIR ( parameterListIR ) blockStatementIR) be (declarationIR as actionDeclarationIR))

      2. (Let rid be $rid_IR(nameIR, parameterListIR))

      3. (Let funcDyn be (action( parameterListIR ){ blockStatementIR }))

      4. (Let Ci_1 be $add_routine_non_overload_inst(p, Ci_0, rid, (funcDyn as routineDyn)))

      5. Result in Ci_1, sto, ?()

  }

  errorDeclarationIR: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type errorDeclarationIR)), then

        1. (Let (error{ nameIR* }) be (declarationIR as errorDeclarationIR))

        2. (Let nameIR_field be $concat_text(["error.", nameIR]))*

        3. (Let Ci_1 be $add_values_inst((global), Ci_0, nameIR_field*, ((error. nameIR) as value)*))

        4. Result in Ci_1, sto, ?()

  }

  matchKindDeclarationIR: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type matchKindDeclarationIR)), then

        1. (Let (match_kind{ nameIR* }) be (declarationIR as matchKindDeclarationIR))

        2. (Let Ci_1 be $add_values_inst((global), Ci_0, nameIR*, ((match_kind. nameIR) as value)*))

        3. Result in Ci_1, sto, ?()

  }

  externFunctionDeclarationIR: p Ci_0 sto |- declarationIR ==> % % % {

    1. If ((declarationIR has type externFunctionDeclarationIR)), then

      1. (Let (_annotationList extern (typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR )) ;) be (declarationIR as externFunctionDeclarationIR))

      2. (Let rid be $rid_IR(nameIR, parameterListIR))

      3. (Let funcDyn be (extern_function< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ){ ?() }))

      4. (Let Ci_1 be $add_routine_overload_inst(p, Ci_0, rid, (funcDyn as routineDyn)))

      5. Result in Ci_1, sto, ?()

  }

  parserDeclarationIR: p Ci_0 sto |- declarationIR ==> % % % {

    1. If ((declarationIR has type parserDeclarationIR)), then

      1. (Let (_annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }) be (declarationIR as parserDeclarationIR))

      2. (Let cid be $cid_IR(nameIR, constructorParameterListIR))

      3. (Let consDyn be (parser< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }))

      4. (Let Ci_1 be $add_constructor_inst(p, Ci_0, cid, consDyn))

      5. Result in Ci_1, sto, ?()

  }

  controlDeclarationIR: p Ci_0 sto |- declarationIR ==> % % % {

    1. If ((declarationIR has type controlDeclarationIR)), then

      1. (Let (_annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }) be (declarationIR as controlDeclarationIR))

      2. (Let cid be $cid_IR(nameIR, constructorParameterListIR))

      3. (Let consDyn be (control< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }))

      4. (Let Ci_1 be $add_constructor_inst(p, Ci_0, cid, consDyn))

      5. Result in Ci_1, sto, ?()

  }

  typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-enum: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type enumTypeDeclarationIR)), then

        1. (Let enumTypeDeclarationIR be (declarationIR as enumTypeDeclarationIR))

        2. If ((enumTypeDeclarationIR matches pattern `%ENUM%{%}`)), then

          1. (Let (_annotationList enum nameIR { nameIR_mem* }) be enumTypeDeclarationIR)

          2. (Let nameIR_path be $concat_text([nameIR, ".", nameIR_mem]))*

          3. (Let Ci_1 be $add_values_inst((global), Ci_0, nameIR_path*, ((nameIR . nameIR_mem) as value)*))

          4. (Let Ci_2 be $add_typedef_inst((global), Ci_1, nameIR, ((enum nameIR { nameIR_mem* }) as typeDefIR)))

          5. Result in Ci_2, sto, ?()

  }

  typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-serializableEnum: cursor Ci_0 sto_0 |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type enumTypeDeclarationIR)), then

        1. (Let enumTypeDeclarationIR be (declarationIR as enumTypeDeclarationIR))

        2. If ((enumTypeDeclarationIR matches pattern `%ENUM%%{%}`)), then

          1. (Let (_annotationList enum typeIR nameIR { (nameIR_mem = typedExpressionIR)* }) be enumTypeDeclarationIR)

          2. (Let nameIR_path be $concat_text([nameIR, ".", nameIR_mem]))*

          3. (Exprs_inst: (global) Ci_0 sto_0 |- typedExpressionIR* ==> sto_1 value_mem*)

          4. (Let Ci_1 be $add_values_inst((global), Ci_0, nameIR_path*, ((nameIR . nameIR_mem # value_mem) as value)*))

          5. (Let Ci_2 be $add_typedef_inst((global), Ci_1, nameIR, ((enum nameIR # typeIR { (nameIR_mem = value_mem ;)* }) as typeDefIR)))

          6. Result in Ci_2, sto_1, ?()

  }

  typeDeclarationIR-derivedTypeDeclarationIR-structTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type structTypeDeclarationIR)), then

        1. (Let (_annotationList struct nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR* }) be (declarationIR as structTypeDeclarationIR))

        2. (Let (_annotationList' typeIR nameIR_field ;) be typeFieldIR)*

        3. (Let typeDefIR be ((((struct nameIR { (typeIR nameIR_field ;)* }) as typeIR) < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

        4. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR))

        5. Result in Ci_1, sto, ?()

  }

  typeDeclarationIR-derivedTypeDeclarationIR-headerTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type headerTypeDeclarationIR)), then

        1. (Let (_annotationList header nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR* }) be (declarationIR as headerTypeDeclarationIR))

        2. (Let (_annotationList' typeIR nameIR_field ;) be typeFieldIR)*

        3. (Let typeDefIR be ((((header nameIR { (typeIR nameIR_field ;)* }) as typeIR) < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

        4. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR))

        5. Result in Ci_1, sto, ?()

  }

  typeDeclarationIR-derivedTypeDeclarationIR-headerUnionTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type headerUnionTypeDeclarationIR)), then

        1. (Let (_annotationList header_union nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR* }) be (declarationIR as headerUnionTypeDeclarationIR))

        2. (Let (_annotationList' typeIR nameIR_field ;) be typeFieldIR)*

        3. (Let typeDefIR be ((((header_union nameIR { (typeIR nameIR_field ;)* }) as typeIR) < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

        4. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR))

        5. Result in Ci_1, sto, ?()

  }

  typeDeclarationIR-typedefDeclarationIR-typedef-typeIR: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type typedefDeclarationIR)), then

        1. (Let typedefDeclarationIR be (declarationIR as typedefDeclarationIR))

        2. If ((typedefDeclarationIR matches pattern `%TYPEDEF%%;`)), then

          1. (Let (_annotationList typedef typedefTypeIR nameIR ;) be typedefDeclarationIR)

          2. If ((typedefTypeIR has type typeIR)), then

            1. (Let typeIR be (typedefTypeIR as typeIR))

            2. (Let typeIR_typedef be ((typedef nameIR typeIR) as typeIR))

            3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, (typeIR_typedef as typeDefIR)))

            4. Result in Ci_1, sto, ?()

  }

  typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclarationIR-monoTypeDefIR: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type typedefDeclarationIR)), then

        1. (Let typedefDeclarationIR be (declarationIR as typedefDeclarationIR))

        2. If ((typedefDeclarationIR matches pattern `%TYPEDEF%%;`)), then

          1. (Let (_annotationList typedef typedefTypeIR nameIR ;) be typedefDeclarationIR)

          2. If ((typedefTypeIR has type derivedTypeDeclarationIR)), then

            1. (Let derivedTypeDeclarationIR be (typedefTypeIR as derivedTypeDeclarationIR))

            2. (Decl_inst: (global) Ci_0 $empty_sto |- (derivedTypeDeclarationIR as declarationIR) ==> Ci_local _sto _declarationIR?)

            3. (Let ({ tid* }) be $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_0.global.tdenv), $dom_map<tid, typeDefIR>(Ci_local.global.tdenv)))

            4. If ((tid* matches pattern [ _/1 ])), then

              1. (Let [tid_newtype] be tid*)

              2. (Let typeDefIR'? be $find_typedef_inst((global), Ci_local, tid_newtype))

              3. If ((typeDefIR'? matches pattern (_))), then

                1. (Let ?(typeDefIR) be typeDefIR'?)

                2. (Let typeDefIR'' be typeDefIR)

                3. If ((typeDefIR'' has type monoTypeDefIR)), then

                  1. (Let monoTypeDefIR be (typeDefIR'' as monoTypeDefIR))

                  2. (Let typeIR_typedef be ((typedef nameIR monoTypeDefIR) as typeIR))

                  3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, (typeIR_typedef as typeDefIR)))

                  4. Result in Ci_1, sto, ?()

  }

  typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclaration-polyTypeDefIR: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type typedefDeclarationIR)), then

        1. (Let typedefDeclarationIR be (declarationIR as typedefDeclarationIR))

        2. If ((typedefDeclarationIR matches pattern `%TYPEDEF%%;`)), then

          1. (Let (_annotationList typedef typedefTypeIR nameIR ;) be typedefDeclarationIR)

          2. If ((typedefTypeIR has type derivedTypeDeclarationIR)), then

            1. (Let derivedTypeDeclarationIR be (typedefTypeIR as derivedTypeDeclarationIR))

            2. (Decl_inst: (global) Ci_0 $empty_sto |- (derivedTypeDeclarationIR as declarationIR) ==> Ci_local _sto _declarationIR?)

            3. (Let ({ tid* }) be $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_0.global.tdenv), $dom_map<tid, typeDefIR>(Ci_local.global.tdenv)))

            4. If ((tid* matches pattern [ _/1 ])), then

              1. (Let [tid_newtype] be tid*)

              2. (Let typeDefIR'? be $find_typedef_inst((global), Ci_local, tid_newtype))

              3. If ((typeDefIR'? matches pattern (_))), then

                1. (Let ?(typeDefIR) be typeDefIR'?)

                2. (Let typeDefIR'' be typeDefIR)

                3. If ((typeDefIR'' has type polyTypeDefIR)), then

                  1. (Let polyTypeDefIR be (typeDefIR'' as polyTypeDefIR))

                  2. (Let typeIR_typedef be ((typedef nameIR ((polyTypeDefIR < [] >) as typeIR)) as typeIR))

                  3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, (typeIR_typedef as typeDefIR)))

                  4. Result in Ci_1, sto, ?()

  }

  typeDeclarationIR-typedefDeclarationIR-newtype: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type typedefDeclarationIR)), then

        1. (Let typedefDeclarationIR be (declarationIR as typedefDeclarationIR))

        2. If ((typedefDeclarationIR matches pattern `%TYPE%%;`)), then

          1. (Let (_annotationList type typeIR nameIR ;) be typedefDeclarationIR)

          2. (Let typeIR_newtype be ((type nameIR typeIR) as typeIR))

          3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, (typeIR_newtype as typeDefIR)))

          4. Result in Ci_1, sto, ?()

  }

  typeDeclarationIR-parserTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type parserTypeDeclarationIR)), then

        1. (Let (_annotationList parser nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* );) be (declarationIR as parserTypeDeclarationIR))

        2. (Let parameterTypeIR be $parameterIR(parameterIR))*

        3. (Let typeIR_parser be ((parser( parameterTypeIR* )) as typeIR))

        4. (Let typeDefIR_parser be ((typeIR_parser < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

        5. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR_parser))

        6. Result in Ci_1, sto, ?()

  }

  typeDeclarationIR-controlTypeDeclarationIR: cursor Ci_0 sto |- declarationIR ==> % % % {

    1. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type controlTypeDeclarationIR)), then

        1. (Let (_annotationList control nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* );) be (declarationIR as controlTypeDeclarationIR))

        2. (Let parameterTypeIR be $parameterIR(parameterIR))*

        3. (Let typeIR_parser be ((control( parameterTypeIR* )) as typeIR))

        4. (Let typeDefIR_parser be ((typeIR_parser < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

        5. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR_parser))

        6. Result in Ci_1, sto, ?()

  }

  typeDeclarationIR-packageTypeDeclarationIR: p Ci_0 sto |- declarationIR ==> % % % {

    1. If ((declarationIR has type packageTypeDeclarationIR)), then

      1. (Let (_annotationList package nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* );) be (declarationIR as packageTypeDeclarationIR))

      2. (Let (_annotationList' _direction typeIR _nameIR _constantInitializerOptIR) be parameterIR)*

      3. (Let typeIR_package be ((package< typeIR* >) as typeIR))

      4. (Let typeDefIR_package be ((typeIR_package < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

      5. (Let Ci_1 be $add_typedef_inst(p, Ci_0, nameIR, typeDefIR_package))

      6. (Let cid be $cid_IR(nameIR, parameterIR*))

      7. (Let consDyn_package be (package< typeParameterListIR ++ typeParameterListIR_inferred >( parameterIR* )))

      8. (Let Ci_2 be $add_constructor_inst((global), Ci_1, cid, consDyn_package))

      9. Result in Ci_2, sto, ?()

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:43.1-45.26
relation ParserLocalDecl_inst: 



;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:47.1-49.26
relation ParserLocalDecls_inst: 



;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:51.1-53.23
relation ControlLocalDecl_inst: 

  constantDeclarationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> % % % {

    1. If ((controlLocalDeclarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (controlLocalDeclarationIR as constantDeclarationIR))

      2. (Decl_inst: (block) Ci_0 sto_0 |- (constantDeclarationIR as declarationIR) ==> Ci_1 sto_1 declarationIR?)

      3. If ((declarationIR? has type constantDeclarationIR?)), then

        1. (Let constantDeclarationIR_inst? be (declarationIR? as constantDeclarationIR?))

        2. Result in Ci_1, sto_1, (constantDeclarationIR_inst? as controlLocalDeclarationIR?)

  }

  instantiationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> % % % {

    1. If ((controlLocalDeclarationIR has type instantiationIR)), then

      1. (Let instantiationIR be (controlLocalDeclarationIR as instantiationIR))

      2. (Decl_inst: (block) Ci_0 sto_0 |- (instantiationIR as declarationIR) ==> Ci_1 sto_1 declarationIR?)

      3. If ((declarationIR? has type instantiationIR?)), then

        1. (Let instantiationIR_inst? be (declarationIR? as instantiationIR?))

        2. Result in Ci_1, sto_1, (instantiationIR_inst? as controlLocalDeclarationIR?)

  }

  variableDeclarationIR: Ci sto |- controlLocalDeclarationIR ==> % % % {

    1. If ((controlLocalDeclarationIR has type variableDeclarationIR)), then

      1. (Let variableDeclarationIR be (controlLocalDeclarationIR as variableDeclarationIR))

      2. Result in Ci, sto, ?((variableDeclarationIR as controlLocalDeclarationIR))

  }

  actionDeclarationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> % % % {

    1. If ((controlLocalDeclarationIR has type actionDeclarationIR)), then

      1. (Let actionDeclarationIR be (controlLocalDeclarationIR as actionDeclarationIR))

      2. (Decl_inst: (block) Ci_0 sto_0 |- (actionDeclarationIR as declarationIR) ==> Ci_1 sto_1 declarationIR?)

      3. If ((declarationIR? has type actionDeclarationIR?)), then

        1. (Let actionDeclarationIR_inst? be (declarationIR? as actionDeclarationIR?))

        2. Result in Ci_1, sto_1, (actionDeclarationIR_inst? as controlLocalDeclarationIR?)

  }

  tableDeclarationIR: Ci_0 sto_0 |- controlLocalDeclarationIR ==> % % % {

    1. If ((controlLocalDeclarationIR has type tableDeclarationIR)), then

      1. (Let (_annotationList table typeIR nameIR { tablePropertyListIR }) be (controlLocalDeclarationIR as tableDeclarationIR))

      2. (Let Ci_1 be $enter_path(Ci_0, nameIR))

      3. (Constructor_inst: (block) Ci_0 sto_0 |- (table nameIR { tablePropertyListIR }) < [] >( [] # [] )==> sto_1 objDyn)

      4. (Let oid be Ci_1.path ++ [nameIR])

      5. (Let sto_2 be $add_sto(sto_1, oid, objDyn))

      6. (Let Ci_2 be $add_value_inst((block), Ci_1, nameIR, ((! oid) as value)))

      7. (Let constantDeclarationIR be (() const typeIR nameIR (= ((! oid) as value)) ;))

      8. Result in Ci_2, sto_1, ?((constantDeclarationIR as controlLocalDeclarationIR))

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:55.1-57.23
relation ControlLocalDecls_inst: 

  nil: Ci sto |- controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} ==> % % % {

    1. If ((controlLocalDeclarationIR* matches pattern [])), then

      1. Result in Ci, sto, []

  }

  cons-none: Ci_0 sto_0 |- controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} ==> % % % {

    1. If ((controlLocalDeclarationIR* matches pattern _ :: _)), then

      1. (Let controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t* be controlLocalDeclarationIR*)

      2. (ControlLocalDecl_inst: Ci_0 sto_0 |- controlLocalDeclarationIR_h ==> Ci_1 sto_1 controlLocalDeclarationIR'?)

      3. If ((controlLocalDeclarationIR'? matches pattern ())), then

        1. (ControlLocalDecls_inst: Ci_1 sto_1 |- controlLocalDeclarationIR_t* ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*)

        2. Result in Ci_2, sto_2, controlLocalDeclarationIR_t'*

  }

  cons-some: Ci_0 sto_0 |- controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} ==> % % % {

    1. If ((controlLocalDeclarationIR* matches pattern _ :: _)), then

      1. (Let controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t* be controlLocalDeclarationIR*)

      2. (ControlLocalDecl_inst: Ci_0 sto_0 |- controlLocalDeclarationIR_h ==> Ci_1 sto_1 controlLocalDeclarationIR'?)

      3. If ((controlLocalDeclarationIR'? matches pattern (_))), then

        1. (Let ?(controlLocalDeclarationIR_h') be controlLocalDeclarationIR'?)

        2. (ControlLocalDecls_inst: Ci_1 sto_1 |- controlLocalDeclarationIR_t* ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*)

        3. Result in Ci_2, sto_2, controlLocalDeclarationIR_h' :: controlLocalDeclarationIR_t'*

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:59.1-61.23
relation TableProperty_inst: 

  key: Ci sto |- tablePropertyIR ==> % % % {

    1. If ((tablePropertyIR matches pattern `KEY={%}`)), then

      1. (Let (key={ tableKeyListIR }) be tablePropertyIR)

      2. Result in Ci, sto, (key={ tableKeyListIR })

  }

  actions: Ci sto |- tablePropertyIR ==> % % % {

    1. If ((tablePropertyIR matches pattern `ACTIONS={%}`)), then

      1. (Let (actions={ tableActionListIR }) be tablePropertyIR)

      2. Result in Ci, sto, (actions={ tableActionListIR })

  }

  entries: Ci sto |- tablePropertyIR ==> % % % {

    1. If ((tablePropertyIR matches pattern `%%ENTRIES={%}`)), then

      1. (Let (annotationList constOptIR entries={ tableEntryListIR }) be tablePropertyIR)

      2. Result in Ci, sto, (annotationList constOptIR entries={ tableEntryListIR })

  }

  custom-default-action: Ci sto |- tablePropertyIR ==> % % % {

    1. If ((tablePropertyIR matches pattern `%%DEFAULT_ACTION=%;`)), then

      1. (Let (annotationList constOptIR default_action= tableActionReferenceIR ;) be tablePropertyIR)

      2. Result in Ci, sto, (annotationList constOptIR default_action= tableActionReferenceIR ;)

  }

  custom: Ci sto |- tablePropertyIR ==> % % % {

    1. If ((tablePropertyIR matches pattern `%%CUSTOM%%;`)), then

      1. (Let (annotationList constOptIR custom nameIR (= typedExpressionIR) ;) be tablePropertyIR)

      2. (Let Ci_1 be $enter_path(Ci, nameIR))

      3. (Expr_inst: (local) Ci_1 sto |- typedExpressionIR ==> sto_1 value)

      4. Result in Ci, sto, (annotationList constOptIR custom_const nameIR (= value) ;)

  }

  custom-const: Ci sto |- tablePropertyIR ==> % % % {

    1. If ((tablePropertyIR matches pattern `%%CUSTOM_CONST%%;`)), then

      1. (Let (annotationList constOptIR custom_const nameIR constantInitializerIR ;) be tablePropertyIR)

      2. Result in Ci, sto, (annotationList constOptIR custom_const nameIR constantInitializerIR ;)

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:63.1-65.23
relation TableProperties_inst: 

  nil: Ci sto |- tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} ==> % % % {

    1. If ((tablePropertyIR* matches pattern [])), then

      1. Result in Ci, sto, []

  }

  cons: Ci_0 sto_0 |- tablePropertyIR*{tablePropertyIR <- tablePropertyIR*} ==> % % % {

    1. If ((tablePropertyIR* matches pattern _ :: _)), then

      1. (Let tablePropertyIR_h :: tablePropertyIR_t* be tablePropertyIR*)

      2. (TableProperty_inst: Ci_0 sto_0 |- tablePropertyIR_h ==> Ci_1 sto_1 tablePropertyIR_h')

      3. (TableProperties_inst: Ci_1 sto_1 |- tablePropertyIR_t* ==> Ci_2 sto_2 tablePropertyIR'*)

      4. If ((tablePropertyIR'* = tablePropertyIR_t*)), then

        1. Result in Ci_2, sto_2, tablePropertyIR_h' :: tablePropertyIR_t*

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:67.1-69.26
relation ObjectDecls_inst: 



;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:74.1-76.23
relation Methods_inst: 



;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:78.1-80.23
relation Method_inst: 



;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:86.1-88.26
relation Stmts_inst: 



;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:90.1-92.26
relation Stmt_inst: 

  emptyStatementIR: p Ci sto |- statementIR ==> % % % {

    1. If ((statementIR has type emptyStatementIR)), then

      1. (Let emptyStatementIR be (statementIR as emptyStatementIR))

      2. Result in Ci, sto, (emptyStatementIR as statementIR)

  }

  assignmentStatementIR: p Ci sto |- statementIR ==> % % % {

    1. If ((statementIR has type assignmentStatementIR)), then

      1. (Let assignmentStatementIR be (statementIR as assignmentStatementIR))

      2. Result in Ci, sto, (assignmentStatementIR as statementIR)

  }

  callStatementIR: p Ci sto |- statementIR ==> % % % {

    1. If ((statementIR has type callStatementIR)), then

      1. (Let callStatementIR be (statementIR as callStatementIR))

      2. Result in Ci, sto, (callStatementIR as statementIR)

  }

  directApplicationStatementIR: p Ci sto_0 |- statementIR ==> % % % {

    1. If ((statementIR has type directApplicationStatementIR)), then

      1. (Let (prefixedNameIR .apply( argumentListIR );) be (statementIR as directApplicationStatementIR))

      2. (Let (rid, consDyn, id*)? be $find_constructor_overloaded_inst(Ci, prefixedNameIR, []))

      3. If (((rid, consDyn, id*)? matches pattern (_))), then

        1. (Let ?((_rid, consDyn, _id*)) be (rid, consDyn, id*)?)

        2. (Constructor_inst: p Ci sto_0 |- consDyn < [] >( [] # [] )==> sto_1 objDyn)

        3. (Let tid_fresh be $fresh_tid)

        4. (Let tid be $flatten_prefixedNameIR(prefixedNameIR))

        5. (Let typeIR be ((tid tid) as typeIR))

        6. (Let nameIR be $concat_text([tid, "_", tid_fresh]))

        7. (Let oid be Ci.path ++ [nameIR])

        8. (Let sto_2 be $add_sto(sto_1, oid, objDyn))

        9. (Let constantDeclarationIR be (() const typeIR nameIR (= ((! oid) as value)) ;))

        10. (Let routineTargetIR be ((((` tid) as expressionIR) # (( typeIR (ctk) ))) . "apply"))

        11. (Let callStatementIR be (routineTargetIR < [] >( argumentListIR );))

        12. (Let blockStatementIR be (() { [(constantDeclarationIR as blockElementStatementIR), (callStatementIR as blockElementStatementIR)] }))

        13. Result in Ci, sto_2, (blockStatementIR as statementIR)

  }

  returnStatementIR: p Ci sto |- statementIR ==> % % % {

    1. If ((statementIR has type returnStatementIR)), then

      1. (Let returnStatementIR be (statementIR as returnStatementIR))

      2. Result in Ci, sto, (returnStatementIR as statementIR)

  }

  exitStatementIR: p Ci sto |- statementIR ==> % % % {

    1. If ((statementIR has type exitStatementIR)), then

      1. (Let exitStatementIR be (statementIR as exitStatementIR))

      2. Result in Ci, sto, (exitStatementIR as statementIR)

  }

  blockStatementIR: p Ci sto |- statementIR ==> % % % {

    1. If ((statementIR has type blockStatementIR)), then

      1. (Let (annotationList { blockElementStatementListIR }) be (statementIR as blockStatementIR))

      2. (Block_inst: Ci sto false |- (annotationList { blockElementStatementListIR }) ==> Ci' sto' (_annotationList { blockElementStatementListIR' }))

      3. Result in Ci', sto', ((annotationList { blockElementStatementListIR' }) as statementIR)

  }

  conditionalStatementIR-non-else: p Ci sto |- statementIR'' ==> % % % {

    1. If ((statementIR'' has type conditionalStatementIR)), then

      1. (Let conditionalStatementIR be (statementIR'' as conditionalStatementIR))

      2. If ((conditionalStatementIR matches pattern `IF(%)%`)), then

        1. (Let (if( typedExpressionIR ) statementIR) be conditionalStatementIR)

        2. (Stmt_inst: p Ci sto |- statementIR ==> _contextInst sto' statementIR')

        3. Result in Ci, sto', ((if( typedExpressionIR ) statementIR') as statementIR)

  }

  conditionalStatementIR-else: p Ci sto |- statementIR ==> % % % {

    1. If ((statementIR has type conditionalStatementIR)), then

      1. (Let conditionalStatementIR be (statementIR as conditionalStatementIR))

      2. If ((conditionalStatementIR matches pattern `IF(%)%ELSE%`)), then

        1. (Let (if( typedExpressionIR ) statementIR_then else statementIR_else) be conditionalStatementIR)

        2. (Stmt_inst: p Ci sto |- statementIR_then ==> _contextInst sto' statementIR_then')

        3. (Stmt_inst: p Ci sto' |- statementIR_else ==> _contextInst' sto'' statementIR_else')

        4. Result in Ci, sto'', ((if( typedExpressionIR ) statementIR_then' else statementIR_else') as statementIR)

  }

  breakStatementIR: p Ci sto |- statementIR ==> % % % {

    1. If ((statementIR has type breakStatementIR)), then

      1. (Let breakStatementIR be (statementIR as breakStatementIR))

      2. Result in Ci, sto, (breakStatementIR as statementIR)

  }

  continueStatementIR: p Ci sto |- statementIR ==> % % % {

    1. If ((statementIR has type continueStatementIR)), then

      1. (Let continueStatementIR be (statementIR as continueStatementIR))

      2. Result in Ci, sto, (continueStatementIR as statementIR)

  }

  switchStatementIR: p Ci sto |- statementIR ==> % % % {

    1. If ((statementIR has type switchStatementIR)), then

      1. (Let (switch( typedExpressionIR ){ switchCaseListIR }) be (statementIR as switchStatementIR))

      2. (SwitchCases_inst: p Ci sto |- switchCaseListIR ==> Ci' sto' switchCaseListIR')

      3. Result in Ci', sto', ((switch( typedExpressionIR ){ switchCaseListIR' }) as statementIR)

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:94.1-96.23
relation BlockElementStmt_inst: 

  constantDeclarationIR: Ci sto |- blockElementStatementIR ==> % % % {

    1. If ((blockElementStatementIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (blockElementStatementIR as constantDeclarationIR))

      2. (Decl_inst: (local) Ci sto |- (constantDeclarationIR as declarationIR) ==> Ci' sto' declarationIR'?)

      3. If ((declarationIR'? matches pattern (_))), then

        1. (Let ?(declarationIR) be declarationIR'?)

        2. If ((declarationIR has type constantDeclarationIR)), then

          1. (Let constantDeclarationIR' be (declarationIR as constantDeclarationIR))

          2. Result in Ci', sto', ?((constantDeclarationIR' as blockElementStatementIR))

  }

  variableDeclarationIR: Ci sto |- blockElementStatementIR ==> % % % {

    1. If ((blockElementStatementIR has type variableDeclarationIR)), then

      1. (Let variableDeclarationIR be (blockElementStatementIR as variableDeclarationIR))

      2. Result in Ci, sto, ?((variableDeclarationIR as blockElementStatementIR))

  }

  statementIR: Ci sto |- blockElementStatementIR ==> % % % {

    1. If ((blockElementStatementIR has type statementIR)), then

      1. (Let statementIR be (blockElementStatementIR as statementIR))

      2. (Stmt_inst: (local) Ci sto |- statementIR ==> Ci' sto' statementIR_inst)

      3. Result in Ci', sto', ?((statementIR_inst as blockElementStatementIR))

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:98.1-100.23
relation BlockElementStmts_inst: 

  nil: Ci sto |- blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} ==> % % % {

    1. If ((blockElementStatementIR* matches pattern [])), then

      1. Result in Ci, sto, []

  }

  cons: Ci_0 sto_0 |- blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*} ==> % % % {

    1. If ((blockElementStatementIR* matches pattern _ :: _)), then

      1. (Let blockElementStatementIR_h :: blockElementStatementIR_t* be blockElementStatementIR*)

      2. (BlockElementStmt_inst: Ci_0 sto_0 |- blockElementStatementIR_h ==> Ci_1 sto_1 blockElementStatementIR'?)

      3. If ((blockElementStatementIR'? matches pattern (_))), then

        1. (Let ?(blockElementStatementIR_h') be blockElementStatementIR'?)

        2. (BlockElementStmts_inst: Ci_1 sto_1 |- blockElementStatementIR_t* ==> Ci_2 sto_2 blockElementStatementIR_t'*)

        3. Result in Ci_2, sto_2, blockElementStatementIR_h' :: blockElementStatementIR_t'*

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:102.1-104.26
relation SwitchCases_inst: 



;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:106.1-108.26
relation SwitchCase_inst: 

  match: p Ci sto |- switchCaseIR ==> % % % {

    1. If ((switchCaseIR matches pattern `%:%`)), then

      1. (Let (switchLabelIR : blockStatementIR) be switchCaseIR)

      2. (Stmt_inst: p Ci sto |- (blockStatementIR as statementIR) ==> Ci' sto' statementIR)

      3. If ((statementIR has type blockStatementIR)), then

        1. (Let blockStatementIR' be (statementIR as blockStatementIR))

        2. Result in Ci', sto', (switchLabelIR : blockStatementIR')

  }

  fallthrough: p Ci sto |- switchCaseIR ==> % % % {

    1. If ((switchCaseIR matches pattern `%:`)), then

      1. (Let (switchLabelIR :) be switchCaseIR)

      2. Result in Ci, sto, (switchLabelIR :)

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:114.1-116.23
relation ParserStmt_inst: 

  constantDeclarationIR: Ci sto |- parserStatementIR ==> % % % {

    1. If ((parserStatementIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (parserStatementIR as constantDeclarationIR))

      2. Result in Ci, sto, ?((constantDeclarationIR as parserStatementIR))

  }

  variableDeclarationIR: Ci sto |- parserStatementIR ==> % % % {

    1. If ((parserStatementIR has type variableDeclarationIR)), then

      1. (Let variableDeclarationIR be (parserStatementIR as variableDeclarationIR))

      2. Result in Ci, sto, ?((variableDeclarationIR as parserStatementIR))

  }

  emptyStatementIR: Ci_0 sto_0 |- parserStatementIR ==> % % % {

    1. If ((parserStatementIR has type emptyStatementIR)), then

      1. (Let emptyStatementIR be (parserStatementIR as emptyStatementIR))

      2. (Stmt_inst: (local) Ci_0 sto_0 |- (emptyStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

      3. If ((statementIR has type emptyStatementIR)), then

        1. (Let emptyStatementIR_inst be (statementIR as emptyStatementIR))

        2. Result in Ci_1, sto_1, ?((emptyStatementIR_inst as parserStatementIR))

  }

  assignmentStatementIR: Ci_0 sto_0 |- parserStatementIR ==> % % % {

    1. If ((parserStatementIR has type assignmentStatementIR)), then

      1. (Let assignmentStatementIR be (parserStatementIR as assignmentStatementIR))

      2. (Stmt_inst: (local) Ci_0 sto_0 |- (assignmentStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

      3. If ((statementIR has type assignmentStatementIR)), then

        1. (Let assignmentStatementIR_inst be (statementIR as assignmentStatementIR))

        2. Result in Ci_1, sto_1, ?((assignmentStatementIR_inst as parserStatementIR))

  }

  callStatementIR: Ci_0 sto_0 |- parserStatementIR ==> % % % {

    1. If ((parserStatementIR has type callStatementIR)), then

      1. (Let callStatementIR be (parserStatementIR as callStatementIR))

      2. (Stmt_inst: (local) Ci_0 sto_0 |- (callStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

      3. If ((statementIR has type callStatementIR)), then

        1. (Let callStatementIR_inst be (statementIR as callStatementIR))

        2. Result in Ci_1, sto_1, ?((callStatementIR_inst as parserStatementIR))

  }

  directApplicationStatementIR: Ci_0 sto_0 |- parserStatementIR ==> % % % {

    1. If ((parserStatementIR has type directApplicationStatementIR)), then

      1. (Let directApplicationStatementIR be (parserStatementIR as directApplicationStatementIR))

      2. (Stmt_inst: (local) Ci_0 sto_0 |- (directApplicationStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

      3. If ((statementIR has type directApplicationStatementIR)), then

        1. (Let directApplicationStatementIR_inst be (statementIR as directApplicationStatementIR))

        2. Result in Ci_1, sto_1, ?((directApplicationStatementIR_inst as parserStatementIR))

  }

  parserBlockStatementIR: Ci_0 sto_0 |- parserStatementIR ==> % % % {

    1. If ((parserStatementIR has type parserBlockStatementIR)), then

      1. (Let (annotationList { parserStatementListIR }) be (parserStatementIR as parserBlockStatementIR))

      2. (ParserStmts_inst: Ci_0 sto_0 |- parserStatementListIR ==> Ci_1 sto_1 parserStatementListIR_inst)

      3. (Let parserBlockStatementIR be (annotationList { parserStatementListIR_inst }))

      4. Result in Ci_1, sto_1, ?((parserBlockStatementIR as parserStatementIR))

  }

  conditionalStatementIR: Ci_0 sto_0 |- parserStatementIR ==> % % % {

    1. If ((parserStatementIR has type conditionalStatementIR)), then

      1. (Let conditionalStatementIR be (parserStatementIR as conditionalStatementIR))

      2. (Stmt_inst: (local) Ci_0 sto_0 |- (conditionalStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

      3. If ((statementIR has type conditionalStatementIR)), then

        1. (Let conditionalStatementIR_inst be (statementIR as conditionalStatementIR))

        2. Result in Ci_1, sto_1, ?((conditionalStatementIR_inst as parserStatementIR))

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:118.1-120.23
relation ParserStmts_inst: 

  nil: Ci sto |- parserStatementIR*{parserStatementIR <- parserStatementIR*} ==> % % % {

    1. If ((parserStatementIR* matches pattern [])), then

      1. Result in Ci, sto, []

  }

  cons: Ci_0 sto_0 |- parserStatementIR*{parserStatementIR <- parserStatementIR*} ==> % % % {

    1. If ((parserStatementIR* matches pattern _ :: _)), then

      1. (Let parserStatementIR_h :: parserStatementIR_t* be parserStatementIR*)

      2. (ParserStmt_inst: Ci_0 sto_0 |- parserStatementIR_h ==> Ci_1 sto_1 parserStatementIR'?)

      3. If ((parserStatementIR'? matches pattern (_))), then

        1. (Let ?(parserStatementIR_h') be parserStatementIR'?)

        2. (ParserStmts_inst: Ci_1 sto_1 |- parserStatementIR_t* ==> Ci_2 sto_2 parserStatementIR_t'*)

        3. Result in Ci_2, sto_2, parserStatementIR_h' :: parserStatementIR_t'*

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:122.1-124.23
relation ParserState_inst: 

  : Ci_0 sto_0 |- annotationList state nameIR { parserStatementListIR transitionStatementIR } ==> % % {

    1. (ParserStmts_inst: Ci_0 sto_0 |- parserStatementListIR ==> Ci_1 sto_1 parserStatementListIR_inst)

    2. Result in Ci_0, sto_0

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:126.1-128.23
relation ParserStates_inst: 



;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:131.1-133.26
relation Block_inst: 

  start: Ci_0 sto_0 bool |- annotationList { blockElementStatementListIR } ==> % % % {

    1. If ((bool = true)), then

      1. (BlockElementStmts_inst: Ci_0 sto_0 |- blockElementStatementListIR ==> Ci_1 sto_1 blockElementStatementListIR_inst)

      2. Result in Ci_1, sto_1, (annotationList { blockElementStatementListIR_inst })

  }

  no-start: Ci_0 sto_0 bool |- annotationList { blockElementStatementListIR } ==> % % % {

    1. If ((bool = false)), then

      1. (Let Ci_1 be $enter_inst(Ci_0))

      2. (BlockElementStmts_inst: Ci_1 sto_0 |- blockElementStatementListIR ==> Ci_2 sto_1 blockElementStatementListIR_inst)

      3. (Let Ci_3 be $exit_inst(Ci_2))

      4. Result in Ci_2, sto_1, (annotationList { blockElementStatementListIR_inst })

  }

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:135.1-137.26
relation Table_inst: 



;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:1.1-1.84
def $partition_default_parameters(parameterIR*, id_default*)

1. Case analysis on parameterIR*

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let parameterIR_h :: parameterIR_t* be parameterIR*)

    2. (Let (_annotationList _direction _typeIR id_h _constantInitializerOptIR) be parameterIR_h)

    3. (Let (parameterIR_nondefault*, parameterIR_default*) be $partition_default_parameters(parameterIR_t*, id_default*))

    4. Case analysis on id_h is in id_default*

      1. Case true

        1. Return (parameterIR_nondefault*, parameterIR_h :: parameterIR_default*)

      2. Case false

        1. Return (parameterIR_h :: parameterIR_nondefault*, parameterIR_default*)

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:24.1-24.146
def $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*)

1. (Let (constructorParameterIR_nondefault*, constructorParameterIR_default*) be $partition_default_parameters(constructorParameterIR*, id_default*))

2. (Let (_annotationList _direction _typeIR id _constantInitializerOptIR) be constructorParameterIR_nondefault)*

3. (Let (constructorParameterIR_aligned*, argumentIR_aligned*) be $align_cparams_with_args'(({ (id : constructorParameterIR_nondefault)* }), constructorParameterIR_nondefault*, argumentIR*))

4. (Let (_annotationList' _direction' _typeIR' _nameIR constantInitializerOptIR) be constructorParameterIR_default)*

5. If ((constantInitializerOptIR matches pattern (_)))*, then

  1. (Let ?((= value_default)) be constantInitializerOptIR)*

  2. Return (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*)

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:25.1-25.142
def $align_cparams_with_args'(({ (id_map : constructorParameterIR_map)* }), constructorParameterIR*, argumentIR*)

1. Case analysis on constructorParameterIR*

  1. Case (% matches pattern _ :: _)

    1. (Let constructorParameterIR_h :: constructorParameterIR_t* be constructorParameterIR*)

    2. If ((argumentIR* matches pattern _ :: _)), then

      1. (Let argumentIR_h :: argumentIR_t* be argumentIR*)

      2. (Let argumentIR' be argumentIR_h)

      3. If ((argumentIR' has type typedExpressionIR)), then

        1. (Let typedExpressionIR be (argumentIR' as typedExpressionIR))

        2. (Let (constructorParameterIR_aligned*, argumentIR_aligned*) be $align_cparams_with_args'(({ (id_map : constructorParameterIR_map)* }), constructorParameterIR_t*, argumentIR_t*))

        3. Return (constructorParameterIR_h :: constructorParameterIR_aligned*, argumentIR_h :: argumentIR_aligned*)

      4. If ((argumentIR_h matches pattern `_`)), then

        1. (Let (constructorParameterIR_aligned*, argumentIR_aligned*) be $align_cparams_with_args'(({ (id_map : constructorParameterIR_map)* }), constructorParameterIR_t*, argumentIR_t*))

        2. Return (constructorParameterIR_h :: constructorParameterIR_aligned*, argumentIR_h :: argumentIR_aligned*)

      5. If ((argumentIR' matches pattern `%=%`)), then

        1. (Let (nameIR = _typedExpressionIR) be argumentIR')

        2. (Let constructorParameterIR'? be $find_map<id, constructorParameterIR>(({ (id_map : constructorParameterIR_map)* }), nameIR))

        3. If ((constructorParameterIR'? matches pattern (_))), then

          1. (Let ?(constructorParameterIR_matching) be constructorParameterIR'?)

          2. (Let (constructorParameterIR_aligned*, argumentIR_aligned*) be $align_cparams_with_args'(({ (id_map : constructorParameterIR_map)* }), constructorParameterIR_t*, argumentIR_t*))

          3. Return (constructorParameterIR_matching :: constructorParameterIR_aligned*, argumentIR_h :: argumentIR_aligned*)

  2. Case (% matches pattern [])

    1. If ((argumentIR* matches pattern [])), then

      1. Return ([], [])

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:70.1-72.32
relation Eval_args: 

  nil: p p_callee Ci_0 sto_0 |- id*{id <- id*} argumentIR*{argumentIR <- argumentIR*} ==> % % {

    1. If ((id* matches pattern [])), then

      1. If ((argumentIR* matches pattern [])), then

        1. Result in Ci_0, sto_0

  }

  cons: p p_callee Ci_0 sto_0 |- id*{id <- id*} argumentIR*{argumentIR <- argumentIR*} ==> % % {

    1. If ((id* matches pattern _ :: _)), then

      1. (Let id_h :: id_t* be id*)

      2. If ((argumentIR* matches pattern _ :: _)), then

        1. (Let argumentIR_h :: argumentIR_t* be argumentIR*)

        2. (Eval_arg: p p_callee Ci_0 sto_0 |- id_h argumentIR_h ==> Ci_1 sto_1)

        3. (Eval_args: p p_callee Ci_1 sto_1 |- id_t* argumentIR_t* ==> Ci_2 sto_2)

        4. Result in Ci_2, sto_2

  }

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:74.1-76.32
relation Eval_arg: 

  : p p_callee Ci_0 sto_0 |- id argumentIR ==> % % {

    1. (Let Ci_caller be $enter_path(Ci_0, id))

    2. (Argument_inst: p Ci_caller sto_0 |- argumentIR ==> sto_1 value)

    3. (Let Ci_1 be $add_value_inst(p_callee, Ci_0, id, value))

    4. Result in Ci_1, sto_1

  }

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:170.1-170.59
def $init_table(tablePropertyListIR)

1. Return tablePropertyListIR

;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:408.1-408.34
def $size



;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:24.1-24.70
def $get_init_decls



;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:38.1-38.37
def $is_extern_object(objDyn')

1. If ((objDyn' matches pattern `EXTERN{%%%%}`)), then

  1. (Let (extern{ _tid _theta _venv _renv }) be objDyn')

  2. Return true

2. Return false

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:60.1-60.43
def $rid_IR(nameIR, parameterIR*)

1. Return (nameIR ( $pid_IR(parameterIR)* ))

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:61.1-61.31
def $pid_IR((_annotationList _direction _typeIR nameIR constantInitializerOptIR'))

1. (Let constantInitializerIR? be constantInitializerOptIR')

2. If ((constantInitializerIR? matches pattern ())), then

  1. Return (nameIR # false)

3. If ((constantInitializerOptIR' matches pattern (_))), then

  1. (Let ?(constantInitializerIR) be constantInitializerOptIR')

  2. Return (nameIR # true)

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:68.1-68.54
def $cid_IR(nameIR, constructorParameterListIR)

1. Return $rid_IR(nameIR, constructorParameterListIR)
