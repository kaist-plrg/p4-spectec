;; ../../../../spec-concrete/0-aux.watsup:18.1-18.21
def $sum



;; ../../../../spec-concrete/0-aux.watsup:20.1-20.21
def $max



;; ../../../../spec-concrete/0-aux.watsup:22.1-22.21
def $min



;; ../../../../spec-concrete/0-aux.watsup:28.1-28.29
def $int_to_text



;; ../../../../spec-concrete/0-aux.watsup:30.1-30.31
def $concat_text(text*)

1. Case analysis on text*

  1. Case (% matches pattern [])

    1. Return ""

  2. Case (% matches pattern _ :: _)

    1. (Let t_h :: t_t* be text*)

    2. Return t_h ++ $concat_text(t_t*)

;; ../../../../spec-concrete/0-aux.watsup:34.1-34.37
def $strip_prefix



;; ../../../../spec-concrete/0-aux.watsup:35.1-35.37
def $strip_suffix



;; ../../../../spec-concrete/0-aux.watsup:41.1-41.23
def $init_(nat')

1. (Let nat be nat')

2. If ((nat = 0)), then

  1. Return []

3. (Let n be nat')

4. Otherwise

  1. Return (n - 1) :: $init_((n - 1))

;; ../../../../spec-concrete/0-aux.watsup:46.1-46.29
def $repeat_<X>(X, nat')

1. (Let nat be nat')

2. If ((nat = 0)), then

  1. Return []

3. (Let n be nat')

4. Otherwise

  1. Return [X] ++ $repeat_<X>(X, (n - 1))

;; ../../../../spec-concrete/0-aux.watsup:51.1-51.22
def $rev_<X>



;; ../../../../spec-concrete/0-aux.watsup:53.1-53.28
def $concat_<X>



;; ../../../../spec-concrete/0-aux.watsup:55.1-55.39
def $partition_<X>



;; ../../../../spec-concrete/0-aux.watsup:57.1-57.35
def $assoc_<X, Y>



;; ../../../../spec-concrete/0-aux.watsup:59.1-59.29
def $distinct_<K>



;; ../../../../spec-concrete/0-aux.watsup:65.17-65.24
syntax set<K> = 
   | { K* }

;; ../../../../spec-concrete/0-aux.watsup:67.1-67.27
def $empty_set<K>

1. Return ({ [] })

;; ../../../../spec-concrete/0-aux.watsup:70.1-70.33
def $in_set<K>(K, ({ K_e* }))

1. Return K is in K_e*

;; ../../../../spec-concrete/0-aux.watsup:73.1-73.47
def $intersect_set<K>



;; ../../../../spec-concrete/0-aux.watsup:75.1-75.43
def $union_set<K>



;; ../../../../spec-concrete/0-aux.watsup:77.1-77.37
def $unions_set<K>



;; ../../../../spec-concrete/0-aux.watsup:79.1-79.42
def $diff_set<K>



;; ../../../../spec-concrete/0-aux.watsup:81.1-81.39
def $sub_set<K>



;; ../../../../spec-concrete/0-aux.watsup:83.1-83.38
def $eq_set<K>



;; ../../../../spec-concrete/0-aux.watsup:89.21-89.27
syntax pair<K, V> = 
   | K : V

;; ../../../../spec-concrete/0-aux.watsup:91.20-91.35
syntax map<K, V> = set<pair<K, V>>

;; ../../../../spec-concrete/0-aux.watsup:93.1-93.33
def $empty_map<K, V>

1. Return ({ [] })

;; ../../../../spec-concrete/0-aux.watsup:96.1-96.39
def $dom_map<K, V>(({ (K : V)* }))

1. Return ({ K* })

;; ../../../../spec-concrete/0-aux.watsup:99.1-99.39
def $find_map<K, V>



;; ../../../../spec-concrete/0-aux.watsup:101.1-101.41
def $find_maps<K, V>



;; ../../../../spec-concrete/0-aux.watsup:103.1-103.48
def $add_map<K, V>



;; ../../../../spec-concrete/0-aux.watsup:105.1-105.51
def $adds_map<K, V>



;; ../../../../spec-concrete/0-aux.watsup:107.1-107.51
def $update_map<K, V>



;; ../../../../spec-concrete/1-syntax.watsup:6.1-7.7
syntax trailingCommaOpt = 
   | 
   | ,

;; ../../../../spec-concrete/1-syntax.watsup:14.1-15.10
syntax booleanLiteral = 
   | true
   | false

;; ../../../../spec-concrete/1-syntax.watsup:22.1-24.35
syntax numberLiteral = 
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)

;; ../../../../spec-concrete/1-syntax.watsup:30.24-30.57
syntax stringLiteral = 
   | " text " hint(print "#%#")

;; ../../../../spec-concrete/1-syntax.watsup:43.21-43.29
syntax identifier = 
   | text

;; ../../../../spec-concrete/1-syntax.watsup:44.25-44.34
syntax typeIdentifier = 
   | text

;; ../../../../spec-concrete/1-syntax.watsup:51.1-53.30
syntax nonTypeName = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority

;; ../../../../spec-concrete/1-syntax.watsup:56.1-57.23
syntax prefixedNonTypeName = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName

;; ../../../../spec-concrete/1-syntax.watsup:63.19-63.33
syntax typeName = typeIdentifier

;; ../../../../spec-concrete/1-syntax.watsup:66.1-67.21
syntax prefixedTypeName = 
   | text
   | . typeName

;; ../../../../spec-concrete/1-syntax.watsup:74.1-76.36
syntax tableCustomName = 
   | text
   | text
   | apply
   | state
   | type
   | priority

;; ../../../../spec-concrete/1-syntax.watsup:83.1-85.9
syntax name = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list

;; ../../../../spec-concrete/1-syntax.watsup:88.1-89.21
syntax nameList = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list
   | nameList , name

;; ../../../../spec-concrete/1-syntax.watsup:91.1-91.40
def $flatten_nameList(nameList'')

1. (Let nameList be nameList'')

2. If ((nameList has type name)), then

  1. (Let name be (nameList as name))

  2. Return [name]

3. (Let nameList' be nameList'')

4. If ((nameList' matches pattern `%,%`)), then

  1. (Let (nameList , name) be nameList')

  2. Return $flatten_nameList(nameList) ++ [name]

;; ../../../../spec-concrete/1-syntax.watsup:96.17-96.21
syntax member = name

;; ../../../../spec-concrete/1-syntax.watsup:102.20-102.45
syntax direction = 
   | 
   | in
   | out
   | inout

;; ../../../../spec-concrete/1-syntax.watsup:115.1-126.32
syntax baseType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>

;; ../../../../spec-concrete/1-syntax.watsup:134.26-134.64
syntax specializedType = 
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:137.1-138.20
syntax namedType = 
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:144.26-144.51
syntax headerStackType = 
   | namedType [ expression ]

;; ../../../../spec-concrete/1-syntax.watsup:152.19-152.41
syntax listType = 
   | list< typeArgument >

;; ../../../../spec-concrete/1-syntax.watsup:158.20-158.47
syntax tupleType = 
   | tuple< typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:165.1-169.14
syntax type = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:172.1-174.15
syntax typeOrVoid = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | text

;; ../../../../spec-concrete/1-syntax.watsup:180.24-180.28
syntax typeParameter = name

;; ../../../../spec-concrete/1-syntax.watsup:183.1-184.39
syntax typeParameterList = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | text
   | list
   | typeParameterList , typeParameter

;; ../../../../spec-concrete/1-syntax.watsup:186.1-186.67
def $flatten_typeParameterList(typeParameterList'')

1. (Let typeParameterList be typeParameterList'')

2. If ((typeParameterList has type typeParameter)), then

  1. (Let typeParameter be (typeParameterList as typeParameter))

  2. Return [typeParameter]

3. (Let typeParameterList' be typeParameterList'')

4. If ((typeParameterList' matches pattern `%,%`)), then

  1. (Let (typeParameterList , typeParameter) be typeParameterList')

  2. Return $flatten_typeParameterList(typeParameterList) ++ [typeParameter]

;; ../../../../spec-concrete/1-syntax.watsup:192.1-193.27
syntax typeParameterListOpt = 
   | 
   | < typeParameterList >

;; ../../../../spec-concrete/1-syntax.watsup:195.1-195.73
def $flatten_typeParameterListOpt(typeParameterListOpt)

1. Case analysis on typeParameterListOpt

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `<%>`)

    1. (Let (< typeParameterList >) be typeParameterListOpt)

    2. Return $flatten_typeParameterList(typeParameterList)

;; ../../../../spec-concrete/1-syntax.watsup:207.3-207.52
syntax parameter = 
   | annotationList direction type name initializerOpt

;; ../../../../spec-concrete/1-syntax.watsup:210.1-211.39
syntax nonEmptyParameterList = 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList , parameter

;; ../../../../spec-concrete/1-syntax.watsup:214.1-215.26
syntax parameterList = 
   | 
   | annotationList direction type name initializerOpt
   | nonEmptyParameterList , parameter

;; ../../../../spec-concrete/1-syntax.watsup:217.1-217.55
def $flatten_parameterList(parameterList)

1. If ((parameterList matches pattern ``EMPTY`)), then

  1. Return []

2. If ((parameterList has type parameter)), then

  1. (Let parameter be (parameterList as parameter))

  2. Return [parameter]

3. If ((parameterList has type nonEmptyParameterList)), then

  1. (Let nonEmptyParameterList' be (parameterList as nonEmptyParameterList))

  2. If ((nonEmptyParameterList' matches pattern `%,%`)), then

    1. (Let (nonEmptyParameterList , parameter) be nonEmptyParameterList')

    2. Return $flatten_parameterList((nonEmptyParameterList as parameterList)) ++ [parameter]

;; ../../../../spec-concrete/1-syntax.watsup:227.31-227.40
syntax constructorParameter = parameter

;; ../../../../spec-concrete/1-syntax.watsup:229.35-229.48
syntax constructorParameterList = parameterList

;; ../../../../spec-concrete/1-syntax.watsup:232.1-233.23
syntax constructorParameterListOpt = 
   | 
   | ( parameterList )

;; ../../../../spec-concrete/1-syntax.watsup:235.1-236.26
def $flatten_constructorParameterListOpt(constructorParameterListOpt)

1. Case analysis on constructorParameterListOpt

  1. Case (% matches pattern ``EMPTY`)

    1. Return []

  2. Case (% matches pattern `(%)`)

    1. (Let (( parameterList )) be constructorParameterListOpt)

    2. Return $flatten_parameterList(parameterList)

;; ../../../../spec-concrete/1-syntax.watsup:246.26-246.44
syntax namedExpression = 
   | name = expression

;; ../../../../spec-concrete/1-syntax.watsup:249.1-250.43
syntax namedExpressionList = 
   | name = expression
   | namedExpressionList , namedExpression

;; ../../../../spec-concrete/1-syntax.watsup:252.1-252.73
def $flatten_namedExpressionList(namedExpressionList'')

1. (Let namedExpressionList be namedExpressionList'')

2. If ((namedExpressionList has type namedExpression)), then

  1. (Let namedExpression be (namedExpressionList as namedExpression))

  2. Return [namedExpression]

3. (Let namedExpressionList' be namedExpressionList'')

4. If ((namedExpressionList' matches pattern `%,%`)), then

  1. (Let (namedExpressionList , namedExpression) be namedExpressionList')

  2. Return $flatten_namedExpressionList(namedExpressionList) ++ [namedExpression]

;; ../../../../spec-concrete/1-syntax.watsup:266.1-268.18
syntax literalExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")

;; ../../../../spec-concrete/1-syntax.watsup:275.1-276.9
syntax referenceExpression = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this

;; ../../../../spec-concrete/1-syntax.watsup:282.28-282.32
syntax defaultExpression = 
   | ...

;; ../../../../spec-concrete/1-syntax.watsup:290.15-290.32
syntax unop = 
   | !
   | ~
   | -
   | +

;; ../../../../spec-concrete/1-syntax.watsup:292.26-292.41
syntax unaryExpression = 
   | unop expression

;; ../../../../spec-concrete/1-syntax.watsup:295.1-297.35
syntax binop = 
   | *
   | /
   | %
   | +
   | -
   | |+|
   | |-|
   | <<
   | >>
   | <=
   | >=
   | <
   | >
   | !=
   | ==
   | &
   | ^
   | |
   | ++
   | &&
   | ||

;; ../../../../spec-concrete/1-syntax.watsup:299.27-299.54
syntax binaryExpression = 
   | expression binop expression

;; ../../../../spec-concrete/1-syntax.watsup:302.3-302.38
syntax binaryExpressionNonBrace = 
   | expressionNonBrace binop expression

;; ../../../../spec-concrete/1-syntax.watsup:305.3-305.41
syntax ternaryExpression = 
   | expression ? expression : expression

;; ../../../../spec-concrete/1-syntax.watsup:308.3-308.49
syntax ternaryExpressionNonBrace = 
   | expressionNonBrace ? expression : expression

;; ../../../../spec-concrete/1-syntax.watsup:314.25-314.45
syntax castExpression = 
   | ( type ) expression

;; ../../../../spec-concrete/1-syntax.watsup:323.1-324.48
syntax dataExpression = 
   | {#}
   | { dataElementExpression trailingCommaOpt }

;; ../../../../spec-concrete/1-syntax.watsup:333.3-333.18
syntax errorAccessExpression = 
   | error. member

;; ../../../../spec-concrete/1-syntax.watsup:336.3-336.29
syntax memberAccessExpression = 
   | memberAccessBase . member

;; ../../../../spec-concrete/1-syntax.watsup:339.1-340.45
syntax indexAccessExpression = 
   | expression [ expression ]
   | expression [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:343.1-345.26
syntax accessExpression = 
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:348.3-348.37
syntax memberAccessExpressionNonBrace = 
   | memberAccessBaseNonBrace . member

;; ../../../../spec-concrete/1-syntax.watsup:351.1-352.53
syntax indexAccessExpressionNonBrace = 
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:355.1-357.34
syntax accessExpressionNonBrace = 
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]

;; ../../../../spec-concrete/1-syntax.watsup:371.1-372.62
syntax callExpression = 
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )

;; ../../../../spec-concrete/1-syntax.watsup:375.1-376.70
syntax callExpressionNonBrace = 
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )

;; ../../../../spec-concrete/1-syntax.watsup:382.34-382.49
syntax parenthesizedExpression = 
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:389.1-399.28
syntax expression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:403.1-405.33
syntax expressionList = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expressionList , expression

;; ../../../../spec-concrete/1-syntax.watsup:407.1-407.58
def $flatten_expressionList(expressionList'')

1. (Let expressionList be expressionList'')

2. If ((expressionList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let expressionList be expressionList'')

4. If ((expressionList has type expression)), then

  1. (Let expression be (expressionList as expression))

  2. Return [expression]

5. (Let expressionList' be expressionList'')

6. If ((expressionList' matches pattern `%,%`)), then

  1. (Let (expressionList , expression) be expressionList')

  2. Return $flatten_expressionList(expressionList) ++ [expression]

;; ../../../../spec-concrete/1-syntax.watsup:414.1-415.15
syntax memberAccessBase = 
   | text
   | . typeName
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:417.36-417.50
syntax sequenceElementExpression = expressionList

;; ../../../../spec-concrete/1-syntax.watsup:420.1-423.54
syntax recordElementExpression = 
   | name = expression
   | name = expression ,...
   | name = expression , namedExpressionList
   | name = expression , namedExpressionList ,...

;; ../../../../spec-concrete/1-syntax.watsup:426.1-427.28
syntax dataElementExpression = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expressionList , expression
   | name = expression
   | name = expression ,...
   | name = expression , namedExpressionList
   | name = expression , namedExpressionList ,...

;; ../../../../spec-concrete/1-syntax.watsup:429.24-429.34
syntax routineTarget = expression

;; ../../../../spec-concrete/1-syntax.watsup:430.28-430.37
syntax constructorTarget = namedType

;; ../../../../spec-concrete/1-syntax.watsup:433.1-434.22
syntax callTarget = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:441.1-449.28
syntax expressionNonBrace = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:452.1-453.23
syntax memberAccessBaseNonBrace = 
   | text
   | . typeName
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:455.32-455.50
syntax routineTargetNonBrace = expressionNonBrace

;; ../../../../spec-concrete/1-syntax.watsup:458.1-459.22
syntax callTargetNonBrace = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >

;; ../../../../spec-concrete/1-syntax.watsup:461.1-461.57
def $expressionNonBrace(expressionNonBrace'')

1. (Let expressionNonBrace be expressionNonBrace'')

2. If ((expressionNonBrace has type literalExpression)), then

  1. (Let literalExpression be (expressionNonBrace as literalExpression))

  2. Return (literalExpression as expression)

3. (Let expressionNonBrace be expressionNonBrace'')

4. If ((expressionNonBrace has type referenceExpression)), then

  1. (Let referenceExpression be (expressionNonBrace as referenceExpression))

  2. Return (referenceExpression as expression)

5. (Let expressionNonBrace be expressionNonBrace'')

6. If ((expressionNonBrace has type unaryExpression)), then

  1. (Let unaryExpression be (expressionNonBrace as unaryExpression))

  2. Return (unaryExpression as expression)

7. (Let expressionNonBrace be expressionNonBrace'')

8. If ((expressionNonBrace has type binaryExpressionNonBrace)), then

  1. (Let (expressionNonBrace_l binop expression_r) be (expressionNonBrace as binaryExpressionNonBrace))

  2. (Let expression_l be $expressionNonBrace(expressionNonBrace_l))

  3. Return ((expression_l binop expression_r) as expression)

9. (Let expressionNonBrace be expressionNonBrace'')

10. If ((expressionNonBrace has type ternaryExpressionNonBrace)), then

  1. (Let (expressionNonBrace_cond ? expression_true : expression_false) be (expressionNonBrace as ternaryExpressionNonBrace))

  2. (Let expression_cond be $expressionNonBrace(expressionNonBrace_cond))

  3. Return ((expression_cond ? expression_true : expression_false) as expression)

11. (Let expressionNonBrace be expressionNonBrace'')

12. If ((expressionNonBrace has type castExpression)), then

  1. (Let castExpression be (expressionNonBrace as castExpression))

  2. Return (castExpression as expression)

13. (Let expressionNonBrace be expressionNonBrace'')

14. If ((expressionNonBrace has type errorAccessExpression)), then

  1. (Let errorAccessExpression be (expressionNonBrace as errorAccessExpression))

  2. Return (errorAccessExpression as expression)

15. (Let expressionNonBrace be expressionNonBrace'')

16. If ((expressionNonBrace has type memberAccessExpressionNonBrace)), then

  1. (Let (memberAccessBaseNonBrace . member) be (expressionNonBrace as memberAccessExpressionNonBrace))

  2. If ((memberAccessBaseNonBrace has type prefixedTypeName)), then

    1. (Let prefixedTypeName be (memberAccessBaseNonBrace as prefixedTypeName))

    2. Return (((prefixedTypeName as memberAccessBase) . member) as expression)

17. (Let expressionNonBrace be expressionNonBrace'')

18. If ((expressionNonBrace has type memberAccessExpressionNonBrace)), then

  1. (Let (memberAccessBaseNonBrace . member) be (expressionNonBrace as memberAccessExpressionNonBrace))

  2. If ((memberAccessBaseNonBrace has type expressionNonBrace)), then

    1. (Let expressionNonBrace_base be (memberAccessBaseNonBrace as expressionNonBrace))

    2. (Let expression_base be $expressionNonBrace(expressionNonBrace_base))

    3. Return (((expression_base as memberAccessBase) . member) as expression)

19. (Let expressionNonBrace be expressionNonBrace'')

20. If ((expressionNonBrace has type indexAccessExpressionNonBrace)), then

  1. (Let indexAccessExpressionNonBrace be (expressionNonBrace as indexAccessExpressionNonBrace))

  2. If ((indexAccessExpressionNonBrace matches pattern `%[%]`)), then

    1. (Let (expressionNonBrace_base [ expression_index ]) be indexAccessExpressionNonBrace)

    2. (Let expression_base be $expressionNonBrace(expressionNonBrace_base))

    3. Return ((expression_base [ expression_index ]) as expression)

21. (Let expressionNonBrace be expressionNonBrace'')

22. If ((expressionNonBrace has type indexAccessExpressionNonBrace)), then

  1. (Let indexAccessExpressionNonBrace be (expressionNonBrace as indexAccessExpressionNonBrace))

  2. If ((indexAccessExpressionNonBrace matches pattern `%[%:%]`)), then

    1. (Let (expressionNonBrace_base [ expression_hi : expression_lo ]) be indexAccessExpressionNonBrace)

    2. (Let expression_base be $expressionNonBrace(expressionNonBrace_base))

    3. Return ((expression_base [ expression_hi : expression_lo ]) as expression)

23. (Let expressionNonBrace' be expressionNonBrace'')

24. If ((expressionNonBrace' has type callExpressionNonBrace)), then

  1. (Let callExpressionNonBrace be (expressionNonBrace' as callExpressionNonBrace))

  2. If ((callExpressionNonBrace matches pattern `%(%)`)), then

    1. (Let (callTargetNonBrace ( argumentList )) be callExpressionNonBrace)

    2. If ((callTargetNonBrace has type expressionNonBrace)), then

      1. (Let expressionNonBrace be (callTargetNonBrace as expressionNonBrace))

      2. (Let expression be $expressionNonBrace(expressionNonBrace))

      3. Return (((expression as callTarget) ( argumentList )) as expression)

25. (Let expressionNonBrace be expressionNonBrace'')

26. If ((expressionNonBrace has type callExpressionNonBrace)), then

  1. (Let callExpressionNonBrace be (expressionNonBrace as callExpressionNonBrace))

  2. If ((callExpressionNonBrace matches pattern `%(%)`)), then

    1. (Let (callTargetNonBrace ( argumentList )) be callExpressionNonBrace)

    2. If ((callTargetNonBrace has type constructorTarget)), then

      1. (Let constructorTarget be (callTargetNonBrace as constructorTarget))

      2. Return (((constructorTarget as callTarget) ( argumentList )) as expression)

27. (Let expressionNonBrace' be expressionNonBrace'')

28. If ((expressionNonBrace' has type callExpressionNonBrace)), then

  1. (Let callExpressionNonBrace be (expressionNonBrace' as callExpressionNonBrace))

  2. If ((callExpressionNonBrace matches pattern `%<%>(%)`)), then

    1. (Let (expressionNonBrace < realTypeArgumentList >( argumentList )) be callExpressionNonBrace)

    2. (Let expression be $expressionNonBrace(expressionNonBrace))

    3. Return ((expression < realTypeArgumentList >( argumentList )) as expression)

29. (Let expressionNonBrace be expressionNonBrace'')

30. If ((expressionNonBrace has type parenthesizedExpression)), then

  1. (Let parenthesizedExpression be (expressionNonBrace as parenthesizedExpression))

  2. Return (parenthesizedExpression as expression)

;; ../../../../spec-concrete/1-syntax.watsup:513.1-517.7
syntax simpleKeysetExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _

;; ../../../../spec-concrete/1-syntax.watsup:520.1-521.57
syntax simpleKeysetExpressionList = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _
   | simpleKeysetExpressionList , simpleKeysetExpression

;; ../../../../spec-concrete/1-syntax.watsup:523.1-524.28
def $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList'')

1. (Let simpleKeysetExpressionList be simpleKeysetExpressionList'')

2. If ((simpleKeysetExpressionList has type simpleKeysetExpression)), then

  1. (Let simpleKeysetExpression be (simpleKeysetExpressionList as simpleKeysetExpression))

  2. Return [simpleKeysetExpression]

3. (Let simpleKeysetExpressionList' be simpleKeysetExpressionList'')

4. If ((simpleKeysetExpressionList' matches pattern `%,%`)), then

  1. (Let (simpleKeysetExpressionList , simpleKeysetExpression) be simpleKeysetExpressionList')

  2. Return $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList) ++ [simpleKeysetExpression]

;; ../../../../spec-concrete/1-syntax.watsup:534.1-538.62
syntax tupleKeysetExpression = 
   | ( expression &&& expression )
   | ( expression .. expression )
   | (default)
   | (_)
   | ( simpleKeysetExpression , simpleKeysetExpressionList )

;; ../../../../spec-concrete/1-syntax.watsup:541.1-542.26
syntax keysetExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression &&& expression
   | expression .. expression
   | default
   | _
   | ( expression &&& expression )
   | ( expression .. expression )
   | (default)
   | (_)
   | ( simpleKeysetExpression , simpleKeysetExpressionList )

;; ../../../../spec-concrete/1-syntax.watsup:549.1-551.7
syntax realTypeArgument = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _

;; ../../../../spec-concrete/1-syntax.watsup:554.1-555.45
syntax realTypeArgumentList = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | realTypeArgumentList , realTypeArgument

;; ../../../../spec-concrete/1-syntax.watsup:557.1-557.76
def $flatten_realTypeArgumentList(realTypeArgumentList'')

1. (Let realTypeArgumentList be realTypeArgumentList'')

2. If ((realTypeArgumentList has type realTypeArgument)), then

  1. (Let realTypeArgument be (realTypeArgumentList as realTypeArgument))

  2. Return [realTypeArgument]

3. (Let realTypeArgumentList' be realTypeArgumentList'')

4. If ((realTypeArgumentList' matches pattern `%,%`)), then

  1. (Let (realTypeArgumentList , realTypeArgument) be realTypeArgumentList')

  2. Return $flatten_realTypeArgumentList(realTypeArgumentList) ++ [realTypeArgument]

;; ../../../../spec-concrete/1-syntax.watsup:563.1-564.16
syntax typeArgument = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority

;; ../../../../spec-concrete/1-syntax.watsup:568.1-570.37
syntax typeArgumentList = 
   | 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | void
   | _
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | typeArgumentList , typeArgument

;; ../../../../spec-concrete/1-syntax.watsup:572.1-572.64
def $flatten_typeArgumentList(typeArgumentList'')

1. (Let typeArgumentList be typeArgumentList'')

2. If ((typeArgumentList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let typeArgumentList be typeArgumentList'')

4. If ((typeArgumentList has type typeArgument)), then

  1. (Let typeArgument be (typeArgumentList as typeArgument))

  2. Return [typeArgument]

5. (Let typeArgumentList' be typeArgumentList'')

6. If ((typeArgumentList' matches pattern `%,%`)), then

  1. (Let (typeArgumentList , typeArgument) be typeArgumentList')

  2. Return $flatten_typeArgumentList(typeArgumentList) ++ [typeArgument]

;; ../../../../spec-concrete/1-syntax.watsup:583.1-586.7
syntax argument = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _

;; ../../../../spec-concrete/1-syntax.watsup:589.1-590.37
syntax argumentListNonEmpty = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _
   | argumentListNonEmpty , argument

;; ../../../../spec-concrete/1-syntax.watsup:593.1-594.25
syntax argumentList = 
   | 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | name = expression
   | name =_
   | _
   | argumentListNonEmpty , argument

;; ../../../../spec-concrete/1-syntax.watsup:596.1-596.52
def $flatten_argumentList(argumentList)

1. If ((argumentList matches pattern ``EMPTY`)), then

  1. Return []

2. If ((argumentList has type argument)), then

  1. (Let argument be (argumentList as argument))

  2. Return [argument]

3. If ((argumentList has type argumentListNonEmpty)), then

  1. (Let argumentListNonEmpty' be (argumentList as argumentListNonEmpty))

  2. If ((argumentListNonEmpty' matches pattern `%,%`)), then

    1. (Let (argumentListNonEmpty , argument) be argumentListNonEmpty')

    2. Return $flatten_argumentList((argumentListNonEmpty as argumentList)) ++ [argument]

;; ../../../../spec-concrete/1-syntax.watsup:607.1-611.16
syntax lvalue = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | lvalue . member
   | lvalue [ expression ]
   | lvalue [ expression : expression ]
   | ( lvalue )

;; ../../../../spec-concrete/1-syntax.watsup:621.25-621.27
syntax emptyStatement = 
   | ;

;; ../../../../spec-concrete/1-syntax.watsup:628.1-630.34
syntax assignop = 
   | =
   | +=
   | -=
   | |+|=
   | |-|=
   | *=
   | /=
   | %=
   | <<=
   | >>=
   | &=
   | ^=
   | |=

;; ../../../../spec-concrete/1-syntax.watsup:632.30-632.59
syntax assignmentStatement = 
   | lvalue assignop expression ;

;; ../../../../spec-concrete/1-syntax.watsup:639.1-640.54
syntax callStatement = 
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );

;; ../../../../spec-concrete/1-syntax.watsup:646.37-646.76
syntax directApplicationStatement = 
   | namedType .apply( argumentList );

;; ../../../../spec-concrete/1-syntax.watsup:653.1-654.25
syntax returnStatement = 
   | return;
   | return expression ;

;; ../../../../spec-concrete/1-syntax.watsup:660.24-660.31
syntax exitStatement = 
   | exit;

;; ../../../../spec-concrete/1-syntax.watsup:668.25-668.70
syntax blockStatement = 
   | annotationList { blockElementStatementList }

;; ../../../../spec-concrete/1-syntax.watsup:677.1-678.48
syntax conditionalStatement = 
   | if( expression ) statement
   | if( expression ) statement else statement

;; ../../../../spec-concrete/1-syntax.watsup:687.1-690.31
syntax forInitStatement = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression

;; ../../../../spec-concrete/1-syntax.watsup:693.1-694.53
syntax forInitStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forInitStatementListNonEmpty , forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:697.1-698.33
syntax forInitStatementList = 
   | 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forInitStatementListNonEmpty , forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:700.29-700.45
syntax forUpdateStatement = forInitStatement

;; ../../../../spec-concrete/1-syntax.watsup:703.1-704.57
syntax forUpdateStatementListNonEmpty = 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty , forUpdateStatement

;; ../../../../spec-concrete/1-syntax.watsup:707.1-708.35
syntax forUpdateStatementList = 
   | 
   | annotationList type name initializerOpt
   | lvalue ( argumentList )
   | lvalue < typeArgumentList >( argumentList )
   | lvalue assignop expression
   | forUpdateStatementListNonEmpty , forUpdateStatement

;; ../../../../spec-concrete/1-syntax.watsup:711.1-712.30
syntax forCollectionExpression = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | ...
   | unop expression
   | expression binop expression
   | expression ? expression : expression
   | ( type ) expression
   | {#}
   | { dataElementExpression trailingCommaOpt }
   | error. member
   | memberAccessBase . member
   | expression [ expression ]
   | expression [ expression : expression ]
   | callTarget ( argumentList )
   | routineTarget < realTypeArgumentList >( argumentList )
   | ( expression )
   | expression .. expression

;; ../../../../spec-concrete/1-syntax.watsup:715.1-720.81
syntax forStatement = 
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement

;; ../../../../spec-concrete/1-syntax.watsup:727.1-728.23
syntax switchLabel = 
   | default
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | this
   | unop expression
   | expressionNonBrace binop expression
   | expressionNonBrace ? expression : expression
   | ( type ) expression
   | error. member
   | memberAccessBaseNonBrace . member
   | expressionNonBrace [ expression ]
   | expressionNonBrace [ expression : expression ]
   | callTargetNonBrace ( argumentList )
   | routineTargetNonBrace < realTypeArgumentList >( argumentList )
   | ( expression )

;; ../../../../spec-concrete/1-syntax.watsup:731.1-732.19
syntax switchCase = 
   | switchLabel : blockStatement
   | switchLabel :

;; ../../../../spec-concrete/1-syntax.watsup:735.1-736.30
syntax switchCaseList = 
   | 
   | switchCaseList switchCase

;; ../../../../spec-concrete/1-syntax.watsup:738.1-738.58
def $flatten_switchCaseList(switchCaseList'')

1. (Let switchCaseList be switchCaseList'')

2. If ((switchCaseList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let switchCaseList' be switchCaseList'')

4. If ((switchCaseList' matches pattern `%%`)), then

  1. (Let (switchCaseList switchCase) be switchCaseList')

  2. Return $flatten_switchCaseList(switchCaseList) ++ [switchCase]

;; ../../../../spec-concrete/1-syntax.watsup:743.26-743.68
syntax switchStatement = 
   | switch( expression ){ switchCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:749.25-749.33
syntax breakStatement = 
   | break;

;; ../../../../spec-concrete/1-syntax.watsup:751.28-751.39
syntax continueStatement = 
   | continue;

;; ../../../../spec-concrete/1-syntax.watsup:758.1-769.20
syntax statement = 
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | return;
   | return expression ;
   | exit;
   | annotationList { blockElementStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement
   | break;
   | continue;
   | switch( expression ){ switchCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:779.22-779.35
syntax initializer = 
   | = expression

;; ../../../../spec-concrete/1-syntax.watsup:782.3-782.48
syntax constantDeclaration = 
   | annotationList const type name initializer ;

;; ../../../../spec-concrete/1-syntax.watsup:785.1-786.16
syntax initializerOpt = 
   | 
   | = expression

;; ../../../../spec-concrete/1-syntax.watsup:789.3-789.45
syntax variableDeclaration = 
   | annotationList type name initializerOpt ;

;; ../../../../spec-concrete/1-syntax.watsup:792.1-794.14
syntax blockElementStatement = 
   | annotationList const type name initializer ;
   | annotationList type name initializerOpt ;
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | return;
   | return expression ;
   | exit;
   | annotationList { blockElementStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement
   | annotationList for( forInitStatementList ; expression ; forUpdateStatementList ) statement
   | annotationList for( type name in forCollectionExpression ) statement
   | annotationList for( annotationListNonEmpty type name in forCollectionExpression ) statement
   | break;
   | continue;
   | switch( expression ){ switchCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:797.1-798.52
syntax blockElementStatementList = 
   | 
   | blockElementStatementList blockElementStatement

;; ../../../../spec-concrete/1-syntax.watsup:800.1-801.27
def $flatten_blockElementStatementList(blockElementStatementList'')

1. (Let blockElementStatementList be blockElementStatementList'')

2. If ((blockElementStatementList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let blockElementStatementList' be blockElementStatementList'')

4. If ((blockElementStatementList' matches pattern `%%`)), then

  1. (Let (blockElementStatementList blockElementStatement) be blockElementStatementList')

  2. Return $flatten_blockElementStatementList(blockElementStatementList) ++ [blockElementStatement]

;; ../../../../spec-concrete/1-syntax.watsup:814.3-814.58
syntax functionPrototype = 
   | typeOrVoid name typeParameterListOpt ( parameterList )

;; ../../../../spec-concrete/1-syntax.watsup:817.3-817.50
syntax functionDeclaration = 
   | annotationList functionPrototype blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:824.3-824.63
syntax actionDeclaration = 
   | annotationList action name ( parameterList ) blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:832.28-832.57
syntax objectInitializer = 
   | ={ objectDeclarationList }

;; ../../../../spec-concrete/1-syntax.watsup:836.1-837.68
syntax instantiation = 
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;

;; ../../../../spec-concrete/1-syntax.watsup:840.1-841.18
syntax objectDeclaration = 
   | annotationList functionPrototype blockStatement
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;

;; ../../../../spec-concrete/1-syntax.watsup:844.1-845.44
syntax objectDeclarationList = 
   | 
   | objectDeclarationList objectDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:847.1-847.79
def $flatten_objectDeclarationList(objectDeclarationList'')

1. (Let objectDeclarationList be objectDeclarationList'')

2. If ((objectDeclarationList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let objectDeclarationList' be objectDeclarationList'')

4. If ((objectDeclarationList' matches pattern `%%`)), then

  1. (Let (objectDeclarationList objectDeclaration) be objectDeclarationList')

  2. Return $flatten_objectDeclarationList(objectDeclarationList) ++ [objectDeclaration]

;; ../../../../spec-concrete/1-syntax.watsup:859.27-859.46
syntax errorDeclaration = 
   | error{ nameList }

;; ../../../../spec-concrete/1-syntax.watsup:865.31-865.72
syntax matchKindDeclaration = 
   | match_kind{ nameList trailingCommaOpt }

;; ../../../../spec-concrete/1-syntax.watsup:876.1-877.76
syntax enumTypeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }

;; ../../../../spec-concrete/1-syntax.watsup:883.20-883.47
syntax typeField = 
   | annotationList type name ;

;; ../../../../spec-concrete/1-syntax.watsup:886.1-887.28
syntax typeFieldList = 
   | 
   | typeFieldList typeField

;; ../../../../spec-concrete/1-syntax.watsup:889.1-889.55
def $flatten_typeFieldList(typeFieldList'')

1. (Let typeFieldList be typeFieldList'')

2. If ((typeFieldList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let typeFieldList' be typeFieldList'')

4. If ((typeFieldList' matches pattern `%%`)), then

  1. (Let (typeFieldList typeField) be typeFieldList')

  2. Return $flatten_typeFieldList(typeFieldList) ++ [typeField]

;; ../../../../spec-concrete/1-syntax.watsup:895.3-895.69
syntax structTypeDeclaration = 
   | annotationList struct name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:898.3-898.69
syntax headerTypeDeclaration = 
   | annotationList header name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:901.3-901.75
syntax headerUnionTypeDeclaration = 
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:904.1-907.31
syntax derivedTypeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:914.1-915.27
syntax typedefType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | text
   | . typeName
   | prefixedTypeName < typeArgumentList >
   | namedType [ expression ]
   | list< typeArgument >
   | tuple< typeArgumentList >
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }

;; ../../../../spec-concrete/1-syntax.watsup:918.1-919.37
syntax typedefDeclaration = 
   | annotationList typedef typedefType name ;
   | annotationList type type name ;

;; ../../../../spec-concrete/1-syntax.watsup:926.3-926.45
syntax externFunctionDeclaration = 
   | annotationList extern functionPrototype ;

;; ../../../../spec-concrete/1-syntax.watsup:929.1-931.49
syntax methodPrototype = 
   | annotationList typeIdentifier ( parameterList );
   | annotationList functionPrototype ;
   | annotationList abstract functionPrototype ;

;; ../../../../spec-concrete/1-syntax.watsup:934.1-935.40
syntax methodPrototypeList = 
   | 
   | methodPrototypeList methodPrototype

;; ../../../../spec-concrete/1-syntax.watsup:937.1-937.73
def $flatten_methodPrototypeList(methodPrototypeList'')

1. (Let methodPrototypeList be methodPrototypeList'')

2. If ((methodPrototypeList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let methodPrototypeList' be methodPrototypeList'')

4. If ((methodPrototypeList' matches pattern `%%`)), then

  1. (Let (methodPrototypeList methodPrototype) be methodPrototypeList')

  2. Return $flatten_methodPrototypeList(methodPrototypeList) ++ [methodPrototype]

;; ../../../../spec-concrete/1-syntax.watsup:945.3-945.82
syntax externObjectDeclaration = 
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }

;; ../../../../spec-concrete/1-syntax.watsup:948.1-949.28
syntax externDeclaration = 
   | annotationList extern functionPrototype ;
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }

;; ../../../../spec-concrete/1-syntax.watsup:959.21-959.48
syntax selectCase = 
   | keysetExpression : name ;

;; ../../../../spec-concrete/1-syntax.watsup:962.1-963.30
syntax selectCaseList = 
   | 
   | selectCaseList selectCase

;; ../../../../spec-concrete/1-syntax.watsup:965.1-965.58
def $flatten_selectCaseList(selectCaseList'')

1. (Let selectCaseList be selectCaseList'')

2. If ((selectCaseList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let selectCaseList' be selectCaseList'')

4. If ((selectCaseList' matches pattern `%%`)), then

  1. (Let (selectCaseList selectCase) be selectCaseList')

  2. Return $flatten_selectCaseList(selectCaseList) ++ [selectCase]

;; ../../../../spec-concrete/1-syntax.watsup:970.27-970.73
syntax selectExpression = 
   | select( expressionList ){ selectCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:977.1-978.21
syntax stateExpression = 
   | name ;
   | select( expressionList ){ selectCaseList }

;; ../../../../spec-concrete/1-syntax.watsup:981.1-982.31
syntax transitionStatement = 
   | 
   | transition stateExpression

;; ../../../../spec-concrete/1-syntax.watsup:989.1-991.21
syntax valueSetType = 
   | bool
   | error
   | match_kind
   | string
   | int
   | int< int >
   | int<( expression )>
   | bit
   | bit< int >
   | bit<( expression )>
   | varbit< int >
   | varbit<( expression )>
   | tuple< typeArgumentList >
   | text
   | . typeName

;; ../../../../spec-concrete/1-syntax.watsup:994.3-994.69
syntax valueSetDeclaration = 
   | annotationList value_set< valueSetType >( expression ) name ;

;; ../../../../spec-concrete/1-syntax.watsup:1001.3-1001.72
syntax parserTypeDeclaration = 
   | annotationList parser name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1009.31-1009.70
syntax parserBlockStatement = 
   | annotationList { parserStatementList }

;; ../../../../spec-concrete/1-syntax.watsup:1012.1-1019.25
syntax parserStatement = 
   | annotationList const type name initializer ;
   | annotationList type name initializerOpt ;
   | ;
   | lvalue assignop expression ;
   | lvalue ( argumentList );
   | lvalue < typeArgumentList >( argumentList );
   | namedType .apply( argumentList );
   | annotationList { parserStatementList }
   | if( expression ) statement
   | if( expression ) statement else statement

;; ../../../../spec-concrete/1-syntax.watsup:1022.1-1023.40
syntax parserStatementList = 
   | 
   | parserStatementList parserStatement

;; ../../../../spec-concrete/1-syntax.watsup:1025.1-1025.73
def $flatten_parserStatementList(parserStatementList'')

1. (Let parserStatementList be parserStatementList'')

2. If ((parserStatementList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let parserStatementList' be parserStatementList'')

4. If ((parserStatementList' matches pattern `%%`)), then

  1. (Let (parserStatementList parserStatement) be parserStatementList')

  2. Return $flatten_parserStatementList(parserStatementList) ++ [parserStatement]

;; ../../../../spec-concrete/1-syntax.watsup:1031.3-1031.73
syntax parserState = 
   | annotationList state name { parserStatementList transitionStatement }

;; ../../../../spec-concrete/1-syntax.watsup:1034.1-1035.32
syntax parserStateList = 
   | annotationList state name { parserStatementList transitionStatement }
   | parserStateList parserState

;; ../../../../spec-concrete/1-syntax.watsup:1037.1-1037.61
def $flatten_parserStateList(parserStateList'')

1. (Let parserStateList be parserStateList'')

2. If ((parserStateList has type parserState)), then

  1. (Let parserState be (parserStateList as parserState))

  2. Return [parserState]

3. (Let parserStateList' be parserStateList'')

4. If ((parserStateList' matches pattern `%%`)), then

  1. (Let (parserStateList parserState) be parserStateList')

  2. Return $flatten_parserStateList(parserStateList) ++ [parserState]

;; ../../../../spec-concrete/1-syntax.watsup:1043.1-1046.24
syntax parserLocalDeclaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList type name initializerOpt ;
   | annotationList value_set< valueSetType >( expression ) name ;

;; ../../../../spec-concrete/1-syntax.watsup:1049.1-1050.54
syntax parserLocalDeclarationList = 
   | 
   | parserLocalDeclarationList parserLocalDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:1052.1-1053.28
def $flatten_parserLocalDeclarationList(parserLocalDeclarationList'')

1. (Let parserLocalDeclarationList be parserLocalDeclarationList'')

2. If ((parserLocalDeclarationList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let parserLocalDeclarationList' be parserLocalDeclarationList'')

4. If ((parserLocalDeclarationList' matches pattern `%%`)), then

  1. (Let (parserLocalDeclarationList parserLocalDeclaration) be parserLocalDeclarationList')

  2. Return $flatten_parserLocalDeclarationList(parserLocalDeclarationList) ++ [parserLocalDeclaration]

;; ../../../../spec-concrete/1-syntax.watsup:1062.3-1064.52
syntax parserDeclaration = 
   | annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }

;; ../../../../spec-concrete/1-syntax.watsup:1074.16-1074.21
syntax const = 
   | const

;; ../../../../spec-concrete/1-syntax.watsup:1077.1-1078.10
syntax constOpt = 
   | 
   | const

;; ../../../../spec-concrete/1-syntax.watsup:1080.1-1080.41
def $flatten_constOpt(constOpt)

1. If ((constOpt matches pattern ``EMPTY`)), then

  1. Return ?()

2. If ((constOpt has type const)), then

  1. (Let const be (constOpt as const))

  2. Return ?(const)

;; ../../../../spec-concrete/1-syntax.watsup:1088.19-1088.55
syntax tableKey = 
   | expression : name annotationList ;

;; ../../../../spec-concrete/1-syntax.watsup:1091.1-1092.26
syntax tableKeyList = 
   | 
   | tableKeyList tableKey

;; ../../../../spec-concrete/1-syntax.watsup:1094.1-1094.52
def $flatten_tableKeyList(tableKeyList'')

1. (Let tableKeyList be tableKeyList'')

2. If ((tableKeyList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let tableKeyList' be tableKeyList'')

4. If ((tableKeyList' matches pattern `%%`)), then

  1. (Let (tableKeyList tableKey) be tableKeyList')

  2. Return $flatten_tableKeyList(tableKeyList) ++ [tableKey]

;; ../../../../spec-concrete/1-syntax.watsup:1104.1-1105.42
syntax tableActionReference = 
   | text
   | apply
   | key
   | actions
   | state
   | entries
   | type
   | priority
   | . nonTypeName
   | prefixedNonTypeName ( argumentList )

;; ../../../../spec-concrete/1-syntax.watsup:1107.22-1107.60
syntax tableAction = 
   | annotationList tableActionReference ;

;; ../../../../spec-concrete/1-syntax.watsup:1110.1-1111.32
syntax tableActionList = 
   | 
   | tableActionList tableAction

;; ../../../../spec-concrete/1-syntax.watsup:1113.1-1113.61
def $flatten_tableActionList(tableActionList'')

1. (Let tableActionList be tableActionList'')

2. If ((tableActionList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let tableActionList' be tableActionList'')

4. If ((tableActionList' matches pattern `%%`)), then

  1. (Let (tableActionList tableAction) be tableActionList')

  2. Return $flatten_tableActionList(tableActionList) ++ [tableAction]

;; ../../../../spec-concrete/1-syntax.watsup:1123.1-1124.35
syntax tableEntryPriority = 
   | priority= numberLiteral :
   | priority=( expression ):

;; ../../../../spec-concrete/1-syntax.watsup:1127.1-1128.72
syntax tableEntry = 
   | constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ;
   | constOpt keysetExpression : tableActionReference annotationList ;

;; ../../../../spec-concrete/1-syntax.watsup:1131.1-1132.30
syntax tableEntryList = 
   | 
   | tableEntryList tableEntry

;; ../../../../spec-concrete/1-syntax.watsup:1134.1-1134.58
def $flatten_tableEntryList(tableEntryList'')

1. (Let tableEntryList be tableEntryList'')

2. If ((tableEntryList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let tableEntryList' be tableEntryList'')

4. If ((tableEntryList' matches pattern `%%`)), then

  1. (Let (tableEntryList tableEntry) be tableEntryList')

  2. Return $flatten_tableEntryList(tableEntryList) ++ [tableEntry]

;; ../../../../spec-concrete/1-syntax.watsup:1144.1-1147.59
syntax tableProperty = 
   | key={ tableKeyList }
   | actions={ tableActionList }
   | annotationList constOpt entries={ tableEntryList }
   | annotationList constOpt tableCustomName initializer ;

;; ../../../../spec-concrete/1-syntax.watsup:1150.1-1151.36
syntax tablePropertyList = 
   | 
   | tablePropertyList tableProperty

;; ../../../../spec-concrete/1-syntax.watsup:1153.1-1153.67
def $flatten_tablePropertyList(tablePropertyList'')

1. (Let tablePropertyList be tablePropertyList'')

2. If ((tablePropertyList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let tablePropertyList' be tablePropertyList'')

4. If ((tablePropertyList' matches pattern `%%`)), then

  1. (Let (tablePropertyList tableProperty) be tablePropertyList')

  2. Return $flatten_tablePropertyList(tablePropertyList) ++ [tableProperty]

;; ../../../../spec-concrete/1-syntax.watsup:1159.3-1159.51
syntax tableDeclaration = 
   | annotationList table name { tablePropertyList }

;; ../../../../spec-concrete/1-syntax.watsup:1166.3-1166.73
syntax controlTypeDeclaration = 
   | annotationList control name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1172.22-1172.36
syntax controlBody = blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:1175.1-1179.21
syntax controlLocalDeclaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList type name initializerOpt ;
   | annotationList action name ( parameterList ) blockStatement
   | annotationList table name { tablePropertyList }

;; ../../../../spec-concrete/1-syntax.watsup:1182.1-1183.56
syntax controlLocalDeclarationList = 
   | 
   | controlLocalDeclarationList controlLocalDeclaration

;; ../../../../spec-concrete/1-syntax.watsup:1185.1-1186.29
def $flatten_controlLocalDeclarationList(controlLocalDeclarationList'')

1. (Let controlLocalDeclarationList be controlLocalDeclarationList'')

2. If ((controlLocalDeclarationList matches pattern ``EMPTY`)), then

  1. Return []

3. (Let controlLocalDeclarationList' be controlLocalDeclarationList'')

4. If ((controlLocalDeclarationList' matches pattern `%%`)), then

  1. (Let (controlLocalDeclarationList controlLocalDeclaration) be controlLocalDeclarationList')

  2. Return $flatten_controlLocalDeclarationList(controlLocalDeclarationList) ++ [controlLocalDeclaration]

;; ../../../../spec-concrete/1-syntax.watsup:1196.3-1198.55
syntax controlDeclaration = 
   | annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }

;; ../../../../spec-concrete/1-syntax.watsup:1205.3-1205.73
syntax packageTypeDeclaration = 
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1212.1-1216.27
syntax typeDeclaration = 
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }
   | annotationList typedef typedefType name ;
   | annotationList type type name ;
   | annotationList parser name typeParameterListOpt ( parameterList );
   | annotationList control name typeParameterListOpt ( parameterList );
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1223.1-1232.20
syntax declaration = 
   | annotationList const type name initializer ;
   | annotationList type ( argumentList ) name ;
   | annotationList type ( argumentList ) name objectInitializer ;
   | annotationList functionPrototype blockStatement
   | annotationList action name ( parameterList ) blockStatement
   | error{ nameList }
   | match_kind{ nameList trailingCommaOpt }
   | annotationList extern functionPrototype ;
   | annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }
   | annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }
   | annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }
   | annotationList enum name { nameList trailingCommaOpt }
   | annotationList enum type name { namedExpressionList trailingCommaOpt }
   | annotationList struct name typeParameterListOpt { typeFieldList }
   | annotationList header name typeParameterListOpt { typeFieldList }
   | annotationList header_union name typeParameterListOpt { typeFieldList }
   | annotationList typedef typedefType name ;
   | annotationList type type name ;
   | annotationList parser name typeParameterListOpt ( parameterList );
   | annotationList control name typeParameterListOpt ( parameterList );
   | annotationList package name typeParameterListOpt ( parameterList );

;; ../../../../spec-concrete/1-syntax.watsup:1239.1-1256.27
syntax annotationToken = 
   | unexpected_token
   | abstract
   | action
   | actions
   | apply
   | bool
   | bit
   | break
   | const
   | continue
   | control
   | default
   | else
   | entries
   | enum
   | error
   | exit
   | extern
   | false
   | for
   | header
   | header_union
   | if
   | in
   | inout
   | int
   | key
   | match_kind
   | type
   | out
   | parser
   | package
   | pragma
   | return
   | select
   | state
   | string
   | struct
   | switch
   | table
   | this
   | transition
   | true
   | tuple
   | typedef
   | varbit
   | value_set
   | list
   | void
   | _
   | text
   | text
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | &&&
   | ..
   | <<
   | &&
   | ||
   | ==
   | !=
   | >=
   | <=
   | ++
   | +
   | |+|
   | -
   | |-|
   | *
   | /
   | %
   | |
   | &
   | ^
   | ~
   | [
   | ]
   | {
   | }
   | <
   | >
   | !
   | :
   | ,
   | ?
   | .
   | =
   | ;
   | @

;; ../../../../spec-concrete/1-syntax.watsup:1259.1-1261.35
syntax annotationBody = 
   | 
   | annotationBody ( annotationBody )
   | annotationBody annotationToken

;; ../../../../spec-concrete/1-syntax.watsup:1264.3-1264.41
syntax structuredAnnotationBody = 
   | dataElementExpression trailingCommaOpt

;; ../../../../spec-concrete/1-syntax.watsup:1267.1-1269.42
syntax annotation = 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]

;; ../../../../spec-concrete/1-syntax.watsup:1272.1-1273.38
syntax annotationListNonEmpty = 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]
   | annotationListNonEmpty annotation

;; ../../../../spec-concrete/1-syntax.watsup:1276.1-1277.27
syntax annotationList = 
   | 
   | @ name
   | @ name ( annotationBody )
   | @ name [ structuredAnnotationBody ]
   | annotationListNonEmpty annotation

;; ../../../../spec-concrete/1-syntax.watsup:1284.1-1286.17
syntax p4program = 
   | 
   | p4program declaration
   | p4program ;

;; ../../../../spec-concrete/1-syntax.watsup:1288.1-1288.49
def $flatten_p4program(p4program'')

1. (Let p4program be p4program'')

2. If ((p4program matches pattern ``EMPTY`)), then

  1. Return []

3. (Let p4program' be p4program'')

4. If ((p4program' matches pattern `%%`)), then

  1. (Let (p4program declaration) be p4program')

  2. Return $flatten_p4program(p4program) ++ [declaration]

5. (Let p4program' be p4program'')

6. If ((p4program' matches pattern `%;`)), then

  1. (Let (p4program ;) be p4program')

  2. Return $flatten_p4program(p4program)

;; ../../../../spec-concrete/2.0-domain.watsup:5.17-5.21
syntax nameIR = text

;; ../../../../spec-concrete/2.0-domain.watsup:7.1-7.25
def $name(name)

1. Case analysis on name

  1. Case (% has type identifier)

    1. (Let (t) be (name as identifier))

    2. Return t

  2. Case (% has type typeIdentifier)

    1. (Let (t) be (name as typeIdentifier))

    2. Return t

2. If ((name = ((apply) as name))), then

  1. Return "apply"

3. If ((name = ((key) as name))), then

  1. Return "key"

4. If ((name = ((actions) as name))), then

  1. Return "actions"

5. If ((name = ((state) as name))), then

  1. Return "state"

6. If ((name = ((entries) as name))), then

  1. Return "entries"

7. If ((name = ((type) as name))), then

  1. Return "type"

8. If ((name = ((priority) as name))), then

  1. Return "priority"

9. If ((name matches pattern `LIST`)), then

  1. Return "list"

;; ../../../../spec-concrete/2.0-domain.watsup:20.1-20.47
def $tableCustomName(tableCustomName)

1. Case analysis on tableCustomName

  1. Case (% has type identifier)

    1. (Let (t) be (tableCustomName as identifier))

    2. Return t

  2. Case (% has type typeIdentifier)

    1. (Let (t) be (tableCustomName as typeIdentifier))

    2. Return t

2. Case analysis on tableCustomName

  1. Case (% matches pattern `APPLY`)

    1. Return "apply"

  2. Case (% matches pattern `STATE`)

    1. Return "state"

  3. Case (% matches pattern `TYPE`)

    1. Return "type"

  4. Case (% matches pattern `PRIORITY`)

    1. Return "priority"

;; ../../../../spec-concrete/2.0-domain.watsup:33.13-33.17
syntax id = text

;; ../../../../spec-concrete/2.0-domain.watsup:39.14-39.16
syntax tid = id

;; ../../../../spec-concrete/2.0-domain.watsup:41.1-41.23
def $fresh_tid



;; ../../../../spec-concrete/2.0-domain.watsup:42.1-42.28
def $fresh_tids(nat')

1. (Let nat be nat')

2. If ((nat = 0)), then

  1. Return []

3. (Let n be nat')

4. Otherwise

  1. Return $fresh_tid :: $fresh_tids((n - 1))

;; ../../../../spec-concrete/2.0-domain.watsup:56.14-56.24
syntax pid = 
   | id # bool

;; ../../../../spec-concrete/2.0-domain.watsup:57.14-57.26
syntax rid = 
   | id ( pid* )

;; ../../../../spec-concrete/2.0-domain.watsup:59.1-59.36
def $rid(name, parameterList)

1. Return ($name(name) ( $pids(parameterList) ))

;; ../../../../spec-concrete/2.0-domain.watsup:60.1-60.32
def $pids(parameterList)

1. If ((parameterList matches pattern ``EMPTY`)), then

  1. Return []

2. If ((parameterList has type parameter)), then

  1. (Let parameter be (parameterList as parameter))

  2. Return [$pid(parameter)]

3. If ((parameterList has type nonEmptyParameterList)), then

  1. (Let nonEmptyParameterList' be (parameterList as nonEmptyParameterList))

  2. If ((nonEmptyParameterList' matches pattern `%,%`)), then

    1. (Let (nonEmptyParameterList , parameter) be nonEmptyParameterList')

    2. Return $pids((nonEmptyParameterList as parameterList)) ++ [$pid(parameter)]

;; ../../../../spec-concrete/2.0-domain.watsup:61.1-61.26
def $pid((_annotationList _direction _type name initializerOpt))

1. If ((initializerOpt matches pattern ``EMPTY`)), then

  1. Return ($name(name) # false)

2. If ((initializerOpt has type initializer)), then

  1. (Let initializer be (initializerOpt as initializer))

  2. Return ($name(name) # true)

;; ../../../../spec-concrete/2.0-domain.watsup:78.14-78.17
syntax cid = rid

;; ../../../../spec-concrete/2.0-domain.watsup:80.1-80.50
def $cid(name, constructorParameterListOpt)

1. Case analysis on constructorParameterListOpt

  1. Case (% matches pattern ``EMPTY`)

    1. Return ($name(name) ( [] ))

  2. Case (% matches pattern `(%)`)

    1. (Let (( parameterList )) be constructorParameterListOpt)

    2. Return ($name(name) ( $pids(parameterList) ))

;; ../../../../spec-concrete/2.0-domain.watsup:88.1-88.48
def $expression_as_lvalue(expression'')

1. (Let expression be expression'')

2. If ((expression has type referenceExpression)), then

  1. (Let referenceExpression be (expression as referenceExpression))

  2. Return ?((referenceExpression as lvalue))

3. (Let expression' be expression'')

4. If ((expression' has type memberAccessExpression)), then

  1. (Let (memberAccessBase . member) be (expression' as memberAccessExpression))

  2. If ((memberAccessBase has type expression)), then

    1. (Let expression be (memberAccessBase as expression))

    2. (Let lvalue'? be $expression_as_lvalue(expression))

    3. If ((lvalue'? matches pattern (_))), then

      1. (Let ?(lvalue) be lvalue'?)

      2. Return ?((lvalue . member))

5. (Let expression' be expression'')

6. If ((expression' has type parenthesizedExpression)), then

  1. (Let (( expression )) be (expression' as parenthesizedExpression))

  2. (Let lvalue'? be $expression_as_lvalue(expression))

  3. If ((lvalue'? matches pattern (_))), then

    1. (Let ?(lvalue) be lvalue'?)

    2. Return ?((( lvalue )))

;; ../../../../spec-concrete/2.0-domain.watsup:99.14-99.17
syntax oid = id*

;; ../../../../spec-concrete/2.1.1-value.watsup:14.1-17.18
syntax primitiveValue = 
   | b bool
   | error. id
   | match_kind. id
   | " text " hint(print "#%#")

;; ../../../../spec-concrete/2.1.1-value.watsup:24.1-25.21
syntax numberValue = 
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat

;; ../../../../spec-concrete/2.1.1-value.watsup:27.20-27.50
syntax baseValue = 
   | b bool
   | error. id
   | match_kind. id
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat

;; ../../../../spec-concrete/2.1.1-value.watsup:35.20-35.31
syntax listValue = 
   | [ value* ]

;; ../../../../spec-concrete/2.1.1-value.watsup:36.21-36.32
syntax tupleValue = 
   | ( value* )

;; ../../../../spec-concrete/2.1.1-value.watsup:37.27-37.55
syntax headerStackValue = 
   | [ value* #( nat ; nat )]

;; ../../../../spec-concrete/2.1.1-value.watsup:39.21-39.32
syntax fieldValue = 
   | value id ;

;; ../../../../spec-concrete/2.1.1-value.watsup:41.22-41.49
syntax structValue = 
   | struct tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:42.22-42.49
syntax headerValue = 
   | header tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:43.27-43.60
syntax headerUnionValue = 
   | header_union tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:46.1-47.23
syntax enumValue = 
   | tid . id
   | tid . id # value

;; ../../../../spec-concrete/2.1.1-value.watsup:50.1-56.14
syntax dataValue = 
   | [ value* ]
   | ( value* )
   | [ value* #( nat ; nat )]
   | struct tid { fieldValue* }
   | header tid { fieldValue* }
   | header_union tid { fieldValue* }
   | tid . id
   | tid . id # value

;; ../../../../spec-concrete/2.1.1-value.watsup:62.23-62.30
syntax defaultValue = 
   | default

;; ../../../../spec-concrete/2.1.1-value.watsup:64.29-64.33
syntax invalidHeaderValue = 
   | {#}

;; ../../../../spec-concrete/2.1.1-value.watsup:67.1-68.28
syntax sequenceValue = 
   | seq( value* )
   | seq( value* ,...)

;; ../../../../spec-concrete/2.1.1-value.watsup:71.1-72.36
syntax recordValue = 
   | record{ fieldValue* }
   | record{ fieldValue* ,...}

;; ../../../../spec-concrete/2.1.1-value.watsup:75.1-77.29
syntax setValue = 
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }

;; ../../../../spec-concrete/2.1.1-value.watsup:80.1-81.38
syntax tableValue = 
   | table_enum tid . id
   | table_struct tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:84.1-89.15
syntax synthesizedValue = 
   | default
   | {#}
   | seq( value* )
   | seq( value* ,...)
   | record{ fieldValue* }
   | record{ fieldValue* ,...}
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }
   | table_enum tid . id
   | table_struct tid { fieldValue* }

;; ../../../../spec-concrete/2.1.1-value.watsup:95.31-95.37
syntax objectReferenceValue = 
   | ! oid

;; ../../../../spec-concrete/2.1.1-value.watsup:102.1-105.25
syntax value = 
   | b bool
   | error. id
   | match_kind. id
   | " text " hint(print "#%#")
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | nat v int # nat
   | [ value* ]
   | ( value* )
   | [ value* #( nat ; nat )]
   | struct tid { fieldValue* }
   | header tid { fieldValue* }
   | header_union tid { fieldValue* }
   | tid . id
   | tid . id # value
   | default
   | {#}
   | seq( value* )
   | seq( value* ,...)
   | record{ fieldValue* }
   | record{ fieldValue* ,...}
   | set{ value }
   | set{ value &&& value }
   | set{ value .. value }
   | table_enum tid . id
   | table_struct tid { fieldValue* }
   | ! oid

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:5.1-5.28
def $to_int



;; ../../../../spec-concrete/2.1.2-value-aux.watsup:12.1-12.31
def $to_bitstr



;; ../../../../spec-concrete/2.1.2-value-aux.watsup:18.1-18.28
def $to_number(value)

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i) be numberLiteral)

      2. Return i

    2. Case (% matches pattern `%S%`)

      1. (Let (w s i) be numberLiteral)

      2. Return $to_int((w as int), i)

    3. Case (% matches pattern `%W%`)

      1. (Let (w w i) be numberLiteral)

      2. Return i

2. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. If ((numberValue matches pattern `%V%#%`)), then

    1. (Let (w v i # _nat) be numberValue)

    2. Return i

;; ../../../../spec-concrete/2.2.1-type.watsup:14.1-18.11
syntax primitiveTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string

;; ../../../../spec-concrete/2.2.1-type.watsup:25.1-28.20
syntax numberTypeIR = 
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >

;; ../../../../spec-concrete/2.2.1-type.watsup:30.21-30.51
syntax baseTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >

;; ../../../../spec-concrete/2.2.1-type.watsup:40.1-41.31
syntax namedTypeIR = 
   | tid tid
   | polyTypeDefIR < typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:52.1-53.20
syntax aliasTypeIR = 
   | typedef tid typeIR
   | type tid typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:59.21-59.37
syntax listTypeIR = 
   | list< typeIR >

;; ../../../../spec-concrete/2.2.1-type.watsup:60.22-60.40
syntax tupleTypeIR = 
   | tuple< typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:61.28-61.43
syntax headerStackTypeIR = 
   | typeIR [ nat ]

;; ../../../../spec-concrete/2.2.1-type.watsup:63.22-63.34
syntax fieldTypeIR = 
   | typeIR id ;

;; ../../../../spec-concrete/2.2.1-type.watsup:65.23-65.51
syntax structTypeIR = 
   | struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:66.23-66.51
syntax headerTypeIR = 
   | header tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:67.28-67.62
syntax headerUnionTypeIR = 
   | header_union tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:69.23-69.37
syntax valueFieldIR = 
   | id = value ;

;; ../../../../spec-concrete/2.2.1-type.watsup:72.1-73.42
syntax enumTypeIR = 
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:76.1-82.15
syntax dataTypeIR = 
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:92.3-92.40
syntax externObjectTypeIR = 
   | extern tid map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/2.2.1-type.watsup:93.29-93.57
syntax parserObjectTypeIR = 
   | parser( parameterTypeIR* )

;; ../../../../spec-concrete/2.2.1-type.watsup:94.30-94.59
syntax controlObjectTypeIR = 
   | control( parameterTypeIR* )

;; ../../../../spec-concrete/2.2.1-type.watsup:95.30-95.50
syntax packageObjectTypeIR = 
   | package< typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:96.28-96.47
syntax tableObjectTypeIR = 
   | table tid # typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:99.1-103.22
syntax objectTypeIR = 
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:106.1-108.17
syntax definedTypeIR = 
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:114.24-114.31
syntax defaultTypeIR = 
   | default

;; ../../../../spec-concrete/2.2.1-type.watsup:116.30-116.44
syntax invalidHeaderTypeIR = 
   | header_invalid

;; ../../../../spec-concrete/2.2.1-type.watsup:119.1-120.29
syntax sequenceTypeIR = 
   | seq< typeIR* >
   | seq< typeIR* ,...>

;; ../../../../spec-concrete/2.2.1-type.watsup:123.1-124.37
syntax recordTypeIR = 
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}

;; ../../../../spec-concrete/2.2.1-type.watsup:126.20-126.36
syntax setTypeIR = 
   | set< typeIR* >

;; ../../../../spec-concrete/2.2.1-type.watsup:129.1-130.39
syntax tableTypeIR = 
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:133.1-138.16
syntax synthesizedTypeIR = 
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:145.1-148.22
syntax typeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }

;; ../../../../spec-concrete/2.2.1-type.watsup:154.24-154.30
syntax monoTypeDefIR = typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:156.24-156.48
syntax polyTypeDefIR = 
   | typeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:158.20-158.49
syntax typeDefIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }
   | typeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:164.26-164.52
syntax parameterTypeIR = 
   | direction typeIR id value?

;; ../../../../spec-concrete/2.2.1-type.watsup:171.1-174.33
syntax functionTypeIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )

;; ../../../../spec-concrete/2.2.1-type.watsup:177.1-182.27
syntax methodTypeIR = 
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:185.1-186.17
syntax routineTypeIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:192.31-192.44
syntax monoRoutineTypeDefIR = routineTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:194.31-194.62
syntax polyRoutineTypeDefIR = 
   | routineTypeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:197.1-198.25
syntax routineTypeDefIR = 
   | builtin_function( parameterTypeIR* )-> typeIR
   | function( parameterTypeIR* )-> typeIR
   | extern_function( parameterTypeIR* )-> typeIR
   | action( parameterTypeIR* )
   | builtin_method( parameterTypeIR* )-> typeIR
   | extern_method( parameterTypeIR* )-> typeIR
   | extern_methodabstract( parameterTypeIR* )-> typeIR
   | parser_apply( parameterTypeIR* )
   | control_apply( parameterTypeIR* )
   | table_apply-> typeIR
   | routineTypeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.1-type.watsup:204.37-204.52
syntax constructorParameterTypeIR = parameterTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:211.3-211.58
syntax constructorTypeIR = 
   | constructor( constructorParameterTypeIR* )-> typeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:217.31-217.66
syntax constructorTypeDefIR = 
   | constructorTypeIR < tid* , tid* >

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:9.1-9.34
def $is_baseTypeIR(typeIR)

1. If ((typeIR has type baseTypeIR)), then

  1. (Let baseTypeIR be (typeIR as baseTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:16.1-16.39
def $is_primitiveTypeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:21.1-21.35
def $is_void_typeIR(typeIR)

1. If ((typeIR = ((void) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:26.1-26.35
def $is_bool_typeIR(typeIR)

1. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:31.1-31.36
def $is_error_typeIR(typeIR)

1. If ((typeIR = ((error) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:36.1-36.40
def $is_matchkind_typeIR(typeIR)

1. If ((typeIR = ((match_kind) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:41.1-41.37
def $is_string_typeIR(typeIR)

1. If ((typeIR = ((string) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:48.1-48.36
def $is_numberTypeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:53.1-53.44
def $is_arbitrary_int_typeIR(typeIR)

1. If ((typeIR = ((int) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:58.1-58.40
def $is_fixed_int_typeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:63.1-63.40
def $is_fixed_bit_typeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:76.1-76.34
def $is_dataTypeIR(typeIR)

1. If ((typeIR has type dataTypeIR)), then

  1. (Let dataTypeIR be (typeIR as dataTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:81.1-81.41
def $is_headerStackTypeIR(typeIR)

1. If ((typeIR has type headerStackTypeIR)), then

  1. (Let headerStackTypeIR be (typeIR as headerStackTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:88.1-88.36
def $is_objectTypeIR(typeIR)

1. If ((typeIR has type objectTypeIR)), then

  1. (Let objectTypeIR be (typeIR as objectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:93.1-93.44
def $is_extern_object_typeIR(typeIR)

1. If ((typeIR has type externObjectTypeIR)), then

  1. (Let externObjectTypeIR be (typeIR as externObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:98.1-98.44
def $is_parser_object_typeIR(typeIR)

1. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let parserObjectTypeIR be (typeIR as parserObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:103.1-103.45
def $is_control_object_typeIR(typeIR)

1. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let controlObjectTypeIR be (typeIR as controlObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:108.1-108.45
def $is_package_object_typeIR(typeIR)

1. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let packageObjectTypeIR be (typeIR as packageObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:113.1-113.43
def $is_table_object_typeIR(typeIR)

1. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let controlObjectTypeIR be (typeIR as controlObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:120.1-120.41
def $is_synthesizedTypeIR(typeIR)

1. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let tableObjectTypeIR be (typeIR as tableObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:125.1-125.34
def $is_set_typeIR(typeIR)

1. If ((typeIR has type setTypeIR)), then

  1. (Let (set< _typeIR* >) be (typeIR as setTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:5.16-5.24
syntax bound = set<tid>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:6.16-6.32
syntax theta = map<tid, typeIR>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:8.1-8.31
def $free_type(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR has type baseTypeIR)), then

  1. (Let baseTypeIR be (typeIR as baseTypeIR))

  2. Return ({ [] })

3. (Let typeIR be typeIR'')

4. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid tid) be namedTypeIR)

    2. Return ({ [tid] })

5. (Let typeIR' be typeIR'')

6. If ((typeIR' has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR' as namedTypeIR))

  2. If ((namedTypeIR matches pattern `%<%>`)), then

    1. (Let (polyTypeDefIR < typeIR* >) be namedTypeIR)

    2. (Let bound_base be $free_typeDef((polyTypeDefIR as typeDefIR)))

    3. (Let bound_args be $unions_set<tid>($free_type(typeIR)*))

    4. Return $union_set<tid>(bound_base, bound_args)

7. (Let typeIR' be typeIR'')

8. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

    1. (Let (typedef _tid typeIR) be aliasTypeIR)

    2. Return $free_type(typeIR)

9. (Let typeIR' be typeIR'')

10. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid typeIR) be aliasTypeIR)

    2. Return $free_type(typeIR)

11. (Let typeIR' be typeIR'')

12. If ((typeIR' has type listTypeIR)), then

  1. (Let (list< typeIR >) be (typeIR' as listTypeIR))

  2. Return $free_type(typeIR)

13. (Let typeIR' be typeIR'')

14. If ((typeIR' has type tupleTypeIR)), then

  1. (Let (tuple< typeIR* >) be (typeIR' as tupleTypeIR))

  2. Return $unions_set<tid>($free_type(typeIR)*)

15. (Let typeIR' be typeIR'')

16. If ((typeIR' has type headerStackTypeIR)), then

  1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

  2. Return $free_type(typeIR)

17. (Let typeIR' be typeIR'')

18. If ((typeIR' has type headerTypeIR)), then

  1. (Let (header _tid { (typeIR _id ;)* }) be (typeIR' as headerTypeIR))

  2. Return $unions_set<tid>($free_type(typeIR)*)

19. (Let typeIR' be typeIR'')

20. If ((typeIR' has type headerUnionTypeIR)), then

  1. (Let (header_union _tid { (typeIR _id ;)* }) be (typeIR' as headerUnionTypeIR))

  2. Return $unions_set<tid>($free_type(typeIR)*)

21. (Let typeIR' be typeIR'')

22. If ((typeIR' has type structTypeIR)), then

  1. (Let (struct _tid { (typeIR _id ;)* }) be (typeIR' as structTypeIR))

  2. Return $unions_set<tid>($free_type(typeIR)*)

23. (Let typeIR be typeIR'')

24. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

    1. (Let (enum _tid { _id* }) be enumTypeIR)

    2. Return ({ [] })

25. (Let typeIR' be typeIR'')

26. If ((typeIR' has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR' as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return $free_type(typeIR)

27. (Let typeIR be typeIR'')

28. If ((typeIR has type externObjectTypeIR)), then

  1. (Let (extern _tid ({ (_rid : routineTypeDefIR)* })) be (typeIR as externObjectTypeIR))

  2. Return $unions_set<tid>($free_routineTypeDef(routineTypeDefIR)*)

29. (Let typeIR be typeIR'')

30. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

  3. Return bound_params

31. (Let typeIR be typeIR'')

32. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let (control( parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

  2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

  3. Return bound_params

33. (Let typeIR' be typeIR'')

34. If ((typeIR' has type packageObjectTypeIR)), then

  1. (Let (package< typeIR* >) be (typeIR' as packageObjectTypeIR))

  2. Return $unions_set<tid>($free_type(typeIR)*)

35. (Let typeIR' be typeIR'')

36. If ((typeIR' has type tableObjectTypeIR)), then

  1. (Let (table _tid # typeIR) be (typeIR' as tableObjectTypeIR))

  2. Return $free_type(typeIR)

37. (Let typeIR be typeIR'')

38. If ((typeIR = ((default) as typeIR))), then

  1. Return ({ [] })

39. (Let typeIR be typeIR'')

40. If ((typeIR = ((header_invalid) as typeIR))), then

  1. Return ({ [] })

41. (Let typeIR' be typeIR'')

42. If ((typeIR' has type sequenceTypeIR)), then

  1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

  2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

    1. (Let (seq< typeIR* >) be sequenceTypeIR)

    2. Return $unions_set<tid>($free_type(typeIR)*)

43. (Let typeIR' be typeIR'')

44. If ((typeIR' has type sequenceTypeIR)), then

  1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

  2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

    1. (Let (seq< typeIR* ,...>) be sequenceTypeIR)

    2. Return $unions_set<tid>($free_type(typeIR)*)

45. (Let typeIR' be typeIR'')

46. If ((typeIR' has type recordTypeIR)), then

  1. (Let recordTypeIR be (typeIR' as recordTypeIR))

  2. If ((recordTypeIR matches pattern `RECORD{%}`)), then

    1. (Let (record{ (typeIR _id ;)* }) be recordTypeIR)

    2. Return $unions_set<tid>($free_type(typeIR)*)

47. (Let typeIR' be typeIR'')

48. If ((typeIR' has type recordTypeIR)), then

  1. (Let recordTypeIR be (typeIR' as recordTypeIR))

  2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

    1. (Let (record{ (typeIR _id ;)* ,...}) be recordTypeIR)

    2. Return $unions_set<tid>($free_type(typeIR)*)

49. (Let typeIR' be typeIR'')

50. If ((typeIR' has type setTypeIR)), then

  1. (Let (set< typeIR* >) be (typeIR' as setTypeIR))

  2. Return $unions_set<tid>($free_type(typeIR)*)

51. (Let typeIR be typeIR'')

52. If ((typeIR has type tableTypeIR)), then

  1. (Let tableTypeIR be (typeIR as tableTypeIR))

  2. If ((tableTypeIR matches pattern `TABLE_ENUM%{%}`)), then

    1. (Let (table_enum _tid { _id* }) be tableTypeIR)

    2. Return ({ [] })

53. (Let typeIR be typeIR'')

54. If ((typeIR has type tableTypeIR)), then

  1. (Let tableTypeIR be (typeIR as tableTypeIR))

  2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

    1. (Let (table_struct _tid { _fieldTypeIR* }) be tableTypeIR)

    2. Return ({ [] })

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:9.1-9.37
def $free_typeDef(typeDefIR)

1. Case analysis on typeDefIR

  1. Case (% has type typeIR)

    1. (Let typeIR be (typeDefIR as typeIR))

    2. Return $free_type(typeIR)

  2. Case (% has type polyTypeDefIR)

    1. (Let (typeIR_base < tid* , tid_hidden* >) be (typeDefIR as polyTypeDefIR))

    2. (Let bound_base be $free_typeDef((typeIR_base as typeDefIR)))

    3. (Let bound_tparams be ({ tid* ++ tid_hidden* }))

    4. Return $diff_set<tid>(bound_base, bound_tparams)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:10.1-10.49
def $free_parameterType((_direction typeIR _id _value?))

1. Return $free_type(typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:11.1-11.45
def $free_routineType(routineTypeIR)

1. Case analysis on routineTypeIR

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

        1. (Let (builtin_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      2. Case (% matches pattern `FUNCTION(%)->%`)

        1. (Let (function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      3. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

        1. (Let (extern_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      4. Case (% matches pattern `ACTION(%)`)

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. Return bound_params

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

        1. (Let (builtin_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      2. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      3. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. (Let bound_ret be $free_type(typeIR_ret))

        4. Return $union_set<tid>(bound_params, bound_ret)

      4. Case (% matches pattern `PARSER_APPLY(%)`)

        1. (Let (parser_apply( parameterTypeIR* )) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. Return bound_params

      5. Case (% matches pattern `CONTROL_APPLY(%)`)

        1. (Let (control_apply( parameterTypeIR* )) be methodTypeIR)

        2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*))

        3. Return bound_params

      6. Case (% matches pattern `TABLE_APPLY->%`)

        1. (Let (table_apply-> typeIR_ret) be methodTypeIR)

        2. (Let bound_ret be $free_type(typeIR_ret))

        3. Return bound_ret

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:12.1-12.51
def $free_routineTypeDef(routineTypeDefIR)

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

    2. Return $free_routineType(routineTypeIR)

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR < tid* , tid_hidden* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. (Let bound_base be $free_routineTypeDef((routineTypeIR as routineTypeDefIR)))

    3. (Let bound_tparams be ({ tid* ++ tid_hidden* }))

    4. Return $diff_set<tid>(bound_base, bound_tparams)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:14.1-14.40
def $subst_type(set<pair<tid, typeIR>>', typeIR)

1. (Let set<pair<tid, typeIR>> be set<pair<tid, typeIR>>')

2. If ((set<pair<tid, typeIR>> = ({ [] }))), then

  1. Return typeIR

3. (Let theta be set<pair<tid, typeIR>>')

4. Otherwise

  1. Return $subst_type'(theta, typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:15.1-15.41
def $subst_type'(theta, typeIR''')

1. (Let typeIR' be typeIR''')

2. If ((typeIR' has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR' as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid tid) be namedTypeIR)

    2. (Let typeIR''? be $find_map<tid, typeIR>(theta, tid))

    3. If ((typeIR''? matches pattern (_))), then

      1. (Let ?(typeIR) be typeIR''?)

      2. Return typeIR

3. (Let typeIR' be typeIR''')

4. If ((typeIR' has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR' as namedTypeIR))

  2. If ((namedTypeIR matches pattern `%<%>`)), then

    1. (Let (polyTypeDefIR < typeIR* >) be namedTypeIR)

    2. (Let typeDefIR be $subst_typeDef'(theta, (polyTypeDefIR as typeDefIR)))

    3. If ((typeDefIR has type polyTypeDefIR)), then

      1. (Let polyTypeDefIR_subst be (typeDefIR as polyTypeDefIR))

      2. (Let typeIR_subst be $subst_type'(theta, typeIR))*

      3. Return ((polyTypeDefIR_subst < typeIR_subst* >) as typeIR)

5. (Let typeIR' be typeIR''')

6. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

    1. (Let (typedef tid typeIR) be aliasTypeIR)

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))

    3. Return ((typedef tid typeIR_subst) as typeIR)

7. (Let typeIR' be typeIR''')

8. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type tid typeIR) be aliasTypeIR)

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))

    3. Return ((type tid typeIR_subst) as typeIR)

9. (Let typeIR' be typeIR''')

10. If ((typeIR' has type listTypeIR)), then

  1. (Let (list< typeIR >) be (typeIR' as listTypeIR))

  2. (Let typeIR_subst be $subst_type'(theta, typeIR))

  3. Return ((list< typeIR_subst >) as typeIR)

11. (Let typeIR' be typeIR''')

12. If ((typeIR' has type tupleTypeIR)), then

  1. (Let (tuple< typeIR* >) be (typeIR' as tupleTypeIR))

  2. (Let typeIR_subst be $subst_type'(theta, typeIR))*

  3. Return ((tuple< typeIR_subst* >) as typeIR)

13. (Let typeIR' be typeIR''')

14. If ((typeIR' has type headerStackTypeIR)), then

  1. (Let (typeIR [ n ]) be (typeIR' as headerStackTypeIR))

  2. (Let typeIR_subst be $subst_type'(theta, typeIR))

  3. Return ((typeIR_subst [ n ]) as typeIR)

15. (Let typeIR be typeIR''')

16. If ((typeIR has type structTypeIR)), then

  1. (Let (struct tid { (typeIR_f id_f ;)* }) be (typeIR as structTypeIR))

  2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

  3. Return ((struct tid { (typeIR_f_subst id_f ;)* }) as typeIR)

17. (Let typeIR be typeIR''')

18. If ((typeIR has type headerTypeIR)), then

  1. (Let (header tid { (typeIR_f id_f ;)* }) be (typeIR as headerTypeIR))

  2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

  3. Return ((header tid { (typeIR_f_subst id_f ;)* }) as typeIR)

19. (Let typeIR be typeIR''')

20. If ((typeIR has type headerUnionTypeIR)), then

  1. (Let (header_union tid { (typeIR_f id_f ;)* }) be (typeIR as headerUnionTypeIR))

  2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

  3. Return ((header_union tid { (typeIR_f_subst id_f ;)* }) as typeIR)

21. (Let typeIR' be typeIR''')

22. If ((typeIR' has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR' as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum tid # typeIR { valueFieldIR* }) be enumTypeIR)

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))

    3. Return ((enum tid # typeIR_subst { valueFieldIR* }) as typeIR)

23. (Let typeIR be typeIR''')

24. If ((typeIR has type externObjectTypeIR)), then

  1. (Let (extern tid ({ (rid : routineTypeDefIR)* })) be (typeIR as externObjectTypeIR))

  2. (Let routineTypeDefIR_subst be $subst_routineTypeDef'(theta, routineTypeDefIR))*

  3. Return ((extern tid ({ (rid : routineTypeDefIR_subst)* })) as typeIR)

25. (Let typeIR be typeIR''')

26. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

  3. Return ((parser( parameterTypeIR_subst* )) as typeIR)

27. (Let typeIR be typeIR''')

28. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let (control( parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

  2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

  3. Return ((control( parameterTypeIR_subst* )) as typeIR)

29. (Let typeIR' be typeIR''')

30. If ((typeIR' has type packageObjectTypeIR)), then

  1. (Let (package< typeIR* >) be (typeIR' as packageObjectTypeIR))

  2. (Let typeIR_subst be $subst_type'(theta, typeIR))*

  3. Return ((package< typeIR_subst* >) as typeIR)

31. (Let typeIR' be typeIR''')

32. If ((typeIR' has type tableObjectTypeIR)), then

  1. (Let (table tid # typeIR) be (typeIR' as tableObjectTypeIR))

  2. (Let typeIR_subst be $subst_type'(theta, typeIR))

  3. Return ((table tid # typeIR_subst) as typeIR)

33. (Let typeIR' be typeIR''')

34. If ((typeIR' has type sequenceTypeIR)), then

  1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

  2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

    1. (Let (seq< typeIR* >) be sequenceTypeIR)

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))*

    3. Return ((seq< typeIR_subst* >) as typeIR)

35. (Let typeIR' be typeIR''')

36. If ((typeIR' has type sequenceTypeIR)), then

  1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

  2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

    1. (Let (seq< typeIR* ,...>) be sequenceTypeIR)

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))*

    3. Return ((seq< typeIR_subst* ,...>) as typeIR)

37. (Let typeIR be typeIR''')

38. If ((typeIR has type recordTypeIR)), then

  1. (Let recordTypeIR be (typeIR as recordTypeIR))

  2. If ((recordTypeIR matches pattern `RECORD{%}`)), then

    1. (Let (record{ (typeIR_f id_f ;)* }) be recordTypeIR)

    2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

    3. Return ((record{ (typeIR_f_subst id_f ;)* }) as typeIR)

39. (Let typeIR be typeIR''')

40. If ((typeIR has type recordTypeIR)), then

  1. (Let recordTypeIR be (typeIR as recordTypeIR))

  2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

    1. (Let (record{ (typeIR_f id_f ;)* ,...}) be recordTypeIR)

    2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*

    3. Return ((record{ (typeIR_f_subst id_f ;)* ,...}) as typeIR)

41. (Let typeIR' be typeIR''')

42. If ((typeIR' has type setTypeIR)), then

  1. (Let (set< typeIR* >) be (typeIR' as setTypeIR))

  2. (Let typeIR_subst be $subst_type'(theta, typeIR))*

  3. Return ((set< typeIR_subst* >) as typeIR)

43. (Let typeIR be typeIR''')

44. Otherwise

  1. Return typeIR

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:16.1-16.49
def $subst_typeDef(set<pair<tid, typeIR>>', typeDefIR)

1. (Let set<pair<tid, typeIR>> be set<pair<tid, typeIR>>')

2. If ((set<pair<tid, typeIR>> = ({ [] }))), then

  1. Return typeDefIR

3. (Let theta be set<pair<tid, typeIR>>')

4. Otherwise

  1. Return $subst_typeDef'(theta, typeDefIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:17.1-17.50
def $subst_typeDef'(theta, typeDefIR)

1. Case analysis on typeDefIR

  1. Case (% has type typeIR)

    1. (Let typeIR be (typeDefIR as typeIR))

    2. Return ($subst_type'(theta, typeIR) as typeDefIR)

  2. Case (% has type polyTypeDefIR)

    1. (Let (typeIR_base < tid* , tid_hidden* >) be (typeDefIR as polyTypeDefIR))

    2. (Let ({ tid_free* }) be $diff_set<tid>($free_type(typeIR_base), ({ tid* ++ tid_hidden* })))

    3. (Let typeIR? be $find_map<tid, typeIR>(theta, tid_free))*

    4. If ((typeIR? matches pattern (_)))*, then

      1. (Let ?(typeIR_free) be typeIR?)*

      2. (Let bound_capture be $unions_set<tid>($free_type(typeIR_free)*))

      3. (Let tid_fresh* be $fresh_tids(|tid* ++ tid_hidden*|))

      4. If (~$in_set<tid>(tid_fresh, bound_capture))*, then

        1. (Let tid_fresh_spec* be tid_fresh*[0 : |tid*|])

        2. (Let tid_fresh_hidden* be tid_fresh*[|tid*| : |tid_hidden*|])

        3. (Let theta' be $adds_map<tid, typeIR>(theta, tid*, ((tid tid_fresh_spec) as typeIR)*))

        4. (Let theta'' be $adds_map<tid, typeIR>(theta', tid_hidden*, ((tid tid_fresh_hidden) as typeIR)*))

        5. (Let typeIR_base_subst be $subst_type(theta'', typeIR_base))

        6. Return ((typeIR_base_subst < tid_fresh_spec* , tid_fresh_hidden* >) as typeDefIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:18.1-18.67
def $subst_parameterType(set<pair<tid, typeIR>>', parameterTypeIR)

1. (Let set<pair<tid, typeIR>> be set<pair<tid, typeIR>>')

2. If ((set<pair<tid, typeIR>> = ({ [] }))), then

  1. Return parameterTypeIR

3. (Let theta be set<pair<tid, typeIR>>')

4. Otherwise

  1. Return $subst_parameterType'(theta, parameterTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:19.1-19.68
def $subst_parameterType'(theta, (direction typeIR id value?))

1. (Let typeIR_subst be $subst_type'(theta, typeIR))

2. Return (direction typeIR_subst id value?)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:20.1-20.61
def $subst_routineType(set<pair<tid, typeIR>>', routineTypeIR)

1. (Let set<pair<tid, typeIR>> be set<pair<tid, typeIR>>')

2. If ((set<pair<tid, typeIR>> = ({ [] }))), then

  1. Return routineTypeIR

3. (Let theta be set<pair<tid, typeIR>>')

4. Otherwise

  1. Return $subst_routineType'(theta, routineTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:21.1-21.62
def $subst_routineType'(theta, routineTypeIR)

1. Case analysis on routineTypeIR

  1. Case (% has type functionTypeIR)

    1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

    2. Case analysis on functionTypeIR

      1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

        1. (Let (builtin_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((builtin_function( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      2. Case (% matches pattern `FUNCTION(%)->%`)

        1. (Let (function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((function( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      3. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

        1. (Let (extern_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((extern_function( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      4. Case (% matches pattern `ACTION(%)`)

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. Return ((action( parameterTypeIR_subst* )) as routineTypeIR)

  2. Case (% has type methodTypeIR)

    1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

        1. (Let (builtin_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((builtin_method( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      2. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((extern_method( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      3. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        4. Return ((extern_methodabstract( parameterTypeIR_subst* )-> typeIR_ret_subst) as routineTypeIR)

      4. Case (% matches pattern `PARSER_APPLY(%)`)

        1. (Let (parser_apply( parameterTypeIR* )) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. Return ((parser_apply( parameterTypeIR_subst* )) as routineTypeIR)

      5. Case (% matches pattern `CONTROL_APPLY(%)`)

        1. (Let (control_apply( parameterTypeIR* )) be methodTypeIR)

        2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

        3. Return ((control_apply( parameterTypeIR_subst* )) as routineTypeIR)

      6. Case (% matches pattern `TABLE_APPLY->%`)

        1. (Let (table_apply-> typeIR_ret) be methodTypeIR)

        2. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

        3. Return ((table_apply-> typeIR_ret_subst) as routineTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:22.1-22.70
def $subst_routineTypeDef(set<pair<tid, typeIR>>', routineTypeDefIR)

1. (Let set<pair<tid, typeIR>> be set<pair<tid, typeIR>>')

2. If ((set<pair<tid, typeIR>> = ({ [] }))), then

  1. Return routineTypeDefIR

3. (Let theta be set<pair<tid, typeIR>>')

4. Otherwise

  1. Return $subst_routineTypeDef'(theta, routineTypeDefIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:23.1-23.71
def $subst_routineTypeDef'(theta, routineTypeDefIR)

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

    2. Return ($subst_routineType'(theta, routineTypeIR) as routineTypeDefIR)

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR < tid* , tid_hidden* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. (Let ({ tid_free* }) be $diff_set<tid>($free_routineType(routineTypeIR), ({ tid* ++ tid_hidden* })))

    3. (Let typeIR? be $find_map<tid, typeIR>(theta, tid_free))*

    4. If ((typeIR? matches pattern (_)))*, then

      1. (Let ?(typeIR_free) be typeIR?)*

      2. (Let bound_capture be $unions_set<tid>($free_type(typeIR_free)*))

      3. (Let tid_fresh* be $fresh_tids(|tid* ++ tid_hidden*|))

      4. If (~$in_set<tid>(tid_fresh, bound_capture))*, then

        1. (Let tid_fresh_spec* be tid_fresh*[0 : |tid*|])

        2. (Let tid_fresh_hidden* be tid_fresh*[|tid*| : |tid_hidden*|])

        3. (Let theta' be $adds_map<tid, typeIR>(theta, tid*, ((tid tid_fresh_spec) as typeIR)*))

        4. (Let theta'' be $adds_map<tid, typeIR>(theta', tid_hidden*, ((tid tid_fresh_hidden) as typeIR)*))

        5. (Let routineTypeIR_subst be $subst_routineType(theta'', routineTypeIR))

        6. Return ((routineTypeIR_subst < tid_fresh_spec* , tid_fresh_hidden* >) as routineTypeDefIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:24.1-24.73
def $subst_constructorType(set<pair<tid, typeIR>>', constructorTypeIR)

1. (Let set<pair<tid, typeIR>> be set<pair<tid, typeIR>>')

2. If ((set<pair<tid, typeIR>> = ({ [] }))), then

  1. Return constructorTypeIR

3. (Let theta be set<pair<tid, typeIR>>')

4. Otherwise

  1. Return $subst_constructorType'(theta, constructorTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:25.1-25.74
def $subst_constructorType'(theta, (constructor( parameterTypeIR* )-> typeIR_obj))

1. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*

2. (Let typeIR_obj_subst be $subst_type'(theta, typeIR_obj))

3. Return (constructor( parameterTypeIR_subst* )-> typeIR_obj_subst)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:561.1-561.53
def $specialize_typeDef(typeDefIR, typeIR''*)

1. (Let typeIR' be typeIR'')*

2. If ((typeDefIR has type typeIR)), then

  1. (Let typeIR be (typeDefIR as typeIR))

  2. If ((typeIR'* matches pattern [])), then

    1. Return typeIR

3. (Let typeIR_arg be typeIR'')*

4. If ((typeDefIR has type polyTypeDefIR)), then

  1. (Let (typeIR_base < tid* , tid_hidden* >) be (typeDefIR as polyTypeDefIR))

  2. (Let tid_tparam* be tid* ++ tid_hidden*)

  3. (Let theta be ({ (tid_tparam : typeIR_arg)* }))

  4. Return $subst_type(theta, typeIR_base)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:574.1-575.29
def $specialize_routineTypeDef(routineTypeDefIR, typeIR'*)

1. (Let typeIR be typeIR')*

2. If ((routineTypeDefIR has type routineTypeIR)), then

  1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

  2. If ((typeIR* matches pattern [])), then

    1. Return ((routineTypeIR as routineTypeDefIR), [])

3. (Let typeIR_arg be typeIR')*

4. If ((routineTypeDefIR has type polyRoutineTypeDefIR)), then

  1. (Let (routineTypeIR < tid* , tid_hidden* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

  2. (Let tid_tparam* be tid* ++ tid_hidden*)

  3. If ((|tid_tparam*| = |typeIR_arg*|)), then

    1. (Let theta be ({ (tid_tparam : typeIR_arg)* }))

    2. Return (($subst_routineType(theta, routineTypeIR) as routineTypeDefIR), [])

5. (Let typeIR_arg be typeIR')*

6. If ((routineTypeDefIR has type polyRoutineTypeDefIR)), then

  1. (Let (routineTypeIR < tid* , tid_hidden* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

  2. (Let tid_tparam* be tid* ++ tid_hidden*)

  3. If (((|tid_tparam*| > 0) /\ (|typeIR_arg*| = 0))), then

    1. (Let tid_fresh* be $fresh_tids(|tid_tparam*|))

    2. (Let theta be ({ (tid_tparam : ((tid tid_fresh) as typeIR))* }))

    3. Return (($subst_routineType(theta, routineTypeIR), tid_fresh*) as (routineTypeDefIR, tid*))

7. (Let typeIR_arg be typeIR')*

8. If ((routineTypeDefIR has type polyRoutineTypeDefIR)), then

  1. (Let (routineTypeIR < tid* , tid_hidden* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

  2. (Let tid_tparam* be tid* ++ tid_hidden*)

  3. If ((((|tid_hidden*| > 0) /\ (|tid*| = |typeIR_arg*|)) /\ (|typeIR_arg*| > 0))), then

    1. (Let tid_fresh* be $fresh_tids(|tid_hidden*|))

    2. (Let typeIR_arg_new* be typeIR_arg* ++ ((tid tid_fresh) as typeIR)*)

    3. (Let theta be ({ (tid_tparam : typeIR_arg_new)* }))

    4. Return (($subst_routineType(theta, routineTypeIR), tid_fresh*) as (routineTypeDefIR, tid*))

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:616.1-617.30
def $specialize_constructorTypeDef((constructorTypeIR < tid* , tid_hidden* >), typeIR_arg*)

1. (Let tid_tparam* be tid* ++ tid_hidden*)

2. If ((|tid_tparam*| = |typeIR_arg*|)), then

  1. (Let theta be ({ (tid_tparam : typeIR_arg)* }))

  2. (Let constructorTypeIR_subst be $subst_constructorType(theta, constructorTypeIR))

  3. Return (constructorTypeIR_subst, [])

3. (Let tid_tparam* be tid* ++ tid_hidden*)

4. If (((|tid_tparam*| > 0) /\ (|typeIR_arg*| = 0))), then

  1. (Let tid_fresh* be $fresh_tids(|tid_tparam*|))

  2. (Let theta be ({ (tid_tparam : ((tid tid_fresh) as typeIR))* }))

  3. (Let constructorTypeIR_subst be $subst_constructorType(theta, constructorTypeIR))

  4. Return (constructorTypeIR_subst, tid_fresh*)

5. (Let tid_tparam* be tid* ++ tid_hidden*)

6. If ((((|tid_hidden*| > 0) /\ (|tid*| = |typeIR_arg*|)) /\ (|typeIR_arg*| > 0))), then

  1. (Let tid_fresh* be $fresh_tids(|tid_hidden*|))

  2. (Let typeIR_arg_new* be typeIR_arg* ++ ((tid tid_fresh) as typeIR)*)

  3. (Let theta be ({ (tid_tparam : typeIR_arg_new)* }))

  4. (Let constructorTypeIR_subst be $subst_constructorType(theta, constructorTypeIR))

  5. Return (constructorTypeIR_subst, tid_fresh*)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:662.1-662.28
def $canon(typeIR'')

1. (Let typeIR' be typeIR'')

2. If ((typeIR' has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR' as namedTypeIR))

  2. If ((namedTypeIR matches pattern `%<%>`)), then

    1. (Let (polyTypeDefIR < typeIR_arg* >) be namedTypeIR)

    2. (Let typeIR be $specialize_typeDef((polyTypeDefIR as typeDefIR), typeIR_arg*))

    3. Return $canon(typeIR)

3. (Let typeIR' be typeIR'')

4. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

    1. (Let (typedef _tid typeIR) be aliasTypeIR)

    2. Return $canon(typeIR)

5. (Let typeIR be typeIR'')

6. Otherwise

  1. Return typeIR

;; ../../../../spec-concrete/2.2.4-type-util.watsup:7.1-7.38
def $is_nominal_typeIR(typeIR)

1. Return $is_nominal_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:8.1-8.39
def $is_nominal_typeIR'(typeIR)

1. Case analysis on typeIR

  1. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid _typeIR) be aliasTypeIR)

      2. Return true

  2. Case (% has type structTypeIR)

    1. (Let (struct _tid { _fieldTypeIR* }) be (typeIR as structTypeIR))

    2. Return true

  3. Case (% has type headerTypeIR)

    1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

    2. Return true

  4. Case (% has type headerUnionTypeIR)

    1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR as headerUnionTypeIR))

    2. Return true

  5. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

  6. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR as externObjectTypeIR))

    2. Return true

  7. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.4-type-util.watsup:25.1-25.42
def $is_defaultable_typeIR(typeIR)

1. Return $is_defaultable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:26.1-26.43
def $is_defaultable_typeIR'(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR'')

4. If ((typeIR = ((error) as typeIR))), then

  1. Return true

5. (Let typeIR be typeIR'')

6. If ((typeIR = ((string) as typeIR))), then

  1. Return true

7. (Let typeIR be typeIR'')

8. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Return true

9. (Let typeIR' be typeIR'')

10. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid typeIR) be aliasTypeIR)

    2. Return $is_defaultable_typeIR(typeIR)

11. (Let typeIR' be typeIR'')

12. If ((typeIR' has type tupleTypeIR)), then

  1. (Let (tuple< typeIR* >) be (typeIR' as tupleTypeIR))

  2. If ($is_defaultable_typeIR(typeIR))*, then

    1. Return true

13. (Let typeIR' be typeIR'')

14. If ((typeIR' has type headerStackTypeIR)), then

  1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

  2. Return $is_defaultable_typeIR(typeIR)

15. (Let typeIR' be typeIR'')

16. If ((typeIR' has type structTypeIR)), then

  1. (Let (struct _tid { (typeIR _id ;)* }) be (typeIR' as structTypeIR))

  2. If ($is_defaultable_typeIR(typeIR))*, then

    1. Return true

17. (Let typeIR' be typeIR'')

18. If ((typeIR' has type headerTypeIR)), then

  1. (Let (header _tid { (typeIR _id ;)* }) be (typeIR' as headerTypeIR))

  2. If ($is_defaultable_typeIR(typeIR))*, then

    1. Return true

19. (Let typeIR' be typeIR'')

20. If ((typeIR' has type headerUnionTypeIR)), then

  1. (Let (header_union _tid { (typeIR _id ;)* }) be (typeIR' as headerUnionTypeIR))

  2. If ($is_defaultable_typeIR(typeIR))*, then

    1. Return true

21. (Let typeIR be typeIR'')

22. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

    1. (Let (enum _tid { _id* }) be enumTypeIR)

    2. Return true

23. (Let typeIR' be typeIR'')

24. If ((typeIR' has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR' as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return $is_defaultable_typeIR(typeIR)

25. (Let typeIR be typeIR'')

26. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.4-type-util.watsup:54.1-54.40
def $is_equalable_typeIR(typeIR)

1. Return $is_equalable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:55.1-55.41
def $is_equalable_typeIR'(typeIR)

1. If ((typeIR = ((void) as typeIR))), then

  1. Return false

2. Case analysis on typeIR

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR as namedTypeIR))

    2. If ((namedTypeIR matches pattern `TID%`)), then

      1. (Let (tid tid) be namedTypeIR)

      2. Return false

  2. Case (% has type externObjectTypeIR)

    1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR as externObjectTypeIR))

    2. Return false

  3. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

    2. Return false

  4. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

    2. Return false

  5. Case (% has type packageObjectTypeIR)

    1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

    2. Return false

  6. Case (% has type tableObjectTypeIR)

    1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

    2. Return false

  7. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

    2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

      1. (Let (seq< _typeIR* ,...>) be sequenceTypeIR)

      2. Return false

  8. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR as recordTypeIR))

    2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

      1. (Let (record{ _fieldTypeIR* ,...}) be recordTypeIR)

      2. Return false

  9. Case (% has type setTypeIR)

    1. (Let (set< _typeIR* >) be (typeIR as setTypeIR))

    2. Return false

  10. Case (% has type tableTypeIR)

    1. (Let tableTypeIR be (typeIR as tableTypeIR))

    2. Case analysis on tableTypeIR

      1. Case (% matches pattern `TABLE_ENUM%{%}`)

        1. (Let (table_enum _tid { _id* }) be tableTypeIR)

        2. Return false

      2. Case (% matches pattern `TABLE_STRUCT%{%}`)

        1. (Let (table_struct _tid { _fieldTypeIR* }) be tableTypeIR)

        2. Return false

3. If ((typeIR = ((default) as typeIR))), then

  1. Return false

4. If ((typeIR = ((header_invalid) as typeIR))), then

  1. Return false

5. Otherwise

  1. Return true

;; ../../../../spec-concrete/2.2.4-type-util.watsup:78.1-78.41
def $is_assignable_typeIR(typeIR)

1. Return $is_assignable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:79.1-79.42
def $is_assignable_typeIR'(typeIR)

1. If ((typeIR = ((void) as typeIR))), then

  1. Return false

2. If ((typeIR = ((string) as typeIR))), then

  1. Return false

3. If ((typeIR = ((int) as typeIR))), then

  1. Return false

4. Case analysis on typeIR

  1. Case (% has type objectTypeIR)

    1. (Let objectTypeIR be (typeIR as objectTypeIR))

    2. Return false

  2. Case (% has type synthesizedTypeIR)

    1. (Let synthesizedTypeIR be (typeIR as synthesizedTypeIR))

    2. Return false

5. Otherwise

  1. Return true

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:5.1-7.20
relation Type_alpha

  (match) typeIR'''' | typeIR'''''

    1. (Let typeIR be typeIR'''')

    2. (Let typeIR' be typeIR''''')

    3. If ((typeIR has type baseTypeIR)), then

      1. (Let baseTypeIR be (typeIR as baseTypeIR))

      2. If ((typeIR' has type baseTypeIR)), then

        1. (Let baseTypeIR' be (typeIR' as baseTypeIR))

        2. If ((baseTypeIR = baseTypeIR')), then

          1. Try matching path basetype

    4. (Let typeIR be typeIR'''')

    5. (Let typeIR' be typeIR''''')

    6. If ((typeIR has type namedTypeIR)), then

      1. (Let namedTypeIR be (typeIR as namedTypeIR))

      2. If ((namedTypeIR matches pattern `TID%`)), then

        1. (Let (tid tid) be namedTypeIR)

        2. If ((typeIR' has type namedTypeIR)), then

          1. (Let namedTypeIR' be (typeIR' as namedTypeIR))

          2. If ((namedTypeIR' matches pattern `TID%`)), then

            1. (Let (tid tid') be namedTypeIR')

            2. If ((tid = tid')), then

              1. Try matching path nametype

    7. (Let typeIR be typeIR'''')

    8. (Let typeIR' be typeIR''''')

    9. If ((typeIR has type namedTypeIR)), then

      1. (Let namedTypeIR be (typeIR as namedTypeIR))

      2. If ((namedTypeIR matches pattern `%<%>`)), then

        1. (Let (polyTypeDefIR_a < typeIR_a* >) be namedTypeIR)

        2. If ((typeIR' has type namedTypeIR)), then

          1. (Let namedTypeIR' be (typeIR' as namedTypeIR))

          2. If ((namedTypeIR' matches pattern `%<%>`)), then

            1. (Let (polyTypeDefIR_b < typeIR_b* >) be namedTypeIR')

            2. Try matching path spectype

    10. (Let typeIR be typeIR'''')

    11. (Let typeIR' be typeIR''''')

    12. Try matching path typedeftype

    13. (Let typeIR be typeIR'''')

    14. (Let typeIR' be typeIR''''')

    15. If ((typeIR has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

        1. (Let (type tid typeIR_a) be aliasTypeIR)

        2. If ((typeIR' has type aliasTypeIR)), then

          1. (Let aliasTypeIR' be (typeIR' as aliasTypeIR))

          2. If ((aliasTypeIR' matches pattern `TYPE%%`)), then

            1. (Let (type tid' typeIR_b) be aliasTypeIR')

            2. If ((tid = tid')), then

              1. Try matching path newtype

    16. (Let typeIR be typeIR'''')

    17. (Let typeIR' be typeIR''''')

    18. If ((typeIR has type listTypeIR)), then

      1. (Let (list< typeIR_a >) be (typeIR as listTypeIR))

      2. If ((typeIR' has type listTypeIR)), then

        1. (Let (list< typeIR_b >) be (typeIR' as listTypeIR))

        2. Try matching path listtype

    19. (Let typeIR be typeIR'''')

    20. (Let typeIR' be typeIR''''')

    21. If ((typeIR has type tupleTypeIR)), then

      1. (Let (tuple< typeIR_a* >) be (typeIR as tupleTypeIR))

      2. If ((typeIR' has type tupleTypeIR)), then

        1. (Let (tuple< typeIR_b* >) be (typeIR' as tupleTypeIR))

        2. Try matching path tupletype

    22. (Let typeIR be typeIR'''')

    23. (Let typeIR' be typeIR''''')

    24. If ((typeIR has type headerStackTypeIR)), then

      1. (Let (typeIR_a [ n_s ]) be (typeIR as headerStackTypeIR))

      2. If ((typeIR' has type headerStackTypeIR)), then

        1. (Let (typeIR_b [ n_s' ]) be (typeIR' as headerStackTypeIR))

        2. If ((n_s = n_s')), then

          1. Try matching path stacktype

    25. (Let typeIR be typeIR'''')

    26. (Let typeIR' be typeIR''''')

    27. If ((typeIR has type structTypeIR)), then

      1. (Let (struct tid { (typeIR_f_a id_f ;)* }) be (typeIR as structTypeIR))

      2. If ((typeIR' has type structTypeIR)), then

        1. (Let (struct tid' { (typeIR_f_b id_f' ;)* }) be (typeIR' as structTypeIR))

        2. If ((id_f = id_f'))*, then

          1. If ((tid = tid')), then

            1. Try matching path structtype

    28. (Let typeIR be typeIR'''')

    29. (Let typeIR' be typeIR''''')

    30. If ((typeIR has type headerTypeIR)), then

      1. (Let (header tid { (typeIR_f_a id_f ;)* }) be (typeIR as headerTypeIR))

      2. If ((typeIR' has type headerTypeIR)), then

        1. (Let (header tid' { (typeIR_f_b id_f' ;)* }) be (typeIR' as headerTypeIR))

        2. If ((id_f = id_f'))*, then

          1. If ((tid = tid')), then

            1. Try matching path headertype

    31. (Let typeIR be typeIR'''')

    32. (Let typeIR' be typeIR''''')

    33. If ((typeIR has type headerUnionTypeIR)), then

      1. (Let (header_union tid { (typeIR_f_a id_f ;)* }) be (typeIR as headerUnionTypeIR))

      2. If ((typeIR' has type headerUnionTypeIR)), then

        1. (Let (header_union tid' { (typeIR_f_b id_f' ;)* }) be (typeIR' as headerUnionTypeIR))

        2. If ((id_f = id_f'))*, then

          1. If ((tid = tid')), then

            1. Try matching path headeruniontype

    34. (Let typeIR be typeIR'''')

    35. (Let typeIR' be typeIR''''')

    36. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

        1. (Let (enum tid { id_f* }) be enumTypeIR)

        2. If ((typeIR' has type enumTypeIR)), then

          1. (Let enumTypeIR' be (typeIR' as enumTypeIR))

          2. If ((enumTypeIR' matches pattern `ENUM%{%}`)), then

            1. (Let (enum tid' { id_f'* }) be enumTypeIR')

            2. If ((id_f = id_f'))*, then

              1. If ((tid = tid')), then

                1. Try matching path enumtype

    37. (Let typeIR be typeIR'''')

    38. (Let typeIR' be typeIR''''')

    39. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum tid # typeIR_a { (id_f = value_f ;)* }) be enumTypeIR)

        2. If ((typeIR' has type enumTypeIR)), then

          1. (Let enumTypeIR' be (typeIR' as enumTypeIR))

          2. If ((enumTypeIR' matches pattern `ENUM%#%{%}`)), then

            1. (Let (enum tid' # typeIR_b { (id_f' = value_f' ;)* }) be enumTypeIR')

            2. If ((id_f = id_f'))*, then

              1. If ((tid = tid')), then

                1. If ((value_f = value_f'))*, then

                  1. Try matching path serenumtype

    40. (Let typeIR be typeIR'''')

    41. (Let typeIR' be typeIR''''')

    42. If ((typeIR has type externObjectTypeIR)), then

      1. (Let (extern tid ({ (rid_a : routineTypeDefIR_a)* })) be (typeIR as externObjectTypeIR))

      2. If ((typeIR' has type externObjectTypeIR)), then

        1. (Let (extern tid' ({ (rid_b : routineTypeDefIR_b)* })) be (typeIR' as externObjectTypeIR))

        2. If ((tid = tid')), then

          1. Try matching path externtype

    43. (Let typeIR be typeIR'''')

    44. (Let typeIR' be typeIR''''')

    45. If ((typeIR has type parserObjectTypeIR)), then

      1. (Let (parser( parameterTypeIR_a* )) be (typeIR as parserObjectTypeIR))

      2. If ((typeIR' has type parserObjectTypeIR)), then

        1. (Let (parser( parameterTypeIR_b* )) be (typeIR' as parserObjectTypeIR))

        2. Try matching path parsertype

    46. (Let typeIR be typeIR'''')

    47. (Let typeIR' be typeIR''''')

    48. If ((typeIR has type controlObjectTypeIR)), then

      1. (Let (control( parameterTypeIR_a* )) be (typeIR as controlObjectTypeIR))

      2. If ((typeIR' has type controlObjectTypeIR)), then

        1. (Let (control( parameterTypeIR_b* )) be (typeIR' as controlObjectTypeIR))

        2. Try matching path controltype

    49. (Let typeIR be typeIR'''')

    50. (Let typeIR' be typeIR''''')

    51. If ((typeIR has type packageObjectTypeIR)), then

      1. (Let (package< typeIR_a* >) be (typeIR as packageObjectTypeIR))

      2. If ((typeIR' has type packageObjectTypeIR)), then

        1. (Let (package< typeIR_b* >) be (typeIR' as packageObjectTypeIR))

        2. Try matching path packagetype

    52. (Let typeIR be typeIR'''')

    53. (Let typeIR' be typeIR''''')

    54. If ((typeIR has type tableObjectTypeIR)), then

      1. (Let (table tid # typeIR_a) be (typeIR as tableObjectTypeIR))

      2. If ((typeIR' has type tableObjectTypeIR)), then

        1. (Let (table tid' # typeIR_b) be (typeIR' as tableObjectTypeIR))

        2. If ((tid = tid')), then

          1. Try matching path tabletype

    55. (Let typeIR be typeIR'''')

    56. (Let typeIR' be typeIR''''')

    57. If ((typeIR = ((default) as typeIR))), then

      1. If ((typeIR' = ((default) as typeIR))), then

        1. Try matching path defaulttype

    58. (Let typeIR be typeIR'''')

    59. (Let typeIR' be typeIR''''')

    60. If ((typeIR has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

        1. (Let (seq< typeIR_a* >) be sequenceTypeIR)

        2. If ((typeIR' has type sequenceTypeIR)), then

          1. (Let sequenceTypeIR' be (typeIR' as sequenceTypeIR))

          2. If ((sequenceTypeIR' matches pattern `SEQ<%>`)), then

            1. (Let (seq< typeIR_b* >) be sequenceTypeIR')

            2. Try matching path sequencetype

    61. (Let typeIR be typeIR'''')

    62. (Let typeIR' be typeIR''''')

    63. If ((typeIR has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

        1. (Let (seq< typeIR_a* ,...>) be sequenceTypeIR)

        2. If ((typeIR' has type sequenceTypeIR)), then

          1. (Let sequenceTypeIR' be (typeIR' as sequenceTypeIR))

          2. If ((sequenceTypeIR' matches pattern `SEQ<%,...>`)), then

            1. (Let (seq< typeIR_b* ,...>) be sequenceTypeIR')

            2. Try matching path sequencedefaulttype

    64. (Let typeIR be typeIR'''')

    65. (Let typeIR' be typeIR''''')

    66. If ((typeIR has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%}`)), then

        1. (Let (record{ (typeIR_a id ;)* }) be recordTypeIR)

        2. If ((typeIR' has type recordTypeIR)), then

          1. (Let recordTypeIR' be (typeIR' as recordTypeIR))

          2. If ((recordTypeIR' matches pattern `RECORD{%}`)), then

            1. (Let (record{ (typeIR_b id' ;)* }) be recordTypeIR')

            2. If ((id = id'))*, then

              1. Try matching path recordtype

    67. (Let typeIR be typeIR'''')

    68. (Let typeIR' be typeIR''''')

    69. If ((typeIR has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

        1. (Let (record{ (typeIR_a id ;)* ,...}) be recordTypeIR)

        2. If ((typeIR' has type recordTypeIR)), then

          1. (Let recordTypeIR' be (typeIR' as recordTypeIR))

          2. If ((recordTypeIR' matches pattern `RECORD{%,...}`)), then

            1. (Let (record{ (typeIR_b id' ;)* ,...}) be recordTypeIR')

            2. If ((id = id'))*, then

              1. Try matching path recorddefaulttype

    70. (Let typeIR be typeIR'''')

    71. (Let typeIR' be typeIR''''')

    72. If ((typeIR = ((header_invalid) as typeIR))), then

      1. If ((typeIR' = ((header_invalid) as typeIR))), then

        1. Try matching path invalidtype

    73. (Let typeIR' be typeIR'''')

    74. (Let typeIR''' be typeIR''''')

    75. If ((typeIR' has type setTypeIR)), then

      1. (Let (set< typeIR* >) be (typeIR' as setTypeIR))

      2. If ((typeIR* matches pattern [ _/1 ])), then

        1. (Let [typeIR_a] be typeIR*)

        2. If ((typeIR''' has type setTypeIR)), then

          1. (Let (set< typeIR''* >) be (typeIR''' as setTypeIR))

          2. If ((typeIR''* matches pattern [ _/1 ])), then

            1. (Let [typeIR_b] be typeIR''*)

            2. Try matching path settype

    76. (Let typeIR be typeIR'''')

    77. (Let typeIR' be typeIR''''')

    78. If ((typeIR has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TABLE_ENUM%{%}`)), then

        1. (Let (table_enum tid { id_f* }) be tableTypeIR)

        2. If ((typeIR' has type tableTypeIR)), then

          1. (Let tableTypeIR' be (typeIR' as tableTypeIR))

          2. If ((tableTypeIR' matches pattern `TABLE_ENUM%{%}`)), then

            1. (Let (table_enum tid' { id_f'* }) be tableTypeIR')

            2. If ((id_f = id_f'))*, then

              1. If ((tid = tid')), then

                1. Try matching path tableenumtype

    79. (Let typeIR be typeIR'''')

    80. (Let typeIR' be typeIR''''')

    81. If ((typeIR has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

        1. (Let (table_struct tid { (typeIR_f_a id_f ;)* }) be tableTypeIR)

        2. If ((typeIR' has type tableTypeIR)), then

          1. (Let tableTypeIR' be (typeIR' as tableTypeIR))

          2. If ((tableTypeIR' matches pattern `TABLE_STRUCT%{%}`)), then

            1. (Let (table_struct tid' { (typeIR_f_b id_f' ;)* }) be tableTypeIR')

            2. If ((id_f = id_f'))*, then

              1. If ((tid = tid')), then

                1. Try matching path tablestructtype

  (path) basetype (baseTypeIR as typeIR) | (baseTypeIR as typeIR)

    1. The relation holds

  (path) nametype ((tid tid) as typeIR) | ((tid tid) as typeIR)

    1. The relation holds

  (path) spectype ((polyTypeDefIR_a < typeIR_a* >) as typeIR) | ((polyTypeDefIR_b < typeIR_b* >) as typeIR)

    1. (Let typeIR_a_spec be $specialize_typeDef((polyTypeDefIR_a as typeDefIR), typeIR_a*))

    2. (Let typeIR_b_spec be $specialize_typeDef((polyTypeDefIR_b as typeDefIR), typeIR_b*))

    3. If ((Type_alpha: typeIR_a_spec ~~ typeIR_b_spec holds)), then

      1. If (($is_nominal_typeIR(typeIR_a_spec) /\ $is_nominal_typeIR(typeIR_b_spec))), then

        1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

          1. The relation holds

    4. (Let typeIR_a_spec be $specialize_typeDef((polyTypeDefIR_a as typeDefIR), typeIR_a*))

    5. (Let typeIR_b_spec be $specialize_typeDef((polyTypeDefIR_b as typeDefIR), typeIR_b*))

    6. If ((Type_alpha: typeIR_a_spec ~~ typeIR_b_spec holds)), then

      1. If ((~$is_nominal_typeIR(typeIR_a_spec) /\ ~$is_nominal_typeIR(typeIR_b_spec))), then

        1. The relation holds

  (path) typedeftype typeIR | typeIR'

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

        1. (Let (typedef _tid typeIR_a) be aliasTypeIR)

        2. (Let typeIR_b be typeIR')

        3. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

          1. The relation holds

    3. (Let typeIR_a be typeIR)

    4. (Let typeIR'' be typeIR')

    5. If ((typeIR'' has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

        1. (Let (typedef _tid typeIR_b) be aliasTypeIR)

        2. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

          1. The relation holds

  (path) newtype ((type tid typeIR_a) as typeIR) | ((type tid typeIR_b) as typeIR)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. The relation holds

  (path) listtype ((list< typeIR_a >) as typeIR) | ((list< typeIR_b >) as typeIR)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. The relation holds

  (path) tupletype ((tuple< typeIR_a* >) as typeIR) | ((tuple< typeIR_b* >) as typeIR)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

      1. The relation holds

  (path) stacktype ((typeIR_a [ n_s ]) as typeIR) | ((typeIR_b [ n_s ]) as typeIR)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. The relation holds

  (path) structtype ((struct tid { (typeIR_f_a id_f ;)* }) as typeIR) | ((struct tid { (typeIR_f_b id_f ;)* }) as typeIR)

    1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*, then

      1. The relation holds

  (path) headertype ((header tid { (typeIR_f_a id_f ;)* }) as typeIR) | ((header tid { (typeIR_f_b id_f ;)* }) as typeIR)

    1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*, then

      1. The relation holds

  (path) headeruniontype ((header_union tid { (typeIR_f_a id_f ;)* }) as typeIR) | ((header_union tid { (typeIR_f_b id_f ;)* }) as typeIR)

    1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*, then

      1. The relation holds

  (path) enumtype ((enum tid { id_f* }) as typeIR) | ((enum tid { id_f* }) as typeIR)

    1. The relation holds

  (path) serenumtype ((enum tid # typeIR_a { (id_f = value_f ;)* }) as typeIR) | ((enum tid # typeIR_b { (id_f = value_f ;)* }) as typeIR)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. The relation holds

  (path) externtype ((extern tid ({ (rid_a : routineTypeDefIR_a)* })) as typeIR) | ((extern tid ({ (rid_b : routineTypeDefIR_b)* })) as typeIR)

    1. If ($eq_set<rid>(({ rid_a* }), ({ rid_b* }))), then

      1. (Let routineTypeDefIR? be $find_map<rid, routineTypeDefIR>(({ (rid_a : routineTypeDefIR_a)* }), rid_a))*

      2. If ((routineTypeDefIR? matches pattern (_)))*, then

        1. (Let ?(routineTypeDefIR_a') be routineTypeDefIR?)*

        2. (Let routineTypeDefIR'? be $find_map<rid, routineTypeDefIR>(({ (rid_b : routineTypeDefIR_b)* }), rid_a))*

        3. If ((routineTypeDefIR'? matches pattern (_)))*, then

          1. (Let ?(routineTypeDefIR_b') be routineTypeDefIR'?)*

          2. If ((RoutineTypeDef_alpha: routineTypeDefIR_a' ~~ routineTypeDefIR_b' holds))*, then

            1. The relation holds

  (path) parsertype ((parser( parameterTypeIR_a* )) as typeIR) | ((parser( parameterTypeIR_b* )) as typeIR)

    1. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

      1. The relation holds

  (path) controltype ((control( parameterTypeIR_a* )) as typeIR) | ((control( parameterTypeIR_b* )) as typeIR)

    1. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

      1. The relation holds

  (path) packagetype ((package< typeIR_a* >) as typeIR) | ((package< typeIR_b* >) as typeIR)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

      1. The relation holds

  (path) tabletype ((table tid # typeIR_a) as typeIR) | ((table tid # typeIR_b) as typeIR)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. The relation holds

  (path) defaulttype ((default) as typeIR) | ((default) as typeIR)

    1. The relation holds

  (path) sequencetype ((seq< typeIR_a* >) as typeIR) | ((seq< typeIR_b* >) as typeIR)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

      1. The relation holds

  (path) sequencedefaulttype ((seq< typeIR_a* ,...>) as typeIR) | ((seq< typeIR_b* ,...>) as typeIR)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

      1. The relation holds

  (path) recordtype ((record{ (typeIR_a id ;)* }) as typeIR) | ((record{ (typeIR_b id ;)* }) as typeIR)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

      1. The relation holds

  (path) recorddefaulttype ((record{ (typeIR_a id ;)* ,...}) as typeIR) | ((record{ (typeIR_b id ;)* ,...}) as typeIR)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*, then

      1. The relation holds

  (path) invalidtype ((header_invalid) as typeIR) | ((header_invalid) as typeIR)

    1. The relation holds

  (path) settype ((set< [typeIR_a] >) as typeIR) | ((set< [typeIR_b] >) as typeIR)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. The relation holds

  (path) tableenumtype ((table_enum tid { id_f* }) as typeIR) | ((table_enum tid { id_f* }) as typeIR)

    1. The relation holds

  (path) tablestructtype ((table_struct tid { (typeIR_f_a id_f ;)* }) as typeIR) | ((table_struct tid { (typeIR_f_b id_f ;)* }) as typeIR)

    1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*, then

      1. The relation holds

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:9.1-11.20
relation ParameterType_alpha

  (match) (_direction typeIR_a _id _value?) | (_direction' typeIR_b _id' _value'?)

    1. Try matching path 

  (path)  (_direction typeIR_a _id _value?) | (_direction' typeIR_b _id' _value'?)

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. The relation holds

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:13.1-15.20
relation RoutineType_alpha

  (match) routineTypeIR | routineTypeIR'

    1. Case analysis on routineTypeIR

      1. Case (% has type functionTypeIR)

        1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

        2. Case analysis on functionTypeIR

          1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

            1. (Let (builtin_function( parameterTypeIR_a* )-> typeIR_ret_a) be functionTypeIR)

            2. If ((routineTypeIR' has type functionTypeIR)), then

              1. (Let functionTypeIR' be (routineTypeIR' as functionTypeIR))

              2. If ((functionTypeIR' matches pattern `BUILTIN_FUNCTION(%)->%`)), then

                1. (Let (builtin_function( parameterTypeIR_b* )-> typeIR_ret_b) be functionTypeIR')

                2. Try matching path builtinfunction

          2. Case (% matches pattern `FUNCTION(%)->%`)

            1. (Let (function( parameterTypeIR_a* )-> typeIR_ret_a) be functionTypeIR)

            2. If ((routineTypeIR' has type functionTypeIR)), then

              1. (Let functionTypeIR' be (routineTypeIR' as functionTypeIR))

              2. If ((functionTypeIR' matches pattern `FUNCTION(%)->%`)), then

                1. (Let (function( parameterTypeIR_b* )-> typeIR_ret_b) be functionTypeIR')

                2. Try matching path function

          3. Case (% matches pattern `ACTION(%)`)

            1. (Let (action( parameterTypeIR_a* )) be functionTypeIR)

            2. If ((routineTypeIR' has type functionTypeIR)), then

              1. (Let functionTypeIR' be (routineTypeIR' as functionTypeIR))

              2. If ((functionTypeIR' matches pattern `ACTION(%)`)), then

                1. (Let (action( parameterTypeIR_b* )) be functionTypeIR')

                2. Try matching path action

          4. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

            1. (Let (extern_function( parameterTypeIR_a* )-> typeIR_ret_a) be functionTypeIR)

            2. If ((routineTypeIR' has type functionTypeIR)), then

              1. (Let functionTypeIR' be (routineTypeIR' as functionTypeIR))

              2. If ((functionTypeIR' matches pattern `EXTERN_FUNCTION(%)->%`)), then

                1. (Let (extern_function( parameterTypeIR_b* )-> typeIR_ret_b) be functionTypeIR')

                2. Try matching path externfunction

      2. Case (% has type methodTypeIR)

        1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

        2. Case analysis on methodTypeIR

          1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

            1. (Let (builtin_method( parameterTypeIR_a* )-> typeIR_ret_a) be methodTypeIR)

            2. If ((routineTypeIR' has type methodTypeIR)), then

              1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

              2. If ((methodTypeIR' matches pattern `BUILTIN_METHOD(%)->%`)), then

                1. (Let (builtin_method( parameterTypeIR_b* )-> typeIR_ret_b) be methodTypeIR')

                2. Try matching path builtinmethod

          2. Case (% matches pattern `EXTERN_METHOD(%)->%`)

            1. (Let (extern_method( parameterTypeIR_a* )-> typeIR_ret_a) be methodTypeIR)

            2. If ((routineTypeIR' has type methodTypeIR)), then

              1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

              2. If ((methodTypeIR' matches pattern `EXTERN_METHOD(%)->%`)), then

                1. (Let (extern_method( parameterTypeIR_b* )-> typeIR_ret_b) be methodTypeIR')

                2. Try matching path externmethod

          3. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

            1. (Let (extern_methodabstract( parameterTypeIR_a* )-> typeIR_ret_a) be methodTypeIR)

            2. If ((routineTypeIR' has type methodTypeIR)), then

              1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

              2. If ((methodTypeIR' matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

                1. (Let (extern_methodabstract( parameterTypeIR_b* )-> typeIR_ret_b) be methodTypeIR')

                2. Try matching path externmethod-abstract

          4. Case (% matches pattern `PARSER_APPLY(%)`)

            1. (Let (parser_apply( parameterTypeIR_a* )) be methodTypeIR)

            2. If ((routineTypeIR' has type methodTypeIR)), then

              1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

              2. If ((methodTypeIR' matches pattern `PARSER_APPLY(%)`)), then

                1. (Let (parser_apply( parameterTypeIR_b* )) be methodTypeIR')

                2. Try matching path parserapply

          5. Case (% matches pattern `CONTROL_APPLY(%)`)

            1. (Let (control_apply( parameterTypeIR_a* )) be methodTypeIR)

            2. If ((routineTypeIR' has type methodTypeIR)), then

              1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

              2. If ((methodTypeIR' matches pattern `CONTROL_APPLY(%)`)), then

                1. (Let (control_apply( parameterTypeIR_b* )) be methodTypeIR')

                2. Try matching path controlapply

          6. Case (% matches pattern `TABLE_APPLY->%`)

            1. (Let (table_apply-> typeIR_ret_a) be methodTypeIR)

            2. If ((routineTypeIR' has type methodTypeIR)), then

              1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

              2. If ((methodTypeIR' matches pattern `TABLE_APPLY->%`)), then

                1. (Let (table_apply-> typeIR_ret_b) be methodTypeIR')

                2. Try matching path tableapply

  (path) builtinfunction ((builtin_function( parameterTypeIR_a* )-> typeIR_ret_a) as routineTypeIR) | ((builtin_function( parameterTypeIR_b* )-> typeIR_ret_b) as routineTypeIR)

    1. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

      1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

        1. The relation holds

  (path) function ((function( parameterTypeIR_a* )-> typeIR_ret_a) as routineTypeIR) | ((function( parameterTypeIR_b* )-> typeIR_ret_b) as routineTypeIR)

    1. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

      1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

        1. The relation holds

  (path) action ((action( parameterTypeIR_a* )) as routineTypeIR) | ((action( parameterTypeIR_b* )) as routineTypeIR)

    1. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

      1. The relation holds

  (path) externfunction ((extern_function( parameterTypeIR_a* )-> typeIR_ret_a) as routineTypeIR) | ((extern_function( parameterTypeIR_b* )-> typeIR_ret_b) as routineTypeIR)

    1. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

      1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

        1. The relation holds

  (path) builtinmethod ((builtin_method( parameterTypeIR_a* )-> typeIR_ret_a) as routineTypeIR) | ((builtin_method( parameterTypeIR_b* )-> typeIR_ret_b) as routineTypeIR)

    1. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

      1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

        1. The relation holds

  (path) externmethod ((extern_method( parameterTypeIR_a* )-> typeIR_ret_a) as routineTypeIR) | ((extern_method( parameterTypeIR_b* )-> typeIR_ret_b) as routineTypeIR)

    1. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

      1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

        1. The relation holds

  (path) externmethod-abstract ((extern_methodabstract( parameterTypeIR_a* )-> typeIR_ret_a) as routineTypeIR) | ((extern_methodabstract( parameterTypeIR_b* )-> typeIR_ret_b) as routineTypeIR)

    1. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

      1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

        1. The relation holds

  (path) parserapply ((parser_apply( parameterTypeIR_a* )) as routineTypeIR) | ((parser_apply( parameterTypeIR_b* )) as routineTypeIR)

    1. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

      1. The relation holds

  (path) controlapply ((control_apply( parameterTypeIR_a* )) as routineTypeIR) | ((control_apply( parameterTypeIR_b* )) as routineTypeIR)

    1. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*, then

      1. The relation holds

  (path) tableapply ((table_apply-> typeIR_ret_a) as routineTypeIR) | ((table_apply-> typeIR_ret_b) as routineTypeIR)

    1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

      1. The relation holds

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:17.1-19.20
relation RoutineTypeDef_alpha

  (match) routineTypeDefIR | routineTypeDefIR'

    1. Case analysis on routineTypeDefIR

      1. Case (% has type routineTypeIR)

        1. (Let routineTypeIR_a be (routineTypeDefIR as routineTypeIR))

        2. If ((routineTypeDefIR' has type routineTypeIR)), then

          1. (Let routineTypeIR_b be (routineTypeDefIR' as routineTypeIR))

          2. Try matching path mono

      2. Case (% has type polyRoutineTypeDefIR)

        1. (Let (routineTypeIR_a < tid_a* , tid_hidden_a* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

        2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

          1. (Let (routineTypeIR_b < tid_b* , tid_hidden_b* >) be (routineTypeDefIR' as polyRoutineTypeDefIR))

          2. Try matching path poly

  (path) mono (routineTypeIR_a as routineTypeDefIR) | (routineTypeIR_b as routineTypeDefIR)

    1. If ((RoutineType_alpha: routineTypeIR_a ~~ routineTypeIR_b holds)), then

      1. The relation holds

  (path) poly ((routineTypeIR_a < tid_a* , tid_hidden_a* >) as routineTypeDefIR) | ((routineTypeIR_b < tid_b* , tid_hidden_b* >) as routineTypeDefIR)

    1. If ((|tid_a*| = |tid_b*|)), then

      1. If ((|tid_hidden_a*| = |tid_hidden_b*|)), then

        1. (Let tid_fresh* be $fresh_tids((|tid_a*| + |tid_hidden_a*|)))

        2. (Let tid_a'* be tid_a* ++ tid_hidden_a*)

        3. (Let theta_a be ({ (tid_a' : ((tid tid_fresh) as typeIR))* }))

        4. (Let routineTypeIR_a_subst be $subst_routineType(theta_a, routineTypeIR_a))

        5. (Let tid_b'* be tid_b* ++ tid_hidden_b*)

        6. (Let theta_b be ({ (tid_b' : ((tid tid_fresh) as typeIR))* }))

        7. (Let routineTypeIR_b_subst be $subst_routineType(theta_b, routineTypeIR_b))

        8. If ((RoutineType_alpha: routineTypeIR_a_subst ~~ routineTypeIR_b_subst holds)), then

          1. The relation holds

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:5.14-5.30
syntax ctk = 
   | lctk
   | ctk
   | dyn

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:7.1-7.30
def $join_ctk(ctk'', ctk''')

1. (Let ctk be ctk'')

2. (Let ctk' be ctk''')

3. If ((ctk matches pattern `LCTK`)), then

  1. If ((ctk' matches pattern `LCTK`)), then

    1. Return (lctk)

4. (Let ctk be ctk'')

5. (Let ctk' be ctk''')

6. If ((ctk matches pattern `LCTK`)), then

  1. If ((ctk' matches pattern `CTK`)), then

    1. Return (ctk)

7. (Let ctk be ctk'')

8. (Let ctk' be ctk''')

9. If ((ctk matches pattern `CTK`)), then

  1. If ((ctk' matches pattern `LCTK`)), then

    1. Return (ctk)

10. (Let ctk be ctk'')

11. (Let ctk' be ctk''')

12. If ((ctk matches pattern `CTK`)), then

  1. If ((ctk' matches pattern `CTK`)), then

    1. Return (ctk)

13. (Let ctk_a be ctk'')

14. (Let ctk_b be ctk''')

15. Otherwise

  1. Return (dyn)

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:16.1-16.27
def $joins_ctk(ctk''*)

1. (Let ctk be ctk'')*

2. If ((ctk* matches pattern [])), then

  1. Return (dyn)

3. (Let ctk' be ctk'')*

4. If ((ctk'* matches pattern [ _/1 ])), then

  1. (Let [ctk] be ctk'*)

  2. Return ctk

5. (Let ctk' be ctk'')*

6. If ((ctk'* matches pattern _ :: _)), then

  1. (Let ctk_a :: ctk* be ctk'*)

  2. If ((ctk* matches pattern [ _/1 ])), then

    1. (Let [ctk_b] be ctk*)

    2. Return $join_ctk(ctk_a, ctk_b)

7. (Let ctk' be ctk'')*

8. If ((ctk'* matches pattern _ :: _)), then

  1. (Let ctk_a :: ctk* be ctk'*)

  2. If ((ctk* matches pattern _ :: _)), then

    1. (Let ctk_b :: ctk_c* be ctk*)

    2. (Let ctk_d be $join_ctk(ctk_a, ctk_b))

    3. Return $joins_ctk(ctk_d :: ctk_c*)

;; ../../../../spec-concrete/3-numerics.watsup:5.1-5.21
def $pow2



;; ../../../../spec-concrete/3-numerics.watsup:7.1-7.25
def $shl



;; ../../../../spec-concrete/3-numerics.watsup:8.1-8.25
def $shr



;; ../../../../spec-concrete/3-numerics.watsup:9.1-9.36
def $shr_arith



;; ../../../../spec-concrete/3-numerics.watsup:11.1-11.21
def $bneg



;; ../../../../spec-concrete/3-numerics.watsup:12.1-12.26
def $band



;; ../../../../spec-concrete/3-numerics.watsup:13.1-13.26
def $bxor



;; ../../../../spec-concrete/3-numerics.watsup:14.1-14.25
def $bor



;; ../../../../spec-concrete/3-numerics.watsup:16.1-16.33
def $bitacc



;; ../../../../spec-concrete/3-numerics.watsup:24.1-24.28
def $un_bnot(value)

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `%W%`)), then

    1. (Let (w w i) be numberLiteral)

    2. (Let i' be $bneg(i))

    3. Return ((w w i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:31.1-31.28
def $un_lnot(value)

1. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `B%`)), then

    1. (Let (b b) be primitiveValue)

    2. Return ((b ~b) as value)

;; ../../../../spec-concrete/3-numerics.watsup:37.1-37.28
def $un_plus(value)

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i) be numberLiteral)

      2. Return ((d i) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i) be numberLiteral)

      2. Return ((w w i) as value)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i) be numberLiteral)

      2. Return ((w s i) as value)

;; ../../../../spec-concrete/3-numerics.watsup:45.1-45.29
def $un_minus(value)

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i) be numberLiteral)

      2. Return ((d -i) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i) be numberLiteral)

      2. (Let i' be ($pow2(w) - i))

      3. Return ((w w i') as value)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i) be numberLiteral)

      2. (Let i' be $to_bitstr((w as int), $to_int((w as int), -i)))

      3. Return ((w s i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:59.1-59.36
def $bin_plus(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `D%`)), then

          1. (Let (d i_r) be numberLiteral')

          2. Return ((d (i_l + i_r)) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), (i_l' + i_r')))

            4. Return ((w w i') as value)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), (i_l' + i_r')))

            4. Return ((w s i') as value)

            5. (Let i' be $to_bitstr((w as int), (i_l' - i_r')))

            6. Return ((w s i') as value)

            7. (Let i' be $to_bitstr((w as int), (i_l' * i_r')))

            8. Return ((w s i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:73.1-73.39
def $bin_satplus



;; ../../../../spec-concrete/3-numerics.watsup:77.1-77.37
def $bin_minus(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `D%`)), then

          1. (Let (d i_r) be numberLiteral')

          2. Return ((d (i_l - i_r)) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), (i_l' - i_r')))

            4. Return ((w w i') as value)

            5. (Let i' be $to_bitstr((w as int), (i_l' * i_r')))

            6. Return ((w w i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:91.1-91.40
def $bin_satminus



;; ../../../../spec-concrete/3-numerics.watsup:95.1-95.35
def $bin_mul(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `D%`)), then

    1. (Let (d i_l) be numberLiteral)

    2. If ((value' has type numberLiteral)), then

      1. (Let numberLiteral' be (value' as numberLiteral))

      2. If ((numberLiteral' matches pattern `D%`)), then

        1. (Let (d i_r) be numberLiteral')

        2. Return ((d (i_l * i_r)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:109.1-109.35
def $bin_div(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `D%`)), then

    1. (Let (d i_l) be numberLiteral)

    2. If ((value' has type numberLiteral)), then

      1. (Let numberLiteral' be (value' as numberLiteral))

      2. If ((numberLiteral' matches pattern `D%`)), then

        1. (Let (d i_r) be numberLiteral')

        2. Return ((d (i_l / i_r)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:115.1-115.35
def $bin_mod(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `D%`)), then

    1. (Let (d i_l) be numberLiteral)

    2. If ((value' has type numberLiteral)), then

      1. (Let numberLiteral' be (value' as numberLiteral))

      2. If ((numberLiteral' matches pattern `D%`)), then

        1. (Let (d i_r) be numberLiteral')

        2. Return ((d (i_l \ i_r)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:121.1-121.35
def $bin_shl(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be numberLiteral')

            2. Return ((d $shl(i_l, i_r)) as value)

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. Return ((d $shl(i_l, i_r)) as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. Return ((d $shl(i_l, i_r')) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w_l w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be numberLiteral')

            2. Return $bin_shl(((w_l w i_l) as value), ((w_l w $to_int((w_l as int), i_r)) as value))

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. (Let i' be $to_bitstr((w_l as int), $shl(i_l, i_r)))

            3. Return ((w_l w i') as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. (Let i' be $to_bitstr((w_l as int), $shl(i_l, i_r')))

            4. Return ((w_l w i') as value)

    3. Case (% matches pattern `%S%`)

      1. (Let (w_l s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be numberLiteral')

            2. Return $bin_shl(((w_l s i_l) as value), ((w_l s $to_int((w_l as int), i_r)) as value))

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i' be $to_bitstr((w_l as int), $shl(i_l', i_r)))

            4. Return ((w_l s i') as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_r' be $to_int((w_r as int), i_r))

            4. (Let i' be $to_bitstr((w_l as int), $shl(i_l', i_r')))

            5. Return ((w_l s i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:148.1-148.35
def $bin_shr(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be numberLiteral')

            2. Return ((d $shr(i_l, i_r)) as value)

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. Return ((d $shr(i_l, i_r)) as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. Return ((d $shr(i_l, i_r')) as value)

    2. Case (% matches pattern `%W%`)

      1. (Let (w_l w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be numberLiteral')

            2. Return $bin_shr(((w_l w i_l) as value), ((w_l w $to_int((w_l as int), i_r)) as value))

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. (Let i' be $to_bitstr((w_l as int), $shr(i_l, i_r)))

            3. Return ((w_l w i') as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. (Let i' be $to_bitstr((w_l as int), $shr(i_l, i_r')))

            4. Return ((w_l w i') as value)

    3. Case (% matches pattern `%S%`)

      1. (Let (w_l s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `D%`)

            1. (Let (d i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. If ((i_l' < (0 as int))), then

              1. (Let i' be $shr_arith(i_l, i_r, ($pow2(w_l) - (1 as int))))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

            4. If ((i_l' >= (0 as int))), then

              1. (Let i' be $shr(i_l, i_r))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

          2. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. If ((i_l' < (0 as int))), then

              1. (Let i' be $shr_arith(i_l, i_r, ($pow2(w_l) - (1 as int))))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

            4. If ((i_l' >= (0 as int))), then

              1. (Let i' be $shr(i_l, i_r))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

          3. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_r' be $to_int((w_r as int), i_r))

            4. If ((i_l' < (0 as int))), then

              1. (Let i' be $shr_arith(i_l, i_r, ($pow2(w_l) - (1 as int))))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

            5. If ((i_l' >= (0 as int))), then

              1. (Let i' be $shr(i_l, i_r))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((w_l s i'') as value)

;; ../../../../spec-concrete/3-numerics.watsup:198.1-198.33
def $bin_le(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `D%`)), then

          1. (Let (d i_r) be numberLiteral')

          2. Return (i_l <= i_r)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. Return (i_l <= i_r)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' <= i_r')

;; ../../../../spec-concrete/3-numerics.watsup:208.1-208.33
def $bin_ge(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `D%`)), then

          1. (Let (d i_r) be numberLiteral')

          2. Return (i_l >= i_r)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. Return (i_l >= i_r)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' >= i_r')

;; ../../../../spec-concrete/3-numerics.watsup:218.1-218.33
def $bin_lt(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `D%`)), then

          1. (Let (d i_r) be numberLiteral')

          2. Return (i_l < i_r)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. Return (i_l < i_r)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' < i_r')

;; ../../../../spec-concrete/3-numerics.watsup:228.1-228.33
def $bin_gt(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `D%`)

      1. (Let (d i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `D%`)), then

          1. (Let (d i_r) be numberLiteral')

          2. Return (i_l > i_r)

    2. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. Return (i_l > i_r)

    3. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' > i_r')

;; ../../../../spec-concrete/3-numerics.watsup:238.1-238.33
def $bin_eq(value, value')

1. Case analysis on value

  1. Case (% has type primitiveValue)

    1. (Let primitiveValue_a be (value as primitiveValue))

    2. If ((value' has type primitiveValue)), then

      1. (Let primitiveValue_b be (value' as primitiveValue))

      2. Return (primitiveValue_a = primitiveValue_b)

  2. Case (% has type numberLiteral)

    1. (Let numberLiteral be (value as numberLiteral))

    2. Case analysis on numberLiteral

      1. Case (% matches pattern `D%`)

        1. (Let (d i_a) be numberLiteral)

        2. If ((value' has type numberLiteral)), then

          1. (Let numberLiteral' be (value' as numberLiteral))

          2. If ((numberLiteral' matches pattern `D%`)), then

            1. (Let (d i_b) be numberLiteral')

            2. Return (i_a = i_b)

      2. Case (% matches pattern `%W%`)

        1. (Let (w_a w i_a) be numberLiteral)

        2. If ((value' has type numberLiteral)), then

          1. (Let numberLiteral' be (value' as numberLiteral))

          2. If ((numberLiteral' matches pattern `%W%`)), then

            1. (Let (w_b w i_b) be numberLiteral')

            2. Return ((w_a = w_b) /\ (i_a = i_b))

      3. Case (% matches pattern `%S%`)

        1. (Let (w_a s i_a) be numberLiteral)

        2. If ((value' has type numberLiteral)), then

          1. (Let numberLiteral' be (value' as numberLiteral))

          2. If ((numberLiteral' matches pattern `%S%`)), then

            1. (Let (w_b s i_b) be numberLiteral')

            2. Return ((w_a = w_b) /\ (i_a = i_b))

  3. Case (% has type listValue)

    1. (Let ([ value_a* ]) be (value as listValue))

    2. If ((value' has type listValue)), then

      1. (Let ([ value_b* ]) be (value' as listValue))

      2. Return $bin_eqs(value_a*, value_b*)

  4. Case (% has type tupleValue)

    1. (Let (( value_a* )) be (value as tupleValue))

    2. If ((value' has type tupleValue)), then

      1. (Let (( value_b* )) be (value' as tupleValue))

      2. Return $bin_eqs(value_a*, value_b*)

  5. Case (% has type headerStackValue)

    1. (Let ([ value_a* #( _nat ; n_s_a )]) be (value as headerStackValue))

    2. If ((value' has type headerStackValue)), then

      1. (Let ([ value_b* #( _nat' ; n_s_b )]) be (value' as headerStackValue))

      2. Return ($bin_eqs(value_a*, value_b*) /\ (n_s_a = n_s_b))

  6. Case (% has type structValue)

    1. (Let (struct tid_a { (value_f_a id_f_a ;)* }) be (value as structValue))

    2. If ((value' has type structValue)), then

      1. (Let (struct tid_b { (value_f_b id_f_b ;)* }) be (value' as structValue))

      2. Return ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*, (value_f_b, id_f_b)*))

  7. Case (% has type headerValue)

    1. (Let (header tid_a { (value_f_a id_f_a ;)* }) be (value as headerValue))

    2. If ((value' has type headerValue)), then

      1. (Let (header tid_b { (value_f_b id_f_b ;)* }) be (value' as headerValue))

      2. Return ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*, (value_f_b, id_f_b)*))

  8. Case (% has type headerUnionValue)

    1. (Let (header_union tid_a { (value_f_a id_f_a ;)* }) be (value as headerUnionValue))

    2. If ((value' has type headerUnionValue)), then

      1. (Let (header_union tid_b { (value_f_b id_f_b ;)* }) be (value' as headerUnionValue))

      2. Return ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*, (value_f_b, id_f_b)*))

  9. Case (% has type enumValue)

    1. (Let enumValue be (value as enumValue))

    2. Case analysis on enumValue

      1. Case (% matches pattern `%.%`)

        1. (Let (tid_a . id_f_a) be enumValue)

        2. If ((value' has type enumValue)), then

          1. (Let enumValue' be (value' as enumValue))

          2. If ((enumValue' matches pattern `%.%`)), then

            1. (Let (tid_b . id_f_b) be enumValue')

            2. Return ((tid_a = tid_b) /\ (id_f_a = id_f_b))

      2. Case (% matches pattern `%.%#%`)

        1. (Let (tid_a . id_f_a # value_f_a) be enumValue)

        2. If ((value' has type enumValue)), then

          1. (Let enumValue' be (value' as enumValue))

          2. If ((enumValue' matches pattern `%.%#%`)), then

            1. (Let (tid_b . id_f_b # value_f_b) be enumValue')

            2. Return (((tid_a = tid_b) /\ (id_f_a = id_f_b)) /\ $bin_eq(value_f_a, value_f_b))

2. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. If ((numberValue matches pattern `%V%#%`)), then

    1. (Let (w_a v i_a # _nat) be numberValue)

    2. If ((value' has type numberValue)), then

      1. (Let numberValue' be (value' as numberValue))

      2. If ((numberValue' matches pattern `%V%#%`)), then

        1. (Let (w_b v i_b # _nat') be numberValue')

        2. Return ((w_a = w_b) /\ (i_a = i_b))

3. If ((value = (({#}) as value))), then

  1. If ((value' = (({#}) as value))), then

    1. Return true

;; ../../../../spec-concrete/3-numerics.watsup:239.1-239.36
def $bin_eqs(value*, value'*)

1. Case analysis on value*

  1. Case (% matches pattern [])

    1. Case analysis on value'*

      1. Case (% matches pattern [])

        1. Return true

      2. Case (% matches pattern _ :: _)

        1. (Let _value :: _value'* be value'*)

        2. Return false

  2. Case (% matches pattern _ :: _)

    1. (Let _value :: _value'* be value*)

    2. If ((value'* matches pattern [])), then

      1. Return false

    3. (Let value_a_h :: value_a_t* be value*)

    4. If ((value'* matches pattern _ :: _)), then

      1. (Let value_b_h :: value_b_t* be value'*)

      2. Return ($bin_eq(value_a_h, value_b_h) /\ $bin_eqs(value_a_t*, value_b_t*))

;; ../../../../spec-concrete/3-numerics.watsup:240.1-240.55
def $bin_eqs_fields((value, id)*, (value, id)'*)

1. Case analysis on (value, id)*

  1. Case (% matches pattern [])

    1. Case analysis on (value, id)'*

      1. Case (% matches pattern [])

        1. Return true

      2. Case (% matches pattern _ :: _)

        1. (Let _(value, id) :: _(value, id)'* be (value, id)'*)

        2. Return false

  2. Case (% matches pattern _ :: _)

    1. (Let _(value, id) :: _(value, id)'* be (value, id)*)

    2. If (((value, id)'* matches pattern [])), then

      1. Return false

    3. (Let (value_a_h, id_a_h) :: (value_a_t, id_a_t)* be (value, id)*)

    4. If (((value, id)'* matches pattern _ :: _)), then

      1. (Let (value_b_h, id_b_h) :: (value_b_t, id_b_t)* be (value, id)'*)

      2. Return (((id_a_h = id_b_h) /\ $bin_eq(value_a_h, value_b_h)) /\ $bin_eqs_fields((value_a_t, id_a_t)*, (value_b_t, id_b_t)*))

;; ../../../../spec-concrete/3-numerics.watsup:297.1-297.33
def $bin_ne(value_l, value_r)

1. Return ~$bin_eq(value_l, value_r)

;; ../../../../spec-concrete/3-numerics.watsup:303.1-303.36
def $bin_band(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i' be $to_bitstr((w as int), $band(i_l, i_r)))

            2. Return ((w w i') as value)

    2. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), $band(i_l', i_r')))

            4. Return ((w s i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:315.1-315.36
def $bin_bxor(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i' be $to_bitstr((w as int), $bxor(i_l, i_r)))

            2. Return ((w w i') as value)

    2. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), $bxor(i_l', i_r')))

            4. Return ((w s i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:327.1-327.35
def $bin_bor(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `%W%`)

      1. (Let (w w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%W%`)), then

          1. (Let (w' w i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i' be $to_bitstr((w as int), $bor(i_l, i_r)))

            2. Return ((w w i') as value)

    2. Case (% matches pattern `%S%`)

      1. (Let (w s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. If ((numberLiteral' matches pattern `%S%`)), then

          1. (Let (w' s i_r) be numberLiteral')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), $bor(i_l', i_r')))

            4. Return ((w s i') as value)

;; ../../../../spec-concrete/3-numerics.watsup:339.1-339.38
def $bin_concat(value, value')

1. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. Case analysis on numberLiteral

    1. Case (% matches pattern `%W%`)

      1. (Let (w_l w i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. (Let i_l' be $shl(i_l, (w_r as int)))

            3. (Let i_l'' be (i_l' + i_r))

            4. (Let w be (w_l + w_r))

            5. (Let i'' be $to_bitstr((w as int), i_l''))

            6. Return ((w w i'') as value)

          2. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_l' be $shl(i_l, (w_r as int)))

            3. (Let i_l'' be (i_l' + i_r))

            4. (Let w be (w_l + w_r))

            5. (Let i'' be $to_bitstr((w as int), i_l''))

            6. Return ((w w i'') as value)

    2. Case (% matches pattern `%S%`)

      1. (Let (w_l s i_l) be numberLiteral)

      2. If ((value' has type numberLiteral)), then

        1. (Let numberLiteral' be (value' as numberLiteral))

        2. Case analysis on numberLiteral'

          1. Case (% matches pattern `%W%`)

            1. (Let (w_r w i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_l'' be $shl(i_l', (w_r as int)))

            4. (Let i_l''' be (i_l'' + i_r))

            5. (Let w be (w_l + w_r))

            6. (Let i''' be $to_bitstr((w as int), i_l'''))

            7. Return ((w s i''') as value)

          2. Case (% matches pattern `%S%`)

            1. (Let (w_r s i_r) be numberLiteral')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_l'' be $shl(i_l', (w_r as int)))

            4. (Let i_l''' be (i_l'' + i_r))

            5. (Let w be (w_l + w_r))

            6. (Let i''' be $to_bitstr((w as int), i_l'''))

            7. Return ((w s i''') as value)

;; ../../../../spec-concrete/3-numerics.watsup:367.1-367.36
def $bin_land(value, value')

1. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `B%`)), then

    1. (Let (b b_l) be primitiveValue)

    2. If ((value' has type primitiveValue)), then

      1. (Let primitiveValue' be (value' as primitiveValue))

      2. If ((primitiveValue' matches pattern `B%`)), then

        1. (Let (b b_r) be primitiveValue')

        2. Return ((b (b_l /\ b_r)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:373.1-373.35
def $bin_lor(value, value')

1. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `B%`)), then

    1. (Let (b b_l) be primitiveValue)

    2. If ((value' has type primitiveValue)), then

      1. (Let primitiveValue' be (value' as primitiveValue))

      2. If ((primitiveValue' matches pattern `B%`)), then

        1. (Let (b b_r) be primitiveValue')

        2. Return ((b (b_l \/ b_r)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:381.1-381.36
def $cast_op(typeIR, value'')

1. (Let value be value'')

2. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `B%`)), then

    1. (Let (b b) be primitiveValue)

    2. Return $cast_bool(typeIR, b)

3. (Let value be value'')

4. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `D%`)), then

    1. (Let (d i) be numberLiteral)

    2. Return $cast_arbint(typeIR, i)

5. (Let value be value'')

6. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `%W%`)), then

    1. (Let (w w i) be numberLiteral)

    2. Return $cast_fixbit(typeIR, w, i)

7. (Let value be value'')

8. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `%S%`)), then

    1. (Let (w s i) be numberLiteral)

    2. Return $cast_fixint(typeIR, w, i)

9. (Let value be value'')

10. If ((value has type structValue)), then

  1. (Let (struct tid { (value_f id_f ;)* }) be (value as structValue))

  2. Return $cast_struct(typeIR, tid, (value_f, id_f)*)

11. (Let value be value'')

12. If ((value has type headerValue)), then

  1. (Let (header tid { (value_f id_f ;)* }) be (value as headerValue))

  2. Return $cast_header(typeIR, tid, (value_f, id_f)*)

13. (Let value' be value'')

14. If ((value' has type enumValue)), then

  1. (Let enumValue be (value' as enumValue))

  2. If ((enumValue matches pattern `%.%#%`)), then

    1. (Let (_tid . _id # value) be enumValue)

    2. Return $cast_op(typeIR, value)

15. (Let value' be value'')

16. If ((value' has type sequenceValue)), then

  1. (Let sequenceValue be (value' as sequenceValue))

  2. If ((sequenceValue matches pattern `SEQ(%)`)), then

    1. (Let (seq( value* )) be sequenceValue)

    2. Return $cast_sequence(typeIR, value*)

17. (Let value' be value'')

18. If ((value' has type recordValue)), then

  1. (Let recordValue be (value' as recordValue))

  2. If ((recordValue matches pattern `RECORD{%}`)), then

    1. (Let (record{ (value id ;)* }) be recordValue)

    2. Return $cast_record(typeIR, (value, id)*)

19. (Let value be value'')

20. If ((value = ((default) as value))), then

  1. Return $default(typeIR)

21. (Let value' be value'')

22. If ((value' has type setValue)), then

  1. (Let setValue be (value' as setValue))

  2. If ((setValue matches pattern `SET{%}`)), then

    1. (Let (set{ value }) be setValue)

    2. Return $cast_set_singleton(typeIR, value)

23. (Let value be value'')

24. If ((value has type setValue)), then

  1. (Let setValue be (value as setValue))

  2. If ((setValue matches pattern `SET{%&&&%}`)), then

    1. (Let (set{ value_b &&& value_m }) be setValue)

    2. Return $cast_set_mask(typeIR, value_b, value_m)

25. (Let value be value'')

26. If ((value has type setValue)), then

  1. (Let setValue be (value as setValue))

  2. If ((setValue matches pattern `SET{%..%}`)), then

    1. (Let (set{ value_l .. value_u }) be setValue)

    2. Return $cast_set_range(typeIR, value_l, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:383.1-383.29
def $default(typeIR)

1. Return $default'($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:384.1-384.30
def $default'(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return ((b false) as value)

3. (Let typeIR be typeIR'')

4. If ((typeIR = ((error) as typeIR))), then

  1. Return ((error. "NoError") as value)

5. (Let typeIR be typeIR'')

6. If ((typeIR = ((string) as typeIR))), then

  1. (Let text_empty be "")

  2. Return ((" text_empty ") as value)

7. (Let typeIR be typeIR'')

8. If ((typeIR = ((int) as typeIR))), then

  1. Return ((d (0 as int)) as value)

9. (Let typeIR be typeIR'')

10. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. Return ((w w (0 as int)) as value)

11. (Let typeIR be typeIR'')

12. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w >) be numberTypeIR)

    2. Return ((w s (0 as int)) as value)

13. (Let typeIR be typeIR'')

14. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `VARBIT<%>`)), then

    1. (Let (varbit< w >) be numberTypeIR)

    2. Return ((w v (0 as int) # 0) as value)

15. (Let typeIR' be typeIR'')

16. If ((typeIR' has type tupleTypeIR)), then

  1. (Let (tuple< typeIR* >) be (typeIR' as tupleTypeIR))

  2. Return (([ $default(typeIR)* ]) as value)

17. (Let typeIR' be typeIR'')

18. If ((typeIR' has type headerStackTypeIR)), then

  1. (Let (typeIR [ n_s ]) be (typeIR' as headerStackTypeIR))

  2. (Let value* be $repeat_<value>($default(typeIR), n_s))

  3. Return (([ value* #( 0 ; n_s )]) as value)

19. (Let typeIR be typeIR'')

20. If ((typeIR has type structTypeIR)), then

  1. (Let (struct tid { (typeIR_f id_f ;)* }) be (typeIR as structTypeIR))

  2. Return ((struct tid { ($default(typeIR_f) id_f ;)* }) as value)

21. (Let typeIR be typeIR'')

22. If ((typeIR has type headerTypeIR)), then

  1. (Let (header tid { (typeIR_f id_f ;)* }) be (typeIR as headerTypeIR))

  2. Return ((header tid { ($default(typeIR_f) id_f ;)* }) as value)

23. (Let typeIR be typeIR'')

24. If ((typeIR has type headerUnionTypeIR)), then

  1. (Let (header_union tid { (typeIR_f id_f ;)* }) be (typeIR as headerUnionTypeIR))

  2. Return ((header_union tid { ($default(typeIR_f) id_f ;)* }) as value)

25. (Let typeIR be typeIR'')

26. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

    1. (Let (enum tid { id* }) be enumTypeIR)

    2. If ((id* matches pattern _ :: _)), then

      1. (Let id_f_h :: _id* be id*)

      2. Return ((tid . id_f_h) as value)

27. (Let typeIR' be typeIR'')

28. If ((typeIR' has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR' as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum tid # typeIR { (id_f = value_f ;)* }) be enumTypeIR)

    2. (Let value_zero be $cast_arbint(typeIR, (0 as int)))

    3. (Let id? be $assoc_<value, id>(value_zero, (value_f, id_f)*))

    4. If ((id? matches pattern (_))), then

      1. (Let ?(id_zero) be id?)

      2. Return ((tid . id_zero # value_zero) as value)

29. (Let typeIR' be typeIR'')

30. If ((typeIR' has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR' as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum tid # typeIR { (id_f = value_f ;)* }) be enumTypeIR)

    2. (Let value_zero be $cast_arbint(typeIR, (0 as int)))

    3. If ((?() = $assoc_<value, id>(value_zero, (value_f, id_f)*))), then

      1. (Let id_zero be "__UNSPECIFIED")

      2. Return ((tid . id_zero # value_zero) as value)

;; ../../../../spec-concrete/3-numerics.watsup:388.1-388.37
def $cast_bool(typeIR, b)

1. Return $cast_bool'($canon(typeIR), b)

;; ../../../../spec-concrete/3-numerics.watsup:389.1-389.38
def $cast_bool'(typeIR'', b')

1. (Let typeIR be typeIR'')

2. (Let b be b')

3. If ((typeIR = ((bool) as typeIR))), then

  1. Return ((b b) as value)

4. (Let typeIR be typeIR'')

5. (Let bool be b')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. If ((bool = true)), then

      1. Return ((w w (1 as int)) as value)

7. (Let typeIR be typeIR'')

8. (Let bool be b')

9. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. If ((bool = false)), then

      1. Return ((w w (0 as int)) as value)

10. (Let typeIR' be typeIR'')

11. (Let b be b')

12. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid typeIR) be aliasTypeIR)

    2. Return $cast_bool(typeIR, b)

;; ../../../../spec-concrete/3-numerics.watsup:402.1-402.38
def $cast_arbint(typeIR, i)

1. Return $cast_arbint'($canon(typeIR), i)

;; ../../../../spec-concrete/3-numerics.watsup:403.1-403.39
def $cast_arbint'(typeIR''', i)

1. (Let typeIR be typeIR''')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return ((b (i = (0 as int))) as value)

3. (Let typeIR be typeIR''')

4. If ((typeIR = ((int) as typeIR))), then

  1. Return ((d i) as value)

5. (Let typeIR be typeIR''')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. Return ((w w $to_bitstr((w as int), i)) as value)

7. (Let typeIR be typeIR''')

8. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w >) be numberTypeIR)

    2. Return ((w s $to_bitstr((w as int), i)) as value)

9. (Let typeIR' be typeIR''')

10. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid typeIR) be aliasTypeIR)

    2. Return $cast_arbint(typeIR, i)

11. (Let typeIR'' be typeIR''')

12. If ((typeIR'' has type setTypeIR)), then

  1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

  2. If ((typeIR'* matches pattern [ _/1 ])), then

    1. (Let [typeIR] be typeIR'*)

    2. Return ((set{ $cast_arbint(typeIR, i) }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:418.1-418.43
def $cast_fixbit(typeIR, w, i)

1. Return $cast_fixbit'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:419.1-419.44
def $cast_fixbit'(typeIR''', w', i)

1. (Let typeIR be typeIR''')

2. (Let w be w')

3. If ((typeIR = ((bool) as typeIR))), then

  1. Return ((b (i = (1 as int))) as value)

4. (Let typeIR be typeIR''')

5. (Let _nat be w')

6. If ((typeIR = ((int) as typeIR))), then

  1. Return ((d i) as value)

7. (Let typeIR be typeIR''')

8. (Let _nat be w')

9. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w_to >) be numberTypeIR)

    2. (Let i' be $to_bitstr((w_to as int), i))

    3. Return ((w_to w i') as value)

10. (Let typeIR be typeIR''')

11. (Let _nat be w')

12. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w_to >) be numberTypeIR)

    2. (Let i' be $to_bitstr((w_to as int), i))

    3. Return ((w_to s i') as value)

13. (Let typeIR' be typeIR''')

14. (Let w be w')

15. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid typeIR) be aliasTypeIR)

    2. Return $cast_fixbit(typeIR, w, i)

16. (Let typeIR'' be typeIR''')

17. (Let w be w')

18. If ((typeIR'' has type setTypeIR)), then

  1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

  2. If ((typeIR'* matches pattern [ _/1 ])), then

    1. (Let [typeIR] be typeIR'*)

    2. Return ((set{ $cast_fixbit(typeIR, w, i) }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:436.1-436.43
def $cast_fixint(typeIR, w, i)

1. Return $cast_fixint'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:437.1-437.44
def $cast_fixint'(typeIR''', w', i)

1. (Let typeIR be typeIR''')

2. (Let w be w')

3. If ((typeIR = ((int) as typeIR))), then

  1. Return ((d $to_int((w as int), i)) as value)

4. (Let typeIR be typeIR''')

5. (Let w_from be w')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w_to >) be numberTypeIR)

    2. (Let i' be $to_bitstr((w_to as int), $to_int((w_from as int), i)))

    3. Return ((w_to w i') as value)

7. (Let typeIR be typeIR''')

8. (Let w_from be w')

9. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w_to >) be numberTypeIR)

    2. (Let i' be $to_bitstr((w_to as int), $to_int((w_from as int), i)))

    3. Return ((w_to s i') as value)

10. (Let typeIR' be typeIR''')

11. (Let w be w')

12. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid typeIR) be aliasTypeIR)

    2. Return $cast_fixint(typeIR, w, i)

13. (Let typeIR'' be typeIR''')

14. (Let w be w')

15. If ((typeIR'' has type setTypeIR)), then

  1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

  2. If ((typeIR'* matches pattern [ _/1 ])), then

    1. (Let [typeIR] be typeIR'*)

    2. Return ((set{ $cast_fixint(typeIR, w, i) }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:453.1-453.52
def $cast_struct(typeIR, tid, (value_f, id_f)*)

1. Return $cast_struct'($canon(typeIR), tid, (value_f, id_f)*)

;; ../../../../spec-concrete/3-numerics.watsup:454.1-454.53
def $cast_struct'(typeIR, tid', (value_f, id_f)*)

1. If ((typeIR has type structTypeIR)), then

  1. (Let (struct tid { _fieldTypeIR* }) be (typeIR as structTypeIR))

  2. If ((tid = tid')), then

    1. Return ((struct tid { (value_f id_f ;)* }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:467.1-467.52
def $cast_header(typeIR, tid, (value_f, id_f)*)

1. Return $cast_header'($canon(typeIR), tid, (value_f, id_f)*)

;; ../../../../spec-concrete/3-numerics.watsup:468.1-468.53
def $cast_header'(typeIR, tid', (value_f, id_f)*)

1. If ((typeIR has type headerTypeIR)), then

  1. (Let (header tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

  2. If ((tid = tid')), then

    1. Return ((header tid { (value_f id_f ;)* }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:485.1-485.43
def $cast_sequence(typeIR, value*)

1. Return $cast_sequence'($canon(typeIR), value*)

;; ../../../../spec-concrete/3-numerics.watsup:486.1-486.44
def $cast_sequence'(typeIR'', value*)

1. (Let typeIR' be typeIR'')

2. If ((typeIR' has type listTypeIR)), then

  1. (Let (list< typeIR >) be (typeIR' as listTypeIR))

  2. Return (([ $cast_op(typeIR, value)* ]) as value)

3. (Let typeIR' be typeIR'')

4. If ((typeIR' has type tupleTypeIR)), then

  1. (Let (tuple< typeIR* >) be (typeIR' as tupleTypeIR))

  2. Return ((( $cast_op(typeIR, value)* )) as value)

5. (Let typeIR' be typeIR'')

6. If ((typeIR' has type headerStackTypeIR)), then

  1. (Let (typeIR [ n_s ]) be (typeIR' as headerStackTypeIR))

  2. (Let value_cast be $cast_op(typeIR, value))*

  3. (Let n_idx be |value*|)

  4. Return (([ value_cast* #( n_idx ; n_s )]) as value)

7. (Let typeIR be typeIR'')

8. If ((typeIR has type structTypeIR)), then

  1. (Let (struct tid { (typeIR_f id_f ;)* }) be (typeIR as structTypeIR))

  2. (Let value_cast be $cast_op(typeIR_f, value))*

  3. Return ((struct tid { (value_cast id_f ;)* }) as value)

9. (Let typeIR be typeIR'')

10. If ((typeIR has type headerTypeIR)), then

  1. (Let (header tid { (typeIR_f id_f ;)* }) be (typeIR as headerTypeIR))

  2. (Let value_cast be $cast_op(typeIR_f, value))*

  3. Return ((header tid { (value_cast id_f ;)* }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:516.1-516.47
def $cast_record(typeIR, (value, id)*)

1. Return $cast_record'($canon(typeIR), (value, id)*)

;; ../../../../spec-concrete/3-numerics.watsup:517.1-517.48
def $cast_record'(typeIR, (value_f, id_f)*)

1. Case analysis on typeIR

  1. Case (% has type structTypeIR)

    1. (Let (struct tid { (typeIR_t_f id_t_f ;)* }) be (typeIR as structTypeIR))

    2. (Let value? be $find_map<id, value>(({ (id_f : value_f)* }), id_t_f))*

    3. If ((value? matches pattern (_)))*, then

      1. (Let ?(value_f') be value?)*

      2. (Let value_f_cast be $cast_op(typeIR_t_f, value_f'))*

      3. Return ((struct tid { (value_f_cast id_f ;)* }) as value)

  2. Case (% has type headerTypeIR)

    1. (Let (header tid { (typeIR_t_f id_t_f ;)* }) be (typeIR as headerTypeIR))

    2. (Let value? be $find_map<id, value>(({ (id_f : value_f)* }), id_t_f))*

    3. If ((value? matches pattern (_)))*, then

      1. (Let ?(value_f') be value?)*

      2. (Let value_f_cast be $cast_op(typeIR_t_f, value_f'))*

      3. Return ((header tid { (value_f_cast id_f ;)* }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:551.1-551.47
def $cast_set_singleton(typeIR, value)

1. Return $cast_set_singleton'($canon(typeIR), value)

;; ../../../../spec-concrete/3-numerics.watsup:552.1-552.48
def $cast_set_singleton'(typeIR'', value)

1. If ((typeIR'' has type setTypeIR)), then

  1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

  2. If ((typeIR'* matches pattern [ _/1 ])), then

    1. (Let [typeIR] be typeIR'*)

    2. Return ((set{ $cast_op(typeIR, value) }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:560.1-560.49
def $cast_set_mask(typeIR, value_b, value_m)

1. Return $cast_set_mask'($canon(typeIR), value_b, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:561.1-561.50
def $cast_set_mask'(typeIR'', value_b, value_m)

1. If ((typeIR'' has type setTypeIR)), then

  1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

  2. If ((typeIR'* matches pattern [ _/1 ])), then

    1. (Let [typeIR] be typeIR'*)

    2. (Let value_b_cast be $cast_op(typeIR, value_b))

    3. (Let value_m_cast be $cast_op(typeIR, value_m))

    4. Return ((set{ value_b_cast &&& value_m_cast }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:571.1-571.50
def $cast_set_range(typeIR, value_l, value_u)

1. Return $cast_set_range'($canon(typeIR), value_l, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:572.1-572.51
def $cast_set_range'(typeIR'', value_l, value_u)

1. If ((typeIR'' has type setTypeIR)), then

  1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

  2. If ((typeIR'* matches pattern [ _/1 ])), then

    1. (Let [typeIR] be typeIR'*)

    2. (Let value_l_cast be $cast_op(typeIR, value_l))

    3. (Let value_u_cast be $cast_op(typeIR, value_u))

    4. Return ((set{ value_l_cast .. value_u_cast }) as value)

;; ../../../../spec-concrete/3-numerics.watsup:637.1-637.44
def $bitacc_op(value_b, value_h, value_l)

1. (Let i_b be $to_number(value_b))

2. (Let i_h be $to_number(value_h))

3. (Let i_l be $to_number(value_l))

4. (Let int be ((i_h + (1 as int)) - i_l))

5. If ((int has type nat)), then

  1. (Let w be (int as nat))

  2. (Let i be $bitacc(i_b, i_h, i_l))

  3. Return ((w w i) as value)

;; ../../../../spec-concrete/3-numerics.watsup:650.1-650.32
def $sizeof(typeIR, text)

1. Case analysis on text

  1. Case (% = "minSizeInBits")

    1. Return $sizeof_minSizeInBits(typeIR)

  2. Case (% = "minSizeInBytes")

    1. Return $sizeof_minSizeInBytes(typeIR)

  3. Case (% = "maxSizeInBits")

    1. Return $sizeof_maxSizeInBits(typeIR)

  4. Case (% = "maxSizeInBytes")

    1. Return $sizeof_maxSizeInBytes(typeIR)

;; ../../../../spec-concrete/3-numerics.watsup:652.1-652.42
def $sizeof_minSizeInBits(typeIR)

1. Return ((d ($sizeof_minSizeInBits'(typeIR) as int)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:653.1-653.41
def $sizeof_minSizeInBits'(typeIR)

1. Return $sizeof_minSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:654.1-654.42
def $sizeof_minSizeInBits''(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return 1

3. (Let typeIR be typeIR'')

4. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w >) be numberTypeIR)

    2. Return w

5. (Let typeIR be typeIR'')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. Return w

7. (Let typeIR be typeIR'')

8. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `VARBIT<%>`)), then

    1. (Let (varbit< _nat >) be numberTypeIR)

    2. Return 0

9. (Let typeIR' be typeIR'')

10. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid typeIR) be aliasTypeIR)

    2. Return $sizeof_minSizeInBits'(typeIR)

11. (Let typeIR' be typeIR'')

12. If ((typeIR' has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR' as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return $sizeof_minSizeInBits'(typeIR)

13. (Let typeIR' be typeIR'')

14. If ((typeIR' has type tupleTypeIR)), then

  1. (Let (tuple< typeIR* >) be (typeIR' as tupleTypeIR))

  2. Return $sum($sizeof_minSizeInBits'(typeIR)*)

15. (Let typeIR' be typeIR'')

16. If ((typeIR' has type headerStackTypeIR)), then

  1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

  2. Return ($sizeof_minSizeInBits'(typeIR) * n_size)

17. (Let typeIR' be typeIR'')

18. If ((typeIR' has type structTypeIR)), then

  1. (Let (struct _tid { (typeIR _id ;)* }) be (typeIR' as structTypeIR))

  2. Return $sum($sizeof_minSizeInBits'(typeIR)*)

19. (Let typeIR' be typeIR'')

20. If ((typeIR' has type headerTypeIR)), then

  1. (Let (header _tid { (typeIR _id ;)* }) be (typeIR' as headerTypeIR))

  2. Return $sum($sizeof_minSizeInBits'(typeIR)*)

21. (Let typeIR' be typeIR'')

22. If ((typeIR' has type headerUnionTypeIR)), then

  1. (Let (header_union _tid { (typeIR _id ;)* }) be (typeIR' as headerUnionTypeIR))

  2. Return $min($sizeof_minSizeInBits'(typeIR)*)

;; ../../../../spec-concrete/3-numerics.watsup:656.1-656.43
def $sizeof_minSizeInBytes(typeIR)

1. (Let n_size be $sizeof_minSizeInBits'(typeIR))

2. Return ((d ((n_size / 8) as int)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:658.1-658.42
def $sizeof_maxSizeInBits(typeIR)

1. Return ((d ($sizeof_maxSizeInBits'(typeIR) as int)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:659.1-659.41
def $sizeof_maxSizeInBits'(typeIR)

1. Return $sizeof_maxSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:660.1-660.42
def $sizeof_maxSizeInBits''(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return 1

3. (Let typeIR be typeIR'')

4. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w >) be numberTypeIR)

    2. Return w

5. (Let typeIR be typeIR'')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. Return w

7. (Let typeIR be typeIR'')

8. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `VARBIT<%>`)), then

    1. (Let (varbit< w >) be numberTypeIR)

    2. Return w

9. (Let typeIR' be typeIR'')

10. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid typeIR) be aliasTypeIR)

    2. Return $sizeof_maxSizeInBits'(typeIR)

11. (Let typeIR' be typeIR'')

12. If ((typeIR' has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR' as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return $sizeof_maxSizeInBits'(typeIR)

13. (Let typeIR' be typeIR'')

14. If ((typeIR' has type tupleTypeIR)), then

  1. (Let (tuple< typeIR* >) be (typeIR' as tupleTypeIR))

  2. Return $sum($sizeof_maxSizeInBits'(typeIR)*)

15. (Let typeIR' be typeIR'')

16. If ((typeIR' has type headerStackTypeIR)), then

  1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

  2. Return ($sizeof_maxSizeInBits'(typeIR) * n_size)

17. (Let typeIR' be typeIR'')

18. If ((typeIR' has type structTypeIR)), then

  1. (Let (struct _tid { (typeIR _id ;)* }) be (typeIR' as structTypeIR))

  2. Return $sum($sizeof_maxSizeInBits'(typeIR)*)

19. (Let typeIR' be typeIR'')

20. If ((typeIR' has type headerTypeIR)), then

  1. (Let (header _tid { (typeIR _id ;)* }) be (typeIR' as headerTypeIR))

  2. Return $sum($sizeof_maxSizeInBits'(typeIR)*)

21. (Let typeIR' be typeIR'')

22. If ((typeIR' has type headerUnionTypeIR)), then

  1. (Let (header_union _tid { (typeIR _id ;)* }) be (typeIR' as headerUnionTypeIR))

  2. Return $max($sizeof_maxSizeInBits'(typeIR)*)

;; ../../../../spec-concrete/3-numerics.watsup:662.1-662.43
def $sizeof_maxSizeInBytes(typeIR)

1. (Let n_size be $sizeof_maxSizeInBits'(typeIR))

2. Return ((d ((n_size / 8) as int)) as value)

;; ../../../../spec-concrete/4-ir-syntax.watsup:6.1-7.14
syntax prefixedNameIR = 
   | ` nameIR
   | . nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:9.1-9.63
def $prefixedNonTypeName(prefixedNonTypeName)

1. If ((prefixedNonTypeName has type nonTypeName)), then

  1. (Let nonTypeName be (prefixedNonTypeName as nonTypeName))

  2. Return (` $name((nonTypeName as name)))

2. If ((prefixedNonTypeName matches pattern ``ID.%`)), then

  1. (Let (. nonTypeName) be prefixedNonTypeName)

  2. Return (. $name((nonTypeName as name)))

;; ../../../../spec-concrete/4-ir-syntax.watsup:13.1-13.57
def $prefixedTypeName(prefixedTypeName)

1. If ((prefixedTypeName has type typeName)), then

  1. (Let typeName be (prefixedTypeName as typeName))

  2. Return (` $name((typeName as name)))

2. If ((prefixedTypeName matches pattern ``TID.%`)), then

  1. (Let (. typeName) be prefixedTypeName)

  2. Return (. $name((typeName as name)))

;; ../../../../spec-concrete/4-ir-syntax.watsup:17.1-17.53
def $flatten_prefixedNameIR(prefixedNameIR)

1. Case analysis on prefixedNameIR

  1. Case (% matches pattern ``%`)

    1. (Let (` nameIR) be prefixedNameIR)

    2. Return nameIR

  2. Case (% matches pattern `.%`)

    1. (Let (. nameIR) be prefixedNameIR)

    2. Return "." ++ nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:21.21-21.28
syntax nameListIR = nameIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:27.26-27.29
syntax typeParameterIR = tid

;; ../../../../spec-concrete/4-ir-syntax.watsup:29.30-29.46
syntax typeParameterListIR = typeParameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:38.3-38.66
syntax parameterIR = 
   | annotationList direction typeIR nameIR constantInitializerOptIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:40.26-40.38
syntax parameterListIR = parameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:46.33-46.44
syntax constructorParameterIR = parameterIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:48.37-48.49
syntax constructorParameterListIR = parameterIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:56.28-56.55
syntax namedExpressionIR = 
   | nameIR = typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:58.32-58.50
syntax namedExpressionListIR = namedExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:68.30-68.47
syntax literalExpressionIR = literalExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:74.32-74.46
syntax referenceExpressionIR = prefixedNameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:80.30-80.47
syntax defaultExpressionIR = defaultExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:86.28-86.50
syntax unaryExpressionIR = 
   | unop typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:89.3-89.44
syntax binaryExpressionIR = 
   | typedExpressionIR binop typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:92.3-92.62
syntax ternaryExpressionIR = 
   | typedExpressionIR ? typedExpressionIR : typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:98.27-98.56
syntax castExpressionIR = 
   | ( typeIR ) typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:107.1-111.46
syntax dataExpressionIR = 
   | {#}
   | seq{ typedExpressionListIR }
   | seq{ typedExpressionListIR ,...}
   | record{ namedExpressionListIR }
   | record{ namedExpressionListIR ,...}

;; ../../../../spec-concrete/4-ir-syntax.watsup:120.3-120.18
syntax errorAccessExpressionIR = 
   | error. nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:123.3-123.31
syntax memberAccessExpressionIR = 
   | memberAccessBaseIR . nameIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:126.1-127.66
syntax indexAccessExpressionIR = 
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]

;; ../../../../spec-concrete/4-ir-syntax.watsup:130.1-132.28
syntax accessExpressionIR = 
   | error. nameIR
   | memberAccessBaseIR . nameIR
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]

;; ../../../../spec-concrete/4-ir-syntax.watsup:143.1-146.25
syntax routineTargetIR = 
   | ` nameIR
   | . nameIR
   | typedExpressionIR . nameIR
   | type prefixedNameIR . nameIR
   | ( routineTargetIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:148.30-148.68
syntax constructorTargetIR = 
   | prefixedNameIR < typeArgumentListIR >

;; ../../../../spec-concrete/4-ir-syntax.watsup:151.1-152.64
syntax callExpressionIR = 
   | constructorTargetIR ( argumentListIR )
   | routineTargetIR < typeArgumentListIR >( argumentListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:158.36-158.58
syntax parenthesizedExpressionIR = 
   | ( typedExpressionIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:165.1-175.30
syntax expressionIR = 
   | true
   | false
   | d int hint(print %)
   | nat w int hint(print %#W#%)
   | nat s int hint(print %#S#%)
   | " text " hint(print "#%#")
   | ` nameIR
   | . nameIR
   | ...
   | unop typedExpressionIR
   | typedExpressionIR binop typedExpressionIR
   | typedExpressionIR ? typedExpressionIR : typedExpressionIR
   | ( typeIR ) typedExpressionIR
   | {#}
   | seq{ typedExpressionListIR }
   | seq{ typedExpressionListIR ,...}
   | record{ namedExpressionListIR }
   | record{ namedExpressionListIR ,...}
   | error. nameIR
   | memberAccessBaseIR . nameIR
   | typedExpressionIR [ typedExpressionIR ]
   | typedExpressionIR [ typedExpressionIR : typedExpressionIR ]
   | constructorTargetIR ( argumentListIR )
   | routineTargetIR < typeArgumentListIR >( argumentListIR )
   | ( typedExpressionIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:177.27-177.42
syntax expressionNoteIR = 
   | ( typeIR ctk )

;; ../../../../spec-concrete/4-ir-syntax.watsup:180.3-180.35
syntax typedExpressionIR = 
   | expressionIR # expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:182.32-182.50
syntax typedExpressionListIR = typedExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:185.1-186.22
syntax memberAccessBaseIR = 
   | type prefixedNameIR
   | expressionIR # expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:193.1-197.7
syntax simpleKeysetExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR &&& typedExpressionIR
   | typedExpressionIR .. typedExpressionIR
   | default
   | _

;; ../../../../spec-concrete/4-ir-syntax.watsup:199.39-199.64
syntax simpleKeysetExpressionListIR = simpleKeysetExpressionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:201.34-201.67
syntax tupleKeysetExpressionIR = 
   | ( simpleKeysetExpressionListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:204.1-205.28
syntax keysetExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR &&& typedExpressionIR
   | typedExpressionIR .. typedExpressionIR
   | default
   | _
   | ( simpleKeysetExpressionListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:211.25-211.31
syntax typeArgumentIR = typeIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:213.29-213.44
syntax typeArgumentListIR = typeArgumentIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:220.1-223.7
syntax argumentIR = 
   | expressionIR # expressionNoteIR
   | nameIR = typedExpressionIR
   | nameIR =_
   | _

;; ../../../../spec-concrete/4-ir-syntax.watsup:225.25-225.36
syntax argumentListIR = argumentIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:232.1-236.23
syntax lvalueIR = 
   | ` nameIR
   | . nameIR
   | typedLvalueIR . nameIR
   | typedLvalueIR [ typedExpressionIR ]
   | typedLvalueIR [ typedExpressionIR : typedExpressionIR ]
   | ( typedLvalueIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:238.24-238.47
syntax typedLvalueIR = 
   | lvalueIR #( typeIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:248.27-248.41
syntax emptyStatementIR = emptyStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:255.3-255.46
syntax assignmentStatementIR = 
   | typedLvalueIR assignop typedExpressionIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:262.3-262.65
syntax callStatementIR = 
   | routineTargetIR < typeArgumentListIR >( argumentListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:269.3-269.49
syntax directApplicationStatementIR = 
   | prefixedNameIR .apply( argumentListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:276.1-277.32
syntax returnStatementIR = 
   | return;
   | return typedExpressionIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:283.26-283.39
syntax exitStatementIR = exitStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:292.3-292.50
syntax blockStatementIR = 
   | annotationList { blockElementStatementListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:301.1-302.59
syntax conditionalStatementIR = 
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:311.1-314.35
syntax forInitStatementIR = 
   | annotationList typeIR nameIR initializerOptIR
   | lvalueIR ( argumentListIR )
   | lvalueIR < typeArgumentListIR >( argumentListIR )
   | lvalueIR assignop expressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:316.33-316.52
syntax forInitStatementListIR = forInitStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:318.31-318.49
syntax forUpdateStatementIR = forInitStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:320.35-320.56
syntax forUpdateStatementListIR = forUpdateStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:323.1-324.44
syntax forCollectionExpressionIR = 
   | expressionIR # expressionNoteIR
   | typedExpressionIR .. typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:327.1-335.18
syntax forStatementIR = 
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:342.1-343.22
syntax switchLabelIR = 
   | default
   | expressionIR # expressionNoteIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:346.1-347.21
syntax switchCaseIR = 
   | switchLabelIR : blockStatementIR
   | switchLabelIR :

;; ../../../../spec-concrete/4-ir-syntax.watsup:349.27-349.40
syntax switchCaseListIR = switchCaseIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:352.3-352.54
syntax switchStatementIR = 
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:358.27-358.41
syntax breakStatementIR = breakStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:360.30-360.47
syntax continueStatementIR = continueStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:367.1-378.22
syntax statementIR = 
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | return;
   | return typedExpressionIR ;
   | exit;
   | annotationList { blockElementStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR
   | break;
   | continue;
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:388.32-388.40
syntax constantInitializerIR = 
   | = value

;; ../../../../spec-concrete/4-ir-syntax.watsup:390.35-390.57
syntax constantInitializerOptIR = constantInitializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:393.3-393.62
syntax constantDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:395.24-395.44
syntax initializerIR = 
   | = typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:397.27-397.41
syntax initializerOptIR = initializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:400.3-400.51
syntax variableDeclarationIR = 
   | annotationList typeIR nameIR initializerOptIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:403.1-405.16
syntax blockElementStatementIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | return;
   | return typedExpressionIR ;
   | exit;
   | annotationList { blockElementStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR
   | annotationList for( forInitStatementListIR ; typedExpressionIR ; forUpdateStatementListIR ) statementIR
   | annotationList for( typeIR nameIR in forCollectionExpressionIR ) statementIR
   | annotationList for( annotationList typeIR nameIR in forCollectionExpressionIR ) statementIR
   | break;
   | continue;
   | switch( typedExpressionIR ){ switchCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:407.38-407.62
syntax blockElementStatementListIR = blockElementStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:414.3-415.73
syntax functionPrototypeIR = 
   | typeIR nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:418.3-418.54
syntax functionDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:425.3-425.69
syntax actionDeclarationIR = 
   | annotationList action nameIR ( parameterListIR ) blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:433.30-433.61
syntax objectInitializerIR = 
   | ={ objectDeclarationListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:435.33-435.53
syntax objectInitializerOptIR = objectInitializerIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:438.3-440.30
syntax instantiationIR = 
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:443.1-444.20
syntax objectDeclarationIR = 
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:446.34-446.54
syntax objectDeclarationListIR = objectDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:452.29-452.50
syntax errorDeclarationIR = 
   | error{ nameListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:458.33-458.59
syntax matchKindDeclarationIR = 
   | match_kind{ nameListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:469.1-470.65
syntax enumTypeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:476.22-476.53
syntax typeFieldIR = 
   | annotationList typeIR nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:478.26-478.38
syntax typeFieldListIR = typeFieldIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:481.3-482.73
syntax structTypeDeclarationIR = 
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:485.3-486.73
syntax headerTypeDeclarationIR = 
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:489.3-490.73
syntax headerUnionTypeDeclarationIR = 
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:493.1-496.33
syntax derivedTypeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:503.1-504.29
syntax typedefTypeIR = 
   | void
   | bool
   | error
   | match_kind
   | string
   | int
   | int< nat >
   | bit< nat >
   | varbit< nat >
   | tid tid
   | polyTypeDefIR < typeIR* >
   | typedef tid typeIR
   | type tid typeIR
   | list< typeIR >
   | tuple< typeIR* >
   | typeIR [ nat ]
   | struct tid { fieldTypeIR* }
   | header tid { fieldTypeIR* }
   | header_union tid { fieldTypeIR* }
   | enum tid { id* }
   | enum tid # typeIR { valueFieldIR* }
   | extern tid map<rid, routineTypeDefIR>
   | parser( parameterTypeIR* )
   | control( parameterTypeIR* )
   | package< typeIR* >
   | table tid # typeIR
   | default
   | header_invalid
   | seq< typeIR* >
   | seq< typeIR* ,...>
   | record{ fieldTypeIR* }
   | record{ fieldTypeIR* ,...}
   | set< typeIR* >
   | table_enum tid { id* }
   | table_struct tid { fieldTypeIR* }
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:507.1-508.41
syntax typedefDeclarationIR = 
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:515.3-515.47
syntax externFunctionDeclarationIR = 
   | annotationList extern functionPrototypeIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:518.1-520.51
syntax methodPrototypeIR = 
   | annotationList nameIR <, typeParameterListIR >( parameterListIR );
   | annotationList functionPrototypeIR ;
   | annotationList abstract functionPrototypeIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:522.32-522.50
syntax methodPrototypeListIR = methodPrototypeIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:525.3-527.31
syntax externObjectDeclarationIR = 
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:530.1-531.30
syntax externDeclarationIR = 
   | annotationList extern functionPrototypeIR ;
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:541.23-541.54
syntax selectCaseIR = 
   | keysetExpressionIR : nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:543.27-543.40
syntax selectCaseListIR = selectCaseIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:546.3-546.58
syntax selectExpressionIR = 
   | select( typedExpressionListIR ){ selectCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:553.1-554.23
syntax stateExpressionIR = 
   | nameIR ;
   | select( typedExpressionListIR ){ selectCaseListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:556.32-556.60
syntax transitionStatementIR = 
   | transition stateExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:563.3-563.72
syntax valueSetDeclarationIR = 
   | annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:570.3-571.76
syntax parserTypeDeclarationIR = 
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:580.3-580.44
syntax parserBlockStatementIR = 
   | annotationList { parserStatementListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:583.1-590.27
syntax parserStatementIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | ;
   | typedLvalueIR assignop typedExpressionIR ;
   | routineTargetIR < typeArgumentListIR >( argumentListIR );
   | prefixedNameIR .apply( argumentListIR );
   | annotationList { parserStatementListIR }
   | if( typedExpressionIR ) statementIR
   | if( typedExpressionIR ) statementIR else statementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:592.32-592.50
syntax parserStatementListIR = parserStatementIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:595.3-596.53
syntax parserStateIR = 
   | annotationList state nameIR { parserStatementListIR transitionStatementIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:598.28-598.42
syntax parserStateListIR = parserStateIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:601.1-604.26
syntax parserLocalDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:607.3-607.28
syntax parserLocalDeclarationListIR = parserLocalDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:610.3-613.56
syntax parserDeclarationIR = 
   | annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:623.18-623.23
syntax constIR = const

;; ../../../../spec-concrete/4-ir-syntax.watsup:625.21-625.29
syntax constOptIR = constIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:631.21-631.66
syntax tableKeyIR = 
   | typedExpressionIR : nameIR annotationList ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:633.25-633.36
syntax tableKeyListIR = tableKeyIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:639.33-639.67
syntax tableActionReferenceIR = 
   | prefixedNameIR ( argumentListIR )

;; ../../../../spec-concrete/4-ir-syntax.watsup:641.24-641.64
syntax tableActionIR = 
   | annotationList tableActionReferenceIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:643.28-643.42
syntax tableActionListIR = tableActionIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:650.1-651.42
syntax tableEntryPriorityIR = 
   | priority= numberLiteral :
   | priority=( typedExpressionIR ):

;; ../../../../spec-concrete/4-ir-syntax.watsup:653.34-653.55
syntax tableEntryPriorityOptIR = tableEntryPriorityIR?

;; ../../../../spec-concrete/4-ir-syntax.watsup:656.3-657.67
syntax tableEntryIR = 
   | constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:659.27-659.40
syntax tableEntryListIR = tableEntryIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:666.1-672.75
syntax tablePropertyIR = 
   | key={ tableKeyListIR }
   | actions={ tableActionListIR }
   | annotationList constOptIR entries={ tableEntryListIR }
   | annotationList constOptIR default_action= tableActionReferenceIR ;
   | annotationList constOptIR custom nameIR initializerIR ;
   | annotationList constOptIR custom_const nameIR constantInitializerIR ;

;; ../../../../spec-concrete/4-ir-syntax.watsup:674.30-674.46
syntax tablePropertyListIR = tablePropertyIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:677.3-677.62
syntax tableDeclarationIR = 
   | annotationList table typeIR nameIR { tablePropertyListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:684.3-686.28
syntax controlTypeDeclarationIR = 
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:692.24-692.40
syntax controlBodyIR = blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:695.1-699.23
syntax controlLocalDeclarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList typeIR nameIR initializerOptIR ;
   | annotationList action nameIR ( parameterListIR ) blockStatementIR
   | annotationList table typeIR nameIR { tablePropertyListIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:702.3-702.29
syntax controlLocalDeclarationListIR = controlLocalDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:705.3-708.59
syntax controlDeclarationIR = 
   | annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }

;; ../../../../spec-concrete/4-ir-syntax.watsup:715.3-717.28
syntax packageTypeDeclarationIR = 
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:724.1-728.29
syntax typeDeclarationIR = 
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:735.1-744.22
syntax declarationIR = 
   | annotationList const typeIR nameIR constantInitializerIR ;
   | annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;
   | annotationList functionPrototypeIR blockStatementIR
   | annotationList action nameIR ( parameterListIR ) blockStatementIR
   | error{ nameListIR }
   | match_kind{ nameListIR }
   | annotationList extern functionPrototypeIR ;
   | annotationList extern nameIR < typeParameterListIR , typeParameterListIR >{ methodPrototypeListIR }
   | annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
   | annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
   | annotationList enum nameIR { nameListIR }
   | annotationList enum typeIR nameIR { namedExpressionListIR }
   | annotationList struct nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList header_union nameIR < typeParameterListIR , typeParameterListIR >{ typeFieldListIR }
   | annotationList typedef typedefTypeIR nameIR ;
   | annotationList type typeIR nameIR ;
   | annotationList parser nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList control nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );
   | annotationList package nameIR < typeParameterListIR , typeParameterListIR >( parameterListIR );

;; ../../../../spec-concrete/4-ir-syntax.watsup:750.22-750.39
syntax p4programIR = 
   | declarationIR* ;

;; ../../../../spec-concrete/5.0-flow.watsup:5.15-5.25
syntax flow = 
   | cont
   | ret

;; ../../../../spec-concrete/5.0-flow.watsup:9.1-9.34
def $join_flow(flow'', flow''')

1. (Let flow be flow'')

2. (Let flow' be flow''')

3. If ((flow matches pattern `RET`)), then

  1. If ((flow' matches pattern `RET`)), then

    1. Return (ret)

4. (Let f_a be flow'')

5. (Let f_b be flow''')

6. Otherwise

  1. Return (cont)

;; ../../../../spec-concrete/5.01-env.watsup:5.20-5.47
syntax varTypeIR = 
   | direction typeIR ctk value?

;; ../../../../spec-concrete/5.01-env.watsup:12.16-12.34
syntax frame = map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:14.1-14.27
def $empty_frame

1. Return $empty_map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:18.16-18.35
syntax tdenv = map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:20.1-20.27
def $empty_tdenv

1. Return $empty_map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:24.16-24.42
syntax rdenv = map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:26.1-26.27
def $empty_rdenv

1. Return $empty_map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:30.16-30.46
syntax cdenv = map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:32.1-32.27
def $empty_cdenv

1. Return $empty_map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:39.1-39.39
def $check_routine_name(id_l, id_r)

1. Return (id_l = id_r)

;; ../../../../spec-concrete/5.01-env.watsup:42.1-42.37
def $check_arity(id_arg?*, id_param*)

1. Return (|id_arg?*| = |id_param*|)

;; ../../../../spec-concrete/5.01-env.watsup:45.1-45.42
def $check_arity_more(id_arg?*, id_param*)

1. Return (|id_arg?*| > |id_param*|)

;; ../../../../spec-concrete/5.01-env.watsup:48.1-48.42
def $check_arity_less(id_arg?*, id_param*)

1. Return (|id_arg?*| < |id_param*|)

;; ../../../../spec-concrete/5.01-env.watsup:51.1-51.44
def $get_missing_parameters(id*, id_arg*)

1. Case analysis on id*

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let id_param_h :: id_param_t* be id*)

    2. If (~$in_set<id>(id_param_h, ({ id_arg* }))), then

      1. Return id_param_h :: $get_missing_parameters(id_param_t*, id_arg*)

    3. Otherwise

      1. Return $get_missing_parameters(id_param_t*, id_arg*)

;; ../../../../spec-concrete/5.01-env.watsup:68.1-68.61
def $find_match_named<V>(rid, V, id_arg*, pid'*)

1. (Let (id_param # bool_param) be pid')*

2. If ($eq_set<id>(({ id_arg* }), ({ id_param* }))), then

  1. Return ?((rid, V, []))

3. (Let pid be pid')*

4. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:77.1-77.69
def $find_match_named_default<V>(rid, V, id_arg*, pid'*)

1. (Let (id_param # bool_param) be pid')*

2. (Let id_default* be $get_missing_parameters(id_param*, id_arg*))

3. If (($find_match_named<V>(rid, V, id_arg* ++ id_default*, (id_param # bool_param)*) =/= ?())), then

  1. Return ?((rid, V, id_default*))

4. (Let pid be pid')*

5. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:91.1-91.74
def $find_match_unnamed_default<V>(rid, V, id_arg?*, pid*)

1. (Let (_pid*, (id_default # bool)*) be $partition_<pid>(pid*, |id_arg?*|))

2. If ((bool = true))*, then

  1. Return ?((rid, V, id_default*))

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:100.1-100.64
def $find_matching<V>(id_r, id_arg?*, id_arg''*, (id_r' ( pid_r''* )), V)

1. (Let id_arg' be id_arg'')*

2. (Let pid_r' be pid_r'')*

3. If (~$check_routine_name(id_r, id_r')), then

  1. Return ?()

4. (Let id_arg' be id_arg'')*

5. (Let (id_param' # bool_param') be pid_r'')*

6. If ($check_routine_name(id_r, id_r')), then

  1. If ($check_arity_more(id_arg?*, id_param'*)), then

    1. Return ?()

7. (Let id_arg' be id_arg'')*

8. (Let (id_param' # bool_param') be pid_r'')*

9. If ((|id_arg'*| > 0)), then

  1. If ($check_routine_name(id_r, id_r')), then

    1. If ($check_arity(id_arg?*, id_param'*)), then

      1. Return $find_match_named<V>((id_r' ( (id_param' # bool_param')* )), V, id_arg'*, (id_param' # bool_param')*)

10. (Let id be id_arg'')*

11. (Let (id_param' # bool_param') be pid_r'')*

12. If ((id* matches pattern [])), then

  1. If ($check_routine_name(id_r, id_r')), then

    1. If ($check_arity(id_arg?*, id_param'*)), then

      1. Return ?(((id_r' ( (id_param' # bool_param')* )), V, []))

13. (Let id_arg' be id_arg'')*

14. (Let (id_param' # bool_param') be pid_r'')*

15. If ((|id_arg'*| > 0)), then

  1. If ($check_routine_name(id_r, id_r')), then

    1. If ($check_arity_less(id_arg?*, id_param'*)), then

      1. Return $find_match_named_default<V>((id_r' ( (id_param' # bool_param')* )), V, id_arg'*, (id_param' # bool_param')*)

16. (Let id be id_arg'')*

17. (Let (id_param' # bool_param') be pid_r'')*

18. If ((id* matches pattern [])), then

  1. If ($check_routine_name(id_r, id_r')), then

    1. If ($check_arity_less(id_arg?*, id_param'*)), then

      1. Return $find_match_unnamed_default<V>((id_r' ( (id_param' # bool_param')* )), V, id_arg?*, (id_param' # bool_param')*)

;; ../../../../spec-concrete/5.01-env.watsup:159.1-159.67
def $find_matchings<V>(id_r, id_arg?*, id_arg'*, rid''*, V''*)

1. (Let rid be rid'')*

2. (Let V be V'')*

3. If ((rid* matches pattern [])), then

  1. If ((V* matches pattern [])), then

    1. Return []

4. (Let rid be rid'')*

5. (Let V be V'')*

6. If ((rid* matches pattern _ :: _)), then

  1. (Let rid_h :: rid_t* be rid*)

  2. If ((V* matches pattern _ :: _)), then

    1. (Let V_h :: V_t* be V*)

    2. If (($find_matching<V>(id_r, id_arg?*, id_arg'*, rid_h, V_h) = ?())), then

      1. Return $find_matchings<V>(id_r, id_arg?*, id_arg'*, rid_t*, V_t*)

7. (Let rid' be rid'')*

8. (Let V' be V'')*

9. If ((rid'* matches pattern _ :: _)), then

  1. (Let rid_h :: rid_t* be rid'*)

  2. If ((V'* matches pattern _ :: _)), then

    1. (Let V_h :: V_t* be V'*)

    2. (Let (rid, V, id*)? be $find_matching<V>(id_r, id_arg?*, id_arg'*, rid_h, V_h))

    3. If (((rid, V, id*)? matches pattern (_))), then

      1. (Let ?((rid, V, id_default*)) be (rid, V, id*)?)

      2. Return (rid, V, id_default*) :: $find_matchings<V>(id_r, id_arg?*, id_arg'*, rid_t*, V_t*)

;; ../../../../spec-concrete/5.01-env.watsup:181.1-181.66
def $find_overloaded<V>(({ (rid : V)* }), id_r, id_arg?*)

1. If ((|id_arg?*| > 0)), then

  1. (Let id? be id_arg?)*

  2. If ((id? matches pattern (_)))*, then

    1. (Let ?(id_arg') be id?)*

    2. If (($find_matchings<V>(id_r, id_arg?*, id_arg'*, rid*, V*) = [])), then

      1. Return ?()

    3. (Let (rid, V, id*)* be $find_matchings<V>(id_r, id_arg?*, id_arg'*, rid*, V*))

    4. If (((rid, V, id*)* matches pattern [ _/1 ])), then

      1. (Let [(rid', V', id_default*)] be (rid, V, id*)*)

      2. Return ?((rid', V', id_default*))

2. If ((id_arg? = ?()))*, then

  1. If (($find_matchings<V>(id_r, id_arg?*, [], rid*, V*) = [])), then

    1. Return ?()

  2. (Let (rid, V, id*)* be $find_matchings<V>(id_r, id_arg?*, [], rid*, V*))

  3. If (((rid, V, id*)* matches pattern [ _/1 ])), then

    1. (Let [(rid', V', id_default*)] be (rid, V, id*)*)

    2. Return ?((rid', V', id_default*))

;; ../../../../spec-concrete/5.01-env.watsup:218.1-218.50
def $find_non_overloaded<V>(({ (rid : V)* }), id)

1. (Let V''* be $find_non_overloaded'<V>(({ (rid : V)* }), id))

2. If ((V''* matches pattern [ _/1 ])), then

  1. (Let [V'] be V''*)

  2. Return ?(V')

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:219.1-219.51
def $find_non_overloaded'<V>(set<pair<rid, V>>', id)

1. (Let set<pair<rid, V>> be set<pair<rid, V>>')

2. If ((set<pair<rid, V>> = ({ [] }))), then

  1. Return []

3. (Let ({ pair<rid, V>* }) be set<pair<rid, V>>')

4. If ((pair<rid, V>* matches pattern _ :: _)), then

  1. (Let (rid_h : V_h) :: (rid_t : V_t)* be pair<rid, V>*)

  2. (Let (id' ( _pid* )) be rid_h)

  3. If ((id' = id)), then

    1. (Let V_t_found* be $find_non_overloaded'<V>(({ (rid_t : V_t)* }), id))

    2. Return V_h :: V_t_found*

5. (Let ({ pair<rid, V>* }) be set<pair<rid, V>>')

6. If ((pair<rid, V>* matches pattern _ :: _)), then

  1. (Let (rid_h : V_h) :: (rid_t : V_t)* be pair<rid, V>*)

  2. (Let (id_h ( _pid* )) be rid_h)

  3. If ((id =/= id_h)), then

    1. (Let V_t_found* be $find_non_overloaded'<V>(({ (rid_t : V_t)* }), id))

    2. Return V_t_found*

;; ../../../../spec-concrete/5.02-context.watsup:5.17-5.39
syntax cursor = 
   | global
   | block
   | local

;; ../../../../spec-concrete/5.02-context.watsup:16.3-19.18
syntax globalTypingLayer = {cdenv cdenv, tdenv tdenv, rdenv rdenv, frame frame}

;; ../../../../spec-concrete/5.02-context.watsup:24.1-28.12
syntax blockKind = 
   | 
   | extern
   | parser
   | control
   | package

;; ../../../../spec-concrete/5.02-context.watsup:30.1-30.43
def $is_extern_blockKind(blockKind)

1. Return (blockKind = (extern))

;; ../../../../spec-concrete/5.02-context.watsup:33.1-33.43
def $is_parser_blockKind(blockKind)

1. Return (blockKind = (parser))

;; ../../../../spec-concrete/5.02-context.watsup:36.1-36.44
def $is_control_blockKind(blockKind)

1. Return (blockKind = (control))

;; ../../../../spec-concrete/5.02-context.watsup:39.1-39.44
def $is_package_blockKind(blockKind)

1. Return (blockKind = (package))

;; ../../../../spec-concrete/5.02-context.watsup:43.3-47.18
syntax blockTypingLayer = {id id, kind blockKind, tdenv tdenv, rdenv rdenv, frame frame}

;; ../../../../spec-concrete/5.02-context.watsup:52.1-60.23
syntax localKind = 
   | 
   | function-> typeIR
   | extern_function-> typeIR
   | action
   | extern_method-> typeIR
   | extern_methodabstract-> typeIR
   | parser_state
   | control_apply_method
   | table_apply_method

;; ../../../../spec-concrete/5.02-context.watsup:62.1-62.45
def $is_function_localKind(localKind')

1. (Let localKind be localKind')

2. If ((localKind matches pattern `FUNCTION->%`)), then

  1. (Let (function-> _typeIR) be localKind)

  2. Return true

3. (Let _localKind be localKind')

4. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:67.1-67.52
def $is_extern_function_localKind(localKind')

1. (Let localKind be localKind')

2. If ((localKind matches pattern `EXTERN_FUNCTION->%`)), then

  1. (Let (extern_function-> _typeIR) be localKind)

  2. Return true

3. (Let _localKind be localKind')

4. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:74.1-74.43
def $is_action_localKind(localKind')

1. (Let localKind be localKind')

2. If ((localKind matches pattern `ACTION`)), then

  1. Return true

3. (Let _localKind be localKind')

4. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:79.1-79.50
def $is_extern_method_localKind(localKind')

1. (Let localKind be localKind')

2. If ((localKind matches pattern `EXTERN_METHOD->%`)), then

  1. (Let (extern_method-> _typeIR) be localKind)

  2. Return true

3. (Let _localKind be localKind')

4. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:86.1-86.59
def $is_extern_abstract_method_localKind(localKind')

1. (Let localKind be localKind')

2. If ((localKind matches pattern `EXTERN_METHODABSTRACT->%`)), then

  1. (Let (extern_methodabstract-> _typeIR) be localKind)

  2. Return true

3. (Let _localKind be localKind')

4. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:93.1-93.49
def $is_parser_state_localKind(localKind')

1. (Let localKind be localKind')

2. If ((localKind matches pattern `PARSER_STATE`)), then

  1. Return true

3. (Let _localKind be localKind')

4. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:98.1-98.57
def $is_control_apply_method_localKind(localKind')

1. (Let localKind be localKind')

2. If ((localKind matches pattern `CONTROL_APPLY_METHOD`)), then

  1. Return true

3. (Let _localKind be localKind')

4. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:105.1-105.55
def $is_table_apply_method_localKind(localKind')

1. (Let localKind be localKind')

2. If ((localKind matches pattern `TABLE_APPLY_METHOD`)), then

  1. Return true

3. (Let _localKind be localKind')

4. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02-context.watsup:113.3-116.20
syntax localTypingLayer = {id id, kind localKind, tdenv tdenv, frames frame*}

;; ../../../../spec-concrete/5.02-context.watsup:123.3-125.29
syntax typingContext = {global globalTypingLayer, block blockTypingLayer, local localTypingLayer}

;; ../../../../spec-concrete/5.02-context.watsup:133.1-133.41
def $empty_typingContext

1. (Let globalTypingLayer be {cdenv $empty_cdenv, tdenv $empty_tdenv, rdenv $empty_rdenv, frame $empty_frame})

2. (Let blockTypingLayer be {id "", kind (), tdenv $empty_tdenv, rdenv $empty_rdenv, frame $empty_frame})

3. (Let localTypingLayer be {id "", kind (), tdenv $empty_tdenv, frames [$empty_frame]})

4. (Let TC be {global globalTypingLayer, block blockTypingLayer, local localTypingLayer})

5. Return TC

;; ../../../../spec-concrete/5.02-context.watsup:161.1-161.42
def $bound(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return ({ [] })

  2. Case (% matches pattern `BLOCK`)

    1. Return $dom_map<tid, typeDefIR>(TC.block.tdenv)

  3. Case (% matches pattern `LOCAL`)

    1. (Let bound_block be $bound((block), TC))

    2. (Let bound_local be $dom_map<tid, typeDefIR>(TC.local.tdenv))

    3. Return $union_set<tid>(bound_block, bound_local)

;; ../../../../spec-concrete/5.02-context.watsup:173.1-173.42
def $enter(TC)

1. Return TC[local.frames = $empty_frame :: TC.local.frames]

;; ../../../../spec-concrete/5.02-context.watsup:177.1-177.41
def $exit(TC)

1. (Let frame* be TC.local.frames)

2. If ((frame* matches pattern _ :: _)), then

  1. (Let frame_h :: frame_t* be frame*)

  2. Return TC[local.frames = frame_t*]

;; ../../../../spec-concrete/5.02-context.watsup:188.1-188.67
def $add_var(cursor, TC, id, varTypeIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let frame be TC.global.frame)

    2. If (~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))), then

      1. (Let (_direction typeIR _ctk _value?) be varTypeIR)

      2. If (((id = "main") => $is_package_object_typeIR($canon(typeIR)))), then

        1. (Let frame_update be $add_map<id, varTypeIR>(frame, id, varTypeIR))

        2. (Let TC' be TC[global.frame = frame_update])

        3. Return TC'

  2. Case (% matches pattern `BLOCK`)

    1. (Let frame be TC.block.frame)

    2. If (~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))), then

      1. If ((id =/= "main")), then

        1. (Let frame_update be $add_map<id, varTypeIR>(TC.block.frame, id, varTypeIR))

        2. (Let TC' be TC[block.frame = frame_update])

        3. Return TC'

  3. Case (% matches pattern `LOCAL`)

    1. (Let frame'* be TC.local.frames)

    2. If ((frame'* matches pattern _ :: _)), then

      1. (Let frame_h :: frame_t* be frame'*)

      2. If (~$in_set<id>(id, $dom_map<id, varTypeIR>(frame_h))), then

        1. If ((id =/= "main")), then

          1. (Let frame_h_update be $add_map<id, varTypeIR>(frame_h, id, varTypeIR))

          2. (Let frame* be frame_h_update :: frame_t*)

          3. (Let TC' be TC[local.frames = frame*])

          4. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:189.1-189.70
def $add_vars(p, TC, id*, varTypeIR*)

1. Case analysis on id*

  1. Case (% matches pattern [])

    1. If ((varTypeIR* matches pattern [])), then

      1. Return TC

  2. Case (% matches pattern _ :: _)

    1. (Let id_h :: id_t* be id*)

    2. If ((varTypeIR* matches pattern _ :: _)), then

      1. (Let varTypeIR_h :: varTypeIR_t* be varTypeIR*)

      2. (Let TC' be $add_var(p, TC, id_h, varTypeIR_h))

      3. (Let TC'' be $add_vars(p, TC', id_t*, varTypeIR_t*))

      4. Return TC''

;; ../../../../spec-concrete/5.02-context.watsup:219.1-219.75
def $add_parameter(cursor, TC, (direction typeIR id value?))

1. Case analysis on direction

  1. Case (% matches pattern ``EMPTY`)

    1. (Let varTypeIR be (() typeIR (ctk) value?))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

  2. Case (% matches pattern `IN`)

    1. (Let varTypeIR be (direction typeIR (dyn) value?))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

  3. Case (% matches pattern `OUT`)

    1. (Let varTypeIR be (direction typeIR (dyn) value?))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

  4. Case (% matches pattern `INOUT`)

    1. (Let varTypeIR be (direction typeIR (dyn) value?))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:220.1-220.77
def $add_parameters(cursor, TC, parameterTypeIR*)

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. Return TC

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. (Let TC' be $add_parameter(cursor, TC, parameterTypeIR_h))

    3. (Let TC'' be $add_parameters(cursor, TC', parameterTypeIR_t*))

    4. Return TC''

;; ../../../../spec-concrete/5.02-context.watsup:237.1-237.78
def $add_constructorParameter(TC, (direction typeIR id value''?))

1. (Let value be value'')?

2. If ((value? matches pattern ())), then

  1. (Let varTypeIR be (direction typeIR (ctk) ?()))

  2. (Let TC' be $add_var((block), TC, id, varTypeIR))

  3. Return TC'

3. (Let value' be value'')?

4. If ((value'? matches pattern (_))), then

  1. (Let ?(value) be value'?)

  2. (Let varTypeIR be (direction typeIR (ctk) ?(value)))

  3. (Let TC' be $add_var((block), TC, id, varTypeIR))

  4. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:238.1-238.80
def $add_constructorParameters(TC, parameterTypeIR*)

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. Return TC

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. (Let TC' be $add_constructorParameter(TC, parameterTypeIR_h))

    3. (Let TC'' be $add_constructorParameters(TC', parameterTypeIR_t*))

    4. Return TC''

;; ../../../../spec-concrete/5.02-context.watsup:254.1-254.69
def $add_type(cursor, TC, tid, typeDefIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let tdenv be TC.global.tdenv)

    2. If (~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))), then

      1. (Let tdenv_update be $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR))

      2. (Let TC' be TC[global.tdenv = tdenv_update])

      3. Return TC'

  2. Case (% matches pattern `BLOCK`)

    1. (Let tdenv be TC.block.tdenv)

    2. If (~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))), then

      1. (Let tdenv_update be $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR))

      2. (Let TC' be TC[block.tdenv = tdenv_update])

      3. Return TC'

  3. Case (% matches pattern `LOCAL`)

    1. (Let tdenv be TC.local.tdenv)

    2. If (~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))), then

      1. (Let tdenv_update be $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR))

      2. (Let TC' be TC[local.tdenv = tdenv_update])

      3. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:274.1-274.72
def $add_types(p, TC, tid*, typeDefIR*)

1. Case analysis on tid*

  1. Case (% matches pattern [])

    1. If ((typeDefIR* matches pattern [])), then

      1. Return TC

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t* be tid*)

    2. If ((typeDefIR* matches pattern _ :: _)), then

      1. (Let typeDefIR_h :: typeDefIR_t* be typeDefIR*)

      2. (Let TC' be $add_type(p, TC, tid_h, typeDefIR_h))

      3. (Let TC'' be $add_types(p, TC', tid_t*, typeDefIR_t*))

      4. Return TC''

;; ../../../../spec-concrete/5.02-context.watsup:282.1-282.88
def $add_routine_overload(cursor, TC, rid, routineTypeDefIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let rdenv be TC.global.rdenv)

    2. If (~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[global.rdenv = rdenv_update])

      3. Return TC'

  2. Case (% matches pattern `BLOCK`)

    1. (Let rdenv be TC.block.rdenv)

    2. If (~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[block.rdenv = rdenv_update])

      3. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:297.1-297.92
def $add_routine_non_overload(cursor, TC, rid, routineTypeDefIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let rdenv be TC.global.rdenv)

    2. (Let (id ( _pid* )) be rid)

    3. (Let ({ (id_k ( _pid'* ))* }) be $dom_map<rid, routineTypeDefIR>(rdenv))

    4. If (~$in_set<id>(id, ({ id_k* }))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[global.rdenv = rdenv_update])

      3. Return TC'

  2. Case (% matches pattern `BLOCK`)

    1. (Let rdenv be TC.block.rdenv)

    2. (Let (id ( _pid* )) be rid)

    3. (Let ({ (id_k ( _pid'* ))* }) be $dom_map<rid, routineTypeDefIR>(rdenv))

    4. If (~$in_set<id>(id, ({ id_k* }))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[block.rdenv = rdenv_update])

      3. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:318.1-318.79
def $add_constructor(TC, cid, constructorTypeDefIR)

1. (Let cdenv be TC.global.cdenv)

2. If (~$in_set<cid>(cid, $dom_map<cid, constructorTypeDefIR>(cdenv))), then

  1. (Let cdenv_update be $add_map<cid, constructorTypeDefIR>(cdenv, cid, constructorTypeDefIR))

  2. (Let TC' be TC[global.cdenv = cdenv_update])

  3. Return TC'

;; ../../../../spec-concrete/5.02-context.watsup:333.1-333.66
def $find_var(p', TC, prefixedNameIR)

1. (Let p be p')

2. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. id) be prefixedNameIR)

  2. (Let frame be TC.global.frame)

  3. Return $find_map<id, varTypeIR>(frame, id)

3. (Let cursor be p')

4. If ((cursor matches pattern `GLOBAL`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. (Let frame be TC.global.frame)

    3. Return $find_map<id, varTypeIR>(frame, id)

5. (Let cursor be p')

6. If ((cursor matches pattern `BLOCK`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. (Let frame be TC.block.frame)

    3. (Let varTypeIR'? be $find_map<id, varTypeIR>(frame, id))

    4. If ((varTypeIR'? matches pattern (_))), then

      1. (Let ?(varTypeIR) be varTypeIR'?)

      2. Return ?(varTypeIR)

7. (Let cursor be p')

8. If ((cursor matches pattern `BLOCK`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. (Let frame be TC.block.frame)

    3. If ((?() = $find_map<id, varTypeIR>(frame, id))), then

      1. Return $find_var((global), TC, (` id))

9. (Let cursor be p')

10. If ((cursor matches pattern `LOCAL`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. (Let frame* be TC.local.frames)

    3. (Let varTypeIR'? be $find_maps<id, varTypeIR>(frame*, id))

    4. If ((varTypeIR'? matches pattern (_))), then

      1. (Let ?(varTypeIR) be varTypeIR'?)

      2. Return ?(varTypeIR)

11. (Let cursor be p')

12. If ((cursor matches pattern `LOCAL`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. (Let frame* be TC.local.frames)

    3. If ((?() = $find_maps<id, varTypeIR>(frame*, id))), then

      1. Return $find_var((block), TC, (` id))

;; ../../../../spec-concrete/5.02-context.watsup:354.1-354.63
def $find_value(p', TC, prefixedNameIR)

1. (Let p be p')

2. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. id) be prefixedNameIR)

  2. (Let frame be TC.global.frame)

  3. (Let varTypeIR? be $find_map<id, varTypeIR>(frame, id))

  4. If ((varTypeIR? matches pattern (_))), then

    1. (Let ?((_direction _typeIR _ctk value'?)) be varTypeIR?)

    2. If ((value'? matches pattern (_))), then

      1. (Let ?(value) be value'?)

      2. Return value

3. (Let cursor be p')

4. If ((cursor matches pattern `GLOBAL`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. (Let frame be TC.global.frame)

    3. (Let varTypeIR? be $find_map<id, varTypeIR>(frame, id))

    4. If ((varTypeIR? matches pattern (_))), then

      1. (Let ?((_direction _typeIR _ctk value'?)) be varTypeIR?)

      2. If ((value'? matches pattern (_))), then

        1. (Let ?(value) be value'?)

        2. Return value

5. (Let cursor be p')

6. If ((cursor matches pattern `BLOCK`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. (Let frame be TC.block.frame)

    3. (Let varTypeIR? be $find_map<id, varTypeIR>(frame, id))

    4. If ((varTypeIR? matches pattern (_))), then

      1. (Let ?((_direction _typeIR _ctk value'?)) be varTypeIR?)

      2. If ((value'? matches pattern (_))), then

        1. (Let ?(value) be value'?)

        2. Return value

7. (Let cursor be p')

8. If ((cursor matches pattern `BLOCK`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. (Let frame be TC.block.frame)

    3. If ((?() = $find_map<id, varTypeIR>(frame, id))), then

      1. Return $find_value((global), TC, (` id))

9. (Let cursor be p')

10. If ((cursor matches pattern `LOCAL`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. (Let frame* be TC.local.frames)

    3. (Let varTypeIR? be $find_maps<id, varTypeIR>(frame*, id))

    4. If ((varTypeIR? matches pattern (_))), then

      1. (Let ?((_direction _typeIR _ctk value'?)) be varTypeIR?)

      2. If ((value'? matches pattern (_))), then

        1. (Let ?(value) be value'?)

        2. Return value

11. (Let cursor be p')

12. If ((cursor matches pattern `LOCAL`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. (Let frame* be TC.local.frames)

    3. If ((?() = $find_maps<id, varTypeIR>(frame*, id))), then

      1. Return $find_value((block), TC, (` id))

;; ../../../../spec-concrete/5.02-context.watsup:377.1-377.67
def $find_type(p', TC, prefixedNameIR)

1. (Let p be p')

2. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. tid) be prefixedNameIR)

  2. (Let tdenv be TC.global.tdenv)

  3. Return $find_map<tid, typeDefIR>(tdenv, tid)

3. (Let cursor be p')

4. If ((cursor matches pattern `GLOBAL`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` tid) be prefixedNameIR)

    2. (Let tdenv be TC.global.tdenv)

    3. Return $find_map<tid, typeDefIR>(tdenv, tid)

5. (Let cursor be p')

6. If ((cursor matches pattern `BLOCK`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` tid) be prefixedNameIR)

    2. (Let tdenv be TC.block.tdenv)

    3. (Let typeDefIR'? be $find_map<tid, typeDefIR>(tdenv, tid))

    4. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. Return ?(typeDefIR)

7. (Let cursor be p')

8. If ((cursor matches pattern `BLOCK`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` tid) be prefixedNameIR)

    2. (Let tdenv be TC.block.tdenv)

    3. If ((?() = $find_map<tid, typeDefIR>(tdenv, tid))), then

      1. Return $find_type((global), TC, (` tid))

9. (Let cursor be p')

10. If ((cursor matches pattern `LOCAL`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` tid) be prefixedNameIR)

    2. (Let tdenv* be [TC.local.tdenv])

    3. (Let typeDefIR'? be $find_maps<tid, typeDefIR>(tdenv*, tid))

    4. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. Return ?(typeDefIR)

11. (Let cursor be p')

12. If ((cursor matches pattern `LOCAL`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` tid) be prefixedNameIR)

    2. (Let tdenv* be [TC.local.tdenv])

    3. If ((?() = $find_maps<tid, typeDefIR>(tdenv*, tid))), then

      1. Return $find_type((block), TC, (` tid))

;; ../../../../spec-concrete/5.02-context.watsup:400.1-400.41
def $ids_arguments(argumentIR*)

1. Return $id_argument(argumentIR)*

;; ../../../../spec-concrete/5.02-context.watsup:401.1-401.35
def $id_argument(argumentIR)

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. Return ?()

2. Case analysis on argumentIR

  1. Case (% matches pattern `%=%`)

    1. (Let (nameIR = _typedExpressionIR) be argumentIR)

    2. Return ?(nameIR)

  2. Case (% matches pattern `%=_`)

    1. (Let (nameIR =_) be argumentIR)

    2. Return ?(nameIR)

  3. Case (% matches pattern `_`)

    1. Return ?()

;; ../../../../spec-concrete/5.02-context.watsup:409.1-410.34
def $find_routine_overloaded(cursor, TC, prefixedNameIR, argumentIR*)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Case analysis on prefixedNameIR

      1. Case (% matches pattern `.%`)

        1. (Let (. id) be prefixedNameIR)

        2. (Let rdenv be TC.global.rdenv)

        3. (Let id_arg?* be $ids_arguments(argumentIR*))

        4. Return $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?*)

      2. Case (% matches pattern ``%`)

        1. (Let (` id) be prefixedNameIR)

        2. (Let rdenv be TC.global.rdenv)

        3. (Let id_arg?* be $ids_arguments(argumentIR*))

        4. Return $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?*)

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. (Let rdenv be TC.block.rdenv)

      3. (Let id_arg?* be $ids_arguments(argumentIR*))

      4. (Let (rid, routineTypeDefIR, id*)? be $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?*))

      5. If (((rid, routineTypeDefIR, id*)? matches pattern (_))), then

        1. (Let ?((rid, routineTypeDefIR, id_default*)) be (rid, routineTypeDefIR, id*)?)

        2. Return ?((rid, routineTypeDefIR, id_default*))

      6. If ((?() = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?*))), then

        1. Return $find_routine_overloaded((global), TC, (` id), argumentIR*)

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` id) be prefixedNameIR)

      2. Return $find_routine_overloaded((block), TC, (` id), argumentIR*)

;; ../../../../spec-concrete/5.02-context.watsup:435.1-436.22
def $find_routine_non_overloaded(p', TC, prefixedNameIR)

1. (Let p be p')

2. If ((prefixedNameIR matches pattern `.%`)), then

  1. (Let (. id) be prefixedNameIR)

  2. Return $find_non_overloaded<routineTypeDefIR>(TC.global.rdenv, id)

3. (Let cursor be p')

4. If ((cursor matches pattern `GLOBAL`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. Return $find_non_overloaded<routineTypeDefIR>(TC.global.rdenv, id)

5. (Let cursor be p')

6. If ((cursor matches pattern `BLOCK`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. (Let routineTypeDefIR'? be $find_non_overloaded<routineTypeDefIR>(TC.block.rdenv, id))

    3. If ((routineTypeDefIR'? matches pattern (_))), then

      1. (Let ?(routineTypeDefIR) be routineTypeDefIR'?)

      2. Return ?(routineTypeDefIR)

7. (Let cursor be p')

8. If ((cursor matches pattern `BLOCK`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. If ((?() = $find_non_overloaded<routineTypeDefIR>(TC.block.rdenv, id))), then

      1. Return $find_routine_non_overloaded((global), TC, (` id))

9. (Let cursor be p')

10. If ((cursor matches pattern `LOCAL`)), then

  1. If ((prefixedNameIR matches pattern ``%`)), then

    1. (Let (` id) be prefixedNameIR)

    2. Return $find_routine_non_overloaded((block), TC, (` id))

;; ../../../../spec-concrete/5.02-context.watsup:454.1-455.38
def $find_constructor_overloaded(TC, prefixedNameIR, argumentIR*)

1. Case analysis on prefixedNameIR

  1. Case (% matches pattern `.%`)

    1. (Let (. id) be prefixedNameIR)

    2. (Let cdenv be TC.global.cdenv)

    3. (Let id_arg?* be $ids_arguments(argumentIR*))

    4. Return $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?*)

  2. Case (% matches pattern ``%`)

    1. (Let (` id) be prefixedNameIR)

    2. (Let cdenv be TC.global.cdenv)

    3. (Let id_arg?* be $ids_arguments(argumentIR*))

    4. Return $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?*)

;; ../../../../spec-concrete/5.02-context.watsup:468.1-468.47
def $find_return_type(TC)

1. (Let localKind be TC.local.kind)

2. If ((localKind matches pattern `FUNCTION->%`)), then

  1. (Let (function-> typeIR_ret) be localKind)

  2. Return ?(typeIR_ret)

3. (Let localKind be TC.local.kind)

4. If ((localKind matches pattern `EXTERN_FUNCTION->%`)), then

  1. (Let (extern_function-> typeIR_ret) be localKind)

  2. Return ?(typeIR_ret)

5. If (((action) = TC.local.kind)), then

  1. Return ?(((void) as typeIR))

6. (Let localKind be TC.local.kind)

7. If ((localKind matches pattern `EXTERN_METHOD->%`)), then

  1. (Let (extern_method-> typeIR_ret) be localKind)

  2. Return ?(typeIR_ret)

8. (Let localKind be TC.local.kind)

9. If ((localKind matches pattern `EXTERN_METHODABSTRACT->%`)), then

  1. (Let (extern_methodabstract-> typeIR_ret) be localKind)

  2. Return ?(typeIR_ret)

10. If (((control_apply_method) = TC.local.kind)), then

  1. Return ?(((void) as typeIR))

11. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.03-table-context.watsup:5.19-5.31
syntax matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.03-table-context.watsup:7.22-7.72
syntax matchAction = (prefixedNameIR, parameterTypeIR*, argumentListIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:10.3-13.24
syntax matchPriority = {values nat*, init bool, delta nat, largest_wins bool}

;; ../../../../spec-concrete/5.03-table-context.watsup:16.3-17.17
syntax matchEntry = {size nat, const bool}

;; ../../../../spec-concrete/5.03-table-context.watsup:21.1-27.11
syntax matchMode = 
   | nopri
   | noprilpm nat
   | pri
   | prilpm

;; ../../../../spec-concrete/5.03-table-context.watsup:30.3-34.21
syntax tableContext = {keys matchKey*, actions matchAction*, priorities matchPriority, entries matchEntry, mode matchMode}

;; ../../../../spec-concrete/5.03-table-context.watsup:44.1-46.10
syntax tableEntryState = 
   | lpm nat
   | nolpm

;; ../../../../spec-concrete/5.03-table-context.watsup:54.1-54.38
def $empty_tableContext

1. (Let matchPriority be {values [], init false, delta 1, largest_wins true})

2. (Let matchEntry be {size 0, const true})

3. Return {keys [], actions [], priorities matchPriority, entries matchEntry, mode (nopri)}

;; ../../../../spec-concrete/5.03-table-context.watsup:76.1-76.54
def $add_key(TBLC, id, typeIR)

1. (Let matchKey be (typeIR, id))

2. Return TBLC[keys = TBLC.keys ++ [matchKey]]

;; ../../../../spec-concrete/5.03-table-context.watsup:84.1-84.95
def $add_action(TBLC, prefixedNameIR, parameterTypeIR*, argumentListIR)

1. (Let matchAction be (prefixedNameIR, parameterTypeIR*, argumentListIR))

2. Return TBLC[actions = TBLC.actions ++ [matchAction]]

;; ../../../../spec-concrete/5.03-table-context.watsup:92.1-92.58
def $add_table_priority(TBLC, n)

1. Return TBLC[priorities.values = TBLC.priorities.values ++ [n]]

;; ../../../../spec-concrete/5.03-table-context.watsup:103.1-103.58
def $update_mode(TBLC, id, typeIR)

1. Return $update_mode'(TBLC, id, $canon(typeIR))

;; ../../../../spec-concrete/5.03-table-context.watsup:104.1-104.59
def $update_mode'(TBLC, text', typeIR'')

1. (Let text be text')

2. (Let typeIR be typeIR'')

3. If ((text = "lpm")), then

  1. If ((typeIR has type numberTypeIR)), then

    1. (Let numberTypeIR be (typeIR as numberTypeIR))

    2. If ((numberTypeIR matches pattern `INT<%>`)), then

      1. (Let (int< n >) be numberTypeIR)

      2. If ((TBLC.mode matches pattern `NOPRI`)), then

        1. Return TBLC[mode = (noprilpm n)]

4. (Let text be text')

5. (Let typeIR be typeIR'')

6. If ((text = "lpm")), then

  1. If ((typeIR has type numberTypeIR)), then

    1. (Let numberTypeIR be (typeIR as numberTypeIR))

    2. If ((numberTypeIR matches pattern `BIT<%>`)), then

      1. (Let (bit< n >) be numberTypeIR)

      2. If ((TBLC.mode matches pattern `NOPRI`)), then

        1. Return TBLC[mode = (noprilpm n)]

7. (Let text be text')

8. (Let typeIR be typeIR'')

9. If ((text = "lpm")), then

  1. If ((typeIR has type numberTypeIR)), then

    1. (Let numberTypeIR be (typeIR as numberTypeIR))

    2. If ((numberTypeIR matches pattern `VARBIT<%>`)), then

      1. (Let (varbit< n >) be numberTypeIR)

      2. If ((TBLC.mode matches pattern `NOPRI`)), then

        1. Return TBLC[mode = (noprilpm n)]

10. (Let text be text')

11. (Let typeIR' be typeIR'')

12. If ((text = "lpm")), then

  1. If ((typeIR' has type aliasTypeIR)), then

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

      1. (Let (type _tid typeIR) be aliasTypeIR)

      2. Return $update_mode(TBLC, "lpm", typeIR)

13. (Let text be text')

14. (Let _typeIR be typeIR'')

15. If ((text = "lpm")), then

  1. If ((TBLC.mode matches pattern `PRI`)), then

    1. Return TBLC[mode = (prilpm)]

16. (Let text be text')

17. (Let _typeIR be typeIR'')

18. If ((text = "range")), then

  1. If ((TBLC.mode matches pattern `NOPRI`)), then

    1. Return TBLC[mode = (pri)]

19. (Let text be text')

20. (Let _typeIR be typeIR'')

21. If ((text = "ternary")), then

  1. If ((TBLC.mode matches pattern `NOPRI`)), then

    1. Return TBLC[mode = (pri)]

22. (Let text be text')

23. (Let _typeIR be typeIR'')

24. If ((text = "optional")), then

  1. If ((TBLC.mode matches pattern `NOPRI`)), then

    1. Return TBLC[mode = (pri)]

25. (Let text be text')

26. (Let _typeIR be typeIR'')

27. If ((text = "range")), then

  1. (Let matchMode be TBLC.mode)

  2. If ((matchMode matches pattern `NOPRILPM%`)), then

    1. (Let (noprilpm _nat) be matchMode)

    2. Return TBLC[mode = (prilpm)]

28. (Let text be text')

29. (Let _typeIR be typeIR'')

30. If ((text = "ternary")), then

  1. (Let matchMode be TBLC.mode)

  2. If ((matchMode matches pattern `NOPRILPM%`)), then

    1. (Let (noprilpm _nat) be matchMode)

    2. Return TBLC[mode = (prilpm)]

31. (Let text be text')

32. (Let _typeIR be typeIR'')

33. If ((text = "optional")), then

  1. (Let matchMode be TBLC.mode)

  2. If ((matchMode matches pattern `NOPRILPM%`)), then

    1. (Let (noprilpm _nat) be matchMode)

    2. Return TBLC[mode = (prilpm)]

34. (Let _id be text')

35. (Let _typeIR be typeIR'')

36. Otherwise

  1. Return TBLC

;; ../../../../spec-concrete/5.03-table-context.watsup:138.1-138.85
def $find_action(TBLC, prefixedNameIR)

1. Return $find_action'(TBLC.actions, prefixedNameIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:139.1-139.86
def $find_action'(matchAction*, prefixedNameIR)

1. Case analysis on matchAction*

  1. Case (% matches pattern [])

    1. Return ?()

  2. Case (% matches pattern _ :: _)

    1. (Let matchAction_h :: matchAction_t* be matchAction*)

    2. (Let (prefixedNameIR', parameterTypeIR*, argumentListIR) be matchAction_h)

    3. If ((prefixedNameIR' = prefixedNameIR)), then

      1. Return ?((parameterTypeIR*, argumentListIR))

    4. (Let (prefixedNameIR_h, _parameterTypeIR*, _argumentListIR) be matchAction_h)

    5. If ((prefixedNameIR_h =/= prefixedNameIR)), then

      1. Return $find_action'(matchAction_t*, prefixedNameIR)

;; ../../../../spec-concrete/5.03-table-context.watsup:156.1-156.50
def $find_table_priority_last(TBLC)

1. (Let n* be TBLC.priorities.values)

2. Return n*[(|n*| - 1)]

;; ../../../../spec-concrete/5.03-table-context.watsup:165.1-165.78
def $join_tableEntryState(tableEntryState, tableEntryState')

1. Case analysis on tableEntryState

  1. Case (% matches pattern `NOLPM`)

    1. Case analysis on tableEntryState'

      1. Case (% matches pattern `LPM%`)

        1. (Let (lpm n) be tableEntryState')

        2. Return (lpm n)

      2. Case (% matches pattern `NOLPM`)

        1. Return (nolpm)

  2. Case (% matches pattern `LPM%`)

    1. (Let (lpm n) be tableEntryState)

    2. If ((tableEntryState' matches pattern `NOLPM`)), then

      1. Return (lpm n)

;; ../../../../spec-concrete/5.03-table-context.watsup:171.1-171.40
def $tableEntry_lpm_prefix(value)

1. Return $tableEntry_lpm_prefix'(value, 0)

;; ../../../../spec-concrete/5.03-table-context.watsup:172.1-172.46
def $tableEntry_lpm_prefix'(value, n_prefix')

1. (Let n_prefix be n_prefix')

2. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `%W%`)), then

    1. (Let (nat w _int) be numberLiteral)

    2. If ((nat = 0)), then

      1. Return n_prefix

3. (Let n_prefix be n_prefix')

4. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `%W%`)), then

    1. (Let (w w int) be numberLiteral)

    2. If ((int has type nat)), then

      1. (Let n be (int as nat))

      2. If ((w > 0)), then

        1. If (((n \ 2) =/= 0)), then

          1. (Let value' be (((w - 1) w (((n - 1) / 2) as int)) as value))

          2. Return $tableEntry_lpm_prefix'(value', (n_prefix + 1))

5. (Let nat be n_prefix')

6. If ((value has type numberLiteral)), then

  1. (Let numberLiteral be (value as numberLiteral))

  2. If ((numberLiteral matches pattern `%W%`)), then

    1. (Let (w w int) be numberLiteral)

    2. If ((int has type nat)), then

      1. (Let n be (int as nat))

      2. If ((nat = 0)), then

        1. If ((w > 0)), then

          1. If (((n \ 2) = 0)), then

            1. (Let value' be (((w - 1) w ((n / 2) as int)) as value))

            2. Return $tableEntry_lpm_prefix'(value', 0)

;; ../../../../spec-concrete/5.03-wellformed.watsup:5.1-7.20
relation Type_wf

  (match) bound | typeIR'''

    1. (Let typeIR be typeIR''')

    2. If ((typeIR has type baseTypeIR)), then

      1. (Let baseTypeIR be (typeIR as baseTypeIR))

      2. Try matching path basetype

    3. (Let typeIR be typeIR''')

    4. If ((typeIR has type namedTypeIR)), then

      1. (Let namedTypeIR be (typeIR as namedTypeIR))

      2. If ((namedTypeIR matches pattern `TID%`)), then

        1. (Let (tid tid) be namedTypeIR)

        2. Try matching path tid

    5. (Let typeIR' be typeIR''')

    6. If ((typeIR' has type namedTypeIR)), then

      1. (Let namedTypeIR be (typeIR' as namedTypeIR))

      2. If ((namedTypeIR matches pattern `%<%>`)), then

        1. (Let (polyTypeDefIR < typeIR_arg* >) be namedTypeIR)

        2. Try matching path spectype

    7. (Let typeIR' be typeIR''')

    8. If ((typeIR' has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

        1. (Let (typedef _tid typeIR) be aliasTypeIR)

        2. Try matching path typedeftype

    9. (Let typeIR' be typeIR''')

    10. If ((typeIR' has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

        1. (Let (type _tid typeIR) be aliasTypeIR)

        2. Try matching path newtype

    11. (Let typeIR' be typeIR''')

    12. If ((typeIR' has type listTypeIR)), then

      1. (Let (list< typeIR >) be (typeIR' as listTypeIR))

      2. Try matching path listttype

    13. (Let typeIR' be typeIR''')

    14. If ((typeIR' has type tupleTypeIR)), then

      1. (Let (tuple< typeIR* >) be (typeIR' as tupleTypeIR))

      2. Try matching path tupletype

    15. (Let typeIR' be typeIR''')

    16. If ((typeIR' has type headerStackTypeIR)), then

      1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

      2. Try matching path stacktype

    17. (Let typeIR' be typeIR''')

    18. If ((typeIR' has type structTypeIR)), then

      1. (Let (struct _tid { (typeIR id ;)* }) be (typeIR' as structTypeIR))

      2. Try matching path structtype

    19. (Let typeIR' be typeIR''')

    20. If ((typeIR' has type headerTypeIR)), then

      1. (Let (header _tid { (typeIR id ;)* }) be (typeIR' as headerTypeIR))

      2. Try matching path headertype

    21. (Let typeIR' be typeIR''')

    22. If ((typeIR' has type headerUnionTypeIR)), then

      1. (Let (header_union _tid { (typeIR id ;)* }) be (typeIR' as headerUnionTypeIR))

      2. Try matching path headeruniontype

    23. (Let typeIR be typeIR''')

    24. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

        1. (Let (enum _tid { id* }) be enumTypeIR)

        2. Try matching path enumtype

    25. (Let typeIR' be typeIR''')

    26. If ((typeIR' has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR' as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR { (id = _value ;)* }) be enumTypeIR)

        2. Try matching path serenumtype

    27. (Let typeIR be typeIR''')

    28. If ((typeIR has type externObjectTypeIR)), then

      1. (Let (extern _tid ({ (_rid : routineTypeDefIR)* })) be (typeIR as externObjectTypeIR))

      2. Try matching path externtype

    29. (Let typeIR be typeIR''')

    30. If ((typeIR has type parserObjectTypeIR)), then

      1. (Let (parser( parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

      2. Try matching path parsertype

    31. (Let typeIR be typeIR''')

    32. If ((typeIR has type controlObjectTypeIR)), then

      1. (Let (control( parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

      2. Try matching path controltype

    33. (Let typeIR' be typeIR''')

    34. If ((typeIR' has type packageObjectTypeIR)), then

      1. (Let (package< typeIR* >) be (typeIR' as packageObjectTypeIR))

      2. Try matching path packagetype

    35. (Let typeIR' be typeIR''')

    36. If ((typeIR' has type tableObjectTypeIR)), then

      1. (Let (table _tid # typeIR) be (typeIR' as tableObjectTypeIR))

      2. Try matching path tabletype

    37. (Let typeIR be typeIR''')

    38. If ((typeIR = ((default) as typeIR))), then

      1. Try matching path defaulttype

    39. (Let typeIR' be typeIR''')

    40. If ((typeIR' has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

        1. (Let (seq< typeIR* >) be sequenceTypeIR)

        2. Try matching path sequencetype

    41. (Let typeIR' be typeIR''')

    42. If ((typeIR' has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

        1. (Let (seq< typeIR* ,...>) be sequenceTypeIR)

        2. Try matching path sequencedefaulttype

    43. (Let typeIR' be typeIR''')

    44. If ((typeIR' has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR' as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%}`)), then

        1. (Let (record{ (typeIR id ;)* }) be recordTypeIR)

        2. Try matching path recordtype

    45. (Let typeIR' be typeIR''')

    46. If ((typeIR' has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR' as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

        1. (Let (record{ (typeIR id ;)* ,...}) be recordTypeIR)

        2. Try matching path recorddefaulttype

    47. (Let typeIR be typeIR''')

    48. If ((typeIR = ((header_invalid) as typeIR))), then

      1. Try matching path invalidtype

    49. (Let typeIR'' be typeIR''')

    50. If ((typeIR'' has type setTypeIR)), then

      1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

      2. If ((typeIR'* matches pattern [ _/1 ])), then

        1. (Let [typeIR] be typeIR'*)

        2. Try matching path settype

    51. (Let typeIR be typeIR''')

    52. If ((typeIR has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TABLE_ENUM%{%}`)), then

        1. (Let (table_enum _tid { id* }) be tableTypeIR)

        2. Try matching path tableenumtype

    53. (Let typeIR be typeIR''')

    54. If ((typeIR has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

        1. (Let (table_struct _tid { _fieldTypeIR* }) be tableTypeIR)

        2. Try matching path tablestructtype

  (path) basetype bound | (baseTypeIR as typeIR)

    1. The relation holds

  (path) tid bound | ((tid tid) as typeIR)

    1. If ($in_set<tid>(tid, bound)), then

      1. The relation holds

  (path) spectype bound | ((polyTypeDefIR < typeIR_arg* >) as typeIR)

    1. (Let typeIR be $specialize_typeDef((polyTypeDefIR as typeDefIR), typeIR_arg*))

    2. If ((Type_wf: bound |- typeIR holds)), then

      1. The relation holds

  (path) typedeftype bound | ((typedef _tid typeIR) as typeIR)

    1. If ($nestable_typedef(typeIR)), then

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. The relation holds

  (path) newtype bound | ((type _tid typeIR) as typeIR)

    1. If ($nestable_new(typeIR)), then

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. The relation holds

  (path) listttype bound | ((list< typeIR >) as typeIR)

    1. If ($nestable_list(typeIR)), then

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. The relation holds

  (path) tupletype bound | ((tuple< typeIR* >) as typeIR)

    1. If ($nestable_tuple(typeIR))*, then

      1. If ((Type_wf: bound |- typeIR holds))*, then

        1. The relation holds

  (path) stacktype bound | ((typeIR [ _nat ]) as typeIR)

    1. If ($nestable_stack(typeIR)), then

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. The relation holds

  (path) structtype bound | ((struct _tid { (typeIR id ;)* }) as typeIR)

    1. If ($distinct_<id>(id*)), then

      1. If ($nestable_struct(typeIR))*, then

        1. If ((Type_wf: bound |- typeIR holds))*, then

          1. The relation holds

  (path) headertype bound | ((header _tid { (typeIR id ;)* }) as typeIR)

    1. If ($distinct_<id>(id*)), then

      1. If ($nestable_header(typeIR))*, then

        1. If ((Type_wf: bound |- typeIR holds))*, then

          1. The relation holds

  (path) headeruniontype bound | ((header_union _tid { (typeIR id ;)* }) as typeIR)

    1. If ($distinct_<id>(id*)), then

      1. If ($nestable_headerunion(typeIR))*, then

        1. If ((Type_wf: bound |- typeIR holds))*, then

          1. The relation holds

  (path) enumtype bound | ((enum _tid { id* }) as typeIR)

    1. If ($distinct_<id>(id*)), then

      1. The relation holds

  (path) serenumtype bound | ((enum _tid # typeIR { (id = _value ;)* }) as typeIR)

    1. If ($distinct_<id>(id*)), then

      1. If ($nestable_serenum(typeIR)), then

        1. If ((Type_wf: bound |- typeIR holds)), then

          1. The relation holds

  (path) externtype bound | ((extern _tid ({ (_rid : routineTypeDefIR)* })) as typeIR)

    1. If ((RoutineTypeDef_wf: bound |- routineTypeDefIR holds))*, then

      1. The relation holds

  (path) parsertype bound | ((parser( parameterTypeIR* )) as typeIR)

    1. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. The relation holds

  (path) controltype bound | ((control( parameterTypeIR* )) as typeIR)

    1. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. The relation holds

  (path) packagetype bound | ((package< typeIR* >) as typeIR)

    1. If ((Type_wf: bound |- typeIR holds))*, then

      1. The relation holds

  (path) tabletype bound | ((table _tid # typeIR) as typeIR)

    1. (Let typeIR'' be $canon(typeIR))

    2. If ((typeIR'' has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR'' as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

        1. (Let (table_struct _tid' { _fieldTypeIR* }) be tableTypeIR)

        2. If ((Type_wf: bound |- typeIR holds)), then

          1. The relation holds

  (path) defaulttype bound | ((default) as typeIR)

    1. The relation holds

  (path) sequencetype bound | ((seq< typeIR* >) as typeIR)

    1. If ((Type_wf: bound |- typeIR holds))*, then

      1. The relation holds

  (path) sequencedefaulttype bound | ((seq< typeIR* ,...>) as typeIR)

    1. If ((Type_wf: bound |- typeIR holds))*, then

      1. The relation holds

  (path) recordtype bound | ((record{ (typeIR id ;)* }) as typeIR)

    1. If ($distinct_<id>(id*)), then

      1. If ((Type_wf: bound |- typeIR holds))*, then

        1. The relation holds

  (path) recorddefaulttype bound | ((record{ (typeIR id ;)* ,...}) as typeIR)

    1. If ($distinct_<id>(id*)), then

      1. If ((Type_wf: bound |- typeIR holds))*, then

        1. The relation holds

  (path) invalidtype bound | ((header_invalid) as typeIR)

    1. The relation holds

  (path) settype bound | ((set< [typeIR] >) as typeIR)

    1. If ($nestable_set(typeIR)), then

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. The relation holds

  (path) tableenumtype bound | ((table_enum _tid { id* }) as typeIR)

    1. If ($distinct_<id>(id*)), then

      1. The relation holds

  (path) tablestructtype bound | ((table_struct _tid { _fieldTypeIR* }) as typeIR)

    1. The relation holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:9.1-11.20
relation TypeDef_wf

  (match) bound | typeDefIR

    1. Case analysis on typeDefIR

      1. Case (% has type typeIR)

        1. (Let typeIR be (typeDefIR as typeIR))

        2. Try matching path mono

      2. Case (% has type polyTypeDefIR)

        1. (Let (typeIR < tid_expl* , tid_impl* >) be (typeDefIR as polyTypeDefIR))

        2. Try matching path poly

  (path) mono bound | (typeIR as typeDefIR)

    1. If ($definable_type_mono(typeIR)), then

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. The relation holds

  (path) poly bound | ((typeIR < tid_expl* , tid_impl* >) as typeDefIR)

    1. If ($definable_type_poly(typeIR)), then

      1. If ($distinct_<tid>(tid_expl* ++ tid_impl*)), then

        1. (Let bound_inner be $union_set<tid>(bound, ({ tid_expl* ++ tid_impl* })))

        2. If ((Type_wf: bound_inner |- typeIR holds)), then

          1. The relation holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:13.1-15.20
relation ParameterType_wf

  (match) bound | (direction typeIR _id value''?)

    1. (Let value be value'')?

    2. If ((direction matches pattern ``EMPTY`)), then

      1. If ((value? matches pattern ())), then

        1. Try matching path default-empty-extern

    3. (Let value be value'')?

    4. If ((value? matches pattern ())), then

      1. Try matching path default-none-not-extern

    5. (Let value' be value'')?

    6. If ((direction matches pattern ``EMPTY`)), then

      1. If ((value'? matches pattern (_))), then

        1. (Let ?(value) be value'?)

        2. Try matching path default-some-extern

    7. (Let value' be value'')?

    8. If ((value'? matches pattern (_))), then

      1. (Let ?(value) be value'?)

      2. Try matching path default-some-not-extern

  (path) default-empty-extern bound | (() typeIR _id ?())

    1. If ((Type_wf: bound |- typeIR holds)), then

      1. If ($is_extern_object_typeIR($canon(typeIR))), then

        1. The relation holds

  (path) default-none-not-extern bound | (direction typeIR _id ?())

    1. If ((Type_wf: bound |- typeIR holds)), then

      1. If (~$is_extern_object_typeIR($canon(typeIR))), then

        1. The relation holds

  (path) default-some-extern bound | (() typeIR _id ?(value))

    1. If ((Type_wf: bound |- typeIR holds)), then

      1. If ($is_extern_object_typeIR($canon(typeIR))), then

        1. The relation holds

  (path) default-some-not-extern bound | (direction typeIR _id ?(value))

    1. If ((Type_wf: bound |- typeIR holds)), then

      1. If (~$is_extern_object_typeIR($canon(typeIR))), then

        1. If (((direction = (in)) \/ (direction = ()))), then

          1. The relation holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:17.1-19.20
relation ParameterTypes_wf

  (match) bound | parameterTypeIR*

    1. Try matching path 

  (path)  bound | parameterTypeIR*

    1. (Let (_direction _typeIR id _value?) be parameterTypeIR)*

    2. If ($distinct_<id>(id*)), then

      1. If ((ParameterType_wf: bound |- parameterTypeIR holds))*, then

        1. The relation holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:21.1-23.20
relation RoutineType_wf

  (match) bound | routineTypeIR

    1. Case analysis on routineTypeIR

      1. Case (% has type functionTypeIR)

        1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

        2. Case analysis on functionTypeIR

          1. Case (% matches pattern `BUILTIN_FUNCTION(%)->%`)

            1. (Let (builtin_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

            2. Try matching path builtinfunction

          2. Case (% matches pattern `FUNCTION(%)->%`)

            1. (Let (function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

            2. Try matching path functiontype

          3. Case (% matches pattern `ACTION(%)`)

            1. (Let (action( parameterTypeIR* )) be functionTypeIR)

            2. Try matching path actiontype

          4. Case (% matches pattern `EXTERN_FUNCTION(%)->%`)

            1. (Let (extern_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

            2. Try matching path externfunctiontype

      2. Case (% has type methodTypeIR)

        1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

        2. Case analysis on methodTypeIR

          1. Case (% matches pattern `BUILTIN_METHOD(%)->%`)

            1. (Let (builtin_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

            2. Try matching path builtinmethod

          2. Case (% matches pattern `EXTERN_METHOD(%)->%`)

            1. (Let (extern_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

            2. Try matching path externmethod

          3. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

            1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

            2. Try matching path externabstractmethod

          4. Case (% matches pattern `PARSER_APPLY(%)`)

            1. (Let (parser_apply( parameterTypeIR* )) be methodTypeIR)

            2. Try matching path parserapplymethod

          5. Case (% matches pattern `CONTROL_APPLY(%)`)

            1. (Let (control_apply( parameterTypeIR* )) be methodTypeIR)

            2. Try matching path controlapplymethod

          6. Case (% matches pattern `TABLE_APPLY->%`)

            1. (Let (table_apply-> typeIR) be methodTypeIR)

            2. If ((typeIR has type tableTypeIR)), then

              1. (Let tableTypeIR be (typeIR as tableTypeIR))

              2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

                1. (Let (table_struct _tid { _fieldTypeIR* }) be tableTypeIR)

                2. Try matching path tableapplymethod

  (path) builtinfunction bound | ((builtin_function( parameterTypeIR* )-> typeIR_ret) as routineTypeIR)

    1. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. If ((Type_wf: bound |- typeIR_ret holds)), then

        1. The relation holds

  (path) functiontype bound | ((function( parameterTypeIR* )-> typeIR_ret) as routineTypeIR)

    1. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

      2. If ($nestable_function(direction, typeIR))*, then

        1. If ((Type_wf: bound |- typeIR_ret holds)), then

          1. The relation holds

  (path) actiontype bound | ((action( parameterTypeIR* )) as routineTypeIR)

    1. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

      2. If ($directionless_trailing(direction*)), then

        1. If ($nestable_action(direction, typeIR))*, then

          1. The relation holds

  (path) externfunctiontype bound | ((extern_function( parameterTypeIR* )-> typeIR_ret) as routineTypeIR)

    1. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

      2. If ($nestable_externfunction(direction, typeIR))*, then

        1. If ((Type_wf: bound |- typeIR_ret holds)), then

          1. The relation holds

  (path) builtinmethod bound | ((builtin_method( parameterTypeIR* )-> typeIR_ret) as routineTypeIR)

    1. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. If ((Type_wf: bound |- typeIR_ret holds)), then

        1. The relation holds

  (path) externmethod bound | ((extern_method( parameterTypeIR* )-> typeIR_ret) as routineTypeIR)

    1. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

      2. If ($nestable_externmethod(direction, typeIR))*, then

        1. If ((Type_wf: bound |- typeIR_ret holds)), then

          1. The relation holds

  (path) externabstractmethod bound | ((extern_methodabstract( parameterTypeIR* )-> typeIR_ret) as routineTypeIR)

    1. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

      2. If ($nestable_externabstractmethod(direction, typeIR))*, then

        1. If ((Type_wf: bound |- typeIR_ret holds)), then

          1. The relation holds

  (path) parserapplymethod bound | ((parser_apply( parameterTypeIR* )) as routineTypeIR)

    1. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

      2. If ($nestable_parserapplymethod(direction, typeIR))*, then

        1. The relation holds

  (path) controlapplymethod bound | ((control_apply( parameterTypeIR* )) as routineTypeIR)

    1. If ((ParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. (Let (direction typeIR _id _value?) be parameterTypeIR)*

      2. If ($nestable_controlapplymethod(direction, typeIR))*, then

        1. The relation holds

  (path) tableapplymethod bound | ((table_apply-> ((table_struct _tid { _fieldTypeIR* }) as typeIR)) as routineTypeIR)

    1. The relation holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:25.1-27.20
relation RoutineTypeDef_wf

  (match) bound | routineTypeDefIR

    1. Case analysis on routineTypeDefIR

      1. Case (% has type routineTypeIR)

        1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

        2. Try matching path mono

      2. Case (% has type polyRoutineTypeDefIR)

        1. (Let (routineTypeIR < tid_expl* , tid_impl* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

        2. Try matching path poly

  (path) mono bound | (routineTypeIR as routineTypeDefIR)

    1. If ($definable_routine_mono(routineTypeIR)), then

      1. If ((RoutineType_wf: bound |- routineTypeIR holds)), then

        1. The relation holds

  (path) poly bound | ((routineTypeIR < tid_expl* , tid_impl* >) as routineTypeDefIR)

    1. If ($definable_routine_poly(routineTypeIR)), then

      1. If ($distinct_<tid>(tid_expl* ++ tid_impl*)), then

        1. (Let bound_inner be $union_set<tid>(bound, ({ tid_expl* ++ tid_impl* })))

        2. If ((RoutineType_wf: bound_inner |- routineTypeIR holds)), then

          1. The relation holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:29.1-31.20
relation ConstructorParameterType_wf

  (match) bound | (direction typeIR _id _value?)

    1. If ((direction matches pattern ``EMPTY`)), then

      1. Try matching path 

  (path)  bound | (() typeIR _id _value?)

    1. If ((Type_wf: bound |- typeIR holds)), then

      1. The relation holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:33.1-35.20
relation ConstructorParameterTypes_wf

  (match) bound | parameterTypeIR*

    1. Try matching path 

  (path)  bound | parameterTypeIR*

    1. (Let (_direction _typeIR id _value?) be parameterTypeIR)*

    2. If ($distinct_<id>(id*)), then

      1. If ((ConstructorParameterType_wf: bound |- parameterTypeIR holds))*, then

        1. The relation holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:37.1-39.20
relation ConstructorType_wf

  (match) bound | (constructor( parameterTypeIR* )-> typeIR_object)

    1. Try matching path externtype

    2. Try matching path parsertype

    3. Try matching path controltype

    4. Try matching path packagetype

  (path) externtype bound | (constructor( parameterTypeIR* )-> typeIR_object)

    1. If ((ConstructorParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. If ((Type_wf: bound |- typeIR_object holds)), then

        1. (Let typeIR' be $canon(typeIR_object))

        2. If ((typeIR' has type externObjectTypeIR)), then

          1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR' as externObjectTypeIR))

          2. (Let (_direction typeIR _id _value?) be parameterTypeIR)*

          3. If ($nestable_constructor_extern(typeIR))*, then

            1. The relation holds

  (path) parsertype bound | (constructor( parameterTypeIR* )-> typeIR_object)

    1. If ((ConstructorParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. If ((Type_wf: bound |- typeIR_object holds)), then

        1. (Let typeIR' be $canon(typeIR_object))

        2. If ((typeIR' has type parserObjectTypeIR)), then

          1. (Let (parser( _parameterTypeIR* )) be (typeIR' as parserObjectTypeIR))

          2. (Let (_direction typeIR _id _value?) be parameterTypeIR)*

          3. If ($nestable_constructor_parser(typeIR))*, then

            1. The relation holds

  (path) controltype bound | (constructor( parameterTypeIR* )-> typeIR_object)

    1. If ((ConstructorParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. If ((Type_wf: bound |- typeIR_object holds)), then

        1. (Let typeIR' be $canon(typeIR_object))

        2. If ((typeIR' has type controlObjectTypeIR)), then

          1. (Let (control( _parameterTypeIR* )) be (typeIR' as controlObjectTypeIR))

          2. (Let (_direction typeIR _id _value?) be parameterTypeIR)*

          3. If ($nestable_constructor_control(typeIR))*, then

            1. The relation holds

  (path) packagetype bound | (constructor( parameterTypeIR* )-> typeIR_object)

    1. If ((ConstructorParameterTypes_wf: bound |- parameterTypeIR* holds)), then

      1. If ((Type_wf: bound |- typeIR_object holds)), then

        1. (Let typeIR' be $canon(typeIR_object))

        2. If ((typeIR' has type packageObjectTypeIR)), then

          1. (Let (package< _typeIR* >) be (typeIR' as packageObjectTypeIR))

          2. (Let (_direction typeIR _id _value?) be parameterTypeIR)*

          3. If ($nestable_constructor_package(typeIR))*, then

            1. The relation holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:41.1-43.20
relation ConstructorTypeDef_wf

  (match) bound | (constructorTypeIR < tid_expl* , tid_impl* >)

    1. Try matching path 

  (path)  bound | (constructorTypeIR < tid_expl* , tid_impl* >)

    1. (Let (constructor( _constructorParameterTypeIR* )-> typeIR_object) be constructorTypeIR)

    2. If ($definable_constructor(typeIR_object)), then

      1. If ($distinct_<tid>(tid_expl* ++ tid_impl*)), then

        1. (Let bound_inner be $union_set<tid>(bound, ({ tid_expl* ++ tid_impl* })))

        2. If ((ConstructorType_wf: bound_inner |- constructorTypeIR holds)), then

          1. The relation holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:98.1-98.37
def $nestable_typedef(typeIR)

1. Return $nestable'_typedef($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:99.1-99.38
def $nestable'_typedef(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR')

4. If ((typeIR = ((error) as typeIR))), then

  1. Return true

5. (Let typeIR be typeIR')

6. If ((typeIR = ((string) as typeIR))), then

  1. Return true

7. (Let typeIR be typeIR')

8. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Return true

9. (Let typeIR be typeIR')

10. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

11. (Let typeIR be typeIR')

12. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid _typeIR) be aliasTypeIR)

    2. Return true

13. (Let typeIR be typeIR')

14. If ((typeIR has type dataTypeIR)), then

  1. (Let dataTypeIR be (typeIR as dataTypeIR))

  2. Return true

15. (Let _typeIR be typeIR')

16. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:117.1-117.33
def $nestable_new(typeIR)

1. Return $nestable'_new($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:118.1-118.34
def $nestable'_new(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR')

4. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

5. (Let typeIR be typeIR')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

7. (Let typeIR be typeIR')

8. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

9. (Let typeIR be typeIR')

10. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid _typeIR) be aliasTypeIR)

    2. Return true

11. (Let _typeIR be typeIR')

12. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:136.1-136.34
def $nestable_list(typeIR)

1. Return $nestable'_list($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:137.1-137.35
def $nestable'_list(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR')

4. If ((typeIR = ((error) as typeIR))), then

  1. Return true

5. (Let typeIR be typeIR')

6. If ((typeIR = ((match_kind) as typeIR))), then

  1. Return true

7. (Let typeIR be typeIR')

8. If ((typeIR = ((string) as typeIR))), then

  1. Return true

9. (Let typeIR be typeIR')

10. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Return true

11. (Let typeIR be typeIR')

12. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

13. (Let typeIR be typeIR')

14. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid _typeIR) be aliasTypeIR)

    2. Return true

15. (Let typeIR be typeIR')

16. If ((typeIR has type dataTypeIR)), then

  1. (Let dataTypeIR be (typeIR as dataTypeIR))

  2. Return true

17. (Let _typeIR be typeIR')

18. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:156.1-156.35
def $nestable_tuple(typeIR)

1. Return $nestable'_tuple($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:157.1-157.36
def $nestable'_tuple(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR'')

4. If ((typeIR = ((error) as typeIR))), then

  1. Return true

5. (Let typeIR be typeIR'')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

7. (Let typeIR be typeIR'')

8. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

9. (Let typeIR be typeIR'')

10. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `VARBIT<%>`)), then

    1. (Let (varbit< _nat >) be numberTypeIR)

    2. Return true

11. (Let typeIR be typeIR'')

12. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

13. (Let typeIR be typeIR'')

14. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid _typeIR) be aliasTypeIR)

    2. Return true

15. (Let typeIR be typeIR'')

16. If ((typeIR has type tupleTypeIR)), then

  1. (Let (tuple< _typeIR* >) be (typeIR as tupleTypeIR))

  2. Return true

17. (Let typeIR' be typeIR'')

18. If ((typeIR' has type headerStackTypeIR)), then

  1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

  2. Return true

19. (Let typeIR be typeIR'')

20. If ((typeIR has type headerTypeIR)), then

  1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

  2. Return true

21. (Let typeIR be typeIR'')

22. If ((typeIR has type headerUnionTypeIR)), then

  1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR as headerUnionTypeIR))

  2. Return true

23. (Let typeIR be typeIR'')

24. If ((typeIR has type structTypeIR)), then

  1. (Let (struct _tid { _fieldTypeIR* }) be (typeIR as structTypeIR))

  2. Return true

25. (Let typeIR be typeIR'')

26. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

    1. (Let (enum _tid { _id* }) be enumTypeIR)

    2. Return true

27. (Let typeIR be typeIR'')

28. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return true

29. (Let _typeIR be typeIR'')

30. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:182.1-182.35
def $nestable_stack(typeIR)

1. Return $nestable'_stack($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:183.1-183.36
def $nestable'_stack(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

3. (Let typeIR be typeIR')

4. If ((typeIR has type headerTypeIR)), then

  1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

  2. Return true

5. (Let typeIR be typeIR')

6. If ((typeIR has type headerUnionTypeIR)), then

  1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR as headerUnionTypeIR))

  2. Return true

7. (Let _typeIR be typeIR')

8. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:197.1-197.36
def $nestable_struct(typeIR)

1. Return $nestable'_struct($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:198.1-198.37
def $nestable'_struct(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR'')

4. If ((typeIR = ((error) as typeIR))), then

  1. Return true

5. (Let typeIR be typeIR'')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

7. (Let typeIR be typeIR'')

8. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

9. (Let typeIR be typeIR'')

10. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `VARBIT<%>`)), then

    1. (Let (varbit< _nat >) be numberTypeIR)

    2. Return true

11. (Let typeIR be typeIR'')

12. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

13. (Let typeIR be typeIR'')

14. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid _typeIR) be aliasTypeIR)

    2. Return true

15. (Let typeIR be typeIR'')

16. If ((typeIR has type tupleTypeIR)), then

  1. (Let (tuple< _typeIR* >) be (typeIR as tupleTypeIR))

  2. Return true

17. (Let typeIR' be typeIR'')

18. If ((typeIR' has type headerStackTypeIR)), then

  1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

  2. Return true

19. (Let typeIR be typeIR'')

20. If ((typeIR has type structTypeIR)), then

  1. (Let (struct _tid { _fieldTypeIR* }) be (typeIR as structTypeIR))

  2. Return true

21. (Let typeIR be typeIR'')

22. If ((typeIR has type headerTypeIR)), then

  1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

  2. Return true

23. (Let typeIR be typeIR'')

24. If ((typeIR has type headerUnionTypeIR)), then

  1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR as headerUnionTypeIR))

  2. Return true

25. (Let typeIR be typeIR'')

26. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

    1. (Let (enum _tid { _id* }) be enumTypeIR)

    2. Return true

27. (Let typeIR be typeIR'')

28. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return true

29. (Let _typeIR be typeIR'')

30. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:224.1-224.36
def $nestable_header(typeIR)

1. Return $nestable'_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:225.1-225.37
def $nestable'_header(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR'')

4. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

5. (Let typeIR be typeIR'')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

7. (Let typeIR be typeIR'')

8. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `VARBIT<%>`)), then

    1. (Let (varbit< _nat >) be numberTypeIR)

    2. Return true

9. (Let typeIR be typeIR'')

10. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

11. (Let typeIR be typeIR'')

12. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid _typeIR) be aliasTypeIR)

    2. Return true

13. (Let typeIR be typeIR'')

14. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return true

15. (Let typeIR' be typeIR'')

16. If ((typeIR' has type structTypeIR)), then

  1. (Let (struct _tid { (typeIR _id ;)* }) be (typeIR' as structTypeIR))

  2. If ($nestable_struct_in_header(typeIR))*, then

    1. Return true

17. (Let _typeIR be typeIR'')

18. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:226.1-226.46
def $nestable_struct_in_header(typeIR)

1. Return $nestable'_struct_in_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:227.1-227.47
def $nestable'_struct_in_header(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR'')

4. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

5. (Let typeIR be typeIR'')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

7. (Let typeIR be typeIR'')

8. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

9. (Let typeIR be typeIR'')

10. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid _typeIR) be aliasTypeIR)

    2. Return true

11. (Let typeIR be typeIR'')

12. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return true

13. (Let typeIR' be typeIR'')

14. If ((typeIR' has type structTypeIR)), then

  1. (Let (struct _tid { (typeIR _id ;)* }) be (typeIR' as structTypeIR))

  2. If ($nestable_struct_in_header(typeIR))*, then

    1. Return true

15. (Let _typeIR be typeIR'')

16. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:261.1-261.41
def $nestable_headerunion(typeIR)

1. Return $nestable'_headerunion($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:262.1-262.42
def $nestable'_headerunion(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

3. (Let typeIR be typeIR')

4. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid _typeIR) be aliasTypeIR)

    2. Return true

5. (Let typeIR be typeIR')

6. If ((typeIR has type headerTypeIR)), then

  1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

  2. Return true

7. (Let _typeIR be typeIR')

8. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:282.1-282.37
def $nestable_serenum(typeIR)

1. Return $nestable'_serenum($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:283.1-283.38
def $nestable'_serenum(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

3. (Let typeIR be typeIR'')

4. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

5. (Let typeIR be typeIR'')

6. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

7. (Let typeIR' be typeIR'')

8. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid typeIR) be aliasTypeIR)

    2. Return $nestable_new_in_serenum(typeIR)

9. (Let _typeIR be typeIR'')

10. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:284.1-284.44
def $nestable_new_in_serenum(typeIR)

1. Return $nestable_new_in_serenum'($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:285.1-285.45
def $nestable_new_in_serenum'(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

3. (Let typeIR be typeIR')

4. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

5. (Let typeIR be typeIR')

6. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

7. (Let typeIR be typeIR')

8. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid _typeIR) be aliasTypeIR)

    2. Return true

9. (Let _typeIR be typeIR')

10. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:361.1-361.33
def $nestable_set(typeIR)

1. Return $nestable'_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:362.1-362.34
def $nestable'_set(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR'')

4. If ((typeIR = ((error) as typeIR))), then

  1. Return true

5. (Let typeIR be typeIR'')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

7. (Let typeIR be typeIR'')

8. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

9. (Let typeIR be typeIR'')

10. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

11. (Let typeIR be typeIR'')

12. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid _typeIR) be aliasTypeIR)

    2. Return true

13. (Let typeIR' be typeIR'')

14. If ((typeIR' has type tupleTypeIR)), then

  1. (Let (tuple< typeIR* >) be (typeIR' as tupleTypeIR))

  2. If ($nestable_tuple_in_set(typeIR))*, then

    1. Return true

15. (Let typeIR be typeIR'')

16. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

    1. (Let (enum _tid { _id* }) be enumTypeIR)

    2. Return true

17. (Let typeIR be typeIR'')

18. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return true

19. (Let typeIR' be typeIR'')

20. If ((typeIR' has type sequenceTypeIR)), then

  1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

  2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

    1. (Let (seq< typeIR* >) be sequenceTypeIR)

    2. If ($nestable_sequence_in_set(typeIR))*, then

      1. Return true

21. (Let _typeIR be typeIR'')

22. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:363.1-363.42
def $nestable_tuple_in_set(typeIR)

1. Return $nestable'_tuple_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:364.1-364.43
def $nestable'_tuple_in_set(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR'')

4. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

5. (Let typeIR be typeIR'')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

7. (Let typeIR be typeIR'')

8. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

9. (Let typeIR be typeIR'')

10. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid _typeIR) be aliasTypeIR)

    2. Return true

11. (Let typeIR' be typeIR'')

12. If ((typeIR' has type tupleTypeIR)), then

  1. (Let (tuple< typeIR* >) be (typeIR' as tupleTypeIR))

  2. If ($nestable_tuple_in_set(typeIR))*, then

    1. Return true

13. (Let typeIR be typeIR'')

14. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

    1. (Let (enum _tid { _id* }) be enumTypeIR)

    2. Return true

15. (Let typeIR be typeIR'')

16. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return true

17. (Let _typeIR be typeIR'')

18. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:365.1-365.45
def $nestable_sequence_in_set(typeIR)

1. Return $nestable'_sequence_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:366.1-366.46
def $nestable'_sequence_in_set(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR'')

4. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

5. (Let typeIR be typeIR'')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

7. (Let typeIR be typeIR'')

8. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

9. (Let typeIR be typeIR'')

10. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid _typeIR) be aliasTypeIR)

    2. Return true

11. (Let typeIR' be typeIR'')

12. If ((typeIR' has type tupleTypeIR)), then

  1. (Let (tuple< typeIR* >) be (typeIR' as tupleTypeIR))

  2. If ($nestable_sequence_in_set(typeIR))*, then

    1. Return true

13. (Let typeIR be typeIR'')

14. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

    1. (Let (enum _tid { _id* }) be enumTypeIR)

    2. Return true

15. (Let typeIR be typeIR'')

16. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return true

17. (Let typeIR' be typeIR'')

18. If ((typeIR' has type sequenceTypeIR)), then

  1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

  2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

    1. (Let (seq< typeIR* >) be sequenceTypeIR)

    2. If ($nestable_sequence_in_set(typeIR))*, then

      1. Return true

19. (Let _typeIR be typeIR'')

20. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:430.1-430.40
def $definable_type_mono(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid _tid) be namedTypeIR)

    2. Return true

3. (Let typeIR be typeIR')

4. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. Return true

5. (Let typeIR be typeIR')

6. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

    1. (Let (enum _tid { _id* }) be enumTypeIR)

    2. Return true

7. (Let typeIR be typeIR')

8. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return true

9. (Let typeIR be typeIR')

10. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

  2. Return true

11. (Let _typeIR be typeIR')

12. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:445.1-445.40
def $definable_type_poly(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR has type tupleTypeIR)), then

  1. (Let (tuple< _typeIR* >) be (typeIR as tupleTypeIR))

  2. Return true

3. (Let typeIR be typeIR')

4. If ((typeIR has type headerStackTypeIR)), then

  1. (Let (_typeIR [ _nat ]) be (typeIR as headerStackTypeIR))

  2. Return true

5. (Let typeIR be typeIR')

6. If ((typeIR has type headerTypeIR)), then

  1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

  2. Return true

7. (Let typeIR be typeIR')

8. If ((typeIR has type headerUnionTypeIR)), then

  1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR as headerUnionTypeIR))

  2. Return true

9. (Let typeIR be typeIR')

10. If ((typeIR has type structTypeIR)), then

  1. (Let (struct _tid { _fieldTypeIR* }) be (typeIR as structTypeIR))

  2. Return true

11. (Let typeIR be typeIR')

12. If ((typeIR has type externObjectTypeIR)), then

  1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR as externObjectTypeIR))

  2. Return true

13. (Let typeIR be typeIR')

14. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. Return true

15. (Let typeIR be typeIR')

16. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

  2. Return true

17. (Let typeIR be typeIR')

18. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

  2. Return true

19. (Let _typeIR be typeIR')

20. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:478.1-478.49
def $nestable_function(direction, typeIR)

1. Return $nestable_function'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:479.1-479.50
def $nestable_function'(direction', typeIR')

1. (Let direction be direction')

2. (Let typeIR be typeIR')

3. If ((typeIR = ((string) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

4. (Let direction be direction')

5. (Let typeIR be typeIR')

6. If ((typeIR = ((int) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

7. (Let direction be direction')

8. (Let typeIR be typeIR')

9. If ((typeIR has type objectTypeIR)), then

  1. (Let objectTypeIR be (typeIR as objectTypeIR))

  2. Return false

10. (Let _direction be direction')

11. (Let _typeIR be typeIR')

12. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:498.1-498.47
def $directionless_trailing(direction*)

1. Return $directionless_trailing'(true, $rev_<direction>(direction*))

;; ../../../../spec-concrete/5.03-wellformed.watsup:499.1-499.54
def $directionless_trailing'(_bool', direction''*)

1. (Let _bool be _bool')

2. (Let direction be direction'')*

3. If ((direction* matches pattern [])), then

  1. Return true

4. (Let bool be _bool')

5. (Let direction' be direction'')*

6. If ((bool = true)), then

  1. If ((direction'* matches pattern _ :: _)), then

    1. (Let direction :: direction_t* be direction'*)

    2. If ((direction matches pattern ``EMPTY`)), then

      1. Return $directionless_trailing'(true, direction_t*)

7. (Let bool be _bool')

8. (Let direction' be direction'')*

9. If ((bool = false)), then

  1. If ((direction'* matches pattern _ :: _)), then

    1. (Let direction :: direction_t* be direction'*)

    2. If ((direction matches pattern ``EMPTY`)), then

      1. Return false

10. (Let _bool be _bool')

11. (Let direction be direction'')*

12. If ((direction* matches pattern _ :: _)), then

  1. (Let direction_h :: direction_t* be direction*)

  2. If (~(direction_h matches pattern ``EMPTY`)), then

    1. Return $directionless_trailing'(false, direction_t*)

;; ../../../../spec-concrete/5.03-wellformed.watsup:512.1-512.47
def $nestable_action(direction, typeIR)

1. Return $nestable_action'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:513.1-513.48
def $nestable_action'(direction', typeIR')

1. (Let direction be direction')

2. (Let typeIR be typeIR')

3. If ((typeIR = ((string) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

4. (Let _direction be direction')

5. (Let typeIR be typeIR')

6. If ((typeIR = ((int) as typeIR))), then

  1. Return false

7. (Let _direction be direction')

8. (Let typeIR be typeIR')

9. If ((typeIR has type objectTypeIR)), then

  1. (Let objectTypeIR be (typeIR as objectTypeIR))

  2. Return false

10. (Let _direction be direction')

11. (Let _typeIR be typeIR')

12. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:531.1-531.55
def $nestable_externfunction(direction, typeIR)

1. Return $nestable_externfunction'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:532.1-532.56
def $nestable_externfunction'(direction', typeIR')

1. (Let direction be direction')

2. (Let typeIR be typeIR')

3. If ((typeIR = ((string) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

4. (Let direction be direction')

5. (Let typeIR be typeIR')

6. If ((typeIR = ((int) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

7. (Let direction be direction')

8. (Let typeIR be typeIR')

9. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. Return false

10. (Let direction be direction')

11. (Let typeIR be typeIR')

12. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

  2. Return false

13. (Let direction be direction')

14. (Let typeIR be typeIR')

15. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

  2. Return false

16. (Let direction be direction')

17. (Let typeIR be typeIR')

18. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

  2. Return false

19. (Let _direction be direction')

20. (Let _typeIR be typeIR')

21. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:561.1-561.53
def $nestable_externmethod(direction, typeIR)

1. Return $nestable_externmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:562.1-562.54
def $nestable_externmethod'(direction', typeIR')

1. (Let direction be direction')

2. (Let typeIR be typeIR')

3. If ((typeIR = ((string) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

4. (Let direction be direction')

5. (Let typeIR be typeIR')

6. If ((typeIR = ((int) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

7. (Let direction be direction')

8. (Let typeIR be typeIR')

9. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. Return false

10. (Let direction be direction')

11. (Let typeIR be typeIR')

12. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

  2. Return false

13. (Let direction be direction')

14. (Let typeIR be typeIR')

15. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

  2. Return false

16. (Let direction be direction')

17. (Let typeIR be typeIR')

18. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

  2. Return false

19. (Let _direction be direction')

20. (Let _typeIR be typeIR')

21. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:584.1-584.61
def $nestable_externabstractmethod(direction, typeIR)

1. Return $nestable_externabstractmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:585.1-585.62
def $nestable_externabstractmethod'(direction', typeIR')

1. (Let direction be direction')

2. (Let typeIR be typeIR')

3. If ((typeIR = ((string) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

4. (Let direction be direction')

5. (Let typeIR be typeIR')

6. If ((typeIR = ((int) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

7. (Let direction be direction')

8. (Let typeIR be typeIR')

9. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. Return false

10. (Let direction be direction')

11. (Let typeIR be typeIR')

12. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

  2. Return false

13. (Let direction be direction')

14. (Let typeIR be typeIR')

15. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

  2. Return false

16. (Let direction be direction')

17. (Let typeIR be typeIR')

18. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

  2. Return false

19. (Let _direction be direction')

20. (Let _typeIR be typeIR')

21. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:607.1-607.58
def $nestable_parserapplymethod(direction, typeIR)

1. Return $nestable_parserapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:608.1-608.59
def $nestable_parserapplymethod'(direction', typeIR')

1. (Let direction be direction')

2. (Let typeIR be typeIR')

3. If ((typeIR = ((string) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

4. (Let direction be direction')

5. (Let typeIR be typeIR')

6. If ((typeIR = ((int) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

7. (Let direction be direction')

8. (Let typeIR be typeIR')

9. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. Return false

10. (Let direction be direction')

11. (Let typeIR be typeIR')

12. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

  2. Return false

13. (Let direction be direction')

14. (Let typeIR be typeIR')

15. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

  2. Return false

16. (Let direction be direction')

17. (Let typeIR be typeIR')

18. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

  2. Return false

19. (Let _direction be direction')

20. (Let _typeIR be typeIR')

21. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:629.1-629.59
def $nestable_controlapplymethod(direction, typeIR)

1. Return $nestable_controlapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:630.1-630.60
def $nestable_controlapplymethod'(direction', typeIR')

1. (Let direction be direction')

2. (Let typeIR be typeIR')

3. If ((typeIR = ((string) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

4. (Let direction be direction')

5. (Let typeIR be typeIR')

6. If ((typeIR = ((int) as typeIR))), then

  1. If (~(direction matches pattern ``EMPTY`)), then

    1. Return false

7. (Let direction be direction')

8. (Let typeIR be typeIR')

9. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. Return false

10. (Let direction be direction')

11. (Let typeIR be typeIR')

12. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

  2. Return false

13. (Let direction be direction')

14. (Let typeIR be typeIR')

15. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

  2. Return false

16. (Let _direction be direction')

17. (Let _typeIR be typeIR')

18. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:657.1-657.50
def $definable_routine_mono(routineTypeIR')

1. (Let routineTypeIR be routineTypeIR')

2. If ((routineTypeIR has type functionTypeIR)), then

  1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

  2. If ((functionTypeIR matches pattern `BUILTIN_FUNCTION(%)->%`)), then

    1. (Let (builtin_function( _parameterTypeIR* )-> _typeIR) be functionTypeIR)

    2. Return true

3. (Let routineTypeIR be routineTypeIR')

4. If ((routineTypeIR has type functionTypeIR)), then

  1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

  2. If ((functionTypeIR matches pattern `ACTION(%)`)), then

    1. (Let (action( _parameterTypeIR* )) be functionTypeIR)

    2. Return true

5. (Let routineTypeIR be routineTypeIR')

6. If ((routineTypeIR has type methodTypeIR)), then

  1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

  2. If ((methodTypeIR matches pattern `BUILTIN_METHOD(%)->%`)), then

    1. (Let (builtin_method( _parameterTypeIR* )-> _typeIR) be methodTypeIR)

    2. Return true

7. (Let routineTypeIR be routineTypeIR')

8. If ((routineTypeIR has type methodTypeIR)), then

  1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

  2. If ((methodTypeIR matches pattern `PARSER_APPLY(%)`)), then

    1. (Let (parser_apply( _parameterTypeIR* )) be methodTypeIR)

    2. Return true

9. (Let routineTypeIR be routineTypeIR')

10. If ((routineTypeIR has type methodTypeIR)), then

  1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

  2. If ((methodTypeIR matches pattern `CONTROL_APPLY(%)`)), then

    1. (Let (control_apply( _parameterTypeIR* )) be methodTypeIR)

    2. Return true

11. (Let routineTypeIR be routineTypeIR')

12. If ((routineTypeIR has type methodTypeIR)), then

  1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

  2. If ((methodTypeIR matches pattern `TABLE_APPLY->%`)), then

    1. (Let (table_apply-> _typeIR) be methodTypeIR)

    2. Return true

13. (Let _routineTypeIR be routineTypeIR')

14. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:673.1-673.50
def $definable_routine_poly(routineTypeIR')

1. (Let routineTypeIR be routineTypeIR')

2. If ((routineTypeIR has type functionTypeIR)), then

  1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

  2. If ((functionTypeIR matches pattern `FUNCTION(%)->%`)), then

    1. (Let (function( _parameterTypeIR* )-> _typeIR) be functionTypeIR)

    2. Return true

3. (Let routineTypeIR be routineTypeIR')

4. If ((routineTypeIR has type functionTypeIR)), then

  1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

  2. If ((functionTypeIR matches pattern `EXTERN_FUNCTION(%)->%`)), then

    1. (Let (extern_function( _parameterTypeIR* )-> _typeIR) be functionTypeIR)

    2. Return true

5. (Let routineTypeIR be routineTypeIR')

6. If ((routineTypeIR has type methodTypeIR)), then

  1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

  2. If ((methodTypeIR matches pattern `EXTERN_METHOD(%)->%`)), then

    1. (Let (extern_method( _parameterTypeIR* )-> _typeIR) be methodTypeIR)

    2. Return true

7. (Let routineTypeIR be routineTypeIR')

8. If ((routineTypeIR has type methodTypeIR)), then

  1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

  2. If ((methodTypeIR matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

    1. (Let (extern_methodabstract( _parameterTypeIR* )-> _typeIR) be methodTypeIR)

    2. Return true

9. (Let _routineTypeIR be routineTypeIR')

10. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:708.1-708.48
def $nestable_constructor_extern(typeIR)

1. Return $nestable'_constructor_extern($canon(typeIR))

2. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:709.1-709.49
def $nestable'_constructor_extern(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

  2. Return false

3. (Let typeIR be typeIR')

4. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

  2. Return false

5. (Let typeIR be typeIR')

6. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

  2. Return false

7. (Let _typeIR be typeIR')

8. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:728.1-728.48
def $nestable_constructor_parser(typeIR)

1. Return $nestable'_constructor_parser($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:729.1-729.49
def $nestable'_constructor_parser(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

  2. Return false

3. (Let typeIR be typeIR')

4. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

  2. Return false

5. (Let typeIR be typeIR')

6. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

  2. Return false

7. (Let _typeIR be typeIR')

8. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:747.1-747.49
def $nestable_constructor_control(typeIR)

1. Return $nestable'_constructor_control($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:748.1-748.50
def $nestable'_constructor_control(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. Return false

3. (Let typeIR be typeIR')

4. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

  2. Return false

5. (Let typeIR be typeIR')

6. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

  2. Return false

7. (Let _typeIR be typeIR')

8. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:766.1-766.49
def $nestable_constructor_package(typeIR)

1. Return $nestable'_constructor_package($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:767.1-767.50
def $nestable'_constructor_package(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let (table _tid # _typeIR) be (typeIR as tableObjectTypeIR))

  2. Return false

3. (Let _typeIR be typeIR')

4. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:787.1-787.42
def $definable_constructor(typeIR)

1. Return $definable'_constructor($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:788.1-788.43
def $definable'_constructor(typeIR')

1. (Let typeIR be typeIR')

2. If ((typeIR has type externObjectTypeIR)), then

  1. (Let (extern _tid _map<rid, routineTypeDefIR>) be (typeIR as externObjectTypeIR))

  2. Return true

3. (Let typeIR be typeIR')

4. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

  2. Return true

5. (Let typeIR be typeIR')

6. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

  2. Return true

7. (Let typeIR be typeIR')

8. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

  2. Return true

9. (Let _typeIR be typeIR')

10. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.04-typing-relation.watsup:6.1-8.23
relation Eval_static

  (match) p | TC | (expressionIR # (( _typeIR' _ctk'' )))

    1. (Let _typeIR be _typeIR')

    2. (Let _ctk be _ctk'')

    3. If ((expressionIR has type booleanLiteral)), then

      1. (Let booleanLiteral be (expressionIR as booleanLiteral))

      2. Try matching path literalExpressionIR-boolean

    4. (Let _typeIR be _typeIR')

    5. (Let _ctk be _ctk'')

    6. If ((expressionIR has type numberLiteral)), then

      1. (Let numberLiteral be (expressionIR as numberLiteral))

      2. Try matching path literalExpressionIR-number

    7. (Let _typeIR be _typeIR')

    8. (Let _ctk be _ctk'')

    9. If ((expressionIR has type stringLiteral)), then

      1. (Let (" text ") be (expressionIR as stringLiteral))

      2. Try matching path literalExpressionIR-stringliteral

    10. (Let _typeIR be _typeIR')

    11. (Let _ctk be _ctk'')

    12. If ((expressionIR has type prefixedNameIR)), then

      1. (Let prefixedNameIR be (expressionIR as prefixedNameIR))

      2. Try matching path referenceExpression

    13. (Let _typeIR be _typeIR')

    14. (Let _ctk be _ctk'')

    15. If ((expressionIR = ((...) as expressionIR))), then

      1. Try matching path defaultExpressionIR

    16. (Let _typeIR be _typeIR')

    17. (Let _ctk be _ctk'')

    18. If ((expressionIR has type unaryExpressionIR)), then

      1. (Let (unop typedExpressionIR) be (expressionIR as unaryExpressionIR))

      2. Try matching path unaryExpressionIR

    19. (Let _typeIR be _typeIR')

    20. (Let _ctk be _ctk'')

    21. If ((expressionIR has type binaryExpressionIR)), then

      1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

      2. Try matching path binaryExpressionIR

    22. (Let _typeIR be _typeIR')

    23. (Let _ctk be _ctk'')

    24. If ((expressionIR has type ternaryExpressionIR)), then

      1. (Let (typedExpressionIR_cond ? typedExpressionIR_true : typedExpressionIR_false) be (expressionIR as ternaryExpressionIR))

      2. Try matching path ternaryExpressionIR

    25. (Let _typeIR be _typeIR')

    26. (Let _ctk be _ctk'')

    27. If ((expressionIR has type castExpressionIR)), then

      1. (Let (( typeIR ) typedExpressionIR) be (expressionIR as castExpressionIR))

      2. Try matching path castExpression

    28. (Let _typeIR be _typeIR')

    29. (Let _ctk be _ctk'')

    30. If ((expressionIR = (({#}) as expressionIR))), then

      1. Try matching path dataExpressionIR-invalid

    31. (Let _typeIR be _typeIR')

    32. (Let _ctk be _ctk'')

    33. If ((expressionIR has type dataExpressionIR)), then

      1. (Let dataExpressionIR be (expressionIR as dataExpressionIR))

      2. Try matching path dataExpressionIR-sequence

    34. (Let _typeIR be _typeIR')

    35. (Let _ctk be _ctk'')

    36. If ((expressionIR has type dataExpressionIR)), then

      1. (Let dataExpressionIR be (expressionIR as dataExpressionIR))

      2. Try matching path dataExpressionIR-record

    37. (Let _typeIR be _typeIR')

    38. (Let _ctk be _ctk'')

    39. If ((expressionIR has type errorAccessExpressionIR)), then

      1. (Let (error. nameIR) be (expressionIR as errorAccessExpressionIR))

      2. Try matching path errorAccessExpressionIR

    40. (Let typeIR_base be _typeIR')

    41. (Let _ctk be _ctk'')

    42. If ((expressionIR has type memberAccessExpressionIR)), then

      1. (Let (memberAccessBaseIR . nameIR) be (expressionIR as memberAccessExpressionIR))

      2. If ((memberAccessBaseIR matches pattern `TYPE%`)), then

        1. (Let (type prefixedNameIR) be memberAccessBaseIR)

        2. Try matching path memberAccessExpressionIR-type

    43. (Let typeIR_base be _typeIR')

    44. (Let _ctk be _ctk'')

    45. If ((expressionIR has type memberAccessExpressionIR)), then

      1. (Let (memberAccessBaseIR . text) be (expressionIR as memberAccessExpressionIR))

      2. If ((memberAccessBaseIR has type typedExpressionIR)), then

        1. (Let typedExpressionIR_base be (memberAccessBaseIR as typedExpressionIR))

        2. If ((text = "size")), then

          1. Try matching path memberAccessExpressionIR-typedExpressionIR-stack-size

    46. (Let _typeIR be _typeIR')

    47. (Let _ctk be _ctk'')

    48. If ((expressionIR has type indexAccessExpressionIR)), then

      1. (Let indexAccessExpressionIR be (expressionIR as indexAccessExpressionIR))

      2. If ((indexAccessExpressionIR matches pattern `%[%:%]`)), then

        1. (Let (typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ]) be indexAccessExpressionIR)

        2. Try matching path indexAccessExpressionIR-bitslice

    49. (Let _typeIR be _typeIR')

    50. (Let _ctk be _ctk'')

    51. If ((expressionIR has type callExpressionIR)), then

      1. (Let callExpressionIR be (expressionIR as callExpressionIR))

      2. If ((callExpressionIR matches pattern `%<%>(%)`)), then

        1. (Let (routineTargetIR < typeArgumentIR* >( argumentIR* )) be callExpressionIR)

        2. If ((routineTargetIR matches pattern `%.%`)), then

          1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

          2. If ((typeArgumentIR* matches pattern [])), then

            1. If ((argumentIR* matches pattern [])), then

              1. Try matching path callExpressionIR-typedLvalueIR-size

    52. (Let _typeIR be _typeIR')

    53. (Let _ctk be _ctk'')

    54. If ((expressionIR has type callExpressionIR)), then

      1. (Let callExpressionIR be (expressionIR as callExpressionIR))

      2. If ((callExpressionIR matches pattern `%<%>(%)`)), then

        1. (Let (routineTargetIR < typeArgumentIR* >( argumentIR* )) be callExpressionIR)

        2. If ((routineTargetIR matches pattern `TYPE%.%`)), then

          1. (Let (type prefixedNameIR . nameIR) be routineTargetIR)

          2. If ((typeArgumentIR* matches pattern [])), then

            1. If ((argumentIR* matches pattern [])), then

              1. Try matching path callExpressionIR-type

    55. (Let typeIR be _typeIR')

    56. (Let ctk be _ctk'')

    57. If ((expressionIR has type callExpressionIR)), then

      1. (Let callExpressionIR be (expressionIR as callExpressionIR))

      2. If ((callExpressionIR matches pattern `%<%>(%)`)), then

        1. (Let (routineTargetIR' < typeArgumentIR* >( argumentIR* )) be callExpressionIR)

        2. If ((routineTargetIR' matches pattern `(%)`)), then

          1. (Let (( routineTargetIR )) be routineTargetIR')

          2. Try matching path callExpressionIR-parenthesized

    58. (Let _typeIR be _typeIR')

    59. (Let _ctk be _ctk'')

    60. If ((expressionIR has type parenthesizedExpressionIR)), then

      1. (Let (( typedExpressionIR )) be (expressionIR as parenthesizedExpressionIR))

      2. Try matching path parenthesizedExpressionIR

  (path) literalExpressionIR-boolean p | TC | ((booleanLiteral as expressionIR) # (( _typeIR _ctk )))

    1. If (((true) = booleanLiteral)), then

      1. Result in ((b true) as value)

    2. If (((false) = booleanLiteral)), then

      1. Result in ((b false) as value)

  (path) literalExpressionIR-number p | TC | ((numberLiteral as expressionIR) # (( _typeIR _ctk )))

    1. (Let numberLiteral' be numberLiteral)

    2. If ((numberLiteral' matches pattern `D%`)), then

      1. (Let (d i) be numberLiteral')

      2. Result in ((d i) as value)

    3. (Let numberLiteral' be numberLiteral)

    4. If ((numberLiteral' matches pattern `%W%`)), then

      1. (Let (n w i) be numberLiteral')

      2. Result in ((n w i) as value)

    5. (Let numberLiteral' be numberLiteral)

    6. If ((numberLiteral' matches pattern `%S%`)), then

      1. (Let (n s i) be numberLiteral')

      2. Result in ((n s i) as value)

  (path) literalExpressionIR-stringliteral p | TC | (((" text ") as expressionIR) # (( _typeIR _ctk )))

    1. Result in ((" text ") as value)

  (path) referenceExpression p | TC | ((prefixedNameIR as expressionIR) # (( _typeIR _ctk )))

    1. (Let value be $find_value(p, TC, prefixedNameIR))

    2. Result in value

  (path) defaultExpressionIR p | TC | (((...) as expressionIR) # (( _typeIR _ctk )))

    1. Result in ((default) as value)

  (path) unaryExpressionIR p | TC | (((unop typedExpressionIR) as expressionIR) # (( _typeIR _ctk )))

    1. If (((~) = unop)), then

      1. (Eval_static: p TC |- typedExpressionIR ~> value)

      2. Result in $un_bnot(value)

    2. If (((!) = unop)), then

      1. (Eval_static: p TC |- typedExpressionIR ~> value)

      2. Result in $un_lnot(value)

    3. If (((+) = unop)), then

      1. (Eval_static: p TC |- typedExpressionIR ~> value)

      2. Result in $un_plus(value)

    4. If (((-) = unop)), then

      1. (Eval_static: p TC |- typedExpressionIR ~> value)

      2. Result in $un_minus(value)

  (path) binaryExpressionIR p | TC | (((typedExpressionIR_l binop typedExpressionIR_r) as expressionIR) # (( _typeIR _ctk )))

    1. If (((+) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_plus(value_l, value_r)

    2. If (((|+|) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_satplus(value_l, value_r)

    3. If (((-) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_minus(value_l, value_r)

    4. If (((|-|) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_satminus(value_l, value_r)

    5. If (((*) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_mul(value_l, value_r)

    6. If (((/) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_div(value_l, value_r)

    7. If (((<<) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_shl(value_l, value_r)

    8. If (((>>) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_shr(value_l, value_r)

    9. If (((<=) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in ((b $bin_le(value_l, value_r)) as value)

    10. If (((>=) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in ((b $bin_ge(value_l, value_r)) as value)

    11. If (((<) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in ((b $bin_lt(value_l, value_r)) as value)

    12. If (((>) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in ((b $bin_gt(value_l, value_r)) as value)

    13. If (((==) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in ((b $bin_eq(value_l, value_r)) as value)

    14. If (((!=) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in ((b $bin_ne(value_l, value_r)) as value)

    15. If (((&) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_band(value_l, value_r)

    16. If (((^) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_bxor(value_l, value_r)

    17. If (((|) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_bor(value_l, value_r)

    18. If (((++) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_concat(value_l, value_r)

    19. If (((&&) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_land(value_l, value_r)

    20. If (((||) = binop)), then

      1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

      2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

      3. Result in $bin_lor(value_l, value_r)

  (path) ternaryExpressionIR p | TC | (((typedExpressionIR_cond ? typedExpressionIR_true : typedExpressionIR_false) as expressionIR) # (( _typeIR _ctk )))

    1. (Eval_static: p TC |- typedExpressionIR_cond ~> value)

    2. If ((value = ((b true) as value))), then

      1. (Eval_static: p TC |- typedExpressionIR_true ~> value_true)

      2. Result in value_true

    3. (Eval_static: p TC |- typedExpressionIR_cond ~> value)

    4. If ((value = ((b false) as value))), then

      1. (Eval_static: p TC |- typedExpressionIR_false ~> value_false)

      2. Result in value_false

  (path) castExpression p | TC | (((( typeIR ) typedExpressionIR) as expressionIR) # (( _typeIR _ctk )))

    1. (Eval_static: p TC |- typedExpressionIR ~> value)

    2. (Let value_cast be $cast_op(typeIR, value))

    3. Result in value_cast

  (path) dataExpressionIR-invalid p | TC | ((({#}) as expressionIR) # (( _typeIR _ctk )))

    1. Result in (({#}) as value)

  (path) dataExpressionIR-sequence p | TC | ((dataExpressionIR as expressionIR) # (( _typeIR _ctk )))

    1. (Let dataExpressionIR' be dataExpressionIR)

    2. If ((dataExpressionIR' matches pattern `SEQ{%}`)), then

      1. (Let (seq{ typedExpressionIR* }) be dataExpressionIR')

      2. (Eval_static: p TC |- typedExpressionIR ~> value)*

      3. Result in ((seq( value* )) as value)

    3. (Let dataExpressionIR' be dataExpressionIR)

    4. If ((dataExpressionIR' matches pattern `SEQ{%,...}`)), then

      1. (Let (seq{ typedExpressionIR* ,...}) be dataExpressionIR')

      2. (Eval_static: p TC |- typedExpressionIR ~> value)*

      3. Result in ((seq( value* ,...)) as value)

  (path) dataExpressionIR-record p | TC | ((dataExpressionIR as expressionIR) # (( _typeIR _ctk )))

    1. (Let dataExpressionIR' be dataExpressionIR)

    2. If ((dataExpressionIR' matches pattern `RECORD{%}`)), then

      1. (Let (record{ (nameIR = typedExpressionIR)* }) be dataExpressionIR')

      2. (Eval_static: p TC |- typedExpressionIR ~> value)*

      3. Result in ((record{ (value nameIR ;)* }) as value)

    3. (Let dataExpressionIR' be dataExpressionIR)

    4. If ((dataExpressionIR' matches pattern `RECORD{%,...}`)), then

      1. (Let (record{ (nameIR = typedExpressionIR)* ,...}) be dataExpressionIR')

      2. (Eval_static: p TC |- typedExpressionIR ~> value)*

      3. Result in ((record{ (value nameIR ;)* ,...}) as value)

  (path) errorAccessExpressionIR p | TC | (((error. nameIR) as expressionIR) # (( _typeIR _ctk )))

    1. (Let nameIR_error be "error." ++ nameIR)

    2. (Let value_error be $find_value(p, TC, (` nameIR_error)))

    3. Result in value_error

  (path) memberAccessExpressionIR-type p | TC | ((((type prefixedNameIR) . nameIR) as expressionIR) # (( typeIR_base _ctk )))

    1. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

    2. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type enumTypeIR)), then

        1. (Let enumTypeIR be (typeDefIR as enumTypeIR))

        2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

          1. (Let (enum tid { id_member* }) be enumTypeIR)

          2. If (nameIR is in id_member*), then

            1. Result in ((tid . nameIR) as value)

    3. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

    4. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type enumTypeIR)), then

        1. (Let enumTypeIR be (typeDefIR as enumTypeIR))

        2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

          1. (Let (enum tid # typeIR { (id_member = value_member ;)* }) be enumTypeIR)

          2. (Let value'? be $assoc_<id, value>(nameIR, (id_member, value_member)*))

          3. If ((value'? matches pattern (_))), then

            1. (Let ?(value) be value'?)

            2. Result in ((tid . nameIR # value) as value)

  (path) memberAccessExpressionIR-typedExpressionIR-stack-size p | TC | ((((typedExpressionIR_base as memberAccessBaseIR) . "size") as expressionIR) # (( typeIR_base _ctk )))

    1. (Let typeIR be typeIR_base)

    2. If ((typeIR has type headerStackTypeIR)), then

      1. (Let (_typeIR [ n_size ]) be (typeIR as headerStackTypeIR))

      2. Result in ((d (n_size as int)) as value)

  (path) indexAccessExpressionIR-bitslice p | TC | (((typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ]) as expressionIR) # (( _typeIR _ctk )))

    1. (Eval_static: p TC |- typedExpressionIR_base ~> value_base)

    2. (Eval_static: p TC |- typedExpressionIR_hi ~> value_hi)

    3. (Eval_static: p TC |- typedExpressionIR_lo ~> value_lo)

    4. Result in $bitacc_op(value_base, value_hi, value_lo)

  (path) callExpressionIR-typedLvalueIR-size p | TC | ((((typedExpressionIR_base . nameIR) < [] >( [] )) as expressionIR) # (( _typeIR _ctk )))

    1. (Let (_expressionIR # (( typeIR_base _ctk' ))) be typedExpressionIR_base)

    2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. Result in $sizeof(typeIR_base, nameIR)

  (path) callExpressionIR-type p | TC | ((((type prefixedNameIR . nameIR) < [] >( [] )) as expressionIR) # (( _typeIR _ctk )))

    1. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

    2. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type typeIR)), then

        1. (Let typeIR_base be (typeDefIR as typeIR))

        2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

          1. Result in $sizeof(typeIR_base, nameIR)

    3. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

    4. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type polyTypeDefIR)), then

        1. (Let (typeIR_base < tid* , tid'* >) be (typeDefIR as polyTypeDefIR))

        2. If ((tid* matches pattern [])), then

          1. If ((tid'* matches pattern [])), then

            1. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

              1. Result in $sizeof(typeIR_base, nameIR)

  (path) callExpressionIR-parenthesized p | TC | ((((( routineTargetIR )) < typeArgumentIR* >( argumentIR* )) as expressionIR) # (( typeIR ctk )))

    1. (Eval_static: p TC |- (((routineTargetIR < typeArgumentIR* >( argumentIR* )) as expressionIR) # (( typeIR ctk ))) ~> value)

    2. Result in value

  (path) parenthesizedExpressionIR p | TC | (((( typedExpressionIR )) as expressionIR) # (( _typeIR _ctk )))

    1. (Eval_static: p TC |- typedExpressionIR ~> value)

    2. Result in value

;; ../../../../spec-concrete/5.04-typing-relation.watsup:15.1-17.23
relation Type_ok

  (match) p | TC | typeOrVoid

    1. If ((typeOrVoid = ((bool) as typeOrVoid))), then

      1. Try matching path boolean

    2. If ((typeOrVoid = ((error) as typeOrVoid))), then

      1. Try matching path error

    3. If ((typeOrVoid = ((match_kind) as typeOrVoid))), then

      1. Try matching path matchkind

    4. If ((typeOrVoid = ((string) as typeOrVoid))), then

      1. Try matching path string

    5. If ((typeOrVoid = ((int) as typeOrVoid))), then

      1. Try matching path arbint

    6. Case analysis on typeOrVoid

      1. Case (% has type baseType)

        1. (Let baseType be (typeOrVoid as baseType))

        2. Try matching path fixint

        3. Try matching path fixbit

        4. Try matching path varbit

      2. Case (% has type prefixedTypeName)

        1. (Let prefixedTypeName be (typeOrVoid as prefixedTypeName))

        2. Try matching path prefixedTypeName

      3. Case (% has type specializedType)

        1. (Let (prefixedTypeName < typeArgumentList' >) be (typeOrVoid as specializedType))

        2. Try matching path specializedType

      4. Case (% has type headerStackType)

        1. (Let (namedType [ expression_size ]) be (typeOrVoid as headerStackType))

        2. Try matching path headerStackType

      5. Case (% has type listType)

        1. (Let (list< typeArgument >) be (typeOrVoid as listType))

        2. Try matching path listType

      6. Case (% has type tupleType)

        1. (Let (tuple< typeArgumentList >) be (typeOrVoid as tupleType))

        2. Try matching path tupleType

    7. If ((typeOrVoid matches pattern `VOID`)), then

      1. Try matching path void

  (path) boolean p | TC | ((bool) as typeOrVoid)

    1. Result in ((bool) as typeIR), []

  (path) error p | TC | ((error) as typeOrVoid)

    1. Result in ((error) as typeIR), []

  (path) matchkind p | TC | ((match_kind) as typeOrVoid)

    1. Result in ((match_kind) as typeIR), []

  (path) string p | TC | ((string) as typeOrVoid)

    1. Result in ((string) as typeIR), []

  (path) arbint p | TC | ((int) as typeOrVoid)

    1. Result in ((int) as typeIR), []

  (path) fixint p | TC | (baseType as typeOrVoid)

    1. (Let baseType' be baseType)

    2. If ((baseType' matches pattern `INT<%>`)), then

      1. (Let (int< int >) be baseType')

      2. If ((int has type nat)), then

        1. (Let n be (int as nat))

        2. Result in ((int< n >) as typeIR), []

    3. (Let baseType' be baseType)

    4. If ((baseType' matches pattern `INT<(%)>`)), then

      1. (Let (int<( expression )>) be baseType')

      2. (Expr_ok: p TC |- expression : typedExpressionIR)

      3. (Eval_static: p TC |- typedExpressionIR ~> value)

      4. (Let int be $to_number(value))

      5. If ((int has type nat)), then

        1. (Let n be (int as nat))

        2. Result in ((int< n >) as typeIR), []

  (path) fixbit p | TC | (baseType as typeOrVoid)

    1. If (((bit) = baseType)), then

      1. Result in ((bit< 1 >) as typeIR), []

    2. (Let baseType' be baseType)

    3. If ((baseType' matches pattern `BIT<%>`)), then

      1. (Let (bit< int >) be baseType')

      2. If ((int has type nat)), then

        1. (Let n be (int as nat))

        2. Result in ((bit< n >) as typeIR), []

    4. (Let baseType' be baseType)

    5. If ((baseType' matches pattern `BIT<(%)>`)), then

      1. (Let (bit<( expression )>) be baseType')

      2. (Expr_ok: p TC |- expression : typedExpressionIR)

      3. (Eval_static: p TC |- typedExpressionIR ~> value)

      4. (Let int be $to_number(value))

      5. If ((int has type nat)), then

        1. (Let n be (int as nat))

        2. Result in ((bit< n >) as typeIR), []

  (path) varbit p | TC | (baseType as typeOrVoid)

    1. (Let baseType' be baseType)

    2. If ((baseType' matches pattern `VARBIT<%>`)), then

      1. (Let (varbit< int >) be baseType')

      2. If ((int has type nat)), then

        1. (Let n be (int as nat))

        2. Result in ((varbit< n >) as typeIR), []

    3. (Let baseType' be baseType)

    4. If ((baseType' matches pattern `VARBIT<(%)>`)), then

      1. (Let (varbit<( expression )>) be baseType')

      2. (Expr_ok: p TC |- expression : typedExpressionIR)

      3. (Eval_static: p TC |- typedExpressionIR ~> value)

      4. (Let int be $to_number(value))

      5. If ((int has type nat)), then

        1. (Let n be (int as nat))

        2. Result in ((varbit< n >) as typeIR), []

  (path) prefixedTypeName p | TC | (prefixedTypeName as typeOrVoid)

    1. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

    2. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

    3. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type typeIR)), then

        1. (Let typeIR be (typeDefIR as typeIR))

        2. Result in typeIR, []

    4. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

    5. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

    6. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type polyTypeDefIR)), then

        1. (Let polyTypeDefIR be (typeDefIR as polyTypeDefIR))

        2. Result in ((polyTypeDefIR < [] >) as typeIR), []

  (path) specializedType p | TC | ((prefixedTypeName < typeArgumentList' >) as typeOrVoid)

    1. If ((() = typeArgumentList')), then

      1. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

      2. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

      3. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. If ((typeDefIR has type typeIR)), then

          1. (Let typeIR be (typeDefIR as typeIR))

          2. Result in typeIR, []

    2. (Let typeArgumentList be typeArgumentList')

    3. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

    4. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR))

    5. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type polyTypeDefIR)), then

        1. (Let polyTypeDefIR be (typeDefIR as polyTypeDefIR))

        2. (Let (typeIR < tid_expl* , tid_impl* >) be polyTypeDefIR)

        3. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

        4. (TypeArguments_ok: p TC |- typeArgument* : typeIR_arg* # tid_fresh*)

        5. Result in ((polyTypeDefIR < typeIR_arg* >) as typeIR), tid_fresh*

  (path) headerStackType p | TC | ((namedType [ expression_size ]) as typeOrVoid)

    1. (Let namedType' be namedType)

    2. If ((namedType' has type prefixedTypeName)), then

      1. (Let prefixedTypeName be (namedType' as prefixedTypeName))

      2. (Type_ok: p TC |- (prefixedTypeName as typeOrVoid) : typeIR_base # tid*)

      3. If ((tid* matches pattern [])), then

        1. (Expr_ok: p TC |- expression_size : typedExpressionIR_size)

        2. (Eval_static: p TC |- typedExpressionIR_size ~> value_size)

        3. (Let int be $to_number(value_size))

        4. If ((int has type nat)), then

          1. (Let n_size be (int as nat))

          2. (Let typeIR_stack be ((((tid "T") as typeIR) [ n_size ]) as typeIR))

          3. (Let polyTypeDefIR_stack be (typeIR_stack < ["T"] , [] >))

          4. Result in ((polyTypeDefIR_stack < [typeIR_base] >) as typeIR), []

    3. (Let namedType' be namedType)

    4. If ((namedType' has type specializedType)), then

      1. (Let specializedType be (namedType' as specializedType))

      2. (Type_ok: p TC |- (specializedType as typeOrVoid) : typeIR_base # tid_fresh*)

      3. (Expr_ok: p TC |- expression_size : typedExpressionIR_size)

      4. (Eval_static: p TC |- typedExpressionIR_size ~> value_size)

      5. (Let int be $to_number(value_size))

      6. If ((int has type nat)), then

        1. (Let n_size be (int as nat))

        2. (Let typeIR_stack be ((((tid "T") as typeIR) [ n_size ]) as typeIR))

        3. (Let polyTypeDefIR_stack be (typeIR_stack < ["T"] , [] >))

        4. Result in ((polyTypeDefIR_stack < [typeIR_base] >) as typeIR), tid_fresh*

  (path) listType p | TC | ((list< typeArgument >) as typeOrVoid)

    1. (TypeArgument_ok: p TC |- typeArgument : typeIR_arg # tid_fresh*)

    2. (Let typeIR_list be ((list< ((tid "T") as typeIR) >) as typeIR))

    3. (Let polyTypeDefIR_list be (typeIR_list < ["T"] , [] >))

    4. Result in ((polyTypeDefIR_list < [typeIR_arg] >) as typeIR), tid_fresh*

  (path) tupleType p | TC | ((tuple< typeArgumentList >) as typeOrVoid)

    1. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

    2. (TypeArguments_ok: p TC |- typeArgument* : typeIR_arg* # tid_fresh*)

    3. (Let i_idx* be ($init_(|typeIR_arg*|) as int*))

    4. (Let tid_tparam be "T" ++ $int_to_text(i_idx))*

    5. (Let typeIR_tuple be ((tuple< ((tid tid_tparam) as typeIR)* >) as typeIR))

    6. (Let polyTypeDefIR_tuple be (typeIR_tuple < tid_tparam* , [] >))

    7. Result in ((polyTypeDefIR_tuple < typeIR_arg* >) as typeIR), tid_fresh*

  (path) void p | TC | (void)

    1. Result in ((void) as typeIR), []

;; ../../../../spec-concrete/5.04-typing-relation.watsup:19.1-21.23
relation TypeArgument_ok

  (match) p | TC | typeArgument

    1. Case analysis on typeArgument

      1. Case (% has type type)

        1. (Let type be (typeArgument as type))

        2. Try matching path type

      2. Case (% has type nonTypeName)

        1. (Let nonTypeName be (typeArgument as nonTypeName))

        2. Try matching path nonTypeName

    2. If ((typeArgument = ((void) as typeArgument))), then

      1. Try matching path void

    3. If ((typeArgument = ((_) as typeArgument))), then

      1. Try matching path dontcare

  (path) type p | TC | (type as typeArgument)

    1. (Type_ok: p TC |- (type as typeOrVoid) : typeIR # tid_impl*)

    2. Result in typeIR, tid_impl*

  (path) void p | TC | ((void) as typeArgument)

    1. Result in ((void) as typeArgumentIR), []

  (path) dontcare p | TC | ((_) as typeArgument)

    1. (Let tid_impl be $fresh_tid)

    2. Result in ((tid tid_impl) as typeArgumentIR), [tid_impl]

  (path) nonTypeName p | TC | (nonTypeName as typeArgument)

    1. (Let tid be $name((nonTypeName as name)))

    2. Result in ((tid tid) as typeArgumentIR), []

;; ../../../../spec-concrete/5.04-typing-relation.watsup:23.1-25.23
relation TypeArguments_ok

  (match) p | TC | typeArgument*

    1. Case analysis on typeArgument*

      1. Case (% matches pattern [])

        1. Try matching path nil

      2. Case (% matches pattern _ :: _)

        1. (Let typeArgument_h :: typeArgument_t* be typeArgument*)

        2. Try matching path cons

  (path) nil p | TC | []

    1. Result in [], []

  (path) cons p | TC | typeArgument_h :: typeArgument_t*

    1. (TypeArgument_ok: p TC |- typeArgument_h : typeArgumentIR_h # tid_impl_h*)

    2. (TypeArguments_ok: p TC |- typeArgument_t* : typeArgumentIR_t* # tid_impl_t*)

    3. (Let tid_impl* be tid_impl_h* ++ tid_impl_t*)

    4. Result in typeArgumentIR_h :: typeArgumentIR_t*, tid_impl*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:31.1-31.54
relation Sub_expl

  (match) typeIR_a | typeIR_b

    1. Try matching path 

  (path)  typeIR_a | typeIR_b

    1. (Let typeIR_a_canon be $canon(typeIR_a))

    2. (Let typeIR_b_canon be $canon(typeIR_b))

    3. If ((Sub_expl_canon: typeIR_a_canon <: typeIR_b_canon holds)), then

      1. The relation holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:32.1-32.60
relation Sub_expl_canon

  (match) typeIR_a | typeIR_b

    1. Try matching path equals

    2. Try matching path not-equals

  (path) equals typeIR_a | typeIR_b

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. The relation holds

  (path) not-equals typeIR_a | typeIR_b

    1. If (~(Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. If ((Sub_expl_canon_neq: typeIR_a <: typeIR_b holds)), then

        1. The relation holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:33.1-33.64
relation Sub_expl_canon_neq

  (match) typeIR'''''' | typeIR'''''''

    1. (Let typeIR be typeIR'''''')

    2. (Let typeIR' be typeIR''''''')

    3. If ((typeIR = ((bool) as typeIR))), then

      1. If ((typeIR' = ((bit< 1 >) as typeIR))), then

        1. Try matching path boolean-fixbit

    4. (Let typeIR' be typeIR'''''')

    5. (Let typeIR be typeIR''''''')

    6. If ((typeIR' = ((int) as typeIR))), then

      1. Try matching path arbint

    7. (Let typeIR be typeIR'''''')

    8. (Let typeIR' be typeIR''''''')

    9. If ((typeIR has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< nat >) be numberTypeIR')

        2. If ((typeIR' has type numberTypeIR)), then

          1. (Let numberTypeIR be (typeIR' as numberTypeIR))

          2. Try matching path fixint

    10. (Let typeIR' be typeIR'''''')

    11. (Let typeIR be typeIR''''''')

    12. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR matches pattern `BIT<%>`)), then

        1. (Let (bit< nat >) be numberTypeIR)

        2. Try matching path fixbit

    13. (Let typeIR be typeIR'''''')

    14. (Let typeIR' be typeIR''''''')

    15. Try matching path newtype

    16. (Let typeIR be typeIR'''''')

    17. (Let typeIR' be typeIR''''''')

    18. Try matching path serenum

    19. (Let typeIR be typeIR'''''')

    20. (Let typeIR_b be typeIR''''''')

    21. If ((typeIR = ((default) as typeIR))), then

      1. Try matching path default

    22. (Let typeIR' be typeIR'''''')

    23. (Let typeIR be typeIR''''''')

    24. If ((typeIR' = ((header_invalid) as typeIR))), then

      1. Try matching path invalidheader

    25. (Let typeIR' be typeIR'''''')

    26. (Let typeIR be typeIR''''''')

    27. If ((typeIR' has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

        1. (Let (seq< typeIR_a* >) be sequenceTypeIR)

        2. Try matching path seq

    28. (Let typeIR' be typeIR'''''')

    29. (Let typeIR be typeIR''''''')

    30. If ((typeIR' has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

        1. (Let (seq< typeIR_a* ,...>) be sequenceTypeIR)

        2. Try matching path seqdefault

    31. (Let typeIR' be typeIR'''''')

    32. (Let typeIR be typeIR''''''')

    33. If ((typeIR' has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR' as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%}`)), then

        1. (Let (record{ (typeIR_a id_a ;)* }) be recordTypeIR)

        2. Try matching path record

    34. (Let typeIR' be typeIR'''''')

    35. (Let typeIR be typeIR''''''')

    36. If ((typeIR' has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR' as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

        1. (Let (record{ (typeIR_a id_a ;)* ,...}) be recordTypeIR)

        2. Try matching path recorddefault

    37. (Let typeIR be typeIR'''''')

    38. (Let typeIR'' be typeIR''''''')

    39. If ((typeIR'' has type setTypeIR)), then

      1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

      2. If ((typeIR'* matches pattern [ _/1 ])), then

        1. (Let [typeIR_b] be typeIR'*)

        2. Try matching path set

  (path) boolean-fixbit ((bool) as typeIR) | ((bit< 1 >) as typeIR)

    1. The relation holds

  (path) arbint ((int) as typeIR) | typeIR

    1. If ((((bool) as typeIR) = typeIR)), then

      1. The relation holds

    2. (Let typeIR'' be typeIR)

    3. If ((typeIR'' has type numberTypeIR)), then

      1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

      2. If ((numberTypeIR matches pattern `INT<%>`)), then

        1. (Let (int< _nat >) be numberTypeIR)

        2. The relation holds

    4. (Let typeIR'' be typeIR)

    5. If ((typeIR'' has type numberTypeIR)), then

      1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

      2. If ((numberTypeIR matches pattern `BIT<%>`)), then

        1. (Let (bit< _nat >) be numberTypeIR)

        2. The relation holds

  (path) fixint ((int< nat >) as typeIR) | (numberTypeIR as typeIR)

    1. (Let _nat be nat)

    2. If (((int) = numberTypeIR)), then

      1. The relation holds

    3. (Let w_a be nat)

    4. (Let numberTypeIR'' be numberTypeIR)

    5. If ((numberTypeIR'' matches pattern `INT<%>`)), then

      1. (Let (int< w_b >) be numberTypeIR'')

      2. The relation holds

    6. (Let w be nat)

    7. If (((bit< w >) = numberTypeIR)), then

      1. The relation holds

  (path) fixbit ((bit< nat >) as typeIR) | typeIR

    1. If ((1 = nat)), then

      1. If ((((bool) as typeIR) = typeIR)), then

        1. The relation holds

    2. (Let _nat be nat)

    3. If ((((int) as typeIR) = typeIR)), then

      1. The relation holds

    4. (Let w be nat)

    5. If ((((int< w >) as typeIR) = typeIR)), then

      1. The relation holds

    6. (Let w_a be nat)

    7. (Let typeIR'' be typeIR)

    8. If ((typeIR'' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR'' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< w_b >) be numberTypeIR')

        2. The relation holds

  (path) newtype typeIR | typeIR'

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

        1. (Let (type _tid typeIR_a) be aliasTypeIR)

        2. (Let typeIR_b be typeIR')

        3. If ((Sub_impl: typeIR_a <: typeIR_b holds)), then

          1. The relation holds

    3. (Let typeIR_a be typeIR)

    4. (Let typeIR'' be typeIR')

    5. If ((typeIR'' has type aliasTypeIR)), then

      1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

      2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

        1. (Let (type _tid typeIR_b) be aliasTypeIR)

        2. If ((Sub_impl: typeIR_a <: typeIR_b holds)), then

          1. The relation holds

  (path) serenum typeIR | typeIR'

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR_a { _valueFieldIR* }) be enumTypeIR)

        2. (Let typeIR_b be typeIR')

        3. If ((Sub_impl: typeIR_a <: typeIR_b holds)), then

          1. The relation holds

    3. (Let typeIR_a be typeIR)

    4. (Let typeIR'' be typeIR')

    5. If ((typeIR'' has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR_b { _valueFieldIR* }) be enumTypeIR)

        2. If ((Sub_impl: typeIR_a <: typeIR_b holds)), then

          1. The relation holds

  (path) default ((default) as typeIR) | typeIR_b

    1. If ($is_defaultable_typeIR(typeIR_b)), then

      1. The relation holds

  (path) invalidheader ((header_invalid) as typeIR) | typeIR

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type headerTypeIR)), then

      1. (Let (header _tid { _fieldTypeIR* }) be (typeIR'' as headerTypeIR))

      2. The relation holds

    3. (Let typeIR'' be typeIR)

    4. If ((typeIR'' has type headerUnionTypeIR)), then

      1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR'' as headerUnionTypeIR))

      2. The relation holds

  (path) seq ((seq< typeIR_a* >) as typeIR) | typeIR

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type listTypeIR)), then

      1. (Let (list< typeIR_b >) be (typeIR'' as listTypeIR))

      2. If ((Sub_expl: typeIR_a <: typeIR_b holds))*, then

        1. The relation holds

    3. (Let typeIR'' be typeIR)

    4. If ((typeIR'' has type tupleTypeIR)), then

      1. (Let (tuple< typeIR_b* >) be (typeIR'' as tupleTypeIR))

      2. If ((Sub_expl: typeIR_a <: typeIR_b holds))*, then

        1. The relation holds

    5. (Let typeIR'' be typeIR)

    6. If ((typeIR'' has type headerStackTypeIR)), then

      1. (Let (typeIR_b [ n_size ]) be (typeIR'' as headerStackTypeIR))

      2. If ((|typeIR_a*| <= n_size)), then

        1. If ((Sub_expl: typeIR_a <: typeIR_b holds))*, then

          1. The relation holds

    7. (Let typeIR'' be typeIR)

    8. If ((typeIR'' has type structTypeIR)), then

      1. (Let (struct _tid { (typeIR_b _id ;)* }) be (typeIR'' as structTypeIR))

      2. If ((Sub_expl: typeIR_a <: typeIR_b holds))*, then

        1. The relation holds

    9. (Let typeIR'' be typeIR)

    10. If ((typeIR'' has type headerTypeIR)), then

      1. (Let (header _tid { (typeIR_b _id ;)* }) be (typeIR'' as headerTypeIR))

      2. If ((Sub_expl: typeIR_a <: typeIR_b holds))*, then

        1. The relation holds

  (path) seqdefault ((seq< typeIR_a* ,...>) as typeIR) | typeIR

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type tupleTypeIR)), then

      1. (Let (tuple< typeIR_b* >) be (typeIR'' as tupleTypeIR))

      2. If ((|typeIR_a*| < |typeIR_b*|)), then

        1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR_b*, |typeIR_a*|))

        2. If ((Sub_expl: typeIR_a <: typeIR_b_non_default holds))*, then

          1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

            1. The relation holds

    3. (Let typeIR'' be typeIR)

    4. If ((typeIR'' has type headerStackTypeIR)), then

      1. (Let (typeIR_b [ n_size ]) be (typeIR'' as headerStackTypeIR))

      2. If ((|typeIR_a*| < n_size)), then

        1. If ((Sub_expl: typeIR_a <: typeIR_b holds))*, then

          1. If ($is_defaultable_typeIR(typeIR_b)), then

            1. The relation holds

    5. (Let typeIR'' be typeIR)

    6. If ((typeIR'' has type structTypeIR)), then

      1. (Let (struct _tid { (typeIR_b _id ;)* }) be (typeIR'' as structTypeIR))

      2. If ((|typeIR_a*| < |typeIR_b*|)), then

        1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR_b*, |typeIR_a*|))

        2. If ((Sub_expl: typeIR_a <: typeIR_b_non_default holds))*, then

          1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

            1. The relation holds

    7. (Let typeIR'' be typeIR)

    8. If ((typeIR'' has type headerTypeIR)), then

      1. (Let (header _tid { (typeIR_b _id ;)* }) be (typeIR'' as headerTypeIR))

      2. If ((|typeIR_a*| < |typeIR_b*|)), then

        1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR_b*, |typeIR_a*|))

        2. If ((Sub_expl: typeIR_a <: typeIR_b_non_default holds))*, then

          1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

            1. The relation holds

  (path) record ((record{ (typeIR_a id_a ;)* }) as typeIR) | typeIR

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type structTypeIR)), then

      1. (Let (struct _tid { (typeIR_b id_b ;)* }) be (typeIR'' as structTypeIR))

      2. If ($eq_set<id>(({ id_a* }), ({ id_b* }))), then

        1. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

        2. If ((typeIR'''? matches pattern (_)))*, then

          1. (Let ?(typeIR_a_aligned) be typeIR'''?)*

          2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

          3. If ((typeIR''''? matches pattern (_)))*, then

            1. (Let ?(typeIR_b_aligned) be typeIR''''?)*

            2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds))*, then

              1. The relation holds

    3. (Let typeIR'' be typeIR)

    4. If ((typeIR'' has type headerTypeIR)), then

      1. (Let (header _tid { (typeIR_b id_b ;)* }) be (typeIR'' as headerTypeIR))

      2. If ($eq_set<id>(({ id_a* }), ({ id_b* }))), then

        1. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

        2. If ((typeIR'''? matches pattern (_)))*, then

          1. (Let ?(typeIR_a_aligned) be typeIR'''?)*

          2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

          3. If ((typeIR''''? matches pattern (_)))*, then

            1. (Let ?(typeIR_b_aligned) be typeIR''''?)*

            2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds))*, then

              1. The relation holds

  (path) recorddefault ((record{ (typeIR_a id_a ;)* ,...}) as typeIR) | typeIR

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type structTypeIR)), then

      1. (Let (struct _tid { (typeIR_b id_b ;)* }) be (typeIR'' as structTypeIR))

      2. If ($sub_set<id>(({ id_a* }), ({ id_b* }))), then

        1. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

        2. If ((typeIR'''? matches pattern (_)))*, then

          1. (Let ?(typeIR_a_aligned) be typeIR'''?)*

          2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

          3. If ((typeIR''''? matches pattern (_)))*, then

            1. (Let ?(typeIR_b_non_default_aligned) be typeIR''''?)*

            2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*, then

              1. (Let ({ id_default* }) be $diff_set<id>(({ id_b* }), ({ id_a* })))

              2. (Let typeIR'''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_default))*

              3. If ((typeIR'''''? matches pattern (_)))*, then

                1. (Let ?(typeIR_b_default) be typeIR'''''?)*

                2. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

    3. (Let typeIR'' be typeIR)

    4. If ((typeIR'' has type headerTypeIR)), then

      1. (Let (header _tid { (typeIR_b id_b ;)* }) be (typeIR'' as headerTypeIR))

      2. If ($sub_set<id>(({ id_a* }), ({ id_b* }))), then

        1. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

        2. If ((typeIR'''? matches pattern (_)))*, then

          1. (Let ?(typeIR_a_aligned) be typeIR'''?)*

          2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

          3. If ((typeIR''''? matches pattern (_)))*, then

            1. (Let ?(typeIR_b_non_default_aligned) be typeIR''''?)*

            2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*, then

              1. (Let ({ id_default* }) be $diff_set<id>(({ id_b* }), ({ id_a* })))

              2. (Let typeIR'''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_default))*

              3. If ((typeIR'''''? matches pattern (_)))*, then

                1. (Let ?(typeIR_b_default) be typeIR'''''?)*

                2. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

  (path) set typeIR | ((set< [typeIR_b] >) as typeIR)

    1. (Let typeIR'''' be typeIR)

    2. If ((typeIR'''' has type setTypeIR)), then

      1. (Let (set< typeIR'''* >) be (typeIR'''' as setTypeIR))

      2. If ((typeIR'''* matches pattern [ _/1 ])), then

        1. (Let [typeIR_a] be typeIR'''*)

        2. If ((Sub_expl: typeIR_a <: typeIR_b holds)), then

          1. The relation holds

    3. (Let typeIR_a be typeIR)

    4. If (~$is_set_typeIR(typeIR_a)), then

      1. If ((Sub_expl: typeIR_a <: typeIR_b holds)), then

        1. The relation holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:35.1-35.54
relation Sub_impl

  (match) typeIR_a | typeIR_b

    1. Try matching path 

  (path)  typeIR_a | typeIR_b

    1. (Let typeIR_a_canon be $canon(typeIR_a))

    2. (Let typeIR_b_canon be $canon(typeIR_b))

    3. If ((Sub_impl_canon: typeIR_a_canon <: typeIR_b_canon holds)), then

      1. The relation holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:36.1-36.60
relation Sub_impl_canon

  (match) typeIR_a | typeIR_b

    1. Try matching path equals

    2. Try matching path not-equals

  (path) equals typeIR_a | typeIR_b

    1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. The relation holds

  (path) not-equals typeIR_a | typeIR_b

    1. If (~(Type_alpha: typeIR_a ~~ typeIR_b holds)), then

      1. If ((Sub_impl_canon_neq: typeIR_a <: typeIR_b holds)), then

        1. The relation holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:37.1-37.64
relation Sub_impl_canon_neq

  (match) typeIR'''''' | typeIR'''''''

    1. (Let typeIR be typeIR'''''')

    2. (Let typeIR' be typeIR''''''')

    3. If ((typeIR = ((int) as typeIR))), then

      1. If ((typeIR' has type numberTypeIR)), then

        1. (Let numberTypeIR be (typeIR' as numberTypeIR))

        2. Try matching path arbint

    4. (Let typeIR be typeIR'''''')

    5. (Let typeIR_b be typeIR''''''')

    6. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

        1. (Let (enum _tid # typeIR_a { _valueFieldIR* }) be enumTypeIR)

        2. Try matching path serenum-left

    7. (Let typeIR be typeIR'''''')

    8. (Let typeIR_b be typeIR''''''')

    9. If ((typeIR = ((default) as typeIR))), then

      1. Try matching path default

    10. (Let typeIR' be typeIR'''''')

    11. (Let typeIR be typeIR''''''')

    12. If ((typeIR' = ((header_invalid) as typeIR))), then

      1. Try matching path invalidheader

    13. (Let typeIR' be typeIR'''''')

    14. (Let typeIR be typeIR''''''')

    15. If ((typeIR' has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%>`)), then

        1. (Let (seq< typeIR_a* >) be sequenceTypeIR)

        2. Try matching path seq

    16. (Let typeIR' be typeIR'''''')

    17. (Let typeIR be typeIR''''''')

    18. If ((typeIR' has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR be (typeIR' as sequenceTypeIR))

      2. If ((sequenceTypeIR matches pattern `SEQ<%,...>`)), then

        1. (Let (seq< typeIR_a* ,...>) be sequenceTypeIR)

        2. Try matching path seqdefault

    19. (Let typeIR' be typeIR'''''')

    20. (Let typeIR be typeIR''''''')

    21. If ((typeIR' has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR' as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%}`)), then

        1. (Let (record{ (typeIR_a id_a ;)* }) be recordTypeIR)

        2. Try matching path record

    22. (Let typeIR' be typeIR'''''')

    23. (Let typeIR be typeIR''''''')

    24. If ((typeIR' has type recordTypeIR)), then

      1. (Let recordTypeIR be (typeIR' as recordTypeIR))

      2. If ((recordTypeIR matches pattern `RECORD{%,...}`)), then

        1. (Let (record{ (typeIR_a id_a ;)* ,...}) be recordTypeIR)

        2. Try matching path recorddefault

  (path) arbint ((int) as typeIR) | (numberTypeIR as typeIR)

    1. (Let numberTypeIR' be numberTypeIR)

    2. If ((numberTypeIR' matches pattern `INT<%>`)), then

      1. (Let (int< _nat >) be numberTypeIR')

      2. The relation holds

    3. (Let numberTypeIR' be numberTypeIR)

    4. If ((numberTypeIR' matches pattern `BIT<%>`)), then

      1. (Let (bit< _nat >) be numberTypeIR')

      2. The relation holds

  (path) serenum-left ((enum _tid # typeIR_a { _valueFieldIR* }) as typeIR) | typeIR_b

    1. If ((Sub_impl: typeIR_a <: typeIR_b holds)), then

      1. The relation holds

  (path) default ((default) as typeIR) | typeIR_b

    1. If ($is_defaultable_typeIR(typeIR_b)), then

      1. The relation holds

  (path) invalidheader ((header_invalid) as typeIR) | typeIR

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type headerTypeIR)), then

      1. (Let (header _tid { _fieldTypeIR* }) be (typeIR'' as headerTypeIR))

      2. The relation holds

    3. (Let typeIR'' be typeIR)

    4. If ((typeIR'' has type headerUnionTypeIR)), then

      1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR'' as headerUnionTypeIR))

      2. The relation holds

  (path) seq ((seq< typeIR_a* >) as typeIR) | typeIR

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type listTypeIR)), then

      1. (Let (list< typeIR_b >) be (typeIR'' as listTypeIR))

      2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

        1. The relation holds

    3. (Let typeIR'' be typeIR)

    4. If ((typeIR'' has type tupleTypeIR)), then

      1. (Let (tuple< typeIR_b* >) be (typeIR'' as tupleTypeIR))

      2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

        1. The relation holds

    5. (Let typeIR'' be typeIR)

    6. If ((typeIR'' has type headerStackTypeIR)), then

      1. (Let (typeIR_b [ n_size ]) be (typeIR'' as headerStackTypeIR))

      2. If ((|typeIR_a*| <= n_size)), then

        1. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

          1. The relation holds

    7. (Let typeIR'' be typeIR)

    8. If ((typeIR'' has type structTypeIR)), then

      1. (Let (struct _tid { (typeIR_b _id ;)* }) be (typeIR'' as structTypeIR))

      2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

        1. The relation holds

    9. (Let typeIR'' be typeIR)

    10. If ((typeIR'' has type headerTypeIR)), then

      1. (Let (header _tid { (typeIR_b _id ;)* }) be (typeIR'' as headerTypeIR))

      2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

        1. The relation holds

    11. (Let typeIR'' be typeIR)

    12. If ((typeIR'' has type sequenceTypeIR)), then

      1. (Let sequenceTypeIR' be (typeIR'' as sequenceTypeIR))

      2. If ((sequenceTypeIR' matches pattern `SEQ<%>`)), then

        1. (Let (seq< typeIR_b* >) be sequenceTypeIR')

        2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

          1. The relation holds

  (path) seqdefault ((seq< typeIR_a* ,...>) as typeIR) | typeIR

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type tupleTypeIR)), then

      1. (Let (tuple< typeIR_b* >) be (typeIR'' as tupleTypeIR))

      2. If ((|typeIR_a*| < |typeIR_b*|)), then

        1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR_b*, |typeIR_a*|))

        2. If ((Sub_impl: typeIR_a <: typeIR_b_non_default holds))*, then

          1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

            1. The relation holds

    3. (Let typeIR'' be typeIR)

    4. If ((typeIR'' has type headerStackTypeIR)), then

      1. (Let (typeIR_b [ n_size ]) be (typeIR'' as headerStackTypeIR))

      2. If ((|typeIR_a*| < n_size)), then

        1. If ((Sub_impl: typeIR_a <: typeIR_b holds))*, then

          1. If ($is_defaultable_typeIR(typeIR_b)), then

            1. The relation holds

    5. (Let typeIR'' be typeIR)

    6. If ((typeIR'' has type structTypeIR)), then

      1. (Let (struct _tid { (typeIR_b _id ;)* }) be (typeIR'' as structTypeIR))

      2. If ((|typeIR_a*| < |typeIR_b*|)), then

        1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR_b*, |typeIR_a*|))

        2. If ((Sub_impl: typeIR_a <: typeIR_b_non_default holds))*, then

          1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

            1. The relation holds

    7. (Let typeIR'' be typeIR)

    8. If ((typeIR'' has type headerTypeIR)), then

      1. (Let (header _tid { (typeIR_b _id ;)* }) be (typeIR'' as headerTypeIR))

      2. If ((|typeIR_a*| < |typeIR_b*|)), then

        1. (Let (typeIR_b_non_default*, typeIR_b_default*) be $partition_<typeIR>(typeIR_b*, |typeIR_a*|))

        2. If ((Sub_impl: typeIR_a <: typeIR_b_non_default holds))*, then

          1. If ($is_defaultable_typeIR(typeIR_b_default))*, then

            1. The relation holds

  (path) record ((record{ (typeIR_a id_a ;)* }) as typeIR) | typeIR

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type structTypeIR)), then

      1. (Let (struct _tid { (typeIR_b id_b ;)* }) be (typeIR'' as structTypeIR))

      2. If ($eq_set<id>(({ id_a* }), ({ id_b* }))), then

        1. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

        2. If ((typeIR'''? matches pattern (_)))*, then

          1. (Let ?(typeIR_a_aligned) be typeIR'''?)*

          2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

          3. If ((typeIR''''? matches pattern (_)))*, then

            1. (Let ?(typeIR_b_aligned) be typeIR''''?)*

            2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds))*, then

              1. The relation holds

    3. (Let typeIR'' be typeIR)

    4. If ((typeIR'' has type headerTypeIR)), then

      1. (Let (header _tid { (typeIR_b id_b ;)* }) be (typeIR'' as headerTypeIR))

      2. If ($eq_set<id>(({ id_a* }), ({ id_b* }))), then

        1. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

        2. If ((typeIR'''? matches pattern (_)))*, then

          1. (Let ?(typeIR_a_aligned) be typeIR'''?)*

          2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

          3. If ((typeIR''''? matches pattern (_)))*, then

            1. (Let ?(typeIR_b_aligned) be typeIR''''?)*

            2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds))*, then

              1. The relation holds

  (path) recorddefault ((record{ (typeIR_a id_a ;)* ,...}) as typeIR) | typeIR

    1. (Let typeIR'' be typeIR)

    2. If ((typeIR'' has type structTypeIR)), then

      1. (Let (struct _tid { (typeIR_b id_b ;)* }) be (typeIR'' as structTypeIR))

      2. If ($sub_set<id>(({ id_a* }), ({ id_b* }))), then

        1. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

        2. If ((typeIR'''? matches pattern (_)))*, then

          1. (Let ?(typeIR_a_aligned) be typeIR'''?)*

          2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

          3. If ((typeIR''''? matches pattern (_)))*, then

            1. (Let ?(typeIR_b_non_default_aligned) be typeIR''''?)*

            2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*, then

              1. (Let ({ id_default* }) be $diff_set<id>(({ id_b* }), ({ id_a* })))

              2. (Let typeIR'''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_default))*

              3. If ((typeIR'''''? matches pattern (_)))*, then

                1. (Let ?(typeIR_b_default) be typeIR'''''?)*

                2. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

    3. (Let typeIR'' be typeIR)

    4. If ((typeIR'' has type headerTypeIR)), then

      1. (Let (header _tid { (typeIR_b id_b ;)* }) be (typeIR'' as headerTypeIR))

      2. If ($sub_set<id>(({ id_a* }), ({ id_b* }))), then

        1. (Let typeIR'''? be $find_map<id, typeIR>(({ (id_a : typeIR_a)* }), id_a))*

        2. If ((typeIR'''? matches pattern (_)))*, then

          1. (Let ?(typeIR_a_aligned) be typeIR'''?)*

          2. (Let typeIR''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_a))*

          3. If ((typeIR''''? matches pattern (_)))*, then

            1. (Let ?(typeIR_b_non_default_aligned) be typeIR''''?)*

            2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*, then

              1. (Let ({ id_default* }) be $diff_set<id>(({ id_b* }), ({ id_a* })))

              2. (Let typeIR'''''? be $find_map<id, typeIR>(({ (id_b : typeIR_b)* }), id_default))*

              3. If ((typeIR'''''? matches pattern (_)))*, then

                1. (Let ?(typeIR_b_default) be typeIR'''''?)*

                2. If ($is_defaultable_typeIR(typeIR_b_default))*, then

                  1. The relation holds

;; ../../../../spec-concrete/5.04-typing-relation.watsup:43.1-45.23
relation Expr_ok

  (match) p | TC | expression'''

    1. (Let expression be expression''')

    2. If ((expression has type booleanLiteral)), then

      1. (Let booleanLiteral be (expression as booleanLiteral))

      2. Try matching path literalExpression-boolean

    3. (Let expression be expression''')

    4. If ((expression has type numberLiteral)), then

      1. (Let numberLiteral be (expression as numberLiteral))

      2. Try matching path literalExpression-number

    5. (Let expression be expression''')

    6. If ((expression has type stringLiteral)), then

      1. (Let (" text ") be (expression as stringLiteral))

      2. Try matching path literalExpression-stringliteral

    7. (Let expression be expression''')

    8. Try matching path referenceExpression

    9. (Let expression be expression''')

    10. If ((expression = ((...) as expression))), then

      1. Try matching path defaultExpression

    11. (Let expression' be expression''')

    12. If ((expression' has type unaryExpression)), then

      1. (Let (unop expression) be (expression' as unaryExpression))

      2. If ((unop matches pattern `!`)), then

        1. Try matching path unaryExpression-lnot

    13. (Let expression' be expression''')

    14. If ((expression' has type unaryExpression)), then

      1. (Let (unop expression) be (expression' as unaryExpression))

      2. If ((unop matches pattern `~`)), then

        1. Try matching path unaryExpression-bnot

    15. (Let expression' be expression''')

    16. If ((expression' has type unaryExpression)), then

      1. (Let (unop expression) be (expression' as unaryExpression))

      2. Try matching path unaryExpression-uplusminus

    17. (Let expression be expression''')

    18. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. Try matching path binaryExpression-plusminusmult

    19. (Let expression be expression''')

    20. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. Try matching path binaryExpression-satplusminus

    21. (Let expression be expression''')

    22. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. Try matching path binaryExpression-divmod

    23. (Let expression be expression''')

    24. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. Try matching path binaryExpression-shift

    25. (Let expression be expression''')

    26. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. Try matching path binaryExpression-eq

    27. (Let expression be expression''')

    28. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. Try matching path binaryExpression-compare

    29. (Let expression be expression''')

    30. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. Try matching path binaryExpression-bitwise

    31. (Let expression be expression''')

    32. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. If ((binop matches pattern `++`)), then

        1. Try matching path binaryExpression-concat

    33. (Let expression be expression''')

    34. If ((expression has type binaryExpression)), then

      1. (Let (expression_l binop expression_r) be (expression as binaryExpression))

      2. Try matching path binaryExpression-logical

    35. (Let expression be expression''')

    36. If ((expression has type ternaryExpression)), then

      1. (Let (expression_cond ? expression_true : expression_false) be (expression as ternaryExpression))

      2. Try matching path ternaryExpression

    37. (Let expression' be expression''')

    38. If ((expression' has type castExpression)), then

      1. (Let (( type_t ) expression) be (expression' as castExpression))

      2. Try matching path castExpression

    39. (Let expression be expression''')

    40. If ((expression = (({#}) as expression))), then

      1. Try matching path dataExpression-invalid

    41. (Let expression be expression''')

    42. If ((expression has type dataExpression)), then

      1. (Let dataExpression be (expression as dataExpression))

      2. If ((dataExpression matches pattern `{%%}`)), then

        1. (Let ({ dataElementExpression _trailingCommaOpt }) be dataExpression)

        2. If ((dataElementExpression has type expressionList)), then

          1. (Let expressionList be (dataElementExpression as expressionList))

          2. Try matching path dataExpression-sequenceElementExpression

    43. (Let expression be expression''')

    44. If ((expression has type dataExpression)), then

      1. (Let dataExpression be (expression as dataExpression))

      2. If ((dataExpression matches pattern `{%%}`)), then

        1. (Let ({ dataElementExpression _trailingCommaOpt }) be dataExpression)

        2. If ((dataElementExpression has type recordElementExpression)), then

          1. (Let recordElementExpression be (dataElementExpression as recordElementExpression))

          2. Try matching path dataExpression-recordElementExpression

    45. (Let expression be expression''')

    46. If ((expression has type errorAccessExpression)), then

      1. (Let (error. member) be (expression as errorAccessExpression))

      2. Try matching path accessExpression-errorAccessExpression

    47. (Let expression be expression''')

    48. If ((expression has type memberAccessExpression)), then

      1. (Let (memberAccessBase . member) be (expression as memberAccessExpression))

      2. If ((memberAccessBase has type prefixedTypeName)), then

        1. (Let prefixedTypeName_base be (memberAccessBase as prefixedTypeName))

        2. Try matching path accessExpression-memberAccessExpression-prefixedTypeName

    49. (Let expression be expression''')

    50. If ((expression has type memberAccessExpression)), then

      1. (Let (memberAccessBase . member) be (expression as memberAccessExpression))

      2. If ((memberAccessBase has type expression)), then

        1. (Let expression_base be (memberAccessBase as expression))

        2. Try matching path accessExpression-memberAccessExpression-expression

    51. (Let expression be expression''')

    52. If ((expression has type indexAccessExpression)), then

      1. (Let indexAccessExpression be (expression as indexAccessExpression))

      2. If ((indexAccessExpression matches pattern `%[%]`)), then

        1. (Let (expression_base [ expression_index ]) be indexAccessExpression)

        2. Try matching path indexAccessExpression-index

    53. (Let expression be expression''')

    54. If ((expression has type indexAccessExpression)), then

      1. (Let indexAccessExpression be (expression as indexAccessExpression))

      2. If ((indexAccessExpression matches pattern `%[%:%]`)), then

        1. (Let (expression_base [ expression_hi : expression_lo ]) be indexAccessExpression)

        2. Try matching path indexAccessExpression-bitslice

    55. (Let expression be expression''')

    56. If ((expression has type callExpression)), then

      1. (Let callExpression be (expression as callExpression))

      2. Try matching path callExpression-routineTarget

    57. (Let expression be expression''')

    58. If ((expression has type callExpression)), then

      1. (Let callExpression be (expression as callExpression))

      2. If ((callExpression matches pattern `%(%)`)), then

        1. (Let (callTarget ( argumentList )) be callExpression)

        2. Try matching path callExpression-constructorTarget

    59. (Let expression' be expression''')

    60. If ((expression' has type parenthesizedExpression)), then

      1. (Let (( expression )) be (expression' as parenthesizedExpression))

      2. Try matching path parenthesizedExpression

  (path) literalExpression-boolean p | TC | (booleanLiteral as expression)

    1. If (((true) = booleanLiteral)), then

      1. (Let expressionNoteIR be (( ((bool) as typeIR) (lctk) )))

      2. Result in (((true) as expressionIR) # expressionNoteIR)

    2. If (((false) = booleanLiteral)), then

      1. (Let expressionNoteIR be (( ((bool) as typeIR) (lctk) )))

      2. Result in (((false) as expressionIR) # expressionNoteIR)

  (path) literalExpression-number p | TC | (numberLiteral as expression)

    1. (Let numberLiteral' be numberLiteral)

    2. If ((numberLiteral' matches pattern `D%`)), then

      1. (Let (d i) be numberLiteral')

      2. (Let expressionNoteIR be (( ((int) as typeIR) (lctk) )))

      3. Result in (((d i) as expressionIR) # expressionNoteIR)

    3. (Let numberLiteral' be numberLiteral)

    4. If ((numberLiteral' matches pattern `%S%`)), then

      1. (Let (n s i) be numberLiteral')

      2. (Let expressionNoteIR be (( ((int< n >) as typeIR) (lctk) )))

      3. Result in (((n s i) as expressionIR) # expressionNoteIR)

    5. (Let numberLiteral' be numberLiteral)

    6. If ((numberLiteral' matches pattern `%W%`)), then

      1. (Let (n w i) be numberLiteral')

      2. (Let expressionNoteIR be (( ((bit< n >) as typeIR) (lctk) )))

      3. Result in (((n w i) as expressionIR) # expressionNoteIR)

  (path) literalExpression-stringliteral p | TC | ((" text ") as expression)

    1. (Let expressionNoteIR be (( ((string) as typeIR) (lctk) )))

    2. Result in (((" text ") as expressionIR) # expressionNoteIR)

  (path) referenceExpression p | TC | expression

    1. (Let expression' be expression)

    2. If ((expression' has type prefixedNonTypeName)), then

      1. (Let prefixedNonTypeName be (expression' as prefixedNonTypeName))

      2. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

      3. (Let varTypeIR? be $find_var(p, TC, prefixedNameIR))

      4. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((_direction typeIR ctk _value?)) be varTypeIR?)

        2. (Let expressionNoteIR be (( typeIR ctk )))

        3. Result in ((prefixedNameIR as expressionIR) # expressionNoteIR)

    3. If ((((this) as expression) = expression)), then

      1. (Let prefixedNameIR be (` "this"))

      2. (Let varTypeIR? be $find_var(p, TC, prefixedNameIR))

      3. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((_direction typeIR ctk _value?)) be varTypeIR?)

        2. (Let expressionNoteIR be (( typeIR ctk )))

        3. Result in ((prefixedNameIR as expressionIR) # expressionNoteIR)

  (path) defaultExpression p | TC | ((...) as expression)

    1. (Let expressionNoteIR be (( ((default) as typeIR) (lctk) )))

    2. Result in (((...) as expressionIR) # expressionNoteIR)

  (path) unaryExpression-lnot p | TC | (((!) expression) as expression)

    1. (Expr_ok: p TC |- expression : typedExpressionIR)

    2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR, $compat_lnot))

    3. If ((typedExpressionIR'? matches pattern (_))), then

      1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?)

      2. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR_reduced)

      3. Result in ((((!) typedExpressionIR_reduced) as expressionIR) # expressionNoteIR)

  (path) unaryExpression-bnot p | TC | (((~) expression) as expression)

    1. (Expr_ok: p TC |- expression : typedExpressionIR)

    2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR, $compat_bnot))

    3. If ((typedExpressionIR'? matches pattern (_))), then

      1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?)

      2. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR_reduced)

      3. Result in ((((~) typedExpressionIR_reduced) as expressionIR) # expressionNoteIR)

  (path) unaryExpression-uplusminus p | TC | ((unop expression) as expression)

    1. Case analysis on unop

      1. Case (% matches pattern `+`)

        1. (Expr_ok: p TC |- expression : typedExpressionIR)

        2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR, $compat_uplusminus))

        3. If ((typedExpressionIR'? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?)

          2. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR_reduced)

          3. Result in (((unop typedExpressionIR_reduced) as expressionIR) # expressionNoteIR)

      2. Case (% matches pattern `-`)

        1. (Expr_ok: p TC |- expression : typedExpressionIR)

        2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR, $compat_uplusminus))

        3. If ((typedExpressionIR'? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?)

          2. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR_reduced)

          3. Result in (((unop typedExpressionIR_reduced) as expressionIR) # expressionNoteIR)

  (path) binaryExpression-plusminusmult p | TC | ((expression_l binop expression_r) as expression)

    1. If (binop is in [(+), (-), (*)]), then

      1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

      2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

      3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_plusminusmult))

        3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

          2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

          3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

          5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

          6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  (path) binaryExpression-satplusminus p | TC | ((expression_l binop expression_r) as expression)

    1. If (binop is in [(|+|), (|-|)]), then

      1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

      2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

      3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_satplusminus))

        3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

          2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

          3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

          5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

          6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  (path) binaryExpression-divmod p | TC | ((expression_l binop expression_r) as expression)

    1. If (binop is in [(/), (%)]), then

      1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

      2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

      3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod))

        3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

          2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

          3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          4. Case analysis on (ctk_r_reduced matches pattern `LCTK`)

            1. Case true

              1. (Eval_static: p TC |- typedExpressionIR_r_reduced ~> value_r)

              2. (Let int be $to_number(value_r))

              3. If ((int has type nat)), then

                1. (Let n_r be (int as nat))

                2. If ((n_r > 0)), then

                  1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

                  2. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

                  3. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

            2. Case false

              1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

              2. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

              3. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  (path) binaryExpression-shift p | TC | ((expression_l binop expression_r) as expression)

    1. If (binop is in [(<<), (>>)]), then

      1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

      2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

      3. (Let (typedExpressionIR, typedExpressionIR)? be $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift))

      4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (_expressionIR # (( typeIR_l_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

        3. (Let (_expressionIR' # (( typeIR_r_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

        4. If ($is_fixed_bit_typeIR(typeIR_r_reduced)), then

          1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

          2. (Let expressionNoteIR be (( typeIR_l_reduced ctk_reduced )))

          3. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

        5. If ((ctk_r_reduced matches pattern `LCTK`)), then

          1. If (($is_arbitrary_int_typeIR(typeIR_r_reduced) \/ $is_fixed_int_typeIR(typeIR_r_reduced))), then

            1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            2. (Let expressionNoteIR be (( typeIR_l_reduced ctk_reduced )))

            3. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  (path) binaryExpression-eq p | TC | ((expression_l binop expression_r) as expression)

    1. If (binop is in [(==), (!=)]), then

      1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

      2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

      3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (_expressionIR # (( typeIR_cast ctk_l_cast ))) be typedExpressionIR_l_cast)

        3. (Let (_expressionIR' # (( _typeIR ctk_r_cast ))) be typedExpressionIR_r_cast)

        4. If ($is_equalable_typeIR(typeIR_cast)), then

          1. (Let ctk_cast be $join_ctk(ctk_l_cast, ctk_r_cast))

          2. (Let expressionNoteIR be (( ((bool) as typeIR) ctk_cast )))

          3. Result in (((typedExpressionIR_l_cast binop typedExpressionIR_r_cast) as expressionIR) # expressionNoteIR)

  (path) binaryExpression-compare p | TC | ((expression_l binop expression_r) as expression)

    1. If (binop is in [(<=), (>=), (<), (>)]), then

      1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

      2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

      3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_compare))

        3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

          2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

          3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

          5. (Let expressionNoteIR be (( ((bool) as typeIR) ctk_reduced )))

          6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  (path) binaryExpression-bitwise p | TC | ((expression_l binop expression_r) as expression)

    1. If (binop is in [(&), (^), (|)]), then

      1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

      2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

      3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_bitwise))

        3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

          2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

          3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

          5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

          6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  (path) binaryExpression-concat p | TC | ((expression_l (++) expression_r) as expression)

    1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

    2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

    3. (Let (typedExpressionIR, typedExpressionIR)? be $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_concat))

    4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

      1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)?)

      2. (Let (_expressionIR # (( typeIR_l_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

      3. (Let (_expressionIR' # (( typeIR_r_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

      4. (Let typeIR? be $result_concat(typeIR_l_reduced, typeIR_r_reduced))

      5. If ((typeIR? matches pattern (_))), then

        1. (Let ?(typeIR_reduced) be typeIR?)

        2. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

        3. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

        4. Result in (((typedExpressionIR_l_reduced (++) typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  (path) binaryExpression-logical p | TC | ((expression_l binop expression_r) as expression)

    1. If (binop is in [(&&), (||)]), then

      1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

      2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

      3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_logical))

        3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

          2. (Let (_expressionIR # (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

          3. (Let (_expressionIR' # (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

          5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

          6. Result in (((typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) # expressionNoteIR)

  (path) ternaryExpression p | TC | ((expression_cond ? expression_true : expression_false) as expression)

    1. (Expr_ok: p TC |- expression_cond : typedExpressionIR_cond)

    2. (Let (_expressionIR # (( typeIR ctk_cond ))) be typedExpressionIR_cond)

    3. If ((typeIR = ((bool) as typeIR))), then

      1. (Expr_ok: p TC |- expression_true : typedExpressionIR_true)

      2. (Expr_ok: p TC |- expression_false : typedExpressionIR_false)

      3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_true, typedExpressionIR_false))

      4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_true_cast, typedExpressionIR_false_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (_expressionIR' # (( typeIR_cast ctk_true_cast ))) be typedExpressionIR_true_cast)

        3. (Let (_expressionIR'' # (( _typeIR ctk_false_cast ))) be typedExpressionIR_false_cast)

        4. If (($is_arbitrary_int_typeIR(typeIR_cast) => (ctk_cond =/= (dyn)))), then

          1. (Let ctk be $joins_ctk([ctk_cond, ctk_true_cast, ctk_false_cast]))

          2. (Let expressionNoteIR be (( typeIR_cast ctk )))

          3. Result in (((typedExpressionIR_cond ? typedExpressionIR_true_cast : typedExpressionIR_false_cast) as expressionIR) # expressionNoteIR)

  (path) castExpression p | TC | ((( type_t ) expression) as expression)

    1. (Type_ok: p TC |- (type_t as typeOrVoid) : typeIR_t # tid*)

    2. If ((tid* matches pattern [])), then

      1. If ((Type_wf: $bound(p, TC) |- typeIR_t holds)), then

        1. (Expr_ok: p TC |- expression : typedExpressionIR)

        2. (Let (_expressionIR # (( typeIR ctk ))) be typedExpressionIR)

        3. If ((Sub_expl: typeIR <: typeIR_t holds)), then

          1. (Let expressionNoteIR be (( typeIR_t ctk )))

          2. Result in (((( typeIR_t ) typedExpressionIR) as expressionIR) # expressionNoteIR)

  (path) dataExpression-invalid p | TC | (({#}) as expression)

    1. (Let expressionNoteIR be (( ((header_invalid) as typeIR) (lctk) )))

    2. Result in ((({#}) as expressionIR) # expressionNoteIR)

  (path) dataExpression-sequenceElementExpression p | TC | (({ (expressionList as dataElementExpression) _trailingCommaOpt }) as expression)

    1. (Let expression_e* be $flatten_expressionList(expressionList))

    2. If (~((...) as expression) is in expression_e*), then

      1. If ((expression_e* = $flatten_expressionList(expressionList))), then

        1. (Expr_ok: p TC |- expression_e : typedExpressionIR_e)*

        2. (Let (_expressionIR # (( typeIR_e ctk_e ))) be typedExpressionIR_e)*

        3. (Let typeIR be ((seq< typeIR_e* >) as typeIR))

        4. (Let ctk be $joins_ctk(ctk_e*))

        5. (Let expressionNoteIR be (( typeIR ctk )))

        6. Result in (((seq{ typedExpressionIR_e* }) as expressionIR) # expressionNoteIR)

    3. (Let expression_e* be $flatten_expressionList(expressionList))

    4. If (((...) as expression) is in expression_e*), then

      1. (Let expression''* be $rev_<expression>(expression_e*))

      2. If ((expression''* matches pattern _ :: _)), then

        1. (Let expression' :: expression_e_h_rev* be expression''*)

        2. If ((expression' = ((...) as expression))), then

          1. (Let expression_e_h* be $rev_<expression>(expression_e_h_rev*))

          2. If (~((...) as expression) is in expression_e_h*), then

            1. (Expr_ok: p TC |- expression_e_h : typedExpressionIR_e_h)*

            2. (Let (_expressionIR # (( typeIR_e_h ctk_e_h ))) be typedExpressionIR_e_h)*

            3. (Let typeIR be ((seq< typeIR_e_h* ,...>) as typeIR))

            4. (Let ctk be $joins_ctk(ctk_e_h*))

            5. (Let expressionNoteIR be (( typeIR ctk )))

            6. Result in (((seq{ typedExpressionIR_e_h* ,...}) as expressionIR) # expressionNoteIR)

  (path) dataExpression-recordElementExpression p | TC | (({ (recordElementExpression as dataElementExpression) _trailingCommaOpt }) as expression)

    1. (Let recordElementExpression' be recordElementExpression)

    2. If ((recordElementExpression' matches pattern `%=%`)), then

      1. (Let (name_f = expression_f) be recordElementExpression')

      2. (Let nameIR_f be $name(name_f))

      3. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)

      4. (Let (_expressionIR # (( typeIR_f ctk_f ))) be typedExpressionIR_f)

      5. (Let typeIR be ((record{ [(typeIR_f nameIR_f ;)] }) as typeIR))

      6. (Let expressionNoteIR be (( typeIR ctk_f )))

      7. Result in (((record{ [(nameIR_f = typedExpressionIR_f)] }) as expressionIR) # expressionNoteIR)

    3. (Let recordElementExpression' be recordElementExpression)

    4. If ((recordElementExpression' matches pattern `%=%,...`)), then

      1. (Let (name_f = expression_f ,...) be recordElementExpression')

      2. (Let nameIR_f be $name(name_f))

      3. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)

      4. (Let (_expressionIR # (( typeIR_f ctk_f ))) be typedExpressionIR_f)

      5. (Let typeIR be ((record{ [(typeIR_f nameIR_f ;)] ,...}) as typeIR))

      6. (Let expressionNoteIR be (( typeIR ctk_f )))

      7. Result in (((record{ [(nameIR_f = typedExpressionIR_f)] ,...}) as expressionIR) # expressionNoteIR)

    5. (Let recordElementExpression' be recordElementExpression)

    6. If ((recordElementExpression' matches pattern `%=%,%`)), then

      1. (Let (name_f_h = expression_f_h , namedExpressionList_t) be recordElementExpression')

      2. (Let (name_f_t = expression_f_t)* be $flatten_namedExpressionList(namedExpressionList_t))

      3. (Let name_f* be name_f_h :: name_f_t*)

      4. (Let nameIR_f be $name(name_f))*

      5. (Let expression_f* be expression_f_h :: expression_f_t*)

      6. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*

      7. (Let (_expressionIR # (( typeIR_f ctk_f ))) be typedExpressionIR_f)*

      8. (Let typeIR be ((record{ (typeIR_f nameIR_f ;)* }) as typeIR))

      9. (Let ctk be $joins_ctk(ctk_f*))

      10. (Let expressionNoteIR be (( typeIR ctk )))

      11. Result in (((record{ (nameIR_f = typedExpressionIR_f)* }) as expressionIR) # expressionNoteIR)

    7. (Let recordElementExpression' be recordElementExpression)

    8. If ((recordElementExpression' matches pattern `%=%,%,...`)), then

      1. (Let (name_f_h = expression_f_h , namedExpressionList_t ,...) be recordElementExpression')

      2. (Let (name_f_t = expression_f_t)* be $flatten_namedExpressionList(namedExpressionList_t))

      3. (Let name_f* be name_f_h :: name_f_t*)

      4. (Let nameIR_f be $name(name_f))*

      5. (Let expression_f* be expression_f_h :: expression_f_t*)

      6. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*

      7. (Let (_expressionIR # (( typeIR_f ctk_f ))) be typedExpressionIR_f)*

      8. (Let typeIR be ((record{ (typeIR_f nameIR_f ;)* ,...}) as typeIR))

      9. (Let ctk be $joins_ctk(ctk_f*))

      10. (Let expressionNoteIR be (( typeIR ctk )))

      11. Result in (((record{ (nameIR_f = typedExpressionIR_f)* ,...}) as expressionIR) # expressionNoteIR)

  (path) accessExpression-errorAccessExpression p | TC | ((error. member) as expression)

    1. (Let nameIR be $name(member))

    2. (Let nameIR_error be "error." ++ nameIR)

    3. If ((((error. nameIR) as value) = $find_value(p, TC, (` nameIR_error)))), then

      1. (Let expressionNoteIR be (( ((error) as typeIR) (lctk) )))

      2. Result in (((error. nameIR) as expressionIR) # expressionNoteIR)

  (path) accessExpression-memberAccessExpression-prefixedTypeName p | TC | (((prefixedTypeName_base as memberAccessBase) . member) as expression)

    1. (Let prefixedNameIR_base be $prefixedTypeName(prefixedTypeName_base))

    2. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR_base))

    3. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type typeIR)), then

        1. (Let typeIR_base be (typeDefIR as typeIR))

        2. (Let typeIR be $canon(typeIR_base))

        3. If ((typeIR has type enumTypeIR)), then

          1. (Let enumTypeIR be (typeIR as enumTypeIR))

          2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

            1. (Let (enum _tid { nameIR_f* }) be enumTypeIR)

            2. (Let nameIR be $name(member))

            3. If (nameIR is in nameIR_f*), then

              1. (Let expressionNoteIR be (( typeIR_base (lctk) )))

              2. Result in ((((type prefixedNameIR_base) . nameIR) as expressionIR) # expressionNoteIR)

    4. (Let prefixedNameIR_base be $prefixedTypeName(prefixedTypeName_base))

    5. (Let typeDefIR'? be $find_type(p, TC, prefixedNameIR_base))

    6. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type typeIR)), then

        1. (Let typeIR_base be (typeDefIR as typeIR))

        2. (Let typeIR be $canon(typeIR_base))

        3. If ((typeIR has type enumTypeIR)), then

          1. (Let enumTypeIR be (typeIR as enumTypeIR))

          2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

            1. (Let (enum _tid # _typeIR { (nameIR_f = _value ;)* }) be enumTypeIR)

            2. (Let nameIR be $name(member))

            3. If (nameIR is in nameIR_f*), then

              1. (Let expressionNoteIR be (( typeIR_base (lctk) )))

              2. Result in ((((type prefixedNameIR_base) . nameIR) as expressionIR) # expressionNoteIR)

  (path) accessExpression-memberAccessExpression-expression p | TC | (((expression_base as memberAccessBase) . member) as expression)

    1. If (("size" = $name(member))), then

      1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

      2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

      3. (Let typeIR' be $canon(typeIR_base))

      4. If ((typeIR' has type headerStackTypeIR)), then

        1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

        2. (Let expressionNoteIR be (( ((bit< 32 >) as typeIR) (lctk) )))

        3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . "size") as expressionIR) # expressionNoteIR)

    2. If (("lastIndex" = $name(member))), then

      1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

        1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

        3. (Let typeIR' be $canon(typeIR_base))

        4. If ((typeIR' has type headerStackTypeIR)), then

          1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

          2. (Let expressionNoteIR be (( ((bit< 32 >) as typeIR) (dyn) )))

          3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . "lastIndex") as expressionIR) # expressionNoteIR)

    3. If (("last" = $name(member))), then

      1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

        1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

        3. (Let typeIR' be $canon(typeIR_base))

        4. If ((typeIR' has type headerStackTypeIR)), then

          1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

          2. (Let expressionNoteIR be (( typeIR (dyn) )))

          3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . "last") as expressionIR) # expressionNoteIR)

    4. If (("next" = $name(member))), then

      1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

        1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        2. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

        3. (Let typeIR' be $canon(typeIR_base))

        4. If ((typeIR' has type headerStackTypeIR)), then

          1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

          2. (Let expressionNoteIR be (( typeIR (dyn) )))

          3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . "next") as expressionIR) # expressionNoteIR)

    5. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

    6. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

    7. (Let typeIR' be $canon(typeIR_base))

    8. If ((typeIR' has type structTypeIR)), then

      1. (Let (struct _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as structTypeIR))

      2. (Let nameIR be $name(member))

      3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

      4. If ((typeIR''? matches pattern (_))), then

        1. (Let ?(typeIR) be typeIR''?)

        2. (Let expressionNoteIR be (( typeIR (dyn) )))

        3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # expressionNoteIR)

    9. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

    10. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

    11. (Let typeIR' be $canon(typeIR_base))

    12. If ((typeIR' has type headerTypeIR)), then

      1. (Let (header _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as headerTypeIR))

      2. (Let nameIR be $name(member))

      3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

      4. If ((typeIR''? matches pattern (_))), then

        1. (Let ?(typeIR) be typeIR''?)

        2. (Let expressionNoteIR be (( typeIR (dyn) )))

        3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # expressionNoteIR)

    13. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

    14. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

    15. (Let typeIR' be $canon(typeIR_base))

    16. If ((typeIR' has type headerUnionTypeIR)), then

      1. (Let (header_union _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as headerUnionTypeIR))

      2. (Let nameIR be $name(member))

      3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

      4. If ((typeIR''? matches pattern (_))), then

        1. (Let ?(typeIR) be typeIR''?)

        2. (Let expressionNoteIR be (( typeIR (dyn) )))

        3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # expressionNoteIR)

    17. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

    18. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

    19. (Let typeIR' be $canon(typeIR_base))

    20. If ((typeIR' has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR' as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TABLE_STRUCT%{%}`)), then

        1. (Let (table_struct _tid { (typeIR_f nameIR_f ;)* }) be tableTypeIR)

        2. (Let nameIR be $name(member))

        3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

        4. If ((typeIR''? matches pattern (_))), then

          1. (Let ?(typeIR) be typeIR''?)

          2. (Let expressionNoteIR be (( typeIR (dyn) )))

          3. Result in ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # expressionNoteIR)

  (path) indexAccessExpression-index p | TC | ((expression_base [ expression_index ]) as expression)

    1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

    2. (Expr_ok: p TC |- expression_index : typedExpressionIR_index)

    3. (Let (_expressionIR # (( typeIR_base ctk_base ))) be typedExpressionIR_base)

    4. (Let (_expressionIR' # (( typeIR_index ctk_index ))) be typedExpressionIR_index)

    5. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index))

    6. If ((typedExpressionIR? matches pattern (_))), then

      1. (Let ?(typedExpressionIR_index_reduced) be typedExpressionIR?)

      2. (Let typeIR' be $canon(typeIR_base))

      3. If ((typeIR' has type tupleTypeIR)), then

        1. (Let (tuple< typeIR_e* >) be (typeIR' as tupleTypeIR))

        2. If ((ctk_index matches pattern `LCTK`)), then

          1. (Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index)

          2. (Let int be $to_number(value_index))

          3. If ((int has type nat)), then

            1. (Let n_index be (int as nat))

            2. If ((n_index < |typeIR_e*|)), then

              1. (Let expressionNoteIR be (( typeIR_e*[n_index] (dyn) )))

              2. Result in (((typedExpressionIR_base [ typedExpressionIR_index_reduced ]) as expressionIR) # expressionNoteIR)

    7. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

    8. (Expr_ok: p TC |- expression_index : typedExpressionIR_index)

    9. (Let (_expressionIR # (( typeIR_base ctk_base ))) be typedExpressionIR_base)

    10. (Let (_expressionIR' # (( typeIR_index ctk_index ))) be typedExpressionIR_index)

    11. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index))

    12. If ((typedExpressionIR? matches pattern (_))), then

      1. (Let ?(typedExpressionIR_index_reduced) be typedExpressionIR?)

      2. (Let typeIR' be $canon(typeIR_base))

      3. If ((typeIR' has type headerStackTypeIR)), then

        1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

        2. If ((ctk_index matches pattern `LCTK`)), then

          1. (Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index)

          2. (Let int be $to_number(value_index))

          3. If ((int has type nat)), then

            1. (Let n_index be (int as nat))

            2. If ((n_index < n_size)), then

              1. (Let expressionNoteIR be (( typeIR (dyn) )))

              2. Result in (((typedExpressionIR_base [ typedExpressionIR_index_reduced ]) as expressionIR) # expressionNoteIR)

    13. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

    14. (Expr_ok: p TC |- expression_index : typedExpressionIR_index)

    15. (Let (_expressionIR # (( typeIR_base ctk_base ))) be typedExpressionIR_base)

    16. (Let (_expressionIR' # (( typeIR_index ctk_index ))) be typedExpressionIR_index)

    17. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index))

    18. If ((typedExpressionIR? matches pattern (_))), then

      1. (Let ?(typedExpressionIR_index_reduced) be typedExpressionIR?)

      2. (Let typeIR' be $canon(typeIR_base))

      3. If ((typeIR' has type headerStackTypeIR)), then

        1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

        2. If (~(ctk_index matches pattern `LCTK`)), then

          1. (Let expressionNoteIR be (( typeIR (dyn) )))

          2. Result in (((typedExpressionIR_base [ typedExpressionIR_index_reduced ]) as expressionIR) # expressionNoteIR)

  (path) indexAccessExpression-bitslice p | TC | ((expression_base [ expression_hi : expression_lo ]) as expression)

    1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

    2. (Expr_ok: p TC |- expression_hi : typedExpressionIR_hi)

    3. (Expr_ok: p TC |- expression_lo : typedExpressionIR_lo)

    4. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_base, $compat_bitslice_base))

    5. If ((typedExpressionIR? matches pattern (_))), then

      1. (Let ?(typedExpressionIR_base_reduced) be typedExpressionIR?)

      2. (Let (_expressionIR # (( typeIR_base_reduced ctk_base_reduced ))) be typedExpressionIR_base_reduced)

      3. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index))

      4. If ((typedExpressionIR'? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_hi_reduced) be typedExpressionIR'?)

        2. (Let typedExpressionIR''? be $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index))

        3. If ((typedExpressionIR''? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_lo_reduced) be typedExpressionIR''?)

          2. (Let (_expressionIR' # (( typeIR_hi_reduced ctk_hi_reduced ))) be typedExpressionIR_hi_reduced)

          3. (Let (_expressionIR'' # (( typeIR_lo_reduced ctk_lo_reduced ))) be typedExpressionIR_lo_reduced)

          4. If ((ctk_hi_reduced matches pattern `LCTK`)), then

            1. (Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi)

            2. (Let int be $to_number(value_hi))

            3. If ((int has type nat)), then

              1. (Let n_hi be (int as nat))

              2. If ((ctk_lo_reduced matches pattern `LCTK`)), then

                1. (Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo)

                2. (Let int' be $to_number(value_lo))

                3. If ((int' has type nat)), then

                  1. (Let n_lo be (int' as nat))

                  2. If ($is_valid_bitslice(typeIR_base_reduced, n_lo, n_hi)), then

                    1. (Let typeIR be ((bit< ((n_hi - n_lo) + 1) >) as typeIR))

                    2. (Let expressionNoteIR be (( typeIR ctk_base_reduced )))

                    3. Result in (((typedExpressionIR_base [ typedExpressionIR_hi_reduced : typedExpressionIR_lo_reduced ]) as expressionIR) # expressionNoteIR)

  (path) callExpression-routineTarget p | TC | (callExpression as expression)

    1. (Let callExpression' be callExpression)

    2. If ((callExpression' matches pattern `%(%)`)), then

      1. (Let (callTarget ( argumentList )) be callExpression')

      2. If ((callTarget has type routineTarget)), then

        1. (Let routineTarget be (callTarget as routineTarget))

        2. (RoutineTarget_ok: p TC |- routineTarget : routineTargetIR)

        3. (Let argument* be $flatten_argumentList(argumentList))

        4. (Argument_ok: p TC |- argument : argumentIR)*

        5. (RoutineType_ok: p TC |- routineTargetIR < [] >( argumentIR* ): routineTypeIR <# tid_inserted* >(# id_default* ))

        6. (Let tid_infer* be tid_inserted*)

        7. (Call_ok: p TC |- routineTypeIR < [] # tid_infer* >( argumentIR* # id_default* ): typeIR_ret < typeArgumentIR_inferred* >( argumentIR_cast* ))

        8. If ((typeIR_ret =/= ((void) as typeIR))), then

          1. (Let ctk be $is_static_routineTarget(routineTargetIR))

          2. (Let callExpressionIR be (routineTargetIR < typeArgumentIR_inferred* >( argumentIR_cast* )))

          3. (Let expressionNoteIR be (( typeIR_ret ctk )))

          4. Result in ((callExpressionIR as expressionIR) # expressionNoteIR)

    3. (Let callExpression' be callExpression)

    4. If ((callExpression' matches pattern `%<%>(%)`)), then

      1. (Let (routineTarget < realTypeArgumentList >( argumentList )) be callExpression')

      2. (RoutineTarget_ok: p TC |- routineTarget : routineTargetIR)

      3. (Let realTypeArgument* be $flatten_realTypeArgumentList(realTypeArgumentList))

      4. (TypeArguments_ok: p TC |- (realTypeArgument* as typeArgument*) : typeArgumentIR* # tid_impl*)

      5. (Let argument* be $flatten_argumentList(argumentList))

      6. (Argument_ok: p TC |- argument : argumentIR)*

      7. (RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR* >( argumentIR* ): routineTypeIR <# tid_inserted* >(# id_default* ))

      8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

      9. (Call_ok: p TC |- routineTypeIR < typeArgumentIR* # tid_infer* >( argumentIR* # id_default* ): typeIR_ret < typeArgumentIR_inferred* >( argumentIR_cast* ))

      10. If ((typeIR_ret =/= ((void) as typeIR))), then

        1. (Let ctk be $is_static_routineTarget(routineTargetIR))

        2. (Let callExpressionIR be (routineTargetIR < typeArgumentIR_inferred* >( argumentIR_cast* )))

        3. (Let expressionNoteIR be (( typeIR_ret ctk )))

        4. Result in ((callExpressionIR as expressionIR) # expressionNoteIR)

  (path) callExpression-constructorTarget p | TC | ((callTarget ( argumentList )) as expression)

    1. (Let callTarget' be callTarget)

    2. If ((callTarget' has type prefixedTypeName)), then

      1. (Let prefixedTypeName be (callTarget' as prefixedTypeName))

      2. (Let argument* be $flatten_argumentList(argumentList))

      3. (Argument_ok: p TC |- argument : argumentIR)*

      4. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

      5. (ConstructorType_ok: p TC |- prefixedNameIR < [] >( argumentIR* ): constructorTypeIR <# tid_impl* >(# id_default* ))

      6. (Inst_ok: p TC (anon) |- constructorTypeIR < [] # tid_impl* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

      7. If ($is_concrete_extern_object(typeIR_object)), then

        1. (Let callExpressionIR be ((prefixedNameIR < typeArgumentIR_inferred* >) ( argumentIR_cast* )))

        2. (Let expressionNoteIR be (( typeIR_object (ctk) )))

        3. Result in ((callExpressionIR as expressionIR) # expressionNoteIR)

    3. (Let callTarget' be callTarget)

    4. If ((callTarget' has type specializedType)), then

      1. (Let (prefixedTypeName < typeArgumentList >) be (callTarget' as specializedType))

      2. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

      3. (TypeArguments_ok: p TC |- typeArgument* : typeArgumentIR* # tid_impl*)

      4. (Let argument* be $flatten_argumentList(argumentList))

      5. (Argument_ok: p TC |- argument : argumentIR)*

      6. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

      7. (ConstructorType_ok: p TC |- prefixedNameIR < typeArgumentIR* >( argumentIR* ): constructorTypeIR <# tid_inserted* >(# id_default* ))

      8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

      9. (Inst_ok: p TC (anon) |- constructorTypeIR < typeArgumentIR* # tid_infer* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

      10. If ($is_concrete_extern_object(typeIR_object)), then

        1. (Let callExpressionIR be ((prefixedNameIR < typeArgumentIR_inferred* >) ( argumentIR_cast* )))

        2. (Let expressionNoteIR be (( typeIR_object (ctk) )))

        3. Result in ((callExpressionIR as expressionIR) # expressionNoteIR)

  (path) parenthesizedExpression p | TC | ((( expression )) as expression)

    1. (Expr_ok: p TC |- expression : typedExpressionIR)

    2. (Let (_expressionIR # expressionNoteIR) be typedExpressionIR)

    3. Result in (((( typedExpressionIR )) as expressionIR) # expressionNoteIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:51.1-53.23
relation Argument_ok

  (match) p | TC | argument

    1. If ((argument has type expression)), then

      1. (Let expression be (argument as expression))

      2. Try matching path expression

    2. Case analysis on argument

      1. Case (% matches pattern `%=%`)

        1. (Let (name = expression) be argument)

        2. Try matching path name-expression

      2. Case (% matches pattern `%=_`)

        1. (Let (name =_) be argument)

        2. Try matching path name-dontcare

      3. Case (% matches pattern `_`)

        1. Try matching path dontcare

  (path) expression p | TC | (expression as argument)

    1. (Expr_ok: p TC |- expression : typedExpressionIR)

    2. Result in (typedExpressionIR as argumentIR)

  (path) name-expression p | TC | (name = expression)

    1. (Let nameIR be $name(name))

    2. (Expr_ok: p TC |- expression : typedExpressionIR)

    3. Result in (nameIR = typedExpressionIR)

  (path) name-dontcare p | TC | (name =_)

    1. (Let nameIR be $name(name))

    2. Result in (nameIR =_)

  (path) dontcare p | TC | (_)

    1. Result in (_)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:59.1-61.23
relation Lvalue_ok

  (match) p | TC | lvalue

    1. If ((lvalue has type prefixedNonTypeName)), then

      1. (Let prefixedNonTypeName be (lvalue as prefixedNonTypeName))

      2. Try matching path referenceExpression-prefixedNonTypeName

    2. Case analysis on lvalue

      1. Case (% matches pattern `%.%`)

        1. (Let (lvalue_base . member) be lvalue)

        2. Try matching path lvalue-member

      2. Case (% matches pattern `%[%]`)

        1. (Let (lvalue_base [ expression_index ]) be lvalue)

        2. Try matching path lvalue-expression

      3. Case (% matches pattern `%[%:%]`)

        1. (Let (lvalue_base [ expression_hi : expression_lo ]) be lvalue)

        2. Try matching path lvalue-expression-expression

      4. Case (% matches pattern `(%)`)

        1. (Let (( lvalue_base )) be lvalue)

        2. Try matching path parenthesized

  (path) referenceExpression-prefixedNonTypeName p | TC | (prefixedNonTypeName as lvalue)

    1. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

    2. (Let varTypeIR? be $find_var(p, TC, prefixedNameIR))

    3. If ((varTypeIR? matches pattern (_))), then

      1. (Let ?((direction typeIR ctk value?)) be varTypeIR?)

      2. If ((ctk matches pattern `DYN`)), then

        1. If ((value? matches pattern ())), then

          1. If (((direction = (out)) \/ (direction = (inout)))), then

            1. Result in ((prefixedNameIR as lvalueIR) #( typeIR ))

  (path) lvalue-member p | TC | (lvalue_base . member)

    1. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    2. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

    3. (Let typeIR' be $canon(typeIR_base))

    4. If ((typeIR' has type headerStackTypeIR)), then

      1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

      2. (Let nameIR be $name(member))

      3. If (((nameIR = "next") \/ (nameIR = "last"))), then

        1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

          1. (Let typedLvalueIR be ((typedLvalueIR_base . nameIR) #( typeIR )))

          2. Result in typedLvalueIR

    5. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    6. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

    7. (Let typeIR' be $canon(typeIR_base))

    8. If ((typeIR' has type structTypeIR)), then

      1. (Let (struct _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as structTypeIR))

      2. (Let nameIR be $name(member))

      3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

      4. If ((typeIR''? matches pattern (_))), then

        1. (Let ?(typeIR) be typeIR''?)

        2. (Let typedLvalueIR be ((typedLvalueIR_base . nameIR) #( typeIR )))

        3. Result in typedLvalueIR

    9. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    10. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

    11. (Let typeIR' be $canon(typeIR_base))

    12. If ((typeIR' has type headerTypeIR)), then

      1. (Let (header _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as headerTypeIR))

      2. (Let nameIR be $name(member))

      3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

      4. If ((typeIR''? matches pattern (_))), then

        1. (Let ?(typeIR) be typeIR''?)

        2. (Let typedLvalueIR be ((typedLvalueIR_base . nameIR) #( typeIR )))

        3. Result in typedLvalueIR

    13. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    14. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

    15. (Let typeIR' be $canon(typeIR_base))

    16. If ((typeIR' has type headerUnionTypeIR)), then

      1. (Let (header_union _tid { (typeIR_f nameIR_f ;)* }) be (typeIR' as headerUnionTypeIR))

      2. (Let nameIR be $name(member))

      3. (Let typeIR''? be $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*))

      4. If ((typeIR''? matches pattern (_))), then

        1. (Let ?(typeIR) be typeIR''?)

        2. (Let typedLvalueIR be ((typedLvalueIR_base . nameIR) #( typeIR )))

        3. Result in typedLvalueIR

  (path) lvalue-expression p | TC | (lvalue_base [ expression_index ])

    1. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    2. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

    3. (Let typeIR' be $canon(typeIR_base))

    4. If ((typeIR' has type headerStackTypeIR)), then

      1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

      2. (Expr_ok: p TC |- expression_index : typedExpressionIR_index)

      3. (Let (_expressionIR # (( typeIR_index ctk_index ))) be typedExpressionIR_index)

      4. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index))

      5. If ((typedExpressionIR? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_index_reduced) be typedExpressionIR?)

        2. If ((ctk_index matches pattern `LCTK`)), then

          1. (Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index)

          2. (Let int be $to_number(value_index))

          3. If ((int has type nat)), then

            1. (Let n_index be (int as nat))

            2. If ((n_index < n_size)), then

              1. (Let typedLvalueIR be ((typedLvalueIR_base [ typedExpressionIR_index_reduced ]) #( typeIR )))

              2. Result in typedLvalueIR

    5. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    6. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

    7. (Let typeIR' be $canon(typeIR_base))

    8. If ((typeIR' has type headerStackTypeIR)), then

      1. (Let (typeIR [ n_size ]) be (typeIR' as headerStackTypeIR))

      2. (Expr_ok: p TC |- expression_index : typedExpressionIR_index)

      3. (Let (_expressionIR # (( typeIR_index ctk_index ))) be typedExpressionIR_index)

      4. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index))

      5. If ((typedExpressionIR? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_index_reduced) be typedExpressionIR?)

        2. If (~(ctk_index matches pattern `LCTK`)), then

          1. (Let typedLvalueIR be ((typedLvalueIR_base [ typedExpressionIR_index_reduced ]) #( typeIR )))

          2. Result in typedLvalueIR

  (path) lvalue-expression-expression p | TC | (lvalue_base [ expression_hi : expression_lo ])

    1. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    2. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

    3. If ($compat_bitslice_base(typeIR_base)), then

      1. (Expr_ok: p TC |- expression_hi : typedExpressionIR_hi)

      2. (Expr_ok: p TC |- expression_lo : typedExpressionIR_lo)

      3. (Let typedExpressionIR? be $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index))

      4. If ((typedExpressionIR? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_hi_reduced) be typedExpressionIR?)

        2. (Let typedExpressionIR'? be $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index))

        3. If ((typedExpressionIR'? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_lo_reduced) be typedExpressionIR'?)

          2. (Let (_expressionIR # (( typeIR_hi_reduced ctk_hi_reduced ))) be typedExpressionIR_hi_reduced)

          3. (Let (_expressionIR' # (( typeIR_lo_reduced ctk_lo_reduced ))) be typedExpressionIR_lo_reduced)

          4. If ((ctk_hi_reduced matches pattern `LCTK`)), then

            1. (Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi)

            2. (Let int be $to_number(value_hi))

            3. If ((int has type nat)), then

              1. (Let n_hi be (int as nat))

              2. If ((ctk_lo_reduced matches pattern `LCTK`)), then

                1. (Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo)

                2. (Let int' be $to_number(value_lo))

                3. If ((int' has type nat)), then

                  1. (Let n_lo be (int' as nat))

                  2. If ($is_valid_bitslice(typeIR_base, n_lo, n_hi)), then

                    1. (Let typeIR be ((bit< ((n_hi - n_lo) + 1) >) as typeIR))

                    2. (Let typedLvalueIR be ((typedLvalueIR_base [ typedExpressionIR_hi_reduced : typedExpressionIR_lo_reduced ]) #( typeIR )))

                    3. Result in typedLvalueIR

  (path) parenthesized p | TC | (( lvalue_base ))

    1. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    2. (Let (_lvalueIR #( typeIR_base )) be typedLvalueIR_base)

    3. (Let typedLvalueIR be ((( typedLvalueIR_base )) #( typeIR_base )))

    4. Result in typedLvalueIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:67.1-69.26
relation Stmt_ok

  (match) p' | TC' | f' | statement

    1. (Let p be p')

    2. (Let TC be TC')

    3. (Let f be f')

    4. If ((statement = ((;) as statement))), then

      1. Try matching path emptyStatement

    5. (Let p be p')

    6. (Let TC be TC')

    7. (Let f be f')

    8. If ((statement has type assignmentStatement)), then

      1. (Let (lvalue assignop expression ;) be (statement as assignmentStatement))

      2. If ((assignop matches pattern `=`)), then

        1. Try matching path assignmentStatement-eq

    9. (Let p be p')

    10. (Let TC be TC')

    11. (Let f be f')

    12. If ((statement has type callStatement)), then

      1. (Let callStatement be (statement as callStatement))

      2. Try matching path callStatement

    13. (Let p be p')

    14. (Let TC_0 be TC')

    15. (Let f be f')

    16. If ((statement has type directApplicationStatement)), then

      1. (Let (namedType .apply( argumentList );) be (statement as directApplicationStatement))

      2. Try matching path directApplicationStatement-prefixedTypeName

    17. (Let cursor be p')

    18. (Let TC be TC')

    19. (Let f be f')

    20. If ((cursor matches pattern `LOCAL`)), then

      1. If ((statement has type returnStatement)), then

        1. (Let returnStatement be (statement as returnStatement))

        2. Try matching path returnStatement

    21. (Let p be p')

    22. (Let TC be TC')

    23. (Let f be f')

    24. If ((statement = ((exit;) as statement))), then

      1. Try matching path exitStatement

    25. (Let cursor be p')

    26. (Let TC_0 be TC')

    27. (Let f_0 be f')

    28. If ((cursor matches pattern `LOCAL`)), then

      1. If ((statement has type blockStatement)), then

        1. (Let blockStatement be (statement as blockStatement))

        2. Try matching path blockStatement

    29. (Let p be p')

    30. (Let TC be TC')

    31. (Let f be f')

    32. If ((statement has type conditionalStatement)), then

      1. (Let conditionalStatement be (statement as conditionalStatement))

      2. Try matching path conditionalStatement

    33. (Let cursor be p')

    34. (Let TC be TC')

    35. (Let f be f')

    36. If ((cursor matches pattern `LOCAL`)), then

      1. If ((statement has type switchStatement)), then

        1. (Let (switch( expression_switch ){ switchCaseList }) be (statement as switchStatement))

        2. Try matching path switch-table-apply

    37. (Let cursor be p')

    38. (Let TC be TC')

    39. (Let f be f')

    40. If ((cursor matches pattern `LOCAL`)), then

      1. If ((statement has type switchStatement)), then

        1. (Let (switch( expression_switch ){ switchCaseList }) be (statement as switchStatement))

        2. Try matching path switch-general

  (path) emptyStatement p | TC | f | ((;) as statement)

    1. Result in TC, f, ((;) as statementIR)

  (path) assignmentStatement-eq p | TC | f | ((lvalue (=) expression ;) as statement)

    1. (Lvalue_ok: p TC |- lvalue : typedLvalueIR)

    2. (Expr_ok: p TC |- expression : typedExpressionIR)

    3. (Let (_lvalueIR #( typeIR_l )) be typedLvalueIR)

    4. (Let (_expressionIR # (( typeIR_r _ctk ))) be typedExpressionIR)

    5. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR, typeIR_l))

    6. If ((typedExpressionIR'? matches pattern (_))), then

      1. (Let ?(typedExpressionIR_cast) be typedExpressionIR'?)

      2. Result in TC, f, ((typedLvalueIR (=) typedExpressionIR ;) as statementIR)

  (path) callStatement p | TC | f | (callStatement as statement)

    1. (Let callStatement' be callStatement)

    2. If ((callStatement' matches pattern `%(%);`)), then

      1. (Let (lvalue_routine ( argumentList );) be callStatement')

      2. (RoutineTarget_lvalue_ok: p TC |- lvalue_routine : routineTargetIR)

      3. (Let argument* be $flatten_argumentList(argumentList))

      4. (Argument_ok: p TC |- argument : argumentIR)*

      5. (RoutineType_ok: p TC |- routineTargetIR < [] >( argumentIR* ): routineTypeIR <# tid_impl* >(# id_default* ))

      6. (Call_ok: p TC |- routineTypeIR < [] # tid_impl* >( argumentIR* # id_default* ): typeIR_ret < typeArgumentIR_inferred* >( argumentIR_cast* ))

      7. (Let callStatementIR be (routineTargetIR < typeArgumentIR_inferred* >( argumentIR_cast* );))

      8. Result in TC, f, (callStatementIR as statementIR)

    3. (Let callStatement' be callStatement)

    4. If ((callStatement' matches pattern `%<%>(%);`)), then

      1. (Let (lvalue_routine < typeArgumentList >( argumentList );) be callStatement')

      2. (RoutineTarget_lvalue_ok: p TC |- lvalue_routine : routineTargetIR)

      3. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

      4. (TypeArguments_ok: p TC |- typeArgument* : typeArgumentIR* # tid_impl*)

      5. (Let argument* be $flatten_argumentList(argumentList))

      6. (Argument_ok: p TC |- argument : argumentIR)*

      7. (RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR* >( argumentIR* ): routineTypeIR <# tid_inserted* >(# id_default* ))

      8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

      9. (Call_ok: p TC |- routineTypeIR < [] # tid_infer* >( argumentIR* # id_default* ): typeIR_ret < typeArgumentIR_inferred* >( argumentIR_cast* ))

      10. (Let callStatementIR be (routineTargetIR < typeArgumentIR_inferred* >( argumentIR_cast* );))

      11. Result in TC, f, (callStatementIR as statementIR)

  (path) directApplicationStatement-prefixedTypeName p | TC_0 | f | ((namedType .apply( argumentList );) as statement)

    1. (Expr_ok: p TC_0 |- (((namedType as callTarget) ( () )) as expression) : (expressionIR # (( typeIR_object _ctk ))))

    2. If ((expressionIR has type callExpressionIR)), then

      1. (Let callExpressionIR be (expressionIR as callExpressionIR))

      2. If ((callExpressionIR matches pattern `%(%)`)), then

        1. (Let ((prefixedNameIR < typeArgumentIR* >) ( argumentIR* )) be callExpressionIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((argumentIR* matches pattern [])), then

            1. If ($compat_direct_application(typeIR_object)), then

              1. (Let nameIR_object be "__direct_application")

              2. (Let TC_1 be $add_var(p, TC_0, nameIR_object, (() typeIR_object (ctk) ?())))

              3. (Let lvalue be (((nameIR_object) as lvalue) . (("apply") as member)))

              4. (Stmt_ok: p TC_1 f |- ((lvalue ( argumentList );) as statement) : _typingContext _flow statementIR)

              5. If ((statementIR has type callStatementIR)), then

                1. (Let callStatementIR be (statementIR as callStatementIR))

                2. (Let (routineTargetIR < typeArgumentIR'* >( argumentIR_cast* );) be callStatementIR)

                3. If ((routineTargetIR = ((((` nameIR_object) as expressionIR) # (( typeIR_object (ctk) ))) . "apply"))), then

                  1. If ((typeArgumentIR'* matches pattern [])), then

                    1. (Let directApplicationStatementIR be (prefixedNameIR .apply( argumentIR_cast* );))

                    2. Result in TC_0, f, (directApplicationStatementIR as statementIR)

  (path) returnStatement (local) | TC | f | (returnStatement as statement)

    1. If (((return;) = returnStatement)), then

      1. If ((?(((void) as typeIR)) = $find_return_type(TC))), then

        1. Result in TC, (ret), ((return;) as statementIR)

    2. (Let returnStatement' be returnStatement)

    3. If ((returnStatement' matches pattern `RETURN%;`)), then

      1. (Let (return expression ;) be returnStatement')

      2. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      3. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

      4. (Let typeIR'? be $find_return_type(TC))

      5. If ((typeIR'? matches pattern (_))), then

        1. (Let ?(typeIR_ret) be typeIR'?)

        2. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR, typeIR_ret))

        3. If ((typedExpressionIR'? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_cast) be typedExpressionIR'?)

          2. Result in TC, (ret), ((return typedExpressionIR_cast ;) as statementIR)

  (path) exitStatement p | TC | f | ((exit;) as statement)

    1. Result in TC, f, ((exit;) as statementIR)

  (path) blockStatement (local) | TC_0 | f_0 | (blockStatement as statement)

    1. (Block_ok: TC_0 f_0 |- blockStatement : TC_1 f_1 blockStatementIR)

    2. Result in TC_1, f_1, (blockStatementIR as statementIR)

  (path) conditionalStatement p | TC | f | (conditionalStatement as statement)

    1. (Let conditionalStatement' be conditionalStatement)

    2. If ((conditionalStatement' matches pattern `IF(%)%`)), then

      1. (Let (if( expression_cond ) statement_then) be conditionalStatement')

      2. (Expr_ok: p TC |- expression_cond : typedExpressionIR_cond)

      3. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR_cond)

      4. If ((typeIR = ((bool) as typeIR))), then

        1. (Stmt_ok: p TC f |- statement_then : TC_then f_then statementIR_then)

        2. Result in TC, f, ((if( typedExpressionIR_cond ) statementIR_then) as statementIR)

    3. (Let conditionalStatement' be conditionalStatement)

    4. If ((conditionalStatement' matches pattern `IF(%)%ELSE%`)), then

      1. (Let (if( expression_cond ) statement_then else statement_else) be conditionalStatement')

      2. (Expr_ok: p TC |- expression_cond : typedExpressionIR_cond)

      3. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR_cond)

      4. If ((typeIR = ((bool) as typeIR))), then

        1. (Stmt_ok: p TC f |- statement_then : TC_then f_then statementIR_then)

        2. (Stmt_ok: p TC f |- statement_else : TC_else f_else statementIR_else)

        3. (Let f_post be $join_flow(f_then, f_else))

        4. Result in TC, f_post, ((if( typedExpressionIR_cond ) statementIR_then else statementIR_else) as statementIR)

  (path) switch-table-apply (local) | TC | f | ((switch( expression_switch ){ switchCaseList }) as statement)

    1. (Expr_ok: (local) TC |- expression_switch : typedExpressionIR_switch)

    2. (Let (_expressionIR # (( typeIR_switch _ctk ))) be typedExpressionIR_switch)

    3. (Let typeIR be $canon(typeIR_switch))

    4. If ((typeIR has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TABLE_ENUM%{%}`)), then

        1. (Let (table_enum tid_table_enum { _id* }) be tableTypeIR)

        2. (Let tid_table be $strip_prefix($strip_suffix(tid_table_enum, ")"), "action_list("))

        3. (Let switchCase* be $flatten_switchCaseList(switchCaseList))

        4. (SwitchCases_table_ok: TC f tid_table |- switchCase* : f_post switchCaseIR* # switchLabel*)

        5. If ($distinct_<switchLabel>(switchLabel*)), then

          1. (Let switchStatementIR be (switch( typedExpressionIR_switch ){ switchCaseIR* }))

          2. Result in TC, f_post, (switchStatementIR as statementIR)

  (path) switch-general (local) | TC | f | ((switch( expression_switch ){ switchCaseList }) as statement)

    1. (Expr_ok: (local) TC |- expression_switch : typedExpressionIR_switch)

    2. (Let (_expressionIR # (( typeIR_switch _ctk ))) be typedExpressionIR_switch)

    3. If ($compat_switch(typeIR_switch)), then

      1. (Let switchCase* be $flatten_switchCaseList(switchCaseList))

      2. (SwitchCases_general_ok: TC f typeIR_switch |- switchCase* : f_post switchCaseIR* # switchLabel*)

      3. If ($distinct_<switchLabel>(switchLabel*)), then

        1. (Let switchStatementIR be (switch( typedExpressionIR_switch ){ switchCaseIR* }))

        2. Result in TC, f_post, (switchStatementIR as statementIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:71.1-73.26
relation Stmts_ok

  (match) 





;; ../../../../spec-concrete/5.04-typing-relation.watsup:75.1-78.23
relation BlockElementStmt_ok

  (match) TC_0 | f | blockElementStatement

    1. Case analysis on blockElementStatement

      1. Case (% has type constantDeclaration)

        1. (Let constantDeclaration be (blockElementStatement as constantDeclaration))

        2. Try matching path constantDeclaration

      2. Case (% has type variableDeclaration)

        1. (Let (annotationList type name initializerOpt ;) be (blockElementStatement as variableDeclaration))

        2. Try matching path variableDeclaration

      3. Case (% has type statement)

        1. (Let statement be (blockElementStatement as statement))

        2. Try matching path statement

  (path) constantDeclaration TC_0 | f | (constantDeclaration as blockElementStatement)

    1. (Decl_ok: (local) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

    2. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

      2. Result in TC_1, f, (constantDeclarationIR as blockElementStatementIR)

  (path) variableDeclaration TC_0 | f | ((annotationList type name initializerOpt ;) as blockElementStatement)

    1. If ((() = initializerOpt)), then

      1. (Type_ok: (local) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      2. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((local), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Let nameIR be $name(name))

            2. (Let TC_1 be $add_var((local), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

            3. (Let variableDeclarationIR be (annotationList typeIR nameIR ?() ;))

            4. Result in TC_1, f, (variableDeclarationIR as blockElementStatementIR)

    2. (Let initializerOpt' be initializerOpt)

    3. If ((initializerOpt' has type initializer)), then

      1. (Let (= expression_init) be (initializerOpt' as initializer))

      2. (Type_ok: (local) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      3. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((local), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Expr_ok: (local) TC_0 |- expression_init : typedExpressionIR_init)

            2. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

            3. If ((typedExpressionIR? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

              2. (Let nameIR be $name(name))

              3. (Let TC_1 be $add_var((local), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

              4. (Let variableDeclarationIR be (annotationList typeIR nameIR ?((= typedExpressionIR_init_cast)) ;))

              5. Result in TC_1, f, (variableDeclarationIR as blockElementStatementIR)

  (path) statement TC_0 | f | (statement as blockElementStatement)

    1. (Stmt_ok: (local) TC_0 f |- statement : TC_1 f_post statementIR)

    2. Result in TC_1, f_post, (statementIR as blockElementStatementIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:80.1-83.23
relation BlockElementStmts_ok

  (match) TC' | f' | blockElementStatement*

    1. (Let TC be TC')

    2. (Let f be f')

    3. If ((blockElementStatement* matches pattern [])), then

      1. Try matching path nil

    4. (Let TC_0 be TC')

    5. (Let f_0 be f')

    6. If ((blockElementStatement* matches pattern _ :: _)), then

      1. (Let blockElementStatement_h :: blockElementStatement_t* be blockElementStatement*)

      2. Try matching path cons

  (path) nil TC | f | []

    1. Result in TC, f, []

  (path) cons TC_0 | f_0 | blockElementStatement_h :: blockElementStatement_t*

    1. (BlockElementStmt_ok: TC_0 f_0 |- blockElementStatement_h : TC_1 f_1 blockElementStatementIR_h)

    2. (BlockElementStmts_ok: TC_1 f_1 |- blockElementStatement_t* : TC_2 f_2 blockElementStatementIR_t*)

    3. Result in TC_2, f_2, blockElementStatementIR_h :: blockElementStatementIR_t*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:85.1-88.23
relation Block_ok

  (match) TC_0 | f | (annotationList { blockElementStatementList })

    1. Try matching path 

  (path)  TC_0 | f | (annotationList { blockElementStatementList })

    1. (Let blockElementStatement* be $flatten_blockElementStatementList(blockElementStatementList))

    2. (Let TC_1 be $enter(TC_0))

    3. (BlockElementStmts_ok: TC_1 f |- blockElementStatement* : TC_2 f_post blockElementStatementIR*)

    4. (Let TC_3 be $exit(TC_2))

    5. (Let blockStatementIR be (annotationList { blockElementStatementIR* }))

    6. Result in TC_3, f_post, blockStatementIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:95.1-97.23
relation Parameter_ok

  (match) p | TC | (annotationList direction type name initializerOpt)

    1. If ((initializerOpt matches pattern ``EMPTY`)), then

      1. Try matching path empty

    2. If ((initializerOpt has type initializer)), then

      1. (Let (= expression_init) be (initializerOpt as initializer))

      2. Try matching path initializer

  (path) empty p | TC | (annotationList direction type name ())

    1. (Type_ok: p TC |- (type as typeOrVoid) : typeIR # tid_fresh*)

    2. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_fresh* })))

    3. If ((Type_wf: bound |- typeIR holds)), then

      1. (Let nameIR be $name(name))

      2. Result in (annotationList direction typeIR nameIR ?()), tid_fresh*

  (path) initializer p | TC | (annotationList direction type name ((= expression_init) as initializerOpt))

    1. (Type_ok: p TC |- (type as typeOrVoid) : typeIR # tid_fresh*)

    2. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_fresh* })))

    3. If ((Type_wf: bound |- typeIR holds)), then

      1. (Expr_ok: p TC |- expression_init : typedExpressionIR_init)

      2. (Let (_expressionIR # (( typeIR_init ctk ))) be typedExpressionIR_init)

      3. If ((ctk matches pattern `LCTK`)), then

        1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

        2. If ((typedExpressionIR? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

          2. (Let nameIR be $name(name))

          3. (Eval_static: p TC |- typedExpressionIR_init_cast ~> value_init)

          4. Result in (annotationList direction typeIR nameIR ?((= value_init))), tid_fresh*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:99.1-101.23
relation Parameters_ok

  (match) p | TC | parameter*

    1. Case analysis on parameter*

      1. Case (% matches pattern [])

        1. Try matching path nil

      2. Case (% matches pattern _ :: _)

        1. (Let parameter_h :: parameter_t* be parameter*)

        2. Try matching path cons

  (path) nil p | TC | []

    1. Result in [], []

  (path) cons p | TC | parameter_h :: parameter_t*

    1. (Parameter_ok: p TC |- parameter_h : parameterIR_h # tid_fresh_h*)

    2. (Parameters_ok: p TC |- parameter_t* : parameterIR_t* # tid_fresh_t*)

    3. Result in parameterIR_h :: parameterIR_t*, tid_fresh_h* ++ tid_fresh_t*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:103.1-103.48
def $parameterIR((_annotationList direction typeIR nameIR constantInitializerOptIR'))

1. (Let constantInitializerIR? be constantInitializerOptIR')

2. If ((constantInitializerIR? matches pattern ())), then

  1. Return (direction typeIR nameIR ?())

3. (Let constantInitializerOptIR be constantInitializerOptIR')

4. If ((constantInitializerOptIR matches pattern (_))), then

  1. (Let ?((= value)) be constantInitializerOptIR)

  2. Return (direction typeIR nameIR ?(value))

;; ../../../../spec-concrete/5.04-typing-relation.watsup:109.1-112.23
relation ConstructorParameter_ok

  (match) p | TC | constructorParameter

    1. Try matching path 

  (path)  p | TC | constructorParameter

    1. (Parameter_ok: p TC |- constructorParameter : constructorParameterIR # tid_fresh*)

    2. Result in constructorParameterIR, tid_fresh*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:114.1-117.23
relation ConstructorParameters_ok

  (match) p | TC | constructorParameter*

    1. Try matching path 

  (path)  p | TC | constructorParameter*

    1. (Parameters_ok: p TC |- constructorParameter* : constructorParameterIR* # tid_fresh*)

    2. Result in constructorParameterIR*, tid_fresh*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:119.1-119.81
def $constructorParameterIR(constructorParameterIR)

1. Return $parameterIR(constructorParameterIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:127.1-129.23
relation ExternMethod_ok

  (match) TC_0 | tid_extern | methodPrototype

    1. Case analysis on methodPrototype

      1. Case (% matches pattern `%%;`)

        1. (Let (annotationList (typeOrVoid name typeParameterListOpt ( parameterList )) ;) be methodPrototype)

        2. Try matching path non-abstract

      2. Case (% matches pattern `%ABSTRACT%;`)

        1. (Let (annotationList abstract (typeOrVoid name typeParameterListOpt ( parameterList )) ;) be methodPrototype)

        2. Try matching path abstract

  (path) non-abstract TC_0 | tid_extern | (annotationList (typeOrVoid name typeParameterListOpt ( parameterList )) ;)

    1. (Let nameIR be $name(name))

    2. If ((nameIR =/= tid_extern)), then

      1. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      2. (Let tid_expl be $name(typeParameter))*

      3. (Let TC_1 be $add_types((local), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      4. (Type_ok: (local) TC_1 |- typeOrVoid : typeIR_ret # tid*)

      5. If ((tid* matches pattern [])), then

        1. (Let TC_2 be TC_1[local.kind = (extern_method-> typeIR_ret)])

        2. (Let parameter* be $flatten_parameterList(parameterList))

        3. (Parameters_ok: (local) TC_2 |- parameter* : parameterIR* # tid_impl*)

        4. (Let parameterTypeIR be $parameterIR(parameterIR))*

        5. (Let TC_3 be $add_parameters((local), TC_2, parameterTypeIR*))

        6. (Let rid be $rid(name, parameterList))

        7. (Let methodTypeIR be (extern_method( parameterTypeIR* )-> typeIR_ret))

        8. (Let routineTypeDefIR be (((methodTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

        9. If ((RoutineTypeDef_wf: $bound((block), TC_0) |- routineTypeDefIR holds)), then

          1. (Let TC_4 be $add_routine_overload((block), TC_0, rid, routineTypeDefIR))

          2. (Let methodPrototypeIR be (annotationList (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) ;))

          3. Result in TC_4, methodPrototypeIR

  (path) abstract TC_0 | tid_extern | (annotationList abstract (typeOrVoid name typeParameterListOpt ( parameterList )) ;)

    1. (Let nameIR be $name(name))

    2. If ((nameIR =/= tid_extern)), then

      1. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

      2. (Let tid_expl be $name(typeParameter))*

      3. (Let TC_1 be $add_types((local), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

      4. (Type_ok: (local) TC_1 |- typeOrVoid : typeIR_ret # tid*)

      5. If ((tid* matches pattern [])), then

        1. (Let TC_2 be TC_1[local.kind = (extern_methodabstract-> typeIR_ret)])

        2. (Let parameter* be $flatten_parameterList(parameterList))

        3. (Parameters_ok: (local) TC_2 |- parameter* : parameterIR* # tid_impl*)

        4. (Let parameterTypeIR be $parameterIR(parameterIR))*

        5. (Let TC_3 be $add_parameters((local), TC_2, parameterTypeIR*))

        6. (Let rid be $rid(name, parameterList))

        7. (Let methodTypeIR be (extern_methodabstract( parameterTypeIR* )-> typeIR_ret))

        8. (Let routineTypeDefIR be (((methodTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

        9. If ((RoutineTypeDef_wf: $bound((block), TC_0) |- routineTypeDefIR holds)), then

          1. (Let TC_4 be $add_routine_overload((block), TC_0, rid, routineTypeDefIR))

          2. (Let methodPrototypeIR be (annotationList abstract (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) ;))

          3. Result in TC_4, methodPrototypeIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:131.1-133.23
relation ExternMethods_ok

  (match) TC' | tid_extern | methodPrototype*

    1. (Let TC be TC')

    2. If ((methodPrototype* matches pattern [])), then

      1. Try matching path nil

    3. (Let TC_0 be TC')

    4. If ((methodPrototype* matches pattern _ :: _)), then

      1. (Let methodPrototype_h :: methodPrototype_t* be methodPrototype*)

      2. Try matching path cons

  (path) nil TC | tid_extern | []

    1. Result in TC, []

  (path) cons TC_0 | tid_extern | methodPrototype_h :: methodPrototype_t*

    1. (ExternMethod_ok: TC_0 tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h)

    2. (ExternMethods_ok: TC_1 tid_extern |- methodPrototype_t* : TC_2 methodPrototypeIR_t*)

    3. Result in TC_2, methodPrototypeIR_h :: methodPrototypeIR_t*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:135.1-137.23
relation ExternConstructor_ok

  (match) TC_0 | tid_extern | methodPrototype

    1. If ((methodPrototype matches pattern `%%(%);`)), then

      1. (Let (annotationList typeIdentifier ( parameterList );) be methodPrototype)

      2. Try matching path 

  (path)  TC_0 | tid_extern | (annotationList typeIdentifier ( parameterList );)

    1. (Let nameIR be $name((typeIdentifier as name)))

    2. If ((nameIR = tid_extern)), then

      1. (Let constructorParameter* be $flatten_parameterList(parameterList))

      2. (ConstructorParameters_ok: (block) TC_0 |- constructorParameter* : constructorParameterIR* # tid_impl*)

      3. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*

      4. (Let typeDefIR'? be $find_type((global), TC_0, (` nameIR)))

      5. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. If ((typeDefIR has type polyTypeDefIR)), then

          1. (Let (typeIR_extern < tid_expl* , tid* >) be (typeDefIR as polyTypeDefIR))

          2. If ((tid* matches pattern [])), then

            1. (Let cid be $cid((typeIdentifier as name), (( parameterList ))))

            2. (Let typeIR_extern_spec be (((typeIR_extern < tid_expl* , [] >) < ((tid tid_expl) as typeIR)* >) as typeIR))

            3. (Let constructorTypeIR be (constructor( constructorParameterTypeIR* )-> typeIR_extern_spec))

            4. (Let constructorTypeDefIR be (constructorTypeIR < tid_expl* , tid_impl* >))

            5. If ((ConstructorTypeDef_wf: $bound((block), TC_0) |- constructorTypeDefIR holds)), then

              1. (Let TC_1 be $add_constructor(TC_0, cid, constructorTypeDefIR))

              2. (Let methodPrototypeIR be (annotationList nameIR <, tid_impl* >( constructorParameterIR* );))

              3. Result in TC_1, methodPrototypeIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:139.1-141.23
relation ExternConstructors_ok

  (match) TC' | tid_extern | methodPrototype*

    1. (Let TC be TC')

    2. If ((methodPrototype* matches pattern [])), then

      1. Try matching path nil

    3. (Let TC_0 be TC')

    4. If ((methodPrototype* matches pattern _ :: _)), then

      1. (Let methodPrototype_h :: methodPrototype_t* be methodPrototype*)

      2. Try matching path cons

  (path) nil TC | tid_extern | []

    1. Result in TC, []

  (path) cons TC_0 | tid_extern | methodPrototype_h :: methodPrototype_t*

    1. (ExternConstructor_ok: TC_0 tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h)

    2. (ExternConstructors_ok: TC_1 tid_extern |- methodPrototype_t* : TC_2 methodPrototypeIR_t*)

    3. Result in TC_2, methodPrototypeIR_h :: methodPrototypeIR_t*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:147.1-149.23
relation ParserTransition_ok

  (match) TC_0 | nameIR_state* | transitionStatement

    1. Case analysis on transitionStatement

      1. Case (% matches pattern ``EMPTY`)

        1. Try matching path empty

      2. Case (% matches pattern `TRANSITION%`)

        1. (Let (transition stateExpression) be transitionStatement)

        2. If ((stateExpression matches pattern `%;`)), then

          1. (Let (name ;) be stateExpression)

          2. Try matching path name

        3. If ((stateExpression has type selectExpression)), then

          1. (Let (select( expressionList_key ){ selectCaseList }) be (stateExpression as selectExpression))

          2. Try matching path switch

  (path) empty TC_0 | nameIR_state* | ()

    1. Result in (transition ("reject" ;))

  (path) name TC_0 | nameIR_state* | (transition (name ;))

    1. (Let nameIR be $name(name))

    2. If (nameIR is in nameIR_state*), then

      1. (Let transitionStatementIR be (transition (nameIR ;)))

      2. Result in transitionStatementIR

  (path) switch TC_0 | nameIR_state* | (transition ((select( expressionList_key ){ selectCaseList }) as stateExpression))

    1. (Let expression_key* be $flatten_expressionList(expressionList_key))

    2. (Expr_ok: (local) TC_0 |- expression_key : typedExpressionIR_key)*

    3. (Let (_expressionIR # (( typeIR_key _ctk ))) be typedExpressionIR_key)*

    4. If ((Type_wf: $bound((local), TC_0) |- ((set< [typeIR_key] >) as typeIR) holds))*, then

      1. (Let selectCase* be $flatten_selectCaseList(selectCaseList))

      2. (SelectCase_ok: TC_0 nameIR_state* typeIR_key* |- selectCase : selectCaseIR)*

      3. (Let transitionStatementIR be (transition ((select( typedExpressionIR_key* ){ selectCaseIR* }) as stateExpressionIR)))

      4. Result in transitionStatementIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:151.1-153.20
relation ParserStmt_ok

  (match) TC_0' | parserStatement''

    1. (Let TC_0 be TC_0')

    2. (Let parserStatement be parserStatement'')

    3. If ((parserStatement has type constantDeclaration)), then

      1. (Let constantDeclaration be (parserStatement as constantDeclaration))

      2. Try matching path constantDeclaration

    4. (Let TC_0 be TC_0')

    5. (Let parserStatement be parserStatement'')

    6. If ((parserStatement has type variableDeclaration)), then

      1. (Let (annotationList type name initializerOpt ;) be (parserStatement as variableDeclaration))

      2. Try matching path variableDeclaration

    7. (Let TC be TC_0')

    8. (Let parserStatement be parserStatement'')

    9. If ((parserStatement has type emptyStatement)), then

      1. (Let emptyStatement be (parserStatement as emptyStatement))

      2. Try matching path emptyStatement

    10. (Let TC_0 be TC_0')

    11. (Let parserStatement be parserStatement'')

    12. If ((parserStatement has type assignmentStatement)), then

      1. (Let assignmentStatement be (parserStatement as assignmentStatement))

      2. Try matching path assignmentStatement

    13. (Let TC_0 be TC_0')

    14. (Let parserStatement be parserStatement'')

    15. If ((parserStatement has type callStatement)), then

      1. (Let callStatement be (parserStatement as callStatement))

      2. Try matching path callStatement

    16. (Let TC_0 be TC_0')

    17. (Let parserStatement be parserStatement'')

    18. If ((parserStatement has type directApplicationStatement)), then

      1. (Let directApplicationStatement be (parserStatement as directApplicationStatement))

      2. Try matching path directApplicationStatement

    19. (Let TC_0 be TC_0')

    20. (Let parserStatement' be parserStatement'')

    21. If ((parserStatement' has type parserBlockStatement)), then

      1. (Let (annotationList { parserStatementList }) be (parserStatement' as parserBlockStatement))

      2. Try matching path parserBlockStatement

    22. (Let TC_0 be TC_0')

    23. (Let parserStatement be parserStatement'')

    24. If ((parserStatement has type conditionalStatement)), then

      1. (Let conditionalStatement be (parserStatement as conditionalStatement))

      2. Try matching path conditionalStatement

  (path) constantDeclaration TC_0 | (constantDeclaration as parserStatement)

    1. (Decl_ok: (local) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

    2. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

      2. Result in TC_1, (constantDeclarationIR as parserStatementIR)

  (path) variableDeclaration TC_0 | ((annotationList type name initializerOpt ;) as parserStatement)

    1. If ((() = initializerOpt)), then

      1. (Type_ok: (local) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      2. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((local), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Let nameIR be $name(name))

            2. (Let TC_1 be $add_var((local), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

            3. (Let variableDeclarationIR be (annotationList typeIR nameIR ?() ;))

            4. Result in TC_1, (variableDeclarationIR as parserStatementIR)

    2. (Let initializerOpt' be initializerOpt)

    3. If ((initializerOpt' has type initializer)), then

      1. (Let (= expression_init) be (initializerOpt' as initializer))

      2. (Type_ok: (local) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      3. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((local), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Expr_ok: (local) TC_0 |- expression_init : typedExpressionIR_init)

            2. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

            3. If ((typedExpressionIR? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

              2. (Let nameIR be $name(name))

              3. (Let TC_1 be $add_var((local), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

              4. (Let variableDeclarationIR be (annotationList typeIR nameIR ?((= typedExpressionIR_init_cast)) ;))

              5. Result in TC_1, (variableDeclarationIR as parserStatementIR)

  (path) emptyStatement TC | (emptyStatement as parserStatement)

    1. (Stmt_ok: (local) TC (cont) |- (emptyStatement as statement) : typingContext flow statementIR)

    2. If ((typingContext = TC)), then

      1. If ((flow matches pattern `CONT`)), then

        1. If ((statementIR has type emptyStatementIR)), then

          1. (Let emptyStatementIR be (statementIR as emptyStatementIR))

          2. Result in TC, (emptyStatementIR as parserStatementIR)

  (path) assignmentStatement TC_0 | (assignmentStatement as parserStatement)

    1. (Stmt_ok: (local) TC_0 (cont) |- (assignmentStatement as statement) : TC_1 flow statementIR)

    2. If ((flow matches pattern `CONT`)), then

      1. If ((statementIR has type assignmentStatementIR)), then

        1. (Let assignmentStatementIR be (statementIR as assignmentStatementIR))

        2. Result in TC_1, (assignmentStatementIR as parserStatementIR)

  (path) callStatement TC_0 | (callStatement as parserStatement)

    1. (Stmt_ok: (local) TC_0 (cont) |- (callStatement as statement) : TC_1 flow statementIR)

    2. If ((flow matches pattern `CONT`)), then

      1. If ((statementIR has type callStatementIR)), then

        1. (Let callStatementIR be (statementIR as callStatementIR))

        2. Result in TC_1, (callStatementIR as parserStatementIR)

  (path) directApplicationStatement TC_0 | (directApplicationStatement as parserStatement)

    1. (Stmt_ok: (local) TC_0 (cont) |- (directApplicationStatement as statement) : TC_1 flow statementIR)

    2. If ((flow matches pattern `CONT`)), then

      1. If ((statementIR has type directApplicationStatementIR)), then

        1. (Let directApplicationStatementIR be (statementIR as directApplicationStatementIR))

        2. Result in TC_1, (directApplicationStatementIR as parserStatementIR)

  (path) parserBlockStatement TC_0 | ((annotationList { parserStatementList }) as parserStatement)

    1. (Let parserStatement* be $flatten_parserStatementList(parserStatementList))

    2. (Let TC_1 be $enter(TC_0))

    3. (ParserStmts_ok: TC_1 |- parserStatement* : TC_2 parserStatementIR*)

    4. (Let TC_3 be $exit(TC_2))

    5. (Let parserBlockStatementIR be (annotationList { parserStatementIR* }))

    6. Result in TC_1, (parserBlockStatementIR as parserStatementIR)

  (path) conditionalStatement TC_0 | (conditionalStatement as parserStatement)

    1. (Stmt_ok: (local) TC_0 (cont) |- (conditionalStatement as statement) : TC_1 flow statementIR)

    2. If ((flow matches pattern `CONT`)), then

      1. If ((statementIR has type conditionalStatementIR)), then

        1. (Let conditionalStatementIR be (statementIR as conditionalStatementIR))

        2. Result in TC_1, (conditionalStatementIR as parserStatementIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:155.1-157.20
relation ParserStmts_ok

  (match) TC' | parserStatement*

    1. (Let TC be TC')

    2. If ((parserStatement* matches pattern [])), then

      1. Try matching path nil

    3. (Let TC_0 be TC')

    4. If ((parserStatement* matches pattern _ :: _)), then

      1. (Let parserStatement_h :: parserStatement_t* be parserStatement*)

      2. Try matching path cons

  (path) nil TC | []

    1. Result in TC, []

  (path) cons TC_0 | parserStatement_h :: parserStatement_t*

    1. (ParserStmt_ok: TC_0 |- parserStatement_h : TC_1 parserStatementIR_h)

    2. (ParserStmts_ok: TC_1 |- parserStatement_t* : TC_2 parserStatementIR_t*)

    3. Result in TC_2, parserStatementIR_h :: parserStatementIR_t*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:159.1-161.23
relation ParserState_ok

  (match) TC_0 | nameIR_state* | (annotationList state name { parserStatementList transitionStatement })

    1. Try matching path 

  (path)  TC_0 | nameIR_state* | (annotationList state name { parserStatementList transitionStatement })

    1. (Let nameIR be $name(name))

    2. (Let TC_1 be $enter(TC_0))

    3. (Let parserStatement* be $flatten_parserStatementList(parserStatementList))

    4. (ParserStmts_ok: TC_1 |- parserStatement* : TC_2 parserStatementIR*)

    5. (ParserTransition_ok: TC_2 nameIR_state* |- transitionStatement : transitionStatementIR)

    6. (Let TC_3 be $exit(TC_2))

    7. (Let parserStateIR be (annotationList state nameIR { parserStatementIR* transitionStatementIR }))

    8. Result in parserStateIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:163.1-165.20
relation ParserStates_ok

  (match) TC | parserState*

    1. Try matching path 

  (path)  TC | parserState*

    1. (Let (_annotationList state name_state { _parserStatementList _transitionStatement }) be parserState)*

    2. (Let nameIR_state be $name(name_state))*

    3. If ($distinct_<nameIR>(nameIR_state*)), then

      1. If ("start" is in nameIR_state*), then

        1. If ((~"accept" is in nameIR_state* /\ ~"reject" is in nameIR_state*)), then

          1. (Let nameIR_state_impl* be "accept" :: "reject" :: nameIR_state*)

          2. (ParserState_ok: TC nameIR_state_impl* |- parserState : parserStateIR)*

          3. Result in parserStateIR*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:167.1-170.20
relation ParserLocalDecl_ok

  (match) TC_0 | parserLocalDeclaration

    1. Case analysis on parserLocalDeclaration

      1. Case (% has type constantDeclaration)

        1. (Let constantDeclaration be (parserLocalDeclaration as constantDeclaration))

        2. Try matching path constantDeclaration

      2. Case (% has type instantiation)

        1. (Let instantiation be (parserLocalDeclaration as instantiation))

        2. Try matching path instantiation

      3. Case (% has type variableDeclaration)

        1. (Let (annotationList type name initializerOpt ;) be (parserLocalDeclaration as variableDeclaration))

        2. Try matching path variableDeclaration

      4. Case (% has type valueSetDeclaration)

        1. (Let (annotationList value_set< valueSetType >( expression ) name ;) be (parserLocalDeclaration as valueSetDeclaration))

        2. Try matching path valueSetDeclaration

  (path) constantDeclaration TC_0 | (constantDeclaration as parserLocalDeclaration)

    1. (Decl_ok: (block) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

    2. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

      2. Result in TC_1, (constantDeclarationIR as parserLocalDeclarationIR)

  (path) instantiation TC_0 | (instantiation as parserLocalDeclaration)

    1. (Decl_ok: (block) TC_0 |- (instantiation as declaration) : TC_1 declarationIR)

    2. If ((declarationIR has type instantiationIR)), then

      1. (Let instantiationIR be (declarationIR as instantiationIR))

      2. Result in TC_1, (instantiationIR as parserLocalDeclarationIR)

  (path) variableDeclaration TC_0 | ((annotationList type name initializerOpt ;) as parserLocalDeclaration)

    1. If ((() = initializerOpt)), then

      1. (Type_ok: (block) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      2. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((block), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Let nameIR be $name(name))

            2. (Let TC_1 be $add_var((block), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

            3. (Let variableDeclarationIR be (annotationList typeIR nameIR ?() ;))

            4. Result in TC_1, (variableDeclarationIR as parserLocalDeclarationIR)

    2. (Let initializerOpt' be initializerOpt)

    3. If ((initializerOpt' has type initializer)), then

      1. (Let (= expression_init) be (initializerOpt' as initializer))

      2. (Type_ok: (block) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      3. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((block), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Expr_ok: (block) TC_0 |- expression_init : typedExpressionIR_init)

            2. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

            3. If ((typedExpressionIR? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

              2. (Let nameIR be $name(name))

              3. (Let TC_1 be $add_var((block), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

              4. (Let variableDeclarationIR be (annotationList typeIR nameIR ?((= typedExpressionIR_init_cast)) ;))

              5. Result in TC_1, (variableDeclarationIR as parserLocalDeclarationIR)

  (path) valueSetDeclaration TC_0 | ((annotationList value_set< valueSetType >( expression ) name ;) as parserLocalDeclaration)

    1. (Type_ok: (block) TC_0 |- (valueSetType as typeOrVoid) : typeIR # tid*)

    2. If ((tid* matches pattern [])), then

      1. If ((Type_wf: $bound((block), TC_0) |- ((set< [typeIR] >) as typeIR) holds)), then

        1. (Expr_ok: (block) TC_0 |- expression : typedExpressionIR)

        2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR)

        3. If (~(ctk matches pattern `DYN`)), then

          1. (Let nameIR be $name(name))

          2. (Let TC_1 be $add_var((block), TC_0, nameIR, (() ((set< [typeIR] >) as typeIR) (ctk) ?())))

          3. (Let valueSetDeclarationIR be (annotationList value_set< typeIR >( typedExpressionIR ) nameIR ;))

          4. Result in TC_1, (valueSetDeclarationIR as parserLocalDeclarationIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:172.1-175.20
relation ParserLocalDecls_ok

  (match) TC' | parserLocalDeclaration*

    1. (Let TC be TC')

    2. If ((parserLocalDeclaration* matches pattern [])), then

      1. Try matching path nil

    3. (Let TC_0 be TC')

    4. If ((parserLocalDeclaration* matches pattern _ :: _)), then

      1. (Let parserLocalDeclaration_h :: parserLocalDeclaration_t* be parserLocalDeclaration*)

      2. Try matching path cons

  (path) nil TC | []

    1. Result in TC, []

  (path) cons TC_0 | parserLocalDeclaration_h :: parserLocalDeclaration_t*

    1. (ParserLocalDecl_ok: TC_0 |- parserLocalDeclaration_h : TC_1 parserLocalDeclarationIR_h)

    2. (ParserLocalDecls_ok: TC_1 |- parserLocalDeclaration_t* : TC_2 parserLocalDeclarationIR_t*)

    3. Result in TC_2, parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:181.1-183.23
relation TableKey_ok

  (match) TC | TBLC_0 | (expression : name_matchkind annotationList ;)

    1. Try matching path 

  (path)  TC | TBLC_0 | (expression : name_matchkind annotationList ;)

    1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

    2. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

    3. If ((Type_wf: $bound((local), TC) |- ((set< [typeIR] >) as typeIR) holds)), then

      1. (Let nameIR_matchkind be $name(name_matchkind))

      2. If ((((match_kind. nameIR_matchkind) as value) = $find_value((local), TC, (` nameIR_matchkind)))), then

        1. If ($compat_table_key(nameIR_matchkind, typeIR)), then

          1. (Let TBLC_1 be $update_mode(TBLC_0, nameIR_matchkind, typeIR))

          2. (Let TBLC_2 be $add_key(TBLC_1, nameIR_matchkind, typeIR))

          3. (Let tableKeyIR be (typedExpressionIR : nameIR_matchkind annotationList ;))

          4. Result in TBLC_2, tableKeyIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:185.1-187.23
relation TableKeys_ok

  (match) TC | TBLC' | tableKey*

    1. (Let TBLC be TBLC')

    2. If ((tableKey* matches pattern [])), then

      1. Try matching path nil

    3. (Let TBLC_0 be TBLC')

    4. If ((tableKey* matches pattern _ :: _)), then

      1. (Let tableKey_h :: tableKey_t* be tableKey*)

      2. Try matching path cons

  (path) nil TC | TBLC | []

    1. Result in TBLC, []

  (path) cons TC | TBLC_0 | tableKey_h :: tableKey_t*

    1. (TableKey_ok: TC TBLC_0 |- tableKey_h : TBLC_1 tableKeyIR_h)

    2. (TableKeys_ok: TC TBLC_1 |- tableKey_t* : TBLC_2 tableKeyIR_t*)

    3. Result in TBLC_2, tableKeyIR_h :: tableKeyIR_t*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:189.1-192.23
relation Call_action_partial_ok

  (match) TC | parameterTypeIR* | argumentIR*

    1. Try matching path 

  (path)  TC | parameterTypeIR* | argumentIR*

    1. (Let (parameterTypeIR_data*, parameterTypeIR_control*) be $split_dataplane_parameters(parameterTypeIR*))

    2. If ((|parameterTypeIR_data*| = |argumentIR*|)), then

      1. (Call_convention_ok: (local) TC (action) |- parameterTypeIR_data* @ argumentIR* : argumentIR_cast*)

      2. Result in parameterTypeIR_data*, parameterTypeIR_control*, argumentIR_cast*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:194.1-196.23
relation TableAction_ok

  (match) TC | TBLC_0 | (annotationList tableActionReference ;)

    1. If ((tableActionReference has type prefixedNonTypeName)), then

      1. (Let prefixedNonTypeName be (tableActionReference as prefixedNonTypeName))

      2. Try matching path prefixedNonTypeName

    2. If ((tableActionReference matches pattern `%(%)`)), then

      1. (Let (prefixedNonTypeName ( argumentList )) be tableActionReference)

      2. Try matching path prefixedNonTypeName-argumentList

  (path) prefixedNonTypeName TC | TBLC_0 | (annotationList (prefixedNonTypeName as tableActionReference) ;)

    1. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

    2. (Let routineTypeDefIR'? be $find_routine_non_overloaded((local), TC, prefixedNameIR))

    3. If ((routineTypeDefIR'? matches pattern (_))), then

      1. (Let ?(routineTypeDefIR) be routineTypeDefIR'?)

      2. If ((routineTypeDefIR has type functionTypeIR)), then

        1. (Let functionTypeIR be (routineTypeDefIR as functionTypeIR))

        2. If ((functionTypeIR matches pattern `ACTION(%)`)), then

          1. (Let (action( parameterTypeIR* )) be functionTypeIR)

          2. (Call_action_partial_ok: TC |- parameterTypeIR* @ [] : parameterTypeIR_data* , parameterTypeIR_control* @ argumentIR*)

          3. If ((argumentIR* matches pattern [])), then

            1. (Let TBLC_1 be $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*, []))

            2. (Let tableActionIR be (annotationList (prefixedNameIR ( [] )) ;))

            3. Result in TBLC_1, tableActionIR

  (path) prefixedNonTypeName-argumentList TC | TBLC_0 | (annotationList (prefixedNonTypeName ( argumentList )) ;)

    1. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

    2. (Let routineTypeDefIR'? be $find_routine_non_overloaded((local), TC, prefixedNameIR))

    3. If ((routineTypeDefIR'? matches pattern (_))), then

      1. (Let ?(routineTypeDefIR) be routineTypeDefIR'?)

      2. If ((routineTypeDefIR has type functionTypeIR)), then

        1. (Let functionTypeIR be (routineTypeDefIR as functionTypeIR))

        2. If ((functionTypeIR matches pattern `ACTION(%)`)), then

          1. (Let (action( parameterTypeIR* )) be functionTypeIR)

          2. (Let argument* be $flatten_argumentList(argumentList))

          3. (Argument_ok: (local) TC |- argument : argumentIR)*

          4. (Call_action_partial_ok: TC |- parameterTypeIR* @ argumentIR* : parameterTypeIR_data* , parameterTypeIR_control* @ argumentIR_cast*)

          5. (Let TBLC_1 be $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*, argumentIR_cast*))

          6. (Let tableActionIR be (annotationList (prefixedNameIR ( argumentIR_cast* )) ;))

          7. Result in TBLC_1, tableActionIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:198.1-200.23
relation TableActions_ok

  (match) TC | TBLC' | tableAction*

    1. (Let TBLC be TBLC')

    2. If ((tableAction* matches pattern [])), then

      1. Try matching path nil

    3. (Let TBLC_0 be TBLC')

    4. If ((tableAction* matches pattern _ :: _)), then

      1. (Let tableAction_h :: tableAction_t* be tableAction*)

      2. Try matching path cons

  (path) nil TC | TBLC | []

    1. Result in TBLC, []

  (path) cons TC | TBLC_0 | tableAction_h :: tableAction_t*

    1. (TableAction_ok: TC TBLC_0 |- tableAction_h : TBLC_1 tableActionIR_h)

    2. (TableActions_ok: TC TBLC_1 |- tableAction_t* : TBLC_2 tableActionIR_t*)

    3. Result in TBLC_2, tableActionIR_h :: tableActionIR_t*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:202.1-205.23
relation Call_action_default_ok

  (match) TC | parameterTypeIR* | argumentIR*

    1. Try matching path 

  (path)  TC | parameterTypeIR* | argumentIR*

    1. (Let (parameterTypeIR_data*, parameterTypeIR_control*) be $split_dataplane_parameters(parameterTypeIR*))

    2. (Call_convention_ok: (local) TC (action) |- parameterTypeIR* @ argumentIR* : argumentIR_cast*)

    3. Result in parameterTypeIR_data*, parameterTypeIR_control*, argumentIR_cast*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:207.1-209.23
relation TableDefaultAction_ok

  (match) TC | TBLC | (= expression)

    1. Case analysis on expression

      1. Case (% has type prefixedNonTypeName)

        1. (Let prefixedNonTypeName be (expression as prefixedNonTypeName))

        2. Try matching path prefixedNonTypeName

      2. Case (% has type callExpression)

        1. (Let callExpression be (expression as callExpression))

        2. If ((callExpression matches pattern `%(%)`)), then

          1. (Let (callTarget ( argumentList )) be callExpression)

          2. If ((callTarget has type prefixedNonTypeName)), then

            1. (Let prefixedNonTypeName be (callTarget as prefixedNonTypeName))

            2. Try matching path prefixedNonTypeName-argumentList

  (path) prefixedNonTypeName TC | TBLC | (= (prefixedNonTypeName as expression))

    1. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

    2. If ((?(([], [])) = $find_action(TBLC, prefixedNameIR))), then

      1. Result in (prefixedNameIR ( [] ))

  (path) prefixedNonTypeName-argumentList TC | TBLC | (= (((prefixedNonTypeName as callTarget) ( argumentList )) as expression))

    1. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

    2. (Let (parameterTypeIR*, argumentListIR)? be $find_action(TBLC, prefixedNameIR))

    3. If (((parameterTypeIR*, argumentListIR)? matches pattern (_))), then

      1. (Let ?((parameterTypeIR_action*, argumentIR_action*)) be (parameterTypeIR*, argumentListIR)?)

      2. (Let argument* be $flatten_argumentList(argumentList))

      3. (Argument_ok: (local) TC |- argument : argumentIR)*

      4. (Call_action_default_ok: TC |- parameterTypeIR_action* @ argumentIR* : parameterTypeIR_action_data* , parameterTypeIR_action_control* @ argumentIR_cast*)

      5. (Let argumentIR_action_data* be argumentIR_action*[0 : |parameterTypeIR_action_data*|])

      6. (Let argumentIR_cast_data* be argumentIR_cast*[0 : |parameterTypeIR_action_data*|])

      7. If ((argumentIR_action_data = argumentIR_cast_data))*, then

        1. Result in (prefixedNameIR ( argumentIR_cast* ))

;; ../../../../spec-concrete/5.04-typing-relation.watsup:211.1-213.23
relation TableEntry_keyset_ok

  (match) TC | TBLC | keysetExpression

    1. Case analysis on keysetExpression

      1. Case (% has type expression)

        1. (Let expression be (keysetExpression as expression))

        2. Try matching path simpleKeysetExpression-expression

      2. Case (% has type tupleKeysetExpression)

        1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

        2. Case analysis on tupleKeysetExpression

          1. Case (% matches pattern `(%&&&%)`)

            1. (Let (( expression_l &&& expression_r )) be tupleKeysetExpression)

            2. Try matching path tupleKeysetExpression-mask

          2. Case (% matches pattern `(%..%)`)

            1. (Let (( expression_l .. expression_r )) be tupleKeysetExpression)

            2. Try matching path tupleKeysetExpression-range

          3. Case (% matches pattern `(%,%)`)

            1. (Let (( simpleKeysetExpression_h , simpleKeysetExpressionList_t )) be tupleKeysetExpression)

            2. Try matching path tupleKeysetExpression-list

    2. If ((keysetExpression has type simpleKeysetExpression)), then

      1. (Let simpleKeysetExpression be (keysetExpression as simpleKeysetExpression))

      2. Case analysis on simpleKeysetExpression

        1. Case (% matches pattern `%&&&%`)

          1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

          2. Try matching path simpleKeysetExpression-mask

        2. Case (% matches pattern `%..%`)

          1. (Let (expression_l .. expression_r) be simpleKeysetExpression)

          2. Try matching path simpleKeysetExpression-range

    3. If ((keysetExpression = ((default) as keysetExpression))), then

      1. Try matching path simpleKeysetExpression-default

    4. If ((keysetExpression = ((_) as keysetExpression))), then

      1. Try matching path simpleKeysetExpression-dontcare

    5. If ((keysetExpression = (((default)) as keysetExpression))), then

      1. Try matching path tupleKeysetExpression-default

    6. If ((keysetExpression = (((_)) as keysetExpression))), then

      1. Try matching path tupleKeysetExpression-dontcare

  (path) simpleKeysetExpression-expression TC | TBLC | (expression as keysetExpression)

    1. If ((|TBLC.keys| = 1)), then

      1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression as simpleKeysetExpression)] : TBLS simpleKeysetExpressionIR'*)

      2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

        1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

        2. Result in TBLS, (simpleKeysetExpressionIR as keysetExpressionIR)

  (path) simpleKeysetExpression-mask TC | TBLC | ((expression_l &&& expression_r) as keysetExpression)

    1. If ((|TBLC.keys| = 1)), then

      1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression_l &&& expression_r)] : TBLS simpleKeysetExpressionIR'*)

      2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

        1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

        2. Result in TBLS, (simpleKeysetExpressionIR as keysetExpressionIR)

  (path) simpleKeysetExpression-range TC | TBLC | ((expression_l .. expression_r) as keysetExpression)

    1. If ((|TBLC.keys| = 1)), then

      1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression_l .. expression_r)] : TBLS simpleKeysetExpressionIR'*)

      2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

        1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

        2. Result in TBLS, (simpleKeysetExpressionIR as keysetExpressionIR)

  (path) simpleKeysetExpression-default TC | TBLC | ((default) as keysetExpression)

    1. (Let matchMode be TBLC.mode)

    2. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (noprilpm n) be matchMode)

      2. (Let TBLS be (lpm n))

      3. Result in TBLS, ((default) as keysetExpressionIR)

    3. Case analysis on TBLC.mode

      1. Case (% matches pattern `NOPRI`)

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((default) as keysetExpressionIR)

      2. Case (% matches pattern `PRI`)

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((default) as keysetExpressionIR)

      3. Case (% matches pattern `PRILPM`)

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((default) as keysetExpressionIR)

  (path) simpleKeysetExpression-dontcare TC | TBLC | ((_) as keysetExpression)

    1. (Let matchMode be TBLC.mode)

    2. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (noprilpm n) be matchMode)

      2. (Let TBLS be (lpm 0))

      3. Result in TBLS, ((_) as keysetExpressionIR)

    3. Case analysis on TBLC.mode

      1. Case (% matches pattern `NOPRI`)

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((_) as keysetExpressionIR)

      2. Case (% matches pattern `PRI`)

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((_) as keysetExpressionIR)

      3. Case (% matches pattern `PRILPM`)

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((_) as keysetExpressionIR)

  (path) tupleKeysetExpression-mask TC | TBLC | ((( expression_l &&& expression_r )) as keysetExpression)

    1. If ((|TBLC.keys| = 1)), then

      1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression_l &&& expression_r)] : TBLS simpleKeysetExpressionIR'*)

      2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

        1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

        2. Result in TBLS, ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

  (path) tupleKeysetExpression-range TC | TBLC | ((( expression_l .. expression_r )) as keysetExpression)

    1. If ((|TBLC.keys| = 1)), then

      1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ [(expression_l .. expression_r)] : TBLS simpleKeysetExpressionIR'*)

      2. If ((simpleKeysetExpressionIR'* matches pattern [ _/1 ])), then

        1. (Let [simpleKeysetExpressionIR] be simpleKeysetExpressionIR'*)

        2. Result in TBLS, ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

  (path) tupleKeysetExpression-default TC | TBLC | (((default)) as keysetExpression)

    1. (Let matchMode be TBLC.mode)

    2. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (noprilpm n) be matchMode)

      2. (Let TBLS be (lpm n))

      3. Result in TBLS, ((( [(default)] )) as keysetExpressionIR)

    3. Case analysis on TBLC.mode

      1. Case (% matches pattern `NOPRI`)

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((( [(default)] )) as keysetExpressionIR)

      2. Case (% matches pattern `PRI`)

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((( [(default)] )) as keysetExpressionIR)

      3. Case (% matches pattern `PRILPM`)

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((( [(default)] )) as keysetExpressionIR)

  (path) tupleKeysetExpression-dontcare TC | TBLC | (((_)) as keysetExpression)

    1. (Let matchMode be TBLC.mode)

    2. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (noprilpm n) be matchMode)

      2. (Let TBLS be (lpm 0))

      3. Result in TBLS, ((( [(_)] )) as keysetExpressionIR)

    3. Case analysis on TBLC.mode

      1. Case (% matches pattern `NOPRI`)

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((( [(_)] )) as keysetExpressionIR)

      2. Case (% matches pattern `PRI`)

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((( [(_)] )) as keysetExpressionIR)

      3. Case (% matches pattern `PRILPM`)

        1. (Let TBLS be (nolpm))

        2. Result in TBLS, ((( [(_)] )) as keysetExpressionIR)

  (path) tupleKeysetExpression-list TC | TBLC | ((( simpleKeysetExpression_h , simpleKeysetExpressionList_t )) as keysetExpression)

    1. (Let simpleKeysetExpression_t* be $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t))

    2. (Let simpleKeysetExpression* be simpleKeysetExpression_h :: simpleKeysetExpression_t*)

    3. If ((|TBLC.keys| = |simpleKeysetExpression*|)), then

      1. (TableEntry_keysets_simple_ok: TC TBLC (nolpm) |- TBLC.keys @ simpleKeysetExpression* : TBLS simpleKeysetExpressionIR*)

      2. Result in TBLS, ((( simpleKeysetExpressionIR* )) as keysetExpressionIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:215.1-217.23
relation TableEntry_action_ok

  (match) TC | TBLC | tableActionReference

    1. If ((tableActionReference has type prefixedNonTypeName)), then

      1. (Let prefixedNonTypeName be (tableActionReference as prefixedNonTypeName))

      2. Try matching path prefixedNonTypeName

    2. If ((tableActionReference matches pattern `%(%)`)), then

      1. (Let (prefixedNonTypeName ( argumentList )) be tableActionReference)

      2. Try matching path prefixedNonTypeName-argumentList

  (path) prefixedNonTypeName TC | TBLC | (prefixedNonTypeName as tableActionReference)

    1. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

    2. If ((?(([], [])) = $find_action(TBLC, prefixedNameIR))), then

      1. Result in (prefixedNameIR ( [] ))

  (path) prefixedNonTypeName-argumentList TC | TBLC | (prefixedNonTypeName ( argumentList ))

    1. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

    2. (Let (parameterTypeIR*, argumentListIR)? be $find_action(TBLC, prefixedNameIR))

    3. If (((parameterTypeIR*, argumentListIR)? matches pattern (_))), then

      1. (Let ?((parameterTypeIR_action*, argumentIR_action*)) be (parameterTypeIR*, argumentListIR)?)

      2. (Let argument* be $flatten_argumentList(argumentList))

      3. (Argument_ok: (local) TC |- argument : argumentIR)*

      4. (Call_action_default_ok: TC |- parameterTypeIR_action* @ argumentIR* : parameterTypeIR_action_data* , parameterTypeIR_action_control* @ argumentIR_cast*)

      5. (Let argumentIR_action_data* be argumentIR_action*[0 : |parameterTypeIR_action_data*|])

      6. (Let argumentIR_cast_data* be argumentIR_cast*[0 : |parameterTypeIR_action_data*|])

      7. If ((argumentIR_action_data = argumentIR_cast_data))*, then

        1. Result in (prefixedNameIR ( argumentIR_cast* ))

;; ../../../../spec-concrete/5.04-typing-relation.watsup:219.1-222.26
relation TableEntry_priority_ok

  (match) TC | tableContext' | TBLS | tableEntryPriority''?

    1. (Let tableContext be tableContext')

    2. (Let tableEntryPriority be tableEntryPriority'')?

    3. If ((tableEntryPriority? matches pattern ())), then

      1. Try matching path non-specified

    4. (Let TBLC_0 be tableContext')

    5. (Let tableEntryPriority' be tableEntryPriority'')?

    6. If ((tableEntryPriority'? matches pattern (_))), then

      1. (Let ?(tableEntryPriority) be tableEntryPriority'?)

      2. If ((tableEntryPriority matches pattern `PRIORITY=%:`)), then

        1. (Let (priority= numberLiteral :) be tableEntryPriority)

        2. Try matching path specified-number

    7. (Let TBLC_0 be tableContext')

    8. (Let tableEntryPriority' be tableEntryPriority'')?

    9. If ((tableEntryPriority'? matches pattern (_))), then

      1. (Let ?(tableEntryPriority) be tableEntryPriority'?)

      2. If ((tableEntryPriority matches pattern `PRIORITY=(%):`)), then

        1. (Let (priority=( expression ):) be tableEntryPriority)

        2. Try matching path specified-expression

  (path) non-specified TC | tableContext | TBLS | ?()

    1. (Let TBLC be tableContext)

    2. If ((TBLC.mode matches pattern `NOPRI`)), then

      1. Result in TBLC, ?()

    3. (Let TBLC be tableContext)

    4. (Let matchMode be TBLC.mode)

    5. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (noprilpm n) be matchMode)

      2. (Let tableEntryState be TBLS)

      3. If ((tableEntryState matches pattern `LPM%`)), then

        1. (Let (lpm n_prefix) be tableEntryState)

        2. Result in TBLC, ?()

    6. (Let TBLC_0 be tableContext)

    7. Case analysis on TBLC_0.mode

      1. Case (% matches pattern `PRI`)

        1. If ((TBLC_0.priorities.values = [])), then

          1. If (TBLC_0.priorities.largest_wins), then

            1. (Let n_size be TBLC_0.entries.size)

            2. (Let n_delta be TBLC_0.priorities.delta)

            3. (Let n be (((n_size - 1) * n_delta) + 1))

            4. (Let TBLC_1 be $add_table_priority(TBLC_0, n))

            5. Result in TBLC_1, ?((priority= (d (n as int)) :))

      2. Case (% matches pattern `PRILPM`)

        1. If ((TBLC_0.priorities.values = [])), then

          1. If (TBLC_0.priorities.largest_wins), then

            1. (Let n_size be TBLC_0.entries.size)

            2. (Let n_delta be TBLC_0.priorities.delta)

            3. (Let n be (((n_size - 1) * n_delta) + 1))

            4. (Let TBLC_1 be $add_table_priority(TBLC_0, n))

            5. Result in TBLC_1, ?((priority= (d (n as int)) :))

    8. (Let TBLC_0 be tableContext)

    9. Case analysis on TBLC_0.mode

      1. Case (% matches pattern `PRI`)

        1. If ((TBLC_0.priorities.values = [])), then

          1. If (~TBLC_0.priorities.largest_wins), then

            1. (Let TBLC_1 be $add_table_priority(TBLC_0, 1))

            2. Result in TBLC_1, ?((priority= (d (1 as int)) :))

      2. Case (% matches pattern `PRILPM`)

        1. If ((TBLC_0.priorities.values = [])), then

          1. If (~TBLC_0.priorities.largest_wins), then

            1. (Let TBLC_1 be $add_table_priority(TBLC_0, 1))

            2. Result in TBLC_1, ?((priority= (d (1 as int)) :))

    10. (Let TBLC_0 be tableContext)

    11. Case analysis on TBLC_0.mode

      1. Case (% matches pattern `PRI`)

        1. If ((TBLC_0.priorities.values =/= [])), then

          1. If (TBLC_0.priorities.largest_wins), then

            1. (Let n_last be $find_table_priority_last(TBLC_0))

            2. (Let n_delta be TBLC_0.priorities.delta)

            3. (Let n be (n_last - n_delta))

            4. (Let TBLC_1 be $add_table_priority(TBLC_0, n))

            5. Result in TBLC_1, ?((priority= (d (n as int)) :))

      2. Case (% matches pattern `PRILPM`)

        1. If ((TBLC_0.priorities.values =/= [])), then

          1. If (TBLC_0.priorities.largest_wins), then

            1. (Let n_last be $find_table_priority_last(TBLC_0))

            2. (Let n_delta be TBLC_0.priorities.delta)

            3. (Let n be (n_last - n_delta))

            4. (Let TBLC_1 be $add_table_priority(TBLC_0, n))

            5. Result in TBLC_1, ?((priority= (d (n as int)) :))

    12. (Let TBLC_0 be tableContext)

    13. Case analysis on TBLC_0.mode

      1. Case (% matches pattern `PRI`)

        1. If ((TBLC_0.priorities.values =/= [])), then

          1. If (~TBLC_0.priorities.largest_wins), then

            1. (Let n_last be $find_table_priority_last(TBLC_0))

            2. (Let n_delta be TBLC_0.priorities.delta)

            3. (Let n be (n_last + n_delta))

            4. (Let TBLC_1 be $add_table_priority(TBLC_0, n))

            5. Result in TBLC_1, ?((priority= (d (n as int)) :))

      2. Case (% matches pattern `PRILPM`)

        1. If ((TBLC_0.priorities.values =/= [])), then

          1. If (~TBLC_0.priorities.largest_wins), then

            1. (Let n_last be $find_table_priority_last(TBLC_0))

            2. (Let n_delta be TBLC_0.priorities.delta)

            3. (Let n be (n_last + n_delta))

            4. (Let TBLC_1 be $add_table_priority(TBLC_0, n))

            5. Result in TBLC_1, ?((priority= (d (n as int)) :))

  (path) specified-number TC | TBLC_0 | TBLS | ?((priority= numberLiteral :))

    1. Case analysis on TBLC_0.mode

      1. Case (% matches pattern `PRI`)

        1. If (~TBLC_0.entries.const), then

          1. Case analysis on TBLC_0.priorities.values

            1. Case (% = [])

              1. (Let int be $to_number((numberLiteral as value)))

              2. If ((int has type nat)), then

                1. (Let n be (int as nat))

                2. (Let TBLC_1 be TBLC_0[priorities.init = true])

                3. (Let TBLC_2 be $add_table_priority(TBLC_1, n))

                4. Result in TBLC_2, ?((priority= numberLiteral :))

            2. Case (% =/= [])

              1. If (TBLC_0.priorities.init), then

                1. (Let int be $to_number((numberLiteral as value)))

                2. If ((int has type nat)), then

                  1. (Let n be (int as nat))

                  2. (Let TBLC_1 be $add_table_priority(TBLC_0, n))

                  3. Result in TBLC_1, ?((priority= numberLiteral :))

      2. Case (% matches pattern `PRILPM`)

        1. If (~TBLC_0.entries.const), then

          1. Case analysis on TBLC_0.priorities.values

            1. Case (% = [])

              1. (Let int be $to_number((numberLiteral as value)))

              2. If ((int has type nat)), then

                1. (Let n be (int as nat))

                2. (Let TBLC_1 be TBLC_0[priorities.init = true])

                3. (Let TBLC_2 be $add_table_priority(TBLC_1, n))

                4. Result in TBLC_2, ?((priority= numberLiteral :))

            2. Case (% =/= [])

              1. If (TBLC_0.priorities.init), then

                1. (Let int be $to_number((numberLiteral as value)))

                2. If ((int has type nat)), then

                  1. (Let n be (int as nat))

                  2. (Let TBLC_1 be $add_table_priority(TBLC_0, n))

                  3. Result in TBLC_1, ?((priority= numberLiteral :))

  (path) specified-expression TC | TBLC_0 | TBLS | ?((priority=( expression ):))

    1. Case analysis on TBLC_0.mode

      1. Case (% matches pattern `PRI`)

        1. If (~TBLC_0.entries.const), then

          1. Case analysis on TBLC_0.priorities.values

            1. Case (% = [])

              1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

              2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR)

              3. If ((ctk matches pattern `LCTK`)), then

                1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

                2. (Let int be $to_number(value))

                3. If ((int has type nat)), then

                  1. (Let n be (int as nat))

                  2. (Let TBLC_1 be TBLC_0[priorities.init = true])

                  3. (Let TBLC_2 be $add_table_priority(TBLC_1, n))

                  4. Result in TBLC_2, ?((priority=( typedExpressionIR ):))

            2. Case (% =/= [])

              1. If (TBLC_0.priorities.init), then

                1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

                2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR)

                3. If ((ctk matches pattern `LCTK`)), then

                  1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

                  2. (Let int be $to_number(value))

                  3. If ((int has type nat)), then

                    1. (Let n be (int as nat))

                    2. (Let TBLC_1 be $add_table_priority(TBLC_0, n))

                    3. Result in TBLC_1, ?((priority=( typedExpressionIR ):))

      2. Case (% matches pattern `PRILPM`)

        1. If (~TBLC_0.entries.const), then

          1. Case analysis on TBLC_0.priorities.values

            1. Case (% = [])

              1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

              2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR)

              3. If ((ctk matches pattern `LCTK`)), then

                1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

                2. (Let int be $to_number(value))

                3. If ((int has type nat)), then

                  1. (Let n be (int as nat))

                  2. (Let TBLC_1 be TBLC_0[priorities.init = true])

                  3. (Let TBLC_2 be $add_table_priority(TBLC_1, n))

                  4. Result in TBLC_2, ?((priority=( typedExpressionIR ):))

            2. Case (% =/= [])

              1. If (TBLC_0.priorities.init), then

                1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

                2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR)

                3. If ((ctk matches pattern `LCTK`)), then

                  1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

                  2. (Let int be $to_number(value))

                  3. If ((int has type nat)), then

                    1. (Let n be (int as nat))

                    2. (Let TBLC_1 be $add_table_priority(TBLC_0, n))

                    3. Result in TBLC_1, ?((priority=( typedExpressionIR ):))

;; ../../../../spec-concrete/5.04-typing-relation.watsup:224.1-226.23
relation TableEntry_ok

  (match) TC | TBLC_0 | tableEntry

    1. Case analysis on tableEntry

      1. Case (% matches pattern `%%%:%%;`)

        1. (Let (constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ;) be tableEntry)

        2. Try matching path priority

      2. Case (% matches pattern `%%:%%;`)

        1. (Let (constOpt keysetExpression : tableActionReference annotationList ;) be tableEntry)

        2. Try matching path non-priority

  (path) priority TC | TBLC_0 | (constOpt tableEntryPriority keysetExpression : tableActionReference annotationList ;)

    1. (TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR)

    2. (TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR)

    3. (TableEntry_priority_ok: TC TBLC_0 TBLS |- ?(tableEntryPriority) : TBLC_1 tableEntryPriorityOptIR)

    4. (Let constOptIR be $flatten_constOpt(constOpt))

    5. (Let tableEntryIR be (constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;))

    6. Result in TBLC_1, tableEntryIR

  (path) non-priority TC | TBLC_0 | (constOpt keysetExpression : tableActionReference annotationList ;)

    1. (TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR)

    2. (TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR)

    3. (TableEntry_priority_ok: TC TBLC_0 TBLS |- ?() : TBLC_1 tableEntryPriorityOptIR)

    4. (Let constOptIR be $flatten_constOpt(constOpt))

    5. (Let tableEntryIR be (constOptIR tableEntryPriorityOptIR keysetExpressionIR : tableActionReferenceIR annotationList ;))

    6. Result in TBLC_1, tableEntryIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:228.1-230.23
relation TableEntries_ok

  (match) TC | TBLC' | tableEntry*

    1. (Let TBLC be TBLC')

    2. If ((tableEntry* matches pattern [])), then

      1. Try matching path nil

    3. (Let TBLC_0 be TBLC')

    4. If ((tableEntry* matches pattern _ :: _)), then

      1. (Let tableEntry_h :: tableEntry_t* be tableEntry*)

      2. Try matching path cons

  (path) nil TC | TBLC | []

    1. Result in TBLC, []

  (path) cons TC | TBLC_0 | tableEntry_h :: tableEntry_t*

    1. (TableEntry_ok: TC TBLC_0 |- tableEntry_h : TBLC_1 tableEntryIR_h)

    2. (TableEntries_ok: TC TBLC_1 |- tableEntry_t* : TBLC_2 tableEntryIR_t*)

    3. Result in TBLC_2, tableEntryIR_h :: tableEntryIR_t*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:232.1-234.23
relation TableProperty_ok

  (match) TC | TBLC_0' | tableProperty

    1. (Let TBLC_0 be TBLC_0')

    2. If ((tableProperty matches pattern `KEY={%}`)), then

      1. (Let (key={ tableKeyList }) be tableProperty)

      2. Try matching path key

    3. (Let TBLC_0 be TBLC_0')

    4. If ((tableProperty matches pattern `ACTIONS={%}`)), then

      1. (Let (actions={ tableActionList }) be tableProperty)

      2. Try matching path actions

    5. (Let TBLC_0 be TBLC_0')

    6. If ((tableProperty matches pattern `%%ENTRIES={%}`)), then

      1. (Let (annotationList constOpt entries={ tableEntryList }) be tableProperty)

      2. Try matching path entries

    7. (Let TBLC be TBLC_0')

    8. If ((tableProperty matches pattern `%%%%;`)), then

      1. (Let (annotationList constOpt tableCustomName initializer ;) be tableProperty)

      2. Try matching path default-action

    9. (Let tableContext be TBLC_0')

    10. If ((tableProperty matches pattern `%%%%;`)), then

      1. (Let (annotationList constOpt tableCustomName (= expression) ;) be tableProperty)

      2. Try matching path custom

  (path) key TC | TBLC_0 | (key={ tableKeyList })

    1. (Let tableKey* be $flatten_tableKeyList(tableKeyList))

    2. (TableKeys_ok: TC TBLC_0 |- tableKey* : TBLC_1 tableKeyIR*)

    3. Result in TBLC_1, (key={ tableKeyIR* })

  (path) actions TC | TBLC_0 | (actions={ tableActionList })

    1. (Let tableAction* be $flatten_tableActionList(tableActionList))

    2. (TableActions_ok: TC TBLC_0 |- tableAction* : TBLC_1 tableActionIR*)

    3. Result in TBLC_1, (actions={ tableActionIR* })

  (path) entries TC | TBLC_0 | (annotationList constOpt entries={ tableEntryList })

    1. (Let tableEntry* be $flatten_tableEntryList(tableEntryList))

    2. If (((|TBLC_0.keys| = 0) => (|tableEntry*| = 0))), then

      1. (Let TBLC_1 be TBLC_0[entries.size = |tableEntry*|])

      2. (Let constOptIR be $flatten_constOpt(constOpt))

      3. (Let TBLC_2 be TBLC_1[entries.const = (constOptIR = ?((const)))])

      4. (TableEntries_ok: TC TBLC_2 |- tableEntry* : TBLC_3 tableEntryIR*)

      5. Result in TBLC_3, (annotationList constOptIR entries={ tableEntryIR* })

  (path) default-action TC | TBLC | (annotationList constOpt tableCustomName initializer ;)

    1. If (("default_action" = $tableCustomName(tableCustomName))), then

      1. (TableDefaultAction_ok: TC TBLC |- initializer : tableActionReferenceIR)

      2. (Let constOptIR be $flatten_constOpt(constOpt))

      3. (Let tablePropertyIR be (annotationList constOptIR default_action= tableActionReferenceIR ;))

      4. Result in TBLC, tablePropertyIR

  (path) custom TC | tableContext | (annotationList constOpt tableCustomName (= expression) ;)

    1. (Let TBLC be tableContext)

    2. If (("size" = $tableCustomName(tableCustomName))), then

      1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      2. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

      3. If ((($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))), then

        1. (Let constOptIR be $flatten_constOpt(constOpt))

        2. (Let tablePropertyIR be (annotationList constOptIR custom "size" (= typedExpressionIR) ;))

        3. Result in TBLC, tablePropertyIR

    3. (Let TBLC_0 be tableContext)

    4. If (("largest_priority_wins" = $tableCustomName(tableCustomName))), then

      1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      2. (Let (_expressionIR # (( typeIR' _ctk ))) be typedExpressionIR)

      3. If ((typeIR' = ((bool) as typeIR))), then

        1. (Eval_static: (local) TC |- typedExpressionIR ~> value')

        2. If ((value' has type primitiveValue)), then

          1. (Let primitiveValue be (value' as primitiveValue))

          2. If ((primitiveValue matches pattern `B%`)), then

            1. (Let (b b_largest_priority_wins) be primitiveValue)

            2. (Let TBLC_1 be TBLC_0[priorities.largest_wins = b_largest_priority_wins])

            3. (Let constOptIR be $flatten_constOpt(constOpt))

            4. (Let tablePropertyIR be (annotationList constOptIR custom_const "largest_priority_wins" (= ((b b_largest_priority_wins) as value)) ;))

            5. Result in TBLC_1, tablePropertyIR

    5. (Let TBLC_0 be tableContext)

    6. If (("priority_delta" = $tableCustomName(tableCustomName))), then

      1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      2. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

      3. If ((($is_arbitrary_int_typeIR(typeIR) \/ $is_fixed_int_typeIR(typeIR)) \/ $is_fixed_bit_typeIR(typeIR))), then

        1. (Eval_static: (local) TC |- typedExpressionIR ~> value)

        2. (Let int be $to_number(value))

        3. If ((int has type nat)), then

          1. (Let n_delta be (int as nat))

          2. If ((n_delta > 0)), then

            1. (Let TBLC_1 be TBLC_0[priorities.delta = n_delta])

            2. (Let constOptIR be $flatten_constOpt(constOpt))

            3. (Let tablePropertyIR be (annotationList constOptIR custom_const "priority_delta" (= ((d (n_delta as int)) as value)) ;))

            4. Result in TBLC_1, tablePropertyIR

    7. (Let TBLC be tableContext)

    8. (Let nameIR be $tableCustomName(tableCustomName))

    9. If ((((nameIR =/= "size") /\ (nameIR =/= "largest_priority_wins")) /\ (nameIR =/= "priority_delta"))), then

      1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      2. (Let constOptIR be $flatten_constOpt(constOpt))

      3. (Let tablePropertyIR be (annotationList constOptIR custom nameIR (= typedExpressionIR) ;))

      4. Result in TBLC, tablePropertyIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:236.1-238.23
relation TableProperties_ok

  (match) TC | TBLC' | tableProperty*

    1. (Let TBLC be TBLC')

    2. If ((tableProperty* matches pattern [])), then

      1. Try matching path nil

    3. (Let TBLC_0 be TBLC')

    4. If ((tableProperty* matches pattern _ :: _)), then

      1. (Let tableProperty_h :: tableProperty_t* be tableProperty*)

      2. Try matching path cons

  (path) nil TC | TBLC | []

    1. Result in TBLC, []

  (path) cons TC | TBLC_0 | tableProperty_h :: tableProperty_t*

    1. (TableProperty_ok: TC TBLC_0 |- tableProperty_h : TBLC_1 tablePropertyIR_h)

    2. (TableProperties_ok: TC TBLC_1 |- tableProperty_t* : TBLC_2 tablePropertyIR_t*)

    3. Result in TBLC_2, tablePropertyIR_h :: tablePropertyIR_t*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:240.1-242.20
relation Table_ok

  (match) TC | tableProperty*

    1. Try matching path 

  (path)  TC | tableProperty*

    1. If (($count_table_keys(tableProperty*) <= 1)), then

      1. If (($count_table_actions(tableProperty*) = 1)), then

        1. (Let TBLC_0 be $empty_tableContext)

        2. (TableProperties_ok: TC TBLC_0 |- tableProperty* : TBLC_1 tablePropertyIR*)

        3. Result in TBLC_1, tablePropertyIR*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:244.1-246.23
relation TableType_ok

  (match) TC_0 | TBLC | name

    1. Try matching path 

  (path)  TC_0 | TBLC | name

    1. (Let nameIR be $name(name))

    2. (Let tid_enum be "action_list(" ++ nameIR ++ ")")

    3. (Let (prefixedNameIR_action, _parameterTypeIR*, _argumentListIR)* be TBLC.actions)

    4. (Let id_enum_field be $flatten_prefixedNameIR(prefixedNameIR_action))*

    5. (Let typeIR_table_enum be ((table_enum tid_enum { id_enum_field* }) as typeIR))

    6. (Let value_enum_field be ((table_enum tid_enum . id_enum_field) as value))*

    7. (Let varTypeIR_enum_field be (() typeIR_table_enum (lctk) ?(value_enum_field)))*

    8. (Let TC_1 be $add_vars((block), TC_0, tid_enum ++ "." ++ id_enum_field*, varTypeIR_enum_field*))

    9. (Let tid_struct be "apply_result(" ++ nameIR ++ ")")

    10. (Let typeIR_table_struct be ((table_struct tid_struct { [(((bool) as typeIR) "hit" ;), (((bool) as typeIR) "miss" ;), (typeIR_table_enum "action_run" ;)] }) as typeIR))

    11. (Let typeIR_table be ((table nameIR # typeIR_table_struct) as typeIR))

    12. Result in TC_1, typeIR_table

;; ../../../../spec-concrete/5.04-typing-relation.watsup:248.1-251.20
relation ControlLocalDecl_ok

  (match) TC_0 | controlLocalDeclaration

    1. Case analysis on controlLocalDeclaration

      1. Case (% has type constantDeclaration)

        1. (Let constantDeclaration be (controlLocalDeclaration as constantDeclaration))

        2. Try matching path constantDeclaration

      2. Case (% has type instantiation)

        1. (Let instantiation be (controlLocalDeclaration as instantiation))

        2. Try matching path instantiation

      3. Case (% has type variableDeclaration)

        1. (Let (annotationList type name initializerOpt ;) be (controlLocalDeclaration as variableDeclaration))

        2. Try matching path variableDeclaration

      4. Case (% has type actionDeclaration)

        1. (Let actionDeclaration be (controlLocalDeclaration as actionDeclaration))

        2. Try matching path actionDeclaration

      5. Case (% has type tableDeclaration)

        1. (Let (annotationList table name { tablePropertyList }) be (controlLocalDeclaration as tableDeclaration))

        2. Try matching path tableDeclaration

  (path) constantDeclaration TC_0 | (constantDeclaration as controlLocalDeclaration)

    1. (Decl_ok: (block) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

    2. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

      2. Result in TC_1, (constantDeclarationIR as controlLocalDeclarationIR)

  (path) instantiation TC_0 | (instantiation as controlLocalDeclaration)

    1. (Decl_ok: (block) TC_0 |- (instantiation as declaration) : TC_1 declarationIR)

    2. If ((declarationIR has type instantiationIR)), then

      1. (Let instantiationIR be (declarationIR as instantiationIR))

      2. Result in TC_1, (instantiationIR as controlLocalDeclarationIR)

  (path) variableDeclaration TC_0 | ((annotationList type name initializerOpt ;) as controlLocalDeclaration)

    1. If ((() = initializerOpt)), then

      1. (Type_ok: (block) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      2. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((block), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Let nameIR be $name(name))

            2. (Let TC_1 be $add_var((block), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

            3. (Let variableDeclarationIR be (annotationList typeIR nameIR ?() ;))

            4. Result in TC_1, (variableDeclarationIR as controlLocalDeclarationIR)

    2. (Let initializerOpt' be initializerOpt)

    3. If ((initializerOpt' has type initializer)), then

      1. (Let (= expression_init) be (initializerOpt' as initializer))

      2. (Type_ok: (block) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

      3. If ((tid* matches pattern [])), then

        1. If ((Type_wf: $bound((block), TC_0) |- typeIR holds)), then

          1. If ($is_assignable_typeIR(typeIR)), then

            1. (Expr_ok: (block) TC_0 |- expression_init : typedExpressionIR_init)

            2. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_init, typeIR))

            3. If ((typedExpressionIR? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?)

              2. (Let nameIR be $name(name))

              3. (Let TC_1 be $add_var((block), TC_0, nameIR, ((inout) typeIR (dyn) ?())))

              4. (Let variableDeclarationIR be (annotationList typeIR nameIR ?((= typedExpressionIR_init_cast)) ;))

              5. Result in TC_1, (variableDeclarationIR as controlLocalDeclarationIR)

  (path) actionDeclaration TC_0 | (actionDeclaration as controlLocalDeclaration)

    1. (Decl_ok: (block) TC_0 |- (actionDeclaration as declaration) : TC_1 declarationIR)

    2. If ((declarationIR has type actionDeclarationIR)), then

      1. (Let actionDeclarationIR be (declarationIR as actionDeclarationIR))

      2. Result in TC_1, (actionDeclarationIR as controlLocalDeclarationIR)

  (path) tableDeclaration TC_0 | ((annotationList table name { tablePropertyList }) as controlLocalDeclaration)

    1. (Let TC_1 be TC_0[local.kind = (table_apply_method)])

    2. (Let tableProperty* be $flatten_tablePropertyList(tablePropertyList))

    3. (Table_ok: TC_1 |- tableProperty* : TBLC tablePropertyIR*)

    4. (Let nameIR be $name(name))

    5. (TableType_ok: TC_1 TBLC |- name : TC_2 typeIR_table)

    6. (Let TC_3 be $add_var((block), TC_2, nameIR, (() typeIR_table (dyn) ?())))

    7. (Let tableDeclarationIR be (annotationList table typeIR_table nameIR { tablePropertyIR* }))

    8. Result in TC_3, (tableDeclarationIR as controlLocalDeclarationIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:253.1-256.20
relation ControlLocalDecls_ok

  (match) TC' | controlLocalDeclaration*

    1. (Let TC be TC')

    2. If ((controlLocalDeclaration* matches pattern [])), then

      1. Try matching path nil

    3. (Let TC_0 be TC')

    4. If ((controlLocalDeclaration* matches pattern _ :: _)), then

      1. (Let controlLocalDeclaration_h :: controlLocalDeclaration_t* be controlLocalDeclaration*)

      2. Try matching path cons

  (path) nil TC | []

    1. Result in TC, []

  (path) cons TC_0 | controlLocalDeclaration_h :: controlLocalDeclaration_t*

    1. (ControlLocalDecl_ok: TC_0 |- controlLocalDeclaration_h : TC_1 controlLocalDeclarationIR_h)

    2. (ControlLocalDecls_ok: TC_1 |- controlLocalDeclaration_t* : TC_2 controlLocalDeclarationIR_t*)

    3. Result in TC_2, controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:262.1-264.23
relation Decl_ok

  (match) p' | TC_0 | declaration

    1. (Let p be p')

    2. If ((declaration has type constantDeclaration)), then

      1. (Let (annotationList const type name (= expression_value) ;) be (declaration as constantDeclaration))

      2. Try matching path constantDeclaration

    3. (Let p be p')

    4. If ((declaration has type instantiation)), then

      1. (Let instantiation be (declaration as instantiation))

      2. If ((instantiation matches pattern `%%(%)%;`)), then

        1. (Let (annotationList type ( argumentList ) name ;) be instantiation)

        2. Try matching path instantiation-non-objectInitializer

    5. (Let p be p')

    6. If ((declaration has type instantiation)), then

      1. (Let instantiation be (declaration as instantiation))

      2. If ((instantiation matches pattern `%%(%)%%;`)), then

        1. (Let (annotationList type ( argumentList ) name (={ objectDeclarationList }) ;) be instantiation)

        2. Try matching path instantiation-objectInitializer

    7. (Let p be p')

    8. If ((declaration has type functionDeclaration)), then

      1. (Let (annotationList (typeOrVoid name typeParameterListOpt ( parameterList )) blockStatement) be (declaration as functionDeclaration))

      2. Try matching path functionDeclaration

    9. (Let p be p')

    10. If ((declaration has type actionDeclaration)), then

      1. (Let (annotationList action name ( parameterList ) blockStatement) be (declaration as actionDeclaration))

      2. Try matching path actionDeclaration

    11. (Let cursor be p')

    12. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type errorDeclaration)), then

        1. (Let (error{ nameList }) be (declaration as errorDeclaration))

        2. Try matching path errorDeclaration

    13. (Let cursor be p')

    14. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type matchKindDeclaration)), then

        1. (Let (match_kind{ nameList _trailingCommaOpt }) be (declaration as matchKindDeclaration))

        2. Try matching path matchKindDeclaration

    15. (Let cursor be p')

    16. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type externFunctionDeclaration)), then

        1. (Let (annotationList extern (typeOrVoid name typeParameterListOpt ( parameterList )) ;) be (declaration as externFunctionDeclaration))

        2. Try matching path externDeclaration-externFunctionDeclaration

    17. (Let cursor be p')

    18. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type externObjectDeclaration)), then

        1. (Let (annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }) be (declaration as externObjectDeclaration))

        2. Try matching path externDeclaration-externObjectDeclaration

    19. (Let cursor be p')

    20. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type parserDeclaration)), then

        1. (Let (annotationList parser name typeParameterListOpt ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }) be (declaration as parserDeclaration))

        2. If ((typeParameterListOpt matches pattern ``EMPTY`)), then

          1. Try matching path parserDeclaration

    21. (Let cursor be p')

    22. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type controlDeclaration)), then

        1. (Let (annotationList control name typeParameterListOpt ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }) be (declaration as controlDeclaration))

        2. If ((typeParameterListOpt matches pattern ``EMPTY`)), then

          1. Try matching path controlDeclaration

    23. (Let cursor be p')

    24. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type enumTypeDeclaration)), then

        1. (Let enumTypeDeclaration be (declaration as enumTypeDeclaration))

        2. If ((enumTypeDeclaration matches pattern `%ENUM%{%%}`)), then

          1. (Let (annotationList enum name { nameList_field _trailingCommaOpt }) be enumTypeDeclaration)

          2. Try matching path typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration

    25. (Let cursor be p')

    26. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type enumTypeDeclaration)), then

        1. (Let enumTypeDeclaration be (declaration as enumTypeDeclaration))

        2. If ((enumTypeDeclaration matches pattern `%ENUM%%{%%}`)), then

          1. (Let (annotationList enum type name { namedExpressionList_field _trailingCommaOpt }) be enumTypeDeclaration)

          2. Try matching path typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration-serializable

    27. (Let cursor be p')

    28. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type structTypeDeclaration)), then

        1. (Let (annotationList struct name typeParameterListOpt { typeFieldList }) be (declaration as structTypeDeclaration))

        2. Try matching path typeDeclaration-derivedTypeDeclaration-structTypeDeclaration

    29. (Let cursor be p')

    30. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type headerTypeDeclaration)), then

        1. (Let (annotationList header name typeParameterListOpt { typeFieldList }) be (declaration as headerTypeDeclaration))

        2. Try matching path typeDeclaration-derivedTypeDeclaration-headerTypeDeclaration

    31. (Let cursor be p')

    32. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type headerUnionTypeDeclaration)), then

        1. (Let (annotationList header_union name typeParameterListOpt { typeFieldList }) be (declaration as headerUnionTypeDeclaration))

        2. Try matching path typeDeclaration-derivedTypeDeclaration-headerUnionTypeDeclaration

    33. (Let cursor be p')

    34. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type typedefDeclaration)), then

        1. (Let typedefDeclaration be (declaration as typedefDeclaration))

        2. If ((typedefDeclaration matches pattern `%TYPEDEF%%;`)), then

          1. (Let (annotationList typedef typedefType name ;) be typedefDeclaration)

          2. Try matching path typeDeclaration-typedefDeclaration-typedef

    35. (Let cursor be p')

    36. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type typedefDeclaration)), then

        1. (Let typedefDeclaration be (declaration as typedefDeclaration))

        2. If ((typedefDeclaration matches pattern `%TYPE%%;`)), then

          1. (Let (annotationList type type name ;) be typedefDeclaration)

          2. Try matching path typeDeclaration-typedefDeclaration-newtype

    37. (Let cursor be p')

    38. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type parserTypeDeclaration)), then

        1. (Let (annotationList parser name typeParameterListOpt ( parameterList );) be (declaration as parserTypeDeclaration))

        2. Try matching path typeDeclaration-parserTypeDeclaration

    39. (Let cursor be p')

    40. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type controlTypeDeclaration)), then

        1. (Let (annotationList control name typeParameterListOpt ( parameterList );) be (declaration as controlTypeDeclaration))

        2. Try matching path typeDeclaration-controlTypeDeclaration

    41. (Let cursor be p')

    42. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declaration has type packageTypeDeclaration)), then

        1. (Let (annotationList package name typeParameterListOpt ( parameterList );) be (declaration as packageTypeDeclaration))

        2. Try matching path typeDeclaration-packageTypeDeclaration

  (path) constantDeclaration p | TC_0 | ((annotationList const type name (= expression_value) ;) as declaration)

    1. (Type_ok: p TC_0 |- (type as typeOrVoid) : typeIR # tid*)

    2. If ((tid* matches pattern [])), then

      1. If ((Type_wf: $bound(p, TC_0) |- typeIR holds)), then

        1. (Expr_ok: p TC_0 |- expression_value : typedExpressionIR_value)

        2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR_value)

        3. If ((ctk matches pattern `LCTK`)), then

          1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_value, typeIR))

          2. If ((typedExpressionIR? matches pattern (_))), then

            1. (Let ?(typedExpressionIR_value_cast) be typedExpressionIR?)

            2. (Eval_static: p TC_0 |- typedExpressionIR_value_cast ~> value)

            3. (Let nameIR be $name(name))

            4. (Let TC_1 be $add_var(p, TC_0, nameIR, (() typeIR (lctk) ?(value))))

            5. (Let constantDeclarationIR be (annotationList const typeIR nameIR (= value) ;))

            6. Result in TC_1, (constantDeclarationIR as declarationIR)

  (path) instantiation-non-objectInitializer p | TC_0 | ((annotationList type ( argumentList ) name ;) as declaration)

    1. (Let type' be type)

    2. If ((type' has type prefixedTypeName)), then

      1. (Let prefixedTypeName be (type' as prefixedTypeName))

      2. (Let argument* be $flatten_argumentList(argumentList))

      3. (Argument_ok: p TC_0 |- argument : argumentIR)*

      4. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

      5. (ConstructorType_ok: p TC_0 |- prefixedNameIR < [] >( argumentIR* ): constructorTypeIR <# tid_impl* >(# id_default* ))

      6. (Inst_ok: p TC_0 (named) |- constructorTypeIR < [] # tid_impl* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

      7. (Let nameIR be $name(name))

      8. (Let TC_1 be $add_var(p, TC_0, nameIR, (() typeIR_object (ctk) ?())))

      9. (Let instantiationIR be (annotationList prefixedNameIR < typeArgumentIR_inferred* >( argumentIR* ) nameIR ?() ;))

      10. Result in TC_1, (instantiationIR as declarationIR)

    3. (Let type' be type)

    4. If ((type' has type specializedType)), then

      1. (Let (prefixedTypeName < typeArgumentList >) be (type' as specializedType))

      2. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

      3. (TypeArguments_ok: p TC_0 |- typeArgument* : typeArgumentIR* # tid_impl*)

      4. (Let argument* be $flatten_argumentList(argumentList))

      5. (Argument_ok: p TC_0 |- argument : argumentIR)*

      6. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

      7. (ConstructorType_ok: p TC_0 |- prefixedNameIR < typeArgumentIR* >( argumentIR* ): constructorTypeIR <# tid_inserted* >(# id_default* ))

      8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

      9. (Inst_ok: p TC_0 (named) |- constructorTypeIR < typeArgumentIR* # tid_infer* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

      10. (Let nameIR be $name(name))

      11. (Let TC_1 be $add_var(p, TC_0, nameIR, (() typeIR_object (ctk) ?())))

      12. (Let instantiationIR be (annotationList prefixedNameIR < typeArgumentIR_inferred* >( argumentIR* ) nameIR ?() ;))

      13. Result in TC_1, (instantiationIR as declarationIR)

  (path) instantiation-objectInitializer p | TC_0 | ((annotationList type ( argumentList ) name (={ objectDeclarationList }) ;) as declaration)

    1. (Let type' be type)

    2. If ((type' has type prefixedTypeName)), then

      1. (Let prefixedTypeName be (type' as prefixedTypeName))

      2. (Let argument* be $flatten_argumentList(argumentList))

      3. (Argument_ok: p TC_0 |- argument : argumentIR)*

      4. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

      5. (ConstructorType_ok: p TC_0 |- prefixedNameIR < [] >( argumentIR* ): constructorTypeIR <# tid_impl* >(# id_default* ))

      6. (Inst_ok: p TC_0 (named) |- constructorTypeIR < [] # tid_impl* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

      7. If ($is_extern_object_typeIR($canon(typeIR_object))), then

        1. (Let typeIR' be typeIR_object)

        2. If ((typeIR' has type namedTypeIR)), then

          1. (Let namedTypeIR be (typeIR' as namedTypeIR))

          2. If ((namedTypeIR matches pattern `%<%>`)), then

            1. (Let ((typeIR < tid_expl* , tid'* >) < typeIR_arg* >) be namedTypeIR)

            2. If ((typeIR has type externObjectTypeIR)), then

              1. (Let (extern tid_extern rdenv_extern) be (typeIR as externObjectTypeIR))

              2. If ((tid'* = tid_impl*)), then

                1. (Let TC_1 be $add_var((local), TC_0, "this", (() typeIR_object (ctk) ?())))

                2. (Let objectDeclaration* be $flatten_objectDeclarationList(objectDeclarationList))

                3. (Decls_object_ok: p TC_1 ({ [] }) ({ [] }) |- objectDeclaration* : frame_init rdenv_init objectDeclarationIR*)

                4. (Let tid* be tid_expl* ++ tid_impl*)

                5. (Let theta be ({ (tid : typeIR_arg)* }))

                6. (Let rdenv_init_subst be $subst_rdenv(theta, rdenv_extern, rdenv_init))

                7. (Let typeIR_object_init be (((((extern tid_extern rdenv_init_subst) as typeIR) < tid_expl* , tid_impl* >) < typeIR_arg* >) as typeIR))

                8. If ($is_concrete_extern_object(typeIR_object_init)), then

                  1. (Let nameIR be $name(name))

                  2. (Let TC_2 be $add_var(p, TC_0, nameIR, (() typeIR_object_init (ctk) ?())))

                  3. (Let instantiationIR be (annotationList prefixedNameIR < typeArgumentIR_inferred* >( argumentIR* ) nameIR ?((={ objectDeclarationIR* })) ;))

                  4. Result in TC_2, (instantiationIR as declarationIR)

    3. (Let type' be type)

    4. If ((type' has type specializedType)), then

      1. (Let (prefixedTypeName < typeArgumentList >) be (type' as specializedType))

      2. (Let typeArgument* be $flatten_typeArgumentList(typeArgumentList))

      3. (TypeArguments_ok: p TC_0 |- typeArgument* : typeArgumentIR* # tid_impl*)

      4. (Let argument* be $flatten_argumentList(argumentList))

      5. (Argument_ok: p TC_0 |- argument : argumentIR)*

      6. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

      7. (ConstructorType_ok: p TC_0 |- prefixedNameIR < typeArgumentIR* >( argumentIR* ): constructorTypeIR <# tid_inserted* >(# id_default* ))

      8. (Let tid_infer* be tid_impl* ++ tid_inserted*)

      9. (Inst_ok: p TC_0 (named) |- constructorTypeIR < typeArgumentIR* # tid_infer* >( argumentIR* # id_default* ): typeIR_object < typeArgumentIR_inferred* >( argumentIR_cast* ))

      10. If ($is_extern_object_typeIR($canon(typeIR_object))), then

        1. (Let typeIR' be typeIR_object)

        2. If ((typeIR' has type namedTypeIR)), then

          1. (Let namedTypeIR be (typeIR' as namedTypeIR))

          2. If ((namedTypeIR matches pattern `%<%>`)), then

            1. (Let ((typeIR < tid_expl* , tid'* >) < typeIR_arg* >) be namedTypeIR)

            2. If ((typeIR has type externObjectTypeIR)), then

              1. (Let (extern tid_extern rdenv_extern) be (typeIR as externObjectTypeIR))

              2. If ((tid'* = tid_impl*)), then

                1. (Let TC_1 be $add_var((local), TC_0, "this", (() typeIR_object (ctk) ?())))

                2. (Let objectDeclaration* be $flatten_objectDeclarationList(objectDeclarationList))

                3. (Decls_object_ok: p TC_1 ({ [] }) ({ [] }) |- objectDeclaration* : frame_init rdenv_init objectDeclarationIR*)

                4. (Let tid* be tid_expl* ++ tid_impl*)

                5. (Let theta be ({ (tid : typeIR_arg)* }))

                6. (Let rdenv_init_subst be $subst_rdenv(theta, rdenv_extern, rdenv_init))

                7. (Let typeIR_object_init be (((((extern tid_extern rdenv_init_subst) as typeIR) < tid_expl* , tid_impl* >) < typeIR_arg* >) as typeIR))

                8. If ($is_concrete_extern_object(typeIR_object_init)), then

                  1. (Let nameIR be $name(name))

                  2. (Let TC_2 be $add_var(p, TC_0, nameIR, (() typeIR_object_init (ctk) ?())))

                  3. (Let instantiationIR be (annotationList prefixedNameIR < typeArgumentIR_inferred* >( argumentIR* ) nameIR ?((={ objectDeclarationIR* })) ;))

                  4. Result in TC_2, (instantiationIR as declarationIR)

  (path) functionDeclaration p | TC_0 | ((annotationList (typeOrVoid name typeParameterListOpt ( parameterList )) blockStatement) as declaration)

    1. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

    2. (Let tid_expl be $name(typeParameter))*

    3. (Let TC_1 be $add_types((local), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    4. (Type_ok: (local) TC_1 |- typeOrVoid : typeIR_ret # tid*)

    5. If ((tid* matches pattern [])), then

      1. (Let parameter* be $flatten_parameterList(parameterList))

      2. (Parameters_ok: (local) TC_1 |- parameter* : parameterIR* # tid_impl*)

      3. (Let parameterTypeIR be $parameterIR(parameterIR))*

      4. (Let TC_2 be $add_parameters((local), TC_1, parameterTypeIR*))

      5. (Let TC_3 be TC_2[local.kind = (function-> typeIR_ret)])

      6. (Block_ok: TC_3 (cont) |- blockStatement : _typingContext f blockStatementIR)

      7. If (((f = (ret)) \/ (typeIR_ret = ((void) as typeIR)))), then

        1. (Let rid be $rid(name, parameterList))

        2. (Let functionTypeIR be (function( parameterTypeIR* )-> typeIR_ret))

        3. (Let routineTypeDefIR be (((functionTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

        4. If ((RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds)), then

          1. (Let TC_4 be $add_routine_overload(p, TC_0, rid, routineTypeDefIR))

          2. (Let nameIR be $name(name))

          3. (Let functionDeclarationIR be (annotationList (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) blockStatementIR))

          4. Result in TC_4, (functionDeclarationIR as declarationIR)

  (path) actionDeclaration p | TC_0 | ((annotationList action name ( parameterList ) blockStatement) as declaration)

    1. (Let TC_1 be TC_0[local.kind = (action)])

    2. (Let parameter* be $flatten_parameterList(parameterList))

    3. (Parameters_ok: (local) TC_1 |- parameter* : parameterIR* # tid*)

    4. If ((tid* matches pattern [])), then

      1. (Let parameterTypeIR be $parameterIR(parameterIR))*

      2. (Let TC_2 be $add_parameters((local), TC_1, parameterTypeIR*))

      3. (Block_ok: TC_2 (cont) |- blockStatement : _typingContext _flow blockStatementIR)

      4. (Let rid be $rid(name, parameterList))

      5. (Let functionTypeIR be (action( parameterTypeIR* )))

      6. If ((RoutineTypeDef_wf: $bound(p, TC_0) |- (functionTypeIR as routineTypeDefIR) holds)), then

        1. (Let TC_3 be $add_routine_non_overload(p, TC_0, rid, (functionTypeIR as routineTypeDefIR)))

        2. (Let nameIR be $name(name))

        3. (Let actionDeclarationIR be (annotationList action nameIR ( parameterIR* ) blockStatementIR))

        4. Result in TC_3, (actionDeclarationIR as declarationIR)

  (path) errorDeclaration (global) | TC_0 | ((error{ nameList }) as declaration)

    1. (Let name* be $flatten_nameList(nameList))

    2. (Let nameIR be $name(name))*

    3. If ($distinct_<nameIR>(nameIR*)), then

      1. (Let nameIR_error be "error." ++ nameIR)*

      2. (Let value_error be ((error. nameIR) as value))*

      3. (Let TC_1 be $add_vars((global), TC_0, nameIR_error*, (() ((error) as typeIR) (lctk) ?(value_error))*))

      4. Result in TC_1, ((error{ nameIR* }) as declarationIR)

  (path) matchKindDeclaration (global) | TC_0 | ((match_kind{ nameList _trailingCommaOpt }) as declaration)

    1. (Let name* be $flatten_nameList(nameList))

    2. (Let nameIR be $name(name))*

    3. If ($distinct_<nameIR>(nameIR*)), then

      1. (Let value_match_kind be ((match_kind. nameIR) as value))*

      2. (Let TC_1 be $add_vars((global), TC_0, nameIR*, (() ((match_kind) as typeIR) (lctk) ?(value_match_kind))*))

      3. Result in TC_1, ((match_kind{ nameIR* }) as declarationIR)

  (path) externDeclaration-externFunctionDeclaration (global) | TC_0 | ((annotationList extern (typeOrVoid name typeParameterListOpt ( parameterList )) ;) as declaration)

    1. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

    2. (Let tid_expl be $name(typeParameter))*

    3. (Let TC_1 be $add_types((local), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    4. (Type_ok: (local) TC_1 |- typeOrVoid : typeIR_ret # tid*)

    5. If ((tid* matches pattern [])), then

      1. (Let TC_2 be TC_1[local.kind = (extern_function-> typeIR_ret)])

      2. (Let parameter* be $flatten_parameterList(parameterList))

      3. (Parameters_ok: (local) TC_2 |- parameter* : parameterIR* # tid_impl*)

      4. (Let parameterTypeIR be $parameterIR(parameterIR))*

      5. (Let TC_3 be $add_parameters((local), TC_2, parameterTypeIR*))

      6. (Let rid be $rid(name, parameterList))

      7. (Let functionTypeIR be (extern_function( parameterTypeIR* )-> typeIR_ret))

      8. (Let routineTypeDefIR be (((functionTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

      9. If ((RoutineTypeDef_wf: $bound((global), TC_0) |- routineTypeDefIR holds)), then

        1. (Let TC_4 be $add_routine_overload((global), TC_0, rid, routineTypeDefIR))

        2. (Let nameIR be $name(name))

        3. (Let externFunctionDeclarationIR be (annotationList extern (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) ;))

        4. Result in TC_4, (externFunctionDeclarationIR as declarationIR)

  (path) externDeclaration-externObjectDeclaration (global) | TC_0 | ((annotationList extern nonTypeName typeParameterListOpt { methodPrototypeList }) as declaration)

    1. (Let methodPrototype* be $flatten_methodPrototypeList(methodPrototypeList))

    2. (Let (methodPrototype_constructor*, methodPrototype_method*) be $split_constructors(methodPrototype*))

    3. (Let TC_1 be TC_0[block.kind = (extern)])

    4. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

    5. (Let tid_expl be $name(typeParameter))*

    6. (Let TC_2 be $add_types((block), TC_1, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    7. (Let nameIR be $name((nonTypeName as name)))

    8. (ExternMethods_ok: TC_2 nameIR |- methodPrototype_method* : TC_3 methodPrototypeIR_method*)

    9. (Let typeIR_extern be ((extern nameIR TC_3.block.rdenv) as typeIR))

    10. (Let typeDefIR_extern be ((typeIR_extern < tid_expl* , [] >) as typeDefIR))

    11. (Let TC_4 be $add_type((global), TC_0, nameIR, typeDefIR_extern))

    12. (Let TC_5 be TC_4[block.kind = (extern)])

    13. (Let TC_6 be $add_types((block), TC_5, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    14. (ExternConstructors_ok: TC_6 nameIR |- methodPrototype_constructor* : TC_7 methodPrototypeIR_constructor*)

    15. (Let TC_8 be TC_4[global.cdenv = TC_7.global.cdenv])

    16. (Let externObjectDeclarationIR be (annotationList extern nameIR < tid_expl* , [] >{ methodPrototypeIR_constructor* ++ methodPrototypeIR_method* }))

    17. Result in TC_8, (externObjectDeclarationIR as declarationIR)

  (path) parserDeclaration (global) | TC_0 | ((annotationList parser name () ( parameterList ) constructorParameterListOpt { parserLocalDeclarationList parserStateList }) as declaration)

    1. (Let TC_1 be TC_0[block.kind = (parser)])

    2. (Let constructorParameter* be $flatten_constructorParameterListOpt(constructorParameterListOpt))

    3. (ConstructorParameters_ok: (block) TC_1 |- constructorParameter* : constructorParameterIR* # tid*)

    4. If ((tid* matches pattern [])), then

      1. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*

      2. (Let TC_2 be $add_parameters((block), TC_1, constructorParameterTypeIR*))

      3. (Let parameter* be $flatten_parameterList(parameterList))

      4. (Parameters_ok: (block) TC_2 |- parameter* : parameterIR* # tid'*)

      5. If ((tid'* matches pattern [])), then

        1. (Let parameterTypeIR be $parameterIR(parameterIR))*

        2. (Let TC_3 be $add_parameters((block), TC_2, parameterTypeIR*))

        3. (Let parserLocalDeclaration* be $flatten_parserLocalDeclarationList(parserLocalDeclarationList))

        4. (ParserLocalDecls_ok: TC_3 |- parserLocalDeclaration* : TC_4 parserLocalDeclarationIR*)

        5. (Let TC_5 be TC_4[local.kind = (parser_state)])

        6. (Let parserState* be $flatten_parserStateList(parserStateList))

        7. (ParserStates_ok: TC_5 |- parserState* : parserStateIR*)

        8. (Let methodTypeIR be (parser_apply( parameterTypeIR* )))

        9. If ((RoutineTypeDef_wf: $bound((global), TC_0) |- (methodTypeIR as routineTypeDefIR) holds)), then

          1. (Let cid be $cid(name, constructorParameterListOpt))

          2. (Let typeIR_parser be ((parser( parameterTypeIR* )) as typeIR))

          3. (Let typeIR_parser_spec be (((typeIR_parser < [] , [] >) < [] >) as typeIR))

          4. (Let constructorTypeIR be (constructor( constructorParameterTypeIR* )-> typeIR_parser_spec))

          5. (Let constructorTypeDefIR be (constructorTypeIR < [] , [] >))

          6. If ((ConstructorTypeDef_wf: $bound((global), TC_0) |- constructorTypeDefIR holds)), then

            1. (Let TC_6 be $add_constructor(TC_0, cid, constructorTypeDefIR))

            2. (Let nameIR be $name(name))

            3. (Let parserDeclarationIR be (annotationList parser nameIR < [] >( parameterIR* )( constructorParameterIR* ){ parserLocalDeclarationIR* parserStateIR* }))

            4. Result in TC_6, (parserDeclarationIR as declarationIR)

  (path) controlDeclaration (global) | TC_0 | ((annotationList control name () ( parameterList ) constructorParameterListOpt { controlLocalDeclarationList apply controlBody }) as declaration)

    1. (Let TC_1 be TC_0[block.kind = (control)])

    2. (Let constructorParameter* be $flatten_constructorParameterListOpt(constructorParameterListOpt))

    3. (ConstructorParameters_ok: (block) TC_1 |- constructorParameter* : constructorParameterIR* # tid*)

    4. If ((tid* matches pattern [])), then

      1. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*

      2. (Let TC_2 be $add_parameters((block), TC_1, constructorParameterTypeIR*))

      3. (Let parameter* be $flatten_parameterList(parameterList))

      4. (Parameters_ok: (block) TC_2 |- parameter* : parameterIR* # tid'*)

      5. If ((tid'* matches pattern [])), then

        1. (Let parameterTypeIR be $parameterIR(parameterIR))*

        2. (Let TC_3 be $add_parameters((block), TC_2, parameterTypeIR*))

        3. (Let controlLocalDeclaration* be $flatten_controlLocalDeclarationList(controlLocalDeclarationList))

        4. (ControlLocalDecls_ok: TC_3 |- controlLocalDeclaration* : TC_4 controlLocalDeclarationIR*)

        5. (Let TC_5 be TC_4[local.kind = (control_apply_method)])

        6. (Block_ok: TC_5 (cont) |- controlBody : _typingContext _flow controlBodyIR)

        7. (Let methodTypeIR be (control_apply( parameterTypeIR* )))

        8. If ((RoutineTypeDef_wf: $bound((global), TC_0) |- (methodTypeIR as routineTypeDefIR) holds)), then

          1. (Let cid be $cid(name, constructorParameterListOpt))

          2. (Let typeIR_control be ((control( parameterTypeIR* )) as typeIR))

          3. (Let typeIR_control_spec be (((typeIR_control < [] , [] >) < [] >) as typeIR))

          4. (Let constructorTypeIR be (constructor( constructorParameterTypeIR* )-> typeIR_control_spec))

          5. (Let constructorTypeDefIR be (constructorTypeIR < [] , [] >))

          6. If ((ConstructorTypeDef_wf: $bound((global), TC_0) |- constructorTypeDefIR holds)), then

            1. (Let TC_6 be $add_constructor(TC_0, cid, constructorTypeDefIR))

            2. (Let nameIR be $name(name))

            3. (Let controlDeclarationIR be (annotationList control nameIR < [] >( parameterIR* )( constructorParameterIR* ){ controlLocalDeclarationIR* apply controlBodyIR }))

            4. Result in TC_6, (controlDeclarationIR as declarationIR)

  (path) typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration (global) | TC_0 | ((annotationList enum name { nameList_field _trailingCommaOpt }) as declaration)

    1. (Let nameIR be $name(name))

    2. (Let name_field* be $flatten_nameList(nameList_field))

    3. (Let nameIR_field be $name(name_field))*

    4. (Let typeIR_enum be ((enum nameIR { nameIR_field* }) as typeIR))

    5. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_enum as typeDefIR) holds)), then

      1. (Let TC_1 be $add_type((global), TC_0, nameIR, (typeIR_enum as typeDefIR)))

      2. (Let id_field be nameIR ++ "." ++ nameIR_field)*

      3. (Let value_field be ((nameIR . nameIR_field) as value))*

      4. (Let TC_2 be $add_vars((global), TC_1, id_field*, (() typeIR_enum (lctk) ?(value_field))*))

      5. (Let enumTypeDeclarationIR be (annotationList enum nameIR { nameIR_field* }))

      6. Result in TC_2, (enumTypeDeclarationIR as declarationIR)

  (path) typeDeclaration-derivedTypeDeclaration-enumTypeDeclaration-serializable (global) | TC_0 | ((annotationList enum type name { namedExpressionList_field _trailingCommaOpt }) as declaration)

    1. (Type_ok: (global) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

    2. If ((tid* matches pattern [])), then

      1. If ((Type_wf: $bound((global), TC_0) |- typeIR holds)), then

        1. (Let nameIR be $name(name))

        2. (Let namedExpression_field* be $flatten_namedExpressionList(namedExpressionList_field))

        3. (Enum_serializable_fields_ok: TC_0 nameIR typeIR |- namedExpression_field* : TC_1 namedExpressionIR_field* # value_field*)

        4. (Let (nameIR_field = _typedExpressionIR) be namedExpressionIR_field)*

        5. (Let id_field be nameIR ++ "." ++ nameIR_field)*

        6. (Let typeIR_enum be ((enum nameIR # typeIR { (nameIR_field = value_field ;)* }) as typeIR))

        7. (Let TC_2 be $add_vars((global), TC_0, id_field*, (() typeIR_enum (lctk) ?(value_field))*))

        8. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_enum as typeDefIR) holds)), then

          1. (Let TC_3 be $add_type((global), TC_2, nameIR, (typeIR_enum as typeDefIR)))

          2. (Let enumTypeDeclarationIR be (annotationList enum typeIR nameIR { namedExpressionIR_field* }))

          3. Result in TC_3, (enumTypeDeclarationIR as declarationIR)

  (path) typeDeclaration-derivedTypeDeclaration-structTypeDeclaration (global) | TC_0 | ((annotationList struct name typeParameterListOpt { typeFieldList }) as declaration)

    1. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

    2. (Let tid_expl be $name(typeParameter))*

    3. (Let TC_1 be $add_types((block), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    4. (Let (annotationList_field type_field name_field ;)* be $flatten_typeFieldList(typeFieldList))

    5. (Type_ok: (block) TC_1 |- (type_field as typeOrVoid) : typeIR_field # tid_impl_field*)*

    6. (Let tid_impl* be $concat_<tid>(tid_impl_field**))

    7. (Let nameIR be $name(name))

    8. (Let nameIR_field be $name(name_field))*

    9. (Let typeIR_struct be ((struct nameIR { (typeIR_field nameIR_field ;)* }) as typeIR))

    10. (Let typeDefIR_struct be ((typeIR_struct < tid_expl* , tid_impl* >) as typeDefIR))

    11. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_struct holds)), then

      1. (Let TC_2 be $add_type((global), TC_0, nameIR, typeDefIR_struct))

      2. (Let structTypeDeclarationIR be (annotationList struct nameIR < tid_expl* , tid_impl* >{ (annotationList_field typeIR_field nameIR_field ;)* }))

      3. Result in TC_2, (structTypeDeclarationIR as declarationIR)

  (path) typeDeclaration-derivedTypeDeclaration-headerTypeDeclaration (global) | TC_0 | ((annotationList header name typeParameterListOpt { typeFieldList }) as declaration)

    1. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

    2. (Let tid_expl be $name(typeParameter))*

    3. (Let TC_1 be $add_types((block), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    4. (Let (annotationList_f type_f name_f ;)* be $flatten_typeFieldList(typeFieldList))

    5. (Type_ok: (block) TC_1 |- (type_f as typeOrVoid) : typeIR_f # tid_impl_f*)*

    6. (Let tid_impl* be $concat_<tid>(tid_impl_f**))

    7. (Let nameIR be $name(name))

    8. (Let nameIR_f be $name(name_f))*

    9. (Let typeIR_header be ((header nameIR { (typeIR_f nameIR_f ;)* }) as typeIR))

    10. (Let typeDefIR_header be ((typeIR_header < tid_expl* , tid_impl* >) as typeDefIR))

    11. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_header holds)), then

      1. (Let TC_2 be $add_type((global), TC_0, nameIR, typeDefIR_header))

      2. (Let headerTypeDeclarationIR be (annotationList header nameIR < tid_expl* , tid_impl* >{ (annotationList_f typeIR_f nameIR_f ;)* }))

      3. Result in TC_2, (headerTypeDeclarationIR as declarationIR)

  (path) typeDeclaration-derivedTypeDeclaration-headerUnionTypeDeclaration (global) | TC_0 | ((annotationList header_union name typeParameterListOpt { typeFieldList }) as declaration)

    1. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

    2. (Let tid_expl be $name(typeParameter))*

    3. (Let TC_1 be $add_types((block), TC_0, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    4. (Let (annotationList_f type_f name_f ;)* be $flatten_typeFieldList(typeFieldList))

    5. (Type_ok: (block) TC_1 |- (type_f as typeOrVoid) : typeIR_f # tid_impl_f*)*

    6. (Let tid_impl* be $concat_<tid>(tid_impl_f**))

    7. (Let nameIR be $name(name))

    8. (Let nameIR_f be $name(name_f))*

    9. (Let typeIR_union be ((header_union nameIR { (typeIR_f nameIR_f ;)* }) as typeIR))

    10. (Let typeDefIR_union be ((typeIR_union < tid_expl* , tid_impl* >) as typeDefIR))

    11. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_union holds)), then

      1. (Let TC_2 be $add_type((global), TC_0, nameIR, typeDefIR_union))

      2. (Let headerUnionTypeDeclarationIR be (annotationList header_union nameIR < tid_expl* , tid_impl* >{ (annotationList_f typeIR_f nameIR_f ;)* }))

      3. Result in TC_2, (headerUnionTypeDeclarationIR as declarationIR)

  (path) typeDeclaration-typedefDeclaration-typedef (global) | TC_0 | ((annotationList typedef typedefType name ;) as declaration)

    1. (Let typedefType' be typedefType)

    2. If ((typedefType' has type type)), then

      1. (Let type be (typedefType' as type))

      2. (Type_ok: (global) TC_0 |- (type as typeOrVoid) : typeIR # tid'*)

      3. If ((tid'* matches pattern [])), then

        1. If ((Type_wf: $bound((global), TC_0) |- typeIR holds)), then

          1. (Let nameIR be $name(name))

          2. (Let typeIR_typedef be ((typedef nameIR typeIR) as typeIR))

          3. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_typedef as typeDefIR) holds)), then

            1. (Let TC_1 be $add_type((global), TC_0, nameIR, (typeIR_typedef as typeDefIR)))

            2. (Let typedefDeclarationIR be (annotationList typedef (typeIR as typedefTypeIR) nameIR ;))

            3. Result in TC_1, (typedefDeclarationIR as declarationIR)

    3. (Let typedefType' be typedefType)

    4. If ((typedefType' has type derivedTypeDeclaration)), then

      1. (Let derivedTypeDeclaration be (typedefType' as derivedTypeDeclaration))

      2. (Decl_ok: (global) TC_0 |- (derivedTypeDeclaration as declaration) : TC_1 declarationIR)

      3. If ((declarationIR has type derivedTypeDeclarationIR)), then

        1. (Let derivedTypeDeclarationIR be (declarationIR as derivedTypeDeclarationIR))

        2. (Let ({ tid'* }) be $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.global.tdenv), $dom_map<tid, typeDefIR>(TC_0.global.tdenv)))

        3. If ((tid'* matches pattern [ _/1 ])), then

          1. (Let [tid] be tid'*)

          2. (Let typeDefIR'? be $find_type((global), TC_1, (` tid)))

          3. If ((typeDefIR'? matches pattern (_))), then

            1. (Let ?(typeDefIR) be typeDefIR'?)

            2. If ((typeDefIR has type typeIR)), then

              1. (Let typeIR be (typeDefIR as typeIR))

              2. (Let nameIR be $name(name))

              3. (Let typeIR_typedef be ((typedef nameIR typeIR) as typeIR))

              4. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_typedef as typeDefIR) holds)), then

                1. (Let TC_2 be $add_type((global), TC_0, nameIR, (typeIR_typedef as typeDefIR)))

                2. (Let typedefDeclarationIR be (annotationList typedef (derivedTypeDeclarationIR as typedefTypeIR) nameIR ;))

                3. Result in TC_1, (typedefDeclarationIR as declarationIR)

    5. (Let typedefType' be typedefType)

    6. If ((typedefType' has type derivedTypeDeclaration)), then

      1. (Let derivedTypeDeclaration be (typedefType' as derivedTypeDeclaration))

      2. (Decl_ok: (global) TC_0 |- (derivedTypeDeclaration as declaration) : TC_1 declarationIR)

      3. If ((declarationIR has type derivedTypeDeclarationIR)), then

        1. (Let derivedTypeDeclarationIR be (declarationIR as derivedTypeDeclarationIR))

        2. (Let ({ tid'* }) be $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.global.tdenv), $dom_map<tid, typeDefIR>(TC_0.global.tdenv)))

        3. If ((tid'* matches pattern [ _/1 ])), then

          1. (Let [tid] be tid'*)

          2. (Let typeDefIR'? be $find_type((global), TC_1, (` tid)))

          3. If ((typeDefIR'? matches pattern (_))), then

            1. (Let ?(typeDefIR) be typeDefIR'?)

            2. If ((typeDefIR has type polyTypeDefIR)), then

              1. (Let (typeIR < tid''* , tid'''* >) be (typeDefIR as polyTypeDefIR))

              2. If ((tid''* matches pattern [])), then

                1. If ((tid'''* matches pattern [])), then

                  1. (Let nameIR be $name(name))

                  2. (Let typeIR_typedef be ((typedef nameIR (((typeIR < [] , [] >) < [] >) as typeIR)) as typeIR))

                  3. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_typedef as typeDefIR) holds)), then

                    1. (Let TC_2 be $add_type((global), TC_0, nameIR, (typeIR_typedef as typeDefIR)))

                    2. (Let typedefDeclarationIR be (annotationList typedef (derivedTypeDeclarationIR as typedefTypeIR) nameIR ;))

                    3. Result in TC_1, (typedefDeclarationIR as declarationIR)

  (path) typeDeclaration-typedefDeclaration-newtype (global) | TC_0 | ((annotationList type type name ;) as declaration)

    1. (Type_ok: (global) TC_0 |- (type as typeOrVoid) : typeIR # tid*)

    2. If ((tid* matches pattern [])), then

      1. If ((Type_wf: $bound((global), TC_0) |- typeIR holds)), then

        1. (Let nameIR be $name(name))

        2. (Let typeIR_newtype be ((type nameIR typeIR) as typeIR))

        3. If ((TypeDef_wf: $bound((global), TC_0) |- (typeIR_newtype as typeDefIR) holds)), then

          1. (Let TC_1 be $add_type((global), TC_0, nameIR, (typeIR_newtype as typeDefIR)))

          2. (Let typedefDeclarationIR be (annotationList type typeIR nameIR ;))

          3. Result in TC_1, (typedefDeclarationIR as declarationIR)

  (path) typeDeclaration-parserTypeDeclaration (global) | TC_0 | ((annotationList parser name typeParameterListOpt ( parameterList );) as declaration)

    1. (Let TC_1 be TC_0[block.kind = (parser)])

    2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

    3. (Let tid_expl be $name(typeParameter))*

    4. (Let TC_2 be $add_types((block), TC_1, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    5. (Let parameter* be $flatten_parameterList(parameterList))

    6. (Parameters_ok: (block) TC_2 |- parameter* : parameterIR* # tid_impl*)

    7. (Let parameterTypeIR be $parameterIR(parameterIR))*

    8. (Let nameIR be $name(name))

    9. (Let typeIR_parser be ((parser( parameterTypeIR* )) as typeIR))

    10. (Let typeDefIR_parser be ((typeIR_parser < tid_expl* , tid_impl* >) as typeDefIR))

    11. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_parser holds)), then

      1. (Let TC_3 be $add_type((global), TC_0, nameIR, typeDefIR_parser))

      2. (Let parserTypeDeclarationIR be (annotationList parser nameIR < tid_expl* , tid_impl* >( parameterIR* );))

      3. Result in TC_3, (parserTypeDeclarationIR as declarationIR)

  (path) typeDeclaration-controlTypeDeclaration (global) | TC_0 | ((annotationList control name typeParameterListOpt ( parameterList );) as declaration)

    1. (Let TC_1 be TC_0[block.kind = (control)])

    2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

    3. (Let tid_expl be $name(typeParameter))*

    4. (Let TC_2 be $add_types((block), TC_1, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    5. (Let parameter* be $flatten_parameterList(parameterList))

    6. (Parameters_ok: (block) TC_2 |- parameter* : parameterIR* # tid_impl*)

    7. (Let parameterTypeIR be $parameterIR(parameterIR))*

    8. (Let nameIR be $name(name))

    9. (Let typeIR_control be ((control( parameterTypeIR* )) as typeIR))

    10. (Let typeDefIR_control be ((typeIR_control < tid_expl* , tid_impl* >) as typeDefIR))

    11. If ((TypeDef_wf: $bound((global), TC_0) |- typeDefIR_control holds)), then

      1. (Let TC_3 be $add_type((global), TC_0, nameIR, typeDefIR_control))

      2. (Let controlTypeDeclarationIR be (annotationList control nameIR < tid_expl* , tid_impl* >( parameterIR* );))

      3. Result in TC_3, (controlTypeDeclarationIR as declarationIR)

  (path) typeDeclaration-packageTypeDeclaration (global) | TC_0 | ((annotationList package name typeParameterListOpt ( parameterList );) as declaration)

    1. (Let TC_1 be TC_0[block.kind = (package)])

    2. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

    3. (Let tid_expl be $name(typeParameter))*

    4. (Let TC_2 be $add_types((block), TC_1, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    5. (Let constructorParameter* be $flatten_parameterList(parameterList))

    6. (ConstructorParameters_ok: (block) TC_2 |- constructorParameter* : constructorParameterIR* # tid_impl*)

    7. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*

    8. (Let nameIR be $name(name))

    9. (Let (_direction typeIR_package_inner _id _value?) be constructorParameterTypeIR)*

    10. (Let typeIR_package be ((package< typeIR_package_inner* >) as typeIR))

    11. (Let polyTypeDefIR_package be (typeIR_package < tid_expl* , tid_impl* >))

    12. If ((TypeDef_wf: $bound((global), TC_0) |- (polyTypeDefIR_package as typeDefIR) holds)), then

      1. (Let TC_3 be $add_type((global), TC_0, nameIR, (polyTypeDefIR_package as typeDefIR)))

      2. (Let cid be $cid(name, (( parameterList ))))

      3. (Let typeIR_package_spec be ((polyTypeDefIR_package < ((tid tid_expl) as typeIR)* ++ ((tid tid_impl) as typeIR)* >) as typeIR))

      4. (Let constructorTypeIR be (constructor( constructorParameterTypeIR* )-> typeIR_package_spec))

      5. (Let constructorTypeDefIR be (constructorTypeIR < tid_expl* , tid_impl* >))

      6. If ((ConstructorTypeDef_wf: $bound((global), TC_0) |- constructorTypeDefIR holds)), then

        1. (Let TC_4 be $add_constructor(TC_3, cid, constructorTypeDefIR))

        2. (Let packageTypeDeclarationIR be (annotationList package nameIR < tid_expl* , tid_impl* >( constructorParameterIR* );))

        3. Result in TC_4, (packageTypeDeclarationIR as declarationIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:266.1-268.23
relation Decls_ok

  (match) p | TC' | declaration*

    1. (Let TC be TC')

    2. If ((declaration* matches pattern [])), then

      1. Try matching path nil

    3. (Let TC_0 be TC')

    4. If ((declaration* matches pattern _ :: _)), then

      1. (Let declaration_h :: declaration_t* be declaration*)

      2. Try matching path cons

  (path) nil p | TC | []

    1. Result in TC, []

  (path) cons p | TC_0 | declaration_h :: declaration_t*

    1. (Decl_ok: p TC_0 |- declaration_h : TC_1 declarationIR_h)

    2. (Decls_ok: p TC_1 |- declaration_t* : TC_2 declarationIR_t*)

    3. Result in TC_2, declarationIR_h :: declarationIR_t*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:270.1-272.17
relation Program_ok

  (match) p4program

    1. Try matching path 

  (path)  p4program

    1. (Let declaration* be $flatten_p4program(p4program))

    2. (Let TC_0 be $empty_typingContext)

    3. (Decls_ok: (global) TC_0 |- declaration* : TC_1 declarationIR*)

    4. Result in TC_1, (declarationIR* ;)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:282.18-282.35
syntax actctxt = 
   | action
   | noaction

;; ../../../../spec-concrete/5.04-typing-relation.watsup:284.1-287.29
relation Call_convention_expr_ok

  (match) p | TC | actctxt | (direction typeIR_param _id _value?) | typedExpressionIR_arg

    1. If ((direction matches pattern `IN`)), then

      1. Try matching path in

    2. Try matching path out-inout

    3. If ((direction matches pattern ``EMPTY`)), then

      1. Try matching path empty

  (path) in p | TC | actctxt | ((in) typeIR_param _id _value?) | typedExpressionIR_arg

    1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_arg, typeIR_param))

    2. If ((typedExpressionIR? matches pattern (_))), then

      1. (Let ?(typedExpressionIR_arg_cast) be typedExpressionIR?)

      2. Result in typedExpressionIR_arg_cast

  (path) out-inout p | TC | actctxt | (direction typeIR_param _id _value?) | typedExpressionIR_arg

    1. Case analysis on direction

      1. Case (% matches pattern `OUT`)

        1. (Let (_expressionIR # (( typeIR_arg _ctk ))) be typedExpressionIR_arg)

        2. If ((Type_alpha: typeIR_param ~~ typeIR_arg holds)), then

          1. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_arg holds)), then

            1. Result in typedExpressionIR_arg

      2. Case (% matches pattern `INOUT`)

        1. (Let (_expressionIR # (( typeIR_arg _ctk ))) be typedExpressionIR_arg)

        2. If ((Type_alpha: typeIR_param ~~ typeIR_arg holds)), then

          1. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_arg holds)), then

            1. Result in typedExpressionIR_arg

  (path) empty p | TC | actctxt | (() typeIR_param _id _value?) | typedExpressionIR_arg

    1. If (((action) = actctxt)), then

      1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_arg, typeIR_param))

      2. If ((typedExpressionIR? matches pattern (_))), then

        1. (Let ?(typedExpressionIR_arg_cast) be typedExpressionIR?)

        2. Result in typedExpressionIR_arg_cast

    2. If (((noaction) = actctxt)), then

      1. (Let (_expressionIR # (( typeIR_arg ctk_arg ))) be typedExpressionIR_arg)

      2. If ((Type_alpha: typeIR_param ~~ typeIR_arg holds)), then

        1. If (~(ctk_arg matches pattern `DYN`)), then

          1. Result in typedExpressionIR_arg

;; ../../../../spec-concrete/5.04-typing-relation.watsup:289.1-292.29
relation Call_convention_argument_ok

  (match) p | TC | actctxt | parameterTypeIR | argumentIR

    1. If ((argumentIR has type typedExpressionIR)), then

      1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

      2. Try matching path typedExpression

    2. Case analysis on argumentIR

      1. Case (% matches pattern `%=%`)

        1. (Let (nameIR = typedExpressionIR) be argumentIR)

        2. Try matching path nameIR-typedExpression

      2. Case (% matches pattern `%=_`)

        1. (Let (nameIR =_) be argumentIR)

        2. Try matching path nameIR-dontcare

      3. Case (% matches pattern `_`)

        1. Try matching path dontcare

  (path) typedExpression p | TC | actctxt | parameterTypeIR | (typedExpressionIR as argumentIR)

    1. (Call_convention_expr_ok: p TC actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR_cast)

    2. Result in (typedExpressionIR_cast as argumentIR)

  (path) nameIR-typedExpression p | TC | actctxt | parameterTypeIR | (nameIR = typedExpressionIR)

    1. (Call_convention_expr_ok: p TC actctxt |- parameterTypeIR @ typedExpressionIR : typedExpressionIR_cast)

    2. Result in (nameIR = typedExpressionIR_cast)

  (path) nameIR-dontcare p | TC | actctxt | parameterTypeIR | (nameIR =_)

    1. (Let (direction _typeIR _id _value?) be parameterTypeIR)

    2. If ((direction matches pattern `OUT`)), then

      1. Result in (nameIR =_)

  (path) dontcare p | TC | actctxt | parameterTypeIR | (_)

    1. (Let (direction _typeIR _id _value?) be parameterTypeIR)

    2. If ((direction matches pattern `OUT`)), then

      1. Result in (_)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:294.1-297.29
relation Call_convention_ok

  (match) p | TC | actctxt | parameterTypeIR* | argumentIR*

    1. Case analysis on parameterTypeIR*

      1. Case (% matches pattern [])

        1. If ((argumentIR* matches pattern [])), then

          1. Try matching path nil

      2. Case (% matches pattern _ :: _)

        1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

        2. If ((argumentIR* matches pattern _ :: _)), then

          1. (Let argumentIR_h :: argumentIR_t* be argumentIR*)

          2. Try matching path cons

  (path) nil p | TC | actctxt | [] | []

    1. Result in []

  (path) cons p | TC | actctxt | parameterTypeIR_h :: parameterTypeIR_t* | argumentIR_h :: argumentIR_t*

    1. (Call_convention_argument_ok: p TC actctxt |- parameterTypeIR_h @ argumentIR_h : argumentIR_h_cast)

    2. (Call_convention_ok: p TC actctxt |- parameterTypeIR_t* @ argumentIR_t* : argumentIR_t_cast*)

    3. Result in argumentIR_h_cast :: argumentIR_t_cast*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:307.1-307.52
def $is_static_routineTarget(routineTargetIR')

1. (Let routineTargetIR be routineTargetIR')

2. If ((routineTargetIR matches pattern `%.%`)), then

  1. (Let (_typedExpressionIR . nameIR) be routineTargetIR)

  2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

    1. Return (lctk)

3. (Let routineTargetIR be routineTargetIR')

4. If ((routineTargetIR matches pattern `TYPE%.%`)), then

  1. (Let (type _prefixedNameIR . nameIR) be routineTargetIR)

  2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

    1. Return (lctk)

5. (Let _routineTargetIR be routineTargetIR')

6. Otherwise

  1. Return (dyn)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:318.1-320.23
relation RoutineTarget_ok

  (match) p | TC | routineTarget

    1. Case analysis on routineTarget

      1. Case (% has type prefixedNonTypeName)

        1. (Let prefixedNonTypeName be (routineTarget as prefixedNonTypeName))

        2. Try matching path prefixedNonTypeName

      2. Case (% has type memberAccessExpression)

        1. (Let (memberAccessBase . member) be (routineTarget as memberAccessExpression))

        2. Case analysis on memberAccessBase

          1. Case (% has type prefixedTypeName)

            1. (Let prefixedTypeName be (memberAccessBase as prefixedTypeName))

            2. Try matching path memberAccessExpression-prefixedTypeName

          2. Case (% has type expression)

            1. (Let expression_base be (memberAccessBase as expression))

            2. Try matching path memberAccessExpression-expression

      3. Case (% has type parenthesizedExpression)

        1. (Let (( expression )) be (routineTarget as parenthesizedExpression))

        2. Try matching path parenthesizedExpression

    2. If ((routineTarget = ((this) as routineTarget))), then

      1. Try matching path this

  (path) prefixedNonTypeName p | TC | (prefixedNonTypeName as routineTarget)

    1. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

    2. If ((((prefixedNameIR = (` "verify")) \/ (prefixedNameIR = (. "verify"))) => (((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind))))), then

      1. Result in (prefixedNameIR as routineTargetIR)

  (path) this p | TC | ((this) as routineTarget)

    1. Result in ((` "this") as routineTargetIR)

  (path) memberAccessExpression-prefixedTypeName p | TC | (((prefixedTypeName as memberAccessBase) . member) as routineTarget)

    1. (Let prefixedNameIR be $prefixedTypeName(prefixedTypeName))

    2. (Let nameIR be $name(member))

    3. Result in (type prefixedNameIR . nameIR)

  (path) memberAccessExpression-expression p | TC | (((expression_base as memberAccessBase) . member) as routineTarget)

    1. (Let nameIR be $name(member))

    2. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

    3. Result in (typedExpressionIR_base . nameIR)

  (path) parenthesizedExpression p | TC | ((( expression )) as routineTarget)

    1. (RoutineTarget_ok: p TC |- expression : routineTargetIR)

    2. Result in (( routineTargetIR ))

;; ../../../../spec-concrete/5.04-typing-relation.watsup:322.1-324.23
relation RoutineTarget_lvalue_ok

  (match) p | TC | lvalue

    1. Try matching path 

  (path)  p | TC | lvalue

    1. (Let expression be $lvalue(lvalue))

    2. (RoutineTarget_ok: p TC |- expression : routineTargetIR)

    3. Result in routineTargetIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:326.1-329.29
relation RoutineType_ok

  (match) p | TC | routineTargetIR'' | typeArgumentIR* | argumentIR''*

    1. (Let routineTargetIR be routineTargetIR'')

    2. (Let argumentIR be argumentIR'')*

    3. If ((routineTargetIR has type prefixedNameIR)), then

      1. (Let prefixedNameIR be (routineTargetIR as prefixedNameIR))

      2. Try matching path referenceExpressionIR

    4. (Let routineTargetIR be routineTargetIR'')

    5. (Let argumentIR be argumentIR'')*

    6. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

      2. If ((typeArgumentIR* matches pattern [])), then

        1. If ((argumentIR* matches pattern [])), then

          1. Try matching path typedExpressionIR-nameIR-builtin-method-minmax-SizeIn-BitsBytes

    7. (Let routineTargetIR be routineTargetIR'')

    8. (Let argumentIR' be argumentIR'')*

    9. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

      2. If ((typeArgumentIR* matches pattern [])), then

        1. If ((argumentIR'* matches pattern [ _/1 ])), then

          1. (Let [argumentIR] be argumentIR'*)

          2. Try matching path typedExpressionIR-nameIR-builtin-method-stack-push-pop-front

    10. (Let routineTargetIR be routineTargetIR'')

    11. (Let argumentIR be argumentIR'')*

    12. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

      2. If ((typeArgumentIR* matches pattern [])), then

        1. If ((argumentIR* matches pattern [])), then

          1. Try matching path typedExpressionIR-nameIR-builtin-method-header-isValid

    13. (Let routineTargetIR be routineTargetIR'')

    14. (Let argumentIR be argumentIR'')*

    15. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

      2. If ((typeArgumentIR* matches pattern [])), then

        1. If ((argumentIR* matches pattern [])), then

          1. Try matching path typedExpressionIR-nameIR-builtin-method-union-isValid

    16. (Let routineTargetIR be routineTargetIR'')

    17. (Let argumentIR be argumentIR'')*

    18. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

      2. If ((typeArgumentIR* matches pattern [])), then

        1. If ((argumentIR* matches pattern [])), then

          1. Try matching path typedExpressionIR-nameIR-builtin-method-header-set-ValidInvalid

    19. (Let routineTargetIR be routineTargetIR'')

    20. (Let argumentIR be argumentIR'')*

    21. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . nameIR) be routineTargetIR)

      2. Try matching path typedExpressionIR-nameIR-extern-method

    22. (Let routineTargetIR be routineTargetIR'')

    23. (Let argumentIR be argumentIR'')*

    24. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . text) be routineTargetIR)

      2. If ((text = "apply")), then

        1. If ((typeArgumentIR* matches pattern [])), then

          1. Try matching path typedExpressionIR-nameIR-parser-apply-method

    25. (Let routineTargetIR be routineTargetIR'')

    26. (Let argumentIR be argumentIR'')*

    27. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . text) be routineTargetIR)

      2. If ((text = "apply")), then

        1. If ((typeArgumentIR* matches pattern [])), then

          1. Try matching path typedExpressionIR-nameIR-control-apply-method

    28. (Let routineTargetIR be routineTargetIR'')

    29. (Let argumentIR be argumentIR'')*

    30. If ((routineTargetIR matches pattern `%.%`)), then

      1. (Let (typedExpressionIR_base . text) be routineTargetIR)

      2. If ((text = "apply")), then

        1. If ((typeArgumentIR* matches pattern [])), then

          1. If ((argumentIR* matches pattern [])), then

            1. Try matching path typedExpressionIR-nameIR-table-apply-method

    31. (Let routineTargetIR' be routineTargetIR'')

    32. (Let argumentIR be argumentIR'')*

    33. If ((routineTargetIR' matches pattern `(%)`)), then

      1. (Let (( routineTargetIR )) be routineTargetIR')

      2. Try matching path parenthesized

  (path) referenceExpressionIR p | TC | (prefixedNameIR as routineTargetIR) | typeArgumentIR* | argumentIR*

    1. (Let (rid, routineTypeDefIR, id*)? be $find_routine_overloaded(p, TC, prefixedNameIR, argumentIR*))

    2. If (((rid, routineTypeDefIR, id*)? matches pattern (_))), then

      1. (Let ?((rid, routineTypeDefIR, id_default*)) be (rid, routineTypeDefIR, id*)?)

      2. (Let (routineTypeDefIR, tid*) be $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*))

      3. If (((routineTypeDefIR, tid*) has type (functionTypeIR, tid*))), then

        1. (Let (functionTypeIR, tid_impl*) be ((routineTypeDefIR, tid*) as (functionTypeIR, tid*)))

        2. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_impl* })))

        3. If ((RoutineType_wf: bound |- (functionTypeIR as routineTypeIR) holds)), then

          1. Result in (functionTypeIR as routineTypeIR), tid_impl*, id_default*

  (path) typedExpressionIR-nameIR-builtin-method-minmax-SizeIn-BitsBytes p | TC | (typedExpressionIR_base . nameIR) | [] | []

    1. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. (Let methodTypeIR be (builtin_method( [] )-> ((int) as typeIR)))

      2. Result in (methodTypeIR as routineTypeIR), [], []

  (path) typedExpressionIR-nameIR-builtin-method-stack-push-pop-front p | TC | (typedExpressionIR_base . nameIR) | [] | [argumentIR]

    1. If (nameIR is in ["push_front", "pop_front"]), then

      1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

      2. (Let typeIR' be $canon(typeIR_base))

      3. If ((typeIR' has type headerStackTypeIR)), then

        1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

        2. (Let parameterTypeIR be (() ((int) as typeIR) "count" ?()))

        3. (Let methodTypeIR be (builtin_method( [parameterTypeIR] )-> ((int) as typeIR)))

        4. Result in (methodTypeIR as routineTypeIR), [], []

  (path) typedExpressionIR-nameIR-builtin-method-header-isValid p | TC | (typedExpressionIR_base . nameIR) | [] | []

    1. If (nameIR is in ["isValid"]), then

      1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

      2. (Let typeIR be $canon(typeIR_base))

      3. If ((typeIR has type headerTypeIR)), then

        1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

        2. (Let methodTypeIR be (builtin_method( [] )-> ((bool) as typeIR)))

        3. Result in (methodTypeIR as routineTypeIR), [], []

  (path) typedExpressionIR-nameIR-builtin-method-union-isValid p | TC | (typedExpressionIR_base . nameIR) | [] | []

    1. If (nameIR is in ["isValid"]), then

      1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

      2. (Let typeIR be $canon(typeIR_base))

      3. If ((typeIR has type headerUnionTypeIR)), then

        1. (Let (header_union _tid { _fieldTypeIR* }) be (typeIR as headerUnionTypeIR))

        2. (Let methodTypeIR be (builtin_method( [] )-> ((bool) as typeIR)))

        3. Result in (methodTypeIR as routineTypeIR), [], []

  (path) typedExpressionIR-nameIR-builtin-method-header-set-ValidInvalid p | TC | (typedExpressionIR_base . nameIR) | [] | []

    1. If (nameIR is in ["setValid", "setInvalid"]), then

      1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

      2. (Let typeIR be $canon(typeIR_base))

      3. If ((typeIR has type headerTypeIR)), then

        1. (Let (header _tid { _fieldTypeIR* }) be (typeIR as headerTypeIR))

        2. (Let methodTypeIR be (builtin_method( [] )-> ((void) as typeIR)))

        3. Result in (methodTypeIR as routineTypeIR), [], []

  (path) typedExpressionIR-nameIR-extern-method p | TC | (typedExpressionIR_base . nameIR) | typeArgumentIR* | argumentIR*

    1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

    2. (Let typeIR be $canon(typeIR_base))

    3. If ((typeIR has type externObjectTypeIR)), then

      1. (Let (extern _tid ({ (rid_f : routineTypeDefIR_f)* })) be (typeIR as externObjectTypeIR))

      2. (Let id_arg?* be $ids_arguments(argumentIR*))

      3. (Let (rid, routineTypeDefIR, id*)? be $find_overloaded<routineTypeDefIR>(({ (rid_f : routineTypeDefIR_f)* }), nameIR, id_arg?*))

      4. If (((rid, routineTypeDefIR, id*)? matches pattern (_))), then

        1. (Let ?((rid, routineTypeDefIR, id_default*)) be (rid, routineTypeDefIR, id*)?)

        2. (Let (routineTypeDefIR, tid*) be $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*))

        3. If (((routineTypeDefIR, tid*) has type (routineTypeIR, tid*))), then

          1. (Let (routineTypeIR, tid_impl*) be ((routineTypeDefIR, tid*) as (routineTypeIR, tid*)))

          2. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_impl* })))

          3. If ((RoutineType_wf: bound |- routineTypeIR holds)), then

            1. Result in routineTypeIR, tid_impl*, id_default*

  (path) typedExpressionIR-nameIR-parser-apply-method p | TC | (typedExpressionIR_base . "apply") | [] | argumentIR*

    1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

    2. (Let typeIR be $canon(typeIR_base))

    3. If ((typeIR has type parserObjectTypeIR)), then

      1. (Let (parser( parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

      2. (Let methodTypeIR be (parser_apply( parameterTypeIR* )))

      3. (Let (_direction _typeIR id_param value_param?) be parameterTypeIR)*

      4. (Let pid be (id_param # (value_param? =/= ?())))*

      5. (Let rid be ("apply" ( pid* )))

      6. (Let id_arg?* be $ids_arguments(argumentIR*))

      7. (Let (rid, routineTypeDefIR, id*)'? be $find_overloaded<routineTypeDefIR>(({ [(rid : (methodTypeIR as routineTypeDefIR))] }), "apply", id_arg?*))

      8. If (((rid, routineTypeDefIR, id*)'? matches pattern (_))), then

        1. (Let ?((rid, routineTypeDefIR, id*)) be (rid, routineTypeDefIR, id*)'?)

        2. If (((rid, routineTypeDefIR, id*) has type (rid, methodTypeIR, id*))), then

          1. (Let (rid', methodTypeIR', id_default*) be ((rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)))

          2. If ((rid' = rid)), then

            1. If ((methodTypeIR' = methodTypeIR)), then

              1. Result in (methodTypeIR as routineTypeIR), [], id_default*

  (path) typedExpressionIR-nameIR-control-apply-method p | TC | (typedExpressionIR_base . "apply") | [] | argumentIR*

    1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

    2. (Let typeIR be $canon(typeIR_base))

    3. If ((typeIR has type controlObjectTypeIR)), then

      1. (Let (control( parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

      2. (Let methodTypeIR be (control_apply( parameterTypeIR* )))

      3. (Let (_direction _typeIR id_param value_param?) be parameterTypeIR)*

      4. (Let pid be (id_param # (value_param? =/= ?())))*

      5. (Let rid be ("apply" ( pid* )))

      6. (Let id_arg?* be $ids_arguments(argumentIR*))

      7. (Let (rid, routineTypeDefIR, id*)'? be $find_overloaded<routineTypeDefIR>(({ [(rid : (methodTypeIR as routineTypeDefIR))] }), "apply", id_arg?*))

      8. If (((rid, routineTypeDefIR, id*)'? matches pattern (_))), then

        1. (Let ?((rid, routineTypeDefIR, id*)) be (rid, routineTypeDefIR, id*)'?)

        2. If (((rid, routineTypeDefIR, id*) has type (rid, methodTypeIR, id*))), then

          1. (Let (rid', methodTypeIR', id_default*) be ((rid, routineTypeDefIR, id*) as (rid, methodTypeIR, id*)))

          2. If ((rid' = rid)), then

            1. If ((methodTypeIR' = methodTypeIR)), then

              1. Result in (methodTypeIR as routineTypeIR), [], id_default*

  (path) typedExpressionIR-nameIR-table-apply-method p | TC | (typedExpressionIR_base . "apply") | [] | []

    1. (Let (_expressionIR # (( typeIR_base _ctk ))) be typedExpressionIR_base)

    2. (Let typeIR be $canon(typeIR_base))

    3. If ((typeIR has type tableObjectTypeIR)), then

      1. (Let (table _tid # typeIR_table) be (typeIR as tableObjectTypeIR))

      2. (Let methodTypeIR be (table_apply-> typeIR_table))

      3. Result in (methodTypeIR as routineTypeIR), [], []

  (path) parenthesized p | TC | (( routineTargetIR )) | typeArgumentIR* | argumentIR*

    1. (RoutineType_ok: p TC |- routineTargetIR < typeArgumentIR* >( argumentIR* ): routineTypeIR <# tid_inserted* >(# id_default* ))

    2. Result in routineTypeIR, tid_inserted*, id_default*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:336.1-340.35
relation Call_ok

  (match) p | TC | routineTypeIR | typeArgumentIR* | tid'* | argumentIR* | id_default'*

    1. (Let tid be tid')*

    2. (Let id_default be id_default')*

    3. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `BUILTIN_FUNCTION(%)->%`)), then

        1. (Let (builtin_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. If ((tid* matches pattern [])), then

          1. Try matching path builtin-function

    4. (Let tid_infer be tid')*

    5. (Let id_default be id_default')*

    6. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `FUNCTION(%)->%`)), then

        1. (Let (function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. Try matching path function

    7. (Let tid_infer be tid')*

    8. (Let id_default be id_default')*

    9. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `EXTERN_FUNCTION(%)->%`)), then

        1. (Let (extern_function( parameterTypeIR* )-> typeIR_ret) be functionTypeIR)

        2. Try matching path externfunction

    10. (Let tid be tid')*

    11. (Let id_default be id_default')*

    12. If ((routineTypeIR has type functionTypeIR)), then

      1. (Let functionTypeIR be (routineTypeIR as functionTypeIR))

      2. If ((functionTypeIR matches pattern `ACTION(%)`)), then

        1. (Let (action( parameterTypeIR* )) be functionTypeIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((tid* matches pattern [])), then

            1. Try matching path action

    13. (Let tid be tid')*

    14. (Let id_default be id_default')*

    15. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `BUILTIN_METHOD(%)->%`)), then

        1. (Let (builtin_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. If ((tid* matches pattern [])), then

          1. Try matching path builtin-method

    16. (Let tid_infer be tid')*

    17. (Let id_default be id_default')*

    18. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `EXTERN_METHOD(%)->%`)), then

        1. (Let (extern_method( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. Try matching path extern-method

    19. (Let tid_infer be tid')*

    20. (Let id_default be id_default')*

    21. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

        1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

        2. Try matching path extern-abstract-method

    22. (Let tid be tid')*

    23. (Let id_default be id_default')*

    24. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `PARSER_APPLY(%)`)), then

        1. (Let (parser_apply( parameterTypeIR* )) be methodTypeIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((tid* matches pattern [])), then

            1. Try matching path parser-apply-method

    25. (Let tid be tid')*

    26. (Let id_default be id_default')*

    27. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `CONTROL_APPLY(%)`)), then

        1. (Let (control_apply( parameterTypeIR* )) be methodTypeIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((tid* matches pattern [])), then

            1. Try matching path control-apply-method

    28. (Let tid be tid')*

    29. (Let id be id_default')*

    30. If ((routineTypeIR has type methodTypeIR)), then

      1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

      2. If ((methodTypeIR matches pattern `TABLE_APPLY->%`)), then

        1. (Let (table_apply-> typeIR_table) be methodTypeIR)

        2. If ((typeArgumentIR* matches pattern [])), then

          1. If ((tid* matches pattern [])), then

            1. If ((argumentIR* matches pattern [])), then

              1. If ((id* matches pattern [])), then

                1. Try matching path table-apply-method

  (path) builtin-function p | TC | ((builtin_function( parameterTypeIR* )-> typeIR_ret) as routineTypeIR) | typeArgumentIR* | [] | argumentIR* | id_default*

    1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

    2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

      1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

      2. If ($callable_builtin_function(p, TC)), then

        1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

        2. Result in typeIR_ret, typeArgumentIR*, argumentIR_cast*

  (path) function p | TC | ((function( parameterTypeIR* )-> typeIR_ret) as routineTypeIR) | typeArgumentIR* | tid_infer* | argumentIR* | id_default*

    1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

    2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

      1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

      2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

      3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid_infer))*

      4. If ((typeIR? matches pattern (_)))*, then

        1. (Let ?(typeIR_inferred) be typeIR?)*

        2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

        3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

        4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

        5. (Let functionTypeIR_inferred be (function( parameterTypeIR_aligned_inferred* )-> typeIR_ret_inferred))

        6. If ((RoutineType_wf: $bound(p, TC) |- (functionTypeIR_inferred as routineTypeIR) holds)), then

          1. If ($callable_function(p, TC)), then

            1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

            2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*, argumentIR_cast*

  (path) externfunction p | TC | ((extern_function( parameterTypeIR* )-> typeIR_ret) as routineTypeIR) | typeArgumentIR* | tid_infer* | argumentIR* | id_default*

    1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

    2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

      1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

      2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

      3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid_infer))*

      4. If ((typeIR? matches pattern (_)))*, then

        1. (Let ?(typeIR_inferred) be typeIR?)*

        2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

        3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

        4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

        5. (Let functionTypeIR_inferred be (extern_function( parameterTypeIR_aligned_inferred* )-> typeIR_ret_inferred))

        6. If ((RoutineType_wf: $bound(p, TC) |- (functionTypeIR_inferred as routineTypeIR) holds)), then

          1. If ($callable_extern_function(p, TC)), then

            1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

            2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*, argumentIR_cast*

  (path) action p | TC | ((action( parameterTypeIR* )) as routineTypeIR) | [] | [] | argumentIR* | id_default*

    1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

    2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

      1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

      2. If ($callable_action(p, TC)), then

        1. (Call_convention_ok: p TC (action) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

        2. Result in ((void) as typeIR), [], argumentIR_cast*

  (path) builtin-method p | TC | ((builtin_method( parameterTypeIR* )-> typeIR_ret) as routineTypeIR) | typeArgumentIR* | [] | argumentIR* | id_default*

    1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

    2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

      1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

      2. If ($callable_builtin_method(p, TC)), then

        1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

        2. Result in typeIR_ret, typeArgumentIR*, argumentIR_cast*

  (path) extern-method p | TC | ((extern_method( parameterTypeIR* )-> typeIR_ret) as routineTypeIR) | typeArgumentIR* | tid_infer* | argumentIR* | id_default*

    1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

    2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

      1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

      2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

      3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid_infer))*

      4. If ((typeIR? matches pattern (_)))*, then

        1. (Let ?(typeIR_inferred) be typeIR?)*

        2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

        3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

        4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

        5. (Let methodTypeIR_inferred be (extern_method( parameterTypeIR_aligned_inferred* )-> typeIR_ret_inferred))

        6. If ((RoutineType_wf: $bound(p, TC) |- (methodTypeIR_inferred as routineTypeIR) holds)), then

          1. If ($callable_extern_method(p, TC)), then

            1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

            2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*, argumentIR_cast*

  (path) extern-abstract-method p | TC | ((extern_methodabstract( parameterTypeIR* )-> typeIR_ret) as routineTypeIR) | typeArgumentIR* | tid_infer* | argumentIR* | id_default*

    1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

    2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

      1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

      2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

      3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid_infer))*

      4. If ((typeIR? matches pattern (_)))*, then

        1. (Let ?(typeIR_inferred) be typeIR?)*

        2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

        3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

        4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

        5. (Let methodTypeIR_inferred be (extern_methodabstract( parameterTypeIR_aligned_inferred* )-> typeIR_ret_inferred))

        6. If ((RoutineType_wf: $bound(p, TC) |- (methodTypeIR_inferred as routineTypeIR) holds)), then

          1. If ($callable_extern_abstract_method(p, TC)), then

            1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

            2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*, argumentIR_cast*

  (path) parser-apply-method p | TC | ((parser_apply( parameterTypeIR* )) as routineTypeIR) | [] | [] | argumentIR* | id_default*

    1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

    2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

      1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

      2. If ($callable_parser_apply_method(p, TC)), then

        1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

        2. Result in ((void) as typeIR), [], argumentIR_cast*

  (path) control-apply-method p | TC | ((control_apply( parameterTypeIR* )) as routineTypeIR) | [] | [] | argumentIR* | id_default*

    1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

    2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

      1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

      2. If ($callable_control_apply_method(p, TC)), then

        1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned* @ argumentIR* : argumentIR_cast*)

        2. Result in ((void) as typeIR), [], argumentIR_cast*

  (path) table-apply-method p | TC | ((table_apply-> typeIR_table) as routineTypeIR) | [] | [] | [] | []

    1. If ($callable_table_apply_method(p, TC)), then

      1. Result in typeIR_table, [], []

;; ../../../../spec-concrete/5.04-typing-relation.watsup:350.1-353.29
relation ConstructorType_ok

  (match) p | TC | prefixedNameIR | typeArgumentIR* | argumentIR*

    1. Try matching path 

  (path)  p | TC | prefixedNameIR | typeArgumentIR* | argumentIR*

    1. (Let (rid, constructorTypeDefIR, id*)? be $find_constructor_overloaded(TC, prefixedNameIR, argumentIR*))

    2. If (((rid, constructorTypeDefIR, id*)? matches pattern (_))), then

      1. (Let ?((cid, constructorTypeDefIR, id_default*)) be (rid, constructorTypeDefIR, id*)?)

      2. (Let (constructorTypeIR, tid_impl*) be $specialize_constructorTypeDef(constructorTypeDefIR, typeArgumentIR*))

      3. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_impl* })))

      4. If ((ConstructorType_wf: bound |- constructorTypeIR holds)), then

        1. Result in constructorTypeIR, tid_impl*, id_default*

;; ../../../../spec-concrete/5.04-typing-relation.watsup:360.19-360.31
syntax instctxt = 
   | named
   | anon

;; ../../../../spec-concrete/5.04-typing-relation.watsup:362.1-369.38
relation Inst_ok

  (match) cursor' | TC | instctxt | constructorTypeIR | typeArgumentIR* | tid_infer* | argumentIR* | id_default*

    1. (Let cursor be cursor')

    2. If ((cursor matches pattern `GLOBAL`)), then

      1. Try matching path package

    3. (Let p be cursor')

    4. Try matching path non-package

  (path) package (global) | TC | instctxt | constructorTypeIR | typeArgumentIR* | tid_infer* | argumentIR* | id_default*

    1. (Let (constructor( parameterTypeIR* )-> typeIR_object) be constructorTypeIR)

    2. (Let typeIR be $canon(typeIR_object))

    3. If ((typeIR has type packageObjectTypeIR)), then

      1. (Let (package< _typeIR* >) be (typeIR as packageObjectTypeIR))

      2. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

      3. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

        1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

        2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

        3. (Let typeIR'? be $find_map<tid, typeIR>(inference, tid_infer))*

        4. If ((typeIR'? matches pattern (_)))*, then

          1. (Let ?(typeIR_inferred) be typeIR'?)*

          2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

          3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

          4. (Let typeIR_object_inferred be $subst_type(inference, typeIR_object))

          5. (Let constructorTypeIR_inferred be (constructor( parameterTypeIR_aligned_inferred* )-> typeIR_object_inferred))

          6. If ((ConstructorType_wf: $bound((global), TC) |- constructorTypeIR_inferred holds)), then

            1. If ($instantiable((global), TC, instctxt, typeIR_object_inferred)), then

              1. (Call_convention_ok: (block) TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

              2. Result in typeIR_object_inferred, typeArgumentIR_inferred*, argumentIR_cast*

  (path) non-package p | TC | instctxt | constructorTypeIR | typeArgumentIR* | tid_infer* | argumentIR* | id_default*

    1. (Let (constructor( parameterTypeIR* )-> typeIR_object) be constructorTypeIR)

    2. If (~$is_package_object_typeIR($canon(typeIR_object))), then

      1. (Let parameterTypeIR_non_default* be $filter_default_parameters(parameterTypeIR*, id_default*))

      2. If ((|parameterTypeIR_non_default*| = |argumentIR*|)), then

        1. (Let parameterTypeIR_aligned* be $align_parameters(parameterTypeIR_non_default*, argumentIR*))

        2. (Let inference be $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*))

        3. (Let typeIR? be $find_map<tid, typeIR>(inference, tid_infer))*

        4. If ((typeIR? matches pattern (_)))*, then

          1. (Let ?(typeIR_inferred) be typeIR?)*

          2. (Let typeArgumentIR_inferred* be typeArgumentIR* ++ typeIR_inferred*)

          3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*

          4. (Let typeIR_object_inferred be $subst_type(inference, typeIR_object))

          5. (Let constructorTypeIR_inferred be (constructor( parameterTypeIR_aligned_inferred* )-> typeIR_object_inferred))

          6. If ((ConstructorType_wf: $bound(p, TC) |- constructorTypeIR_inferred holds)), then

            1. If ($instantiable(p, TC, instctxt, typeIR_object_inferred)), then

              1. (Call_convention_ok: p TC (noaction) |- parameterTypeIR_aligned_inferred* @ argumentIR* : argumentIR_cast*)

              2. Result in typeIR_object_inferred, typeArgumentIR_inferred*, argumentIR_cast*

;; ../../../../spec-concrete/5.05.2-subtype.watsup:412.1-416.23
def $reduce_serenum_unary(typedExpressionIR, $check)

1. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

2. If ($check(typeIR)), then

  1. Return ?(typedExpressionIR)

3. (Let (_expressionIR # (( typeIR ctk ))) be typedExpressionIR)

4. If (~$check(typeIR)), then

  1. (Let typeIR' be typeIR)

  2. If ((typeIR' has type enumTypeIR)), then

    1. (Let enumTypeIR be (typeIR' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # typeIR_underlying { _valueFieldIR* }) be enumTypeIR)

      2. (Let typedExpressionIR_cast be (((( typeIR_underlying ) typedExpressionIR) as expressionIR) # (( typeIR_underlying ctk ))))

      3. Return $reduce_serenum_unary(typedExpressionIR_cast, $check)

5. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.05.2-subtype.watsup:437.1-442.44
def $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $check)

1. (Let (_expressionIR # (( typeIR_l _ctk ))) be typedExpressionIR_l)

2. (Let (_expressionIR' # (( typeIR_r _ctk' ))) be typedExpressionIR_r)

3. If ($check(typeIR_l, typeIR_r)), then

  1. Return ?((typedExpressionIR_l, typedExpressionIR_r))

4. (Let (_expressionIR # (( typeIR_l ctk_l ))) be typedExpressionIR_l)

5. (Let (_expressionIR' # (( typeIR_r _ctk ))) be typedExpressionIR_r)

6. If (~$check(typeIR_l, typeIR_r)), then

  1. (Let typeIR be typeIR_l)

  2. If ((typeIR has type enumTypeIR)), then

    1. (Let enumTypeIR be (typeIR as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # typeIR_l_underlying { _valueFieldIR* }) be enumTypeIR)

      2. (Let typedExpressionIR_l_cast be (((( typeIR_l_underlying ) typedExpressionIR_l) as expressionIR) # (( typeIR_l_underlying ctk_l ))))

      3. Return $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r, $check)

7. (Let (_expressionIR # (( typeIR_l _ctk ))) be typedExpressionIR_l)

8. (Let (_expressionIR' # (( typeIR_r ctk_r ))) be typedExpressionIR_r)

9. If (~$check(typeIR_l, typeIR_r)), then

  1. (Let typeIR be typeIR_r)

  2. If ((typeIR has type enumTypeIR)), then

    1. (Let enumTypeIR be (typeIR as enumTypeIR))

    2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

      1. (Let (enum _tid # typeIR_r_underlying { _valueFieldIR* }) be enumTypeIR)

      2. (Let typedExpressionIR_r_cast be (((( typeIR_r_underlying ) typedExpressionIR_r) as expressionIR) # (( typeIR_r_underlying ctk_r ))))

      3. Return $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r_cast, $check)

10. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.05.2-subtype.watsup:482.1-482.66
def $coerce_unary(typedExpressionIR, typeIR_to)

1. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

2. If ((Type_alpha: typeIR ~~ typeIR_to holds)), then

  1. Return ?(typedExpressionIR)

3. (Let (_expressionIR # (( typeIR ctk ))) be typedExpressionIR)

4. If (~(Type_alpha: typeIR ~~ typeIR_to holds)), then

  1. If ((Sub_impl: typeIR <: typeIR_to holds)), then

    1. (Let typedExpressionIR_cast be (((( typeIR_to ) typedExpressionIR) as expressionIR) # (( typeIR_to ctk ))))

    2. Return ?(typedExpressionIR_cast)

;; ../../../../spec-concrete/5.05.2-subtype.watsup:497.1-498.44
def $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)

1. (Let (_expressionIR # (( typeIR_l _ctk ))) be typedExpressionIR_l)

2. (Let (_expressionIR' # (( typeIR_r _ctk' ))) be typedExpressionIR_r)

3. If ((Type_alpha: typeIR_l ~~ typeIR_r holds)), then

  1. Return ?((typedExpressionIR_l, typedExpressionIR_r))

4. (Let (_expressionIR # (( typeIR_l ctk_l ))) be typedExpressionIR_l)

5. (Let (_expressionIR' # (( typeIR_r _ctk ))) be typedExpressionIR_r)

6. If (~(Type_alpha: typeIR_l ~~ typeIR_r holds)), then

  1. If ((Sub_impl: typeIR_l <: typeIR_r holds)), then

    1. (Let typedExpressionIR_l_cast be (((( typeIR_r ) typedExpressionIR_l) as expressionIR) # (( typeIR_r ctk_l ))))

    2. Return ?((typedExpressionIR_l_cast, typedExpressionIR_r))

7. (Let (_expressionIR # (( typeIR_l _ctk ))) be typedExpressionIR_l)

8. (Let (_expressionIR' # (( typeIR_r ctk_r ))) be typedExpressionIR_r)

9. If (~(Type_alpha: typeIR_l ~~ typeIR_r holds)), then

  1. If (~(Sub_impl: typeIR_l <: typeIR_r holds)), then

    1. If ((Sub_impl: typeIR_r <: typeIR_l holds)), then

      1. (Let typedExpressionIR_r_cast be (((( typeIR_l ) typedExpressionIR_r) as expressionIR) # (( typeIR_l ctk_r ))))

      2. Return ?((typedExpressionIR_l, typedExpressionIR_r_cast))

10. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:80.1-80.32
def $compat_lnot(typeIR)

1. Return $compat'_lnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:81.1-81.33
def $compat'_lnot(typeIR)

1. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:101.1-101.32
def $compat_bnot(typeIR)

1. Return $compat'_bnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:102.1-102.33
def $compat'_bnot(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:123.1-123.38
def $compat_uplusminus(typeIR)

1. Return $compat'_uplusminus($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:124.1-124.39
def $compat'_uplusminus(typeIR)

1. If ((typeIR = ((int) as typeIR))), then

  1. Return true

2. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:149.1-149.49
def $compat_plusminusmult(typeIR_l, typeIR_r)

1. Return $compat'_plusminusmult($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:150.1-150.50
def $compat'_plusminusmult(typeIR'', typeIR''')

1. (Let typeIR be typeIR'')

2. (Let typeIR' be typeIR''')

3. If ((typeIR = ((int) as typeIR))), then

  1. If ((typeIR' = ((int) as typeIR))), then

    1. Return true

4. (Let typeIR be typeIR'')

5. (Let typeIR' be typeIR''')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< w' >) be numberTypeIR')

        2. If ((w = w')), then

          1. Return true

7. (Let typeIR be typeIR'')

8. (Let typeIR' be typeIR''')

9. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< w' >) be numberTypeIR')

        2. If ((w = w')), then

          1. Return true

10. (Let typeIR_l be typeIR'')

11. (Let typeIR_r be typeIR''')

12. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:186.1-186.48
def $compat_satplusminus(typeIR_l, typeIR_r)

1. Return $compat'_satplusminus($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:187.1-187.49
def $compat'_satplusminus(typeIR'', typeIR''')

1. (Let typeIR be typeIR'')

2. (Let typeIR' be typeIR''')

3. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< w' >) be numberTypeIR')

        2. If ((w = w')), then

          1. Return true

4. (Let typeIR be typeIR'')

5. (Let typeIR' be typeIR''')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< w' >) be numberTypeIR')

        2. If ((w = w')), then

          1. Return true

7. (Let typeIR_l be typeIR'')

8. (Let typeIR_r be typeIR''')

9. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:222.1-222.42
def $compat_divmod(typeIR_l, typeIR_r)

1. Return $compat'_divmod($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:223.1-223.43
def $compat'_divmod(typeIR'', typeIR''')

1. (Let typeIR be typeIR'')

2. (Let typeIR' be typeIR''')

3. If ((typeIR = ((int) as typeIR))), then

  1. If ((typeIR' = ((int) as typeIR))), then

    1. Return true

4. (Let typeIR_l be typeIR'')

5. (Let typeIR_r be typeIR''')

6. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:293.1-293.41
def $compat_shift(typeIR_l, typeIR_r)

1. Return $compat'_shift($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:294.1-294.42
def $compat'_shift(typeIR'', typeIR''')

1. (Let typeIR be typeIR'')

2. (Let typeIR' be typeIR''')

3. If ((typeIR = ((int) as typeIR))), then

  1. If ((typeIR' = ((int) as typeIR))), then

    1. Return true

4. (Let typeIR be typeIR'')

5. (Let typeIR' be typeIR''')

6. If ((typeIR = ((int) as typeIR))), then

  1. If ((typeIR' has type numberTypeIR)), then

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `INT<%>`)), then

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

7. (Let typeIR be typeIR'')

8. (Let typeIR' be typeIR''')

9. If ((typeIR = ((int) as typeIR))), then

  1. If ((typeIR' has type numberTypeIR)), then

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `BIT<%>`)), then

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

10. (Let typeIR be typeIR'')

11. (Let typeIR' be typeIR''')

12. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. If ((typeIR' = ((int) as typeIR))), then

      1. Return true

13. (Let typeIR be typeIR'')

14. (Let typeIR' be typeIR''')

15. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< _nat' >) be numberTypeIR')

        2. Return true

16. (Let typeIR be typeIR'')

17. (Let typeIR' be typeIR''')

18. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< _nat' >) be numberTypeIR')

        2. Return true

19. (Let typeIR be typeIR'')

20. (Let typeIR' be typeIR''')

21. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. If ((typeIR' = ((int) as typeIR))), then

      1. Return true

22. (Let typeIR be typeIR'')

23. (Let typeIR' be typeIR''')

24. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< _nat' >) be numberTypeIR')

        2. Return true

25. (Let typeIR be typeIR'')

26. (Let typeIR' be typeIR''')

27. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< _nat' >) be numberTypeIR')

        2. Return true

28. (Let typeIR_l be typeIR'')

29. (Let typeIR_r be typeIR''')

30. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:388.1-388.43
def $compat_compare(typeIR_l, typeIR_r)

1. Return $compat'_compare($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:389.1-389.44
def $compat'_compare(typeIR'', typeIR''')

1. (Let typeIR be typeIR'')

2. (Let typeIR' be typeIR''')

3. If ((typeIR = ((int) as typeIR))), then

  1. If ((typeIR' = ((int) as typeIR))), then

    1. Return true

4. (Let typeIR be typeIR'')

5. (Let typeIR' be typeIR''')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< w' >) be numberTypeIR')

        2. If ((w = w')), then

          1. Return true

7. (Let typeIR be typeIR'')

8. (Let typeIR' be typeIR''')

9. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< w' >) be numberTypeIR')

        2. If ((w = w')), then

          1. Return true

10. (Let typeIR_l be typeIR'')

11. (Let typeIR_r be typeIR''')

12. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:425.1-425.43
def $compat_bitwise(typeIR_l, typeIR_r)

1. Return $compat'_bitwise($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:426.1-426.44
def $compat'_bitwise(typeIR'', typeIR''')

1. (Let typeIR be typeIR'')

2. (Let typeIR' be typeIR''')

3. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< w' >) be numberTypeIR')

        2. If ((w = w')), then

          1. Return true

4. (Let typeIR be typeIR'')

5. (Let typeIR' be typeIR''')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< w' >) be numberTypeIR')

        2. If ((w = w')), then

          1. Return true

7. (Let typeIR_l be typeIR'')

8. (Let typeIR_r be typeIR''')

9. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:461.1-461.42
def $compat_concat(typeIR_l, typeIR_r)

1. Return $compat'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:462.1-462.43
def $compat'_concat(typeIR'', typeIR''')

1. (Let typeIR be typeIR'')

2. (Let typeIR' be typeIR''')

3. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< _nat' >) be numberTypeIR')

        2. Return true

4. (Let typeIR be typeIR'')

5. (Let typeIR' be typeIR''')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< _nat' >) be numberTypeIR')

        2. Return true

7. (Let typeIR be typeIR'')

8. (Let typeIR' be typeIR''')

9. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< _nat' >) be numberTypeIR')

        2. Return true

10. (Let typeIR be typeIR'')

11. (Let typeIR' be typeIR''')

12. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< _nat' >) be numberTypeIR')

        2. Return true

13. (Let typeIR_l be typeIR'')

14. (Let typeIR_r be typeIR''')

15. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:473.1-473.45
def $result_concat(typeIR_l, typeIR_r)

1. Return $result'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:474.1-474.46
def $result'_concat(typeIR'', typeIR''')

1. (Let typeIR be typeIR'')

2. (Let typeIR' be typeIR''')

3. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w_a >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< w_b >) be numberTypeIR')

        2. Return ?(((int< (w_a + w_b) >) as typeIR))

4. (Let typeIR be typeIR'')

5. (Let typeIR' be typeIR''')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w_a >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< w_b >) be numberTypeIR')

        2. Return ?(((int< (w_a + w_b) >) as typeIR))

7. (Let typeIR be typeIR'')

8. (Let typeIR' be typeIR''')

9. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w_a >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< w_b >) be numberTypeIR')

        2. Return ?(((bit< (w_a + w_b) >) as typeIR))

10. (Let typeIR be typeIR'')

11. (Let typeIR' be typeIR''')

12. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w_a >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< w_b >) be numberTypeIR')

        2. Return ?(((bit< (w_a + w_b) >) as typeIR))

13. (Let typeIR_l be typeIR'')

14. (Let typeIR_r be typeIR''')

15. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:511.1-511.43
def $compat_logical(typeIR_l, typeIR_r)

1. Return $compat'_logical($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:512.1-512.44
def $compat'_logical(typeIR'', typeIR''')

1. (Let typeIR be typeIR'')

2. (Let typeIR' be typeIR''')

3. If ((typeIR = ((bool) as typeIR))), then

  1. If ((typeIR' = ((bool) as typeIR))), then

    1. Return true

4. (Let typeIR_l be typeIR'')

5. (Let typeIR_r be typeIR''')

6. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:905.1-905.39
def $compat_array_index(typeIR)

1. Return $compat'_arrayindex($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:906.1-906.39
def $compat'_arrayindex(typeIR)

1. If ((typeIR = ((int) as typeIR))), then

  1. Return true

2. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1000.1-1000.41
def $compat_bitslice_base(typeIR)

1. Return $compat'_bitslice_base($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1001.1-1001.42
def $compat'_bitslice_base(typeIR)

1. If ((typeIR = ((int) as typeIR))), then

  1. Return true

2. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< w >) be numberTypeIR)

      2. Return (w > 0)

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1011.1-1011.42
def $compat_bitslice_index(typeIR)

1. Return $compat'_bitslice_index($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1012.1-1012.43
def $compat'_bitslice_index(typeIR)

1. If ((typeIR = ((int) as typeIR))), then

  1. Return true

2. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `INT<%>`)

      1. (Let (int< _nat >) be numberTypeIR)

      2. Return true

    2. Case (% matches pattern `BIT<%>`)

      1. (Let (bit< _nat >) be numberTypeIR)

      2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1022.1-1022.48
def $is_valid_bitslice(typeIR, n_lo, n_hi)

1. Return ((n_lo <= n_hi) /\ $is_valid_bitslice'($canon(typeIR), n_lo, n_hi))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1023.1-1023.49
def $is_valid_bitslice'(typeIR', _nat'', _nat''')

1. (Let typeIR be typeIR')

2. (Let _nat be _nat'')

3. (Let _nat' be _nat''')

4. If ((typeIR = ((int) as typeIR))), then

  1. Return true

5. (Let typeIR be typeIR')

6. (Let n_lo be _nat'')

7. (Let n_hi be _nat''')

8. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w >) be numberTypeIR)

    2. (Let w_slice be ((n_hi - n_lo) + 1))

    3. Return ((n_hi <= w) /\ (w_slice <= w))

9. (Let typeIR be typeIR')

10. (Let n_lo be _nat'')

11. (Let n_hi be _nat''')

12. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. (Let w_slice be ((n_hi - n_lo) + 1))

    3. Return ((n_hi <= w) /\ (w_slice <= w))

13. (Let _typeIR be typeIR')

14. (Let _nat be _nat'')

15. (Let _nat' be _nat''')

16. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1154.1-1154.46
def $is_concrete_extern_object(typeIR)

1. Return $is_concrete_extern_object'($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1155.1-1155.47
def $is_concrete_extern_object'(typeIR)

1. If (~$is_extern_object_typeIR(typeIR)), then

  1. Return true

2. If ((typeIR has type externObjectTypeIR)), then

  1. (Let (extern _tid ({ (_rid : routineTypeDefIR)* })) be (typeIR as externObjectTypeIR))

  2. If ($is_concrete_extern_object''(routineTypeDefIR))*, then

    1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1156.1-1156.58
def $is_concrete_extern_object''(routineTypeDefIR)

1. Case analysis on routineTypeDefIR

  1. Case (% has type routineTypeIR)

    1. (Let routineTypeIR be (routineTypeDefIR as routineTypeIR))

    2. Return $is_concrete_extern_object'''(routineTypeIR)

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (routineTypeIR < _tid* , _tid'* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. Return (true = $is_concrete_extern_object'''(routineTypeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1157.1-1157.56
def $is_concrete_extern_object'''(routineTypeIR')

1. (Let routineTypeIR be routineTypeIR')

2. If ((routineTypeIR has type methodTypeIR)), then

  1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

  2. If ((methodTypeIR matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

    1. (Let (extern_methodabstract( _parameterTypeIR* )-> _typeIR) be methodTypeIR)

    2. Return false

3. (Let _routineTypeIR be routineTypeIR')

4. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.10-typing-statement.watsup:91.1-91.46
def $compat_direct_application(typeIR)

1. Return $compat'_direct_application($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:92.1-92.47
def $compat'_direct_application(typeIR)

1. Case analysis on typeIR

  1. Case (% has type parserObjectTypeIR)

    1. (Let (parser( _parameterTypeIR* )) be (typeIR as parserObjectTypeIR))

    2. Return true

  2. Case (% has type controlObjectTypeIR)

    1. (Let (control( _parameterTypeIR* )) be (typeIR as controlObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.10-typing-statement.watsup:213.1-215.26
relation SwitchLabel_table_ok

  (match) TC | tid_table | bool' | switchLabel

    1. (Let bool be bool')

    2. If ((bool = true)), then

      1. If ((switchLabel matches pattern `DEFAULT`)), then

        1. Try matching path default

    3. (Let _bool be bool')

    4. If ((switchLabel has type prefixedNonTypeName)), then

      1. (Let prefixedNonTypeName be (switchLabel as prefixedNonTypeName))

      2. Try matching path expressionNonBrace-prefixedNonTypeName

  (path) default TC | tid_table | true | (default)

    1. Result in (default)

  (path) expressionNonBrace-prefixedNonTypeName TC | tid_table | _bool | (prefixedNonTypeName as switchLabel)

    1. (Let prefixedNameIR be $prefixedNonTypeName(prefixedNonTypeName))

    2. If ((prefixedNameIR matches pattern ``%`)), then

      1. (Let (` nameIR_label) be prefixedNameIR)

      2. (Let tid_table_enum be "action_list(" ++ tid_table ++ ")")

      3. (Let id_label be tid_table_enum ++ "." ++ nameIR_label)

      4. (Let varTypeIR? be $find_var((local), TC, (` id_label)))

      5. If ((varTypeIR? matches pattern (_))), then

        1. (Let ?((_direction typeIR_label ctk_label value?)) be varTypeIR?)

        2. If ((value? matches pattern (_))), then

          1. (Let ?(value_label) be value?)

          2. If ((value_label = ((table_enum tid_table_enum . nameIR_label) as value))), then

            1. (Let typedExpressionIR_label be (((` nameIR_label) as expressionIR) # (( typeIR_label ctk_label ))))

            2. Result in (typedExpressionIR_label as switchLabelIR)

;; ../../../../spec-concrete/5.10-typing-statement.watsup:242.1-244.29
relation SwitchCase_table_ok

  (match) TC | f | tid_table | b_last | switchCase

    1. Case analysis on switchCase

      1. Case (% matches pattern `%:%`)

        1. (Let (switchLabel : blockStatement) be switchCase)

        2. Try matching path switchLabel-blockStatement

      2. Case (% matches pattern `%:`)

        1. (Let (switchLabel :) be switchCase)

        2. Try matching path switchLabel

  (path) switchLabel-blockStatement TC | f | tid_table | b_last | (switchLabel : blockStatement)

    1. (SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR)

    2. (Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR)

    3. (Let switchCaseIR be (switchLabelIR : blockStatementIR))

    4. Result in f_post, switchCaseIR, switchLabel

  (path) switchLabel TC | f | tid_table | b_last | (switchLabel :)

    1. (SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR)

    2. (Let switchCaseIR be (switchLabelIR :))

    3. Result in f, switchCaseIR, switchLabel

;; ../../../../spec-concrete/5.10-typing-statement.watsup:270.1-272.26
relation SwitchCases_table_ok

  (match) TC | f | tid_table | switchCase*

    1. Case analysis on switchCase*

      1. Case (% matches pattern [])

        1. Try matching path nil

      2. Case (% matches pattern _ :: _)

        1. (Let switchCase_h :: switchCase_t* be switchCase*)

        2. Try matching path cons

  (path) nil TC | f | tid_table | []

    1. Result in f, [], []

  (path) cons TC | f | tid_table | switchCase_h :: switchCase_t*

    1. (Let b_last be (switchCase_t* = []))

    2. (SwitchCase_table_ok: TC f tid_table b_last |- switchCase_h : f_h switchCaseIR_h # switchLabel_h)

    3. (SwitchCases_table_ok: TC f_h tid_table |- switchCase_t* : f_t switchCaseIR_t* # switchLabel_t*)

    4. Result in f_t, switchCaseIR_h :: switchCaseIR_t*, switchLabel_h :: switchLabel_t*

;; ../../../../spec-concrete/5.10-typing-statement.watsup:309.1-311.26
relation SwitchLabel_general_ok

  (match) TC | _typeIR' | bool' | switchLabel

    1. (Let _typeIR be _typeIR')

    2. (Let bool be bool')

    3. If ((bool = true)), then

      1. If ((switchLabel matches pattern `DEFAULT`)), then

        1. Try matching path default

    4. (Let typeIR_switch be _typeIR')

    5. (Let _bool be bool')

    6. If ((switchLabel has type expressionNonBrace)), then

      1. (Let expressionNonBrace_label be (switchLabel as expressionNonBrace))

      2. Try matching path expressionNonBrace

  (path) default TC | _typeIR | true | (default)

    1. Result in (default)

  (path) expressionNonBrace TC | typeIR_switch | _bool | (expressionNonBrace_label as switchLabel)

    1. (Let expression_label be $expressionNonBrace(expressionNonBrace_label))

    2. (Expr_ok: (local) TC |- expression_label : typedExpressionIR_label)

    3. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_label, typeIR_switch))

    4. If ((typedExpressionIR? matches pattern (_))), then

      1. (Let ?(typedExpressionIR_label_cast) be typedExpressionIR?)

      2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR_label_cast)

      3. If ((ctk matches pattern `LCTK`)), then

        1. Result in (typedExpressionIR_label_cast as switchLabelIR)

;; ../../../../spec-concrete/5.10-typing-statement.watsup:332.1-334.29
relation SwitchCase_general_ok

  (match) TC | f | typeIR_switch | b_last | switchCase

    1. Case analysis on switchCase

      1. Case (% matches pattern `%:%`)

        1. (Let (switchLabel : blockStatement) be switchCase)

        2. Try matching path switchLabel-blockStatement

      2. Case (% matches pattern `%:`)

        1. (Let (switchLabel :) be switchCase)

        2. Try matching path switchLabel

  (path) switchLabel-blockStatement TC | f | typeIR_switch | b_last | (switchLabel : blockStatement)

    1. (SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR)

    2. (Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR)

    3. (Let switchCaseIR be (switchLabelIR : blockStatementIR))

    4. Result in f_post, switchCaseIR, switchLabel

  (path) switchLabel TC | f | typeIR_switch | b_last | (switchLabel :)

    1. (SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR)

    2. (Let switchCaseIR be (switchLabelIR :))

    3. Result in f, switchCaseIR, switchLabel

;; ../../../../spec-concrete/5.10-typing-statement.watsup:360.1-362.26
relation SwitchCases_general_ok

  (match) TC | f | typeIR_switch | switchCase*

    1. Case analysis on switchCase*

      1. Case (% matches pattern [])

        1. Try matching path nil

      2. Case (% matches pattern _ :: _)

        1. (Let switchCase_h :: switchCase_t* be switchCase*)

        2. Try matching path cons

  (path) nil TC | f | typeIR_switch | []

    1. Result in f, [], []

  (path) cons TC | f | typeIR_switch | switchCase_h :: switchCase_t*

    1. (Let b_last be (switchCase_t* = []))

    2. (SwitchCase_general_ok: TC f typeIR_switch b_last |- switchCase_h : f_h switchCaseIR_h # switchLabel_h)

    3. (SwitchCases_general_ok: TC f_h typeIR_switch |- switchCase_t* : f_t switchCaseIR_t* # switchLabel_t*)

    4. Result in f_t, switchCaseIR_h :: switchCaseIR_t*, switchLabel_h :: switchLabel_t*

;; ../../../../spec-concrete/5.10-typing-statement.watsup:377.1-377.34
def $compat_switch(typeIR)

1. Return $compat'_switch($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:378.1-378.35
def $compat'_switch(typeIR)

1. If ((typeIR = ((error) as typeIR))), then

  1. Return true

2. Case analysis on typeIR

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `INT<%>`)

        1. (Let (int< _nat >) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `BIT<%>`)

        1. (Let (bit< _nat >) be numberTypeIR)

        2. Return true

  2. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `ENUM%{%}`)

        1. (Let (enum _tid { _id* }) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `ENUM%#%{%}`)

        1. (Let (enum _tid # _typeIR { _valueFieldIR* }) be enumTypeIR)

        2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:92.1-95.29
relation Decl_object_ok

  (match) p | TC_0 | frame | rdenv | objectDeclaration

    1. Case analysis on objectDeclaration

      1. Case (% has type functionDeclaration)

        1. (Let (annotationList (typeOrVoid name typeParameterListOpt ( parameterList )) blockStatement) be (objectDeclaration as functionDeclaration))

        2. Try matching path functionDeclaration

      2. Case (% has type instantiation)

        1. (Let instantiation be (objectDeclaration as instantiation))

        2. Try matching path instantiation

  (path) functionDeclaration p | TC_0 | frame | rdenv | ((annotationList (typeOrVoid name typeParameterListOpt ( parameterList )) blockStatement) as objectDeclaration)

    1. (Let TC_1 be TC_0[block.kind = (extern)])

    2. (Let TC_2 be TC_1[block.frame = frame])

    3. (Let typeParameter* be $flatten_typeParameterListOpt(typeParameterListOpt))

    4. (Let tid_expl be $name(typeParameter))*

    5. (Let TC_3 be $add_types((local), TC_2, tid_expl*, ((tid tid_expl) as typeDefIR)*))

    6. (Type_ok: (local) TC_3 |- typeOrVoid : typeIR_ret # tid*)

    7. If ((tid* matches pattern [])), then

      1. (Let parameter* be $flatten_parameterList(parameterList))

      2. (Parameters_ok: (local) TC_3 |- parameter* : parameterIR* # tid_impl*)

      3. (Let parameterTypeIR be $parameterIR(parameterIR))*

      4. (Let TC_4 be $add_parameters((local), TC_3, parameterTypeIR*))

      5. (Let TC_5 be TC_4[local.kind = (extern_method-> typeIR_ret)])

      6. (Block_ok: TC_5 (cont) |- blockStatement : _typingContext f blockStatementIR)

      7. If (((f = (ret)) \/ (typeIR_ret = ((void) as typeIR)))), then

        1. (Let rid be $rid(name, parameterList))

        2. (Let methodTypeIR be (extern_method( parameterTypeIR* )-> typeIR_ret))

        3. (Let routineTypeDefIR be (((methodTypeIR as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

        4. If ((RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds)), then

          1. (Let rdenv_init be $update_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

          2. (Let nameIR be $name(name))

          3. (Let functionDeclarationIR be (annotationList (typeIR_ret nameIR < tid_expl* , tid_impl* >( parameterIR* )) blockStatementIR))

          4. Result in frame, rdenv_init, (functionDeclarationIR as objectDeclarationIR)

  (path) instantiation p | TC_0 | frame | rdenv | (instantiation as objectDeclaration)

    1. (Decl_ok: p TC_0 |- (instantiation as declaration) : TC_1 declarationIR)

    2. If ((declarationIR has type instantiationIR)), then

      1. (Let instantiationIR be (declarationIR as instantiationIR))

      2. (Let (_annotationList _prefixedNameIR < _typeArgumentListIR >( _argumentListIR ) nameIR _objectInitializerOptIR ;) be instantiationIR)

      3. (Let varTypeIR'? be $find_var(p, TC_1, (` nameIR)))

      4. If ((varTypeIR'? matches pattern (_))), then

        1. (Let ?(varTypeIR) be varTypeIR'?)

        2. (Let frame_init be $update_map<id, varTypeIR>(frame, nameIR, varTypeIR))

        3. Result in frame_init, rdenv, (instantiationIR as objectDeclarationIR)

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:155.1-158.29
relation Decls_object_ok

  (match) p | TC | frame' | rdenv' | objectDeclaration*

    1. (Let frame be frame')

    2. (Let rdenv be rdenv')

    3. If ((objectDeclaration* matches pattern [])), then

      1. Try matching path nil

    4. (Let frame_0 be frame')

    5. (Let rdenv_0 be rdenv')

    6. If ((objectDeclaration* matches pattern _ :: _)), then

      1. (Let objectDeclaration_h :: objectDeclaration_t* be objectDeclaration*)

      2. Try matching path cons

  (path) nil p | TC | frame | rdenv | []

    1. Result in frame, rdenv, []

  (path) cons p | TC | frame_0 | rdenv_0 | objectDeclaration_h :: objectDeclaration_t*

    1. (Decl_object_ok: p TC frame_0 rdenv_0 |- objectDeclaration_h : frame_1 rdenv_1 objectDeclarationIR_h)

    2. (Decls_object_ok: p TC frame_1 rdenv_1 |- objectDeclaration_t* : frame_2 rdenv_2 objectDeclarationIR_t*)

    3. Result in frame_2, rdenv_2, objectDeclarationIR_h :: objectDeclarationIR_t*

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:173.1-173.46
def $subst_rdenv(theta, rdenv_extern, set<pair<rid, routineTypeDefIR>>')

1. (Let set<pair<rid, routineTypeDefIR>> be set<pair<rid, routineTypeDefIR>>')

2. If ((set<pair<rid, routineTypeDefIR>> = ({ [] }))), then

  1. Return rdenv_extern

3. (Let ({ pair<rid, routineTypeDefIR>* }) be set<pair<rid, routineTypeDefIR>>')

4. If ((pair<rid, routineTypeDefIR>* matches pattern _ :: _)), then

  1. (Let (rid_init_h : routineTypeDefIR_init_h) :: (rid_init_t : routineTypeDefIR_init_t)* be pair<rid, routineTypeDefIR>*)

  2. (Let routineTypeDefIR''? be $find_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h))

  3. If ((routineTypeDefIR''? matches pattern (_))), then

    1. (Let ?(routineTypeDefIR') be routineTypeDefIR''?)

    2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

      1. (Let (routineTypeIR < tid_expl* , tid_impl* >) be (routineTypeDefIR' as polyRoutineTypeDefIR))

      2. If ((routineTypeIR has type methodTypeIR)), then

        1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

        2. If ((methodTypeIR matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

          1. (Let (extern_methodabstract( parameterTypeIR* )-> typeIR_ret) be methodTypeIR)

          2. (Let routineTypeDefIR be ((((extern_method( parameterTypeIR* )-> typeIR_ret) as routineTypeIR) < tid_expl* , tid_impl* >) as routineTypeDefIR))

          3. (Let routineTypeDefIR_subst be $subst_routineTypeDef(theta, routineTypeDefIR))

          4. If ((RoutineTypeDef_alpha: routineTypeDefIR_subst ~~ routineTypeDefIR_init_h holds)), then

            1. (Let rdenv_extern_subst be $update_map<rid, routineTypeDefIR>(rdenv_extern, rid_init_h, routineTypeDefIR_subst))

            2. Return $subst_rdenv(theta, rdenv_extern_subst, ({ (rid_init_t : routineTypeDefIR_init_t)* }))

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:426.1-426.81
def $split_constructors(methodPrototype*)

1. Case analysis on methodPrototype*

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let methodPrototype_h :: methodPrototype_t* be methodPrototype*)

    2. (Let methodPrototype' be methodPrototype_h)

    3. Case analysis on methodPrototype'

      1. Case (% matches pattern `%%(%);`)

        1. (Let (_annotationList _typeIdentifier ( _parameterList );) be methodPrototype')

        2. (Let (methodPrototype_t_constructor*, methodPrototype_t_method*) be $split_constructors(methodPrototype_t*))

        3. Return (methodPrototype_h :: methodPrototype_t_constructor*, methodPrototype_t_method*)

      2. Case (% matches pattern `%%;`)

        1. (Let (_annotationList _functionPrototype ;) be methodPrototype')

        2. (Let (methodPrototype_t_constructor*, methodPrototype_t_method*) be $split_constructors(methodPrototype_t*))

        3. Return (methodPrototype_t_constructor*, methodPrototype_h :: methodPrototype_t_method*)

      3. Case (% matches pattern `%ABSTRACT%;`)

        1. (Let (_annotationList abstract _functionPrototype ;) be methodPrototype')

        2. (Let (methodPrototype_t_constructor*, methodPrototype_t_method*) be $split_constructors(methodPrototype_t*))

        3. Return (methodPrototype_t_constructor*, methodPrototype_h :: methodPrototype_t_method*)

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:624.1-627.26
relation Enum_serializable_field_ok

  (match) TC_0 | nameIR_enum | typeIR | (name = expression)

    1. Try matching path 

  (path)  TC_0 | nameIR_enum | typeIR | (name = expression)

    1. (Expr_ok: (block) TC_0 |- expression : typedExpressionIR)

    2. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR, typeIR))

    3. If ((typedExpressionIR'? matches pattern (_))), then

      1. (Let ?(typedExpressionIR_cast) be typedExpressionIR'?)

      2. (Let (_expressionIR # (( _typeIR ctk ))) be typedExpressionIR_cast)

      3. If ((ctk matches pattern `LCTK`)), then

        1. (Eval_static: (block) TC_0 |- typedExpressionIR_cast ~> value)

        2. (Let nameIR be $name(name))

        3. (Let typeIR_enum be ((enum nameIR_enum # typeIR { [] }) as typeIR))

        4. (Let value_enum be ((nameIR_enum . nameIR # value) as value))

        5. (Let TC_1 be $add_var((block), TC_0, nameIR, (() typeIR_enum (lctk) ?(value_enum))))

        6. Result in TC_1, (nameIR = typedExpressionIR_cast), value

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:646.1-649.26
relation Enum_serializable_fields_ok

  (match) TC' | nameIR_enum | typeIR | namedExpression*

    1. (Let TC be TC')

    2. If ((namedExpression* matches pattern [])), then

      1. Try matching path nil

    3. (Let TC_0 be TC')

    4. If ((namedExpression* matches pattern _ :: _)), then

      1. (Let namedExpression_h :: namedExpression_t* be namedExpression*)

      2. Try matching path cons

  (path) nil TC | nameIR_enum | typeIR | []

    1. Result in TC, [], []

  (path) cons TC_0 | nameIR_enum | typeIR | namedExpression_h :: namedExpression_t*

    1. (Enum_serializable_field_ok: TC_0 nameIR_enum typeIR |- namedExpression_h : TC_1 namedExpressionIR_h # value_field_h)

    2. (Enum_serializable_fields_ok: TC_1 nameIR_enum typeIR |- namedExpression_t* : TC_2 namedExpressionIR_t* # value_field_t*)

    3. (Let namedExpressionIR* be namedExpressionIR_h :: namedExpressionIR_t*)

    4. (Let value_field* be value_field_h :: value_field_t*)

    5. Result in TC_2, namedExpressionIR*, value_field*

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:33.1-35.23
relation SelectCase_keyset_simple_ok

  (match) TC | typeIR_key | simpleKeysetExpression

    1. If ((simpleKeysetExpression has type expression)), then

      1. (Let expression be (simpleKeysetExpression as expression))

      2. Try matching path expression-set-alpha

      3. Try matching path expression-set-subtype

      4. Try matching path expression-non-set

    2. Case analysis on simpleKeysetExpression

      1. Case (% matches pattern `%&&&%`)

        1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

        2. Try matching path mask

      2. Case (% matches pattern `%..%`)

        1. (Let (expression_l .. expression_r) be simpleKeysetExpression)

        2. Try matching path range

      3. Case (% matches pattern `DEFAULT`)

        1. Try matching path default

      4. Case (% matches pattern `_`)

        1. Try matching path dontcare

  (path) expression-set-alpha TC | typeIR_key | (expression as simpleKeysetExpression)

    1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

    2. (Let (_expressionIR # (( typeIR'' _ctk ))) be typedExpressionIR)

    3. If ((typeIR'' has type setTypeIR)), then

      1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

      2. If ((typeIR'* matches pattern [ _/1 ])), then

        1. (Let [typeIR] be typeIR'*)

        2. If ((Type_alpha: typeIR ~~ typeIR_key holds)), then

          1. Result in (typedExpressionIR as simpleKeysetExpressionIR)

  (path) expression-set-subtype TC | typeIR_key | (expression as simpleKeysetExpression)

    1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

    2. (Let (_expressionIR # (( typeIR'' _ctk ))) be typedExpressionIR)

    3. If ((typeIR'' has type setTypeIR)), then

      1. (Let (set< typeIR'* >) be (typeIR'' as setTypeIR))

      2. If ((typeIR'* matches pattern [ _/1 ])), then

        1. (Let [typeIR] be typeIR'*)

        2. If (~(Type_alpha: typeIR ~~ typeIR_key holds)), then

          1. If ((Sub_impl: typeIR <: typeIR_key holds)), then

            1. (Let typeIR_cast be ((set< [typeIR_key] >) as typeIR))

            2. (Let typedExpressionIR_cast be (((( typeIR_cast ) typedExpressionIR) as expressionIR) # (( typeIR_cast (dyn) ))))

            3. Result in (typedExpressionIR_cast as simpleKeysetExpressionIR)

  (path) expression-non-set TC | typeIR_key | (expression as simpleKeysetExpression)

    1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

    2. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

    3. If (~$is_set_typeIR(typeIR)), then

      1. If ((Sub_impl: typeIR <: typeIR_key holds)), then

        1. (Let typeIR_cast be ((set< [typeIR_key] >) as typeIR))

        2. (Let typedExpressionIR_cast be (((( typeIR_cast ) typedExpressionIR) as expressionIR) # (( typeIR_cast (dyn) ))))

        3. Result in (typedExpressionIR_cast as simpleKeysetExpressionIR)

  (path) mask TC | typeIR_key | (expression_l &&& expression_r)

    1. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

    2. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

    3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

    4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

      1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

      2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask))

      3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

        2. (Let (_expressionIR # (( typeIR_reduced _ctk ))) be typedExpressionIR_l_reduced)

        3. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_l_reduced, typeIR_key))

        4. If ((typedExpressionIR? matches pattern (_))), then

          1. (Let ?(typedExpressionIR_l_coerced) be typedExpressionIR?)

          2. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR_r_reduced, typeIR_key))

          3. If ((typedExpressionIR'? matches pattern (_))), then

            1. (Let ?(typedExpressionIR_r_coerced) be typedExpressionIR'?)

            2. Result in (typedExpressionIR_l_coerced &&& typedExpressionIR_r_coerced)

  (path) range TC | typeIR_key | (expression_l .. expression_r)

    1. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

    2. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

    3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

    4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

      1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

      2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range))

      3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

        2. (Let (_expressionIR # (( typeIR_reduced _ctk ))) be typedExpressionIR_l_reduced)

        3. (Let (_expressionIR' # (( typeIR _ctk' ))) be typedExpressionIR_r_reduced)

        4. If ((typeIR = typeIR_reduced)), then

          1. (Let typedExpressionIR? be $coerce_unary(typedExpressionIR_l_reduced, typeIR_key))

          2. If ((typedExpressionIR? matches pattern (_))), then

            1. (Let ?(typedExpressionIR_l_coerced) be typedExpressionIR?)

            2. (Let typedExpressionIR'? be $coerce_unary(typedExpressionIR_r_reduced, typeIR_key))

            3. If ((typedExpressionIR'? matches pattern (_))), then

              1. (Let ?(typedExpressionIR_r_coerced) be typedExpressionIR'?)

              2. Result in (typedExpressionIR_l_coerced .. typedExpressionIR_r_coerced)

  (path) default TC | typeIR_key | (default)

    1. Result in (default)

  (path) dontcare TC | typeIR_key | (_)

    1. Result in (_)

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:76.1-76.40
def $compat_mask(typeIR_l, typeIR_r)

1. Return $compat'_mask($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:77.1-77.41
def $compat'_mask(typeIR'', typeIR''')

1. (Let typeIR be typeIR'')

2. (Let typeIR' be typeIR''')

3. If ((typeIR = ((int) as typeIR))), then

  1. If ((typeIR' = ((int) as typeIR))), then

    1. Return true

4. (Let typeIR be typeIR'')

5. (Let typeIR' be typeIR''')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< w' >) be numberTypeIR')

        2. If ((w = w')), then

          1. Return true

7. (Let typeIR be typeIR'')

8. (Let typeIR' be typeIR''')

9. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< w' >) be numberTypeIR')

        2. If ((w = w')), then

          1. Return true

10. (Let typeIR_l be typeIR'')

11. (Let typeIR_r be typeIR''')

12. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:113.1-113.41
def $compat_range(typeIR_l, typeIR_r)

1. Return $compat'_range($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:114.1-114.42
def $compat'_range(typeIR'', typeIR''')

1. (Let typeIR be typeIR'')

2. (Let typeIR' be typeIR''')

3. If ((typeIR = ((int) as typeIR))), then

  1. If ((typeIR' = ((int) as typeIR))), then

    1. Return true

4. (Let typeIR be typeIR'')

5. (Let typeIR' be typeIR''')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< w >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `INT<%>`)), then

        1. (Let (int< w' >) be numberTypeIR')

        2. If ((w = w')), then

          1. Return true

7. (Let typeIR be typeIR'')

8. (Let typeIR' be typeIR''')

9. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< w >) be numberTypeIR)

    2. If ((typeIR' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `BIT<%>`)), then

        1. (Let (bit< w' >) be numberTypeIR')

        2. If ((w = w')), then

          1. Return true

10. (Let typeIR_l be typeIR'')

11. (Let typeIR_r be typeIR''')

12. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:161.1-163.23
relation SelectCase_keyset_ok

  (match) TC | typeIR'''* | keysetExpression

    1. (Let typeIR be typeIR''')*

    2. If ((typeIR* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR*)

      2. If ((keysetExpression has type expression)), then

        1. (Let expression be (keysetExpression as expression))

        2. Try matching path simpleKeysetExpression-expression

    3. (Let typeIR be typeIR''')*

    4. If ((typeIR* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR*)

      2. If ((keysetExpression has type simpleKeysetExpression)), then

        1. (Let simpleKeysetExpression be (keysetExpression as simpleKeysetExpression))

        2. If ((simpleKeysetExpression matches pattern `%&&&%`)), then

          1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

          2. Try matching path simpleKeysetExpression-mask

    5. (Let typeIR be typeIR''')*

    6. If ((typeIR* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR*)

      2. If ((keysetExpression has type simpleKeysetExpression)), then

        1. (Let simpleKeysetExpression be (keysetExpression as simpleKeysetExpression))

        2. If ((simpleKeysetExpression matches pattern `%..%`)), then

          1. (Let (expression_l .. expression_r) be simpleKeysetExpression)

          2. Try matching path simpleKeysetExpression-range

    7. (Let typeIR' be typeIR''')*

    8. If ((keysetExpression = ((default) as keysetExpression))), then

      1. Try matching path simpleKeysetExpression-default

    9. (Let typeIR be typeIR''')*

    10. If ((keysetExpression = ((_) as keysetExpression))), then

      1. Try matching path simpleKeysetExpression-dontcare

    11. (Let typeIR be typeIR''')*

    12. If ((typeIR* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR*)

      2. If ((keysetExpression has type tupleKeysetExpression)), then

        1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

        2. If ((tupleKeysetExpression matches pattern `(%&&&%)`)), then

          1. (Let (( expression_l &&& expression_r )) be tupleKeysetExpression)

          2. Try matching path tupleKeysetExpression-mask

    13. (Let typeIR be typeIR''')*

    14. If ((typeIR* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR*)

      2. If ((keysetExpression has type tupleKeysetExpression)), then

        1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

        2. If ((tupleKeysetExpression matches pattern `(%..%)`)), then

          1. (Let (( expression_l .. expression_r )) be tupleKeysetExpression)

          2. Try matching path tupleKeysetExpression-range

    15. (Let typeIR be typeIR''')*

    16. If ((keysetExpression = (((default)) as keysetExpression))), then

      1. Try matching path tupleKeysetExpression-default

    17. (Let typeIR be typeIR''')*

    18. If ((keysetExpression = (((_)) as keysetExpression))), then

      1. Try matching path tupleKeysetExpression-dontcare

    19. (Let typeIR_key be typeIR''')*

    20. If ((keysetExpression has type tupleKeysetExpression)), then

      1. (Let tupleKeysetExpression be (keysetExpression as tupleKeysetExpression))

      2. If ((tupleKeysetExpression matches pattern `(%,%)`)), then

        1. (Let (( simpleKeysetExpression_h , simpleKeysetExpressionList_t )) be tupleKeysetExpression)

        2. Try matching path tupleKeysetExpression-list

  (path) simpleKeysetExpression-expression TC | [typeIR_key] | (expression as keysetExpression)

    1. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression as simpleKeysetExpression) : simpleKeysetExpressionIR)

    2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

  (path) simpleKeysetExpression-mask TC | [typeIR_key] | ((expression_l &&& expression_r) as keysetExpression)

    1. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression_l &&& expression_r) : simpleKeysetExpressionIR)

    2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

  (path) simpleKeysetExpression-range TC | [typeIR_key] | ((expression_l .. expression_r) as keysetExpression)

    1. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression_l .. expression_r) : simpleKeysetExpressionIR)

    2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

  (path) simpleKeysetExpression-default TC | typeIR'* | ((default) as keysetExpression)

    1. If (([] = typeIR'*)), then

      1. Result in ((default) as keysetExpressionIR)

    2. (Let typeIR''* be typeIR'*)

    3. If ((typeIR''* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR''*)

      2. (SelectCase_keyset_simple_ok: TC typeIR_key |- (default) : simpleKeysetExpressionIR)

      3. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

    4. (Let typeIR_key* be typeIR'*)

    5. If ((|typeIR_key*| > 1)), then

      1. (SelectCase_keyset_simple_ok: TC ((seq< typeIR_key* >) as typeIR) |- (default) : simpleKeysetExpressionIR)

      2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

  (path) simpleKeysetExpression-dontcare TC | typeIR* | ((_) as keysetExpression)

    1. (Let typeIR'* be typeIR*)

    2. If ((typeIR'* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR'*)

      2. (SelectCase_keyset_simple_ok: TC typeIR_key |- (_) : simpleKeysetExpressionIR)

      3. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

    3. (Let typeIR_key* be typeIR*)

    4. If ((|typeIR_key*| > 1)), then

      1. (SelectCase_keyset_simple_ok: TC ((seq< typeIR_key* >) as typeIR) |- (_) : simpleKeysetExpressionIR)

      2. Result in (simpleKeysetExpressionIR as keysetExpressionIR)

  (path) tupleKeysetExpression-mask TC | [typeIR_key] | ((( expression_l &&& expression_r )) as keysetExpression)

    1. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression_l &&& expression_r) : simpleKeysetExpressionIR)

    2. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

  (path) tupleKeysetExpression-range TC | [typeIR_key] | ((( expression_l .. expression_r )) as keysetExpression)

    1. (SelectCase_keyset_simple_ok: TC typeIR_key |- (expression_l .. expression_r) : simpleKeysetExpressionIR)

    2. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

  (path) tupleKeysetExpression-default TC | typeIR* | (((default)) as keysetExpression)

    1. (Let typeIR'* be typeIR*)

    2. If ((typeIR'* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR'*)

      2. (SelectCase_keyset_simple_ok: TC typeIR_key |- (default) : simpleKeysetExpressionIR)

      3. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

    3. (Let typeIR_key* be typeIR*)

    4. If ((|typeIR_key*| > 1)), then

      1. (SelectCase_keyset_simple_ok: TC ((seq< typeIR_key* >) as typeIR) |- (default) : simpleKeysetExpressionIR)

      2. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

  (path) tupleKeysetExpression-dontcare TC | typeIR* | (((_)) as keysetExpression)

    1. (Let typeIR'* be typeIR*)

    2. If ((typeIR'* matches pattern [ _/1 ])), then

      1. (Let [typeIR_key] be typeIR'*)

      2. (SelectCase_keyset_simple_ok: TC typeIR_key |- (_) : simpleKeysetExpressionIR)

      3. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

    3. (Let typeIR_key* be typeIR*)

    4. If ((|typeIR_key*| > 1)), then

      1. (SelectCase_keyset_simple_ok: TC ((seq< typeIR_key* >) as typeIR) |- (_) : simpleKeysetExpressionIR)

      2. Result in ((( [simpleKeysetExpressionIR] )) as keysetExpressionIR)

  (path) tupleKeysetExpression-list TC | typeIR_key* | ((( simpleKeysetExpression_h , simpleKeysetExpressionList_t )) as keysetExpression)

    1. (Let simpleKeysetExpression_t* be $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t))

    2. (Let simpleKeysetExpression* be simpleKeysetExpression_h :: simpleKeysetExpression_t*)

    3. If ((|typeIR_key*| = |simpleKeysetExpression*|)), then

      1. (SelectCase_keyset_simple_ok: TC typeIR_key |- simpleKeysetExpression : simpleKeysetExpressionIR)*

      2. Result in ((( simpleKeysetExpressionIR* )) as keysetExpressionIR)

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:294.1-296.26
relation SelectCase_ok

  (match) TC | nameIR_state* | typeIR_key* | (keysetExpression : name ;)

    1. Try matching path 

  (path)  TC | nameIR_state* | typeIR_key* | (keysetExpression : name ;)

    1. (SelectCase_keyset_ok: TC typeIR_key* |- keysetExpression : keysetExpressionIR)

    2. (Let nameIR be $name(name))

    3. If (nameIR is in nameIR_state*), then

      1. Result in (keysetExpressionIR : nameIR ;)

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:7.1-7.52
def $compat_table_exact_optional_key(typeIR)

1. Return $compat'_table_exact_optional_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:8.1-8.53
def $compat'_table_exact_optional_key(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((bool) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR'')

4. If ((typeIR = ((error) as typeIR))), then

  1. Return true

5. (Let typeIR be typeIR'')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Return true

7. (Let typeIR' be typeIR'')

8. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid typeIR) be aliasTypeIR)

    2. Return $compat_table_exact_optional_key(typeIR)

9. (Let typeIR be typeIR'')

10. If ((typeIR has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

    1. (Let (enum _tid { _id* }) be enumTypeIR)

    2. Return true

11. (Let typeIR' be typeIR'')

12. If ((typeIR' has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR' as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return $compat_table_exact_optional_key(typeIR)

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:21.1-21.55
def $compat_table_lpm_ternary_range_key(typeIR)

1. Return $compat'_table_lpm_ternary_range_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:22.1-22.56
def $compat'_table_lpm_ternary_range_key(typeIR'')

1. (Let typeIR be typeIR'')

2. If ((typeIR = ((int) as typeIR))), then

  1. Return true

3. (Let typeIR be typeIR'')

4. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `INT<%>`)), then

    1. (Let (int< _nat >) be numberTypeIR)

    2. Return true

5. (Let typeIR be typeIR'')

6. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `BIT<%>`)), then

    1. (Let (bit< _nat >) be numberTypeIR)

    2. Return true

7. (Let typeIR' be typeIR'')

8. If ((typeIR' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type _tid typeIR) be aliasTypeIR)

    2. Return $compat_table_lpm_ternary_range_key(typeIR)

9. (Let typeIR' be typeIR'')

10. If ((typeIR' has type enumTypeIR)), then

  1. (Let enumTypeIR be (typeIR' as enumTypeIR))

  2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

    1. (Let (enum _tid # typeIR { _valueFieldIR* }) be enumTypeIR)

    2. Return $compat_table_lpm_ternary_range_key(typeIR)

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:34.1-34.45
def $compat_table_key(nameIR, typeIR)

1. Case analysis on nameIR

  1. Case (% = "exact")

    1. If ($compat_table_exact_optional_key(typeIR)), then

      1. Return true

  2. Case (% = "optional")

    1. If ($compat_table_exact_optional_key(typeIR)), then

      1. Return true

  3. Case (% = "lpm")

    1. If ($compat_table_lpm_ternary_range_key(typeIR)), then

      1. Return true

  4. Case (% = "ternary")

    1. If ($compat_table_lpm_ternary_range_key(typeIR)), then

      1. Return true

  5. Case (% = "range")

    1. If ($compat_table_lpm_ternary_range_key(typeIR)), then

      1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:85.1-86.41
def $split_dataplane_parameters(parameterTypeIR*)

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. (Let (direction _typeIR _id _value?) be parameterTypeIR_h)

    3. Case analysis on (direction matches pattern ``EMPTY`)

      1. Case true

        1. (Let (parameterTypeIR_data*, parameterTypeIR_control*) be $split_dataplane_parameters(parameterTypeIR_t*))

        2. Return (parameterTypeIR_data*, parameterTypeIR_h :: parameterTypeIR_control*)

      2. Case false

        1. (Let (parameterTypeIR_data*, parameterTypeIR_control*) be $split_dataplane_parameters(parameterTypeIR_t*))

        2. Return (parameterTypeIR_h :: parameterTypeIR_data*, parameterTypeIR_control*)

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:236.1-239.26
relation TableEntry_keyset_simple_ok

  (match) TC | TBLC | (typeIR_key, text) | simpleKeysetExpression

    1. If ((simpleKeysetExpression has type expression)), then

      1. (Let expression be (simpleKeysetExpression as expression))

      2. Try matching path expression

    2. Case analysis on simpleKeysetExpression

      1. Case (% matches pattern `%&&&%`)

        1. (Let (expression_l &&& expression_r) be simpleKeysetExpression)

        2. Try matching path mask

      2. Case (% matches pattern `DEFAULT`)

        1. Try matching path default

      3. Case (% matches pattern `_`)

        1. Try matching path dontcare

    3. If ((text = "range")), then

      1. If ((simpleKeysetExpression matches pattern `%..%`)), then

        1. (Let (expression_l .. expression_r) be simpleKeysetExpression)

        2. Try matching path range-range

  (path) expression TC | TBLC | (typeIR_key, text) | (expression as simpleKeysetExpression)

    1. If (("lpm" = text)), then

      1. (Let matchMode be TBLC.mode)

      2. If ((matchMode matches pattern `NOPRILPM%`)), then

        1. (Let (noprilpm n) be matchMode)

        2. (Expr_ok: (local) TC |- expression : typedExpressionIR)

        3. (Let (_expressionIR # (( typeIR ctk ))) be typedExpressionIR)

        4. If ((Sub_impl: typeIR <: typeIR_key holds)), then

          1. (Let typeIR_set be ((set< [typeIR_key] >) as typeIR))

          2. (Let typedExpressionIR_set be (((( typeIR_set ) typedExpressionIR) as expressionIR) # (( typeIR_set ctk ))))

          3. Result in (lpm n), (typedExpressionIR_set as simpleKeysetExpressionIR)

    2. (Let nameIR_matchkind be text)

    3. If ((nameIR_matchkind =/= "lpm")), then

      1. (Expr_ok: (local) TC |- expression : typedExpressionIR)

      2. (Let (_expressionIR # (( typeIR ctk ))) be typedExpressionIR)

      3. If ((Sub_impl: typeIR <: typeIR_key holds)), then

        1. (Let typeIR_set be ((set< [typeIR_key] >) as typeIR))

        2. (Let typedExpressionIR_set be (((( typeIR_set ) typedExpressionIR) as expressionIR) # (( typeIR_set ctk ))))

        3. Result in (nolpm), (typedExpressionIR_set as simpleKeysetExpressionIR)

  (path) mask TC | TBLC | (typeIR_key, text) | (expression_l &&& expression_r)

    1. If (("lpm" = text)), then

      1. (Let matchMode be TBLC.mode)

      2. If ((matchMode matches pattern `NOPRILPM%`)), then

        1. (Let (noprilpm n) be matchMode)

        2. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

        3. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

        4. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        5. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

          2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask))

          3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

            2. (Let (_expressionIR # (( typeIR_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            3. If ((Sub_impl: typeIR_reduced <: typeIR_key holds)), then

              1. If ((ctk_r_reduced matches pattern `LCTK`)), then

                1. (Eval_static: (local) TC |- typedExpressionIR_r_reduced ~> value_r)

                2. (Let i_r be $to_number(value_r))

                3. (Let n_prefix be $tableEntry_lpm_prefix(((n w $to_bitstr((n as int), i_r)) as value)))

                4. Result in (lpm n_prefix), (typedExpressionIR_l_reduced &&& typedExpressionIR_r_reduced)

    2. If (("ternary" = text)), then

      1. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

      2. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

      3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

        2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask))

        3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

          2. (Let (_expressionIR # (( typeIR_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          3. If ((Sub_impl: typeIR_reduced <: typeIR_key holds)), then

            1. Result in (nolpm), (typedExpressionIR_l_reduced &&& typedExpressionIR_r_reduced)

  (path) range-range TC | TBLC | (typeIR_key, "range") | (expression_l .. expression_r)

    1. (Expr_ok: (local) TC |- expression_l : typedExpressionIR_l)

    2. (Expr_ok: (local) TC |- expression_r : typedExpressionIR_r)

    3. (Let (typedExpressionIR, typedExpressionIR)? be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

    4. If (((typedExpressionIR, typedExpressionIR)? matches pattern (_))), then

      1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?)

      2. (Let (typedExpressionIR, typedExpressionIR)'? be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range))

      3. If (((typedExpressionIR, typedExpressionIR)'? matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?)

        2. (Let (_expressionIR # (( typeIR_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

        3. If ((Sub_impl: typeIR_reduced <: typeIR_key holds)), then

          1. Result in (nolpm), (typedExpressionIR_l_reduced .. typedExpressionIR_r_reduced)

  (path) default TC | TBLC | (typeIR_key, text) | (default)

    1. If (("lpm" = text)), then

      1. (Let matchMode be TBLC.mode)

      2. If ((matchMode matches pattern `NOPRILPM%`)), then

        1. (Let (noprilpm n) be matchMode)

        2. Result in (lpm n), (default)

    2. (Let nameIR_matchkind be text)

    3. If ((nameIR_matchkind =/= "lpm")), then

      1. If ((nameIR_matchkind =/= "exact")), then

        1. Result in (nolpm), (default)

  (path) dontcare TC | TBLC | (typeIR_key, text) | (_)

    1. If (("lpm" = text)), then

      1. (Let matchMode be TBLC.mode)

      2. If ((matchMode matches pattern `NOPRILPM%`)), then

        1. (Let (noprilpm _nat) be matchMode)

        2. Result in (lpm 0), (_)

    2. (Let nameIR_matchkind be text)

    3. If ((nameIR_matchkind =/= "lpm")), then

      1. If ((nameIR_matchkind =/= "exact")), then

        1. Result in (nolpm), (_)

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:396.1-399.29
relation TableEntry_keysets_simple_ok

  (match) TC | TBLC | TBLS' | matchKey* | simpleKeysetExpression*

    1. (Let TBLS be TBLS')

    2. If ((matchKey* matches pattern [])), then

      1. If ((simpleKeysetExpression* matches pattern [])), then

        1. Try matching path nil

    3. (Let TBLS_0 be TBLS')

    4. If ((matchKey* matches pattern _ :: _)), then

      1. (Let matchKey_h :: matchKey_t* be matchKey*)

      2. If ((simpleKeysetExpression* matches pattern _ :: _)), then

        1. (Let simpleKeysetExpression_h :: simpleKeysetExpression_t* be simpleKeysetExpression*)

        2. Try matching path cons

  (path) nil TC | TBLC | TBLS | [] | []

    1. Result in TBLS, []

  (path) cons TC | TBLC | TBLS_0 | matchKey_h :: matchKey_t* | simpleKeysetExpression_h :: simpleKeysetExpression_t*

    1. (TableEntry_keyset_simple_ok: TC TBLC |- matchKey_h @ simpleKeysetExpression_h : TBLS_1 simpleKeysetExpressionIR_h)

    2. (Let TBLS_2 be $join_tableEntryState(TBLS_0, TBLS_1))

    3. (TableEntry_keysets_simple_ok: TC TBLC TBLS_2 |- matchKey_t* @ simpleKeysetExpression_t* : TBLS_3 simpleKeysetExpressionIR_t*)

    4. Result in TBLS_3, simpleKeysetExpressionIR_h :: simpleKeysetExpressionIR_t*

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:948.1-948.44
def $count_table_keys(tableProperty''*)

1. (Let tableProperty be tableProperty'')*

2. If ((tableProperty* matches pattern [])), then

  1. Return 0

3. (Let tableProperty' be tableProperty'')*

4. If ((tableProperty'* matches pattern _ :: _)), then

  1. (Let tableProperty :: tableProperty_t* be tableProperty'*)

  2. If ((tableProperty matches pattern `KEY={%}`)), then

    1. (Let (key={ _tableKeyList }) be tableProperty)

    2. Return (1 + $count_table_keys(tableProperty_t*))

5. (Let tableProperty be tableProperty'')*

6. If ((tableProperty* matches pattern _ :: _)), then

  1. (Let tableProperty_h :: tableProperty_t* be tableProperty*)

  2. Otherwise

    1. Return $count_table_keys(tableProperty_t*)

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:961.1-961.47
def $count_table_actions(tableProperty''*)

1. (Let tableProperty be tableProperty'')*

2. If ((tableProperty* matches pattern [])), then

  1. Return 0

3. (Let tableProperty' be tableProperty'')*

4. If ((tableProperty'* matches pattern _ :: _)), then

  1. (Let tableProperty :: tableProperty_t* be tableProperty'*)

  2. If ((tableProperty matches pattern `ACTIONS={%}`)), then

    1. (Let (actions={ _tableActionList }) be tableProperty)

    2. Return (1 + $count_table_actions(tableProperty_t*))

5. (Let tableProperty be tableProperty'')*

6. If ((tableProperty* matches pattern _ :: _)), then

  1. (Let tableProperty_h :: tableProperty_t* be tableProperty*)

  2. Otherwise

    1. Return $count_table_actions(tableProperty_t*)

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:7.1-7.73
def $filter_default_parameters(parameterTypeIR*, id_default*)

1. Case analysis on parameterTypeIR*

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t* be parameterTypeIR*)

    2. (Let (_direction _typeIR id_h _value?) be parameterTypeIR_h)

    3. If (id_h is in id_default*), then

      1. Return $filter_default_parameters(parameterTypeIR_t*, id_default*)

    4. Otherwise

      1. Return parameterTypeIR_h :: $filter_default_parameters(parameterTypeIR_t*, id_default*)

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:26.1-26.71
def $align_parameters(parameterTypeIR*, argumentIR*)

1. (Let (_direction _typeIR id _value?) be parameterTypeIR)*

2. (Let parameterTypeIR'? be $align_parameters'(({ (id : parameterTypeIR)* }), parameterTypeIR, argumentIR))*

3. If ((parameterTypeIR'? matches pattern (_)))*, then

  1. (Let ?(parameterTypeIR_aligned) be parameterTypeIR'?)*

  2. Return parameterTypeIR_aligned*

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:27.1-27.96
def $align_parameters'(_map<id, parameterTypeIR>', parameterTypeIR', argumentIR)

1. (Let _map<id, parameterTypeIR> be _map<id, parameterTypeIR>')

2. (Let parameterTypeIR be parameterTypeIR')

3. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. Return ?(parameterTypeIR)

4. (Let ({ (id_param : parameterTypeIR)* }) be _map<id, parameterTypeIR>')

5. (Let _parameterTypeIR be parameterTypeIR')

6. If ((argumentIR matches pattern `%=%`)), then

  1. (Let (nameIR = _typedExpressionIR) be argumentIR)

  2. Return $find_map<id, parameterTypeIR>(({ (id_param : parameterTypeIR)* }), nameIR)

7. (Let ({ (id_param : parameterTypeIR)* }) be _map<id, parameterTypeIR>')

8. (Let _parameterTypeIR be parameterTypeIR')

9. If ((argumentIR matches pattern `%=_`)), then

  1. (Let (nameIR =_) be argumentIR)

  2. Return $find_map<id, parameterTypeIR>(({ (id_param : parameterTypeIR)* }), nameIR)

10. (Let _map<id, parameterTypeIR> be _map<id, parameterTypeIR>')

11. (Let parameterTypeIR be parameterTypeIR')

12. If ((argumentIR matches pattern `_`)), then

  1. Return ?(parameterTypeIR)

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:60.1-62.23
relation Expr_lvalue_ok

  (match) p | TC | (expressionIR # (( _typeIR _ctk )))

    1. Case analysis on expressionIR

      1. Case (% has type prefixedNameIR)

        1. (Let prefixedNameIR be (expressionIR as prefixedNameIR))

        2. Try matching path referenceExpressionIR

      2. Case (% has type memberAccessExpressionIR)

        1. (Let (memberAccessBaseIR . nameIR) be (expressionIR as memberAccessExpressionIR))

        2. If ((memberAccessBaseIR has type typedExpressionIR)), then

          1. (Let typedExpressionIR_base be (memberAccessBaseIR as typedExpressionIR))

          2. Try matching path accessExpressionIR-memberAccessExpressionIR

      3. Case (% has type indexAccessExpressionIR)

        1. (Let indexAccessExpressionIR be (expressionIR as indexAccessExpressionIR))

        2. Case analysis on indexAccessExpressionIR

          1. Case (% matches pattern `%[%]`)

            1. (Let (typedExpressionIR_base [ typedExpressionIR_index ]) be indexAccessExpressionIR)

            2. Try matching path accessExpressionIR-indexAccessExpressionIR

          2. Case (% matches pattern `%[%:%]`)

            1. (Let (typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ]) be indexAccessExpressionIR)

            2. Try matching path accessExpressionIR-indexAccessExpressionIR-bitslice

  (path) referenceExpressionIR p | TC | ((prefixedNameIR as expressionIR) # (( _typeIR _ctk )))

    1. (Let varTypeIR? be $find_var(p, TC, prefixedNameIR))

    2. If ((varTypeIR? matches pattern (_))), then

      1. (Let ?((direction _typeIR' ctk _value?)) be varTypeIR?)

      2. If ((ctk matches pattern `DYN`)), then

        1. If (((direction = (out)) \/ (direction = (inout)))), then

          1. The relation holds

  (path) accessExpressionIR-memberAccessExpressionIR p | TC | ((((typedExpressionIR_base as memberAccessBaseIR) . nameIR) as expressionIR) # (( _typeIR _ctk )))

    1. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_base holds)), then

      1. (Let (_expressionIR # (( typeIR_base _ctk' ))) be typedExpressionIR_base)

      2. (Let typeIR' be $canon(typeIR_base))

      3. If ((typeIR' has type headerStackTypeIR)), then

        1. (Let (typeIR [ _nat ]) be (typeIR' as headerStackTypeIR))

        2. If (((nameIR = "next") \/ (nameIR = "last"))), then

          1. If ((((p = (block)) /\ $is_parser_blockKind(TC.block.kind)) \/ ((p = (local)) /\ $is_parser_state_localKind(TC.local.kind)))), then

            1. The relation holds

      4. If (~$is_headerStackTypeIR($canon(typeIR_base))), then

        1. The relation holds

  (path) accessExpressionIR-indexAccessExpressionIR p | TC | (((typedExpressionIR_base [ typedExpressionIR_index ]) as expressionIR) # (( _typeIR _ctk )))

    1. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_base holds)), then

      1. The relation holds

  (path) accessExpressionIR-indexAccessExpressionIR-bitslice p | TC | (((typedExpressionIR_base [ typedExpressionIR_hi : typedExpressionIR_lo ]) as expressionIR) # (( _typeIR _ctk )))

    1. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_base holds)), then

      1. The relation holds

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:6.1-7.12
syntax infer = 
   | knownas typeIR
   | unknown

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:9.21-9.36
syntax constraint = map<tid, infer>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:11.1-11.41
def $empty_constraint(tid*)

1. Return ({ (tid : (unknown))* })

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:14.20-14.36
syntax inference = map<tid, typeIR>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:20.1-20.60
def $infer(tid_infer*, parameterTypeIR*, argumentIR*)

1. (Let constraint_init be $empty_constraint(tid_infer*))

2. (Let constraint_pair be $infer'(constraint_init, parameterTypeIR, argumentIR))*

3. (Let constraint_inferred be $merge_constraints(constraint_init, constraint_pair*))

4. (Let inference be $resolve_constraint(constraint_inferred))

5. Return inference

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:21.1-21.66
def $infer'(constraint, parameterTypeIR, argumentIR)

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. (Let (_direction typeIR_param _id _value?) be parameterTypeIR)

  3. (Let (_expressionIR # (( typeIR_arg _ctk ))) be typedExpressionIR)

  4. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

2. Case analysis on argumentIR

  1. Case (% matches pattern `%=%`)

    1. (Let (nameIR = typedExpressionIR) be argumentIR)

    2. (Let (_direction typeIR_param _id _value?) be parameterTypeIR)

    3. (Let (_expressionIR # (( typeIR_arg _ctk ))) be typedExpressionIR)

    4. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

  2. Case (% matches pattern `%=_`)

    1. (Let (nameIR =_) be argumentIR)

    2. Return constraint

  3. Case (% matches pattern `_`)

    1. Return constraint

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:23.1-23.66
def $gen_constraint_type(constraint', typeIR'', typeIR_arg')

1. (Let constraint be constraint')

2. (Let typeIR be typeIR'')

3. (Let typeIR_arg be typeIR_arg')

4. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `TID%`)), then

    1. (Let (tid tid_param) be namedTypeIR)

    2. If ($in_set<tid>(tid_param, $dom_map<tid, infer>(constraint))), then

      1. Return $update_map<tid, infer>(constraint, tid_param, (knownas typeIR_arg))

5. (Let constraint_0 be constraint')

6. (Let typeIR be typeIR'')

7. (Let typeIR' be typeIR_arg')

8. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `%<%>`)), then

    1. (Let (polyTypeDefIR_param < typeIR_param* >) be namedTypeIR)

    2. If ((typeIR' has type namedTypeIR)), then

      1. (Let namedTypeIR' be (typeIR' as namedTypeIR))

      2. If ((namedTypeIR' matches pattern `%<%>`)), then

        1. (Let (polyTypeDefIR_arg < typeIR_arg* >) be namedTypeIR')

        2. (Let typeIR_specialized_param be $specialize_typeDef((polyTypeDefIR_param as typeDefIR), typeIR_param*))

        3. (Let typeIR_specialized_arg be $specialize_typeDef((polyTypeDefIR_arg as typeDefIR), typeIR_arg*))

        4. If (($is_nominal_typeIR(typeIR_specialized_param) /\ $is_nominal_typeIR(typeIR_specialized_arg))), then

          1. (Let constraint_1 be $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg))

          2. (Let constraint_2 be $gen_constraint_types(constraint_1, typeIR_param*, typeIR_arg*))

          3. Return constraint_2

9. (Let constraint_0 be constraint')

10. (Let typeIR be typeIR'')

11. (Let typeIR' be typeIR_arg')

12. If ((typeIR has type namedTypeIR)), then

  1. (Let namedTypeIR be (typeIR as namedTypeIR))

  2. If ((namedTypeIR matches pattern `%<%>`)), then

    1. (Let (polyTypeDefIR_param < typeIR_param* >) be namedTypeIR)

    2. If ((typeIR' has type namedTypeIR)), then

      1. (Let namedTypeIR' be (typeIR' as namedTypeIR))

      2. If ((namedTypeIR' matches pattern `%<%>`)), then

        1. (Let (polyTypeDefIR_arg < typeIR_arg* >) be namedTypeIR')

        2. (Let typeIR_specialized_param be $specialize_typeDef((polyTypeDefIR_param as typeDefIR), typeIR_param*))

        3. (Let typeIR_specialized_arg be $specialize_typeDef((polyTypeDefIR_arg as typeDefIR), typeIR_arg*))

        4. If ((~$is_nominal_typeIR(typeIR_specialized_param) /\ ~$is_nominal_typeIR(typeIR_specialized_arg))), then

          1. (Let constraint_1 be $gen_constraint_type(constraint_0, typeIR_specialized_param, typeIR_specialized_arg))

          2. Return constraint_1

13. (Let constraint be constraint')

14. (Let typeIR be typeIR'')

15. (Let typeIR_arg be typeIR_arg')

16. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

    1. (Let (typedef _tid typeIR_param) be aliasTypeIR)

    2. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

17. (Let constraint be constraint')

18. (Let typeIR_param be typeIR'')

19. (Let typeIR be typeIR_arg')

20. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPEDEF%%`)), then

    1. (Let (typedef _tid typeIR_arg) be aliasTypeIR)

    2. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

21. (Let constraint be constraint')

22. (Let typeIR be typeIR'')

23. (Let typeIR' be typeIR_arg')

24. If ((typeIR has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `TYPE%%`)), then

    1. (Let (type tid typeIR_param) be aliasTypeIR)

    2. If ((typeIR' has type aliasTypeIR)), then

      1. (Let aliasTypeIR' be (typeIR' as aliasTypeIR))

      2. If ((aliasTypeIR' matches pattern `TYPE%%`)), then

        1. (Let (type tid' typeIR_arg) be aliasTypeIR')

        2. If ((tid = tid')), then

          1. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

25. (Let constraint be constraint')

26. (Let typeIR be typeIR'')

27. (Let typeIR' be typeIR_arg')

28. If ((typeIR has type listTypeIR)), then

  1. (Let (list< typeIR_param >) be (typeIR as listTypeIR))

  2. If ((typeIR' has type listTypeIR)), then

    1. (Let (list< typeIR_arg >) be (typeIR' as listTypeIR))

    2. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

29. (Let constraint be constraint')

30. (Let typeIR be typeIR'')

31. (Let typeIR' be typeIR_arg')

32. If ((typeIR has type tupleTypeIR)), then

  1. (Let (tuple< typeIR_param* >) be (typeIR as tupleTypeIR))

  2. If ((typeIR' has type tupleTypeIR)), then

    1. (Let (tuple< typeIR_arg* >) be (typeIR' as tupleTypeIR))

    2. Return $gen_constraint_types(constraint, typeIR_param*, typeIR_arg*)

33. (Let constraint be constraint')

34. (Let typeIR be typeIR'')

35. (Let typeIR' be typeIR_arg')

36. If ((typeIR has type headerStackTypeIR)), then

  1. (Let (typeIR_param [ n_size ]) be (typeIR as headerStackTypeIR))

  2. If ((typeIR' has type headerStackTypeIR)), then

    1. (Let (typeIR_arg [ n_size' ]) be (typeIR' as headerStackTypeIR))

    2. If ((n_size = n_size')), then

      1. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

37. (Let constraint be constraint')

38. (Let typeIR be typeIR'')

39. (Let typeIR' be typeIR_arg')

40. If ((typeIR has type structTypeIR)), then

  1. (Let (struct tid { (typeIR_param id_field ;)* }) be (typeIR as structTypeIR))

  2. If ((typeIR' has type structTypeIR)), then

    1. (Let (struct tid' { (typeIR_arg id_field' ;)* }) be (typeIR' as structTypeIR))

    2. If ((id_field = id_field'))*, then

      1. If ((tid = tid')), then

        1. Return $gen_constraint_types(constraint, typeIR_param*, typeIR_arg*)

41. (Let constraint be constraint')

42. (Let typeIR be typeIR'')

43. (Let typeIR' be typeIR_arg')

44. If ((typeIR has type headerTypeIR)), then

  1. (Let (header tid { (typeIR_param id_field ;)* }) be (typeIR as headerTypeIR))

  2. If ((typeIR' has type headerTypeIR)), then

    1. (Let (header tid' { (typeIR_arg id_field' ;)* }) be (typeIR' as headerTypeIR))

    2. If ((id_field = id_field'))*, then

      1. If ((tid = tid')), then

        1. Return $gen_constraint_types(constraint, typeIR_param*, typeIR_arg*)

45. (Let constraint be constraint')

46. (Let typeIR be typeIR'')

47. (Let typeIR' be typeIR_arg')

48. If ((typeIR has type headerUnionTypeIR)), then

  1. (Let (header_union tid { (typeIR_param id_field ;)* }) be (typeIR as headerUnionTypeIR))

  2. If ((typeIR' has type headerUnionTypeIR)), then

    1. (Let (header_union tid' { (typeIR_arg id_field' ;)* }) be (typeIR' as headerUnionTypeIR))

    2. If ((id_field = id_field'))*, then

      1. If ((tid = tid')), then

        1. Return $gen_constraint_types(constraint, typeIR_param*, typeIR_arg*)

49. (Let constraint be constraint')

50. (Let typeIR be typeIR'')

51. (Let typeIR' be typeIR_arg')

52. If ((typeIR has type externObjectTypeIR)), then

  1. (Let (extern tid ({ (rid : routineTypeDefIR_param)* })) be (typeIR as externObjectTypeIR))

  2. If ((typeIR' has type externObjectTypeIR)), then

    1. (Let (extern tid' ({ (rid' : routineTypeDefIR_arg)* })) be (typeIR' as externObjectTypeIR))

    2. If ((rid = rid'))*, then

      1. If ((tid = tid')), then

        1. Return $gen_constraint_routines(constraint, routineTypeDefIR_param*, routineTypeDefIR_arg*)

53. (Let constraint be constraint')

54. (Let typeIR be typeIR'')

55. (Let typeIR' be typeIR_arg')

56. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let (parser( parameterTypeIR_param* )) be (typeIR as parserObjectTypeIR))

  2. If ((typeIR' has type parserObjectTypeIR)), then

    1. (Let (parser( parameterTypeIR_arg* )) be (typeIR' as parserObjectTypeIR))

    2. (Let (direction typeIR_param _id _value?) be parameterTypeIR_param)*

    3. (Let (direction' typeIR_arg _id' _value'?) be parameterTypeIR_arg)*

    4. If ((direction' = direction))*, then

      1. Return $gen_constraint_types(constraint, typeIR_param*, typeIR_arg*)

57. (Let constraint be constraint')

58. (Let typeIR be typeIR'')

59. (Let typeIR' be typeIR_arg')

60. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let (control( parameterTypeIR_param* )) be (typeIR as controlObjectTypeIR))

  2. If ((typeIR' has type controlObjectTypeIR)), then

    1. (Let (control( parameterTypeIR_arg* )) be (typeIR' as controlObjectTypeIR))

    2. (Let (direction typeIR_param _id _value?) be parameterTypeIR_param)*

    3. (Let (direction' typeIR_arg _id' _value'?) be parameterTypeIR_arg)*

    4. If ((direction' = direction))*, then

      1. Return $gen_constraint_types(constraint, typeIR_param*, typeIR_arg*)

61. (Let constraint be constraint')

62. (Let typeIR be typeIR'')

63. (Let typeIR' be typeIR_arg')

64. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let (package< typeIR_param* >) be (typeIR as packageObjectTypeIR))

  2. If ((typeIR' has type packageObjectTypeIR)), then

    1. (Let (package< typeIR_arg* >) be (typeIR' as packageObjectTypeIR))

    2. Return $gen_constraint_types(constraint, typeIR_param*, typeIR_arg*)

65. (Let constraint be constraint')

66. (Let typeIR_param be typeIR'')

67. (Let typeIR_arg be typeIR_arg')

68. Otherwise

  1. Return constraint

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:24.1-24.69
def $gen_constraint_types(constraint, typeIR_param*, typeIR_arg*)

1. (Let constraint_pair be $gen_constraint_type(constraint, typeIR_param, typeIR_arg))*

2. Return $merge_constraints(constraint, constraint_pair*)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:25.1-28.15
def $gen_constraint_routine(constraint_0, routineTypeDefIR, routineTypeDefIR')

1. If ((routineTypeDefIR has type polyRoutineTypeDefIR)), then

  1. (Let (routineTypeIR < _tid* , _tid'* >) be (routineTypeDefIR as polyRoutineTypeDefIR))

  2. If ((routineTypeIR has type methodTypeIR)), then

    1. (Let methodTypeIR be (routineTypeIR as methodTypeIR))

    2. Case analysis on methodTypeIR

      1. Case (% matches pattern `EXTERN_METHOD(%)->%`)

        1. (Let (extern_method( parameterTypeIR_param* )-> typeIR_ret_param) be methodTypeIR)

        2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

          1. (Let (routineTypeIR' < _tid''* , _tid'''* >) be (routineTypeDefIR' as polyRoutineTypeDefIR))

          2. If ((routineTypeIR' has type methodTypeIR)), then

            1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

            2. If ((methodTypeIR' matches pattern `EXTERN_METHOD(%)->%`)), then

              1. (Let (extern_method( parameterTypeIR_arg* )-> typeIR_ret_arg) be methodTypeIR')

              2. (Let (direction typeIR_param _id _value?) be parameterTypeIR_param)*

              3. (Let (direction' typeIR_arg _id' _value'?) be parameterTypeIR_arg)*

              4. If ((direction' = direction))*, then

                1. (Let constraint_1 be $gen_constraint_types(constraint_0, typeIR_param*, typeIR_arg*))

                2. (Let constraint_2 be $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg))

                3. Return constraint_2

      2. Case (% matches pattern `EXTERN_METHODABSTRACT(%)->%`)

        1. (Let (extern_methodabstract( parameterTypeIR_param* )-> typeIR_ret_param) be methodTypeIR)

        2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

          1. (Let (routineTypeIR' < _tid''* , _tid'''* >) be (routineTypeDefIR' as polyRoutineTypeDefIR))

          2. If ((routineTypeIR' has type methodTypeIR)), then

            1. (Let methodTypeIR' be (routineTypeIR' as methodTypeIR))

            2. If ((methodTypeIR' matches pattern `EXTERN_METHODABSTRACT(%)->%`)), then

              1. (Let (extern_methodabstract( parameterTypeIR_arg* )-> typeIR_ret_arg) be methodTypeIR')

              2. (Let (direction typeIR_param _id _value?) be parameterTypeIR_param)*

              3. (Let (direction' typeIR_arg _id' _value'?) be parameterTypeIR_arg)*

              4. If ((direction' = direction))*, then

                1. (Let constraint_1 be $gen_constraint_types(constraint_0, typeIR_param*, typeIR_arg*))

                2. (Let constraint_2 be $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg))

                3. Return constraint_2

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:29.1-32.15
def $gen_constraint_routines(constraint, routineTypeDefIR_param*, routineTypeDefIR_arg*)

1. (Let constraint_pair be $gen_constraint_routine(constraint, routineTypeDefIR_param, routineTypeDefIR_arg))*

2. Return $merge_constraints(constraint, constraint_pair*)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:34.1-34.59
def $merge_constraint(constraint_pre, constraint_post)

1. (Let ({ tid_pre* }) be $dom_map<tid, infer>(constraint_pre))

2. (Let ({ tid_post* }) be $dom_map<tid, infer>(constraint_post))

3. If ($eq_set<tid>(({ tid_pre* }), ({ tid_post* }))), then

  1. Return $merge_constraint'(constraint_pre, constraint_post, tid_pre*, ({ [] }))

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:35.1-35.78
def $merge_constraint'(constraint_pre, constraint_post, tid*, constraint)

1. Case analysis on tid*

  1. Case (% matches pattern [])

    1. Return constraint

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t* be tid*)

    2. If ((?((unknown)) = $find_map<tid, infer>(constraint_pre, tid_h))), then

      1. If ((?((unknown)) = $find_map<tid, infer>(constraint_post, tid_h))), then

        1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (unknown)))

        2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

      2. (Let infer'? be $find_map<tid, infer>(constraint_post, tid_h))

      3. If ((infer'? matches pattern (_))), then

        1. (Let ?(infer) be infer'?)

        2. If ((infer matches pattern `KNOWNAS%`)), then

          1. (Let (knownas typeIR_post) be infer)

          2. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (knownas typeIR_post)))

          3. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

    3. (Let infer'? be $find_map<tid, infer>(constraint_pre, tid_h))

    4. If ((infer'? matches pattern (_))), then

      1. (Let ?(infer) be infer'?)

      2. If ((infer matches pattern `KNOWNAS%`)), then

        1. (Let (knownas typeIR_pre) be infer)

        2. If ((?((unknown)) = $find_map<tid, infer>(constraint_post, tid_h))), then

          1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (knownas typeIR_pre)))

          2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

    5. (Let infer'? be $find_map<tid, infer>(constraint_pre, tid_h))

    6. If ((infer'? matches pattern (_))), then

      1. (Let ?(infer) be infer'?)

      2. If ((infer matches pattern `KNOWNAS%`)), then

        1. (Let (knownas typeIR_pre) be infer)

        2. (Let infer'''? be $find_map<tid, infer>(constraint_post, tid_h))

        3. If ((infer'''? matches pattern (_))), then

          1. (Let ?(infer'') be infer'''?)

          2. If ((infer'' matches pattern `KNOWNAS%`)), then

            1. (Let (knownas typeIR_post) be infer'')

            2. If ((Sub_impl: typeIR_pre <: typeIR_post holds)), then

              1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (knownas typeIR_post)))

              2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

    7. (Let infer'? be $find_map<tid, infer>(constraint_pre, tid_h))

    8. If ((infer'? matches pattern (_))), then

      1. (Let ?(infer) be infer'?)

      2. If ((infer matches pattern `KNOWNAS%`)), then

        1. (Let (knownas typeIR_pre) be infer)

        2. (Let infer'''? be $find_map<tid, infer>(constraint_post, tid_h))

        3. If ((infer'''? matches pattern (_))), then

          1. (Let ?(infer'') be infer'''?)

          2. If ((infer'' matches pattern `KNOWNAS%`)), then

            1. (Let (knownas typeIR_post) be infer'')

            2. If (~(Sub_impl: typeIR_pre <: typeIR_post holds)), then

              1. If ((Sub_impl: typeIR_post <: typeIR_pre holds)), then

                1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (knownas typeIR_pre)))

                2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*, constraint_updated)

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:36.1-36.61
def $merge_constraints(constraint_pre', constraint*)

1. (Let constraint_pre be constraint_pre')

2. If ((constraint* matches pattern [])), then

  1. Return constraint_pre

3. (Let constraint_pre_0 be constraint_pre')

4. If ((constraint* matches pattern _ :: _)), then

  1. (Let constraint_post_h :: constraint_post_t* be constraint*)

  2. (Let constraint_pre_1 be $merge_constraint(constraint_pre_0, constraint_post_h))

  3. (Let constraint_pre_2 be $merge_constraints(constraint_pre_1, constraint_post_t*))

  4. Return constraint_pre_2

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:38.1-38.48
def $resolve_constraint(({ (tid : infer)* }))

1. (Let infer' be infer)*

2. If ((infer' matches pattern `KNOWNAS%`))*, then

  1. (Let (knownas typeIR) be infer')*

  2. Return ({ (tid : typeIR)* })

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:21.1-21.65
def $instantiable_extern(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return true

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:27.1-27.65
def $instantiable_parser(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return (instctxt = (anon))

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_parser_blockKind(TC.block.kind)

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_parser_state_localKind(TC.local.kind)

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:36.1-36.66
def $instantiable_control(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return (instctxt = (anon))

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_control_blockKind(TC.block.kind)

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_control_apply_method_localKind(TC.local.kind)

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:45.1-45.66
def $instantiable_package(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_package_blockKind(TC.block.kind)

  3. Case (% matches pattern `LOCAL`)

    1. Return false

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:52.1-52.64
def $instantiable_table(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_control_blockKind(TC.block.kind)

  3. Case (% matches pattern `LOCAL`)

    1. Return false

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:59.1-59.66
def $instantiable(p, TC, instctxt, typeIR)

1. If ($is_extern_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_extern(p, TC, instctxt)

2. If ($is_parser_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_parser(p, TC, instctxt)

3. If ($is_control_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_control(p, TC, instctxt)

4. If ($is_package_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_package(p, TC, instctxt)

5. If ($is_table_object_typeIR($canon(typeIR))), then

  1. Return $instantiable_table(p, TC, instctxt)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:55.1-55.33
def $lvalue(lvalue'')

1. (Let lvalue be lvalue'')

2. If ((lvalue has type referenceExpression)), then

  1. (Let referenceExpression be (lvalue as referenceExpression))

  2. Return (referenceExpression as expression)

3. (Let lvalue be lvalue'')

4. If ((lvalue matches pattern `%.%`)), then

  1. (Let (lvalue_base . member) be lvalue)

  2. (Let expression_base be $lvalue(lvalue_base))

  3. Return (((expression_base as memberAccessBase) . member) as expression)

5. (Let lvalue be lvalue'')

6. If ((lvalue matches pattern `%[%]`)), then

  1. (Let (lvalue_base [ expression_index ]) be lvalue)

  2. (Let expression_base be $lvalue(lvalue_base))

  3. Return ((expression_base [ expression_index ]) as expression)

7. (Let lvalue be lvalue'')

8. If ((lvalue matches pattern `%[%:%]`)), then

  1. (Let (lvalue_base [ expression_hi : expression_lo ]) be lvalue)

  2. (Let expression_base be $lvalue(lvalue_base))

  3. Return ((expression_base [ expression_hi : expression_lo ]) as expression)

9. (Let lvalue' be lvalue'')

10. If ((lvalue' matches pattern `(%)`)), then

  1. (Let (( lvalue )) be lvalue')

  2. (Let expression be $lvalue(lvalue))

  3. Return ((( expression )) as expression)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:239.1-239.61
def $callable_builtin_function(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return true

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:266.1-266.53
def $callable_function(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))

  3. Case (% matches pattern `LOCAL`)

    1. Return (~$is_extern_method_localKind(TC.local.kind) /\ ~$is_extern_abstract_method_localKind(TC.local.kind))

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:310.1-310.60
def $callable_extern_function(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:352.1-352.51
def $callable_action(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return ($is_action_localKind(TC.local.kind) \/ $is_control_apply_method_localKind(TC.local.kind))

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:383.1-383.59
def $callable_builtin_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return true

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:410.1-410.58
def $callable_extern_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:452.1-452.67
def $callable_extern_abstract_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.block.kind) \/ $is_control_blockKind(TC.block.kind))

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:494.1-494.64
def $callable_parser_apply_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_parser_state_localKind(TC.local.kind)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:522.1-522.65
def $callable_control_apply_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_control_apply_method_localKind(TC.local.kind)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:550.1-550.63
def $callable_table_apply_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return ($is_control_apply_method_localKind(TC.local.kind) \/ $is_table_apply_method_localKind(TC.local.kind))

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:5.1-5.27
def $empty_theta

1. Return $empty_map<tid, typeIR>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:8.15-8.29
syntax venv = map<id, value>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:10.1-10.25
def $empty_venv

1. Return $empty_map<id, value>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:13.19-13.41
syntax stateDyn = parserBlockStatementIR

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:15.15-15.34
syntax senv = map<name, stateDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:17.1-17.25
def $empty_senv

1. Return $empty_map<name, stateDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:25.1-28.34
syntax lvalueDyn = 
   | ` nameIR
   | . nameIR
   | lvalueDyn . nameIR
   | lvalueDyn [ value ]
   | lvalueDyn [ value : value ]

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:37.1-40.96
syntax funcDyn = 
   | builtin_function< typeParameterListIR >( parameterListIR ){ blockElementStatementListIR }
   | function< typeParameterListIR >( parameterListIR ) blockStatementIR
   | action( parameterListIR ){ blockStatementIR }
   | extern_function< typeParameterListIR >( parameterListIR ){ blockElementStatementIR? }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:43.1-48.41
syntax methodDyn = 
   | builtin_method( parameterListIR )# lvalueDyn
   | extern_method< typeParameterListIR >( parameterListIR )
   | extern_methodabstract< typeParameterListIR >( parameterListIR )
   | parser_apply( parameterListIR ){ parserLocalDeclarationListIR ; senv }
   | control_apply( parameterListIR ){ controlLocalDeclarationListIR ; renv ; blockElementStatementListIR }
   | table_apply{ tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:51.1-52.14
syntax routineDyn = 
   | builtin_function< typeParameterListIR >( parameterListIR ){ blockElementStatementListIR }
   | function< typeParameterListIR >( parameterListIR ) blockStatementIR
   | action( parameterListIR ){ blockStatementIR }
   | extern_function< typeParameterListIR >( parameterListIR ){ blockElementStatementIR? }
   | builtin_method( parameterListIR )# lvalueDyn
   | extern_method< typeParameterListIR >( parameterListIR )
   | extern_methodabstract< typeParameterListIR >( parameterListIR )
   | parser_apply( parameterListIR ){ parserLocalDeclarationListIR ; senv }
   | control_apply( parameterListIR ){ controlLocalDeclarationListIR ; renv ; blockElementStatementListIR }
   | table_apply{ tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:55.15-55.35
syntax renv = map<rid, routineDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:57.1-57.25
def $empty_renv

1. Return $empty_map<rid, routineDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:65.1-69.42
syntax consDyn = 
   | extern nameIR < typeParameterListIR >( constructorParameterListIR ){ methodPrototypeListIR }
   | parser< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }
   | control< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }
   | package< typeParameterListIR >( constructorParameterListIR )
   | table nameIR { tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:72.15-72.32
syntax cenv = map<cid, consDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:74.1-74.25
def $empty_cenv

1. Return $empty_map<cid, consDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:82.1-86.44
syntax objDyn = 
   | extern{ tid theta venv renv }
   | parser{ venv parameterListIR parserLocalDeclarationListIR senv }
   | control{ venv parameterListIR controlLocalDeclarationListIR renv controlBodyIR }
   | package{ theta venv }
   | table{ tid venv tablePropertyListIR }

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:89.14-89.30
syntax sto = map<oid, objDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:91.1-91.23
def $empty_sto

1. Return $empty_map<oid, objDyn>

;; ../../../../spec-concrete/6.01-env-dynamic.watsup:95.1-95.37
def $add_sto(sto, oid, objDyn)

1. Return $add_map<oid, objDyn>(sto, oid, objDyn)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:8.3-11.16
syntax glayerInst = {cenv cenv, tdenv tdenv, renv renv, venv venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:16.3-19.16
syntax blayerInst = {theta theta, renv renv, senv senv, venv venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:24.3-25.18
syntax llayerInst = {theta theta, venvs venv*}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:32.3-35.23
syntax contextInst = {path oid, global glayerInst, block blayerInst, local llayerInst}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:43.1-43.32
def $empty_block

1. Return {theta $empty_theta, renv $empty_renv, senv $empty_senv, venv $empty_venv}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:51.1-51.32
def $empty_local

1. Return {theta $empty_theta, venvs []}

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:57.1-57.40
def $empty_context_inst

1. (Let glayerInst be {cenv $empty_cenv, tdenv $empty_tdenv, renv $empty_renv, venv $empty_venv})

2. (Let blayerInst be $empty_block)

3. (Let llayerInst be $empty_local)

4. (Let Ci be {path [], global glayerInst, block blayerInst, local llayerInst})

5. Return Ci

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:74.1-74.43
def $enter_inst(Ci)

1. Return Ci[local.venvs = $empty_venv :: Ci.local.venvs]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:78.1-78.42
def $exit_inst(Ci)

1. (Let venv* be Ci.local.venvs)

2. If ((venv* matches pattern _ :: _)), then

  1. (Let venv_h :: venv_t* be venv*)

  2. Return Ci[local.venvs = venv_t*]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:87.1-87.47
def $enter_path(Ci, id)

1. Return Ci[path = Ci.path ++ [id]]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:95.1-95.58
def $copy_context_inst(cursor, Ci)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return Ci[block = $empty_block][local = $empty_local]

  2. Case (% matches pattern `BLOCK`)

    1. Return Ci[local = $empty_local]

  3. Case (% matches pattern `LOCAL`)

    1. Return Ci

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:107.1-107.65
def $add_value_inst(cursor, Ci, id, value)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let venv be $add_map<id, value>(Ci.global.venv, id, value))

    2. Return Ci[global.venv = venv]

  2. Case (% matches pattern `BLOCK`)

    1. (Let venv be $add_map<id, value>(Ci.block.venv, id, value))

    2. Return Ci[block.venv = venv]

  3. Case (% matches pattern `LOCAL`)

    1. (Let venv* be Ci.local.venvs)

    2. If ((venv* matches pattern _ :: _)), then

      1. (Let venv_h :: venv_t* be venv*)

      2. (Let venv_h' be $add_map<id, value>(venv_h, id, value))

      3. Return Ci[local.venvs = venv_h :: venv_t*]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:108.1-108.68
def $add_values_inst(p, Ci, id*, value*)

1. Case analysis on id*

  1. Case (% matches pattern [])

    1. If ((value* matches pattern [])), then

      1. Return Ci

  2. Case (% matches pattern _ :: _)

    1. (Let id_h :: id_t* be id*)

    2. If ((value* matches pattern _ :: _)), then

      1. (Let value_h :: value_t* be value*)

      2. (Let Ci' be $add_value_inst(p, Ci, id_h, value_h))

      3. (Let Ci'' be $add_values_inst(p, Ci', id_t*, value_t*))

      4. Return Ci''

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:125.1-125.83
def $add_routine_overload_inst



;; ../../../../spec-concrete/6.02-context-instantiation.watsup:127.1-127.87
def $add_routine_non_overload_inst(cursor, Ci, rid, routineDyn)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. If (~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.global.renv))), then

      1. (Let renv be $add_map<rid, routineDyn>(Ci.global.renv, rid, routineDyn))

      2. Return Ci[global.renv = renv]

  2. Case (% matches pattern `BLOCK`)

    1. If (~$in_set<rid>(rid, $dom_map<rid, routineDyn>(Ci.block.renv))), then

      1. (Let renv be $add_map<rid, routineDyn>(Ci.block.renv, rid, routineDyn))

      2. Return Ci[block.renv = renv]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:137.1-137.84
def $add_tparams_inst(p, Ci, typeParameterIR*, typeIR*)

1. Case analysis on typeParameterIR*

  1. Case (% matches pattern [])

    1. If ((typeIR* matches pattern [])), then

      1. Return Ci

  2. Case (% matches pattern _ :: _)

    1. (Let typeParameterIR_h :: typeParameterIR_t* be typeParameterIR*)

    2. If ((typeIR* matches pattern _ :: _)), then

      1. (Let typeIR_h :: typeIR_t* be typeIR*)

      2. (Let Ci' be $add_tparam_inst(p, Ci, typeParameterIR_h, typeIR_h))

      3. Return $add_tparams_inst(p, Ci', typeParameterIR_t*, typeIR_t*)

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:138.1-138.81
def $add_tparam_inst(cursor, Ci, typeParameterIR, typeIR)

1. Case analysis on cursor

  1. Case (% matches pattern `BLOCK`)

    1. (Let theta be $add_map<tid, typeIR>(Ci.block.theta, typeParameterIR, typeIR))

    2. Return Ci[block.theta = theta]

  2. Case (% matches pattern `LOCAL`)

    1. (Let theta be $add_map<tid, typeIR>(Ci.local.theta, typeParameterIR, typeIR))

    2. Return Ci[local.theta = theta]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:152.1-152.75
def $add_constructor_inst(cursor, Ci, cid, consDyn)

1. If ((cursor matches pattern `GLOBAL`)), then

  1. (Let cenv be $add_map<cid, consDyn>(Ci.global.cenv, cid, consDyn))

  2. Return Ci[global.cenv = cenv]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:158.1-158.73
def $add_typedef_inst(cursor, Ci, tid, typeDefIR)

1. If ((cursor matches pattern `GLOBAL`)), then

  1. (Let tdenv be $add_map<tid, typeDefIR>(Ci.global.tdenv, tid, typeDefIR))

  2. Return Ci[global.tdenv = tdenv]

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:169.1-169.59
def $find_value_inst



;; ../../../../spec-concrete/6.02-context-instantiation.watsup:172.1-172.66
def $find_type_inst



;; ../../../../spec-concrete/6.02-context-instantiation.watsup:176.1-176.65
def $find_typedef_inst



;; ../../../../spec-concrete/6.02-context-instantiation.watsup:180.1-180.44
def $ids_arguments_IR(argumentIR*)

1. Return $id_argument_IR(argumentIR)*

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:181.1-181.38
def $id_argument_IR(argumentIR)

1. If ((argumentIR has type typedExpressionIR)), then

  1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

  2. Return ?()

2. Case analysis on argumentIR

  1. Case (% matches pattern `%=%`)

    1. (Let (nameIR = _typedExpressionIR) be argumentIR)

    2. Return ?(nameIR)

  2. Case (% matches pattern `%=_`)

    1. (Let (nameIR =_) be argumentIR)

    2. Return ?(nameIR)

  3. Case (% matches pattern `_`)

    1. Return ?()

;; ../../../../spec-concrete/6.02-context-instantiation.watsup:189.1-189.103
def $find_constructor_overloaded_inst(Ci, prefixedNameIR, argumentIR*)

1. Case analysis on prefixedNameIR

  1. Case (% matches pattern ``%`)

    1. (Let (` id) be prefixedNameIR)

    2. (Let id_arg?* be $ids_arguments_IR(argumentIR*))

    3. Return $find_overloaded<consDyn>(Ci.global.cenv, id, id_arg?*)

  2. Case (% matches pattern `.%`)

    1. (Let (. id) be prefixedNameIR)

    2. (Let id_arg?* be $ids_arguments_IR(argumentIR*))

    3. Return $find_overloaded<consDyn>(Ci.global.cenv, id, id_arg?*)

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:3.1-5.17
relation Program_inst

  (match) (declarationIR* ;)

    1. Try matching path 

  (path)  (declarationIR* ;)

    1. (Let Ci_0 be $empty_context_inst)

    2. (Let sto_0 be $empty_sto)

    3. (Decls_inst: (global) Ci_0 sto_0 |- declarationIR* ==> Ci_1 sto_1 declarationIR'*)

    4. If ((declarationIR'* matches pattern [])), then

      1. Result in Ci_1.global.cenv, Ci_1.global.tdenv, Ci_1.global.renv, Ci_1.global.venv, sto_1

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:7.1-9.35
relation Constructor_inst

  (match) p | Ci | sto'''' | consDyn | typeArgumentIR* | argumentIR* | id_default*

    1. (Let sto be sto'''')

    2. If ((consDyn matches pattern `EXTERN%<%>(%){%}`)), then

      1. (Let (extern nameIR < typeParameterIR* >( constructorParameterIR* ){ methodPrototypeIR* }) be consDyn)

      2. Try matching path extern

    3. (Let sto be sto'''')

    4. If ((consDyn matches pattern `PARSER<%>(%)(%){%%}`)), then

      1. (Let (parser< typeParameterIR* >( parameterIR* )( constructorParameterIR* ){ parserLocalDeclarationIR* parserStateIR* }) be consDyn)

      2. Try matching path parser

    5. (Let sto be sto'''')

    6. If ((consDyn matches pattern `CONTROL<%>(%)(%){%APPLY%}`)), then

      1. (Let (control< typeParameterIR* >( parameterIR* )( constructorParameterIR* ){ controlLocalDeclarationIR* apply controlBodyIR }) be consDyn)

      2. Try matching path control

    7. (Let sto_0 be sto'''')

    8. If ((consDyn matches pattern `PACKAGE<%>(%)`)), then

      1. (Let (package< typeParameterIR* >( constructorParameterIR* )) be consDyn)

      2. Try matching path package

    9. (Let sto be sto'''')

    10. If ((consDyn matches pattern `TABLE%{%}`)), then

      1. (Let (table nameIR { tablePropertyListIR }) be consDyn)

      2. Try matching path table

  (path) extern p | Ci | sto | (extern nameIR < typeParameterIR* >( constructorParameterIR* ){ methodPrototypeIR* }) | typeArgumentIR* | argumentIR* | id_default*

    1. (Let p_callee be (block))

    2. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

    3. (Let Ci_callee_1 be $add_tparams_inst((global), Ci_callee_0, typeParameterIR*, typeArgumentIR*))

    4. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*))

    5. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

    6. (Eval_args: p p_callee Ci_callee_1 sto |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto')

    7. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

    8. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

    9. (Methods_inst: (block) Ci_callee_3 |- methodPrototypeIR* ==> Ci_callee_4)

    10. Result in sto', (extern{ nameIR Ci_callee_4.block.theta Ci_callee_4.block.venv Ci_callee_4.block.renv })

  (path) parser p | Ci | sto | (parser< typeParameterIR* >( parameterIR* )( constructorParameterIR* ){ parserLocalDeclarationIR* parserStateIR* }) | typeArgumentIR* | argumentIR* | id_default*

    1. (Let p_callee be (block))

    2. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

    3. (Let Ci_callee_1 be $add_tparams_inst((global), Ci_callee_0, typeParameterIR*, typeArgumentIR*))

    4. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*))

    5. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

    6. (Eval_args: p p_callee Ci_callee_1 sto |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto')

    7. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

    8. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

    9. (ParserLocalDecls_inst: (block) Ci_callee_3 sto' |- parserLocalDeclarationIR* ==> Ci_local sto'' parserLocalDeclarationIR'*)

    10. (ParserStates_inst: Ci_local sto'' |- parserStateIR* ==> Ci_state sto''')

    11. Result in sto''', (parser{ Ci_callee_3.block.venv parameterIR* parserLocalDeclarationIR'* Ci_state.block.senv })

  (path) control p | Ci | sto | (control< typeParameterIR* >( parameterIR* )( constructorParameterIR* ){ controlLocalDeclarationIR* apply controlBodyIR }) | typeArgumentIR* | argumentIR* | id_default*

    1. (Let p_callee be (block))

    2. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

    3. (Let Ci_callee_1 be $add_tparams_inst((global), Ci_callee_0, typeParameterIR*, typeArgumentIR*))

    4. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*))

    5. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

    6. (Eval_args: p p_callee Ci_callee_1 sto |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto')

    7. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

    8. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

    9. (ControlLocalDecls_inst: Ci_callee_3 sto' |- controlLocalDeclarationIR* ==> Ci_local sto'' controlLocalDeclarationIR'*)

    10. (Block_inst: Ci_local sto'' true |- controlBodyIR ==> _contextInst sto''' controlBodyIR')

    11. Result in sto''', (control{ Ci_callee_3.block.venv parameterIR* controlLocalDeclarationIR'* Ci_local.block.renv controlBodyIR' })

  (path) package p | Ci | sto_0 | (package< typeParameterIR* >( constructorParameterIR* )) | typeArgumentIR* | argumentIR* | id_default*

    1. (Let p_callee be (block))

    2. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

    3. (Let Ci_callee_1 be $add_tparams_inst((global), Ci_callee_0, typeParameterIR*, typeArgumentIR*))

    4. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*))

    5. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

    6. (Eval_args: p p_callee Ci_callee_1 sto_0 |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto_1)

    7. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

    8. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

    9. Result in sto_1, (package{ Ci_callee_3.block.theta Ci_callee_3.block.venv })

  (path) table p | Ci | sto | (table nameIR { tablePropertyListIR }) | typeArgumentIR* | argumentIR* | id_default*

    1. (Let p_callee be (local))

    2. (Let Ci_callee_0 be $copy_context_inst((global), Ci))

    3. (Let Ci_callee_1 be $add_tparams_inst((global), Ci_callee_0, [], typeArgumentIR*))

    4. (Let (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*) be $align_cparams_with_args([], argumentIR*, id_default*))

    5. (Let (_annotationList _direction _typeIR id_aligned _constantInitializerOptIR) be constructorParameterIR_aligned)*

    6. (Eval_args: p p_callee Ci_callee_1 sto |- id_aligned* argumentIR_aligned* ==> Ci_callee_2 sto')

    7. (Let (_annotationList' _direction' _typeIR' id_cparam_default _constantInitializerOptIR') be constructorParameterIR_default)*

    8. (Let Ci_callee_3 be $add_values_inst(p_callee, Ci_callee_2, id_cparam_default*, value_default*))

    9. (Let Ci_frame be $enter_inst(Ci_callee_3))

    10. (TableProperties_inst: Ci_frame sto' |- tablePropertyListIR ==> Ci_table sto'' tablePropertyListIR_inst)

    11. (Let venv'* be Ci_table.local.venvs)

    12. If ((venv'* matches pattern _ :: _)), then

      1. (Let venv :: _venv* be venv'*)

      2. Result in sto', (table{ nameIR venv tablePropertyListIR_inst })

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:19.1-21.26
relation Exprs_inst

  (match) 





;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:23.1-25.26
relation Expr_inst

  (match) p | Ci | sto | (expressionIR # _expressionNoteIR)

    1. If ((expressionIR = ((true) as expressionIR))), then

      1. Try matching path literalExpressionIR-true

    2. If ((expressionIR = ((false) as expressionIR))), then

      1. Try matching path literalExpressionIR-false

    3. Case analysis on expressionIR

      1. Case (% has type numberLiteral)

        1. (Let numberLiteral be (expressionIR as numberLiteral))

        2. Case analysis on numberLiteral

          1. Case (% matches pattern `D%`)

            1. (Let (d i) be numberLiteral)

            2. Try matching path literalExpressionIR-number-arbint

          2. Case (% matches pattern `%S%`)

            1. (Let (n s i) be numberLiteral)

            2. Try matching path literalExpressionIR-number-fixint

          3. Case (% matches pattern `%W%`)

            1. (Let (n w i) be numberLiteral)

            2. Try matching path literalExpressionIR-number-fixbit

      2. Case (% has type stringLiteral)

        1. (Let (" text ") be (expressionIR as stringLiteral))

        2. Try matching path literalExpressionIR-stringLiteral

      3. Case (% has type prefixedNameIR)

        1. (Let prefixedNameIR be (expressionIR as prefixedNameIR))

        2. Case analysis on prefixedNameIR

          1. Case (% matches pattern ``%`)

            1. (Let (` nameIR) be prefixedNameIR)

            2. Try matching path referenceExpressionIR-id

          2. Case (% matches pattern `.%`)

            1. (Let (. nameIR) be prefixedNameIR)

            2. Try matching path referenceExpressionIR-dotName

      4. Case (% has type unaryExpressionIR)

        1. (Let (unop typedExpressionIR) be (expressionIR as unaryExpressionIR))

        2. Case analysis on unop

          1. Case (% matches pattern `!`)

            1. Try matching path unaryExpressionIR-lnot

          2. Case (% matches pattern `~`)

            1. Try matching path unaryExpressionIR-bnot

          3. Case (% matches pattern `+`)

            1. Try matching path unaryExpressionIR-plus

          4. Case (% matches pattern `-`)

            1. Try matching path unaryExpressionIR-minus

      5. Case (% has type binaryExpressionIR)

        1. (Let (typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

        2. Case analysis on binop

          1. Case (% matches pattern `*`)

            1. Try matching path binaryExpressionIR-mul

          2. Case (% matches pattern `/`)

            1. Try matching path binaryExpressionIR-div

          3. Case (% matches pattern `%`)

            1. Try matching path binaryExpressionIR-mod

          4. Case (% matches pattern `+`)

            1. Try matching path binaryExpressionIR-plus

          5. Case (% matches pattern `-`)

            1. Try matching path binaryExpressionIR-minus

          6. Case (% matches pattern `|+|`)

            1. Try matching path binaryExpressionIR-satplus

          7. Case (% matches pattern `|-|`)

            1. Try matching path binaryExpressionIR-satminus

          8. Case (% matches pattern `<<`)

            1. Try matching path binaryExpressionIR-shl

          9. Case (% matches pattern `>>`)

            1. Try matching path binaryExpressionIR-shr

          10. Case (% matches pattern `<=`)

            1. Try matching path binaryExpressionIR-le

          11. Case (% matches pattern `>=`)

            1. Try matching path binaryExpressionIR-ge

          12. Case (% matches pattern `<`)

            1. Try matching path binaryExpressionIR-lt

          13. Case (% matches pattern `>`)

            1. Try matching path binaryExpressionIR-gt

          14. Case (% matches pattern `!=`)

            1. Try matching path binaryExpressionIR-ne

          15. Case (% matches pattern `==`)

            1. Try matching path binaryExpressionIR-eq

          16. Case (% matches pattern `&`)

            1. Try matching path binaryExpressionIR-band

          17. Case (% matches pattern `^`)

            1. Try matching path binaryExpressionIR-bxor

          18. Case (% matches pattern `|`)

            1. Try matching path binaryExpressionIR-bor

          19. Case (% matches pattern `++`)

            1. Try matching path binaryExpressionIR-concat

          20. Case (% matches pattern `&&`)

            1. Try matching path binaryExpressionIR-land

          21. Case (% matches pattern `||`)

            1. Try matching path binaryExpressionIR-lor

      6. Case (% has type ternaryExpressionIR)

        1. (Let (typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e) be (expressionIR as ternaryExpressionIR))

        2. Try matching path ternaryExpressionIR-then

        3. Try matching path ternaryExpressionIR-else

      7. Case (% has type castExpressionIR)

        1. (Let (( typeIR ) typedExpressionIR) be (expressionIR as castExpressionIR))

        2. Try matching path castExpressionIR

      8. Case (% has type dataExpressionIR)

        1. (Let dataExpressionIR be (expressionIR as dataExpressionIR))

        2. Case analysis on dataExpressionIR

          1. Case (% matches pattern `SEQ{%}`)

            1. (Let (seq{ typedExpressionListIR }) be dataExpressionIR)

            2. Try matching path dataExpressionIR-sequence

          2. Case (% matches pattern `SEQ{%,...}`)

            1. (Let (seq{ typedExpressionListIR ,...}) be dataExpressionIR)

            2. Try matching path dataExpressionIR-sequencedefault

          3. Case (% matches pattern `RECORD{%}`)

            1. (Let (record{ (nameIR = typedExpressionIR)* }) be dataExpressionIR)

            2. Try matching path dataExpressionIR-record

          4. Case (% matches pattern `RECORD{%,...}`)

            1. (Let (record{ (nameIR = typedExpressionIR)* ,...}) be dataExpressionIR)

            2. Try matching path dataExpressionIR-recorddefault

      9. Case (% has type errorAccessExpressionIR)

        1. (Let (error. nameIR) be (expressionIR as errorAccessExpressionIR))

        2. Try matching path accessExpressionIR-errorAccessExpressionIR

      10. Case (% has type memberAccessExpressionIR)

        1. (Let (memberAccessBaseIR . nameIR) be (expressionIR as memberAccessExpressionIR))

        2. If ((memberAccessBaseIR matches pattern `TYPE%`)), then

          1. (Let (type prefixedNameIR) be memberAccessBaseIR)

          2. Try matching path accessExpressionIR-memberAccessExpressionIR-typeaccess-enum

          3. Try matching path accessExpressionIR-memberAccessExpressionIR-senum

        3. (Let (memberAccessBaseIR . text) be (expressionIR as memberAccessExpressionIR))

        4. If ((memberAccessBaseIR has type typedExpressionIR)), then

          1. (Let typedExpressionIR be (memberAccessBaseIR as typedExpressionIR))

          2. If ((text = "size")), then

            1. Try matching path accessExpressionIR-memberAccessExpressionIR-typedExpressionIR

      11. Case (% has type indexAccessExpressionIR)

        1. (Let indexAccessExpressionIR be (expressionIR as indexAccessExpressionIR))

        2. If ((indexAccessExpressionIR matches pattern `%[%:%]`)), then

          1. (Let (typedExpressionIR_b [ typedExpressionIR_l : typedExpressionIR_h ]) be indexAccessExpressionIR)

          2. Try matching path indexAccessExpressionIR-bitslice

      12. Case (% has type callExpressionIR)

        1. (Let callExpressionIR be (expressionIR as callExpressionIR))

        2. Case analysis on callExpressionIR

          1. Case (% matches pattern `%(%)`)

            1. (Let ((prefixedNameIR < typeArgumentListIR >) ( argumentListIR )) be callExpressionIR)

            2. Try matching path callExpressionIR-instantiation

          2. Case (% matches pattern `%<%>(%)`)

            1. (Let (routineTargetIR < typeArgumentIR* >( argumentIR* )) be callExpressionIR)

            2. Case analysis on routineTargetIR

              1. Case (% matches pattern `%.%`)

                1. (Let (typedExpressionIR . nameIR) be routineTargetIR)

                2. If ((typeArgumentIR* matches pattern [])), then

                  1. If ((argumentIR* matches pattern [])), then

                    1. Try matching path callExpressionIR-methodTarget-generic

              2. Case (% matches pattern `TYPE%.%`)

                1. (Let (type prefixedNameIR . nameIR) be routineTargetIR)

                2. If ((typeArgumentIR* matches pattern [])), then

                  1. If ((argumentIR* matches pattern [])), then

                    1. Try matching path callExpressionIR-methodTarget-non-generic

      13. Case (% has type parenthesizedExpressionIR)

        1. (Let (( typedExpressionIR )) be (expressionIR as parenthesizedExpressionIR))

        2. Try matching path parenthesizedExpressionIR

    4. If ((expressionIR = ((...) as expressionIR))), then

      1. Try matching path defaultExpressionIR

    5. If ((expressionIR = (({#}) as expressionIR))), then

      1. Try matching path dataExpressionIR-invalid

  (path) literalExpressionIR-true p | Ci | sto | (((true) as expressionIR) # _expressionNoteIR)

    1. Result in sto, ((b true) as value)

  (path) literalExpressionIR-false p | Ci | sto | (((false) as expressionIR) # _expressionNoteIR)

    1. Result in sto, ((b false) as value)

  (path) literalExpressionIR-number-arbint p | Ci | sto | (((d i) as expressionIR) # _expressionNoteIR)

    1. Result in sto, ((d i) as value)

  (path) literalExpressionIR-number-fixint p | Ci | sto | (((n s i) as expressionIR) # _expressionNoteIR)

    1. Result in sto, ((n s i) as value)

  (path) literalExpressionIR-number-fixbit p | Ci | sto | (((n w i) as expressionIR) # _expressionNoteIR)

    1. Result in sto, ((n w i) as value)

  (path) literalExpressionIR-stringLiteral p | Ci | sto | (((" text ") as expressionIR) # _expressionNoteIR)

    1. Result in sto, ((" text ") as value)

  (path) referenceExpressionIR-id p | Ci | sto | (((` nameIR) as expressionIR) # _expressionNoteIR)

    1. (Let value'? be $find_value_inst(p, Ci, nameIR))

    2. If ((value'? matches pattern (_))), then

      1. (Let ?(value) be value'?)

      2. Result in sto, value

  (path) referenceExpressionIR-dotName p | Ci | sto | (((. nameIR) as expressionIR) # _expressionNoteIR)

    1. (Let value'? be $find_value_inst(p, Ci, nameIR))

    2. If ((value'? matches pattern (_))), then

      1. (Let ?(value) be value'?)

      2. Result in sto, value

  (path) defaultExpressionIR p | Ci | sto | (((...) as expressionIR) # _expressionNoteIR)

    1. Result in sto, ((default) as value)

  (path) unaryExpressionIR-lnot p | Ci | sto | ((((!) typedExpressionIR) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

    2. If (($un_lnot(value) = value)), then

      1. Result in sto', value

  (path) unaryExpressionIR-bnot p | Ci | sto | ((((~) typedExpressionIR) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

    2. If (($un_bnot(value) = value)), then

      1. Result in sto', value

  (path) unaryExpressionIR-plus p | Ci | sto | ((((+) typedExpressionIR) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

    2. Result in sto', value

  (path) unaryExpressionIR-minus p | Ci | sto | ((((-) typedExpressionIR) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

    2. If (($un_minus(value) = value)), then

      1. Result in sto', value

  (path) binaryExpressionIR-mul p | Ci | sto | (((typedExpressionIR_l (*) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_mul(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-div p | Ci | sto | (((typedExpressionIR_l (/) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_div(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-mod p | Ci | sto | (((typedExpressionIR_l (%) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_mod(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-plus p | Ci | sto | (((typedExpressionIR_l (+) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_plus(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-minus p | Ci | sto | (((typedExpressionIR_l (-) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_minus(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-satplus p | Ci | sto | (((typedExpressionIR_l (|+|) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_satplus(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-satminus p | Ci | sto | (((typedExpressionIR_l (|-|) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_satminus(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-shl p | Ci | sto | (((typedExpressionIR_l (<<) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_shl(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-shr p | Ci | sto | (((typedExpressionIR_l (>>) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_shr(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-le p | Ci | sto | (((typedExpressionIR_l (<=) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let bool be $bin_le(value_l, value_r))

    4. Result in sto'', ((b bool) as value)

  (path) binaryExpressionIR-ge p | Ci | sto | (((typedExpressionIR_l (>=) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let bool be $bin_ge(value_l, value_r))

    4. Result in sto'', ((b bool) as value)

  (path) binaryExpressionIR-lt p | Ci | sto | (((typedExpressionIR_l (<) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let bool be $bin_lt(value_l, value_r))

    4. Result in sto'', ((b bool) as value)

  (path) binaryExpressionIR-gt p | Ci | sto | (((typedExpressionIR_l (>) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let bool be $bin_gt(value_l, value_r))

    4. Result in sto'', ((b bool) as value)

  (path) binaryExpressionIR-ne p | Ci | sto | (((typedExpressionIR_l (!=) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let bool be $bin_ne(value_l, value_r))

    4. Result in sto'', ((b bool) as value)

  (path) binaryExpressionIR-eq p | Ci | sto | (((typedExpressionIR_l (==) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let bool be $bin_eq(value_l, value_r))

    4. Result in sto'', ((b bool) as value)

  (path) binaryExpressionIR-band p | Ci | sto | (((typedExpressionIR_l (&) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_band(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-bxor p | Ci | sto | (((typedExpressionIR_l (^) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_bxor(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-bor p | Ci | sto | (((typedExpressionIR_l (|) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_bor(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-concat p | Ci | sto | (((typedExpressionIR_l (++) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_concat(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-land p | Ci | sto | (((typedExpressionIR_l (&&) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_land(value_l, value_r))

    4. Result in sto'', value

  (path) binaryExpressionIR-lor p | Ci | sto | (((typedExpressionIR_l (||) typedExpressionIR_r) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto' value_l)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_r ==> sto'' value_r)

    3. (Let value be $bin_lor(value_l, value_r))

    4. Result in sto'', value

  (path) ternaryExpressionIR-then p | Ci | sto | (((typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_c ==> sto' value_c)

    2. If ((value_c = ((b true) as value))), then

      1. (Expr_inst: p Ci sto' |- typedExpressionIR_t ==> sto'' value_t)

      2. Result in sto'', value_t

  (path) ternaryExpressionIR-else p | Ci | sto | (((typedExpressionIR_c ? typedExpressionIR_t : typedExpressionIR_e) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_c ==> sto' value_c)

    2. If ((value_c = ((b false) as value))), then

      1. (Expr_inst: p Ci sto' |- typedExpressionIR_e ==> sto'' value_e)

      2. Result in sto'', value_e

  (path) castExpressionIR p | Ci | sto | (((( typeIR ) typedExpressionIR) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

    2. (Let value_c be $cast_op(typeIR, value))

    3. Result in sto', value_c

  (path) dataExpressionIR-invalid p | Ci | sto | ((({#}) as expressionIR) # _expressionNoteIR)

    1. Result in sto, (({#}) as value)

  (path) dataExpressionIR-sequence p | Ci | sto | (((seq{ typedExpressionListIR }) as expressionIR) # _expressionNoteIR)

    1. (Exprs_inst: p Ci sto |- typedExpressionListIR ==> sto' value*)

    2. Result in sto', ((seq( value* )) as value)

  (path) dataExpressionIR-sequencedefault p | Ci | sto | (((seq{ typedExpressionListIR ,...}) as expressionIR) # _expressionNoteIR)

    1. (Exprs_inst: p Ci sto |- typedExpressionListIR ==> sto' value*)

    2. Result in sto', ((seq( value* ,...)) as value)

  (path) dataExpressionIR-record p | Ci | sto | (((record{ (nameIR = typedExpressionIR)* }) as expressionIR) # _expressionNoteIR)

    1. (Exprs_inst: p Ci sto |- typedExpressionIR* ==> sto' value*)

    2. Result in sto', ((record{ (value nameIR ;)* }) as value)

  (path) dataExpressionIR-recorddefault p | Ci | sto | (((record{ (nameIR = typedExpressionIR)* ,...}) as expressionIR) # _expressionNoteIR)

    1. (Exprs_inst: p Ci sto |- typedExpressionIR* ==> sto' value*)

    2. Result in sto', ((record{ (value nameIR ;)* ,...}) as value)

  (path) accessExpressionIR-errorAccessExpressionIR p | Ci | sto | (((error. nameIR) as expressionIR) # _expressionNoteIR)

    1. (Let nameIR' be $concat_text(["error.", nameIR]))

    2. (Let value'? be $find_value_inst(p, Ci, nameIR'))

    3. If ((value'? matches pattern (_))), then

      1. (Let ?(value) be value'?)

      2. Result in sto, value

  (path) accessExpressionIR-memberAccessExpressionIR-typeaccess-enum p | Ci | sto | ((((type prefixedNameIR) . nameIR) as expressionIR) # _expressionNoteIR)

    1. (Let nameIR_type be $flatten_prefixedNameIR(prefixedNameIR))

    2. (Let typeDefIR'? be $find_typedef_inst(p, Ci, nameIR_type))

    3. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type typeIR)), then

        1. (Let typeIR be (typeDefIR as typeIR))

        2. (Let typeIR' be $canon(typeIR))

        3. If ((typeIR' has type enumTypeIR)), then

          1. (Let enumTypeIR be (typeIR' as enumTypeIR))

          2. If ((enumTypeIR matches pattern `ENUM%{%}`)), then

            1. (Let (enum tid { _id* }) be enumTypeIR)

            2. Result in sto, ((tid . nameIR) as value)

  (path) accessExpressionIR-memberAccessExpressionIR-senum p | Ci | sto | ((((type prefixedNameIR) . nameIR) as expressionIR) # _expressionNoteIR)

    1. (Let nameIR_type be $flatten_prefixedNameIR(prefixedNameIR))

    2. (Let typeDefIR'? be $find_typedef_inst(p, Ci, nameIR_type))

    3. If ((typeDefIR'? matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?)

      2. If ((typeDefIR has type typeIR)), then

        1. (Let typeIR be (typeDefIR as typeIR))

        2. (Let typeIR' be $canon(typeIR))

        3. If ((typeIR' has type enumTypeIR)), then

          1. (Let enumTypeIR be (typeIR' as enumTypeIR))

          2. If ((enumTypeIR matches pattern `ENUM%#%{%}`)), then

            1. (Let (enum tid # _typeIR { (id_f = value_f ;)* }) be enumTypeIR)

            2. (Let value'? be $assoc_<nameIR, value>(nameIR, (id_f, value_f)*))

            3. If ((value'? matches pattern (_))), then

              1. (Let ?(value) be value'?)

              2. Result in sto, ((tid . nameIR # value) as value)

  (path) accessExpressionIR-memberAccessExpressionIR-typedExpressionIR p | Ci | sto | ((((typedExpressionIR as memberAccessBaseIR) . "size") as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

    2. (Let value' be value)

    3. If ((value' has type headerStackValue)), then

      1. (Let ([ _value* #( _nat ; nat_s )]) be (value' as headerStackValue))

      2. Result in sto', ((d (nat_s as int)) as value)

  (path) indexAccessExpressionIR-bitslice p | Ci | sto | (((typedExpressionIR_b [ typedExpressionIR_l : typedExpressionIR_h ]) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR_b ==> sto' value_b)

    2. (Expr_inst: p Ci sto' |- typedExpressionIR_l ==> sto'' value_l)

    3. (Expr_inst: p Ci sto'' |- typedExpressionIR_h ==> sto''' value_h)

    4. (Let value be $bitacc_op(value_b, value_l, value_h))

    5. Result in sto''', value

  (path) callExpressionIR-instantiation p | Ci | sto | ((((prefixedNameIR < typeArgumentListIR >) ( argumentListIR )) as expressionIR) # _expressionNoteIR)

    1. (Let (rid, consDyn, id*)? be $find_constructor_overloaded_inst(Ci, prefixedNameIR, argumentListIR))

    2. If (((rid, consDyn, id*)? matches pattern (_))), then

      1. (Let ?((_rid, consDyn, id_default*)) be (rid, consDyn, id*)?)

      2. (Constructor_inst: p Ci sto |- consDyn < typeArgumentListIR >( argumentListIR # id_default* )==> sto' objDyn)

      3. (Let sto'' be $add_sto(sto', Ci.path, objDyn))

      4. Result in sto'', ((! Ci.path) as value)

  (path) callExpressionIR-methodTarget-generic p | Ci | sto | ((((typedExpressionIR . nameIR) < [] >( [] )) as expressionIR) # _expressionNoteIR)

    1. (Let (_expressionIR # (( typeIR _ctk ))) be typedExpressionIR)

    2. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. (Let value be $size(typeIR, nameIR))

      2. Result in sto, value

  (path) callExpressionIR-methodTarget-non-generic p | Ci | sto | ((((type prefixedNameIR . nameIR) < [] >( [] )) as expressionIR) # _expressionNoteIR)

    1. If (nameIR is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. (Let typeIR be $find_type_inst(p, Ci, prefixedNameIR))

      2. (Let value be $size(typeIR, nameIR))

      3. Result in sto, value

  (path) parenthesizedExpressionIR p | Ci | sto | (((( typedExpressionIR )) as expressionIR) # _expressionNoteIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

    2. Result in sto', value

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:27.1-29.26
relation Argument_inst

  (match) p | Ci | sto | argumentIR

    1. If ((argumentIR has type typedExpressionIR)), then

      1. (Let typedExpressionIR be (argumentIR as typedExpressionIR))

      2. Try matching path expression

    2. If ((argumentIR matches pattern `%=%`)), then

      1. (Let (nameIR = typedExpressionIR) be argumentIR)

      2. Try matching path namedexpression

  (path) expression p | Ci | sto | (typedExpressionIR as argumentIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

    2. Result in sto', value

  (path) namedexpression p | Ci | sto | (nameIR = typedExpressionIR)

    1. (Expr_inst: p Ci sto |- typedExpressionIR ==> sto' value)

    2. Result in sto', value

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:35.1-37.26
relation Decls_inst

  (match) p | Ci' | sto' | declarationIR*

    1. (Let Ci be Ci')

    2. (Let sto be sto')

    3. If ((declarationIR* matches pattern [])), then

      1. Try matching path nil

    4. (Let Ci_0 be Ci')

    5. (Let sto_0 be sto')

    6. If ((declarationIR* matches pattern _ :: _)), then

      1. (Let declarationIR_h :: declarationIR_t* be declarationIR*)

      2. Try matching path cons-none

    7. (Let Ci_0 be Ci')

    8. (Let sto_0 be sto')

    9. If ((declarationIR* matches pattern _ :: _)), then

      1. (Let declarationIR_h :: declarationIR_t* be declarationIR*)

      2. Try matching path cons-some

  (path) nil p | Ci | sto | []

    1. Result in Ci, sto, []

  (path) cons-none p | Ci_0 | sto_0 | declarationIR_h :: declarationIR_t*

    1. (Decl_inst: p Ci_0 sto_0 |- declarationIR_h ==> Ci_1 sto_1 declarationIR'?)

    2. If ((declarationIR'? matches pattern ())), then

      1. (Decls_inst: p Ci_1 sto_1 |- declarationIR_t* ==> Ci_2 sto_2 declarationIR_t'*)

      2. Result in Ci_2, sto_2, declarationIR_t'*

  (path) cons-some p | Ci_0 | sto_0 | declarationIR_h :: declarationIR_t*

    1. (Decl_inst: p Ci_0 sto_0 |- declarationIR_h ==> Ci_1 sto_1 declarationIR'?)

    2. If ((declarationIR'? matches pattern (_))), then

      1. (Let ?(declarationIR_h') be declarationIR'?)

      2. (Decls_inst: p Ci_1 sto_1 |- declarationIR_t* ==> Ci_2 sto_2 declarationIR_t'*)

      3. Result in Ci_2, sto_2, declarationIR_h' :: declarationIR_t'*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:39.1-41.26
relation Decl_inst

  (match) cursor' | Ci_0 | sto' | declarationIR

    1. (Let cursor be cursor')

    2. (Let sto be sto')

    3. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type constantDeclarationIR)), then

        1. (Let (_annotationList const typeIR nameIR (= value) ;) be (declarationIR as constantDeclarationIR))

        2. Try matching path constantDeclarationIR-global

    4. (Let p be cursor')

    5. (Let sto be sto')

    6. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let (annotationList const typeIR nameIR (= value) ;) be (declarationIR as constantDeclarationIR))

      2. Try matching path constantDeclarationIR-non-global

    7. (Let p be cursor')

    8. (Let sto_0 be sto')

    9. If ((declarationIR has type instantiationIR)), then

      1. (Let (_annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;) be (declarationIR as instantiationIR))

      2. Try matching path instantiationIR-extern

    10. (Let p be cursor')

    11. (Let sto_0 be sto')

    12. If ((declarationIR has type instantiationIR)), then

      1. (Let (_annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;) be (declarationIR as instantiationIR))

      2. Try matching path instantiationIR-non-extern

    13. (Let p be cursor')

    14. (Let sto be sto')

    15. If ((declarationIR has type functionDeclarationIR)), then

      1. (Let (_annotationList (typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR )) blockStatementIR) be (declarationIR as functionDeclarationIR))

      2. Try matching path functionDeclarationIR

    16. (Let p be cursor')

    17. (Let sto be sto')

    18. If ((declarationIR has type actionDeclarationIR)), then

      1. (Let (_annotationList action nameIR ( parameterListIR ) blockStatementIR) be (declarationIR as actionDeclarationIR))

      2. Try matching path actionDeclarationIR

    19. (Let cursor be cursor')

    20. (Let sto be sto')

    21. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type errorDeclarationIR)), then

        1. (Let (error{ nameIR* }) be (declarationIR as errorDeclarationIR))

        2. Try matching path errorDeclarationIR

    22. (Let cursor be cursor')

    23. (Let sto be sto')

    24. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type matchKindDeclarationIR)), then

        1. (Let (match_kind{ nameIR* }) be (declarationIR as matchKindDeclarationIR))

        2. Try matching path matchKindDeclarationIR

    25. (Let p be cursor')

    26. (Let sto be sto')

    27. If ((declarationIR has type externFunctionDeclarationIR)), then

      1. (Let (_annotationList extern (typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR )) ;) be (declarationIR as externFunctionDeclarationIR))

      2. Try matching path externFunctionDeclarationIR

    28. (Let p be cursor')

    29. (Let sto be sto')

    30. If ((declarationIR has type parserDeclarationIR)), then

      1. (Let (_annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }) be (declarationIR as parserDeclarationIR))

      2. Try matching path parserDeclarationIR

    31. (Let p be cursor')

    32. (Let sto be sto')

    33. If ((declarationIR has type controlDeclarationIR)), then

      1. (Let (_annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }) be (declarationIR as controlDeclarationIR))

      2. Try matching path controlDeclarationIR

    34. (Let cursor be cursor')

    35. (Let sto be sto')

    36. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type enumTypeDeclarationIR)), then

        1. (Let enumTypeDeclarationIR be (declarationIR as enumTypeDeclarationIR))

        2. If ((enumTypeDeclarationIR matches pattern `%ENUM%{%}`)), then

          1. (Let (_annotationList enum nameIR { nameIR_mem* }) be enumTypeDeclarationIR)

          2. Try matching path typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-enum

    37. (Let cursor be cursor')

    38. (Let sto_0 be sto')

    39. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type enumTypeDeclarationIR)), then

        1. (Let enumTypeDeclarationIR be (declarationIR as enumTypeDeclarationIR))

        2. If ((enumTypeDeclarationIR matches pattern `%ENUM%%{%}`)), then

          1. (Let (_annotationList enum typeIR nameIR { (nameIR_mem = typedExpressionIR)* }) be enumTypeDeclarationIR)

          2. Try matching path typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-serializableEnum

    40. (Let cursor be cursor')

    41. (Let sto be sto')

    42. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type structTypeDeclarationIR)), then

        1. (Let (_annotationList struct nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR* }) be (declarationIR as structTypeDeclarationIR))

        2. Try matching path typeDeclarationIR-derivedTypeDeclarationIR-structTypeDeclarationIR

    43. (Let cursor be cursor')

    44. (Let sto be sto')

    45. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type headerTypeDeclarationIR)), then

        1. (Let (_annotationList header nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR* }) be (declarationIR as headerTypeDeclarationIR))

        2. Try matching path typeDeclarationIR-derivedTypeDeclarationIR-headerTypeDeclarationIR

    46. (Let cursor be cursor')

    47. (Let sto be sto')

    48. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type headerUnionTypeDeclarationIR)), then

        1. (Let (_annotationList header_union nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR* }) be (declarationIR as headerUnionTypeDeclarationIR))

        2. Try matching path typeDeclarationIR-derivedTypeDeclarationIR-headerUnionTypeDeclarationIR

    49. (Let cursor be cursor')

    50. (Let sto be sto')

    51. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type typedefDeclarationIR)), then

        1. (Let typedefDeclarationIR be (declarationIR as typedefDeclarationIR))

        2. If ((typedefDeclarationIR matches pattern `%TYPEDEF%%;`)), then

          1. (Let (_annotationList typedef typedefTypeIR nameIR ;) be typedefDeclarationIR)

          2. If ((typedefTypeIR has type typeIR)), then

            1. (Let typeIR be (typedefTypeIR as typeIR))

            2. Try matching path typeDeclarationIR-typedefDeclarationIR-typedef-typeIR

    52. (Let cursor be cursor')

    53. (Let sto be sto')

    54. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type typedefDeclarationIR)), then

        1. (Let typedefDeclarationIR be (declarationIR as typedefDeclarationIR))

        2. If ((typedefDeclarationIR matches pattern `%TYPEDEF%%;`)), then

          1. (Let (_annotationList typedef typedefTypeIR nameIR ;) be typedefDeclarationIR)

          2. If ((typedefTypeIR has type derivedTypeDeclarationIR)), then

            1. (Let derivedTypeDeclarationIR be (typedefTypeIR as derivedTypeDeclarationIR))

            2. Try matching path typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclarationIR-monoTypeDefIR

    55. (Let cursor be cursor')

    56. (Let sto be sto')

    57. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type typedefDeclarationIR)), then

        1. (Let typedefDeclarationIR be (declarationIR as typedefDeclarationIR))

        2. If ((typedefDeclarationIR matches pattern `%TYPEDEF%%;`)), then

          1. (Let (_annotationList typedef typedefTypeIR nameIR ;) be typedefDeclarationIR)

          2. If ((typedefTypeIR has type derivedTypeDeclarationIR)), then

            1. (Let derivedTypeDeclarationIR be (typedefTypeIR as derivedTypeDeclarationIR))

            2. Try matching path typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclaration-polyTypeDefIR

    58. (Let cursor be cursor')

    59. (Let sto be sto')

    60. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type typedefDeclarationIR)), then

        1. (Let typedefDeclarationIR be (declarationIR as typedefDeclarationIR))

        2. If ((typedefDeclarationIR matches pattern `%TYPE%%;`)), then

          1. (Let (_annotationList type typeIR nameIR ;) be typedefDeclarationIR)

          2. Try matching path typeDeclarationIR-typedefDeclarationIR-newtype

    61. (Let cursor be cursor')

    62. (Let sto be sto')

    63. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type parserTypeDeclarationIR)), then

        1. (Let (_annotationList parser nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* );) be (declarationIR as parserTypeDeclarationIR))

        2. Try matching path typeDeclarationIR-parserTypeDeclarationIR

    64. (Let cursor be cursor')

    65. (Let sto be sto')

    66. If ((cursor matches pattern `GLOBAL`)), then

      1. If ((declarationIR has type controlTypeDeclarationIR)), then

        1. (Let (_annotationList control nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* );) be (declarationIR as controlTypeDeclarationIR))

        2. Try matching path typeDeclarationIR-controlTypeDeclarationIR

    67. (Let p be cursor')

    68. (Let sto be sto')

    69. If ((declarationIR has type packageTypeDeclarationIR)), then

      1. (Let (_annotationList package nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* );) be (declarationIR as packageTypeDeclarationIR))

      2. Try matching path typeDeclarationIR-packageTypeDeclarationIR

  (path) constantDeclarationIR-global (global) | Ci_0 | sto | ((_annotationList const typeIR nameIR (= value) ;) as declarationIR)

    1. (Let Ci_1 be $add_value_inst((global), Ci_0, nameIR, value))

    2. Result in Ci_1, sto, ?()

  (path) constantDeclarationIR-non-global p | Ci_0 | sto | ((annotationList const typeIR nameIR (= value) ;) as declarationIR)

    1. (Let Ci_1 be $add_value_inst(p, Ci_0, nameIR, value))

    2. Result in Ci_1, sto, ?(((annotationList const typeIR nameIR (= value) ;) as declarationIR))

  (path) instantiationIR-extern p | Ci_0 | sto_0 | ((_annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;) as declarationIR)

    1. (Let (rid, consDyn, id*)? be $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR))

    2. If (((rid, consDyn, id*)? matches pattern (_))), then

      1. (Let ?((_rid, consDyn, id_default*)) be (rid, consDyn, id*)?)

      2. (Let Ci_1 be $enter_path(Ci_0, nameIR))

      3. (Constructor_inst: p Ci_1 sto_0 |- consDyn < typeArgumentListIR >( argumentListIR # id_default* )==> sto_1 objDyn)

      4. (Let objDyn' be objDyn)

      5. If ((objDyn' matches pattern `EXTERN{%%%%}`)), then

        1. (Let (extern{ tid theta venv renv }) be objDyn')

        2. (Let Ci_init be $empty_context_inst[path = Ci_1.path ++ [nameIR]][global = Ci_1.global])

        3. (Let objectDeclarationListIR be $get_init_decls(objectInitializerOptIR))

        4. (ObjectDecls_inst: (block) Ci_init sto_1 |- objectDeclarationListIR ==> Ci_init_2 sto_2 _objectDeclarationListIR)

        5. Result in Ci_0, sto_2, ?()

  (path) instantiationIR-non-extern p | Ci_0 | sto_0 | ((_annotationList prefixedNameIR < typeArgumentListIR >( argumentListIR ) nameIR objectInitializerOptIR ;) as declarationIR)

    1. (Let (rid, consDyn, id*)? be $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR))

    2. If (((rid, consDyn, id*)? matches pattern (_))), then

      1. (Let ?((_rid, consDyn, id_default*)) be (rid, consDyn, id*)?)

      2. (Let Ci_1 be $enter_path(Ci_0, nameIR))

      3. (Constructor_inst: p Ci_1 sto_0 |- consDyn < typeArgumentListIR >( argumentListIR # id_default* )==> sto_1 objDyn)

      4. If (~$is_extern_object(objDyn)), then

        1. (Let tid be $flatten_prefixedNameIR(prefixedNameIR))

        2. (Let typeIR be ((tid tid) as typeIR))

        3. (Let oid be Ci_1.path ++ [nameIR])

        4. (Let sto_2 be $add_sto(sto_1, oid, objDyn))

        5. (Let Ci_2 be $add_value_inst(p, Ci_1, nameIR, ((! oid) as value)))

        6. (Let constantDeclarationIR be (() const typeIR nameIR (= ((! oid) as value)) ;))

        7. Result in Ci_0, sto_1, ?()

  (path) functionDeclarationIR p | Ci_0 | sto | ((_annotationList (typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR )) blockStatementIR) as declarationIR)

    1. (Let rid be $rid_IR(nameIR, parameterListIR))

    2. (Let funcDyn be (function< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ) blockStatementIR))

    3. (Let Ci_1 be $add_routine_overload_inst(p, Ci_0, rid, (funcDyn as routineDyn)))

    4. Result in Ci_1, sto, ?()

  (path) actionDeclarationIR p | Ci_0 | sto | ((_annotationList action nameIR ( parameterListIR ) blockStatementIR) as declarationIR)

    1. (Let rid be $rid_IR(nameIR, parameterListIR))

    2. (Let funcDyn be (action( parameterListIR ){ blockStatementIR }))

    3. (Let Ci_1 be $add_routine_non_overload_inst(p, Ci_0, rid, (funcDyn as routineDyn)))

    4. Result in Ci_1, sto, ?()

  (path) errorDeclarationIR (global) | Ci_0 | sto | ((error{ nameIR* }) as declarationIR)

    1. (Let nameIR_field be $concat_text(["error.", nameIR]))*

    2. (Let Ci_1 be $add_values_inst((global), Ci_0, nameIR_field*, ((error. nameIR) as value)*))

    3. Result in Ci_1, sto, ?()

  (path) matchKindDeclarationIR (global) | Ci_0 | sto | ((match_kind{ nameIR* }) as declarationIR)

    1. (Let Ci_1 be $add_values_inst((global), Ci_0, nameIR*, ((match_kind. nameIR) as value)*))

    2. Result in Ci_1, sto, ?()

  (path) externFunctionDeclarationIR p | Ci_0 | sto | ((_annotationList extern (typeIR nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterListIR )) ;) as declarationIR)

    1. (Let rid be $rid_IR(nameIR, parameterListIR))

    2. (Let funcDyn be (extern_function< typeParameterListIR ++ typeParameterListIR_inferred >( parameterListIR ){ ?() }))

    3. (Let Ci_1 be $add_routine_overload_inst(p, Ci_0, rid, (funcDyn as routineDyn)))

    4. Result in Ci_1, sto, ?()

  (path) parserDeclarationIR p | Ci_0 | sto | ((_annotationList parser nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }) as declarationIR)

    1. (Let cid be $cid_IR(nameIR, constructorParameterListIR))

    2. (Let consDyn be (parser< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ parserLocalDeclarationListIR parserStateListIR }))

    3. (Let Ci_1 be $add_constructor_inst(p, Ci_0, cid, consDyn))

    4. Result in Ci_1, sto, ?()

  (path) controlDeclarationIR p | Ci_0 | sto | ((_annotationList control nameIR < typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }) as declarationIR)

    1. (Let cid be $cid_IR(nameIR, constructorParameterListIR))

    2. (Let consDyn be (control< typeParameterListIR >( parameterListIR )( constructorParameterListIR ){ controlLocalDeclarationListIR apply controlBodyIR }))

    3. (Let Ci_1 be $add_constructor_inst(p, Ci_0, cid, consDyn))

    4. Result in Ci_1, sto, ?()

  (path) typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-enum (global) | Ci_0 | sto | ((_annotationList enum nameIR { nameIR_mem* }) as declarationIR)

    1. (Let nameIR_path be $concat_text([nameIR, ".", nameIR_mem]))*

    2. (Let Ci_1 be $add_values_inst((global), Ci_0, nameIR_path*, ((nameIR . nameIR_mem) as value)*))

    3. (Let Ci_2 be $add_typedef_inst((global), Ci_1, nameIR, ((enum nameIR { nameIR_mem* }) as typeDefIR)))

    4. Result in Ci_2, sto, ?()

  (path) typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-serializableEnum (global) | Ci_0 | sto_0 | ((_annotationList enum typeIR nameIR { (nameIR_mem = typedExpressionIR)* }) as declarationIR)

    1. (Let nameIR_path be $concat_text([nameIR, ".", nameIR_mem]))*

    2. (Exprs_inst: (global) Ci_0 sto_0 |- typedExpressionIR* ==> sto_1 value_mem*)

    3. (Let Ci_1 be $add_values_inst((global), Ci_0, nameIR_path*, ((nameIR . nameIR_mem # value_mem) as value)*))

    4. (Let Ci_2 be $add_typedef_inst((global), Ci_1, nameIR, ((enum nameIR # typeIR { (nameIR_mem = value_mem ;)* }) as typeDefIR)))

    5. Result in Ci_2, sto_1, ?()

  (path) typeDeclarationIR-derivedTypeDeclarationIR-structTypeDeclarationIR (global) | Ci_0 | sto | ((_annotationList struct nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR* }) as declarationIR)

    1. (Let (_annotationList' typeIR nameIR_field ;) be typeFieldIR)*

    2. (Let typeDefIR be ((((struct nameIR { (typeIR nameIR_field ;)* }) as typeIR) < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

    3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR))

    4. Result in Ci_1, sto, ?()

  (path) typeDeclarationIR-derivedTypeDeclarationIR-headerTypeDeclarationIR (global) | Ci_0 | sto | ((_annotationList header nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR* }) as declarationIR)

    1. (Let (_annotationList' typeIR nameIR_field ;) be typeFieldIR)*

    2. (Let typeDefIR be ((((header nameIR { (typeIR nameIR_field ;)* }) as typeIR) < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

    3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR))

    4. Result in Ci_1, sto, ?()

  (path) typeDeclarationIR-derivedTypeDeclarationIR-headerUnionTypeDeclarationIR (global) | Ci_0 | sto | ((_annotationList header_union nameIR < typeParameterListIR , typeParameterListIR_inferred >{ typeFieldIR* }) as declarationIR)

    1. (Let (_annotationList' typeIR nameIR_field ;) be typeFieldIR)*

    2. (Let typeDefIR be ((((header_union nameIR { (typeIR nameIR_field ;)* }) as typeIR) < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

    3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR))

    4. Result in Ci_1, sto, ?()

  (path) typeDeclarationIR-typedefDeclarationIR-typedef-typeIR (global) | Ci_0 | sto | ((_annotationList typedef (typeIR as typedefTypeIR) nameIR ;) as declarationIR)

    1. (Let typeIR_typedef be ((typedef nameIR typeIR) as typeIR))

    2. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, (typeIR_typedef as typeDefIR)))

    3. Result in Ci_1, sto, ?()

  (path) typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclarationIR-monoTypeDefIR (global) | Ci_0 | sto | ((_annotationList typedef (derivedTypeDeclarationIR as typedefTypeIR) nameIR ;) as declarationIR)

    1. (Decl_inst: (global) Ci_0 $empty_sto |- (derivedTypeDeclarationIR as declarationIR) ==> Ci_local _sto _declarationIR?)

    2. (Let ({ tid* }) be $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_0.global.tdenv), $dom_map<tid, typeDefIR>(Ci_local.global.tdenv)))

    3. If ((tid* matches pattern [ _/1 ])), then

      1. (Let [tid_newtype] be tid*)

      2. (Let typeDefIR'? be $find_typedef_inst((global), Ci_local, tid_newtype))

      3. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. (Let typeDefIR'' be typeDefIR)

        3. If ((typeDefIR'' has type monoTypeDefIR)), then

          1. (Let monoTypeDefIR be (typeDefIR'' as monoTypeDefIR))

          2. (Let typeIR_typedef be ((typedef nameIR monoTypeDefIR) as typeIR))

          3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, (typeIR_typedef as typeDefIR)))

          4. Result in Ci_1, sto, ?()

  (path) typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclaration-polyTypeDefIR (global) | Ci_0 | sto | ((_annotationList typedef (derivedTypeDeclarationIR as typedefTypeIR) nameIR ;) as declarationIR)

    1. (Decl_inst: (global) Ci_0 $empty_sto |- (derivedTypeDeclarationIR as declarationIR) ==> Ci_local _sto _declarationIR?)

    2. (Let ({ tid* }) be $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_0.global.tdenv), $dom_map<tid, typeDefIR>(Ci_local.global.tdenv)))

    3. If ((tid* matches pattern [ _/1 ])), then

      1. (Let [tid_newtype] be tid*)

      2. (Let typeDefIR'? be $find_typedef_inst((global), Ci_local, tid_newtype))

      3. If ((typeDefIR'? matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?)

        2. (Let typeDefIR'' be typeDefIR)

        3. If ((typeDefIR'' has type polyTypeDefIR)), then

          1. (Let polyTypeDefIR be (typeDefIR'' as polyTypeDefIR))

          2. (Let typeIR_typedef be ((typedef nameIR ((polyTypeDefIR < [] >) as typeIR)) as typeIR))

          3. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, (typeIR_typedef as typeDefIR)))

          4. Result in Ci_1, sto, ?()

  (path) typeDeclarationIR-typedefDeclarationIR-newtype (global) | Ci_0 | sto | ((_annotationList type typeIR nameIR ;) as declarationIR)

    1. (Let typeIR_newtype be ((type nameIR typeIR) as typeIR))

    2. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, (typeIR_newtype as typeDefIR)))

    3. Result in Ci_1, sto, ?()

  (path) typeDeclarationIR-parserTypeDeclarationIR (global) | Ci_0 | sto | ((_annotationList parser nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* );) as declarationIR)

    1. (Let parameterTypeIR be $parameterIR(parameterIR))*

    2. (Let typeIR_parser be ((parser( parameterTypeIR* )) as typeIR))

    3. (Let typeDefIR_parser be ((typeIR_parser < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

    4. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR_parser))

    5. Result in Ci_1, sto, ?()

  (path) typeDeclarationIR-controlTypeDeclarationIR (global) | Ci_0 | sto | ((_annotationList control nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* );) as declarationIR)

    1. (Let parameterTypeIR be $parameterIR(parameterIR))*

    2. (Let typeIR_parser be ((control( parameterTypeIR* )) as typeIR))

    3. (Let typeDefIR_parser be ((typeIR_parser < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

    4. (Let Ci_1 be $add_typedef_inst((global), Ci_0, nameIR, typeDefIR_parser))

    5. Result in Ci_1, sto, ?()

  (path) typeDeclarationIR-packageTypeDeclarationIR p | Ci_0 | sto | ((_annotationList package nameIR < typeParameterListIR , typeParameterListIR_inferred >( parameterIR* );) as declarationIR)

    1. (Let (_annotationList' _direction typeIR _nameIR _constantInitializerOptIR) be parameterIR)*

    2. (Let typeIR_package be ((package< typeIR* >) as typeIR))

    3. (Let typeDefIR_package be ((typeIR_package < typeParameterListIR , typeParameterListIR_inferred >) as typeDefIR))

    4. (Let Ci_1 be $add_typedef_inst(p, Ci_0, nameIR, typeDefIR_package))

    5. (Let cid be $cid_IR(nameIR, parameterIR*))

    6. (Let consDyn_package be (package< typeParameterListIR ++ typeParameterListIR_inferred >( parameterIR* )))

    7. (Let Ci_2 be $add_constructor_inst((global), Ci_1, cid, consDyn_package))

    8. Result in Ci_2, sto, ?()

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:43.1-45.26
relation ParserLocalDecl_inst

  (match) 





;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:47.1-49.26
relation ParserLocalDecls_inst

  (match) 





;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:51.1-53.23
relation ControlLocalDecl_inst

  (match) Ci_0' | sto_0' | controlLocalDeclarationIR

    1. (Let Ci_0 be Ci_0')

    2. (Let sto_0 be sto_0')

    3. If ((controlLocalDeclarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (controlLocalDeclarationIR as constantDeclarationIR))

      2. Try matching path constantDeclarationIR

    4. (Let Ci_0 be Ci_0')

    5. (Let sto_0 be sto_0')

    6. If ((controlLocalDeclarationIR has type instantiationIR)), then

      1. (Let instantiationIR be (controlLocalDeclarationIR as instantiationIR))

      2. Try matching path instantiationIR

    7. (Let Ci be Ci_0')

    8. (Let sto be sto_0')

    9. If ((controlLocalDeclarationIR has type variableDeclarationIR)), then

      1. (Let variableDeclarationIR be (controlLocalDeclarationIR as variableDeclarationIR))

      2. Try matching path variableDeclarationIR

    10. (Let Ci_0 be Ci_0')

    11. (Let sto_0 be sto_0')

    12. If ((controlLocalDeclarationIR has type actionDeclarationIR)), then

      1. (Let actionDeclarationIR be (controlLocalDeclarationIR as actionDeclarationIR))

      2. Try matching path actionDeclarationIR

    13. (Let Ci_0 be Ci_0')

    14. (Let sto_0 be sto_0')

    15. If ((controlLocalDeclarationIR has type tableDeclarationIR)), then

      1. (Let (_annotationList table typeIR nameIR { tablePropertyListIR }) be (controlLocalDeclarationIR as tableDeclarationIR))

      2. Try matching path tableDeclarationIR

  (path) constantDeclarationIR Ci_0 | sto_0 | (constantDeclarationIR as controlLocalDeclarationIR)

    1. (Decl_inst: (block) Ci_0 sto_0 |- (constantDeclarationIR as declarationIR) ==> Ci_1 sto_1 declarationIR?)

    2. If ((declarationIR? has type constantDeclarationIR?)), then

      1. (Let constantDeclarationIR_inst? be (declarationIR? as constantDeclarationIR?))

      2. Result in Ci_1, sto_1, (constantDeclarationIR_inst? as controlLocalDeclarationIR?)

  (path) instantiationIR Ci_0 | sto_0 | (instantiationIR as controlLocalDeclarationIR)

    1. (Decl_inst: (block) Ci_0 sto_0 |- (instantiationIR as declarationIR) ==> Ci_1 sto_1 declarationIR?)

    2. If ((declarationIR? has type instantiationIR?)), then

      1. (Let instantiationIR_inst? be (declarationIR? as instantiationIR?))

      2. Result in Ci_1, sto_1, (instantiationIR_inst? as controlLocalDeclarationIR?)

  (path) variableDeclarationIR Ci | sto | (variableDeclarationIR as controlLocalDeclarationIR)

    1. Result in Ci, sto, ?((variableDeclarationIR as controlLocalDeclarationIR))

  (path) actionDeclarationIR Ci_0 | sto_0 | (actionDeclarationIR as controlLocalDeclarationIR)

    1. (Decl_inst: (block) Ci_0 sto_0 |- (actionDeclarationIR as declarationIR) ==> Ci_1 sto_1 declarationIR?)

    2. If ((declarationIR? has type actionDeclarationIR?)), then

      1. (Let actionDeclarationIR_inst? be (declarationIR? as actionDeclarationIR?))

      2. Result in Ci_1, sto_1, (actionDeclarationIR_inst? as controlLocalDeclarationIR?)

  (path) tableDeclarationIR Ci_0 | sto_0 | ((_annotationList table typeIR nameIR { tablePropertyListIR }) as controlLocalDeclarationIR)

    1. (Let Ci_1 be $enter_path(Ci_0, nameIR))

    2. (Constructor_inst: (block) Ci_0 sto_0 |- (table nameIR { tablePropertyListIR }) < [] >( [] # [] )==> sto_1 objDyn)

    3. (Let oid be Ci_1.path ++ [nameIR])

    4. (Let sto_2 be $add_sto(sto_1, oid, objDyn))

    5. (Let Ci_2 be $add_value_inst((block), Ci_1, nameIR, ((! oid) as value)))

    6. (Let constantDeclarationIR be (() const typeIR nameIR (= ((! oid) as value)) ;))

    7. Result in Ci_2, sto_1, ?((constantDeclarationIR as controlLocalDeclarationIR))

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:55.1-57.23
relation ControlLocalDecls_inst

  (match) Ci' | sto' | controlLocalDeclarationIR*

    1. (Let Ci be Ci')

    2. (Let sto be sto')

    3. If ((controlLocalDeclarationIR* matches pattern [])), then

      1. Try matching path nil

    4. (Let Ci_0 be Ci')

    5. (Let sto_0 be sto')

    6. If ((controlLocalDeclarationIR* matches pattern _ :: _)), then

      1. (Let controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t* be controlLocalDeclarationIR*)

      2. Try matching path cons-none

    7. (Let Ci_0 be Ci')

    8. (Let sto_0 be sto')

    9. If ((controlLocalDeclarationIR* matches pattern _ :: _)), then

      1. (Let controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t* be controlLocalDeclarationIR*)

      2. Try matching path cons-some

  (path) nil Ci | sto | []

    1. Result in Ci, sto, []

  (path) cons-none Ci_0 | sto_0 | controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*

    1. (ControlLocalDecl_inst: Ci_0 sto_0 |- controlLocalDeclarationIR_h ==> Ci_1 sto_1 controlLocalDeclarationIR'?)

    2. If ((controlLocalDeclarationIR'? matches pattern ())), then

      1. (ControlLocalDecls_inst: Ci_1 sto_1 |- controlLocalDeclarationIR_t* ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*)

      2. Result in Ci_2, sto_2, controlLocalDeclarationIR_t'*

  (path) cons-some Ci_0 | sto_0 | controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*

    1. (ControlLocalDecl_inst: Ci_0 sto_0 |- controlLocalDeclarationIR_h ==> Ci_1 sto_1 controlLocalDeclarationIR'?)

    2. If ((controlLocalDeclarationIR'? matches pattern (_))), then

      1. (Let ?(controlLocalDeclarationIR_h') be controlLocalDeclarationIR'?)

      2. (ControlLocalDecls_inst: Ci_1 sto_1 |- controlLocalDeclarationIR_t* ==> Ci_2 sto_2 controlLocalDeclarationIR_t'*)

      3. Result in Ci_2, sto_2, controlLocalDeclarationIR_h' :: controlLocalDeclarationIR_t'*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:59.1-61.23
relation TableProperty_inst

  (match) Ci | sto | tablePropertyIR

    1. Case analysis on tablePropertyIR

      1. Case (% matches pattern `KEY={%}`)

        1. (Let (key={ tableKeyListIR }) be tablePropertyIR)

        2. Try matching path key

      2. Case (% matches pattern `ACTIONS={%}`)

        1. (Let (actions={ tableActionListIR }) be tablePropertyIR)

        2. Try matching path actions

      3. Case (% matches pattern `%%ENTRIES={%}`)

        1. (Let (annotationList constOptIR entries={ tableEntryListIR }) be tablePropertyIR)

        2. Try matching path entries

      4. Case (% matches pattern `%%DEFAULT_ACTION=%;`)

        1. (Let (annotationList constOptIR default_action= tableActionReferenceIR ;) be tablePropertyIR)

        2. Try matching path custom-default-action

      5. Case (% matches pattern `%%CUSTOM%%;`)

        1. (Let (annotationList constOptIR custom nameIR (= typedExpressionIR) ;) be tablePropertyIR)

        2. Try matching path custom

      6. Case (% matches pattern `%%CUSTOM_CONST%%;`)

        1. (Let (annotationList constOptIR custom_const nameIR constantInitializerIR ;) be tablePropertyIR)

        2. Try matching path custom-const

  (path) key Ci | sto | (key={ tableKeyListIR })

    1. Result in Ci, sto, (key={ tableKeyListIR })

  (path) actions Ci | sto | (actions={ tableActionListIR })

    1. Result in Ci, sto, (actions={ tableActionListIR })

  (path) entries Ci | sto | (annotationList constOptIR entries={ tableEntryListIR })

    1. Result in Ci, sto, (annotationList constOptIR entries={ tableEntryListIR })

  (path) custom-default-action Ci | sto | (annotationList constOptIR default_action= tableActionReferenceIR ;)

    1. Result in Ci, sto, (annotationList constOptIR default_action= tableActionReferenceIR ;)

  (path) custom Ci | sto | (annotationList constOptIR custom nameIR (= typedExpressionIR) ;)

    1. (Let Ci_1 be $enter_path(Ci, nameIR))

    2. (Expr_inst: (local) Ci_1 sto |- typedExpressionIR ==> sto_1 value)

    3. Result in Ci, sto, (annotationList constOptIR custom_const nameIR (= value) ;)

  (path) custom-const Ci | sto | (annotationList constOptIR custom_const nameIR constantInitializerIR ;)

    1. Result in Ci, sto, (annotationList constOptIR custom_const nameIR constantInitializerIR ;)

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:63.1-65.23
relation TableProperties_inst

  (match) Ci' | sto' | tablePropertyIR*

    1. (Let Ci be Ci')

    2. (Let sto be sto')

    3. If ((tablePropertyIR* matches pattern [])), then

      1. Try matching path nil

    4. (Let Ci_0 be Ci')

    5. (Let sto_0 be sto')

    6. If ((tablePropertyIR* matches pattern _ :: _)), then

      1. (Let tablePropertyIR_h :: tablePropertyIR_t* be tablePropertyIR*)

      2. Try matching path cons

  (path) nil Ci | sto | []

    1. Result in Ci, sto, []

  (path) cons Ci_0 | sto_0 | tablePropertyIR_h :: tablePropertyIR_t*

    1. (TableProperty_inst: Ci_0 sto_0 |- tablePropertyIR_h ==> Ci_1 sto_1 tablePropertyIR_h')

    2. (TableProperties_inst: Ci_1 sto_1 |- tablePropertyIR_t* ==> Ci_2 sto_2 tablePropertyIR'*)

    3. If ((tablePropertyIR'* = tablePropertyIR_t*)), then

      1. Result in Ci_2, sto_2, tablePropertyIR_h' :: tablePropertyIR_t*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:67.1-69.26
relation ObjectDecls_inst

  (match) 





;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:74.1-76.23
relation Methods_inst

  (match) 





;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:78.1-80.23
relation Method_inst

  (match) 





;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:86.1-88.26
relation Stmts_inst

  (match) 





;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:90.1-92.26
relation Stmt_inst

  (match) p | Ci | sto''' | statementIR'''

    1. (Let sto be sto''')

    2. (Let statementIR be statementIR''')

    3. If ((statementIR has type emptyStatementIR)), then

      1. (Let emptyStatementIR be (statementIR as emptyStatementIR))

      2. Try matching path emptyStatementIR

    4. (Let sto be sto''')

    5. (Let statementIR be statementIR''')

    6. If ((statementIR has type assignmentStatementIR)), then

      1. (Let assignmentStatementIR be (statementIR as assignmentStatementIR))

      2. Try matching path assignmentStatementIR

    7. (Let sto be sto''')

    8. (Let statementIR be statementIR''')

    9. If ((statementIR has type callStatementIR)), then

      1. (Let callStatementIR be (statementIR as callStatementIR))

      2. Try matching path callStatementIR

    10. (Let sto_0 be sto''')

    11. (Let statementIR be statementIR''')

    12. If ((statementIR has type directApplicationStatementIR)), then

      1. (Let (prefixedNameIR .apply( argumentListIR );) be (statementIR as directApplicationStatementIR))

      2. Try matching path directApplicationStatementIR

    13. (Let sto be sto''')

    14. (Let statementIR be statementIR''')

    15. If ((statementIR has type returnStatementIR)), then

      1. (Let returnStatementIR be (statementIR as returnStatementIR))

      2. Try matching path returnStatementIR

    16. (Let sto be sto''')

    17. (Let statementIR be statementIR''')

    18. If ((statementIR has type exitStatementIR)), then

      1. (Let exitStatementIR be (statementIR as exitStatementIR))

      2. Try matching path exitStatementIR

    19. (Let sto be sto''')

    20. (Let statementIR be statementIR''')

    21. If ((statementIR has type blockStatementIR)), then

      1. (Let (annotationList { blockElementStatementListIR }) be (statementIR as blockStatementIR))

      2. Try matching path blockStatementIR

    22. (Let sto be sto''')

    23. (Let statementIR'' be statementIR''')

    24. If ((statementIR'' has type conditionalStatementIR)), then

      1. (Let conditionalStatementIR be (statementIR'' as conditionalStatementIR))

      2. If ((conditionalStatementIR matches pattern `IF(%)%`)), then

        1. (Let (if( typedExpressionIR ) statementIR) be conditionalStatementIR)

        2. Try matching path conditionalStatementIR-non-else

    25. (Let sto be sto''')

    26. (Let statementIR be statementIR''')

    27. If ((statementIR has type conditionalStatementIR)), then

      1. (Let conditionalStatementIR be (statementIR as conditionalStatementIR))

      2. If ((conditionalStatementIR matches pattern `IF(%)%ELSE%`)), then

        1. (Let (if( typedExpressionIR ) statementIR_then else statementIR_else) be conditionalStatementIR)

        2. Try matching path conditionalStatementIR-else

    28. (Let sto be sto''')

    29. (Let statementIR be statementIR''')

    30. If ((statementIR has type breakStatementIR)), then

      1. (Let breakStatementIR be (statementIR as breakStatementIR))

      2. Try matching path breakStatementIR

    31. (Let sto be sto''')

    32. (Let statementIR be statementIR''')

    33. If ((statementIR has type continueStatementIR)), then

      1. (Let continueStatementIR be (statementIR as continueStatementIR))

      2. Try matching path continueStatementIR

    34. (Let sto be sto''')

    35. (Let statementIR be statementIR''')

    36. If ((statementIR has type switchStatementIR)), then

      1. (Let (switch( typedExpressionIR ){ switchCaseListIR }) be (statementIR as switchStatementIR))

      2. Try matching path switchStatementIR

  (path) emptyStatementIR p | Ci | sto | (emptyStatementIR as statementIR)

    1. Result in Ci, sto, (emptyStatementIR as statementIR)

  (path) assignmentStatementIR p | Ci | sto | (assignmentStatementIR as statementIR)

    1. Result in Ci, sto, (assignmentStatementIR as statementIR)

  (path) callStatementIR p | Ci | sto | (callStatementIR as statementIR)

    1. Result in Ci, sto, (callStatementIR as statementIR)

  (path) directApplicationStatementIR p | Ci | sto_0 | ((prefixedNameIR .apply( argumentListIR );) as statementIR)

    1. (Let (rid, consDyn, id*)? be $find_constructor_overloaded_inst(Ci, prefixedNameIR, []))

    2. If (((rid, consDyn, id*)? matches pattern (_))), then

      1. (Let ?((_rid, consDyn, _id*)) be (rid, consDyn, id*)?)

      2. (Constructor_inst: p Ci sto_0 |- consDyn < [] >( [] # [] )==> sto_1 objDyn)

      3. (Let tid_fresh be $fresh_tid)

      4. (Let tid be $flatten_prefixedNameIR(prefixedNameIR))

      5. (Let typeIR be ((tid tid) as typeIR))

      6. (Let nameIR be $concat_text([tid, "_", tid_fresh]))

      7. (Let oid be Ci.path ++ [nameIR])

      8. (Let sto_2 be $add_sto(sto_1, oid, objDyn))

      9. (Let constantDeclarationIR be (() const typeIR nameIR (= ((! oid) as value)) ;))

      10. (Let routineTargetIR be ((((` tid) as expressionIR) # (( typeIR (ctk) ))) . "apply"))

      11. (Let callStatementIR be (routineTargetIR < [] >( argumentListIR );))

      12. (Let blockStatementIR be (() { [(constantDeclarationIR as blockElementStatementIR), (callStatementIR as blockElementStatementIR)] }))

      13. Result in Ci, sto_2, (blockStatementIR as statementIR)

  (path) returnStatementIR p | Ci | sto | (returnStatementIR as statementIR)

    1. Result in Ci, sto, (returnStatementIR as statementIR)

  (path) exitStatementIR p | Ci | sto | (exitStatementIR as statementIR)

    1. Result in Ci, sto, (exitStatementIR as statementIR)

  (path) blockStatementIR p | Ci | sto | ((annotationList { blockElementStatementListIR }) as statementIR)

    1. (Block_inst: Ci sto false |- (annotationList { blockElementStatementListIR }) ==> Ci' sto' (_annotationList { blockElementStatementListIR' }))

    2. Result in Ci', sto', ((annotationList { blockElementStatementListIR' }) as statementIR)

  (path) conditionalStatementIR-non-else p | Ci | sto | ((if( typedExpressionIR ) statementIR) as statementIR)

    1. (Stmt_inst: p Ci sto |- statementIR ==> _contextInst sto' statementIR')

    2. Result in Ci, sto', ((if( typedExpressionIR ) statementIR') as statementIR)

  (path) conditionalStatementIR-else p | Ci | sto | ((if( typedExpressionIR ) statementIR_then else statementIR_else) as statementIR)

    1. (Stmt_inst: p Ci sto |- statementIR_then ==> _contextInst sto' statementIR_then')

    2. (Stmt_inst: p Ci sto' |- statementIR_else ==> _contextInst' sto'' statementIR_else')

    3. Result in Ci, sto'', ((if( typedExpressionIR ) statementIR_then' else statementIR_else') as statementIR)

  (path) breakStatementIR p | Ci | sto | (breakStatementIR as statementIR)

    1. Result in Ci, sto, (breakStatementIR as statementIR)

  (path) continueStatementIR p | Ci | sto | (continueStatementIR as statementIR)

    1. Result in Ci, sto, (continueStatementIR as statementIR)

  (path) switchStatementIR p | Ci | sto | ((switch( typedExpressionIR ){ switchCaseListIR }) as statementIR)

    1. (SwitchCases_inst: p Ci sto |- switchCaseListIR ==> Ci' sto' switchCaseListIR')

    2. Result in Ci', sto', ((switch( typedExpressionIR ){ switchCaseListIR' }) as statementIR)

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:94.1-96.23
relation BlockElementStmt_inst

  (match) Ci | sto | blockElementStatementIR

    1. Case analysis on blockElementStatementIR

      1. Case (% has type constantDeclarationIR)

        1. (Let constantDeclarationIR be (blockElementStatementIR as constantDeclarationIR))

        2. Try matching path constantDeclarationIR

      2. Case (% has type variableDeclarationIR)

        1. (Let variableDeclarationIR be (blockElementStatementIR as variableDeclarationIR))

        2. Try matching path variableDeclarationIR

      3. Case (% has type statementIR)

        1. (Let statementIR be (blockElementStatementIR as statementIR))

        2. Try matching path statementIR

  (path) constantDeclarationIR Ci | sto | (constantDeclarationIR as blockElementStatementIR)

    1. (Decl_inst: (local) Ci sto |- (constantDeclarationIR as declarationIR) ==> Ci' sto' declarationIR'?)

    2. If ((declarationIR'? matches pattern (_))), then

      1. (Let ?(declarationIR) be declarationIR'?)

      2. If ((declarationIR has type constantDeclarationIR)), then

        1. (Let constantDeclarationIR' be (declarationIR as constantDeclarationIR))

        2. Result in Ci', sto', ?((constantDeclarationIR' as blockElementStatementIR))

  (path) variableDeclarationIR Ci | sto | (variableDeclarationIR as blockElementStatementIR)

    1. Result in Ci, sto, ?((variableDeclarationIR as blockElementStatementIR))

  (path) statementIR Ci | sto | (statementIR as blockElementStatementIR)

    1. (Stmt_inst: (local) Ci sto |- statementIR ==> Ci' sto' statementIR_inst)

    2. Result in Ci', sto', ?((statementIR_inst as blockElementStatementIR))

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:98.1-100.23
relation BlockElementStmts_inst

  (match) Ci' | sto' | blockElementStatementIR*

    1. (Let Ci be Ci')

    2. (Let sto be sto')

    3. If ((blockElementStatementIR* matches pattern [])), then

      1. Try matching path nil

    4. (Let Ci_0 be Ci')

    5. (Let sto_0 be sto')

    6. If ((blockElementStatementIR* matches pattern _ :: _)), then

      1. (Let blockElementStatementIR_h :: blockElementStatementIR_t* be blockElementStatementIR*)

      2. Try matching path cons

  (path) nil Ci | sto | []

    1. Result in Ci, sto, []

  (path) cons Ci_0 | sto_0 | blockElementStatementIR_h :: blockElementStatementIR_t*

    1. (BlockElementStmt_inst: Ci_0 sto_0 |- blockElementStatementIR_h ==> Ci_1 sto_1 blockElementStatementIR'?)

    2. If ((blockElementStatementIR'? matches pattern (_))), then

      1. (Let ?(blockElementStatementIR_h') be blockElementStatementIR'?)

      2. (BlockElementStmts_inst: Ci_1 sto_1 |- blockElementStatementIR_t* ==> Ci_2 sto_2 blockElementStatementIR_t'*)

      3. Result in Ci_2, sto_2, blockElementStatementIR_h' :: blockElementStatementIR_t'*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:102.1-104.26
relation SwitchCases_inst

  (match) 





;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:106.1-108.26
relation SwitchCase_inst

  (match) p | Ci | sto | switchCaseIR

    1. Case analysis on switchCaseIR

      1. Case (% matches pattern `%:%`)

        1. (Let (switchLabelIR : blockStatementIR) be switchCaseIR)

        2. Try matching path match

      2. Case (% matches pattern `%:`)

        1. (Let (switchLabelIR :) be switchCaseIR)

        2. Try matching path fallthrough

  (path) match p | Ci | sto | (switchLabelIR : blockStatementIR)

    1. (Stmt_inst: p Ci sto |- (blockStatementIR as statementIR) ==> Ci' sto' statementIR)

    2. If ((statementIR has type blockStatementIR)), then

      1. (Let blockStatementIR' be (statementIR as blockStatementIR))

      2. Result in Ci', sto', (switchLabelIR : blockStatementIR')

  (path) fallthrough p | Ci | sto | (switchLabelIR :)

    1. Result in Ci, sto, (switchLabelIR :)

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:114.1-116.23
relation ParserStmt_inst

  (match) Ci' | sto' | parserStatementIR

    1. (Let Ci be Ci')

    2. (Let sto be sto')

    3. If ((parserStatementIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (parserStatementIR as constantDeclarationIR))

      2. Try matching path constantDeclarationIR

    4. (Let Ci be Ci')

    5. (Let sto be sto')

    6. If ((parserStatementIR has type variableDeclarationIR)), then

      1. (Let variableDeclarationIR be (parserStatementIR as variableDeclarationIR))

      2. Try matching path variableDeclarationIR

    7. (Let Ci_0 be Ci')

    8. (Let sto_0 be sto')

    9. If ((parserStatementIR has type emptyStatementIR)), then

      1. (Let emptyStatementIR be (parserStatementIR as emptyStatementIR))

      2. Try matching path emptyStatementIR

    10. (Let Ci_0 be Ci')

    11. (Let sto_0 be sto')

    12. If ((parserStatementIR has type assignmentStatementIR)), then

      1. (Let assignmentStatementIR be (parserStatementIR as assignmentStatementIR))

      2. Try matching path assignmentStatementIR

    13. (Let Ci_0 be Ci')

    14. (Let sto_0 be sto')

    15. If ((parserStatementIR has type callStatementIR)), then

      1. (Let callStatementIR be (parserStatementIR as callStatementIR))

      2. Try matching path callStatementIR

    16. (Let Ci_0 be Ci')

    17. (Let sto_0 be sto')

    18. If ((parserStatementIR has type directApplicationStatementIR)), then

      1. (Let directApplicationStatementIR be (parserStatementIR as directApplicationStatementIR))

      2. Try matching path directApplicationStatementIR

    19. (Let Ci_0 be Ci')

    20. (Let sto_0 be sto')

    21. If ((parserStatementIR has type parserBlockStatementIR)), then

      1. (Let (annotationList { parserStatementListIR }) be (parserStatementIR as parserBlockStatementIR))

      2. Try matching path parserBlockStatementIR

    22. (Let Ci_0 be Ci')

    23. (Let sto_0 be sto')

    24. If ((parserStatementIR has type conditionalStatementIR)), then

      1. (Let conditionalStatementIR be (parserStatementIR as conditionalStatementIR))

      2. Try matching path conditionalStatementIR

  (path) constantDeclarationIR Ci | sto | (constantDeclarationIR as parserStatementIR)

    1. Result in Ci, sto, ?((constantDeclarationIR as parserStatementIR))

  (path) variableDeclarationIR Ci | sto | (variableDeclarationIR as parserStatementIR)

    1. Result in Ci, sto, ?((variableDeclarationIR as parserStatementIR))

  (path) emptyStatementIR Ci_0 | sto_0 | (emptyStatementIR as parserStatementIR)

    1. (Stmt_inst: (local) Ci_0 sto_0 |- (emptyStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

    2. If ((statementIR has type emptyStatementIR)), then

      1. (Let emptyStatementIR_inst be (statementIR as emptyStatementIR))

      2. Result in Ci_1, sto_1, ?((emptyStatementIR_inst as parserStatementIR))

  (path) assignmentStatementIR Ci_0 | sto_0 | (assignmentStatementIR as parserStatementIR)

    1. (Stmt_inst: (local) Ci_0 sto_0 |- (assignmentStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

    2. If ((statementIR has type assignmentStatementIR)), then

      1. (Let assignmentStatementIR_inst be (statementIR as assignmentStatementIR))

      2. Result in Ci_1, sto_1, ?((assignmentStatementIR_inst as parserStatementIR))

  (path) callStatementIR Ci_0 | sto_0 | (callStatementIR as parserStatementIR)

    1. (Stmt_inst: (local) Ci_0 sto_0 |- (callStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

    2. If ((statementIR has type callStatementIR)), then

      1. (Let callStatementIR_inst be (statementIR as callStatementIR))

      2. Result in Ci_1, sto_1, ?((callStatementIR_inst as parserStatementIR))

  (path) directApplicationStatementIR Ci_0 | sto_0 | (directApplicationStatementIR as parserStatementIR)

    1. (Stmt_inst: (local) Ci_0 sto_0 |- (directApplicationStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

    2. If ((statementIR has type directApplicationStatementIR)), then

      1. (Let directApplicationStatementIR_inst be (statementIR as directApplicationStatementIR))

      2. Result in Ci_1, sto_1, ?((directApplicationStatementIR_inst as parserStatementIR))

  (path) parserBlockStatementIR Ci_0 | sto_0 | ((annotationList { parserStatementListIR }) as parserStatementIR)

    1. (ParserStmts_inst: Ci_0 sto_0 |- parserStatementListIR ==> Ci_1 sto_1 parserStatementListIR_inst)

    2. (Let parserBlockStatementIR be (annotationList { parserStatementListIR_inst }))

    3. Result in Ci_1, sto_1, ?((parserBlockStatementIR as parserStatementIR))

  (path) conditionalStatementIR Ci_0 | sto_0 | (conditionalStatementIR as parserStatementIR)

    1. (Stmt_inst: (local) Ci_0 sto_0 |- (conditionalStatementIR as statementIR) ==> Ci_1 sto_1 statementIR)

    2. If ((statementIR has type conditionalStatementIR)), then

      1. (Let conditionalStatementIR_inst be (statementIR as conditionalStatementIR))

      2. Result in Ci_1, sto_1, ?((conditionalStatementIR_inst as parserStatementIR))

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:118.1-120.23
relation ParserStmts_inst

  (match) Ci' | sto' | parserStatementIR*

    1. (Let Ci be Ci')

    2. (Let sto be sto')

    3. If ((parserStatementIR* matches pattern [])), then

      1. Try matching path nil

    4. (Let Ci_0 be Ci')

    5. (Let sto_0 be sto')

    6. If ((parserStatementIR* matches pattern _ :: _)), then

      1. (Let parserStatementIR_h :: parserStatementIR_t* be parserStatementIR*)

      2. Try matching path cons

  (path) nil Ci | sto | []

    1. Result in Ci, sto, []

  (path) cons Ci_0 | sto_0 | parserStatementIR_h :: parserStatementIR_t*

    1. (ParserStmt_inst: Ci_0 sto_0 |- parserStatementIR_h ==> Ci_1 sto_1 parserStatementIR'?)

    2. If ((parserStatementIR'? matches pattern (_))), then

      1. (Let ?(parserStatementIR_h') be parserStatementIR'?)

      2. (ParserStmts_inst: Ci_1 sto_1 |- parserStatementIR_t* ==> Ci_2 sto_2 parserStatementIR_t'*)

      3. Result in Ci_2, sto_2, parserStatementIR_h' :: parserStatementIR_t'*

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:122.1-124.23
relation ParserState_inst

  (match) Ci_0 | sto_0 | (annotationList state nameIR { parserStatementListIR transitionStatementIR })

    1. Try matching path 

  (path)  Ci_0 | sto_0 | (annotationList state nameIR { parserStatementListIR transitionStatementIR })

    1. (ParserStmts_inst: Ci_0 sto_0 |- parserStatementListIR ==> Ci_1 sto_1 parserStatementListIR_inst)

    2. Result in Ci_0, sto_0

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:126.1-128.23
relation ParserStates_inst

  (match) 





;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:131.1-133.26
relation Block_inst

  (match) Ci_0 | sto_0 | bool | (annotationList { blockElementStatementListIR })

    1. Case analysis on bool

      1. Case (% = true)

        1. Try matching path start

      2. Case (% = false)

        1. Try matching path no-start

  (path) start Ci_0 | sto_0 | true | (annotationList { blockElementStatementListIR })

    1. (BlockElementStmts_inst: Ci_0 sto_0 |- blockElementStatementListIR ==> Ci_1 sto_1 blockElementStatementListIR_inst)

    2. Result in Ci_1, sto_1, (annotationList { blockElementStatementListIR_inst })

  (path) no-start Ci_0 | sto_0 | false | (annotationList { blockElementStatementListIR })

    1. (Let Ci_1 be $enter_inst(Ci_0))

    2. (BlockElementStmts_inst: Ci_1 sto_0 |- blockElementStatementListIR ==> Ci_2 sto_1 blockElementStatementListIR_inst)

    3. (Let Ci_3 be $exit_inst(Ci_2))

    4. Result in Ci_2, sto_1, (annotationList { blockElementStatementListIR_inst })

;; ../../../../spec-concrete/6.03-instantiation-relation.watsup:135.1-137.26
relation Table_inst

  (match) 





;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:1.1-1.84
def $partition_default_parameters(parameterIR*, id_default*)

1. Case analysis on parameterIR*

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let parameterIR_h :: parameterIR_t* be parameterIR*)

    2. (Let (_annotationList _direction _typeIR id_h _constantInitializerOptIR) be parameterIR_h)

    3. (Let (parameterIR_nondefault*, parameterIR_default*) be $partition_default_parameters(parameterIR_t*, id_default*))

    4. Case analysis on id_h is in id_default*

      1. Case true

        1. Return (parameterIR_nondefault*, parameterIR_h :: parameterIR_default*)

      2. Case false

        1. Return (parameterIR_h :: parameterIR_nondefault*, parameterIR_default*)

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:24.1-24.146
def $align_cparams_with_args(constructorParameterIR*, argumentIR*, id_default*)

1. (Let (constructorParameterIR_nondefault*, constructorParameterIR_default*) be $partition_default_parameters(constructorParameterIR*, id_default*))

2. (Let (_annotationList _direction _typeIR id _constantInitializerOptIR) be constructorParameterIR_nondefault)*

3. (Let (constructorParameterIR_aligned*, argumentIR_aligned*) be $align_cparams_with_args'(({ (id : constructorParameterIR_nondefault)* }), constructorParameterIR_nondefault*, argumentIR*))

4. (Let (_annotationList' _direction' _typeIR' _nameIR constantInitializerOptIR) be constructorParameterIR_default)*

5. If ((constantInitializerOptIR matches pattern (_)))*, then

  1. (Let ?((= value_default)) be constantInitializerOptIR)*

  2. Return (constructorParameterIR_aligned*, argumentIR_aligned*, constructorParameterIR_default*, value_default*)

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:25.1-25.142
def $align_cparams_with_args'(({ (id_map : constructorParameterIR_map)* }), constructorParameterIR*, argumentIR*)

1. Case analysis on constructorParameterIR*

  1. Case (% matches pattern _ :: _)

    1. (Let constructorParameterIR_h :: constructorParameterIR_t* be constructorParameterIR*)

    2. If ((argumentIR* matches pattern _ :: _)), then

      1. (Let argumentIR_h :: argumentIR_t* be argumentIR*)

      2. (Let argumentIR' be argumentIR_h)

      3. If ((argumentIR' has type typedExpressionIR)), then

        1. (Let typedExpressionIR be (argumentIR' as typedExpressionIR))

        2. (Let (constructorParameterIR_aligned*, argumentIR_aligned*) be $align_cparams_with_args'(({ (id_map : constructorParameterIR_map)* }), constructorParameterIR_t*, argumentIR_t*))

        3. Return (constructorParameterIR_h :: constructorParameterIR_aligned*, argumentIR_h :: argumentIR_aligned*)

      4. If ((argumentIR_h matches pattern `_`)), then

        1. (Let (constructorParameterIR_aligned*, argumentIR_aligned*) be $align_cparams_with_args'(({ (id_map : constructorParameterIR_map)* }), constructorParameterIR_t*, argumentIR_t*))

        2. Return (constructorParameterIR_h :: constructorParameterIR_aligned*, argumentIR_h :: argumentIR_aligned*)

      5. If ((argumentIR' matches pattern `%=%`)), then

        1. (Let (nameIR = _typedExpressionIR) be argumentIR')

        2. (Let constructorParameterIR'? be $find_map<id, constructorParameterIR>(({ (id_map : constructorParameterIR_map)* }), nameIR))

        3. If ((constructorParameterIR'? matches pattern (_))), then

          1. (Let ?(constructorParameterIR_matching) be constructorParameterIR'?)

          2. (Let (constructorParameterIR_aligned*, argumentIR_aligned*) be $align_cparams_with_args'(({ (id_map : constructorParameterIR_map)* }), constructorParameterIR_t*, argumentIR_t*))

          3. Return (constructorParameterIR_matching :: constructorParameterIR_aligned*, argumentIR_h :: argumentIR_aligned*)

  2. Case (% matches pattern [])

    1. If ((argumentIR* matches pattern [])), then

      1. Return ([], [])

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:70.1-72.32
relation Eval_args

  (match) p | p_callee | Ci_0 | sto_0 | id* | argumentIR*

    1. Case analysis on id*

      1. Case (% matches pattern [])

        1. If ((argumentIR* matches pattern [])), then

          1. Try matching path nil

      2. Case (% matches pattern _ :: _)

        1. (Let id_h :: id_t* be id*)

        2. If ((argumentIR* matches pattern _ :: _)), then

          1. (Let argumentIR_h :: argumentIR_t* be argumentIR*)

          2. Try matching path cons

  (path) nil p | p_callee | Ci_0 | sto_0 | [] | []

    1. Result in Ci_0, sto_0

  (path) cons p | p_callee | Ci_0 | sto_0 | id_h :: id_t* | argumentIR_h :: argumentIR_t*

    1. (Eval_arg: p p_callee Ci_0 sto_0 |- id_h argumentIR_h ==> Ci_1 sto_1)

    2. (Eval_args: p p_callee Ci_1 sto_1 |- id_t* argumentIR_t* ==> Ci_2 sto_2)

    3. Result in Ci_2, sto_2

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:74.1-76.32
relation Eval_arg

  (match) p | p_callee | Ci_0 | sto_0 | id | argumentIR

    1. Try matching path 

  (path)  p | p_callee | Ci_0 | sto_0 | id | argumentIR

    1. (Let Ci_caller be $enter_path(Ci_0, id))

    2. (Argument_inst: p Ci_caller sto_0 |- argumentIR ==> sto_1 value)

    3. (Let Ci_1 be $add_value_inst(p_callee, Ci_0, id, value))

    4. Result in Ci_1, sto_1

;; ../../../../spec-concrete/6.04-instantiation-constructor.watsup:170.1-170.59
def $init_table(tablePropertyListIR)

1. Return tablePropertyListIR

;; ../../../../spec-concrete/6.05-instantiation-expression.watsup:408.1-408.34
def $size



;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:24.1-24.70
def $get_init_decls



;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:38.1-38.37
def $is_extern_object(objDyn')

1. (Let objDyn be objDyn')

2. If ((objDyn matches pattern `EXTERN{%%%%}`)), then

  1. (Let (extern{ _tid _theta _venv _renv }) be objDyn)

  2. Return true

3. (Let _objDyn be objDyn')

4. Return false

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:60.1-60.43
def $rid_IR(nameIR, parameterIR*)

1. Return (nameIR ( $pid_IR(parameterIR)* ))

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:61.1-61.31
def $pid_IR((_annotationList _direction _typeIR nameIR constantInitializerOptIR'))

1. (Let constantInitializerIR? be constantInitializerOptIR')

2. If ((constantInitializerIR? matches pattern ())), then

  1. Return (nameIR # false)

3. (Let constantInitializerOptIR be constantInitializerOptIR')

4. If ((constantInitializerOptIR matches pattern (_))), then

  1. (Let ?(constantInitializerIR) be constantInitializerOptIR)

  2. Return (nameIR # true)

;; ../../../../spec-concrete/6.08-instantiation-declaration.watsup:68.1-68.54
def $cid_IR(nameIR, constructorParameterListIR)

1. Return $rid_IR(nameIR, constructorParameterListIR)
