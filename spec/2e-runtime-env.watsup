;;
;; Forward declarations of mutually recursive syntax
;;

syntax ctk

;;
;; Static type representation
;;

syntax styp = typ dir ctk val?

;;
;; Environments
;;

;; Map from variable identifiers to static types
syntax frame = map<id, styp>

dec $empty_frame() : frame
def $empty_frame() = $empty_map<id, styp>

;; Map from type identifiers to type definitions
syntax tdenv = map<tid, typdef>

dec $empty_tdenv() : tdenv
def $empty_tdenv() = $empty_map<tid, typdef>

;; Map from function identifiers to function definitions
syntax fdenv = map<fid, funcdef>

dec $empty_fdenv() : fdenv
def $empty_fdenv() = $empty_map<fid, funcdef>

;; Map from constructor identifiers to constructor definitions
syntax cdenv = map<fid, consdef>

dec $empty_cdenv() : cdenv
def $empty_cdenv() = $empty_map<cid, consdef>

;;
;; Function/method overload resolution
;;

dec $check_func_name(id, id) : bool
def $check_func_name(id_l, id_r) = id_l = id_r

dec $check_arity_more((id?)*, id*) : bool
def $check_arity_more((id_a?)*, id_p*) = |(id_a?)*| > |id_p*|

dec $check_arity((id?)*, id*) : bool
def $check_arity((id_a?)*, id_p*) = |(id_a?)*| = |id_p*|

dec $check_arity_less((id?)*, id*) : bool
def $check_arity_less((id_a?)*, id_p*) = |(id_a?)*| < |id_p*|

dec $get_params_missing_names((id, bool)*, id*) : id*

def $get_params_missing_names(eps, id_a*) = eps

def $get_params_missing_names(
    (id_p_h, true) :: (id_p_t, bool_p_t)*,
    id_a*
  )
  = id_p_h :: $get_params_missing_names((id_p_t, bool_p_t)*, id_a*)
  -- if ~$in_set<id>(id_p_h, `{ id_a* })

def $get_params_missing_names(
    (id_p_h, bool_p_h) :: (id_p_t, bool_p_t)*,
    id_a*
  )
  = $get_params_missing_names((id_p_t, bool_p_t)*, id_a*)
  -- otherwise

;; Check match between parameters and named arguments
dec $find_match_named<V>(fid, V, id*, (id, bool)*) : (fid, V, id*)?

def $find_match_named<V>(fid, V, id_a*, (id_p, bool_p)*) = (fid, V, eps)
  -- if $eq_set<id>(`{ id_a* }, `{ id_p* })

def $find_match_named<V>(fid, V, id_a*, (id_p, bool_p)*) = eps
  -- otherwise

;; Check match between parameters and named arguments, with default arguments
dec $find_match_named_default<V>(fid, V, id*, (id, bool)*) : (fid, V, id*)?

def $find_match_named_default<V>(fid, V, id_a*, (id_p, bool_p)*) = (fid, V, id_deft*)
  -- if id_deft* = $get_params_missing_names((id_p, bool_p)*, id_a*)
  -- if $find_match_named<V>(fid, V, id_a* ++ id_deft*, (id_p, bool_p)*) =/= eps

def $find_match_named_default<V>(fid, V, id_a*, (id_p, bool_p)*) = eps
  -- otherwise

;; Check match between parameters and unnamed arguments, with default arguments
dec $find_match_unnamed_default<V>(fid, V, (id?)*, (id, bool)*) : (fid, V, id*)?

def $find_match_unnamed_default<V>(fid, V, (id_a?)*, (id_p, bool_p)*) = (fid, V, id_deft*)
  -- if ((id, bool)*, (id_deft, true)*) = $partition_<(id, bool)>((id_p, bool_p)*, |(id_a?)*|)

def $find_match_unnamed_default<V>(fid, V, (id_a?)*, (id_p, bool_p)*) = eps
  -- otherwise

;; Check if a function matches the given name and arguments
dec $find_matching_func<V>(id, (id?)*, id*, fid, V) : (fid, V, id*)?

;; When function names do not match
def $find_matching_func<V>(id_f, (id_a?)*, id_a'*, id_f' (id_p, bool_p)*, V) = eps
  -- if ~$check_func_name(id_f, id_f')

;; When function names match, but the arity of arguments is greater than that of parameters
def $find_matching_func<V>(id_f, (id_a?)*, id_a'*, id_f' (id_p, bool_p)*, V) = eps
  -- if $check_func_name(id_f, id_f')
  -- if $check_arity_more((id_a?)*, id_p*)

;; When function names and arity match on named arguments, i.e., no default arguments
def $find_matching_func<V>(id_f, (id_a?)*, id_a'*, id_f' (id_p, bool_p)*, V)
    = $find_match_named<V>(id_f' (id_p, bool_p)*, V, id_a'*, (id_p, bool_p)*)
  -- if |id_a'*| > 0
  -- if $check_func_name(id_f, id_f')
  -- if $check_arity((id_a?)*, id_p*)

;; When function names and arity match on unnamed arguments, i.e., no default arguments
def $find_matching_func<V>(id_f, (id_a?)*, eps, id_f' (id_p, bool_p)*, V) = (id_f' (id_p, bool_p)*, V, eps)
  -- if $check_func_name(id_f, id_f')
  -- if $check_arity((id_a?)*, id_p*)

;; When function names match and arity is less than that of parameters, with named arguments
def $find_matching_func<V>(id_f, (id_a?)*, id_a'*, id_f' (id_p, bool_p)*, V)
    = $find_match_named_default<V>(id_f' (id_p, bool_p)*, V, id_a'*, (id_p, bool_p)*)
  -- if |id_a'*| > 0
  -- if $check_func_name(id_f, id_f')
  -- if $check_arity_less((id_a?)*, id_p*)

;; When function names match and arity is less than that of parameters, with unnamed arguments
def $find_matching_func<V>(id_f, (id_a?)*, eps, id_f' (id_p, bool_p)*, V)
    = $find_match_unnamed_default<V>(id_f' (id_p, bool_p)*, V, (id_a?)*, (id_p, bool_p)*)
  -- if $check_func_name(id_f, id_f')
  -- if $check_arity_less((id_a?)*, id_p*)

;; Find all functions that match the given name and arguments
dec $find_matching_funcs<V>(id, (id?)*, id*, fid*, V*) : (fid, V, id*)*

def $find_matching_funcs<V>(id_f, (id_a?)*, id_a'*, eps, eps) = eps

def $find_matching_funcs<V>(id_f, (id_a?)*, id_a'*, fid_h :: fid_t*, V_h :: V_t*)
    = $find_matching_funcs<V>(id_f, (id_a?)*, id_a'*, fid_t*, V_t*)
  -- if $find_matching_func<V>(id_f, (id_a?)*, id_a'*, fid_h, V_h) = eps

def $find_matching_funcs<V>(id_f, (id_a?)*, id_a'*, fid_h :: fid_t*, V_h :: V_t*)
    = (fid, V, id_deft*) :: $find_matching_funcs<V>(id_f, (id_a?)*, id_a'*, fid_t*, V_t*)
  -- if (fid, V, id_deft*) = $find_matching_func<V>(id_f, (id_a?)*, id_a'*, fid_h, V_h)

;; Find a matching function, given a function name and arguments
dec $find_func<V>(id, (id?)*, map<fid, V>) : (fid, V, id*)?

;; When all arguments are named
def $find_func<V>(id_f, (id_a?)*, `{ (fid -> V)* }) = eps
  -- if |(id_a?)*| > 0
  -- if (id_a? = id_a')*
  -- if $find_matching_funcs<V>(id_f, (id_a?)*, id_a'*, fid*, V*) = eps

def $find_func<V>(id_f, (id_a?)*, `{ (fid -> V)* }) = (fid', V', id_deft*)
  -- if |(id_a?)*| > 0
  -- if (id_a? = id_a')*
  -- if (fid', V', id_deft*) = $find_matching_funcs<V>(id_f, (id_a?)*, id_a'*, fid*, V*)

;; When all arguments are unnamed
def $find_func<V>(id_f, (id_a?)*, `{ (fid -> V)* }) = eps
  -- if (id_a? = eps)*
  -- if $find_matching_funcs<V>(id_f, (id_a?)*, eps, fid*, V*) = eps

def $find_func<V>(id_f, (id_a?)*, `{ (fid -> V)* }) = (fid', V', id_deft*)
  -- if (id_a? = eps)*
  -- if (fid', V', id_deft*) = $find_matching_funcs<V>(id_f, (id_a?)*, eps, fid*, V*)

;; Find all functions that match the given name
dec $find_funcs_by_name<V>(id, fid*, V*) : (fid, V)*

def $find_funcs_by_name<V>(id_f, eps, eps) = eps
def $find_funcs_by_name<V>(id_f, (id_h (id_p_h, bool_p_h)*) :: fid_t*, V_h :: V_t*)
    = (id_h (id_p_h, bool_p_h)*, V_h) :: $find_funcs_by_name<V>(id_f, fid_t*, V_t*)
  -- if id_f = id_h
def $find_funcs_by_name<V>(id_f, _ :: fid_t*, _ :: V_t*)
    = $find_funcs_by_name<V>(id_f, fid_t*, V_t*)
  -- otherwise
  
;; Find a matching function, given a function name only
dec $find_func_by_name(id, map<fid, funcdef>) : (fid, funcdef)?

def $find_func_by_name(id_f, `{ (fid -> fd)* }) = eps
  -- if eps = $find_funcs_by_name<funcdef>(id_f, fid*, fd*)
def $find_func_by_name(id_f, `{ (fid -> fd)* }) = (fid_f, fd_f)
  -- if (fid_f, fd_f) = $find_funcs_by_name<funcdef>(id_f, fid*, fd*)
