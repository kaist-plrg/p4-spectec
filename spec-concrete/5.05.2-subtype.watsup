;;
;; Explicit subtyping
;;

rule Sub_expl:
  typeIR_a <: typeIR_b
  -- if typeIR_a_canon = $canon(typeIR_a)
  -- if typeIR_b_canon = $canon(typeIR_b)
  -- Sub_expl_canon: typeIR_a_canon <: typeIR_b_canon

rule Sub_expl_canon/equals:
  typeIR_a <: typeIR_b
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Sub_expl_canon/not-equals:
  typeIR_a <: typeIR_b
  -- Type_alpha:/ typeIR_a ~~ typeIR_b
  -- Sub_expl_canon_neq: typeIR_a <: typeIR_b

;;
;;;; Explicit subtyping, when types are unequal
;;

rule Sub_expl_canon_neq/boolean-fixbit:
  BOOL <: BIT `< 1 >

rulegroup Sub_expl_canon_neq/arbint {

  rule Sub_expl_canon_neq/boolean:
    INT <: BOOL

  rule Sub_expl_canon_neq/fixint:
    INT <: INT `< _ >

  rule Sub_expl_canon_neq/fixbit:
    INT <: BIT `< _ >

}

rulegroup Sub_expl_canon_neq/fixint {

  rule Sub_expl_canon_neq/arbint:
    INT `< _ > <: INT

  rule Sub_expl_canon_neq/fixint:
    INT `< w_a > <: INT `< w_b >

  rule Sub_expl_canon_neq/fixbit:
    INT `< w > <: BIT `< w >

}

rulegroup Sub_expl_canon_neq/fixbit {

  rule Sub_expl_canon_neq/boolean:
    BIT `< 1 > <: BOOL

  rule Sub_expl_canon_neq/arbint:
    BIT `< _ > <: INT

  rule Sub_expl_canon_neq/fixint:
    BIT `< w > <: INT `< w >

  rule Sub_expl_canon_neq/fixbit:
    BIT `< w_a > <: BIT `< w_b >

}

rulegroup Sub_expl_canon_neq/newtype {

  rule Sub_expl_canon_neq/left:
    TYPE _ typeIR_a <: typeIR_b
    -- Sub_impl: typeIR_a <: typeIR_b

  rule Sub_expl_canon_neq/right:
    typeIR_a <: TYPE _ typeIR_b
    -- Sub_impl: typeIR_a <: typeIR_b

}

rulegroup Sub_expl_canon_neq/serenum {

  rule Sub_expl_canon_neq/left:
    ENUM _ `# typeIR_a `{ _ } <: typeIR_b
    -- Sub_impl: typeIR_a <: typeIR_b

  rule Sub_expl_canon_neq/right:
    typeIR_a <: ENUM _ `# typeIR_b `{ _ }
    -- Sub_impl: typeIR_a <: typeIR_b

}

rule Sub_expl_canon_neq/default:
  DEFAULT <: typeIR_b
  -- if $is_defaultable_typeIR(typeIR_b)

rulegroup Sub_expl_canon_neq/invalidheader {

  rule Sub_expl_canon_neq/header:
    HEADER_INVALID <: HEADER _ `{ _ }

  rule Sub_expl_canon_neq/headerunion:
    HEADER_INVALID <: HEADER_UNION _ `{ _ }
}

rulegroup Sub_expl_canon_neq/seq {

  rule Sub_expl_canon_neq/list:
    SEQ `< typeIR_a* > <: LIST `< typeIR_b >
    -- (Sub_expl: typeIR_a <: typeIR_b)*

  rule Sub_expl_canon_neq/tuple:
    SEQ `< typeIR_a* > <: TUPLE `< typeIR_b* >
    -- (Sub_expl: typeIR_a <: typeIR_b)*

  rule Sub_expl_canon_neq/headerstack:
    SEQ `< typeIR_a* > <: typeIR_b `[ n_size ]
    -- if $(|typeIR_a*| <= n_size)
    -- (Sub_expl: typeIR_a <: typeIR_b)*

  rule Sub_expl_canon_neq/struct:
    SEQ `< typeIR_a* > <: STRUCT _ `{ (typeIR_b _ `;)* }
    -- (Sub_expl: typeIR_a <: typeIR_b)*

  rule Sub_expl_canon_neq/header:
    SEQ `< typeIR_a* > <: HEADER _ `{ (typeIR_b _ `;)* }
    -- (Sub_expl: typeIR_a <: typeIR_b)*

}

rulegroup Sub_expl_canon_neq/seqdefault {

  rule Sub_expl_canon_neq/tuple:
    SEQ `< typeIR_a* `, `... > <: TUPLE `< typeIR_b* >
    -- if $(|typeIR_a*| < |typeIR_b*|)
    -- if (typeIR_b_non_default*, typeIR_b_default*)
        = $partition_<typeIR>(typeIR_b*, |typeIR_a*|)
    -- (Sub_expl: typeIR_a <: typeIR_b_non_default)*
    -- if $is_defaultable_typeIR(typeIR_b_default)*

  rule Sub_expl_canon_neq/headerstack:
    SEQ `< typeIR_a* `, `... > <: typeIR_b `[ n_size ]
    -- if $(|typeIR_a*| < n_size)
    -- (Sub_expl: typeIR_a <: typeIR_b)*
    -- if $is_defaultable_typeIR(typeIR_b)

  rule Sub_expl_canon_neq/struct:
    SEQ `< typeIR_a* `, `... > <: STRUCT _ `{ (typeIR_b _ `;)* }
    -- if $(|typeIR_a*| < |typeIR_b*|)
    -- if (typeIR_b_non_default*, typeIR_b_default*)
        = $partition_<typeIR>(typeIR_b*, |typeIR_a*|)
    -- (Sub_expl: typeIR_a <: typeIR_b_non_default)*
    -- if $is_defaultable_typeIR(typeIR_b_default)*

  rule Sub_expl_canon_neq/header:
    SEQ `< typeIR_a* `, `... > <: HEADER _ `{ (typeIR_b _ `;)* }
    -- if $(|typeIR_a*| < |typeIR_b*|)
    -- if (typeIR_b_non_default*, typeIR_b_default*)
        = $partition_<typeIR>(typeIR_b*, |typeIR_a*|)
    -- (Sub_expl: typeIR_a <: typeIR_b_non_default)*
    -- if $is_defaultable_typeIR(typeIR_b_default)*

}

rulegroup Sub_expl_canon_neq/record {

  rule Sub_expl_canon_neq/struct:
    RECORD `{ (typeIR_a id_a `;)* } <: STRUCT _ `{ (typeIR_b id_b `;)* }
    -- if $eq_set<id>(`{ id_a* }, `{ id_b* })
    -- if (typeIR_a_aligned
          = $find_map<id, typeIR>(`{ (id_a `: typeIR_a)* }, id_a))*
    -- if (typeIR_b_aligned
          = $find_map<id, typeIR>(`{ (id_b `: typeIR_b)* }, id_a))*
    -- (Sub_expl: typeIR_a_aligned <: typeIR_b_aligned)*

  rule Sub_expl_canon_neq/header:
    RECORD `{ (typeIR_a id_a `;)* } <: HEADER _ `{ (typeIR_b id_b `;)* }
    -- if $eq_set<id>(`{ id_a* }, `{ id_b* })
    -- if (typeIR_a_aligned
          = $find_map<id, typeIR>(`{ (id_a `: typeIR_a)* }, id_a))*
    -- if (typeIR_b_aligned
          = $find_map<id, typeIR>(`{ (id_b `: typeIR_b)* }, id_a))*
    -- (Sub_expl: typeIR_a_aligned <: typeIR_b_aligned)*

}

rulegroup Sub_expl_canon_neq/recorddefault {

  rule Sub_expl_canon_neq/struct:
    RECORD `{ (typeIR_a id_a `;)* `, `... } <: STRUCT _ `{ (typeIR_b id_b `;)* }
    -- if $sub_set<id>(`{ id_a* }, `{ id_b* })
    ----
    -- if (typeIR_a_aligned
          = $find_map<id, typeIR>(`{ (id_a `: typeIR_a)* }, id_a))*
    -- if (typeIR_b_non_default_aligned
          = $find_map<id, typeIR>(`{ (id_b `: typeIR_b)* }, id_a))*
    -- (Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned)*
    ----
    -- if `{ id_default* } = $diff_set<id>(`{ id_b* }, `{ id_a* })
    -- if (typeIR_b_default
          = $find_map<id, typeIR>(`{ (id_b `: typeIR_b)* }, id_default))*
    -- if $is_defaultable_typeIR(typeIR_b_default)*

  rule Sub_expl_canon_neq/header:
    RECORD `{ (typeIR_a id_a `;)* `, `... } <: HEADER _ `{ (typeIR_b id_b `;)* }
    -- if $sub_set<id>(`{ id_a* }, `{ id_b* })
    ----
    -- if (typeIR_a_aligned
          = $find_map<id, typeIR>(`{ (id_a `: typeIR_a)* }, id_a))*
    -- if (typeIR_b_non_default_aligned
          = $find_map<id, typeIR>(`{ (id_b `: typeIR_b)* }, id_a))*
    -- (Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned)*
    ----
    -- if `{ id_default* } = $diff_set<id>(`{ id_b* }, `{ id_a* })
    -- if (typeIR_b_default
          = $find_map<id, typeIR>(`{ (id_b `: typeIR_b)* }, id_default))*
    -- if $is_defaultable_typeIR(typeIR_b_default)*

}

rulegroup Sub_expl_canon_neq/set {

  rule Sub_expl_canon_neq/set:
    SET `< typeIR_a > <: SET `< typeIR_b >
    -- Sub_expl: typeIR_a <: typeIR_b

  rule Sub_expl_canon_neq/non-set:
    typeIR_a <: SET `< typeIR_b >
    -- if ~$is_set_typeIR(typeIR_a)
    -- Sub_expl: typeIR_a <: typeIR_b

}

;;
;; Implicit subtyping
;;

rule Sub_impl:
  typeIR_a <: typeIR_b
  -- if typeIR_a_canon = $canon(typeIR_a)
  -- if typeIR_b_canon = $canon(typeIR_b)
  -- Sub_impl_canon: typeIR_a_canon <: typeIR_b_canon

rule Sub_impl_canon/equals:
  typeIR_a <: typeIR_b
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Sub_impl_canon/not-equals:
  typeIR_a <: typeIR_b
  -- Type_alpha:/ typeIR_a ~~ typeIR_b
  -- Sub_impl_canon_neq: typeIR_a <: typeIR_b

;;
;;;; Implicit subtyping, when types are unequal
;;

rulegroup Sub_impl_canon_neq/arbint {

  rule Sub_impl_canon_neq/fixint:
    INT <: INT `< _ >

  rule Sub_impl_canon_neq/fixbit:
    INT <: BIT `< _ >

}

rule Sub_impl_canon_neq/serenum-left:
  ENUM _ `# typeIR_a `{ _ } <: typeIR_b
  -- Sub_impl: typeIR_a <: typeIR_b

rule Sub_impl_canon_neq/default:
  DEFAULT <: typeIR_b
  -- if $is_defaultable_typeIR(typeIR_b)

rulegroup Sub_impl_canon_neq/invalidheader {

  rule Sub_impl_canon_neq/header:
    HEADER_INVALID <: HEADER _ `{ _ }

  rule Sub_impl_canon_neq/headerunion:
    HEADER_INVALID <: HEADER_UNION _ `{ _ }
}

rulegroup Sub_impl_canon_neq/seq {

  rule Sub_impl_canon_neq/list:
    SEQ `< typeIR_a* > <: LIST `< typeIR_b >
    -- (Sub_impl: typeIR_a <: typeIR_b)*

  rule Sub_impl_canon_neq/tuple:
    SEQ `< typeIR_a* > <: TUPLE `< typeIR_b* >
    -- (Sub_impl: typeIR_a <: typeIR_b)*

  rule Sub_impl_canon_neq/headerstack:
    SEQ `< typeIR_a* > <: typeIR_b `[ n_size ]
    -- if $(|typeIR_a*| <= n_size)
    -- (Sub_impl: typeIR_a <: typeIR_b)*

  rule Sub_impl_canon_neq/struct:
    SEQ `< typeIR_a* > <: STRUCT _ `{ (typeIR_b _ `;)* }
    -- (Sub_impl: typeIR_a <: typeIR_b)*

  rule Sub_impl_canon_neq/header:
    SEQ `< typeIR_a* > <: HEADER _ `{ (typeIR_b _ `;)* }
    -- (Sub_impl: typeIR_a <: typeIR_b)*

  rule Sub_impl_canon_neq/seq:
    SEQ `< typeIR_a* > <: SEQ `< typeIR_b* >
    -- (Sub_impl: typeIR_a <: typeIR_b)*

}

rulegroup Sub_impl_canon_neq/seqdefault {

  rule Sub_impl_canon_neq/tuple:
    SEQ `< typeIR_a* `, `... > <: TUPLE `< typeIR_b* >
    -- if $(|typeIR_a*| < |typeIR_b*|)
    -- if (typeIR_b_non_default*, typeIR_b_default*)
        = $partition_<typeIR>(typeIR_b*, |typeIR_a*|)
    -- (Sub_impl: typeIR_a <: typeIR_b_non_default)*
    -- if $is_defaultable_typeIR(typeIR_b_default)*

  rule Sub_impl_canon_neq/stack:
    SEQ `< typeIR_a* `, `... > <: typeIR_b `[ n_size ]
    -- if $(|typeIR_a*| < n_size)
    -- (Sub_impl: typeIR_a <: typeIR_b)*
    -- if $is_defaultable_typeIR(typeIR_b)

  rule Sub_impl_canon_neq/struct:
    SEQ `< typeIR_a* `, `... > <: STRUCT _ `{ (typeIR_b _ `;)* }
    -- if $(|typeIR_a*| < |typeIR_b*|)
    -- if (typeIR_b_non_default*, typeIR_b_default*)
        = $partition_<typeIR>(typeIR_b*, |typeIR_a*|)
    -- (Sub_impl: typeIR_a <: typeIR_b_non_default)*
    -- if $is_defaultable_typeIR(typeIR_b_default)*

  rule Sub_impl_canon_neq/header:
    SEQ `< typeIR_a* `, `... > <: HEADER _ `{ (typeIR_b _ `;)* }
    -- if $(|typeIR_a*| < |typeIR_b*|)
    -- if (typeIR_b_non_default*, typeIR_b_default*)
        = $partition_<typeIR>(typeIR_b*, |typeIR_a*|)
    -- (Sub_impl: typeIR_a <: typeIR_b_non_default)*
    -- if $is_defaultable_typeIR(typeIR_b_default)*

}

rulegroup Sub_impl_canon_neq/record {

  rule Sub_impl_canon_neq/struct:
    RECORD `{ (typeIR_a id_a `;)* } <: STRUCT _ `{ (typeIR_b id_b `;)* }
    -- if $eq_set<id>(`{ id_a* }, `{ id_b* })
    -- if (typeIR_a_aligned
          = $find_map<id, typeIR>(`{ (id_a `: typeIR_a)* }, id_a))*
    -- if (typeIR_b_aligned
          = $find_map<id, typeIR>(`{ (id_b `: typeIR_b)* }, id_a))*
    -- (Sub_impl: typeIR_a_aligned <: typeIR_b_aligned)*

  rule Sub_impl_canon_neq/header:
    RECORD `{ (typeIR_a id_a `;)* } <: HEADER _ `{ (typeIR_b id_b `;)* }
    -- if $eq_set<id>(`{ id_a* }, `{ id_b* })
    -- if (typeIR_a_aligned
          = $find_map<id, typeIR>(`{ (id_a `: typeIR_a)* }, id_a))*
    -- if (typeIR_b_aligned
          = $find_map<id, typeIR>(`{ (id_b `: typeIR_b)* }, id_a))*
    -- (Sub_impl: typeIR_a_aligned <: typeIR_b_aligned)*

}

rulegroup Sub_impl_canon_neq/recorddefault {

  rule Sub_impl_canon_neq/struct:
    RECORD `{ (typeIR_a id_a `;)* `, `... } <: STRUCT _ `{ (typeIR_b id_b `;)* }
    -- if $sub_set<id>(`{ id_a* }, `{ id_b* })
    ----
    -- if (typeIR_a_aligned
          = $find_map<id, typeIR>(`{ (id_a `: typeIR_a)* }, id_a))*
    -- if (typeIR_b_non_default_aligned
          = $find_map<id, typeIR>(`{ (id_b `: typeIR_b)* }, id_a))*
    -- (Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned)*
    ----
    -- if `{ id_default* } = $diff_set<id>(`{ id_b* }, `{ id_a* })
    -- if (typeIR_b_default
          = $find_map<id, typeIR>(`{ (id_b `: typeIR_b)* }, id_default))*
    -- if $is_defaultable_typeIR(typeIR_b_default)*

  rule Sub_impl_canon_neq/header:
    RECORD `{ (typeIR_a id_a `;)* `, `... } <: HEADER _ `{ (typeIR_b id_b `;)* }
    -- if $sub_set<id>(`{ id_a* }, `{ id_b* })
    ----
    -- if (typeIR_a_aligned
          = $find_map<id, typeIR>(`{ (id_a `: typeIR_a)* }, id_a))*
    -- if (typeIR_b_non_default_aligned
          = $find_map<id, typeIR>(`{ (id_b `: typeIR_b)* }, id_a))*
    -- (Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned)*
    ----
    -- if `{ id_default* } = $diff_set<id>(`{ id_b* }, `{ id_a* })
    -- if (typeIR_b_default
          = $find_map<id, typeIR>(`{ (id_b `: typeIR_b)* }, id_default))*
    -- if $is_defaultable_typeIR(typeIR_b_default)*

}

;;
;; Serializable enum reduction
;;
;; Reduce serializable enums to their underlying types,
;; until the expression satisfies the given check
;;

;;; Unary case

dec $reduce_serenum_unary(
    typedExpressionIR,
    def $check(typeIR) : bool
  )
  : typedExpressionIR?


def $reduce_serenum_unary(typedExpressionIR, def $check)
  = typedExpressionIR
  -- if _ `# `( typeIR _ ) = typedExpressionIR
  -- if $check(typeIR)

def $reduce_serenum_unary(typedExpressionIR, def $check)
  = $reduce_serenum_unary(typedExpressionIR_cast, def $check)
  -- if _ `# `( typeIR ctk ) = typedExpressionIR
  -- if ~$check(typeIR)
  -- if ENUM _ `# typeIR_underlying `{ _ } = typeIR
  -- if typedExpressionIR_cast
      = (`(typeIR_underlying) typedExpressionIR) `# `( typeIR_underlying ctk )

def $reduce_serenum_unary(typedExpressionIR, def $check) = eps
  -- otherwise

;;; Binary case

dec $reduce_serenum_binary(
    typedExpressionIR,
    typedExpressionIR,
    def $check(typeIR, typeIR) : bool
  )
  : (typedExpressionIR, typedExpressionIR)?

def $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, def $check)
  = (typedExpressionIR_l, typedExpressionIR_r)
  -- if _ `# `( typeIR_l _ ) = typedExpressionIR_l
  -- if _ `# `( typeIR_r _ ) = typedExpressionIR_r
  -- if $check(typeIR_l, typeIR_r)

def $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, def $check)
  = ($reduce_serenum_binary(
      typedExpressionIR_l_cast, typedExpressionIR_r, def $check))
  -- if _ `# `( typeIR_l ctk_l ) = typedExpressionIR_l
  -- if _ `# `( typeIR_r _ ) = typedExpressionIR_r
  -- if ~$check(typeIR_l, typeIR_r)
  -- if ENUM _ `# typeIR_l_underlying `{ _ } = typeIR_l
  -- if typedExpressionIR_l_cast
      = (`(typeIR_l_underlying) typedExpressionIR_l) `# `( typeIR_l_underlying ctk_l )

def $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, def $check)
  = ($reduce_serenum_binary(
      typedExpressionIR_l, typedExpressionIR_r_cast, def $check))
  -- if _ `# `( typeIR_l _ ) = typedExpressionIR_l
  -- if _ `# `( typeIR_r ctk_r ) = typedExpressionIR_r
  -- if ~$check(typeIR_l, typeIR_r)
  -- if ENUM _ `# typeIR_r_underlying `{ _ } = typeIR_r
  -- if typedExpressionIR_r_cast
      = (`(typeIR_r_underlying) typedExpressionIR_r) `# `( typeIR_r_underlying ctk_r )

def $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, def $check) = eps
  -- otherwise

;;
;; Coercions
;;
;; Try to coerce an expression to a given type,
;; and for binary case, one expression to another
;;

;;; Unary

dec $coerce_unary(typedExpressionIR, typeIR) : typedExpressionIR?

def $coerce_unary(typedExpressionIR, typeIR_to) = typedExpressionIR
  -- if _ `# `( typeIR _ ) = typedExpressionIR
  -- Type_alpha: typeIR ~~ typeIR_to

def $coerce_unary(typedExpressionIR, typeIR_to) = typedExpressionIR_cast
  -- if _ `# `( typeIR ctk ) = typedExpressionIR
  -- Type_alpha:/ typeIR ~~ typeIR_to
  -- Sub_impl: typeIR <: typeIR_to
  -- if typedExpressionIR_cast
      = (`(typeIR_to) typedExpressionIR) `# `( typeIR_to ctk )

;;; Binary

dec $coerce_binary(typedExpressionIR, typedExpressionIR)
  : (typedExpressionIR, typedExpressionIR)?

def $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  = (typedExpressionIR_l, typedExpressionIR_r)
  -- if _ `# `( typeIR_l _ ) = typedExpressionIR_l
  -- if _ `# `( typeIR_r _ ) = typedExpressionIR_r
  -- Type_alpha: typeIR_l ~~ typeIR_r

def $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  = (typedExpressionIR_l_cast, typedExpressionIR_r)
  -- if _ `# `( typeIR_l ctk_l ) = typedExpressionIR_l
  -- if _ `# `( typeIR_r _ ) = typedExpressionIR_r
  -- Type_alpha:/ typeIR_l ~~ typeIR_r
  -- Sub_impl: typeIR_l <: typeIR_r
  -- if typedExpressionIR_l_cast
      = (`(typeIR_r) typedExpressionIR_l) `# `( typeIR_r ctk_l )

def $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  = (typedExpressionIR_l, typedExpressionIR_r_cast)
  -- if _ `# `( typeIR_l _ ) = typedExpressionIR_l
  -- if _ `# `( typeIR_r ctk_r ) = typedExpressionIR_r
  -- Type_alpha:/ typeIR_l ~~ typeIR_r
  -- Sub_impl:/ typeIR_l <: typeIR_r
  -- Sub_impl: typeIR_r <: typeIR_l
  -- if typedExpressionIR_r_cast
      = (`(typeIR_l) typedExpressionIR_r) `# `( typeIR_l ctk_r )

def $coerce_binary(typedExpressionIR_l, typedExpressionIR_r) = eps
  -- otherwise
