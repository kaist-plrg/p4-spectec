;;
;; Explicit subtyping
;;

rule Sub_expl:
  typeIR_a <: typeIR_b
  -- if typeIR_a_canon = $canon(typeIR_a)
  -- if typeIR_b_canon = $canon(typeIR_b)
  -- Sub_expl_canon: typeIR_a_canon <: typeIR_b_canon

rule Sub_expl_canon/equals:
  typeIR_a <: typeIR_b
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Sub_expl_canon/not-equals:
  typeIR_a <: typeIR_b
  -- Type_alpha:/ typeIR_a ~~ typeIR_b
  -- Sub_expl_canon_neq: typeIR_a <: typeIR_b

rule Sub_expl_canon_neq/fixbit-boolean:
  FBitT 1 <: BoolT

rule Sub_expl_canon_neq/boolean-fixbit:
  BoolT <: FBitT 1

rule Sub_expl_canon_neq/arbint-boolean:
  IntT <: BoolT

rule Sub_expl_canon_neq/arbint-fixint:
  IntT <: FIntT _

rule Sub_expl_canon_neq/arbint-fixbit:
  IntT <: FBitT _

rule Sub_expl_canon_neq/fixint-fixint:
  FIntT _ <: IntT

rule Sub_expl_canon_neq/fixint-fixint:
  FIntT w_a <: FIntT w_b

rule Sub_expl_canon_neq/fixint-fixbit:
  FIntT w <: FBitT w

rule Sub_expl_canon_neq/fixbit-arbint:
  FBitT _ <: IntT

rule Sub_expl_canon_neq/fixbit-fixint:
  FBitT w <: FIntT w

rule Sub_expl_canon_neq/fixbit-fixbit:
  FBitT w_a <: FBitT w_b

rule Sub_expl_canon_neq/newtype-left:
  NewT _ typeIR_a <: typeIR_b
  -- Sub_impl: typeIR_a <: typeIR_b

rule Sub_expl_canon_neq/newtype-right:
  typeIR_a <: NewT _ typeIR_b
  -- Sub_impl: typeIR_a <: typeIR_b

rule Sub_expl_canon_neq/serenum-left:
  SEnumT _ typeIR_a _ <: typeIR_b
  -- Sub_impl: typeIR_a <: typeIR_b

rule Sub_expl_canon_neq/serenum-right:
  typeIR_a <: SEnumT _ typeIR_b _
  -- Sub_impl: typeIR_a <: typeIR_b

rule Sub_expl_canon_neq/default:
  DefaultT <: typeIR_b
  -- if $is_defaultable_typeIR(typeIR_b)

rule Sub_expl_canon_neq/invalidheader-header:
  InvalidHeaderT <: HeaderT _ _

rule Sub_expl_canon_neq/invalidheader-headerunion:
  InvalidHeaderT <: HeaderUnionT _ _

rule Sub_expl_canon_neq/seq-list:
  SeqT typeIR_a* <: ListT typeIR_b
  -- (Sub_expl: typeIR_a <: typeIR_b)*

rule Sub_expl_canon_neq/seq-tuple:
  SeqT typeIR_a* <: TupleT typeIR_b*
  -- (Sub_expl: typeIR_a <: typeIR_b)*

rule Sub_expl_canon_neq/seq-stack:
  SeqT typeIR_a* <: HeaderStackT typeIR_b n_size
  -- if $(|typeIR_a*| <= n_size)
  -- (Sub_expl: typeIR_a <: typeIR_b)*

rule Sub_expl_canon_neq/seq-struct:
  SeqT typeIR_a* <: StructT _ (typeIR_b _)*
  -- (Sub_expl: typeIR_a <: typeIR_b)*

rule Sub_expl_canon_neq/seq-header:
  SeqT typeIR_a* <: HeaderT _ (typeIR_b _)*
  -- (Sub_expl: typeIR_a <: typeIR_b)*

rule Sub_expl_canon_neq/seqdefault-tuple:
  SeqDefaultT typeIR_a* <: TupleT typeIR_b*
  -- if $(|typeIR_a*| < |typeIR_b*|)
  -- if (typeIR_b_non_default*, typeIR_b_default*)
      = $partition_<typeIR>(typeIR_b*, |typeIR_a*|)
  -- (Sub_expl: typeIR_a <: typeIR_b_non_default)*
  -- if $is_defaultable_typeIR(typeIR_b_default)*

rule Sub_expl_canon_neq/seqdefault-stack:
  SeqDefaultT typeIR_a* <: HeaderStackT typeIR_b n_size
  -- if $(|typeIR_a*| < n_size)
  -- (Sub_expl: typeIR_a <: typeIR_b)*
  -- if $is_defaultable_typeIR(typeIR_b)

rule Sub_expl_canon_neq/seqdefault-struct:
  SeqDefaultT typeIR_a* <: StructT _ (typeIR_b _)*
  -- if $(|typeIR_a*| < |typeIR_b*|)
  -- if (typeIR_b_non_default*, typeIR_b_default*)
      = $partition_<typeIR>(typeIR_b*, |typeIR_a*|)
  -- (Sub_expl: typeIR_a <: typeIR_b_non_default)*
  -- if $is_defaultable_typeIR(typeIR_b_default)*

rule Sub_expl_canon_neq/seqdefault-header:
  SeqDefaultT typeIR_a* <: HeaderT _ (typeIR_b _)*
  -- if $(|typeIR_a*| < |typeIR_b*|)
  -- if (typeIR_b_non_default*, typeIR_b_default*)
      = $partition_<typeIR>(typeIR_b*, |typeIR_a*|)
  -- (Sub_expl: typeIR_a <: typeIR_b_non_default)*
  -- if $is_defaultable_typeIR(typeIR_b_default)*

rule Sub_expl_canon_neq/record-struct:
  RecordT (typeIR_a id_a)* <: StructT _ (typeIR_b id_b)*
  -- if $eq_set<id>(`{ id_a* }, `{ id_b* })
  -- if (typeIR_a_aligned
        = $find_map<id, typeIR>(`{ (id_a -> typeIR_a)* }, id_a))*
  -- if (typeIR_b_aligned
        = $find_map<id, typeIR>(`{ (id_b -> typeIR_b)* }, id_a))*
  -- (Sub_expl: typeIR_a_aligned <: typeIR_b_aligned)*

rule Sub_expl_canon_neq/record-header:
  RecordT (typeIR_a id_a)* <: HeaderT _ (typeIR_b id_b)*
  -- if $eq_set<id>(`{ id_a* }, `{ id_b* })
  -- if (typeIR_a_aligned
        = $find_map<id, typeIR>(`{ (id_a -> typeIR_a)* }, id_a))*
  -- if (typeIR_b_aligned
        = $find_map<id, typeIR>(`{ (id_b -> typeIR_b)* }, id_a))*
  -- (Sub_expl: typeIR_a_aligned <: typeIR_b_aligned)*

rule Sub_expl_canon_neq/recorddefault-struct:
  RecordDefaultT (typeIR_a id_a)* <: StructT _ (typeIR_b id_b)*
  -- if $sub_set<id>(`{ id_a* }, `{ id_b* })
  ----
  -- if (typeIR_a_aligned
        = $find_map<id, typeIR>(`{ (id_a -> typeIR_a)* }, id_a))*
  -- if (typeIR_b_non_default_aligned
        = $find_map<id, typeIR>(`{ (id_b -> typeIR_b)* }, id_a))*
  -- (Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned)*
  ----
  -- if `{ id_default* } = $diff_set<id>(`{ id_b* }, `{ id_a* })
  -- if (typeIR_b_default
        = $find_map<id, typeIR>(`{ (id_b -> typeIR_b)* }, id_default))*
  -- if $is_defaultable_typeIR(typeIR_b_default)*

rule Sub_expl_canon_neq/recorddefault-header:
  RecordDefaultT (typeIR_a id_a)* <: HeaderT _ (typeIR_b id_b)*
  -- if $sub_set<id>(`{ id_a* }, `{ id_b* })
  ----
  -- if (typeIR_a_aligned
        = $find_map<id, typeIR>(`{ (id_a -> typeIR_a)* }, id_a))*
  -- if (typeIR_b_non_default_aligned
        = $find_map<id, typeIR>(`{ (id_b -> typeIR_b)* }, id_a))*
  -- (Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned)*
  ----
  -- if `{ id_default* } = $diff_set<id>(`{ id_b* }, `{ id_a* })
  -- if (typeIR_b_default
        = $find_map<id, typeIR>(`{ (id_b -> typeIR_b)* }, id_default))*
  -- if $is_defaultable_typeIR(typeIR_b_default)*

rule Sub_expl_canon_neq/set-set:
  SetT typeIR_a <: SetT typeIR_b
  -- Sub_expl: typeIR_a <: typeIR_b

rule Sub_expl_canon_neq/non-set-set:
  typeIR_a <: SetT typeIR_b
  -- if ~$is_set_typeIR(typeIR_a)
  -- Sub_expl: typeIR_a <: typeIR_b

;;
;; Implicit subtyping
;;

rule Sub_impl:
  typeIR_a <: typeIR_b
  -- if typeIR_a_canon = $canon(typeIR_a)
  -- if typeIR_b_canon = $canon(typeIR_b)
  -- Sub_impl_canon: typeIR_a_canon <: typeIR_b_canon

rule Sub_impl_canon/equals:
  typeIR_a <: typeIR_b
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Sub_impl_canon/not-equals:
  typeIR_a <: typeIR_b
  -- Type_alpha:/ typeIR_a ~~ typeIR_b
  -- Sub_impl_canon_neq: typeIR_a <: typeIR_b

rule Sub_impl_canon_neq/arbint-fixint:
  IntT <: FIntT _

rule Sub_impl_canon_neq/arbint-fixbit:
  IntT <: FBitT _

rule Sub_impl_canon_neq/serenum-left:
  SEnumT _ typeIR_a _ <: typeIR_b
  -- Sub_impl: typeIR_a <: typeIR_b

rule Sub_impl_canon_neq/default:
  DefaultT <: typeIR_b
  -- if $is_defaultable_typeIR(typeIR_b)

rule Sub_impl_canon_neq/invalidheader-header:
  InvalidHeaderT <: HeaderT _ _

rule Sub_impl_canon_neq/invalidheader-headerunion:
  InvalidHeaderT <: HeaderUnionT _ _

rule Sub_impl_canon_neq/seq-list:
  SeqT typeIR_a* <: ListT typeIR_b
  -- (Sub_impl: typeIR_a <: typeIR_b)*

rule Sub_impl_canon_neq/seq-tuple:
  SeqT typeIR_a* <: TupleT typeIR_b*
  -- (Sub_impl: typeIR_a <: typeIR_b)*

rule Sub_impl_canon_neq/seq-stack:
  SeqT typeIR_a* <: HeaderStackT typeIR_b n_size
  -- if $(|typeIR_a*| <= n_size)
  -- (Sub_impl: typeIR_a <: typeIR_b)*

rule Sub_impl_canon_neq/seq-struct:
  SeqT typeIR_a* <: StructT _ (typeIR_b _)*
  -- (Sub_impl: typeIR_a <: typeIR_b)*

rule Sub_impl_canon_neq/seq-header:
  SeqT typeIR_a* <: HeaderT _ (typeIR_b _)*
  -- (Sub_impl: typeIR_a <: typeIR_b)*

rule Sub_impl_canon_neq/seq-seq:
  SeqT typeIR_a* <: SeqT typeIR_b*
  -- (Sub_impl: typeIR_a <: typeIR_b)*

rule Sub_impl_canon_neq/seqdefault-tuple:
  SeqDefaultT typeIR_a* <: TupleT typeIR_b*
  -- if $(|typeIR_a*| < |typeIR_b*|)
  -- if (typeIR_b_non_default*, typeIR_b_default*)
      = $partition_<typeIR>(typeIR_b*, |typeIR_a*|)
  -- (Sub_impl: typeIR_a <: typeIR_b_non_default)*
  -- if $is_defaultable_typeIR(typeIR_b_default)*

rule Sub_impl_canon_neq/seqdefault-stack:
  SeqDefaultT typeIR_a* <: HeaderStackT typeIR_b n_size
  -- if $(|typeIR_a*| < n_size)
  -- (Sub_impl: typeIR_a <: typeIR_b)*
  -- if $is_defaultable_typeIR(typeIR_b)

rule Sub_impl_canon_neq/seqdefault-struct:
  SeqDefaultT typeIR_a* <: StructT _ (typeIR_b _)*
  -- if $(|typeIR_a*| < |typeIR_b*|)
  -- if (typeIR_b_non_default*, typeIR_b_default*)
      = $partition_<typeIR>(typeIR_b*, |typeIR_a*|)
  -- (Sub_impl: typeIR_a <: typeIR_b_non_default)*
  -- if $is_defaultable_typeIR(typeIR_b_default)*

rule Sub_impl_canon_neq/seqdefault-header:
  SeqDefaultT typeIR_a* <: HeaderT _ (typeIR_b _)*
  -- if $(|typeIR_a*| < |typeIR_b*|)
  -- if (typeIR_b_non_default*, typeIR_b_default*)
      = $partition_<typeIR>(typeIR_b*, |typeIR_a*|)
  -- (Sub_impl: typeIR_a <: typeIR_b_non_default)*
  -- if $is_defaultable_typeIR(typeIR_b_default)*

rule Sub_impl_canon_neq/record-struct:
  RecordT (typeIR_a id_a)* <: StructT _ (typeIR_b id_b)*
  -- if $eq_set<id>(`{ id_a* }, `{ id_b* })
  -- if (typeIR_a_aligned
        = $find_map<id, typeIR>(`{ (id_a -> typeIR_a)* }, id_a))*
  -- if (typeIR_b_aligned
        = $find_map<id, typeIR>(`{ (id_b -> typeIR_b)* }, id_a))*
  -- (Sub_impl: typeIR_a_aligned <: typeIR_b_aligned)*

rule Sub_impl_canon_neq/record-header:
  RecordT (typeIR_a id_a)* <: HeaderT _ (typeIR_b id_b)*
  -- if $eq_set<id>(`{ id_a* }, `{ id_b* })
  -- if (typeIR_a_aligned
        = $find_map<id, typeIR>(`{ (id_a -> typeIR_a)* }, id_a))*
  -- if (typeIR_b_aligned
        = $find_map<id, typeIR>(`{ (id_b -> typeIR_b)* }, id_a))*
  -- (Sub_impl: typeIR_a_aligned <: typeIR_b_aligned)*

rule Sub_impl_canon_neq/recorddefault-struct:
  RecordDefaultT (typeIR_a id_a)* <: StructT _ (typeIR_b id_b)*
  -- if $sub_set<id>(`{ id_a* }, `{ id_b* })
  ----
  -- if (typeIR_a_aligned
        = $find_map<id, typeIR>(`{ (id_a -> typeIR_a)* }, id_a))*
  -- if (typeIR_b_non_default_aligned
        = $find_map<id, typeIR>(`{ (id_b -> typeIR_b)* }, id_a))*
  -- (Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned)*
  ----
  -- if `{ id_default* } = $diff_set<id>(`{ id_b* }, `{ id_a* })
  -- if (typeIR_b_default
        = $find_map<id, typeIR>(`{ (id_b -> typeIR_b)* }, id_default))*
  -- if $is_defaultable_typeIR(typeIR_b_default)*

rule Sub_impl_canon_neq/recorddefault-header:
  RecordDefaultT (typeIR_a id_a)* <: HeaderT _ (typeIR_b id_b)*
  -- if $sub_set<id>(`{ id_a* }, `{ id_b* })
  ----
  -- if (typeIR_a_aligned
        = $find_map<id, typeIR>(`{ (id_a -> typeIR_a)* }, id_a))*
  -- if (typeIR_b_non_default_aligned
        = $find_map<id, typeIR>(`{ (id_b -> typeIR_b)* }, id_a))*
  -- (Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned)*
  ----
  -- if `{ id_default* } = $diff_set<id>(`{ id_b* }, `{ id_a* })
  -- if (typeIR_b_default
        = $find_map<id, typeIR>(`{ (id_b -> typeIR_b)* }, id_default))*
  -- if $is_defaultable_typeIR(typeIR_b_default)*

;;
;; Serializable enum reduction
;;
;; Reduce serializable enums to their underlying types,
;; until the expression satisfies the given check
;;

;;; Unary case

dec $reduce_serenum_unary(
    typedExpressionIR,
    def $check(typeIR) : bool
  )
  : typedExpressionIR?


def $reduce_serenum_unary(typedExpressionIR, def $check)
  = typedExpressionIR
  -- if _ `( typeIR _ ) = typedExpressionIR
  -- if $check(typeIR)

def $reduce_serenum_unary(typedExpressionIR, def $check)
  = $reduce_serenum_unary(typedExpressionIR_cast, def $check)
  -- if _ `( typeIR ctk ) = typedExpressionIR
  -- if ~$check(typeIR)
  -- if SEnumT _ typeIR_underlying _ = typeIR
  -- if typedExpressionIR_cast
      = (CastE typeIR_underlying typedExpressionIR) `( typeIR_underlying ctk )

def $reduce_serenum_unary(typedExpressionIR, def $check) = eps
  -- otherwise

;;; Binary case

dec $reduce_serenum_binary(
    typedExpressionIR,
    typedExpressionIR,
    def $check(typeIR, typeIR) : bool
  )
  : (typedExpressionIR, typedExpressionIR)?

def $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, def $check)
  = (typedExpressionIR_l, typedExpressionIR_r)
  -- if _ `( typeIR_l _ ) = typedExpressionIR_l
  -- if _ `( typeIR_r _ ) = typedExpressionIR_r
  -- if $check(typeIR_l, typeIR_r)

def $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, def $check)
  = ($reduce_serenum_binary(
      typedExpressionIR_l_cast, typedExpressionIR_r, def $check))
  -- if _ `( typeIR_l ctk_l ) = typedExpressionIR_l
  -- if _ `( typeIR_r _ ) = typedExpressionIR_r
  -- if ~$check(typeIR_l, typeIR_r)
  -- if SEnumT _ typeIR_l_underlying _ = typeIR_l
  -- if typedExpressionIR_l_cast
      = (CastE typeIR_l_underlying typedExpressionIR_l) `( typeIR_l_underlying ctk_l )

def $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, def $check)
  = ($reduce_serenum_binary(
      typedExpressionIR_l, typedExpressionIR_r_cast, def $check))
  -- if _ `( typeIR_l _ ) = typedExpressionIR_l
  -- if _ `( typeIR_r ctk_r ) = typedExpressionIR_r
  -- if ~$check(typeIR_l, typeIR_r)
  -- if SEnumT _ typeIR_r_underlying _ = typeIR_r
  -- if typedExpressionIR_r_cast
      = (CastE typeIR_r_underlying typedExpressionIR_r) `( typeIR_r_underlying ctk_r )

def $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, def $check) = eps
  -- otherwise

;;
;; Coercions
;;
;; Try to coerce an expression to a given type,
;; and for binary case, one expression to another
;;

;;; Unary

dec $coerce_unary(typedExpressionIR, typeIR) : typedExpressionIR?

def $coerce_unary(typedExpressionIR, typeIR_to) = typedExpressionIR
  -- if _ `( typeIR _ ) = typedExpressionIR
  -- Type_alpha: typeIR ~~ typeIR_to

def $coerce_unary(typedExpressionIR, typeIR_to) = typedExpressionIR_cast
  -- if _ `( typeIR ctk ) = typedExpressionIR
  -- Type_alpha:/ typeIR ~~ typeIR_to
  -- Sub_impl: typeIR <: typeIR_to
  -- if typedExpressionIR_cast
      = (CastE typeIR_to typedExpressionIR) `( typeIR_to ctk )

;;; Binary

dec $coerce_binary(typedExpressionIR, typedExpressionIR)
  : (typedExpressionIR, typedExpressionIR)?

def $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  = (typedExpressionIR_l, typedExpressionIR_r)
  -- if _ `( typeIR_l _ ) = typedExpressionIR_l
  -- if _ `( typeIR_r _ ) = typedExpressionIR_r
  -- Type_alpha: typeIR_l ~~ typeIR_r

def $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  = (typedExpressionIR_l_cast, typedExpressionIR_r)
  -- if _ `( typeIR_l ctk_l ) = typedExpressionIR_l
  -- if _ `( typeIR_r _ ) = typedExpressionIR_r
  -- Type_alpha:/ typeIR_l ~~ typeIR_r
  -- Sub_impl: typeIR_l <: typeIR_r
  -- if typedExpressionIR_l_cast
      = (CastE typeIR_r typedExpressionIR_l) `( typeIR_r ctk_l )

def $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  = (typedExpressionIR_l, typedExpressionIR_r_cast)
  -- if _ `( typeIR_l _ ) = typedExpressionIR_l
  -- if _ `( typeIR_r ctk_r ) = typedExpressionIR_r
  -- Type_alpha:/ typeIR_l ~~ typeIR_r
  -- Sub_impl:/ typeIR_l <: typeIR_r
  -- Sub_impl: typeIR_r <: typeIR_l
  -- if typedExpressionIR_r_cast
      = (CastE typeIR_l typedExpressionIR_r) `( typeIR_l ctk_r )

def $coerce_binary(typedExpressionIR_l, typedExpressionIR_r) = eps
  -- otherwise
