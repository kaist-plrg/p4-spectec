;;
;; Expression evaluation for instantiation
;;
;; syntax typedExpressionIR =
;;   expressionIR `# `( typeIR ctk )
;;

;;; syntax expressionIR

;;;; literalExpressionIR
;;;; syntax literalExpression

;;;;; TRUE
;;;;; FALSE

rule Expr_inst/literalExpressionIR-true:
  p Ci sto |- TRUE `# _ ==> sto (B true)

rule Expr_inst/literalExpressionIR-false:
  p Ci sto |- FALSE `# _ ==> sto (B false)

;;;;; number

rule Expr_inst/literalExpressionIR-number-arbint:
  p Ci sto |- (D i) `# _ ==> sto (D i)

rule Expr_inst/literalExpressionIR-number-fixint:
  p Ci sto |- (n S i) `# _ ==> sto (n S i)

rule Expr_inst/literalExpressionIR-number-fixbit:
  p Ci sto |- (n W i) `# _ ==> sto (n W i)

;;;;; stringLiteral

rule Expr_inst/literalExpressionIR-stringLiteral:
  p Ci sto |- (`" text `") `# _ ==> sto (`" text `")

;;;; referenceExpressionIR
;;;; syntax referenceExpressionIR = prefixedNameIR

rule Expr_inst/referenceExpressionIR-id:
  p Ci sto |- prefixedNameIR `# _ ==> sto value
  -- if $find_value_inst(p, Ci, prefixedNameIR) = value

;;;; defaultExpressionIR

rule Expr_inst/defaultExpressionIR:
  p Ci sto |- `... `# _ ==> sto DEFAULT

;;;; unaryExpressionIR
;;;; syntax unaryExpressionIR = unop typedExpressionIR

rule Expr_inst/unaryExpressionIR-bnot:
  p Ci sto |- (`~ typedExpressionIR) `# _ ==> sto_1 $un_bnot(value)
  -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value

rule Expr_inst/unaryExpressionIR-lnot:
  p Ci sto |- (`! typedExpressionIR) `# _ ==> sto_1 $un_lnot(value)
  -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value

rule Expr_inst/unaryExpressionIR-plus:
  p Ci sto |- (`+ typedExpressionIR) `# _ ==> sto_1 $un_plus(value)
  -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value

rule Expr_inst/unaryExpressionIR-minus:
  p Ci sto |- (`- typedExpressionIR) `# _ ==> sto_1 $un_minus(value)
  -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value

;;;; binaryExpressionIR
;;;; syntax binaryExpressionIR =
;;;;   typedExpressionIR binop typedExpressionIR

rule Expr_inst/binaryExpressionIR-mul:
  p Ci sto |- (typedExpressionIR_l `* typedExpressionIR_r) `# _
          ==> sto_2 $bin_mul(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-div:
  p Ci sto |- (typedExpressionIR_l `/ typedExpressionIR_r) `# _
          ==> sto_2 $bin_div(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-mod:
  p Ci sto |- (typedExpressionIR_l `% typedExpressionIR_r) `# _
          ==> sto_2 $bin_mod(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-plus:
  p Ci sto |- (typedExpressionIR_l `+ typedExpressionIR_r) `# _
          ==> sto_2 $bin_plus(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-minus:
  p Ci sto |- (typedExpressionIR_l `- typedExpressionIR_r) `# _
          ==> sto_2 $bin_minus(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-satplus:
  p Ci sto |- (typedExpressionIR_l `|+| typedExpressionIR_r) `# _
          ==> sto_2 $bin_satplus(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-satminus:
  p Ci sto |- (typedExpressionIR_l `|-| typedExpressionIR_r) `# _
          ==> sto_2 $bin_satminus(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-shl:
  p Ci sto |- (typedExpressionIR_l `<< typedExpressionIR_r) `# _
          ==> sto_2 $bin_shl(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-shr:
  p Ci sto |- (typedExpressionIR_l `>> typedExpressionIR_r) `# _
          ==> sto_2 $bin_shr(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-le:
  p Ci sto |- (typedExpressionIR_l `<= typedExpressionIR_r) `# _
          ==> sto_2 (B $bin_le(value_l, value_r))
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-ge:
  p Ci sto |- (typedExpressionIR_l `>= typedExpressionIR_r) `# _
          ==> sto_2 (B $bin_ge(value_l, value_r))
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-lt:
  p Ci sto |- (typedExpressionIR_l ``< typedExpressionIR_r) `# _
          ==> sto_2 (B $bin_lt(value_l, value_r))
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-gt:
  p Ci sto |- (typedExpressionIR_l ``> typedExpressionIR_r) `# _
          ==> sto_2 (B $bin_gt(value_l, value_r))
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-ne:
  p Ci sto |- (typedExpressionIR_l `!= typedExpressionIR_r) `# _
          ==> sto_2 (B $bin_ne(value_l, value_r))
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-eq:
  p Ci sto |- (typedExpressionIR_l `== typedExpressionIR_r) `# _
          ==> sto_2 (B $bin_eq(value_l, value_r))
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-band:
  p Ci sto |- (typedExpressionIR_l `& typedExpressionIR_r) `# _
          ==> sto_2 $bin_band(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-bxor:
  p Ci sto |- (typedExpressionIR_l `^ typedExpressionIR_r) `# _
          ==> sto_2 $bin_bxor(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-bor:
  p Ci sto |- (typedExpressionIR_l `| typedExpressionIR_r) `# _
          ==> sto_2 $bin_bor(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-concat:
  p Ci sto |- (typedExpressionIR_l `++ typedExpressionIR_r) `# _
          ==> sto_2 $bin_concat(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-land:
  p Ci sto |- (typedExpressionIR_l `&& typedExpressionIR_r) `# _
          ==> sto_2 $bin_land(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

rule Expr_inst/binaryExpressionIR-lor:
  p Ci sto |- (typedExpressionIR_l `|| typedExpressionIR_r) `# _
          ==> sto_2 $bin_lor(value_l, value_r)
  -- Expr_inst: p Ci sto |- typedExpressionIR_l ==> sto_1 value_l
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_r ==> sto_2 value_r

;;;; ternaryExpressionIR
;;;; syntax ternaryExpressionIR =
;;;;   typedExpressionIR `? typedExpressionIR `: typedExpressionIR

rule Expr_inst/ternaryExpressionIR-then:
  p Ci sto |- (typedExpressionIR_c `? typedExpressionIR_t `: typedExpressionIR_e) `# _
          ==> sto_2 value_true
  -- Expr_inst: p Ci sto |- typedExpressionIR_c ==> sto_1 (B true)
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_t ==> sto_2 value_true

rule Expr_inst/ternaryExpressionIR-else:
  p Ci sto |- (typedExpressionIR_c `? typedExpressionIR_t `: typedExpressionIR_e) `# _
          ==> sto_2 value_false
  -- Expr_inst: p Ci sto |- typedExpressionIR_c ==> sto_1 (B false)
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_e ==> sto_2 value_false

;;;; castExpressionIR
;;;; syntax castExpressionIR = `( typeIR ) typedExpressionIR

rule Expr_inst/castExpressionIR:
  p Ci sto |- (`( typeIR ) typedExpressionIR) `# _ ==> sto_1 value_cast
  -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value
  -- if $cast_op(typeIR, value) = value_cast

;;;; dataExpressionIR
;;;; syntax dataExpressionIR

;;;;; `{#}

rule Expr_inst/dataExpressionIR-invalid:
  p Ci sto |- `{#} `# _ ==> sto `{#}

;;;;; SEQ `{ typedExpressionListIR }

rule Expr_inst/dataExpressionIR-sequence:
  p Ci sto |- (SEQ `{ typedExpressionListIR }) `# _
          ==> sto_1 (SEQ `( value* ))
  -- Exprs_inst: p Ci sto |- typedExpressionListIR ==> sto_1 value*

;;;;; SEQ `{ typedExpressionListIR `, `... }

rule Expr_inst/dataExpressionIR-sequence-default:
  p Ci sto |- (SEQ `{ typedExpressionListIR `, `... }) `# _
          ==> sto_1 (SEQ `( value* `, `... ))
  -- Exprs_inst: p Ci sto |- typedExpressionListIR ==> sto_1 value*

;;;;; RECORD `{ namedExpressionListIR }

rule Expr_inst/dataExpressionIR-record:
  p Ci sto |- (RECORD `{ (nameIR `= typedExpressionIR)* }) `# _
          ==> sto_1 (RECORD `{ (value nameIR `;)* })
  -- Exprs_inst: p Ci sto |- typedExpressionIR* ==> sto_1 value*

;;;;; RECORD `{ namedExpressionListIR `, `... }

rule Expr_inst/dataExpressionIR-record-default:
  p Ci sto |- (RECORD `{ (nameIR `= typedExpressionIR)* `, `... }) `# _
          ==> sto_1 (RECORD `{ (value nameIR `;)* `, `... })
  -- Exprs_inst: p Ci sto |- typedExpressionIR* ==> sto_1 value*

;;;; accessExpressionIR
;;;; syntax accessExpressionIR

;;;;; errorAccessExpressionIR
;;;;; syntax errorAccessExpressionIR = ERROR `. nameIR

rule Expr_inst/accessExpressionIR-errorAccessExpressionIR:
  p Ci sto |- (ERROR `. nameIR) `# _ ==> sto value_error
  -- if "error." ++ nameIR = nameIR_error
  -- if $find_value_inst(p, Ci, `` nameIR_error) = value_error

;;;;; memberAccessExpressionIR
;;;;; syntax memberAccessExpressionIR = memberAccessBaseIR `. nameIR
;;;;;; syntax memberAccessBaseIR

;;;;;;; TYPE prefixedNameIR

rule Expr_inst/accessExpressionIR-memberAccessExpressionIR-typeaccess-enum:
  p Ci sto |- ((TYPE prefixedNameIR) `. nameIR) `# _
          ==> sto (tid `. nameIR)
  -- if $find_typedef_inst(p, Ci, prefixedNameIR) = ENUM tid `{ _ }

rule Expr_inst/accessExpressionIR-memberAccessExpressionIR-typeaccess-senum:
  p Ci sto |- ((TYPE prefixedNameIR) `. nameIR) `# _
          ==> sto (tid `. nameIR `# value)
  -- if $find_typedef_inst(p, Ci, prefixedNameIR) 
      = ENUM tid `# _ `{ (id_member `= value_member `;)* }
  -- if $assoc_<nameIR, value>(nameIR, (id_member, value_member)*) = value

;;;;;;; typedExpressionIR

rule Expr_inst/accessExpressionIR-memberAccessExpressionIR-typedExpressionIR:
  p Ci sto |- (typedExpressionIR `. "size") `# _
          ==> sto_1 (D n_size)
  -- Expr_inst: p Ci sto |- typedExpressionIR ==> sto_1 value
  -- if value = `[ _ `# `( _; n_size )] 

;;;;; indexAccessExpressionIR
;;;;; syntax indexAccessExpressionIR =

;;;;;; typedExpressionIR `[ typedExpressionIR ]
;;;;;; tuple or stack accesses are not evaluated statically

;;;;;; typedExpressionIR `[ typedExpressionIR `: typedExpressionIR ]

rule Expr_inst/indexAccessExpressionIR-bitslice:
  p Ci sto |- (typedExpressionIR_b `[ typedExpressionIR_l `: typedExpressionIR_h ]) `# _
          ==> sto_3 $bitacc_op(value_b, value_l, value_h)
  -- Expr_inst: p Ci sto |- typedExpressionIR_b ==> sto_1 value_b
  -- Expr_inst: p Ci sto_1 |- typedExpressionIR_l ==> sto_2 value_l
  -- Expr_inst: p Ci sto_2 |- typedExpressionIR_h ==> sto_3 value_h

;;;; callExpressionIR
;;;; syntax callExpressionIR

;;;;; constructorTargetIR `( argumentListIR )

rule Expr_inst/callExpressionIR-instantiation:
  p Ci sto |- ((prefixedNameIR `< typeArgumentListIR >) `( argumentListIR )) `# _
          ==> sto_2 value
  ---- ;; find and instantiate constructor
  -- if $find_constructor_overloaded_inst(Ci, prefixedNameIR, argumentListIR) = (_, consDyn, id_default*)
  -- Constructor_inst: p Ci sto |- consDyn `< typeArgumentListIR > `( argumentListIR `# id_default* ) ==> sto_1 objDyn
  ---- ;; add object to caller store
  -- if Ci.PATH = oid
  -- if $add_sto(sto_1, oid, objDyn) = sto_2
  ---- ;; create reference value
  -- if (`! oid) = value

;;;;; routineTargetIR `< typeArgumentListIR > `( argumentListIR )

;;;;;; syntax routineTargetIR

;;;;;;; referenceExpressionIR
;;;;;;; function/action calls are not evaluated statically

;;;;;;; typedExpressionIR `. nameIR

rule Expr_inst/callExpressionIR-methodTarget-generic:
  p Ci sto |- ((typedExpressionIR `. nameIR ) `< eps > `( eps )) `# _
          ==> sto $sizeof(typeIR_base, nameIR)
  -- if typedExpressionIR = _ `# `( typeIR_base _ )
  -- if nameIR <- [ "minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes" ]

;;;;;;; TYPE prefixedNameIR `. nameIR

rule Expr_inst/callExpressionIR-methodTarget-non-generic:
  p Ci sto |- ((TYPE prefixedNameIR `. nameIR ) `< eps > `( eps )) `# _
          ==> sto $sizeof(typeIR_base, nameIR)
  -- if nameIR <- [ "minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes" ]
  -- if $find_typedef_inst(p, Ci, prefixedNameIR) = typeIR_base

;;;;;;; `( routineTargetIR )

rule Expr_inst/callExpressionIR-methodTarget-routine:
  p Ci sto |- ((`( routineTargetIR )) `< typeArgumentListIR > `( argumentListIR ))
              `# expressionNoteIR
          ==> sto_1 value
    -- Expr_inst:
        p Ci sto |- (routineTargetIR `< typeArgumentListIR > `( argumentListIR ))
                    `# expressionNoteIR
                ==> sto_1 value

;;;; parenthesizedExpressionIR
;;;; syntax parenthesizedExpressionIR = `( typedExpressionIR )

rule Expr_inst/parenthesizedExpressionIR:
  p Ci sto_0 |- (`( typedExpressionIR )) `# _ ==> sto_1 value
  -- Expr_inst: p Ci sto_0 |- typedExpressionIR ==> sto_1 value

;;
;; Expression list instantiation
;;
;; syntax typedExpressionListIR
;;

rule Exprs_inst/nil:
  p Ci sto |- eps ==> sto eps

rule Exprs_inst/cons:
  p Ci sto_0 |- typedExpressionIR_h :: typedExpressionIR_t*
    ==> sto_2 (value_h :: value_t*)
  -- Expr_inst: p Ci sto_0 |- typedExpressionIR_h ==> sto_1 value_h
  -- Exprs_inst: p Ci sto_1 |- typedExpressionIR_t* ==> sto_2 value_t*
