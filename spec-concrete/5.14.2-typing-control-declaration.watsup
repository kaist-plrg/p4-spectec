;;
;; Control local declaration typing
;;
;; syntax controlLocalDeclaration
;;

;;; constantDeclaration

rule ControlLocalDecl_ok/constantDeclaration:
  TC_0 |- constantDeclaration : TC_1 constantDeclarationIR
  -- Decl_ok: BLOCK TC_0 |- constantDeclaration : TC_1 constantDeclarationIR

;;; instantiation

rule ControlLocalDecl_ok/instantiation:
  TC_0 |- instantiation : TC_1 instantiationIR
  -- Decl_ok: BLOCK TC_0 |- instantiation : TC_1 instantiationIR

;;; variableDeclaration
;;; syntax variableDeclaration =
;;;   annotationList type name initializerOpt `;

rulegroup ControlLocalDecl_ok/variableDeclaration {

  rule ControlLocalDecl_ok/empty:
    TC_0 |- annotationList type name `EMPTY `;
          : TC_1 variableDeclarationIR
    ---- ;; check type
    -- Type_ok: BLOCK TC_0 |- type : typeIR `# eps
    -- Type_wf: $bound(BLOCK, TC_0) |- typeIR
    ---- ;; check that the type is assignable
    -- if $is_assignable_typeIR(typeIR)
    ---- ;; update the context
    -- if nameIR = $name(name)
    -- if TC_1 = $add_var(BLOCK, TC_0, nameIR, INOUT typeIR DYN eps)
    ---- ;; create IR
    -- if variableDeclarationIR
        = annotationList typeIR nameIR eps `;

  rule ControlLocalDecl_ok/initializer:
    TC_0 |- annotationList type name (`= expression_init) `;
          : TC_1 variableDeclarationIR
    ---- ;; check type
    -- Type_ok: BLOCK TC_0 |- type : typeIR `# eps
    -- Type_wf: $bound(BLOCK, TC_0) |- typeIR
    ---- ;; check that the type is assignable
    -- if $is_assignable_typeIR(typeIR)
    ---- ;; check expression
    -- Expr_ok: BLOCK TC_0 |- expression_init : typedExpressionIR_init
    ---- ;; check that the expression matches the type
    ---- ;; while inserting implicit casts if necessary
    -- if typedExpressionIR_init_cast
        = $coerce_unary(typedExpressionIR_init, typeIR)
    ---- ;; update the context
    -- if nameIR = $name(name)
    -- if TC_1 = $add_var(BLOCK, TC_0, nameIR, INOUT typeIR DYN eps)
    ---- ;; create IR
    -- if variableDeclarationIR
        = annotationList typeIR nameIR (`= typedExpressionIR_init_cast) `;

}

;;; actionDeclaration

rule ControlLocalDecl_ok/actionDeclaration:
  TC_0 |- actionDeclaration : TC_1 actionDeclarationIR
  -- Decl_ok: BLOCK TC_0 |- actionDeclaration : TC_1 actionDeclarationIR

;;; tableDeclaration
;;; syntax tableDeclaration =
;;;   annotationList TABLE name `{ tablePropertyList }

rule ControlLocalDecl_ok/tableDeclaration:
  TC_0 |- annotationList TABLE name `{ tablePropertyList }
       : TC_3 tableDeclarationIR
  ---- ;; set local context
  -- if TC_1 = TC_0 [ .LOCAL.KIND = TABLE_APPLY_METHOD ]
  ---- ;; check table properties
  -- if tableProperty* = $flatten_tablePropertyList(tablePropertyList)
  -- Table_ok: TC_1 |- tableProperty* : TBLC tablePropertyIR*
  ---- ;; update the context with synthesized table
  -- if nameIR = $name(name)
  -- TableType_ok: TC_1 TBLC |- name : TC_2 typeIR_table
  -- if TC_3 = $add_var(BLOCK, TC_2, nameIR, `EMPTY typeIR_table DYN eps)
  ---- ;; create IR
  -- if tableDeclarationIR
      = annotationList TABLE typeIR_table nameIR `{ tablePropertyIR* }

;;
;; Control local declaration list typing
;;
;; syntax controlLocalDeclarationList
;;

rule ControlLocalDecls_ok/nil:
  TC |- eps : TC eps

rule ControlLocalDecls_ok/cons:
  TC_0 |- controlLocalDeclaration_h :: controlLocalDeclaration_t*
        : TC_2 (controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*)
  -- ControlLocalDecl_ok: TC_0 |- controlLocalDeclaration_h
                                : TC_1 controlLocalDeclarationIR_h
  -- ControlLocalDecls_ok: TC_1 |- controlLocalDeclaration_t*
                                 : TC_2 controlLocalDeclarationIR_t*
