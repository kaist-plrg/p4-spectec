;;
;; L-value typing
;;
;; syntax lvalue
;;

dec $lvalue_to_expression(lvalue) : expression
def $lvalue_to_expression(referenceExpression) = referenceExpression
def $lvalue_to_expression(lvalue_base `. member)
  = expression_base `. member
  -- if expression_base = $lvalue_to_expression(lvalue_base)
def $lvalue_to_expression(lvalue_base `[ expression_index ])
  = expression_base `[ expression_index ]
  -- if expression_base = $lvalue_to_expression(lvalue_base)
def $lvalue_to_expression(lvalue_base `[ expression_hi `: expression_lo ])
  = expression_base `[ expression_hi `: expression_lo ]
  -- if expression_base = $lvalue_to_expression(lvalue_base)
def $lvalue_to_expression(`( lvalue )) = `( expression )
  -- if expression = $lvalue_to_expression(lvalue)

;;; referenceExpression
;;; syntax referenceExpression

;;;; prefixedNonTypeName

rule Lvalue_ok/referenceExpression-prefixedNonTypeName-assign:
  p TC |- prefixedNonTypeName : prefixedNameIR `# `( typeIR )
  -- if prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
  -- if direction typeIR DYN eps = $find_var(p, TC, prefixedNameIR)
  -- if direction = OUT \/ direction = INOUT

;;;; THIS
;;;; THIS `= ... is disallowed

;;; lvalue `. member

rule Lvalue_ok/lvalue-member-stack-next-last:
  p TC |- lvalue_base `. member : typedLvalueIR
  ---- ;; check base lvaue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `# `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the lvalue is a struct
  -- if typeIR `[ _ ] = $canon(typeIR_base)
  ---- ;; check that the field is "next" or "last"
  -- if nameIR = $name(member)
  -- if nameIR = "next" \/ nameIR = "last"
  ---- ;; "next" and "last" can be only used within a parser
  -- if (p = BLOCK /\ $is_parser_blockKind(TC.BLOCK.KIND))
        \/ (p = LOCAL /\ $is_parser_state_localKind(TC.LOCAL.KIND))
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (typedLvalueIR_base `. nameIR) `# `( typeIR )

rule Lvalue_ok/lvalue-member-struct:
  p TC |- lvalue_base `. member : typedLvalueIR
  ---- ;; check base lvaue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `# `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the lvalue is a struct
  -- if STRUCT _ `{ (typeIR_f nameIR_f `;)* } = $canon(typeIR_base)
  ---- ;; find the field
  -- if nameIR = $name(member)
  -- if typeIR = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*)
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (typedLvalueIR_base `. nameIR) `# `( typeIR )

rule Lvalue_ok/lvalue-member-header:
  p TC |- lvalue_base `. member : typedLvalueIR
  ---- ;; check base lvaue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `# `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the lvalue is a header
  -- if HEADER _ `{ (typeIR_f nameIR_f `;)* } = $canon(typeIR_base)
  ---- ;; find the field
  -- if nameIR = $name(member)
  -- if typeIR = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*)
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (typedLvalueIR_base `. nameIR) `# `( typeIR )

rule Lvalue_ok/lvalue-member-union:
  p TC |- lvalue_base `. member : typedLvalueIR
  ---- ;; check base lvaue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `# `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the lvalue is a header
  -- if HEADER_UNION _ `{ (typeIR_f nameIR_f `;)* } = $canon(typeIR_base)
  ---- ;; find the field
  -- if nameIR = $name(member)
  -- if typeIR = $assoc_<nameIR, typeIR>(nameIR, (nameIR_f, typeIR_f)*)
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (typedLvalueIR_base `. nameIR) `# `( typeIR )

;;; lvalue `[ expression ]

rule Lvalue_ok/lvalue-expression-lctk:
  p TC |- lvalue_base `[ expression_index ] : typedLvalueIR
  ---- ;; check base lvalue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `# `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the lvalue is a header stack
  -- if typeIR `[ n_size ] = $canon(typeIR_base)
  ---- ;; check index expression
  -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
  -- if _ `# `( typeIR_index ctk_index ) = typedExpressionIR_index
  ---- ;; check that the index is compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_index_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_index,
          def $compat_array_index
        )
  ---- ;; if the index is local compile-time known, then it must be in range
  -- if ctk_index = LCTK
  -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
  -- if n_index = $to_number(value_index)
  -- if $(n_index < n_size)
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (typedLvalueIR_base `[ typedExpressionIR_index_reduced ])
          `# `( typeIR )

rule Lvalue_ok/lvalue-expression-non-lctk:
  p TC |- lvalue_base `[ expression_index ] : typedLvalueIR
  ---- ;; check base lvalue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `# `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the lvalue is a header stack
  -- if typeIR `[ n_size ] = $canon(typeIR_base)
  ---- ;; check index expression
  -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
  -- if _ `# `( typeIR_index ctk_index ) = typedExpressionIR_index
  ---- ;; check that the index is compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_index_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_index,
          def $compat_array_index
        )
  ---- ;; if the index is not local compile-time known, no range check is done
  -- if ctk_index =/= LCTK
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (typedLvalueIR_base `[ typedExpressionIR_index_reduced ])
          `# `( typeIR )

;;; lvalue `[ expression `: expression ]

rule Lvalue_ok/lvalue-expression-expression:
  p TC |- lvalue_base `[ expression_hi `: expression_lo ] : typedLvalueIR
  ---- ;; check base lvalue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `# `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the base lvalue is compatible
  -- if $compat_bitslice_base(typeIR_base)
  ---- ;; check index expressions
  -- Expr_ok: p TC |- expression_hi : typedExpressionIR_hi
  -- Expr_ok: p TC |- expression_lo : typedExpressionIR_lo
  ---- ;; check that the indices are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_hi_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_hi,
          def $compat_bitslice_index
        )
  -- if typedExpressionIR_lo_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_lo,
          def $compat_bitslice_index
        )
  ---- ;; fetch index annotations
  -- if _ `# `( typeIR_hi_reduced ctk_hi_reduced )
      = typedExpressionIR_hi_reduced
  -- if _ `# `( typeIR_lo_reduced ctk_lo_reduced )
      = typedExpressionIR_lo_reduced
  ---- ;; check that the indices are local compile-time known
  -- if ctk_hi_reduced = LCTK
  -- Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi
  -- if n_hi = $to_number(value_hi)
  -- if ctk_lo_reduced = LCTK
  -- Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo
  -- if n_lo = $to_number(value_lo)
  ---- ;; check that the slice is valid
  -- if $is_valid_bitslice(typeIR_base, n_lo, n_hi)
  ---- ;; create typed lvalue
  -- if typeIR = BIT `< $(n_hi - n_lo + 1) >
  -- if typedLvalueIR
      = (typedLvalueIR_base
          `[ typedExpressionIR_hi_reduced `: typedExpressionIR_lo_reduced ])
          `# `( typeIR )

;;; `( lvalue )

rule Lvalue_ok/parenthesized:
  p TC |- `( lvalue_base ) : typedLvalueIR
  ---- ;; check base lvalue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `# `( typeIR_base ) = typedLvalueIR_base
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (`( typedLvalueIR_base )) `# `( typeIR_base )
