;;
;; Parser local declaration typing
;;
;; syntax parserLocalDeclaration
;;

;;; constantDeclaration

rule ParserLocalDecl_ok/constantDeclaration:
  TC_0 |- constantDeclaration
        : TC_1 constantDeclarationIR
  -- Decl_ok: BLOCK TC_0 |- constantDeclaration
                          : TC_1 constantDeclarationIR

;;; instantiation

rule ParserLocalDecl_ok/instantiation:
  TC_0 |- instantiation
        : TC_1 instantiationIR
  -- Decl_ok: BLOCK TC_0 |- instantiation
                          : TC_1 instantiationIR

;;; variableDeclaration
;;; syntax variableDeclaration =
;;;   annotationList type name initializerOpt `;

rule ParserLocalDecl_ok/variableDeclaration-empty:
  TC_0 |- annotationList type name `EMPTY `;
        : TC_1 variableDeclarationIR
  ---- ;; check type
  -- Type_ok: BLOCK TC_0 |- type : typeIR `# eps
  -- Type_wf: $bound(BLOCK, TC_0) |- typeIR
  ---- ;; check that the type is assignable
  -- if $is_assignable_typeIR(typeIR)
  ---- ;; update the context
  -- if nameIR = $name(name)
  -- if TC_1 = $add_var(BLOCK, TC_0, nameIR, INOUT typeIR DYN eps)
  ---- ;; create IR
  -- if variableDeclarationIR
      = annotationList typeIR nameIR eps `;

rule ParserLocalDecl_ok/variableDeclaration-initializer:
  TC_0 |- annotationList type name (`= expression_init) `;
        : TC_1 variableDeclarationIR
  ---- ;; check type
  -- Type_ok: BLOCK TC_0 |- type : typeIR `# eps
  -- Type_wf: $bound(BLOCK, TC_0) |- typeIR
  ---- ;; check that the type is assignable
  -- if $is_assignable_typeIR(typeIR)
  ---- ;; check expression
  -- Expr_ok: BLOCK TC_0 |- expression_init : typedExpressionIR_init
  ---- ;; check that the expression matches the type
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_init_cast
      = $coerce_unary(typedExpressionIR_init, typeIR)
  ---- ;; update the context
  -- if nameIR = $name(name)
  -- if TC_1 = $add_var(BLOCK, TC_0, nameIR, INOUT typeIR DYN eps)
  ---- ;; create IR
  -- if variableDeclarationIR
      = annotationList typeIR nameIR (`= typedExpressionIR_init_cast) `;

;;; valueSetDeclaration
;;; syntax valueSetDeclaration =
;;;   annotationList VALUE_SET `< valueSetType > `( expression ) name `;

rule ParserLocalDecl_ok/valueSetDeclaration:
  TC_0 |- annotationList VALUE_SET `< valueSetType > `( expression ) name `;
       : TC_1 valueSetDeclarationIR
  ---- ;; check type
  -- Type_ok: BLOCK TC_0 |- valueSetType : typeIR `# eps
  ---- ;; check that the type can be embedded in a set
  -- Type_wf: $bound(BLOCK, TC_0) |- SET `< typeIR >
  ---- ;; check expression
  -- Expr_ok: BLOCK TC_0 |- expression : typedExpressionIR
  ---- ;; check that the expression is compile-time known
  -- if _ `# `( _ ctk ) = typedExpressionIR
  -- if ctk =/= DYN
  ---- ;; add the value set to the context
  -- if nameIR = $name(name)
  -- if TC_1 = $add_var(BLOCK, TC_0, nameIR, `EMPTY (SET `< typeIR >) CTK eps)
  ---- ;; create IR
  -- if valueSetDeclarationIR
      = annotationList VALUE_SET `< typeIR > `( typedExpressionIR ) nameIR `;

;;
;; Parser local declaration list typing
;;
;; syntax parserLocalDeclarationList
;;

rule ParserLocalDecls_ok/nil:
  TC |- eps : TC eps

rule ParserLocalDecls_ok/cons:
  TC_0 |- parserLocalDeclaration_h :: parserLocalDeclaration_t*
       : TC_2 (parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*)
  -- ParserLocalDecl_ok: TC_0 |- parserLocalDeclaration_h
                               : TC_1 parserLocalDeclarationIR_h
  -- ParserLocalDecls_ok: TC_1 |- parserLocalDeclaration_t*
                                : TC_2 parserLocalDeclarationIR_t*
