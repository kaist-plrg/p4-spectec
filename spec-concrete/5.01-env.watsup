;;
;; Static type representation
;;

syntax varTypeIR = direction typeIR ctk value?

;;
;; Environments
;;

;; Map from variable identifiers to static types
syntax frame = map<id, varTypeIR>

dec $empty_frame() : frame
def $empty_frame() = $empty_map<id, varTypeIR>

;; Map from type identifiers to type definitions
syntax tdenv = map<tid, typeDefIR>

dec $empty_tdenv() : tdenv
def $empty_tdenv() = $empty_map<tid, typeDefIR>

;; Map from routine identifiers to routine type definitions
syntax rdenv = map<rid, routineTypeDefIR>

dec $empty_rdenv() : rdenv
def $empty_rdenv() = $empty_map<rid, routineTypeDefIR>

;; Map from constructor identifiers to constructor type definitions
syntax cdenv = map<cid, constructorTypeDefIR>

dec $empty_cdenv() : cdenv
def $empty_cdenv() = $empty_map<cid, constructorTypeDefIR>

;;
;; Callable overload resolution
;;

dec $check_routine_name(id, id) : bool
def $check_routine_name(id_l, id_r) = id_l = id_r

dec $check_arity((id?)*, id*) : bool
def $check_arity((id_arg?)*, id_param*) = $(|(id_arg?)*| = |id_param*|)

dec $check_arity_more((id?)*, id*) : bool
def $check_arity_more((id_arg?)*, id_param*) = $(|(id_arg?)*| > |id_param*|)

dec $check_arity_less((id?)*, id*) : bool
def $check_arity_less((id_arg?)*, id_param*) = $(|(id_arg?)*| < |id_param*|)

dec $get_missing_default_parameters(pid*, id*) : id*

def $get_missing_default_parameters(eps, id_arg*) = eps
def $get_missing_default_parameters(
    (id_param `# true) :: pid*,
    id_arg*
  )
  = id_param :: $get_missing_default_parameters(pid*, id_arg*)
  -- if ~$in_set<id>(id_param, `{ id_arg* })
def $get_missing_default_parameters(pid_h :: pid_t*, id_arg*)
  = $get_missing_default_parameters(pid_t*, id_arg*)
  -- otherwise

;; Check match between parameters and named arguments
dec $find_match_named<V>(rid, V, id*, pid*) : (rid, V, id*)?

def $find_match_named<V>(rid, V, id_arg*, (id_param `# bool_param)*)
  = (rid, V, eps)
  -- if $eq_set<id>(`{ id_arg* }, `{ id_param* })
def $find_match_named<V>(rid, V, id_arg*, pid*) = eps
  -- otherwise

;; Check match between parameters and named arguments, with default arguments
dec $find_match_named_default<V>(rid, V, id*, pid*) : (rid, V, id*)?

def $find_match_named_default<V>(rid, V, id_arg*, pid*)
  = (rid, V, id_default*)
  -- if id_default* = $get_missing_default_parameters(pid*, id_arg*)
  -- if $find_match_named<V>(
          rid, V,
          id_arg* ++ id_default*,
          pid*
        ) =/= eps
def $find_match_named_default<V>(rid, V, id_arg*, pid*) = eps
  -- otherwise

;; Check match between parameters and unnamed arguments, with default arguments
dec $find_match_unnamed_default<V>(rid, V, (id?)*, pid*) : (rid, V, id*)?

def $find_match_unnamed_default<V>(rid, V, (id_arg?)*, pid*)
  = (rid, V, id_default*)
  -- if (_, (id_default `# true)*) = $partition_<pid>(pid*, |(id_arg?)*|)
def $find_match_unnamed_default<V>(rid, V, (id_arg?)*, pid*) = eps
  -- otherwise

;; Check if a callable matches the given name and arguments
dec $find_matching<V>(id, (id?)*, id*, rid, V) : (rid, V, id*)?

;; When callable names do not match
def $find_matching<V>(id_r, (id_arg?)*, id_arg'*, id_r' `( pid_r'* ), V)
  = eps
  -- if ~$check_routine_name(id_r, id_r')
;; When callable names match, but the arity of arguments is greater than that of parameters
def $find_matching<V>(
    id_r, (id_arg?)*, id_arg'*,
    id_r' `( (id_param' `# bool_param')* ), V
  )
  = eps
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity_more((id_arg?)*, id_param'*)
;; When callable names and arity match on named arguments, i.e., no default arguments
def $find_matching<V>(
    id_r, (id_arg?)*, id_arg'*,
    id_r' `( (id_param' `# bool_param')* ), V
  )
  = $find_match_named<V>(
      id_r' `( (id_param' `# bool_param')* ),
      V, id_arg'*, (id_param' `# bool_param')*
    )
  -- if $(|id_arg'*| > 0)
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity((id_arg?)*, id_param'*)
;; When callable names and arity match on unnamed arguments, i.e., no default arguments
def $find_matching<V>(
    id_r, (id_arg?)*, eps,
    id_r' `( (id_param' `# bool_param')* ), V
  )
  = (id_r' `( (id_param' `# bool_param')* ), V, eps)
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity((id_arg?)*, id_param'*)
;; When callable names match and arity is less than that of parameters, with named arguments
def $find_matching<V>(
    id_r, (id_arg?)*, id_arg'*,
    id_r' `( (id_param' `# bool_param')* ), V
  )
  = $find_match_named_default<V>(
      id_r' `( (id_param' `# bool_param')* ),
      V, id_arg'*, (id_param' `# bool_param')*
    )
  -- if $(|id_arg'*| > 0)
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity_less((id_arg?)*, id_param'*)
;; When callable names match and arity is less than that of parameters, with unnamed arguments
def $find_matching<V>(
    id_r, (id_arg?)*, eps,
    id_r' `( (id_param' `# bool_param')* ), V
  )
  = $find_match_unnamed_default<V>(
      id_r' `( (id_param' `# bool_param' )* ),
      V, (id_arg?)*, (id_param' `# bool_param')*
    )
  -- if $check_routine_name(id_r, id_r')
  -- if $check_arity_less((id_arg?)*, id_param'*)

;; Find all callables that match the given name and arguments
dec $find_matchings<V>(id, (id?)*, id*, rid*, V*) : (rid, V, id*)*

def $find_matchings<V>(
    id_r, (id_arg?)*, id_arg'*,
    eps, eps
  )
  = eps
def $find_matchings<V>(
    id_r, (id_arg?)*, id_arg'*,
    rid_h :: rid_t*, V_h :: V_t*
  )
  = $find_matchings<V>(id_r, (id_arg?)*, id_arg'*, rid_t*, V_t*)
  -- if $find_matching<V>(id_r, (id_arg?)*, id_arg'*, rid_h, V_h) = eps
def $find_matchings<V>(
    id_r, (id_arg?)*, id_arg'*,
    rid_h :: rid_t*, V_h :: V_t*
  )
  = (rid, V, id_default*) :: $find_matchings<V>(id_r, (id_arg?)*, id_arg'*, rid_t*, V_t*)
  -- if (rid, V, id_default*)
      = $find_matching<V>(id_r, (id_arg?)*, id_arg'*, rid_h, V_h)

;; Find a matching callable, given a callable name and arguments
dec $find_overloaded<V>(map<rid, V>, id, (id?)*) : (rid, V, id*)?

;; When all arguments are named
def $find_overloaded<V>(
    `{ (rid `: V)* }, id_r, (id_arg?)*
  )
  = eps
  -- if $(|(id_arg?)*| > 0)
  -- if (id_arg? = id_arg')*
  -- if $find_matchings<V>(id_r, (id_arg?)*, id_arg'*, rid*, V*) = eps
def $find_overloaded<V>(
    `{ (rid `: V)* }, id_r, (id_arg?)*
  )
  = (rid', V', id_default*)
  -- if $(|(id_arg?)*| > 0)
  -- if (id_arg? = id_arg')*
  -- if (rid', V', id_default*)
      = $find_matchings<V>(id_r, (id_arg?)*, id_arg'*, rid*, V*)
;; When all arguments are unnamed
def $find_overloaded<V>(
    `{ (rid `: V)* }, id_r, (id_arg?)*
  )
  = eps
  -- if (id_arg? = eps)*
  -- if $find_matchings<V>(id_r, (id_arg?)*, eps, rid*, V*) = eps
def $find_overloaded<V>(
    `{ (rid `: V)* }, id_r, (id_arg?)*
  )
  = (rid', V', id_default*)
  -- if (id_arg? = eps)*
  -- if (rid', V', id_default*)
      = $find_matchings<V>(id_r, (id_arg?)*, eps, rid*, V*)

;;
;; Callable non-overload resolution
;;

dec $find_non_overloaded<V>(map<rid, V>, id) : V?
dec $find_non_overloaded'<V>(map<rid, V>, id) : V*

def $find_non_overloaded<V>(`{ (rid `: V)* }, id) = V'
  -- if V' = $find_non_overloaded'<V>(`{ (rid `: V)* }, id)
def $find_non_overloaded<V>(`{ (rid `: V)* }, id) = eps
  -- otherwise

def $find_non_overloaded'<V>(`{ eps }, id) = eps
def $find_non_overloaded'<V>(
    `{ (rid_h `: V_h) :: (rid_t `: V_t)* }, id
  )
  = V_h :: V_t_found*
  -- if id `( _ ) = rid_h
  -- if V_t_found*
      = $find_non_overloaded'<V>(`{ (rid_t `: V_t)* }, id)
def $find_non_overloaded'<V>(
    `{ (rid_h `: V_h) :: (rid_t `: V_t)* }, id
  )
  = V_t_found*
  -- if id_h `( _ ) = rid_h
  -- if id =/= id_h
  -- if V_t_found*
      = $find_non_overloaded'<V>(`{ (rid_t `: V_t)* }, id)
