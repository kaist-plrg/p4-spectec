;;
;; Table key property typing
;;
;; syntax tableKey = expression `: name annotationList `;
;;

dec $compat_table_exact_optional_key(typeIR) : bool
dec $compat'_table_exact_optional_key(typeIR) : bool

def $compat_table_exact_optional_key(typeIR)
  = $compat'_table_exact_optional_key($canon(typeIR))
def $compat'_table_exact_optional_key(BOOL) = true
def $compat'_table_exact_optional_key(ERROR) = true
def $compat'_table_exact_optional_key(numberTypeIR) = true
def $compat'_table_exact_optional_key(TYPE _ typeIR)
  = $compat_table_exact_optional_key(typeIR)
def $compat'_table_exact_optional_key(ENUM _ `{ _ }) = true
def $compat'_table_exact_optional_key(ENUM _ `# typeIR `{ _ })
  = $compat_table_exact_optional_key(typeIR)

dec $compat_table_lpm_ternary_range_key(typeIR) : bool
dec $compat'_table_lpm_ternary_range_key(typeIR) : bool

def $compat_table_lpm_ternary_range_key(typeIR)
  = $compat'_table_lpm_ternary_range_key($canon(typeIR))
def $compat'_table_lpm_ternary_range_key(INT) = true
def $compat'_table_lpm_ternary_range_key(INT `< _ >) = true
def $compat'_table_lpm_ternary_range_key(BIT `< _ >) = true
def $compat'_table_lpm_ternary_range_key(TYPE _ typeIR)
  = $compat_table_lpm_ternary_range_key(typeIR)
def $compat'_table_lpm_ternary_range_key(ENUM _ `# typeIR `{ _ })
  = $compat_table_lpm_ternary_range_key(typeIR)

dec $compat_table_key(nameIR, typeIR) : bool

def $compat_table_key(nameIR, typeIR) = true
  -- if nameIR = "exact" \/ nameIR = "optional"
  -- if $compat_table_exact_optional_key(typeIR)

def $compat_table_key(nameIR, typeIR) = true
  -- if nameIR = "lpm" \/ nameIR = "ternary" \/ nameIR = "range"
  -- if $compat_table_lpm_ternary_range_key(typeIR)

def $compat_table_key(nameIR, typeIR) = false
  -- otherwise

rule TableKey_ok:
  TC TBLC_0 |- expression `: name_matchkind annotationList `;
             : TBLC_2 tableKeyIR
  ---- ;; check expression
  -- Expr_ok: LOCAL TC |- expression : typedExpressionIR
  -- if _ `# `( typeIR _ ) = typedExpressionIR
  ---- ;; check that the expression can be embedded in a set
  -- Type_wf: $bound(LOCAL, TC) |- SET `< typeIR >
  ---- ;; check match kind
  -- if nameIR_matchkind = $name(name_matchkind)
  -- if MATCH_KIND `. nameIR_matchkind = $find_value(LOCAL, TC, `` nameIR_matchkind)
  ---- ;; check compatibility with the match kind
  -- if $compat_table_key(nameIR_matchkind, typeIR)
  ---- ;; update table context
  -- if TBLC_1 = $update_mode(TBLC_0, nameIR_matchkind, typeIR)
  -- if TBLC_2 = $add_key(TBLC_1, nameIR_matchkind, typeIR)
  ---- ;; create IR
  -- if tableKeyIR = typedExpressionIR `: nameIR_matchkind annotationList `;

;;
;; Table key property list typing
;;
;; syntax tableKeyList
;;

rule TableKeys_ok/nil:
  TC TBLC |- eps : TBLC eps

rule TableKeys_ok/cons:
  TC TBLC_0 |- (tableKey_h :: tableKey_t*)
             : TBLC_2 (tableKeyIR_h :: tableKeyIR_t*)
  -- TableKey_ok: TC TBLC_0 |- tableKey_h : TBLC_1 tableKeyIR_h
  -- TableKeys_ok: TC TBLC_1 |- tableKey_t* : TBLC_2 tableKeyIR_t*

;;
;; Table action property typing
;;
;; syntax tableAction
;;

dec $split_dataplane_parameters(parameterTypeIR*)
  : (parameterTypeIR*, parameterTypeIR*)

def $split_dataplane_parameters(eps) = (eps, eps)
def $split_dataplane_parameters(parameterTypeIR_h :: parameterTypeIR_t*)
  = (parameterTypeIR_data*, parameterTypeIR_h :: parameterTypeIR_control*)
  -- if `EMPTY _ _ _ = parameterTypeIR_h
  -- if (parameterTypeIR_data*, parameterTypeIR_control*)
      = $split_dataplane_parameters(parameterTypeIR_t*)
def $split_dataplane_parameters(parameterTypeIR_h :: parameterTypeIR_t*)
  = (parameterTypeIR_h :: parameterTypeIR_data*, parameterTypeIR_control*)
  -- if direction _ _ _ = parameterTypeIR_h
  -- if direction =/= `EMPTY
  -- if (parameterTypeIR_data*, parameterTypeIR_control*)
      = $split_dataplane_parameters(parameterTypeIR_t*)

rule Call_action_partial_ok:
  TC |- parameterTypeIR* `@ argumentIR*
      : parameterTypeIR_data* `, parameterTypeIR_control*
        `@ argumentIR_cast*
  ---- ;; split parameters into data- and control-planes
  -- if (parameterTypeIR_data*, parameterTypeIR_control*)
      = $split_dataplane_parameters(parameterTypeIR*)
  ---- ;; check arity 
  -- if $(|parameterTypeIR_data*| = |argumentIR*|)
  ---- ;; check calling convention on dataplane parameters
  -- Call_convention_ok:
      LOCAL TC ACTION |- parameterTypeIR_data* `@ argumentIR*
                       : argumentIR_cast*

;;; syntax tableAction = annotationList tableActionReference `;
;;;; syntax tableActionReference

;;;; prefixedNonTypeName

rule TableAction_ok/prefixedNonTypeName:
  TC TBLC_0 |- annotationList prefixedNonTypeName `;
             : TBLC_1 tableActionIR
  ---- ;; check that the action exists
  -- if prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
  -- if ACTION `( parameterTypeIR* )
      = $find_routine_non_overloaded(LOCAL, TC, prefixedNameIR)
  ---- ;; check that the action reference is a valid data-plane call
  -- Call_action_partial_ok: TC |- parameterTypeIR* `@ eps
                                 : parameterTypeIR_data* `, parameterTypeIR_control*
                                   `@ eps
  ---- ;; update the table context with the action
  -- if TBLC_1 = $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*, eps)
  ---- ;; create IR
  -- if tableActionIR = annotationList (prefixedNameIR `( eps )) `;

;;;; prefixedNonTypeName `( argumentList )

rule TableAction_ok/prefixedNonTypeName-argumentList:
  TC TBLC_0 |- annotationList (prefixedNonTypeName `( argumentList )) `;
             : TBLC_1 tableActionIR
  ---- ;; check that the action exists
  -- if prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
  -- if ACTION `( parameterTypeIR* )
      = $find_routine_non_overloaded(LOCAL, TC, prefixedNameIR)
  ---- ;; check arguments
  -- if argument* = $flatten_argumentList(argumentList)
  -- (Argument_ok: LOCAL TC |- argument : argumentIR)*
  ---- ;; check that the action reference is a valid data-plane call
  -- Call_action_partial_ok: TC |- parameterTypeIR* `@ argumentIR*
                                 : parameterTypeIR_data* `, parameterTypeIR_control*
                                   `@ argumentIR_cast*
  ---- ;; update the table context with the action
  -- if TBLC_1 = $add_action(TBLC_0, prefixedNameIR, parameterTypeIR*, argumentIR_cast*)
  ---- ;; create IR
  -- if tableActionIR = annotationList (prefixedNameIR `( argumentIR_cast* )) `;

;;
;; Table action property list typing
;;
;; syntax tableActionList
;;

rule TableActions_ok/nil:
  TC TBLC |- eps : TBLC eps

rule TableActions_ok/cons:
  TC TBLC_0 |- (tableAction_h :: tableAction_t*)
             : TBLC_2 (tableActionIR_h :: tableActionIR_t*)
  -- TableAction_ok: TC TBLC_0 |- tableAction_h : TBLC_1 tableActionIR_h
  -- TableActions_ok: TC TBLC_1 |- tableAction_t* : TBLC_2 tableActionIR_t*

;;
;; Table default action property typing
;;
;; syntax tableDefaultAction (doesn't exist in the grammar)
;;

rule Call_action_default_ok:
  TC |- parameterTypeIR* `@ argumentIR*
      : parameterTypeIR_data* `, parameterTypeIR_control*
        `@ argumentIR_cast*
  ---- ;; split parameters into data- and control-planes
  -- if (parameterTypeIR_data*, parameterTypeIR_control*)
      = $split_dataplane_parameters(parameterTypeIR*)
  ---- ;; check calling convention
  -- Call_convention_ok:
      LOCAL TC ACTION |- parameterTypeIR* `@ argumentIR*
                       : argumentIR_cast*

;;; prefixedNonTypeName

rule TableDefaultAction_ok/prefixedNonTypeName:
  TC TBLC |- `= prefixedNonTypeName
           : prefixedNameIR `( eps )
  ---- ;; find matching action
  -- if prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
  -- if (eps, eps) = $find_action(TBLC, prefixedNameIR)

;;; prefixedNonTypeName `( argumentList )

rule TableDefaultAction_ok/prefixedNonTypeName-argumentList:
  TC TBLC |- `= (prefixedNonTypeName `( argumentList ))
           : prefixedNameIR `( argumentIR_cast* )
  ---- ;; find matching action
  -- if prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
  -- if (parameterTypeIR_action*, argumentIR_action*)
      = $find_action(TBLC, prefixedNameIR)
  ---- ;; check arguments
  -- if argument* = $flatten_argumentList(argumentList)
  -- (Argument_ok: LOCAL TC |- argument : argumentIR)*
  ---- ;; check calling convention
  -- Call_action_default_ok:
      TC |- parameterTypeIR_action* `@ argumentIR*
          : parameterTypeIR_action_data* `, parameterTypeIR_action_control*
            `@ argumentIR_cast*
  ---- ;; arguments must be syntatcially equivalent to
  ---- ;; dataplane arguments specified in the actions list property
  -- if argumentIR_action_data*
      = argumentIR_action*[0 : |parameterTypeIR_action_data*|] 
  -- if argumentIR_cast_data*
      = argumentIR_cast*[0 : |parameterTypeIR_action_data*|]
  -- if (argumentIR_action_data = argumentIR_cast_data)*

;;
;; Table entry property typing
;;
;; syntax tableEntry
;;

;;
;;;; Table entry simple keyset typing
;;;;
;;;; syntax simpleKeysetExpression
;;

relation TableEntry_keyset_simple_ok:
  typingContext tableContext |- matchKey `@ simpleKeysetExpression
                              : tableEntryState simpleKeysetExpressionIR
  hint(input %0 %1 %2 %3)

;;;;;; expression

rule TableEntry_keyset_simple_ok/expression-lpm:
  TC TBLC |- (typeIR_key, "lpm") `@ expression
           : (LPM n) typedExpressionIR_set
  ---- ;; check match mode
  -- if TBLC.MODE = NOPRILPM n
  ---- ;; check expression
  -- Expr_ok: LOCAL TC |- expression : typedExpressionIR
  -- if _ `# `( typeIR ctk ) = typedExpressionIR
  ---- ;; check compatibility with the key type
  -- Sub_impl: typeIR <: typeIR_key
  ---- ;; lift the expression to set type
  -- if typeIR_set = SET `< typeIR_key >
  -- if typedExpressionIR_set
      = (`( typeIR_set ) typedExpressionIR) `# `( typeIR_set ctk )

rule TableEntry_keyset_simple_ok/expression-non-lpm:
  TC TBLC |- (typeIR_key, nameIR_matchkind) `@ expression
           : NOLPM typedExpressionIR_set
  ---- ;; check match mode
  -- if nameIR_matchkind =/= "lpm"
  ---- ;; check expression
  -- Expr_ok: LOCAL TC |- expression : typedExpressionIR
  -- if _ `# `( typeIR ctk ) = typedExpressionIR
  ---- ;; check compatibility with the key type
  -- Sub_impl: typeIR <: typeIR_key
  ---- ;; lift the expression to set type
  -- if typeIR_set = SET `< typeIR_key >
  -- if typedExpressionIR_set
      = (`( typeIR_set ) typedExpressionIR) `# `( typeIR_set ctk )

;;;;;; expression `&&& expression

rule TableEntry_keyset_simple_ok/mask-lpm:
  TC TBLC |- (typeIR_key, "lpm") `@ (expression_l `&&& expression_r)
           : (LPM n_prefix) (typedExpressionIR_l_reduced `&&& typedExpressionIR_r_reduced)
  ---- ;; check match mode
  -- if TBLC.MODE = NOPRILPM n
  ---- ;; check both sides
  -- Expr_ok: LOCAL TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: LOCAL TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_cast, typedExpressionIR_r_cast)
        = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l_cast,
            typedExpressionIR_r_cast,
            def $compat_mask
          )
  ---- ;; fetch the type
  -- if _ `# `( typeIR_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; check compatibility with the key type
  -- Sub_impl: typeIR_reduced <: typeIR_key
  ---- ;; statically evaluate the right hand side to get its width
  -- if ctk_r_reduced = LCTK
  -- Eval_static: LOCAL TC |- typedExpressionIR_r_reduced ~> value_r
  -- if i_r = $to_number(value_r)
  ---- ;; compute the table entry state
  -- if n_prefix = $tableEntry_lpm_prefix(n W $to_bitstr(n, i_r))

rule TableEntry_keyset_simple_ok/mask-ternary:
  TC TBLC |- (typeIR_key, "ternary") `@ (expression_l `&&& expression_r)
           : NOLPM (typedExpressionIR_l_reduced `&&& typedExpressionIR_r_reduced)
  ---- ;; check both sides
  -- Expr_ok: LOCAL TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: LOCAL TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_cast, typedExpressionIR_r_cast)
        = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l_cast,
            typedExpressionIR_r_cast,
            def $compat_mask
          )
  ---- ;; fetch the type
  -- if _ `# `( typeIR_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; check compatibility with the key type
  -- Sub_impl: typeIR_reduced <: typeIR_key

;;;;;; expression `.. expression

rule TableEntry_keyset_simple_ok/range-range:
  TC TBLC |- (typeIR_key, "range") `@ (expression_l `.. expression_r)
           : NOLPM (typedExpressionIR_l_reduced `.. typedExpressionIR_r_reduced)
  ---- ;; check both sides
  -- Expr_ok: LOCAL TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: LOCAL TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_cast, typedExpressionIR_r_cast)
        = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l_cast,
            typedExpressionIR_r_cast,
            def $compat_range
          )
  ---- ;; fetch the type
  -- if _ `# `( typeIR_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; check compatibility with the key type
  -- Sub_impl: typeIR_reduced <: typeIR_key

;;;;;; DEFAULT

rule TableEntry_keyset_simple_ok/default-lpm:
  TC TBLC |- (typeIR_key, "lpm") `@ DEFAULT : (LPM n) DEFAULT
  ---- ;; check match mode
  -- if TBLC.MODE = NOPRILPM n

rule TableEntry_keyset_simple_ok/default-else:
  TC TBLC |- (typeIR_key, nameIR_matchkind) `@ DEFAULT : NOLPM DEFAULT
  ---- ;; cannot use default for exact match
  -- if nameIR_matchkind =/= "exact"

;;;;;; `_

rule TableEntry_keyset_simple_ok/dontcare-lpm:
  TC TBLC |- (typeIR_key, "lpm") `@ `_ : (LPM 0) `_
  ---- ;; check match mode
  -- if TBLC.MODE = NOPRILPM _

rule TableEntry_keyset_simple_ok/dontcare-else:
  TC TBLC |- (typeIR_key, nameIR_matchkind) `@ `_ : NOLPM `_
  ---- ;; cannot use don't care for exact match
  -- if nameIR_matchkind =/= "exact"

;;
;;;; Table entry simple keyset list typing
;;;;
;;;; syntax simpleKeysetExpressionList
;;

relation TableEntry_keysets_simple_ok:
  typingContext tableContext tableEntryState |- matchKey* `@ simpleKeysetExpression*
                                              : tableEntryState simpleKeysetExpressionIR*
  hint(input %0 %1 %2 %3 %4)

rule TableEntry_keysets_simple_ok/nil:
  TC TBLC TBLS |- eps `@ eps : TBLS eps

rule TableEntry_keysets_simple_ok/cons:
  TC TBLC TBLS_0 |- (matchKey_h :: matchKey_t*)
                    `@ (simpleKeysetExpression_h :: simpleKeysetExpression_t*)
                  : TBLS_3 (simpleKeysetExpressionIR_h :: simpleKeysetExpressionIR_t*)
  -- TableEntry_keyset_simple_ok:
      TC TBLC |- matchKey_h `@ simpleKeysetExpression_h
               : TBLS_1 simpleKeysetExpressionIR_h
  -- if TBLS_2 = $join_tableEntryState(TBLS_0, TBLS_1)
  -- TableEntry_keysets_simple_ok:
      TC TBLC TBLS_2 |- matchKey_t* `@ simpleKeysetExpression_t*
                      : TBLS_3 simpleKeysetExpressionIR_t*

;;
;;;; Table keyset typing
;;;;
;;;; syntax keysetExpression
;;

;;;;; simpleKeysetExpression
;;;;; syntax simpleKeysetExpression

;;;;;; expression

rule TableEntry_keyset_ok/simpleKeysetExpression-expression:
  TC TBLC |- expression : TBLS simpleKeysetExpressionIR
  ---- ;; check arity
  -- if $(|TBLC.KEYS| = 1)
  ---- ;; check that the expression matches the key type
  -- TableEntry_keysets_simple_ok:
      TC TBLC NOLPM |- TBLC.KEYS `@ expression
                     : TBLS simpleKeysetExpressionIR

;;;;;; expression `&&& expression

rule TableEntry_keyset_ok/simpleKeysetExpression-mask:
  TC TBLC |- expression_l `&&& expression_r : TBLS simpleKeysetExpressionIR
  ---- ;; check arity
  -- if $(|TBLC.KEYS| = 1)
  ---- ;; check that the expression matches the key type
  -- TableEntry_keysets_simple_ok:
      TC TBLC NOLPM |- TBLC.KEYS `@ (expression_l `&&& expression_r)
                     : TBLS simpleKeysetExpressionIR

;;;;;; expression `.. expression

rule TableEntry_keyset_ok/simpleKeysetExpression-range:
  TC TBLC |- expression_l `.. expression_r : TBLS simpleKeysetExpressionIR
  ---- ;; check arity
  -- if $(|TBLC.KEYS| = 1)
  ---- ;; check that the expression matches the key type
  -- TableEntry_keysets_simple_ok:
      TC TBLC NOLPM |- TBLC.KEYS `@ (expression_l `.. expression_r)
                     : TBLS simpleKeysetExpressionIR

;;;;;; DEFAULT

rule TableEntry_keyset_ok/simpleKeysetExpression-default-noprilpm:
  TC TBLC |- DEFAULT : TBLS DEFAULT
  -- if TBLC.MODE = NOPRILPM n
  -- if TBLS = LPM n

rule TableEntry_keyset_ok/simpleKeysetExpression-default-else:
  TC TBLC |- DEFAULT : TBLS DEFAULT
  -- if TBLC.MODE = NOPRI \/ TBLC.MODE = PRI \/ TBLC.MODE = PRILPM
  -- if TBLS = NOLPM

;;;;;; `_

rule TableEntry_keyset_ok/simpleKeysetExpression-dontcare-noprilpm:
  TC TBLC |- `_ : TBLS `_
  -- if TBLC.MODE = NOPRILPM n
  -- if TBLS = LPM 0

rule TableEntry_keyset_ok/simpleKeysetExpression-dontcare-else:
  TC TBLC |- `_ : TBLS `_
  -- if TBLC.MODE = NOPRI \/ TBLC.MODE = PRI \/ TBLC.MODE = PRILPM
  -- if TBLS = NOLPM

;;;;; tupleKeysetExpression
;;;;; syntax tupleKeysetExpression

;;;;;; `( expression `&&& expression )

rule TableEntry_keyset_ok/tupleKeysetExpression-mask:
  TC TBLC |- `( expression_l `&&& expression_r )
           : TBLS (`( simpleKeysetExpressionIR ))
  ---- ;; check arity
  -- if $(|TBLC.KEYS| = 1)
  ---- ;; check that the expression matches the key type
  -- TableEntry_keysets_simple_ok:
      TC TBLC NOLPM |- TBLC.KEYS `@ (expression_l `&&& expression_r)
                     : TBLS simpleKeysetExpressionIR

;;;;;; `( expression `.. expression )

rule TableEntry_keyset_ok/tupleKeysetExpression-range:
  TC TBLC |- `( expression_l `.. expression_r )
           : TBLS (`( simpleKeysetExpressionIR ))
  ---- ;; check arity
  -- if $(|TBLC.KEYS| = 1)
  ---- ;; check that the expression matches the key type
  -- TableEntry_keysets_simple_ok:
      TC TBLC NOLPM |- TBLC.KEYS `@ (expression_l `.. expression_r)
                     : TBLS simpleKeysetExpressionIR

;;;;;; `( DEFAULT )

rule TableEntry_keyset_ok/tupleKeysetExpression-default-noprilpm:
  TC TBLC |- `( DEFAULT ) : TBLS (`( DEFAULT ))
  -- if TBLC.MODE = NOPRILPM n
  -- if TBLS = LPM n

rule TableEntry_keyset_ok/tupleKeysetExpression-default-else:
  TC TBLC |- `( DEFAULT ) : TBLS (`( DEFAULT ))
  -- if TBLC.MODE = NOPRI \/ TBLC.MODE = PRI \/ TBLC.MODE = PRILPM
  -- if TBLS = NOLPM

;;;;;; `( `_ )

rule TableEntry_keyset_ok/tupleKeysetExpression-dontcare-noprilpm:
  TC TBLC |- `( `_ ) : TBLS (`( `_ ))
  -- if TBLC.MODE = NOPRILPM n
  -- if TBLS = LPM 0

rule TableEntry_keyset_ok/simpleKeysetExpression-dontcare-else:
  TC TBLC |- `( `_ ) : TBLS (`( `_ ))
  -- if TBLC.MODE = NOPRI \/ TBLC.MODE = PRI \/ TBLC.MODE = PRILPM
  -- if TBLS = NOLPM

;;;;;; `( simpleKeysetExpression `, simpleKeysetExpressionList )

rule TableEntry_keyset_ok/tupleKeysetExpression-list:
  TC TBLC |- `( simpleKeysetExpression_h `, simpleKeysetExpressionList_t )
           : TBLS (`( simpleKeysetExpressionIR* ))
  ---- ;; check arity
  -- if simpleKeysetExpression_t*
      = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList_t)
  -- if simpleKeysetExpression*
      = simpleKeysetExpression_h :: simpleKeysetExpression_t*
  -- if |TBLC.KEYS| = |simpleKeysetExpression*|
  ---- ;; check keysets pairwise
  -- TableEntry_keysets_simple_ok:
      TC TBLC NOLPM |- TBLC.KEYS `@ simpleKeysetExpression*
                     : TBLS simpleKeysetExpressionIR*

;;
;;;; Table entry action reference typing
;;;;
;;;; syntax tableActionReference
;;

;;; prefixedNonTypeName

rule TableEntry_action_ok/prefixedNonTypeName:
  TC TBLC |- prefixedNonTypeName : prefixedNameIR `( eps )
  ---- ;; find matching action
  -- if prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
  -- if (eps, eps) = $find_action(TBLC, prefixedNameIR)

;;; prefixedNonTypeName `( argumentList )

rule TableEntry_action_ok/prefixedNonTypeName-argumentList:
  TC TBLC |- (prefixedNonTypeName `( argumentList ))
           : prefixedNameIR `( argumentIR_cast* )
  ---- ;; find matching action
  -- if prefixedNameIR = $prefixedNonTypeName(prefixedNonTypeName)
  -- if (parameterTypeIR_action*, argumentIR_action*)
      = $find_action(TBLC, prefixedNameIR)
  ---- ;; check arguments
  -- if argument* = $flatten_argumentList(argumentList)
  -- (Argument_ok: LOCAL TC |- argument : argumentIR)*
  ---- ;; check calling convention
  -- Call_action_default_ok:
      TC |- parameterTypeIR_action* `@ argumentIR*
          : parameterTypeIR_action_data* `, parameterTypeIR_action_control*
            `@ argumentIR_cast*
  ---- ;; arguments must be syntatcially equivalent to
  ---- ;; dataplane arguments specified in the actions list property
  -- if argumentIR_action_data*
      = argumentIR_action*[0 : |parameterTypeIR_action_data*|] 
  -- if argumentIR_cast_data*
      = argumentIR_cast*[0 : |parameterTypeIR_action_data*|]
  -- if (argumentIR_action_data = argumentIR_cast_data)*

;;
;;;; Table entry priority typing
;;;;
;;;; syntax tableEntryPriorityOpt
;;

;;;;; eps

rule TableEntry_priority_ok/nopri:
  TC TBLC TBLS |- eps : TBLC eps
  -- if TBLC.MODE = NOPRI

rule TableEntry_priority_ok/noprilpm:
  TC TBLC TBLS |- eps : TBLC eps
  -- if TBLC.MODE = NOPRILPM n
  -- if TBLS = LPM n_prefix

rule TableEntry_priority_ok/pri-prilpm-number-init-largest-wins:
  TC TBLC_0 TBLS |- eps : TBLC_1 (PRIORITY `= (D n) `:)
  ---- ;; check match mode
  -- if TBLC_0.MODE = PRI \/ TBLC_0.MODE = PRILPM
  ---- ;; if no priority has been specified yet
  -- if TBLC_0.PRIORITIES.VALUES = eps
  ---- ;; if largest wins
  -- if TBLC_0.PRIORITIES.LARGEST_WINS
  ---- ;; infer and initialize the priority
  -- if n_size = TBLC_0.ENTRIES.SIZE
  -- if n_delta = TBLC_0.PRIORITIES.DELTA
  -- if n = $((n_size - 1) * n_delta + 1)
  -- if TBLC_1 = $add_table_priority(TBLC_0, n)

rule TableEntry_priority_ok/pri-prilpm-number-init-non-largest-wins:
  TC TBLC_0 TBLS |- eps : TBLC_1 (PRIORITY `= (D 1) `:)
  ---- ;; check match mode
  -- if TBLC_0.MODE = PRI \/ TBLC_0.MODE = PRILPM
  ---- ;; if no priority has been specified yet
  -- if TBLC_0.PRIORITIES.VALUES = eps
  ---- ;; if not largest wins
  -- if ~TBLC_0.PRIORITIES.LARGEST_WINS
  ---- ;; infer and initialize the priority
  -- if TBLC_1 = $add_table_priority(TBLC_0, 1)

rule TableEntry_priority_ok/pri-prilpm-number-non-init-largest-wins:
  TC TBLC_0 TBLS |- eps : TBLC_1 (PRIORITY `= (D n) `:)
  ---- ;; check match mode
  -- if TBLC_0.MODE = PRI \/ TBLC_0.MODE = PRILPM
  ---- ;; if priority has been specified
  -- if TBLC_0.PRIORITIES.VALUES =/= eps
  ---- ;; if largest wins
  -- if TBLC_0.PRIORITIES.LARGEST_WINS
  ---- ;; infer the priority
  -- if n_last = $find_table_priority_last(TBLC_0)
  -- if n_delta = TBLC_0.PRIORITIES.DELTA
  -- if n = $(n_last - n_delta)
  -- if TBLC_1 = $add_table_priority(TBLC_0, n)

rule TableEntry_priority_ok/pri-prilpm-number-non-init-non-largest-wins:
  TC TBLC_0 TBLS |- eps : TBLC_1 (PRIORITY `= (D n) `:)
  ---- ;; check match mode
  -- if TBLC_0.MODE = PRI \/ TBLC_0.MODE = PRILPM
  ---- ;; if priority has been specified
  -- if TBLC_0.PRIORITIES.VALUES =/= eps
  ---- ;; if not largest wins
  -- if ~TBLC_0.PRIORITIES.LARGEST_WINS
  ---- ;; infer the priority
  -- if n_last = $find_table_priority_last(TBLC_0)
  -- if n_delta = TBLC_0.PRIORITIES.DELTA
  -- if n = $(n_last + n_delta)
  -- if TBLC_1 = $add_table_priority(TBLC_0, n)

;;;;; PRIORITY `= number `:

rule TableEntry_priority_ok/pri-prilpm-number-init:
  TC TBLC_0 TBLS |- PRIORITY `= number `:
                  : TBLC_2 (PRIORITY `= number `:)
  ---- ;; check match mode
  -- if TBLC_0.MODE = PRI \/ TBLC_0.MODE = PRILPM
  -- if ~TBLC_0.ENTRIES.CONST
  ---- ;; if no priority has been specified yet
  -- if TBLC_0.PRIORITIES.VALUES = eps
  ---- ;; evaluate and initialize the priority
  -- if n = $to_number(number)
  -- if TBLC_1 = TBLC_0[ .PRIORITIES.INIT = true ]
  -- if TBLC_2 = $add_table_priority(TBLC_1, n)

rule TableEntry_priority_ok/pri-prilpm-number-non-init:
  TC TBLC_0 TBLS |- PRIORITY `= number `:
                  : TBLC_1 (PRIORITY `= number `:)
  ---- ;; check match mode
  -- if TBLC_0.MODE = PRI \/ TBLC_0.MODE = PRILPM
  -- if ~TBLC_0.ENTRIES.CONST
  ---- ;; if priority has been specified
  -- if TBLC_0.PRIORITIES.VALUES =/= eps
  -- if TBLC_0.PRIORITIES.INIT
  ---- ;; evaluate and initialize the priority
  -- if n = $to_number(number)
  -- if TBLC_1 = $add_table_priority(TBLC_0, n)

;;;;; PRIORITY `= `( expression ) `:

rule TableEntry_priority_ok/pri-prilpm-expression-init:
  TC TBLC_0 TBLS |- PRIORITY `= `( expression ) `:
                  : TBLC_2 (PRIORITY `= `( typedExpressionIR ) `:)
  ---- ;; check match mode
  -- if TBLC_0.MODE = PRI \/ TBLC_0.MODE = PRILPM
  -- if ~TBLC_0.ENTRIES.CONST
  ---- ;; if no priority has been specified yet
  -- if TBLC_0.PRIORITIES.VALUES = eps
  ---- ;; evaluate and initialize the priority
  -- Expr_ok: LOCAL TC |- expression : typedExpressionIR
  -- if _ `# `( _ LCTK ) = typedExpressionIR
  -- Eval_static: LOCAL TC |- typedExpressionIR ~> value
  -- if n = $to_number(value)
  -- if TBLC_1 = TBLC_0[ .PRIORITIES.INIT = true ]
  -- if TBLC_2 = $add_table_priority(TBLC_1, n)

rule TableEntry_priority_ok/pri-prilpm-expression-non-init:
  TC TBLC_0 TBLS |- PRIORITY `= `( expression ) `:
                  : TBLC_1 (PRIORITY `= `( typedExpressionIR ) `:)
  ---- ;; check match mode
  -- if TBLC_0.MODE = PRI \/ TBLC_0.MODE = PRILPM
  -- if ~TBLC_0.ENTRIES.CONST
  ---- ;; if priority has been specified
  -- if TBLC_0.PRIORITIES.VALUES =/= eps
  -- if TBLC_0.PRIORITIES.INIT
  ---- ;; evaluate and initialize the priority
  -- Expr_ok: LOCAL TC |- expression : typedExpressionIR
  -- if _ `# `( _ LCTK ) = typedExpressionIR
  -- Eval_static: LOCAL TC |- typedExpressionIR ~> value
  -- if n = $to_number(value)
  -- if TBLC_1 = $add_table_priority(TBLC_0, n)
  
;;; constOpt tableEntryPriority
;;;   keysetExpression `: tableActionReference annotationList `; 

rule TableEntry_ok/priority:
  TC TBLC_0 |- constOpt tableEntryPriority
                keysetExpression `: tableActionReference annotationList `;
             : TBLC_1 tableEntryIR
  ---- ;; check entry key
  -- TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR
  ---- ;; check entry action
  -- TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR
  ---- ;; check entry priority
  -- TableEntry_priority_ok: TC TBLC_0 TBLS |- tableEntryPriority
                                             : TBLC_1 tableEntryPriorityOptIR
  ---- ;; create IR
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if tableEntryIR
      = constOptIR tableEntryPriorityOptIR
          keysetExpressionIR `: tableActionReferenceIR annotationList `;

;;; constOpt keysetExpression `: tableActionReference annotationList `; 

rule TableEntry_ok/non-priority:
  TC TBLC_0 |- constOpt
                keysetExpression `: tableActionReference annotationList `;
             : TBLC_1 tableEntryIR
  ---- ;; check entry key
  -- TableEntry_keyset_ok: TC TBLC_0 |- keysetExpression : TBLS keysetExpressionIR
  ---- ;; check entry action
  -- TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR
  ---- ;; check entry priority
  -- TableEntry_priority_ok: TC TBLC_0 TBLS |- eps : TBLC_1 tableEntryPriorityOptIR
  ---- ;; create IR
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if tableEntryIR
      = constOptIR tableEntryPriorityOptIR
          keysetExpressionIR `: tableActionReferenceIR annotationList `;

;;
;; Table entry property list typing
;;
;; syntax tableEntryList
;;

rule TableEntries_ok/nil:
  TC TBLC |- eps : TBLC eps

rule TableEntries_ok/cons:
  TC TBLC_0 |- (tableEntry_h :: tableEntry_t*)
             : TBLC_2 (tableEntryIR_h :: tableEntryIR_t*)
  -- TableEntry_ok: TC TBLC_0 |- tableEntry_h : TBLC_1 tableEntryIR_h
  -- TableEntries_ok: TC TBLC_1 |- tableEntry_t* : TBLC_2 tableEntryIR_t*

;;
;; Table property typing
;;
;; syntax tableProperty
;;

;;; KEY `= `{ tableKeyList }

rule TableProperty_ok/key:
  TC TBLC_0 |- KEY `= `{ tableKeyList }
             : TBLC_1 (KEY `= `{ tableKeyIR* })
  -- if tableKey* = $flatten_tableKeyList(tableKeyList)
  -- TableKeys_ok: TC TBLC_0 |- tableKey* : TBLC_1 tableKeyIR*

;;; ACTIONS `= `{ tableActionList }

rule TableProperty_ok/actions:
  TC TBLC_0 |- ACTIONS `= `{ tableActionList }
             : TBLC_1 (ACTIONS `= `{ tableActionIR* })
  -- if tableAction* = $flatten_tableActionList(tableActionList)
  -- TableActions_ok: TC TBLC_0 |- tableAction* : TBLC_1 tableActionIR*

;;; annotationList constOpt ENTRIES `= `{ tableEntryList }

rule TableProperty_ok/entries:
  TC TBLC_0 |- annotationList constOpt ENTRIES `= `{ tableEntryList }
             : TBLC_3 (annotationList constOptIR ENTRIES `= `{ tableEntryIR* })
  ---- ;; if the table key is empty, then the table entries must be empty
  -- if tableEntry* = $flatten_tableEntryList(tableEntryList)
  -- if $(|TBLC_0.KEYS| = 0) => $(|tableEntry*| = 0)
  ---- ;; set size of table entries
  -- if TBLC_1 = TBLC_0[ .ENTRIES.SIZE = |tableEntry*| ]
  ---- ;; set whether the table entries is constant
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if TBLC_2 = TBLC_1[ .ENTRIES.CONST = (constOptIR = CONST) ]
  ---- ;; check table entries
  -- TableEntries_ok: TC TBLC_2 |- tableEntry* : TBLC_3 tableEntryIR*

;;; annotationList constOpt tableCustomName initializer `;

rule TableProperty_ok/custom-default-action:
  TC TBLC |- annotationList constOpt tableCustomName initializer `;
           : TBLC tablePropertyIR
  ---- ;; check that the custom property is for default action
  -- if "default_action" = $tableCustomName(tableCustomName)
  ---- ;; check the initializer
  -- TableDefaultAction_ok: TC TBLC |- initializer : tableActionReferenceIR
  ---- ;; create IR
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if tablePropertyIR
      = annotationList constOptIR DEFAULT_ACTION `= tableActionReferenceIR `;

rule TableProperty_ok/custom-size:
  TC TBLC |- annotationList constOpt tableCustomName (`= expression) `;
           : TBLC tablePropertyIR
  ---- ;; check that the custom property is for size
  -- if "size" = $tableCustomName(tableCustomName)
  ---- ;; check initializer
  -- Expr_ok: LOCAL TC |- expression : typedExpressionIR
  -- if _ `# `( typeIR _ ) = typedExpressionIR
  -- if $is_arbitrary_int_typeIR(typeIR)
        \/ $is_fixed_int_typeIR(typeIR)
        \/ $is_fixed_bit_typeIR(typeIR)
  ---- ;; create IR
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if tablePropertyIR
      = annotationList constOptIR CUSTOM "size" (`= typedExpressionIR) `;

rule TableProperty_ok/custom-largest-priority-wins:
  TC TBLC_0 |- annotationList constOpt tableCustomName (`= expression) `;
            : TBLC_1 tablePropertyIR
  ---- ;; check that the custom property is for largest_priority_wins
  -- if "largest_priority_wins" = $tableCustomName(tableCustomName)
  ---- ;; check initializer
  -- Expr_ok: LOCAL TC |- expression : typedExpressionIR
  -- if _ `# `( BOOL _ ) = typedExpressionIR
  -- Eval_static: LOCAL TC |- typedExpressionIR ~> B b_largest_priority_wins
  ---- ;; update table context
  -- if TBLC_1 = TBLC_0 [ .PRIORITIES.LARGEST_WINS = b_largest_priority_wins ]
  ---- ;; create IR
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if tablePropertyIR
      = annotationList constOptIR CUSTOM_CONST
          "largest_priority_wins" (`= (B b_largest_priority_wins)) `;

rule TableProperty_ok/custom-priority-delta:
  TC TBLC_0 |- annotationList constOpt tableCustomName (`= expression) `;
             : TBLC_1 tablePropertyIR
  ---- ;; check that the custom property is for priority_delta
  -- if "priority_delta" = $tableCustomName(tableCustomName)
  ---- ;; check initializer
  -- Expr_ok: LOCAL TC |- expression : typedExpressionIR
  -- if _ `# `( typeIR _ ) = typedExpressionIR
  -- if $is_arbitrary_int_typeIR(typeIR)
        \/ $is_fixed_int_typeIR(typeIR)
        \/ $is_fixed_bit_typeIR(typeIR)
  -- Eval_static: LOCAL TC |- typedExpressionIR ~> value
  -- if n_delta = $to_number(value)
  -- if $(n_delta > 0)
  ---- ;; update table context
  -- if TBLC_1 = TBLC_0 [ .PRIORITIES.DELTA = n_delta ]
  ---- ;; create IR
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if tablePropertyIR
      = annotationList constOptIR CUSTOM_CONST
          "priority_delta" (`= (D n_delta)) `;

rule TableProperty_ok/custom:
  TC TBLC |- annotationList constOpt tableCustomName (`= expression) `;
           : TBLC tablePropertyIR
  ---- ;; check that the custom property is not one of the predefined ones
  -- if nameIR = $tableCustomName(tableCustomName)
  -- if nameIR =/= "size"
        /\ nameIR =/= "largest_priority_wins"
        /\ nameIR =/= "priority_delta"
  ---- ;; check initializer
  -- Expr_ok: LOCAL TC |- expression : typedExpressionIR
  ---- ;; create IR
  -- if constOptIR = $flatten_constOpt(constOpt)
  -- if tablePropertyIR
      = annotationList constOptIR CUSTOM nameIR (`= typedExpressionIR) `;

;;
;; Table property list typing
;;
;; syntax tablePropertyList
;;

rule TableProperties_ok/nil:
  TC TBLC |- eps : TBLC eps

rule TableProperties_ok/cons:
  TC TBLC_0 |- (tableProperty_h :: tableProperty_t*)
             : TBLC_2 (tablePropertyIR_h :: tablePropertyIR_t*)
  -- TableProperty_ok: TC TBLC_0 |- tableProperty_h : TBLC_1 tablePropertyIR_h
  -- TableProperties_ok: TC TBLC_1 |- tableProperty_t* : TBLC_2 tablePropertyIR_t*

;;
;; Table typing
;;
;; syntax table
;;

dec $count_table_keys(tableProperty*) : nat

def $count_table_keys(eps) = 0
def $count_table_keys(
    (KEY `= `{ _ }) :: tableProperty_t*
  )
  = $(1 + $count_table_keys(tableProperty_t*))
def $count_table_keys(
    tableProperty_h :: tableProperty_t*
  )
  = $count_table_keys(tableProperty_t*)
  -- otherwise

dec $count_table_actions(tableProperty*) : nat

def $count_table_actions(eps) = 0
def $count_table_actions(
    (ACTIONS `= `{ _ }) :: tableProperty_t*
  )
  = $(1 + $count_table_actions(tableProperty_t*))
def $count_table_actions(
    tableProperty_h :: tableProperty_t*
  )
  = $count_table_actions(tableProperty_t*)
  -- otherwise

rule Table_ok:
  TC |- tableProperty* : TBLC_1 tablePropertyIR*
  ---- ;; check that the table has at most one key property
  -- if $($count_table_keys(tableProperty*) <= 1)
  ---- ;; check that the table has exactly one action property
  -- if $($count_table_actions(tableProperty*) = 1)
  ---- ;; check table properties
  -- if TBLC_0 = $empty_tableContext
  -- TableProperties_ok: TC TBLC_0 |- tableProperty* : TBLC_1 tablePropertyIR*

rule TableType_ok:
  TC_0 TBLC |- name : TC_1 typeIR_table
  -- if nameIR = $name(name)
  ---- ;; create table enum type
  -- if tid_enum = "action_list(" ++ nameIR ++ ")"
  -- if (prefixedNameIR_action, _, _)* = TBLC.ACTIONS
  -- if (id_enum_field = $flatten_prefixedNameIR(prefixedNameIR_action))*
  -- if typeIR_table_enum = TABLE_ENUM tid_enum `{ id_enum_field* }
  ---- ;; add enum fields to context
  -- if (value_enum_field = TABLE_ENUM tid_enum `. id_enum_field)*
  -- if (varTypeIR_enum_field
        = `EMPTY typeIR_table_enum LCTK value_enum_field)*
  -- if TC_1
      = $add_vars(
          BLOCK, TC_0,
          (tid_enum ++ "." ++ id_enum_field)*,
          varTypeIR_enum_field*
        )
  ---- ;; create table struct type
  -- if tid_struct = "apply_result(" ++ nameIR ++ ")"
  -- if typeIR_table_struct
      = TABLE_STRUCT tid_struct
          `{ [ (BOOL "hit" `;),
               (BOOL "miss" `;),
               (typeIR_table_enum "action_run" `;) ] }
  ---- ;; create table type
  -- if typeIR_table = TABLE nameIR `# typeIR_table_struct
