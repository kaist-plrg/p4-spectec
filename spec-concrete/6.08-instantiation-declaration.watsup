;;
;; Declaration instantiation
;;
;; syntax declarationIR
;;

;;; constantDeclarationIR
;;; syntax constantDeclarationIR =
;;;   annotationList CONST typeIR nameIR initializerIR `;

dec $wrap_decl(cursor, declarationIR) : declarationIR?

def $wrap_decl(GLOBAL, declarationIR) = eps
def $wrap_decl(_, declarationIR) = declarationIR

rule Decl_inst/constantDeclarationIR:
  p Ci_0 sto |- annotationList CONST typeIR nameIR (`= value) `;
            ==> Ci_1 sto $wrap_decl(p, constantDeclarationIR)
  -- if $add_value_inst(p, Ci_0, nameIR, value) = Ci_1
  -- if annotationList CONST typeIR nameIR (`= value) `;
      = constantDeclarationIR

;;; instantiationIR
;;; syntax instantiationIR
;;;; annotationList typeIR `< typeArgumentListIR > `( argumentListIR ) nameIR objectInitializerOptIR `;

;; Unwrap objectInitializerOptIR
dec $get_init_decls(objectInitializerOptIR) : objectDeclarationListIR

def $get_init_decls(eps) = eps
def $get_init_decls(`= `{ objectDeclarationListIR }) = objectDeclarationListIR

;; Merge value environments
dec $merge_venvs(venv, venv) : venv

def $merge_venvs(venv, `{ (id `: value)* })
  = $adds_map<id, value>(venv, id*, value*)

;; Merge routine environments and transform functions to extern methods
dec $merge_renv_with_extern(renv, renv) : renv

def $merge_renv_with_extern(renv, `{ eps }) = renv
def $merge_renv_with_extern(renv, `{ (rid_h `: routineDyn_h) :: (rid_t `: routineDyn_t)* })
  = $merge_renv_with_extern(renv_post, `{ (rid_t `: routineDyn_t)* })
  -- if FUNCTION `< typeParameterListIR > `( parameterListIR ) blockStatementIR
      = routineDyn_h
  -- if EXTERN_METHOD `< typeParameterListIR > `( parameterListIR ) blockStatementIR
      = routineDyn_h_post
  -- if $update_map<rid, routineDyn>(renv, rid_h, routineDyn_h_post)
      = renv_post

rule Decl_inst/instantiationIR-extern:
  p Ci_0 sto_0 |- _ typeIR prefixedNameIR `< typeArgumentListIR >
                    `( argumentListIR ) nameIR objectInitializerOptIR `;
              ==> Ci_1 sto_2 $wrap_decl(p, constantDeclarationIR)
  ---- ;; find and instantiate constructor
  -- if $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR) = (_, consDyn, id_default*)
  -- if $enter_path(Ci_0, nameIR) = Ci_inner
  -- Constructor_inst: p Ci_inner sto_0 |- consDyn `< typeArgumentListIR > `( argumentListIR `# id_default* ) ==> sto_1 objDyn
  ---- ;; if object is an extern
  -- if objDyn = EXTERN `{ tid theta venv renv }
  ---- ;; initialize context for object declarations
  -- if $empty_context_inst()[ .PATH = Ci_0.PATH ][ .GLOBAL = Ci_0.GLOBAL ] = Ci_decl
  -- if $get_init_decls(objectInitializerOptIR) = objectDeclarationListIR
  -- Decls_inst: BLOCK Ci_decl sto_1 |- objectDeclarationListIR ==> Ci_decl_post sto_2 _
  ---- ;; merge value environments
  -- if $merge_venvs(venv, Ci_decl_post.BLOCK.VENV) = venv_merged
  ---- ;; merge routine environments and transform functions to extern methods
  -- if $merge_renv_with_extern(renv, Ci_decl_post.BLOCK.RENV) = renv_merged
  ---- ;; create new object with merged environments
  -- if EXTERN `{ tid theta venv_merged renv_merged } = objDyn_1
  ---- ;; add object to store
  -- if Ci_0.PATH ++ nameIR = oid
  -- if $add_sto(sto_2, oid, objDyn_1) = sto_3
  ---- ;; add reference to object in value environment
  -- if $add_value_inst(p, Ci_0, nameIR, `! oid) = Ci_1
  ---- ;; replace declaration with constant declaration holding the reference
  -- if `EMPTY CONST typeIR nameIR (`= (`! oid)) `;
      = constantDeclarationIR

dec $is_extern_object(objDyn) : bool
def $is_extern_object(EXTERN `{ _ _ _ _ }) = true
def $is_extern_object(_) = false

rule Decl_inst/instantiationIR-non-extern:
  p Ci_0 sto_0 |- _ typeIR prefixedNameIR `< typeArgumentListIR >
                    `( argumentListIR ) nameIR objectInitializerOptIR `;
              ==> Ci_1 sto_1 $wrap_decl(p, constantDeclarationIR)
  ---- ;; find and instantiate constructor
  -- if $find_constructor_overloaded_inst(Ci_0, prefixedNameIR, argumentListIR) = (_, consDyn, id_default*)
  -- if $enter_path(Ci_0, nameIR) = Ci_inner
  -- Constructor_inst: p Ci_inner sto_0 |- consDyn `< typeArgumentListIR > `( argumentListIR `# id_default* ) ==> sto_1 objDyn
  ---- ;; if object is not an extern
  -- if ~$is_extern_object(objDyn)
  ---- ;; bind object to store
  -- if Ci_0.PATH ++ nameIR = oid
  -- if $add_sto(sto_1, oid, objDyn) = sto_2
  ---- ;; add reference to object in value environment
  -- if $add_value_inst(p, Ci_0, nameIR, `! oid) = Ci_1
  ---- ;; replace declaration with constant declaration holding the reference
  -- if `EMPTY CONST typeIR nameIR (`= (`! oid)) `;
      = constantDeclarationIR

;;; functionDeclarationIR
;;; syntax functionDeclarationIR
;;;; annotationList functionPrototypeIR blockStatementIR

dec $rid_IR(nameIR, parameterListIR) : rid
dec $pid_IR(parameterIR) : pid

def $rid_IR(nameIR, parameterIR*) = nameIR `( $pid_IR(parameterIR)* )

def $pid_IR(_ _ _ nameIR eps) = nameIR `# false
def $pid_IR(_ _ _ nameIR constantInitializerIR) = nameIR `# true

dec $cid_IR(nameIR, constructorParameterListIR) : cid

def $cid_IR(nameIR, constructorParameterListIR) = $rid_IR(nameIR, constructorParameterListIR)

rule Decl_inst/functionDeclarationIR:
  p Ci_0 sto |- _ (typeIR nameIR (`< typeParameterListIR `, typeParameterListIR_inferred >)
                  `( parameterListIR )) blockStatementIR
            ==> Ci_1 sto eps
  ---- ;; bind function to routine environment
  -- if $rid_IR(nameIR, parameterListIR) = rid
  -- if FUNCTION `< typeParameterListIR ++ typeParameterListIR_inferred >
          `( parameterListIR ) blockStatementIR
          = funcDyn
  -- if $add_routine_overload_inst(p, Ci_0, rid, funcDyn) = Ci_1

;;; actionDeclarationIR
;;; syntax actionDeclarationIR
;;;; annotationList ACTION nameIR `( parameterListIR ) blockStatementIR

rule Decl_inst/actionDeclarationIR:
  p Ci_0 sto |- _ ACTION nameIR `( parameterListIR ) blockStatementIR ==> Ci_1 sto eps
  ---- ;; bind action to routine environment
  -- if $rid_IR(nameIR, parameterListIR) = rid
  -- if ACTION `( parameterListIR ) `{ blockStatementIR } = funcDyn
  -- if $add_routine_non_overload_inst(p, Ci_0, rid, funcDyn) = Ci_1

;;; errorDeclarationIR
;;; syntax errorDeclarationIR
;;;; ERROR `{ nameListIR }

rule Decl_inst/errorDeclarationIR:
  GLOBAL Ci_0 sto |- ERROR `{ nameIR* } ==> Ci_1 sto eps
  ---- ;; bind errors to value environment
  -- (if $concat_text([ "error.", nameIR ]) = nameIR_field)*
  -- if $add_values_inst(GLOBAL, Ci_0, nameIR_field*, (ERROR `. nameIR)*) = Ci_1

;;; matchKindDeclarationIR
;;; syntax matchKindDeclarationIR
;;;; MATCH_KIND `{ nameListIR }

rule Decl_inst/matchKindDeclarationIR:
  GLOBAL Ci_0 sto |- MATCH_KIND `{ nameIR* } ==> Ci_1 sto eps
  ---- ;; add match kinds to value environment
  -- if $add_values_inst(GLOBAL, Ci_0, nameIR*, (MATCH_KIND `. nameIR)*) = Ci_1

;;; externDeclarationIR
;;; syntax externDeclarationIR
;;;; externFunctionDeclarationIR
;;;; syntax externFunctionDeclarationIR
;;;;; annotationList EXTERN functionPrototypeIR `;

rule Decl_inst/externFunctionDeclarationIR:
  p Ci_0 sto |- _ EXTERN (typeIR nameIR 
                  `< typeParameterListIR `, typeParameterListIR_inferred >
                  `( parameterListIR )) `;
            ==> Ci_1 sto eps
  ---- ;; bind extern function to routine environment
  -- if $rid_IR(nameIR, parameterListIR) = rid
  -- if EXTERN_FUNCTION
          `< typeParameterListIR ++ typeParameterListIR_inferred >
          `( parameterListIR ) `{ eps }
      = funcDyn
  -- if $add_routine_overload_inst(p, Ci_0, rid, funcDyn) = Ci_1

;;;; externObjectDeclarationIR

dec $split_constructors_IR(methodPrototypeIR*) : (methodPrototypeIR*, methodPrototypeIR*)

def $split_constructors_IR(eps) = (eps, eps)
def $split_constructors_IR(methodPrototypeIR_h :: methodPrototypeIR_t*)
  = (methodPrototypeIR_h :: methodPrototypeIR_t_constructor*,
     methodPrototypeIR_t_method*)
  -- if _ _ `< `, _ > `( _ ) `; = methodPrototypeIR_h
  -- if (methodPrototypeIR_t_constructor*, methodPrototypeIR_t_method*)
      = $split_constructors_IR(methodPrototypeIR_t*)
def $split_constructors_IR(methodPrototypeIR_h :: methodPrototypeIR_t*)
  = (methodPrototypeIR_t_constructor*,
     methodPrototypeIR_h :: methodPrototypeIR_t_method*)
  -- if _ _ `; = methodPrototypeIR_h
  -- if (methodPrototypeIR_t_constructor*, methodPrototypeIR_t_method*)
      = $split_constructors_IR(methodPrototypeIR_t*)
def $split_constructors_IR(methodPrototypeIR_h :: methodPrototypeIR_t*)
  = (methodPrototypeIR_t_constructor*,
     methodPrototypeIR_h :: methodPrototypeIR_t_method*)
  -- if _ ABSTRACT _ `; = methodPrototypeIR_h
  -- if (methodPrototypeIR_t_constructor*, methodPrototypeIR_t_method*)
      = $split_constructors_IR(methodPrototypeIR_t*)

rule Decl_inst/extern-object-no-constructors:
  p Ci_0 sto |- annotationList EXTERN nameIR
                  `< typeParameterListIR `, typeParameterListIR_inferred >
                  `{ methodPrototypeIR* }
            ==> Ci_2 sto eps
  ---- ;; split extern methods and constructors
  -- if $split_constructors_IR(methodPrototypeIR*)
      = (eps, methodPrototypeIR_method*)
  ---- ;; bind methods to routine environment
  -- Bind_methods: $empty_rdenv() |- methodPrototypeIR_method* ==> rdenv
  ---- ;; add polymorphic extern type to typedef environment
  -- if EXTERN nameIR rdenv = externObjectTypeIR
  -- if externObjectTypeIR `< typeParameterListIR `, eps >
      = polyTypeDefIR
  -- if $add_typedef_inst(p, Ci_0, nameIR, polyTypeDefIR) = Ci_1
  ---- ;; if no constructors are provided, add default constructor
  -- if $cid_IR(nameIR, eps) = cid
  -- if EXTERN nameIR `< typeParameterListIR > `( eps ) `{ methodPrototypeIR_method* }
      = consDyn
  -- if $add_constructor_inst(p, Ci_1, cid, consDyn) = Ci_2

rule Decl_inst/extern-object-with-constructors:
  p Ci_0 sto |- annotationList EXTERN nameIR
                  `< typeParameterListIR `, typeParameterListIR_inferred >
                  `{ methodPrototypeIR* }
            ==> Ci_2 sto eps
  ---- ;; split extern methods and constructors
  -- if $split_constructors_IR(methodPrototypeIR*)
      = (methodPrototypeIR_constructor*, methodPrototypeIR_method*)
  ---- ;; bind methods to routine environment
  -- Bind_methods: $empty_rdenv() |- methodPrototypeIR_method* ==> rdenv
  ---- ;; add polymorphic extern type to typedef environment
  -- if EXTERN nameIR rdenv = externObjectTypeIR
  -- if externObjectTypeIR `< typeParameterListIR `, eps >
      = polyTypeDefIR
  -- if $add_typedef_inst(p, Ci_0, nameIR, polyTypeDefIR) = Ci_1
  ---- ;; bind extern constructors to constructor environment
  -- Bind_constructors: p Ci_1 typeParameterListIR methodPrototypeIR_method* |- methodPrototypeIR_constructor* ==> Ci_2

;;; parserDeclarationIR
;;; syntax parserDeclarationIR
;;;; annotationList PARSER
;;;;  nameIR `< typeParameterListIR >
;;;;  `( parameterListIR ) `( constructorParameterListIR )
;;;;  `{ parserLocalDeclarationListIR parserStateListIR }`

rule Decl_inst/parserDeclarationIR:
  p Ci_0 sto |- _ PARSER nameIR `< typeParameterListIR >
                  `( parameterListIR ) `( constructorParameterListIR )
                  `{ parserLocalDeclarationListIR parserStateListIR }
            ==> Ci_1 sto eps
  -- if $cid_IR(nameIR, constructorParameterListIR) = cid
  -- if PARSER `< typeParameterListIR >
          `( parameterListIR ) `( constructorParameterListIR )
          `{ parserLocalDeclarationListIR parserStateListIR }
      = consDyn
  -- if $add_constructor_inst(p, Ci_0, cid, consDyn) = Ci_1

;;; controlDeclarationIR
;;; syntax controlDeclarationIR =
;;;; annotationList CONTROL
;;;;  nameIR `< typeParameterListIR >
;;;;  `( parameterListIR ) `( constructorParameterListIR )
;;;;  `{ controlLocalDeclarationListIR APPLY controlBodyIR }

rule Decl_inst/controlDeclarationIR:
  p Ci_0 sto |- _ CONTROL nameIR `< typeParameterListIR >
                  `( parameterListIR ) `( constructorParameterListIR )
                  `{ controlLocalDeclarationListIR APPLY controlBodyIR }
            ==> Ci_1 sto eps
  ---- ;; bind control to constructor environment
  -- if $cid_IR(nameIR, constructorParameterListIR) = cid
  -- if CONTROL `< typeParameterListIR >
          `( parameterListIR ) `( constructorParameterListIR )
          `{ controlLocalDeclarationListIR APPLY controlBodyIR }
      = consDyn
  -- if $add_constructor_inst(p, Ci_0, cid, consDyn) = Ci_1

;;; typeDeclarationIR
;;; syntax typeDeclarationIR

;;;; derivedTypeDeclarationIR
;;;; syntax derivedTypeDeclarationIR

;;;;; enumTypeDeclarationIR
;;;;; syntax enumTypeDeclarationIR =

;;;;;; annotationList ENUM nameIR `{ nameListIR }

rule Decl_inst/typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-enum:
  GLOBAL Ci_0 sto |- _ ENUM nameIR `{ nameIR_mem* } ==> Ci_2 sto eps
  ---- ;; bind fields to value environment
  -- if ($concat_text([nameIR, ".", nameIR_mem]) = nameIR_path)*
  -- if $add_values_inst(GLOBAL, Ci_0, nameIR_path*, (nameIR `. nameIR_mem)*) = Ci_1
  ---- ;; bind enum type to typedef environment
  -- if $add_typedef_inst(GLOBAL, Ci_1, nameIR, ENUM nameIR `{ nameIR_mem* }) = Ci_2

;;;;;; annotationList ENUM typeIR nameIR `{ namedExpressionListIR }
;; TODO: need to be value instead of typedExpressionIR?

rule Decl_inst/typeDeclarationIR-derivedTypeDeclarationIR-enumTypeDeclarationIR-serializableEnum:
  GLOBAL Ci_0 sto_0 |- _ ENUM typeIR nameIR `{ (nameIR_mem `= typedExpressionIR)* }
                   ==> Ci_2 sto_1 eps
  ---- ;; instantiate fields
  -- Exprs_inst: GLOBAL Ci_0 sto_0 |- typedExpressionIR* ==> sto_1 value_mem*
  ---- ;; bind fields to value environment
  -- if ($concat_text([nameIR, ".", nameIR_mem]) = nameIR_path)*
  -- if $add_values_inst(GLOBAL, Ci_0, nameIR_path*, (nameIR `. nameIR_mem `# value_mem)*) = Ci_1
  ---- ;; bind enum type to typedef environment
  -- if $add_typedef_inst(GLOBAL, Ci_1, nameIR, ENUM nameIR `# typeIR `{ (nameIR_mem `= value_mem `;)* }) = Ci_2

;;;;; structTypeDeclarationIR
;;;;; syntax structTypeDeclarationIR =
;;;;;   annotationList STRUCT nameIR
;;;;;     `< typeParameterListIR `, typeParameterListIR >
;;;;;     `{ typeFieldListIR }

rule Decl_inst/typeDeclarationIR-derivedTypeDeclarationIR-structTypeDeclarationIR:
  GLOBAL Ci_0 sto |- _ STRUCT nameIR
                       `< typeParameterListIR `, typeParameterListIR_inferred >
                       `{ typeFieldIR* }
                 ==> Ci_1 sto eps
  ---- ;; bind struct type to typedef environment
  -- if (typeFieldIR = _ typeIR nameIR_field `;)*
  -- if (STRUCT nameIR `{ (typeIR nameIR_field `;)* }) 
          `< typeParameterListIR `, typeParameterListIR_inferred >
      = typeDefIR
  -- if $add_typedef_inst(GLOBAL, Ci_0, nameIR, typeDefIR) = Ci_1

;;;;; headerTypeDeclarationIR
;;;;; syntax headerTypeDeclarationIR =
;;;;;   annotationList HEADER nameIR
;;;;;     `< typeParameterListIR `, typeParameterListIR >
;;;;;     `{ typeFieldListIR }

rule Decl_inst/typeDeclarationIR-derivedTypeDeclarationIR-headerTypeDeclarationIR:
  GLOBAL Ci_0 sto |- _ HEADER nameIR
                       `< typeParameterListIR `, typeParameterListIR_inferred >
                       `{ typeFieldIR* }
                 ==> Ci_1 sto eps
  ---- ;; bind header type to typedef environment
  -- if (typeFieldIR = _ typeIR nameIR_field `;)*
  -- if (HEADER nameIR `{ (typeIR nameIR_field `;)* })
          `< typeParameterListIR `, typeParameterListIR_inferred >
      = typeDefIR
  -- if $add_typedef_inst(GLOBAL, Ci_0, nameIR, typeDefIR) = Ci_1

;;;;; headerUnionTypeDeclarationIR
;;;;; syntax headerUnionTypeDeclarationIR =
;;;;;   annotationList HEADER_UNION nameIR
;;;;;     `< typeParameterListIR `, typeParameterListIR >
;;;;;     `{ typeFieldListIR }

rule Decl_inst/typeDeclarationIR-derivedTypeDeclarationIR-headerUnionTypeDeclarationIR:
  GLOBAL Ci_0 sto |- _ HEADER_UNION nameIR
                       `< typeParameterListIR `, typeParameterListIR_inferred >
                       `{ typeFieldIR* }
                 ==> Ci_1 sto eps
  ---- ;; bind header union type to typedef environment
  -- if (typeFieldIR = _ typeIR nameIR_field `;)*
  -- if (HEADER_UNION nameIR `{ (typeIR nameIR_field `;)* }) 
      `< typeParameterListIR `, typeParameterListIR_inferred >
      = typeDefIR
  -- if $add_typedef_inst(GLOBAL, Ci_0, nameIR, typeDefIR) = Ci_1

;;;; typedefDeclarationIR
;;;; syntax typedefDeclarationIR

;;;;; annotationList TYPEDEF typedefTypeIR nameIR `;
;;;;; syntax typedefTypeIR

;;;;;; typeIR

rule Decl_inst/typeDeclarationIR-typedefDeclarationIR-typedef-typeIR:
  GLOBAL Ci_0 sto |- _ TYPEDEF typeIR nameIR `;
                 ==> Ci_1 sto eps
  ---- ;; bind type to typedef environment
  -- if TYPEDEF nameIR typeIR = typeIR_typedef
  -- if $add_typedef_inst(GLOBAL, Ci_0, nameIR, typeIR_typedef) = Ci_1

;;;;;; derivedTypeDeclarationIR

rule Decl_inst/typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclarationIR-monoTypeDefIR:
  GLOBAL Ci_0 sto |- _ TYPEDEF derivedTypeDeclarationIR nameIR `;
                 ==> Ci_1 sto eps
  ---- ;; instantiate type declaration
  -- Decl_inst: GLOBAL Ci_0 $empty_sto() |- derivedTypeDeclarationIR ==> Ci_local _ _
  ---- ;; diff the local and global context to get the declared type id
  -- if $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_local.GLOBAL.TDENV), $dom_map<tid, typeDefIR>(Ci_0.GLOBAL.TDENV))
    = `{ tid_newtype }
  ---- ;; find the type definition
  -- if $find_typedef_inst(GLOBAL, Ci_local, `. tid_newtype) = typeDefIR
  -- if typeDefIR = monoTypeDefIR
  ---- ;; if the type is monomorphic, add to the environment as is
  -- if TYPEDEF nameIR monoTypeDefIR = typeIR_typedef
  -- if $add_typedef_inst(GLOBAL, Ci_0, nameIR, typeIR_typedef) = Ci_1

rule Decl_inst/typeDeclarationIR-typedefDeclarationIR-typedef-derivedTypeDeclaration-polyTypeDefIR:
  GLOBAL Ci_0 sto |- _ TYPEDEF derivedTypeDeclarationIR nameIR `;
                 ==> Ci_1 sto eps
  ---- ;; instantiate type declaration
  -- Decl_inst: GLOBAL Ci_0 $empty_sto() |- derivedTypeDeclarationIR ==> Ci_local _ _
  ---- ;; diff the local and global context to get the declared type id
  -- if $diff_set<tid>($dom_map<tid, typeDefIR>(Ci_local.GLOBAL.TDENV), $dom_map<tid, typeDefIR>(Ci_0.GLOBAL.TDENV))
      = `{ tid_newtype }
  -- if $find_typedef_inst(GLOBAL, Ci_local, `. tid_newtype) = typeDefIR
  -- if typeDefIR = polyTypeDefIR
  ---- ;; if type is polymorphic, specialize it with no type parameters the the typedef type
  -- if TYPEDEF nameIR (polyTypeDefIR `< eps >) = typeIR_typedef
  ---- ;; bind specialized type to typedef environment
  -- if $add_typedef_inst(GLOBAL, Ci_0, nameIR, typeIR_typedef) = Ci_1

;;;;; annotationList TYPE typeIR nameIR `;

rule Decl_inst/typeDeclarationIR-typedefDeclarationIR-newtype:
  GLOBAL Ci_0 sto |- _ TYPE typeIR nameIR `;
                 ==> Ci_1 sto eps
  ---- ;; bind newtype to typedef environment
  -- if TYPE nameIR typeIR = typeIR_newtype
  -- if $add_typedef_inst(GLOBAL, Ci_0, nameIR, typeIR_newtype) = Ci_1

;;;; parserTypeDeclarationIR
;;;; syntax parserTypeDeclarationIR =
;;;;   annotationList PARSER nameIR
;;;;     `< typeParameterListIR `, typeParameterListIR >
;;;;     `( parameterListIR ) `;

rule Decl_inst/typeDeclarationIR-parserTypeDeclarationIR:
  GLOBAL Ci_0 sto |- _ PARSER nameIR
                       `< typeParameterListIR `, typeParameterListIR_inferred >
                       `( parameterIR* ) `;
                 ==> Ci_1 sto eps
  ---- ;; bind parser type to typedef environment
  -- if ($parameterIR(parameterIR) = parameterTypeIR)*
  -- if PARSER `( parameterTypeIR* ) = typeIR_parser
  -- if typeIR_parser `< typeParameterListIR `, typeParameterListIR_inferred >
      = typeDefIR_parser
  -- if $add_typedef_inst(GLOBAL, Ci_0, nameIR, typeDefIR_parser) = Ci_1

;;;; controlTypeDeclarationIR
;;;; syntax controlTypeDeclarationIR =
;;;;   annotationList CONTROL nameIR
;;;;     `< typeParameterListIR `, typeParameterListIR >
;;;;     `( parameterListIR ) `;

rule Decl_inst/typeDeclarationIR-controlTypeDeclarationIR:
  GLOBAL Ci_0 sto |- _ CONTROL nameIR
                       `< typeParameterListIR `, typeParameterListIR_inferred >
                       `( parameterIR* ) `;
                 ==> Ci_1 sto eps
  ---- ;; bind control type to typedef environment
  -- if ($parameterIR(parameterIR) = parameterTypeIR)*
  -- if CONTROL `( parameterTypeIR* ) = typeIR_control
  -- if typeIR_control `< typeParameterListIR `, typeParameterListIR_inferred >
      = typeDefIR_control
  -- if $add_typedef_inst(GLOBAL, Ci_0, nameIR, typeDefIR_control) = Ci_1

;;;; packageTypeDeclarationIR
;;;; syntax packageTypeDeclarationIR =
;;;;   annotationList PACKAGE nameIR
;;;;     `< typeParameterListIR `, typeParameterListIR >
;;;;     `( parameterListIR ) `;

;;TODO: params to cparams?
rule Decl_inst/typeDeclarationIR-packageTypeDeclarationIR:
  p Ci_0 sto |- _ PACKAGE nameIR
                  `< typeParameterListIR `, typeParameterListIR_inferred >
                  `( parameterIR* ) `;
            ==> Ci_2 sto eps
  ---- ;; bind package type to typedef environment
  -- if (parameterIR = _ _ typeIR _ _)*
  -- if PACKAGE `< typeIR* > = typeIR_package
  -- if typeIR_package `< typeParameterListIR `, typeParameterListIR_inferred >
      = typeDefIR_package
  -- if $add_typedef_inst(p, Ci_0, nameIR, typeDefIR_package) = Ci_1 
  ---- ;; bind package constructor to constructor environment
  -- if $cid_IR(nameIR, parameterIR*) = cid
  -- if PACKAGE `< typeParameterListIR ++ typeParameterListIR_inferred > `( parameterIR* )
      = consDyn_package
  -- if $add_constructor_inst(GLOBAL, Ci_1, cid, consDyn_package) = Ci_2

;;
;; syntax declarationListIR
;;

rule Decls_inst/nil:
  p Ci sto |- eps ==> Ci sto eps

rule Decls_inst/cons-none:
  p Ci_0 sto_0 |- declarationIR_h :: declarationIR_t*
    ==> Ci_2 sto_2 declarationIR_t'*
  -- Decl_inst: p Ci_0 sto_0 |- declarationIR_h ==> Ci_1 sto_1 eps
  -- Decls_inst: p Ci_1 sto_1 |- declarationIR_t* ==> Ci_2 sto_2 declarationIR_t'*

rule Decls_inst/cons-some:
  p Ci_0 sto_0 |- declarationIR_h :: declarationIR_t*
    ==> Ci_2 sto_2 (declarationIR_h' :: declarationIR_t'*)
  -- Decl_inst: p Ci_0 sto_0 |- declarationIR_h ==> Ci_1 sto_1 declarationIR_h'
  -- Decls_inst: p Ci_1 sto_1 |- declarationIR_t* ==> Ci_2 sto_2 declarationIR_t'*

;;
;; syntax p4programIR
;;

rule Program_inst:
  |- declarationIR* `; ==> Ci_1.GLOBAL.CENV Ci_1.GLOBAL.TDENV Ci_1.GLOBAL.RENV Ci_1.GLOBAL.VENV sto_1
  ---- ;; initialize empty context and stor
  -- if $empty_context_inst() = Ci_0
  -- if $empty_sto() = sto_0
  ---- ;; instantiate declarations
  -- Decls_inst: GLOBAL Ci_0 sto_0 |- declarationIR* ==> Ci_1 sto_1 eps
