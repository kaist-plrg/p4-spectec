;;
;; Parser state typing
;;
;; syntax parserState =
;;   annotationList STATE name `{ parserStatementList transitionStatement }
;;

rule ParserState_ok:
  TC_0 nameIR_state* |- annotationList STATE name
                        `{ parserStatementList transitionStatement }
                      : parserStateIR
  -- if nameIR = $name(name)
  ---- ;; enter block scope
  -- if TC_1 = $enter(TC_0)
  ---- ;; check parser statements
  -- if parserStatement*
      = $flatten_parserStatementList(parserStatementList)
  -- ParserStmts_ok: TC_1 |- parserStatement* : TC_2 parserStatementIR*
  ---- ;; check transition statement
  -- ParserTransition_ok: TC_2 nameIR_state* |- transitionStatement
                                              : transitionStatementIR
  ---- ;; exit block scope
  -- if TC_3 = $exit(TC_2)
  ---- ;; create IR
  -- if parserStateIR
      = annotationList STATE nameIR `{ parserStatementIR* transitionStatementIR }

;;
;; Parser state list typing
;;
;; syntax parserStateList
;;

rule ParserStates_ok:
  TC |- parserState* : parserStateIR*
  ---- ;; check that state names are distinct
  -- if (_ STATE name_state `{ _ _ } = parserState)*
  -- if (nameIR_state = $name(name_state))*
  -- if $distinct_<nameIR>(nameIR_state*)
  ---- ;; check that a "start" state exists
  ---- ;; and "accept"/"reject" are reserved
  -- if "start" <- nameIR_state*
  -- if ~("accept" <- nameIR_state*) /\ ~("reject" <- nameIR_state*)
  -- if nameIR_state_impl* = "accept" :: "reject" :: nameIR_state*
  ---- ;; check each parser state
  -- (ParserState_ok: TC nameIR_state_impl* |- parserState : parserStateIR)*
