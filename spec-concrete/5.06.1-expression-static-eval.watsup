;;
;; Static evaluation of expression
;;
;; syntax typedExpressionIR =
;;   expressionIR `# `( typeIR ctk )
;;

;;; syntax expressionIR

;;;; literalExpressionIR
;;;; syntax literalExpression

;;;;; TRUE
;;;;; FALSE

rulegroup Eval_static/literalExpressionIR-boolean {

  rule Eval_static/true:
    p TC |- TRUE `# `( _ _ ) ~> B true

  rule Eval_static/false:
    p TC |- FALSE `# `( _ _ ) ~> B false

}

;;;;; number

rulegroup Eval_static/literalExpressionIR-number {

  rule Eval_static/arbint:
    p TC |- (D i) `# `( _ _ ) ~> D i

  rule Eval_static/fixbit:
    p TC |- (n W i) `# `( _ _ ) ~> n W i

  rule Eval_static/fixint:
    p TC |- (n S i) `# `( _ _ ) ~> n S i

}

;;;;; stringLiteral 

rule Eval_static/literalExpressionIR-stringliteral:
  p TC |- (`" text `") `# `( _ _ ) ~> `" text `"

;;;; referenceExpressionIR
;;;; syntax referenceExpressionIR = prefixedNameIR

rule Eval_static/referenceExpression:
  p TC |- prefixedNameIR `# `( _ _ ) ~> value
  -- if value = $find_value(p, TC, prefixedNameIR)

;;;; defaultExpressionIR
;;;; syntax defaultExpressionIR = defaultExpression

rule Eval_static/defaultExpressionIR:
  p TC |- `... `# `( _ _ ) ~> DEFAULT

;;;; unaryExpressionIR
;;;; syntax unaryExpressionIR = unop typedExpressionIR

rulegroup Eval_static/unaryExpressionIR {

  rule Eval_static/bnot:
    p TC |- (`~ typedExpressionIR) `# `( _ _ ) ~> $un_bnot(value)
    -- Eval_static: p TC |- typedExpressionIR ~> value

  rule Eval_static/lnot:
    p TC |- (`! typedExpressionIR) `# `( _ _ ) ~> $un_lnot(value)
    -- Eval_static: p TC |- typedExpressionIR ~> value

  rule Eval_static/plus:
    p TC |- (`+ typedExpressionIR) `# `( _ _ ) ~> $un_plus(value)
    -- Eval_static: p TC |- typedExpressionIR ~> value

  rule Eval_static/minus:
    p TC |- (`- typedExpressionIR) `# `( _ _ ) ~> $un_minus(value)
    -- Eval_static: p TC |- typedExpressionIR ~> value

}

;;;; binaryExpressionIR
;;;; syntax binaryExpressionIR =
;;;;  typedExpressionIR binop typedExpressionIR

rulegroup Eval_static/binaryExpressionIR {

  rule Eval_static/plus:
    p TC |- (typedExpressionIR_l `+ typedExpressionIR_r) `# `( _ _ )
         ~> $bin_plus(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/satplus:
    p TC |- (typedExpressionIR_l `|+| typedExpressionIR_r) `# `( _ _ )
         ~> $bin_satplus(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/minus:
    p TC |- (typedExpressionIR_l `- typedExpressionIR_r) `# `( _ _ )
         ~> $bin_minus(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/satminus:
    p TC |- (typedExpressionIR_l `|-| typedExpressionIR_r) `# `( _ _ )
         ~> $bin_satminus(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/mul:
    p TC |- (typedExpressionIR_l `* typedExpressionIR_r) `# `( _ _ )
         ~> $bin_mul(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/div:
    p TC |- (typedExpressionIR_l `/ typedExpressionIR_r) `# `( _ _ )
         ~> $bin_div(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/shl:
    p TC |- (typedExpressionIR_l `<< typedExpressionIR_r) `# `( _ _ )
         ~> $bin_shl(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/shr:
    p TC |- (typedExpressionIR_l `>> typedExpressionIR_r) `# `( _ _ )
         ~> $bin_shr(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/le:
    p TC |- (typedExpressionIR_l `<= typedExpressionIR_r) `# `( _ _ )
         ~> (B $bin_le(value_l, value_r))
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/ge:
    p TC |- (typedExpressionIR_l `>= typedExpressionIR_r) `# `( _ _ )
         ~> (B $bin_ge(value_l, value_r))
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/lt:
    p TC |- (typedExpressionIR_l ``< typedExpressionIR_r) `# `( _ _ )
         ~> (B $bin_lt(value_l, value_r))
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/gt:
    p TC |- (typedExpressionIR_l ``> typedExpressionIR_r) `# `( _ _ )
         ~> (B $bin_gt(value_l, value_r))
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/eq:
    p TC |- (typedExpressionIR_l `== typedExpressionIR_r) `# `( _ _ )
         ~> (B $bin_eq(value_l, value_r))
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/ne:
    p TC |- (typedExpressionIR_l `!= typedExpressionIR_r) `# `( _ _ )
         ~> (B $bin_ne(value_l, value_r))
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/band:
    p TC |- (typedExpressionIR_l `& typedExpressionIR_r) `# `( _ _ )
         ~> $bin_band(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/bxor:
    p TC |- (typedExpressionIR_l `^ typedExpressionIR_r) `# `( _ _ )
         ~> $bin_bxor(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/bor:
    p TC |- (typedExpressionIR_l `| typedExpressionIR_r) `# `( _ _ )
         ~> $bin_bor(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/concat:
    p TC |- (typedExpressionIR_l `++ typedExpressionIR_r) `# `( _ _ )
         ~> $bin_concat(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/land:
    p TC |- (typedExpressionIR_l `&& typedExpressionIR_r) `# `( _ _ )
         ~> $bin_land(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

  rule Eval_static/lor:
    p TC |- (typedExpressionIR_l `|| typedExpressionIR_r) `# `( _ _ )
         ~> $bin_lor(value_l, value_r)
    -- Eval_static: p TC |- typedExpressionIR_l ~> value_l
    -- Eval_static: p TC |- typedExpressionIR_r ~> value_r

}

;;;; ternaryExpressionIR
;;;; syntax ternaryExpressionIR =
;;;;   typedExpressionIR `? typedExpressionIR `: typedExpressionIR

rulegroup Eval_static/ternaryExpressionIR {

  rule Eval_static/true:
    p TC |- (typedExpressionIR_cond `? typedExpressionIR_true `: typedExpressionIR_false)
            `# `( _ _ )
         ~> value_true
    -- Eval_static: p TC |- typedExpressionIR_cond ~> (B true)
    -- Eval_static: p TC |- typedExpressionIR_true ~> value_true

  rule Eval_static/false:
    p TC |- (typedExpressionIR_cond `? typedExpressionIR_true `: typedExpressionIR_false)
            `# `( _ _ )
         ~> value_false
    -- Eval_static: p TC |- typedExpressionIR_cond ~> (B false)
    -- Eval_static: p TC |- typedExpressionIR_false ~> value_false

}

;;;; castExpressionIR
;;;; syntax castExpressionIR = `( typeIR ) typedExpressionIR

rule Eval_static/castExpression:
  p TC |- (`( typeIR ) typedExpressionIR) `# `( _ _ ) ~> value_cast
  -- Eval_static: p TC |- typedExpressionIR ~> value
  -- if value_cast = $cast_op(typeIR, value)

;;;; dataExpressionIR
;;;; syntax dataExpressionIR

;;;;; `{#}

rule Eval_static/dataExpressionIR-invalid:
  p TC |- `{#} `# `( _ _ ) ~> `{#}

;;;;; SEQ `{ typedExpressionListIR }
;;;;; SEQ `{ typedExpressionListIR `, `... }

rulegroup Eval_static/dataExpressionIR-sequence {

  rule Eval_static/non-default:
    p TC |- (SEQ `{ typedExpressionIR* }) `# `( _ _ ) ~> SEQ `( value* )
    -- (Eval_static: p TC |- typedExpressionIR ~> value)*

  rule Eval_static/default:
    p TC |- (SEQ `{ typedExpressionIR* `, `... }) `# `( _ _ ) ~> SEQ `( value* `, `... )
    -- (Eval_static: p TC |- typedExpressionIR ~> value)*

}

;;;;; RECORD `{ namedExpressionListIR }
;;;;; RECORD `{ namedExpressionListIR `, `... }

rulegroup Eval_static/dataExpressionIR-record {

  rule Eval_static/non-default:
    p TC |- (RECORD `{ (nameIR `= typedExpressionIR)* }) `# `( _ _ )
        ~> RECORD `{ (value nameIR `;)* }
    -- (Eval_static: p TC |- typedExpressionIR ~> value)*

  rule Eval_static/default:
    p TC |- (RECORD `{ (nameIR `= typedExpressionIR)* `, `... }) `# `( _ _ )
        ~> RECORD `{ (value nameIR `;)* `, `... }
    -- (Eval_static: p TC |- typedExpressionIR ~> value)*

}

;;;; accessExpressionIR
;;;; syntax accessExpressionIR =

;;;;; errorAccessExpressionIR
;;;;; syntax errorAccessExpressionIR = ERROR `. nameIR

rule Eval_static/errorAccessExpressionIR:
  p TC |- (ERROR `. nameIR) `# `( _ _ ) ~> value_error
  -- if nameIR_error = "error." ++ nameIR
  -- if value_error = $find_value(p, TC, `` nameIR_error)

;;;;; memberAccessExpressionIR
;;;;; syntax memberAccessExpressionIR = memberAccessBaseIR `. nameIR
;;;;;; syntax memberAccessBaseIR

;;;;;;; TYPE prefixedNameIR

rulegroup Eval_static/memberAccessExpressionIR-type {

  rule Eval_static/enum:
    p TC |- ((TYPE prefixedNameIR) `. nameIR) `# `( typeIR_base _ )
         ~> tid `. nameIR
    -- if ENUM tid `{ id_member* } = $find_type(p, TC, prefixedNameIR)
    -- if nameIR <- id_member*

  rule Eval_static/serenum:
    p TC |- ((TYPE prefixedNameIR) `. nameIR) `# `( typeIR_base _ )
         ~> tid `. nameIR `# value
    -- if ENUM tid `# typeIR `{ (id_member `= value_member `;)* }
        = $find_type(p, TC, prefixedNameIR)
    -- if value
        = $assoc_<id, value>(nameIR, (id_member, value_member)*)

}

;;;;;;; typedExpressionIR
;;;;;;; general member accesses are not evaluated statically

rule Eval_static/memberAccessExpressionIR-typedExpressionIR-stack-size:
  p TC |- (typedExpressionIR_base `. "size") `# `( typeIR_base _ )
       ~> D n_size
  -- if _ `[ n_size ] = typeIR_base

;;;;; indexAccessExpressionIR
;;;;; syntax indexAccessExpressionIR

;;;;;; typedExpressionIR `[ typedExpressionIR ]
;;;;;; tuple or stack accesses are not evaluated statically

;;;;;; typedExpressionIR `[ typedExpressionIR `: typedExpressionIR ]

rule Eval_static/indexAccessExpressionIR-bitslice:
  p TC |- (typedExpressionIR_base `[ typedExpressionIR_hi `: typedExpressionIR_lo ])
          `# `( _ _ )
       ~> $bitacc_op(value_base, value_hi, value_lo)
  -- Eval_static: p TC |- typedExpressionIR_base ~> value_base
  -- Eval_static: p TC |- typedExpressionIR_hi ~> value_hi
  -- Eval_static: p TC |- typedExpressionIR_lo ~> value_lo

;;;; callExpressionIR
;;;; syntax callExpressionIR

;;;;; constructorTargetIR `( argumentListIR )
;;;;; constructor calls are not evaluated statically

;;;;; routineTargetIR `< typeArgumentListIR > `( argumentListIR )
;;;;;; syntax routineTargetIR

;;;;;;; referenceExpressionIR
;;;;;;; function/action calls are not evaluated statically

;;;;;;; typedLvalueIR `. nameIR

rule Eval_static/callExpressionIR-typedLvalueIR-size:
  p TC |- ((typedExpressionIR_base `. nameIR) `< eps > `( eps )) `# `( _ _ )
      ~> $sizeof(typeIR_base, nameIR)
  -- if _ `# `( typeIR_base _ ) = typedExpressionIR_base
  -- if nameIR <- [ "minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes" ]

;;;;;;; TYPE prefixedNameIR `. nameIR

rulegroup Eval_static/callExpressionIR-type {

  rule Eval_static/size-mono:
    p TC |- ((TYPE prefixedNameIR `. nameIR) `< eps > `( eps )) `# `( _ _ )
        ~> $sizeof(typeIR_base, nameIR)
    -- if typeIR_base = $find_type(p, TC, prefixedNameIR)
    -- if nameIR <- [ "minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes" ]

  rule Eval_static/size-poly:
    p TC |- ((TYPE prefixedNameIR `. nameIR) `< eps > `( eps )) `# `( _ _ )
        ~> $sizeof(typeIR_base, nameIR)
    -- if typeIR_base `< eps `, eps > = $find_type(p, TC, prefixedNameIR)
    -- if nameIR <- [ "minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes" ]

}

;;;;;;; `( routineTargetIR )

rule Eval_static/callExpressionIR-parenthesized:
  p TC |- ((`( routineTargetIR )) `< typeArgumentIR* > `( argumentIR* ))
          `# `( typeIR ctk )
        ~> value
  -- Eval_static:
      p TC |- (routineTargetIR `< typeArgumentIR* > `( argumentIR* ))
              `# `( typeIR ctk )
            ~> value

;;;; parenthesizedExpressionIR
;;;; syntax parenthesizedExpressionIR = `( typedExpressionIR )

rule Eval_static/parenthesizedExpressionIR:
  p TC |- (`( typedExpressionIR )) `# `( _ _ ) ~> value
  -- Eval_static: p TC |- typedExpressionIR ~> value
