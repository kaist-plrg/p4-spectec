;;
;; Static evaluation of expression
;;
;; syntax typedExpressionIR =
;;   expressionIR `# `( typeIR ctk )
;;

;;; syntax expressionIR

;;;; literalExpressionIR
;;;; syntax literalExpression

;;;;; TRUE
;;;;; FALSE

rule Eval_static/literalExpressionIR-true:
  p C |- TRUE `# `( _ _ ) ~> B true

rule Eval_static/literalExpressionIR-false:
  p C |- FALSE `# `( _ _ ) ~> B false

;;;;; number

rule Eval_static/literalExpressionIR-number-arbint:
  p C |- (D i) `# `( _ _ ) ~> D i

rule Eval_static/literalExpressionIR-number-fixbit:
  p C |- (n W i) `# `( _ _ ) ~> n W i

rule Eval_static/literalExpressionIR-number-fixint:
  p C |- (n S i) `# `( _ _ ) ~> n S i

;;;;; stringLiteral 

rule Eval_static/literalExpressionIR-stringliteral:
  p C |- (`" text `") `# `( _ _ ) ~> `" text `"

;;;; referenceExpressionIR
;;;; syntax referenceExpressionIR = prefixedNameIR

rule Eval_static/referenceExpression:
  p C |- prefixedNameIR `# `( _ _ ) ~> value
  -- if value = $find_value(p, C, prefixedNameIR)

;;;; defaultExpressionIR
;;;; syntax defaultExpressionIR = defaultExpression

rule Eval_static/defaultExpressionIR:
  p C |- `... `# `( _ _ ) ~> DEFAULT

;;;; unaryExpressionIR
;;;; syntax unaryExpressionIR = unop typedExpressionIR

rule Eval_static/unaryExpressionIR-bnot:
  p C |- (`~ typedExpressionIR) `# `( _ _ ) ~> $un_bnot(value)
  -- Eval_static: p C |- typedExpressionIR ~> value

rule Eval_static/unaryExpressionIR-lnot:
  p C |- (`! typedExpressionIR) `# `( _ _ ) ~> $un_lnot(value)
  -- Eval_static: p C |- typedExpressionIR ~> value

rule Eval_static/unaryExpressionIR-plus:
  p C |- (`+ typedExpressionIR) `# `( _ _ ) ~> $un_plus(value)
  -- Eval_static: p C |- typedExpressionIR ~> value

rule Eval_static/unaryExpressionIR-minus:
  p C |- (`- typedExpressionIR) `# `( _ _ ) ~> $un_minus(value)
  -- Eval_static: p C |- typedExpressionIR ~> value

;;;; binaryExpressionIR
;;;; syntax binaryExpressionIR =
;;;;  typedExpressionIR binop typedExpressionIR

rule Eval_static/binaryExpressionIR-plus:
  p C |- (typedExpressionIR_l `+ typedExpressionIR_r) `# `( _ _ )
       ~> $bin_plus(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-satplus:
  p C |- (typedExpressionIR_l `|+| typedExpressionIR_r) `# `( _ _ )
       ~> $bin_satplus(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-minus:
  p C |- (typedExpressionIR_l `- typedExpressionIR_r) `# `( _ _ )
       ~> $bin_minus(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-satminus:
  p C |- (typedExpressionIR_l `|-| typedExpressionIR_r) `# `( _ _ )
       ~> $bin_satminus(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-mul:
  p C |- (typedExpressionIR_l `* typedExpressionIR_r) `# `( _ _ )
       ~> $bin_mul(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-div:
  p C |- (typedExpressionIR_l `/ typedExpressionIR_r) `# `( _ _ )
       ~> $bin_div(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-shl:
  p C |- (typedExpressionIR_l `<< typedExpressionIR_r) `# `( _ _ )
       ~> $bin_shl(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-shr:
  p C |- (typedExpressionIR_l `>> typedExpressionIR_r) `# `( _ _ )
       ~> $bin_shr(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-le:
  p C |- (typedExpressionIR_l `<= typedExpressionIR_r) `# `( _ _ )
       ~> (B $bin_le(value_l, value_r))
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-ge:
  p C |- (typedExpressionIR_l `>= typedExpressionIR_r) `# `( _ _ )
       ~> (B $bin_ge(value_l, value_r))
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-lt:
  p C |- (typedExpressionIR_l ``< typedExpressionIR_r) `# `( _ _ )
       ~> (B $bin_lt(value_l, value_r))
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-gt:
  p C |- (typedExpressionIR_l ``> typedExpressionIR_r) `# `( _ _ )
       ~> (B $bin_gt(value_l, value_r))
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-eq:
  p C |- (typedExpressionIR_l `== typedExpressionIR_r) `# `( _ _ )
       ~> (B $bin_eq(value_l, value_r))
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-ne:
  p C |- (typedExpressionIR_l `!= typedExpressionIR_r) `# `( _ _ )
       ~> (B $bin_ne(value_l, value_r))
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-band:
  p C |- (typedExpressionIR_l `& typedExpressionIR_r) `# `( _ _ )
       ~> $bin_band(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-bxor:
  p C |- (typedExpressionIR_l `^ typedExpressionIR_r) `# `( _ _ )
       ~> $bin_bxor(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-bor:
  p C |- (typedExpressionIR_l `| typedExpressionIR_r) `# `( _ _ )
       ~> $bin_bor(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-concat:
  p C |- (typedExpressionIR_l `++ typedExpressionIR_r) `# `( _ _ )
       ~> $bin_concat(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-land:
  p C |- (typedExpressionIR_l `&& typedExpressionIR_r) `# `( _ _ )
       ~> $bin_land(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

rule Eval_static/binaryExpressionIR-lor:
  p C |- (typedExpressionIR_l `|| typedExpressionIR_r) `# `( _ _ )
       ~> $bin_lor(value_l, value_r)
  -- Eval_static: p C |- typedExpressionIR_l ~> value_l
  -- Eval_static: p C |- typedExpressionIR_r ~> value_r

;;;; ternaryExpressionIR
;;;; syntax ternaryExpressionIR =
;;;;   typedExpressionIR `? typedExpressionIR `: typedExpressionIR

rule Eval_static/ternaryExpressionIR-true:
  p C |- (typedExpressionIR_cond `? typedExpressionIR_true `: typedExpressionIR_false)
          `# `( _ _ )
       ~> value_true
  -- Eval_static: p C |- typedExpressionIR_cond ~> (B true)
  -- Eval_static: p C |- typedExpressionIR_true ~> value_true

rule Eval_static/ternaryExpressionIR-false:
  p C |- (typedExpressionIR_cond `? typedExpressionIR_true `: typedExpressionIR_false)
          `# `( _ _ )
       ~> value_false
  -- Eval_static: p C |- typedExpressionIR_cond ~> (B false)
  -- Eval_static: p C |- typedExpressionIR_false ~> value_false

;;;; castExpressionIR
;;;; syntax castExpressionIR = `( typeIR ) typedExpressionIR

rule Eval_static/castExpression:
  p C |- (`( typeIR ) typedExpressionIR) `# `( _ _ ) ~> value_cast
  -- Eval_static: p C |- typedExpressionIR ~> value
  -- if value_cast = $cast_op(typeIR, value)

;;;; dataExpressionIR
;;;; syntax dataExpressionIR

;;;;; `{#}

rule Eval_static/dataExpressionIR-invalid:
  p C |- `{#} `# `( _ _ ) ~> `{#}

;;;;; SEQ `{ typedExpressionListIR }

rule Eval_static/dataExpressionIR-sequence:
  p C |- (SEQ `{ typedExpressionIR* }) `# `( _ _ ) ~> SEQ `( value* )
  -- (Eval_static: p C |- typedExpressionIR ~> value)*

;;;;; SEQ `{ typedExpressionListIR `, `... }

rule Eval_static/dataExpressionIR-sequence-default:
  p C |- (SEQ `{ typedExpressionIR* `, `... }) `# `( _ _ ) ~> SEQ `( value* `, `... )
  -- (Eval_static: p C |- typedExpressionIR ~> value)*

;;;;; RECORD `{ namedExpressionListIR }

rule Eval_static/dataExpressionIR-record:
  p C |- (RECORD `{ (nameIR `= typedExpressionIR)* }) `# `( _ _ )
      ~> RECORD `{ (value nameIR `;)* }
  -- (Eval_static: p C |- typedExpressionIR ~> value)*

;;;;; RECORD `{ namedExpressionListIR `, `... }

rule Eval_static/dataExpressionIR-record-default:
  p C |- (RECORD `{ (nameIR `= typedExpressionIR)* `, `... }) `# `( _ _ )
      ~> RECORD `{ (value nameIR `;)* `, `... }
  -- (Eval_static: p C |- typedExpressionIR ~> value)*

;;;; accessExpressionIR
;;;; syntax accessExpressionIR =

;;;;; errorAccessExpressionIR
;;;;; syntax errorAccessExpressionIR = ERROR `. nameIR

rule Eval_static/errorAccessExpressionIR:
  p C |- (ERROR `. nameIR) `# `( _ _ ) ~> value_error
  -- if nameIR_error = "error." ++ nameIR
  -- if value_error = $find_value(p, C, `` nameIR_error)

;;;;; memberAccessExpressionIR
;;;;; syntax memberAccessExpressionIR = memberAccessBaseIR `. nameIR
;;;;;; syntax memberAccessBaseIR

;;;;;;; TYPE prefixedNameIR

rule Eval_static/memberAccessExpressionIR-prefixedNameIR-enum:
  p C |- ((TYPE prefixedNameIR) `. nameIR) `# `( typeIR_base _ )
      ~> tid `. nameIR
  -- if ENUM tid `{ id_member* } = $find_type(p, C, prefixedNameIR)
  -- if nameIR <- id_member*

rule Eval_static/memberAccessExpressionIR-prefixedNameIR-serenum:
  p C |- ((TYPE prefixedNameIR) `. nameIR) `# `( typeIR_base _ )
      ~> tid `. nameIR `# value
  -- if ENUM tid `# typeIR `{ (id_member `= value_member `;)* }
      = $find_type(p, C, prefixedNameIR)
  -- if value
      = $assoc_<id, value>(nameIR, (id_member, value_member)*)

;;;;;;; typedExpressionIR
;;;;;;; general member accesses are not evaluated statically

rule Eval_static/memberAccessExpressionIR-typedExpressionIR-stack-size:
  p C |- (typedExpressionIR_base `. "size") `# `( typeIR_base _ )
      ~> D n_size
  -- if _ `[ n_size ] = typeIR_base

rule Eval_static/memberAccessExpressionIR-typedExpressionIR-struct:
  p C |- (typedExpressionIR_base `. nameIR) `# `( typeIR_base _ )
      ~> value
  -- Eval_static: p C |- typedExpressionIR_base ~> value_base
  -- if STRUCT _ `{ (value_field id_field `;)* } = value_base
  -- if value = $assoc_<id, value>(nameIR, (id_field, value_field)*)

rule Eval_static/memberAccessExpressionIR-typedExpressionIR-header:
  p C |- (typedExpressionIR_base `. nameIR) `# `( typeIR_base _ )
      ~> value
  -- Eval_static: p C |- typedExpressionIR_base ~> value_base
  -- if HEADER _ `{ _ (value_field id_field `;)* } = value_base
  -- if value = $assoc_<id, value>(nameIR, (id_field, value_field)*)

;; local compile-time known header unions do not seem to be constructable
rule Eval_static/memberAccessExpressionIR-typedExpressionIR-headerunion:
  p C |- (typedExpressionIR_base `. nameIR) `# `( typeIR_base _ )
      ~> value
  -- Eval_static: p C |- typedExpressionIR_base ~> value_base
  -- if HEADER_UNION _ `{ (value_field id_field `;)* } = value_base
  -- if value = $assoc_<id, value>(nameIR, (id_field, value_field)*)

;;;;; indexAccessExpressionIR
;;;;; syntax indexAccessExpressionIR

;;;;;; typedExpressionIR `[ typedExpressionIR ]

rule Eval_static/indexAccessExpressionIR-tuple:
  p C |- (typedExpressionIR_base `[ typedExpressionIR_index ]) `# `( _ _ )
      ~> value
  -- Eval_static: p C |- typedExpressionIR_base ~> value_base
  -- Eval_static: p C |- typedExpressionIR_index ~> value_index
  -- if `( value_e* ) = value_base
  -- if n_index = $to_number(value_index)
  -- if $(n_index < |value_e*|)
  -- if value = value_e*[n_index]

rule Eval_static/indexAccessExpressionIR-stack:
  p C |- (typedExpressionIR_base `[ typedExpressionIR_index ]) `# `( _ _ )
      ~> value
  -- Eval_static: p C |- typedExpressionIR_base ~> value_base
  -- Eval_static: p C |- typedExpressionIR_index ~> value_index
  -- if `[ value_e* `# `( _; _ ) ] = value_base
  -- if n_index = $to_number(value_index)
  -- if $(n_index < |value_e*|)
  -- if value = value_e*[n_index]

;;;;;; typedExpressionIR `[ typedExpressionIR `: typedExpressionIR ]

rule Eval_static/indexAccessExpressionIR-bitslice:
  p C |- (typedExpressionIR_base `[ typedExpressionIR_hi `: typedExpressionIR_lo ])
          `# `( _ _ )
      ~> $bitacc_op(value_base, value_hi, value_lo)
  -- Eval_static: p C |- typedExpressionIR_base ~> value_base
  -- Eval_static: p C |- typedExpressionIR_hi ~> value_hi
  -- Eval_static: p C |- typedExpressionIR_lo ~> value_lo

;;;; callExpressionIR
;;;; syntax callExpressionIR

;;;;; constructorTargetIR `( argumentListIR )
;;;;; constructor calls are not evaluated statically

;;;;; routineTargetIR `< typeArgumentListIR > `( argumentListIR )
;;;;;; syntax routineTargetIR

;;;;;;; referenceExpressionIR
;;;;;;; function/action calls are not evaluated statically

;;;;;;; typedLvalueIR `. nameIR

rule Eval_static/callExpressionIR-typedLvalueIR-size:
  p C |- ((typedExpressionIR_base `. nameIR) `< eps > `( eps )) `# `( _ _ )
      ~> $sizeof(typeIR_base, nameIR)
  -- if _ `# `( typeIR_base _ ) = typedExpressionIR_base
  -- if nameIR <- [ "minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes" ]

;;;;;;; TYPE prefixedNameIR `. nameIR

rule Eval_static/callExpressionIR-type-size-mono:
  p C |- ((TYPE prefixedNameIR `. nameIR) `< eps > `( eps )) `# `( _ _ )
      ~> $sizeof(typeIR_base, nameIR)
  -- if typeIR_base = $find_type(p, C, prefixedNameIR)
  -- if nameIR <- [ "minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes" ]

rule Eval_static/callExpressionIR-type-size-poly:
  p C |- ((TYPE prefixedNameIR `. nameIR) `< eps > `( eps )) `# `( _ _ )
      ~> $sizeof(typeIR_base, nameIR)
  -- if typeIR_base `< eps `, eps > = $find_type(p, C, prefixedNameIR)
  -- if nameIR <- [ "minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes" ]

;;;;;;; `( routineTargetIR )

rule Eval_static/callExpressionIR-parenthesized:
  p C |- ((`( routineTargetIR )) `< typeArgumentIR* > `( argumentIR* ))
          `# `( typeIR ctk )
      ~> value
  -- Eval_static:
      p C |- (routineTargetIR `< typeArgumentIR* > `( argumentIR* ))
              `# `( typeIR ctk )
          ~> value

;;;; parenthesizedExpressionIR
;;;; syntax parenthesizedExpressionIR = `( typedExpressionIR )

rule Eval_static/parenthesizedExpressionIR:
  p C |- (`( typedExpressionIR )) `# `( _ _ ) ~> value
  -- Eval_static: p C |- typedExpressionIR ~> value
