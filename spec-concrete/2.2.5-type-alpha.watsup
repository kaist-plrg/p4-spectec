;;
;; Relations for type alpha-equivalence
;;

relation Type_alpha:
  typeIR ~~ typeIR
  hint(input %0 %1)

relation ParameterType_alpha:
  parameterTypeIR ~~ parameterTypeIR
  hint(input %0 %1)

relation RoutineType_alpha:
  routineTypeIR ~~ routineTypeIR
  hint(input %0 %1)

relation RoutineTypeDef_alpha:
  routineTypeDefIR ~~ routineTypeDefIR
  hint(input %0 %1)

;;
;;;; Alpha-equivalence of types
;;

;;; Base types

rule Type_alpha/basetype:
  baseTypeIR ~~ baseTypeIR

;;; Named types

rule Type_alpha/nametype:
  (NameT tid) ~~  (NameT tid)

rule Type_alpha/spectype-nominal:
  (SpecT polyTypeDefIR_a typeIR_a*) ~~ (SpecT polyTypeDefIR_b typeIR_b*)
  -- if typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a, typeIR_a*)
  -- if typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b, typeIR_b*)
  -- Type_alpha: typeIR_a_spec ~~ typeIR_b_spec
  ---- ;; for nominal types, the type arguments must also match
  -- if $is_nominal_typeIR(typeIR_a_spec)
        /\ $is_nominal_typeIR(typeIR_b_spec)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/spectype-structural:
  (SpecT polyTypeDefIR_a typeIR_a*) ~~ (SpecT polyTypeDefIR_b typeIR_b*)
  -- if typeIR_a_spec = $specialize_typeDef(polyTypeDefIR_a, typeIR_a*)
  -- if typeIR_b_spec = $specialize_typeDef(polyTypeDefIR_b, typeIR_b*)
  -- Type_alpha: typeIR_a_spec ~~ typeIR_b_spec
  ---- ;; for structural types, the type arguments do not need to match
  -- if ~$is_nominal_typeIR(typeIR_a_spec)
        /\ ~$is_nominal_typeIR(typeIR_b_spec)

;;; Typedef types

rule Type_alpha/typedeftype-left:
  (DefT _ typeIR_a) ~~ typeIR_b
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/typedeftype-right:
  typeIR_a ~~ (DefT _ typeIR_b)
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/newtype:
  (NewT tid typeIR_a) ~~ (NewT tid typeIR_b)
  -- Type_alpha: typeIR_a ~~ typeIR_b

;;; Data types

rule Type_alpha/listtype:
  (ListT typeIR_a) ~~ (ListT typeIR_b)
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/tupletype:
  (TupleT typeIR_a*) ~~ (TupleT typeIR_b*)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/stacktype:
  (HeaderStackT typeIR_a n_s) ~~ (HeaderStackT typeIR_b n_s)
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/structtype:
  (StructT tid (typeIR_f_a id_f)*)
  ~~ (StructT tid (typeIR_f_b id_f)*)
  -- (Type_alpha: typeIR_f_a ~~ typeIR_f_b)*

rule Type_alpha/headertype:
  (HeaderT tid (typeIR_f_a id_f)*)
  ~~ (HeaderT tid (typeIR_f_b id_f)*)
  -- (Type_alpha: typeIR_f_a ~~ typeIR_f_b)*

rule Type_alpha/headeruniontype:
  (HeaderUnionT tid (typeIR_f_a id_f)*)
  ~~ (HeaderUnionT tid (typeIR_f_b id_f)*)
  -- (Type_alpha: typeIR_f_a ~~ typeIR_f_b)*

rule Type_alpha/enumtype:
  (EnumT tid id_f*) ~~ (EnumT tid id_f*)

rule Type_alpha/serenumtype:
  (SEnumT tid typeIR_a (id_f value_f)*)
  ~~ (SEnumT tid typeIR_b (id_f value_f)*)
  -- Type_alpha: typeIR_a ~~ typeIR_b

;;; Object types

rule Type_alpha/externtype:
  (ExternT tid (`{ (rid_a -> routineTypeDefIR_a)* }))
  ~~ (ExternT tid (`{ (rid_b -> routineTypeDefIR_b)* }))
  -- if $eq_set<rid>(`{ rid_a* }, `{ rid_b* })
  -- if (routineTypeDefIR_a'
        = $find_map<rid, routineTypeDefIR>(
            `{ (rid_a -> routineTypeDefIR_a)* },
            rid_a))*
  -- if (routineTypeDefIR_b'
        = $find_map<rid, routineTypeDefIR>(
            `{ (rid_b -> routineTypeDefIR_b)* },
            rid_a))*
  -- (RoutineTypeDef_alpha: routineTypeDefIR_a' ~~ routineTypeDefIR_b')*

rule Type_alpha/parsertype:
  (ParserT parameterTypeIR_a*) ~~ (ParserT parameterTypeIR_b*)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*

rule Type_alpha/controltype:
  (ControlT parameterTypeIR_a*) ~~ (ControlT parameterTypeIR_b*)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*

rule Type_alpha/packagetype:
  (PackageT tid typeIR_a*) ~~ (PackageT tid typeIR_b*)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/tabletype:
  (TableT tid typeIR_a) ~~ (TableT tid typeIR_b)
  -- Type_alpha: typeIR_a ~~ typeIR_b

;;; Synthesized types

rule Type_alpha/defaulttype:
  DefaultT ~~ DefaultT

rule Type_alpha/sequencetype:
  (SeqT typeIR_a*) ~~ (SeqT typeIR_b*)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/sequencedefaulttype:
  (SeqDefaultT typeIR_a*) ~~ (SeqDefaultT typeIR_b*)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/recordtype:
  (RecordT (typeIR_a id)*) ~~ (RecordT (typeIR_b id)*)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/recorddefaulttype:
  (RecordDefaultT (typeIR_a id)*)
  ~~ (RecordDefaultT (typeIR_b id)*)
  -- (Type_alpha: typeIR_a ~~ typeIR_b)*

rule Type_alpha/invalidtype:
  InvalidHeaderT ~~ InvalidHeaderT

rule Type_alpha/settype:
  (SetT typeIR_a) ~~ (SetT typeIR_b)
  -- Type_alpha: typeIR_a ~~ typeIR_b

rule Type_alpha/tableenumtype:
  (TableEnumT tid id_f*) ~~ (TableEnumT tid id_f*)

rule Type_alpha/tablestructtype:
  (TableStructT tid (typeIR_f_a id_f)*)
  ~~ (TableStructT tid (typeIR_f_b id_f)*)
  -- (Type_alpha: typeIR_f_a ~~ typeIR_f_b)*

;;
;;;; Alpha-equivalence of parameter types
;;

rule ParameterType_alpha:
  (_ typeIR_a _ _) ~~ (_ typeIR_b _ _)
  -- Type_alpha: typeIR_a ~~ typeIR_b

;;
;;;; Alpha-equivalence of routine types
;;

rule RoutineType_alpha/builtinfunction:
  (BuiltinFuncT parameterTypeIR_a* typeIR_ret_a)
  ~~ (BuiltinFuncT parameterTypeIR_b* typeIR_ret_b)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule RoutineType_alpha/function:
  (FuncT parameterTypeIR_a* typeIR_ret_a)
  ~~ (FuncT parameterTypeIR_b* typeIR_ret_b)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule RoutineType_alpha/action:
  (ActionT parameterTypeIR_a*) ~~ (ActionT parameterTypeIR_b*)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*

rule RoutineType_alpha/externfunction:
  (ExternFuncT parameterTypeIR_a* typeIR_ret_a)
  ~~ (ExternFuncT parameterTypeIR_b* typeIR_ret_b)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule RoutineType_alpha/builtinmethod:
  (BuiltinMethodT parameterTypeIR_a* typeIR_ret_a)
  ~~ (BuiltinMethodT parameterTypeIR_b* typeIR_ret_b)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule RoutineType_alpha/externmethod:
  (ExternMethodT parameterTypeIR_a* typeIR_ret_a)
  ~~ (ExternMethodT parameterTypeIR_b* typeIR_ret_b)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule RoutineType_alpha/externmethod-abstract:
  (ExternAbstractMethodT parameterTypeIR_a* typeIR_ret_a)
  ~~ (ExternAbstractMethodT parameterTypeIR_b* typeIR_ret_b)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

rule RoutineType_alpha/parserapply:
  (ParserApplyMethodT parameterTypeIR_a*)
  ~~ (ParserApplyMethodT parameterTypeIR_b*)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*

rule RoutineType_alpha/controlapply:
  (ControlApplyMethodT parameterTypeIR_a*)
  ~~ (ControlApplyMethodT parameterTypeIR_b*)
  -- (ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b)*

rule RoutineType_alpha/tableapply:
  (TableApplyMethodT typeIR_ret_a)
  ~~ (TableApplyMethodT typeIR_ret_b)
  -- Type_alpha: typeIR_ret_a ~~ typeIR_ret_b

;;
;;;; Alpha-equivalence of routine definitions
;;

rule RoutineTypeDef_alpha/mono:
  MonoTD routineTypeIR_a ~~ MonoTD routineTypeIR_b
  -- RoutineType_alpha: routineTypeIR_a ~~ routineTypeIR_b

rule RoutineTypeDef_alpha/poly:
  (PolyTD routineTypeIR_a tid_a* tid_hidden_a*)
  ~~ (PolyTD routineTypeIR_b tid_b* tid_hidden_b*)
  ---- ;; check that the type arguments match
  -- if |tid_a*| = |tid_b*|
  -- if |tid_hidden_a*| = |tid_hidden_b*|
  ---- ;; create fresh type identifiers
  -- if tid_fresh* = $fresh_tids($(|tid_a*| + |tid_hidden_a*|))
  ---- ;; substitute the left hand side with fresh type identifiers
  -- if tid_a'* = tid_a* ++ tid_hidden_a*
  -- if theta_a = `{ (tid_a' -> (NameT tid_fresh))* }
  -- if routineTypeIR_a_subst
      = $subst_routineType(theta_a, routineTypeIR_a)
  ---- ;; substitute the right hand side with fresh type identifiers
  -- if tid_b'* = tid_b* ++ tid_hidden_b*
  -- if theta_b = `{ (tid_b' -> (NameT tid_fresh))* }
  -- if routineTypeIR_b_subst
      = $subst_routineType(theta_b, routineTypeIR_b)
  ---- ;; check that the substituted routine types are alpha-equivalent
  -- RoutineType_alpha: routineTypeIR_a_subst ~~ routineTypeIR_b_subst
