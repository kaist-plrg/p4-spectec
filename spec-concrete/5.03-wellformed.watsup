;;
;; Relations for well-formedness
;;

relation Type_wf:
  bound |- typeIR
  hint(input %0 %1)

relation TypeDef_wf:
  bound |- typeDefIR
  hint(input %0 %1)

relation ParameterType_wf:
  bound |- parameterTypeIR
  hint(input %0 %1)

relation ParameterTypes_wf:
  bound |- parameterTypeIR*
  hint(input %0 %1)

relation RoutineType_wf:
  bound |- routineTypeIR
  hint(input %0 %1)

relation RoutineTypeDef_wf:
  bound |- routineTypeDefIR
  hint(input %0 %1)

relation ConstructorParameterType_wf:
  bound |- parameterTypeIR
  hint(input %0 %1)

relation ConstructorParameterTypes_wf:
  bound |- parameterTypeIR*
  hint(input %0 %1)

relation ConstructorType_wf:
  bound |- constructorTypeIR
  hint(input %0 %1)

relation ConstructorTypeDef_wf:
  bound |- constructorTypeDefIR
  hint(input %0 %1)

;;
;;;; Well-formedness of parameter types
;;

rule ParameterType_wf/default-empty-extern:
  bound |- `EMPTY typeIR _ eps
  -- Type_wf: bound |- typeIR
  -- if $is_extern_object_typeIR($canon(typeIR))

rule ParameterType_wf/default-none-not-extern:
  bound |- direction typeIR _ eps
  -- Type_wf: bound |- typeIR
  -- if ~$is_extern_object_typeIR($canon(typeIR))

rule ParameterType_wf/default-some-extern:
  bound |- `EMPTY typeIR _ value
  -- Type_wf: bound |- typeIR
  -- if $is_extern_object_typeIR($canon(typeIR))

rule ParameterType_wf/default-some-not-extern:
  bound |- direction typeIR _ value
  -- Type_wf: bound |- typeIR
  -- if ~$is_extern_object_typeIR($canon(typeIR))
  -- if direction = IN \/ direction = `EMPTY

rule ParameterTypes_wf:
  bound |- parameterTypeIR*
  -- if (_ _ id _ = parameterTypeIR)*
  -- if $distinct_<id>(id*)
  -- (ParameterType_wf: bound |- parameterTypeIR)*

;;
;;;; Well-formedness of types
;;

;;; Base types

rule Type_wf/basetype:
  bound |- baseTypeIR

;;; Named types

rule Type_wf/tid:
  bound |- (TID tid)
  -- if $in_set<tid>(tid, bound)

rule Type_wf/spectype:
  bound |- polyTypeDefIR `< typeIR_arg* >
  -- if typeIR = $specialize_typeDef(polyTypeDefIR, typeIR_arg*)
  -- Type_wf: bound |- typeIR

;;; Alias types

dec $nestable_typedef(typeIR) : bool
dec $nestable'_typedef(typeIR) : bool

def $nestable_typedef(typeIR) = $nestable'_typedef($canon(typeIR))
def $nestable'_typedef(BOOL) = true
def $nestable'_typedef(ERROR) = true
def $nestable'_typedef(STRING) = true
def $nestable'_typedef(numberTypeIR) = true
def $nestable'_typedef(TID _) = true
def $nestable'_typedef(TYPE _ _) = true
def $nestable'_typedef(dataTypeIR) = true
def $nestable'_typedef(_) = false
  -- otherwise

rule Type_wf/typedeftype:
  bound |- TYPEDEF _ typeIR
  -- if $nestable_typedef(typeIR)
  -- Type_wf: bound |- typeIR

dec $nestable_new(typeIR) : bool
dec $nestable'_new(typeIR) : bool

def $nestable_new(typeIR) = $nestable'_new($canon(typeIR))
def $nestable'_new(BOOL) = true
def $nestable'_new(BIT `< _ >) = true
def $nestable'_new(INT `< _ >) = true
def $nestable'_new(TID _) = true
def $nestable'_new(TYPE _ _) = true
def $nestable'_new(_) = false
  -- otherwise

rule Type_wf/newtype:
  bound |- TYPE _ typeIR
  -- if $nestable_new(typeIR)
  -- Type_wf: bound |- typeIR 

;;; Data types

dec $nestable_list(typeIR) : bool
dec $nestable'_list(typeIR) : bool

def $nestable_list(typeIR) = $nestable'_list($canon(typeIR))
def $nestable'_list(BOOL) = true
def $nestable'_list(ERROR) = true
def $nestable'_list(MATCH_KIND) = true
def $nestable'_list(STRING) = true
def $nestable'_list(numberTypeIR) = true
def $nestable'_list(TID _) = true
def $nestable'_list(TYPE _ _) = true
def $nestable'_list(dataTypeIR) = true
def $nestable'_list(_) = false
  -- otherwise

rule Type_wf/listttype:
  bound |- LIST `< typeIR >
  -- if $nestable_list(typeIR)
  -- Type_wf: bound |- typeIR

dec $nestable_tuple(typeIR) : bool
dec $nestable'_tuple(typeIR) : bool

def $nestable_tuple(typeIR) = $nestable'_tuple($canon(typeIR))
def $nestable'_tuple(BOOL) = true
def $nestable'_tuple(ERROR) = true
def $nestable'_tuple(BIT `< _ >) = true
def $nestable'_tuple(INT `< _ >) = true
def $nestable'_tuple(VARBIT `< _ >) = true
def $nestable'_tuple(TID _) = true
def $nestable'_tuple(TYPE _ _) = true
def $nestable'_tuple(TUPLE `< _ >) = true
def $nestable'_tuple(typeIR `[ _ ]) = true
def $nestable'_tuple(HEADER _ `{ _ }) = true
def $nestable'_tuple(HEADER_UNION _ `{ _ }) = true
def $nestable'_tuple(STRUCT _ `{ _ }) = true
def $nestable'_tuple(ENUM _ `{ _ }) = true
def $nestable'_tuple(ENUM _ `# _ `{ _ }) = true
def $nestable'_tuple(_) = false
  -- otherwise

rule Type_wf/tupletype:
  bound |- TUPLE `< typeIR* >
  -- if $nestable_tuple(typeIR)*
  -- (Type_wf: bound |- typeIR)*

dec $nestable_stack(typeIR) : bool
dec $nestable'_stack(typeIR) : bool

def $nestable_stack(typeIR) = $nestable'_stack($canon(typeIR))
def $nestable'_stack(TID _) = true
def $nestable'_stack(HEADER _ `{ _ }) = true
def $nestable'_stack(HEADER_UNION _ `{ _ }) = true
def $nestable'_stack(_) = false
  -- otherwise

rule Type_wf/stacktype:
  bound |- typeIR `[ _ ]
  -- if $nestable_stack(typeIR)
  -- Type_wf: bound |- typeIR

dec $nestable_struct(typeIR) : bool
dec $nestable'_struct(typeIR) : bool

def $nestable_struct(typeIR) = $nestable'_struct($canon(typeIR))
def $nestable'_struct(BOOL) = true
def $nestable'_struct(ERROR) = true
def $nestable'_struct(INT `< _ >) = true
def $nestable'_struct(BIT `< _ >) = true
def $nestable'_struct(VARBIT `< _ >) = true
def $nestable'_struct(TID _) = true
def $nestable'_struct(TYPE _ _) = true
def $nestable'_struct(TUPLE `< _ >) = true
def $nestable'_struct(typeIR `[ _ ]) = true
def $nestable'_struct(STRUCT _ `{ _ }) = true
def $nestable'_struct(HEADER _ `{ _ }) = true
def $nestable'_struct(HEADER_UNION _ `{ _ }) = true
def $nestable'_struct(ENUM _ `{ _ }) = true
def $nestable'_struct(ENUM _ `# _ `{ _ }) = true
def $nestable'_struct(_) = false
  -- otherwise

rule Type_wf/structtype:
  bound |- STRUCT _ `{ (typeIR id `;)* }
  -- if $distinct_<id>(id*)
  -- if $nestable_struct(typeIR)*
  -- (Type_wf: bound |- typeIR)*

dec $nestable_header(typeIR) : bool
dec $nestable'_header(typeIR) : bool
dec $nestable_struct_in_header(typeIR) : bool
dec $nestable'_struct_in_header(typeIR) : bool

def $nestable_header(typeIR) = $nestable'_header($canon(typeIR))
def $nestable'_header(BOOL) = true
def $nestable'_header(INT `< _ >) = true
def $nestable'_header(BIT `< _ >) = true
def $nestable'_header(VARBIT `< _ >) = true
def $nestable'_header(TID _) = true
def $nestable'_header(TYPE _ _) = true
def $nestable'_header(ENUM _ `# _ `{ _ }) = true
def $nestable'_header(STRUCT _ `{ (typeIR _ `;)* }) = true
  -- if $nestable_struct_in_header(typeIR)*
def $nestable'_header(_) = false
  -- otherwise

def $nestable_struct_in_header(typeIR)
  = $nestable'_struct_in_header($canon(typeIR))
def $nestable'_struct_in_header(BOOL) = true
def $nestable'_struct_in_header(INT `< _ >) = true
def $nestable'_struct_in_header(BIT `< _ >) = true
def $nestable'_struct_in_header(TID _) = true
def $nestable'_struct_in_header(TYPE _ _) = true
def $nestable'_struct_in_header(ENUM _ `# _ `{ _ }) = true
def $nestable'_struct_in_header(STRUCT _ `{ (typeIR _ `;)* }) = true
  -- if $nestable_struct_in_header(typeIR)*
def $nestable'_struct_in_header(_) = false
  -- otherwise

rule Type_wf/headertype:
  bound |- HEADER _ `{ (typeIR id `;)* }
  -- if $distinct_<id>(id*)
  -- if $nestable_header(typeIR)*
  -- (Type_wf: bound |- typeIR)*

dec $nestable_headerunion(typeIR) : bool
dec $nestable'_headerunion(typeIR) : bool

def $nestable_headerunion(typeIR)
  = $nestable'_headerunion($canon(typeIR))
def $nestable'_headerunion(TID _) = true
def $nestable'_headerunion(TYPE _ _) = true
def $nestable'_headerunion(HEADER _ `{ _ }) = true
def $nestable'_headerunion(_) = false
  -- otherwise

rule Type_wf/headeruniontype:
  bound |- HEADER_UNION _ `{ (typeIR id `;)* }
  -- if $distinct_<id>(id*)
  -- if $nestable_headerunion(typeIR)*
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/enumtype:
  bound |- ENUM _ `{ id* }
  -- if $distinct_<id>(id*)

dec $nestable_serenum(typeIR) : bool
dec $nestable'_serenum(typeIR) : bool
dec $nestable_new_in_serenum(typeIR) : bool
dec $nestable_new_in_serenum'(typeIR) : bool

def $nestable_serenum(typeIR)
  = $nestable'_serenum($canon(typeIR))
def $nestable'_serenum(INT `< _ >) = true
def $nestable'_serenum(BIT `< _ >) = true
def $nestable'_serenum(TID _) = true
def $nestable'_serenum(TYPE _ typeIR)
  = $nestable_new_in_serenum(typeIR)
def $nestable'_serenum(_) = false
  -- otherwise

def $nestable_new_in_serenum(typeIR)
  = $nestable_new_in_serenum'($canon(typeIR))
def $nestable_new_in_serenum'(INT `< _ >) = true
def $nestable_new_in_serenum'(BIT `< _ >) = true
def $nestable_new_in_serenum'(TID _) = true
def $nestable_new_in_serenum'(TYPE _ _) = true
def $nestable_new_in_serenum'(_) = false
  -- otherwise

rule Type_wf/serenumtype:
  bound |- ENUM _ `# typeIR `{ (id `= _ `;)* }
  -- if $distinct_<id>(id*)
  -- if $nestable_serenum(typeIR)
  -- Type_wf: bound |- typeIR

;;; Object types

rule Type_wf/externtype:
  bound |- EXTERN _ (`{ (_ `: routineTypeDefIR)* })
  -- (RoutineTypeDef_wf: bound |- routineTypeDefIR)*

rule Type_wf/parsertype:
  bound |- PARSER `( parameterTypeIR* )
  -- ParameterTypes_wf: bound |- parameterTypeIR*

rule Type_wf/controltype:
  bound |- CONTROL `( parameterTypeIR* )
  -- ParameterTypes_wf: bound |- parameterTypeIR*

rule Type_wf/packagetype:
  bound |- PACKAGE `< typeIR* >
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/tabletype:
  bound |- TABLE _ `# typeIR
  -- if TABLE_STRUCT _ `{ _ } = $canon(typeIR)
  -- Type_wf: bound |- typeIR

;;; Synthesized types

rule Type_wf/defaulttype:
  bound |- DEFAULT

rule Type_wf/sequencetype:
  bound |- SEQ `< typeIR* >
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/sequencedefaulttype:
  bound |- SEQ `< typeIR* `, `... >
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/recordtype:
  bound |- RECORD `{ (typeIR id `;)* }
  -- if $distinct_<id>(id*)
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/recorddefaulttype:
  bound |- RECORD `{ (typeIR id `;)* `, `... }
  -- if $distinct_<id>(id*)
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/invalidtype:
  bound |- HEADER_INVALID

dec $nestable_set(typeIR) : bool
dec $nestable'_set(typeIR) : bool
dec $nestable_tuple_in_set(typeIR) : bool
dec $nestable'_tuple_in_set(typeIR) : bool
dec $nestable_sequence_in_set(typeIR) : bool
dec $nestable'_sequence_in_set(typeIR) : bool

def $nestable_set(typeIR) = $nestable'_set($canon(typeIR))
def $nestable'_set(BOOL) = true
def $nestable'_set(ERROR) = true
def $nestable'_set(INT `< _ >) = true
def $nestable'_set(BIT `< _ >) = true
def $nestable'_set(TID _) = true
def $nestable'_set(TYPE _ _) = true
def $nestable'_set(TUPLE `< typeIR* >) = true
  -- if $nestable_tuple_in_set(typeIR)*
def $nestable'_set(ENUM _ `{ _ }) = true
def $nestable'_set(ENUM _ `# _ `{ _ }) = true
def $nestable'_set(SEQ `< typeIR* >) = true
  -- if $nestable_sequence_in_set(typeIR)*
def $nestable'_set(_) = false
  -- otherwise

def $nestable_tuple_in_set(typeIR)
  = $nestable'_tuple_in_set($canon(typeIR))
def $nestable'_tuple_in_set(BOOL) = true
def $nestable'_tuple_in_set(INT `< _ >) = true
def $nestable'_tuple_in_set(BIT `< _ >) = true
def $nestable'_tuple_in_set(TID _) = true
def $nestable'_tuple_in_set(TYPE _ _) = true
def $nestable'_tuple_in_set(TUPLE `< typeIR* >) = true
  -- if $nestable_tuple_in_set(typeIR)*
def $nestable'_tuple_in_set(ENUM _ `{ _ }) = true
def $nestable'_tuple_in_set(ENUM _ `# _ `{ _ }) = true
def $nestable'_tuple_in_set(_) = false
  -- otherwise

def $nestable_sequence_in_set(typeIR)
  = $nestable'_sequence_in_set($canon(typeIR))
def $nestable'_sequence_in_set(BOOL) = true
def $nestable'_sequence_in_set(INT `< _ >) = true
def $nestable'_sequence_in_set(BIT `< _ >) = true
def $nestable'_sequence_in_set(TID _) = true
def $nestable'_sequence_in_set(TYPE _ _) = true
def $nestable'_sequence_in_set(TUPLE `< typeIR* >) = true
  -- if $nestable_sequence_in_set(typeIR)*
def $nestable'_sequence_in_set(ENUM _ `{ _ }) = true
def $nestable'_sequence_in_set(ENUM _ `# _ `{ _ }) = true
def $nestable'_sequence_in_set(SEQ `< typeIR* >) = true
  -- if $nestable_sequence_in_set(typeIR)*
def $nestable'_sequence_in_set(_) = false
  -- otherwise

rule Type_wf/settype:
  bound |- SET `< typeIR >
  -- if $nestable_set(typeIR)
  -- Type_wf: bound |- typeIR

rule Type_wf/tableenumtype:
  bound |- TABLE_ENUM _ `{ id* }
  -- if $distinct_<id>(id*)

rule Type_wf/tablestructtype:
  bound |- TABLE_STRUCT _ `{ _ }

;;
;;;; Well-formedness of type definitions
;;

dec $definable_type_mono(typeIR) : bool

def $definable_type_mono(TID _) = true
def $definable_type_mono(aliasTypeIR) = true
def $definable_type_mono(ENUM _ `{ _ }) = true
def $definable_type_mono(ENUM _ `# _ `{ _ }) = true
def $definable_type_mono(TABLE _ `# _) = true
def $definable_type_mono(_) = false
  -- otherwise

rule TypeDef_wf/mono:
  bound |- typeIR
  -- if $definable_type_mono(typeIR)
  -- Type_wf: bound |- typeIR

dec $definable_type_poly(typeIR) : bool

def $definable_type_poly(TUPLE `< _ >) = true
def $definable_type_poly(_ `[ _ ]) = true
def $definable_type_poly(HEADER _ `{ _ }) = true
def $definable_type_poly(HEADER_UNION _ `{ _ }) = true
def $definable_type_poly(STRUCT _ `{ _ }) = true
def $definable_type_poly(EXTERN _ _) = true
def $definable_type_poly(PARSER `( _ )) = true
def $definable_type_poly(CONTROL `( _ )) = true
def $definable_type_poly(PACKAGE `< _ >) = true
def $definable_type_poly(_) = false
  -- otherwise

rule TypeDef_wf/poly:
  bound |- typeIR `< tid_expl* `, tid_impl* >
  -- if $definable_type_poly(typeIR)
  -- if $distinct_<tid>(tid_expl* ++ tid_impl*)
  -- if bound_inner
      = $union_set<tid>(bound, `{ tid_expl* ++ tid_impl* })
  -- Type_wf: bound_inner |- typeIR

;;
;;;; Well-formedness of routine types
;;

;;; Function types

rule RoutineType_wf/builtinfunction:
  bound |- BUILTIN_FUNCTION `( parameterTypeIR* ) `-> typeIR_ret
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- Type_wf: bound |- typeIR_ret

dec $nestable_function(direction, typeIR) : bool
dec $nestable_function'(direction, typeIR) : bool

def $nestable_function(direction, typeIR)
  = $nestable_function'(direction, $canon(typeIR))
def $nestable_function'(direction, STRING) = false
  -- if direction =/= `EMPTY
def $nestable_function'(direction, INT) = false
  -- if direction =/= `EMPTY
def $nestable_function'(direction, objectTypeIR) = false
def $nestable_function'(_, _) = true
  -- otherwise

rule RoutineType_wf/functiontype:
  bound |- FUNCTION `( parameterTypeIR* ) `-> typeIR_ret
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)* 
  -- if $nestable_function(direction, typeIR)*
  -- Type_wf: bound |- typeIR_ret

dec $directionless_trailing(direction*) : bool
dec $directionless_trailing'(bool, direction*) : bool

def $directionless_trailing(direction*)
  = $directionless_trailing'(true, $rev_<direction>(direction*))

def $directionless_trailing'(_, eps) = true
def $directionless_trailing'(true, `EMPTY :: direction_t*)
  = $directionless_trailing'(true, direction_t*)
def $directionless_trailing'(false, `EMPTY :: direction_t*) = false
def $directionless_trailing'(_, direction_h :: direction_t*)
  = $directionless_trailing'(false, direction_t*)
  -- if direction_h =/= `EMPTY

dec $nestable_action(direction, typeIR) : bool
dec $nestable_action'(direction, typeIR) : bool

def $nestable_action(direction, typeIR)
  = $nestable_action'(direction, $canon(typeIR))
def $nestable_action'(direction, STRING) = false
  -- if direction =/= `EMPTY
def $nestable_action'(_, INT) = false
def $nestable_action'(_, objectTypeIR) = false
def $nestable_action'(_, _) = true
  -- otherwise

rule RoutineType_wf/actiontype:
  bound |- ACTION `( parameterTypeIR* )
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)*
  -- if $directionless_trailing(direction*)
  -- if $nestable_action(direction, typeIR)*

dec $nestable_externfunction(direction, typeIR) : bool
dec $nestable_externfunction'(direction, typeIR) : bool

def $nestable_externfunction(direction, typeIR)
  = $nestable_externfunction'(direction, $canon(typeIR))
def $nestable_externfunction'(direction, STRING) = false
  -- if direction =/= `EMPTY
def $nestable_externfunction'(direction, INT) = false
  -- if direction =/= `EMPTY
def $nestable_externfunction'(direction, PARSER `( _ )) = false
def $nestable_externfunction'(direction, CONTROL `( _ )) = false
def $nestable_externfunction'(direction, PACKAGE `< _ >) = false
def $nestable_externfunction'(direction, TABLE _ `# _) = false
def $nestable_externfunction'(_, _) = true
  -- otherwise

rule RoutineType_wf/externfunctiontype:
  bound |- EXTERN_FUNCTION `( parameterTypeIR* ) `-> typeIR_ret
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)* 
  -- if $nestable_externfunction(direction, typeIR)*
  -- Type_wf: bound |- typeIR_ret

;;; Method types

rule RoutineType_wf/builtinmethod:
  bound |- BUILTIN_METHOD `( parameterTypeIR* ) `-> typeIR_ret
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- Type_wf: bound |- typeIR_ret

dec $nestable_externmethod(direction, typeIR) : bool
dec $nestable_externmethod'(direction, typeIR) : bool

def $nestable_externmethod(direction, typeIR)
  = $nestable_externmethod'(direction, $canon(typeIR))
def $nestable_externmethod'(direction, STRING) = false
  -- if direction =/= `EMPTY
def $nestable_externmethod'(direction, INT) = false
  -- if direction =/= `EMPTY
def $nestable_externmethod'(direction, PARSER `( _ )) = false
def $nestable_externmethod'(direction, CONTROL `( _ )) = false
def $nestable_externmethod'(direction, PACKAGE `< _ >) = false
def $nestable_externmethod'(direction, TABLE _ `# _) = false
def $nestable_externmethod'(_, _) = true
  -- otherwise

rule RoutineType_wf/externmethod:
  bound |- EXTERN_METHOD `( parameterTypeIR* ) `-> typeIR_ret
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)* 
  -- if $nestable_externmethod(direction, typeIR)*
  -- Type_wf: bound |- typeIR_ret

dec $nestable_externabstractmethod(direction, typeIR) : bool
dec $nestable_externabstractmethod'(direction, typeIR) : bool

def $nestable_externabstractmethod(direction, typeIR)
  = $nestable_externabstractmethod'(direction, $canon(typeIR))
def $nestable_externabstractmethod'(direction, STRING) = false
  -- if direction =/= `EMPTY
def $nestable_externabstractmethod'(direction, INT) = false
  -- if direction =/= `EMPTY
def $nestable_externabstractmethod'(direction, PARSER `( _ )) = false
def $nestable_externabstractmethod'(direction, CONTROL `( _ )) = false
def $nestable_externabstractmethod'(direction, PACKAGE `< _ >) = false
def $nestable_externabstractmethod'(direction, TABLE _ `# _) = false
def $nestable_externabstractmethod'(_, _) = true
  -- otherwise

rule RoutineType_wf/externabstractmethod:
  bound |- EXTERN_METHOD ABSTRACT `( parameterTypeIR* ) `-> typeIR_ret
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)* 
  -- if $nestable_externabstractmethod(direction, typeIR)*
  -- Type_wf: bound |- typeIR_ret

dec $nestable_parserapplymethod(direction, typeIR) : bool
dec $nestable_parserapplymethod'(direction, typeIR) : bool

def $nestable_parserapplymethod(direction, typeIR)
  = $nestable_parserapplymethod'(direction, $canon(typeIR))
def $nestable_parserapplymethod'(direction, STRING) = false
  -- if direction =/= `EMPTY
def $nestable_parserapplymethod'(direction, INT) = false
  -- if direction =/= `EMPTY
def $nestable_parserapplymethod'(direction, PARSER `( _ )) = false
def $nestable_parserapplymethod'(direction, CONTROL `( _ )) = false
def $nestable_parserapplymethod'(direction, PACKAGE `< _ >) = false
def $nestable_parserapplymethod'(direction, TABLE _ `# _) = false
def $nestable_parserapplymethod'(_, _) = true
  -- otherwise

rule RoutineType_wf/parserapplymethod:
  bound |- PARSER_APPLY `( parameterTypeIR* )
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)* 
  -- if $nestable_parserapplymethod(direction, typeIR)*

dec $nestable_controlapplymethod(direction, typeIR) : bool
dec $nestable_controlapplymethod'(direction, typeIR) : bool

def $nestable_controlapplymethod(direction, typeIR)
  = $nestable_controlapplymethod'(direction, $canon(typeIR))
def $nestable_controlapplymethod'(direction, STRING) = false
  -- if direction =/= `EMPTY
def $nestable_controlapplymethod'(direction, INT) = false
  -- if direction =/= `EMPTY
def $nestable_controlapplymethod'(direction, PARSER `( _ )) = false
def $nestable_controlapplymethod'(direction, PACKAGE `< _ >) = false
def $nestable_controlapplymethod'(direction, TABLE _ `# _) = false
def $nestable_controlapplymethod'(_, _) = true
  -- otherwise

rule RoutineType_wf/controlapplymethod:
  bound |- CONTROL_APPLY `( parameterTypeIR* )
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)* 
  -- if $nestable_controlapplymethod(direction, typeIR)*

rule RoutineType_wf/tableapplymethod:
  bound |- TABLE_APPLY `-> (TABLE_STRUCT _ `{ _ })

;;
;;;; Well-formedness of routine type definitions
;;

dec $definable_routine_mono(routineTypeIR) : bool

def $definable_routine_mono(BUILTIN_FUNCTION `( _ ) `-> _) = true
def $definable_routine_mono(ACTION `( _ )) = true
def $definable_routine_mono(BUILTIN_METHOD `( _ ) `-> _) = true
def $definable_routine_mono(PARSER_APPLY `( _ )) = true
def $definable_routine_mono(CONTROL_APPLY `( _ )) = true
def $definable_routine_mono(TABLE_APPLY `-> _) = true
def $definable_routine_mono(_) = false
  -- otherwise

rule RoutineTypeDef_wf/mono:
  bound |- routineTypeIR
  -- if $definable_routine_mono(routineTypeIR)
  -- RoutineType_wf: bound |- routineTypeIR

dec $definable_routine_poly(routineTypeIR) : bool

def $definable_routine_poly(FUNCTION `( _ ) `-> _) = true
def $definable_routine_poly(EXTERN_FUNCTION `( _ ) `-> _) = true
def $definable_routine_poly(EXTERN_METHOD `( _ ) `-> _) = true
def $definable_routine_poly(EXTERN_METHOD ABSTRACT `( _ ) `-> _) = true
def $definable_routine_poly(_) = false
  -- otherwise

rule RoutineTypeDef_wf/poly:
  bound |- routineTypeIR `< tid_expl* `, tid_impl* >
  -- if $definable_routine_poly(routineTypeIR)
  -- if $distinct_<tid>(tid_expl* ++ tid_impl*)
  -- if bound_inner
      = $union_set<tid>(bound, `{ tid_expl* ++ tid_impl* })
  -- RoutineType_wf: bound_inner |- routineTypeIR

;;
;;;; Well-formedness of constructor paramter types
;;

rule ConstructorParameterType_wf:
  bound |- `EMPTY typeIR _ _
  -- Type_wf: bound |- typeIR

rule ConstructorParameterTypes_wf:
  bound |- parameterTypeIR*
  -- if (_ _ id _ = parameterTypeIR)*
  -- if $distinct_<id>(id*)
  -- (ConstructorParameterType_wf: bound |- parameterTypeIR)*

;;
;;;; Well-formedness of constructor types
;;

dec $nestable_constructor_extern(typeIR) : bool
dec $nestable'_constructor_extern(typeIR) : bool

def $nestable_constructor_extern(typeIR)
  = $nestable'_constructor_extern($canon(typeIR))
def $nestable_constructor_extern(PARSER `( _ )) = false
def $nestable'_constructor_extern(CONTROL `( _ )) = false
def $nestable'_constructor_extern(PACKAGE `< _ >) = false
def $nestable'_constructor_extern(TABLE _ `# _) = false
def $nestable'_constructor_extern(_) = true
  -- otherwise

rule ConstructorType_wf/externtype:
  bound |- CONSTRUCTOR `( parameterTypeIR* ) `-> typeIR_object
  -- ConstructorParameterTypes_wf: bound |- parameterTypeIR*
  -- Type_wf: bound |- typeIR_object
  -- if EXTERN _ _ = $canon(typeIR_object)
  -- if (_ typeIR _ _ = parameterTypeIR)*
  -- if $nestable_constructor_extern(typeIR)*

dec $nestable_constructor_parser(typeIR) : bool
dec $nestable'_constructor_parser(typeIR) : bool

def $nestable_constructor_parser(typeIR)
  = $nestable'_constructor_parser($canon(typeIR))
def $nestable'_constructor_parser(CONTROL `( _ )) = false
def $nestable'_constructor_parser(PACKAGE `< _ >) = false
def $nestable'_constructor_parser(TABLE _ `# _) = false
def $nestable'_constructor_parser(_) = true
  -- otherwise

rule ConstructorType_wf/parsertype:
  bound |- CONSTRUCTOR `( parameterTypeIR* ) `-> typeIR_object
  -- ConstructorParameterTypes_wf: bound |- parameterTypeIR*
  -- Type_wf: bound |- typeIR_object
  -- if PARSER `( _ ) = $canon(typeIR_object)
  -- if (_ typeIR _ _ = parameterTypeIR)*
  -- if $nestable_constructor_parser(typeIR)*

dec $nestable_constructor_control(typeIR) : bool
dec $nestable'_constructor_control(typeIR) : bool

def $nestable_constructor_control(typeIR)
  = $nestable'_constructor_control($canon(typeIR))
def $nestable'_constructor_control(PARSER `( _ )) = false
def $nestable'_constructor_control(PACKAGE `< _ >) = false
def $nestable'_constructor_control(TABLE _ `# _) = false
def $nestable'_constructor_control(_) = true
  -- otherwise

rule ConstructorType_wf/controltype:
  bound |- CONSTRUCTOR `( parameterTypeIR* ) `-> typeIR_object
  -- ConstructorParameterTypes_wf: bound |- parameterTypeIR*
  -- Type_wf: bound |- typeIR_object
  -- if CONTROL `( _ ) = $canon(typeIR_object)
  -- if (_ typeIR _ _ = parameterTypeIR)*
  -- if $nestable_constructor_control(typeIR)*

dec $nestable_constructor_package(typeIR) : bool
dec $nestable'_constructor_package(typeIR) : bool

def $nestable_constructor_package(typeIR)
  = $nestable'_constructor_package($canon(typeIR))
def $nestable'_constructor_package(TABLE _ `# _) = false
def $nestable'_constructor_package(_) = true
  -- otherwise

rule ConstructorType_wf/packagetype:
  bound |- CONSTRUCTOR `( parameterTypeIR* ) `-> typeIR_object
  -- ConstructorParameterTypes_wf: bound |- parameterTypeIR*
  -- Type_wf: bound |- typeIR_object
  -- if PACKAGE `< _ > = $canon(typeIR_object)
  -- if (_ typeIR _ _ = parameterTypeIR)*
  -- if $nestable_constructor_package(typeIR)*

;;
;;;; Well-formedness of constructor definitions
;;

dec $definable_constructor(typeIR) : bool
dec $definable'_constructor(typeIR) : bool

def $definable_constructor(typeIR)
  = $definable'_constructor($canon(typeIR))
def $definable'_constructor(EXTERN _ _) = true
def $definable'_constructor(PARSER `( _ )) = true
def $definable'_constructor(CONTROL `( _ )) = true
def $definable'_constructor(PACKAGE `< _ >) = true
def $definable'_constructor(_) = false
  -- otherwise

rule ConstructorTypeDef_wf:
  bound |- constructorTypeIR `< tid_expl* `, tid_impl* >
  -- if CONSTRUCTOR `( _ ) `-> typeIR_object = constructorTypeIR
  -- if $definable_constructor(typeIR_object)
  -- if $distinct_<tid>(tid_expl* ++ tid_impl*)
  -- if bound_inner
      = $union_set<tid>(bound, `{ tid_expl* ++ tid_impl* })
  -- ConstructorType_wf: bound_inner |- constructorTypeIR
