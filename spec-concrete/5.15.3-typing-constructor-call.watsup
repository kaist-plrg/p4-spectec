;;
;; Constructor typing
;;

rule ConstructorType_ok:
  p TC |- prefixedNameIR `< typeArgumentIR* > `( argumentIR* )
        : constructorTypeIR `< `# tid_impl* > `( `# id_default* )
  ---- ;; find and specialize the constructor type definition
  -- if (cid, constructorTypeDefIR, id_default*)
      = $find_constructor_overloaded(TC, prefixedNameIR, argumentIR*)
  -- if (constructorTypeIR, tid_impl*)
      = $specialize_constructorTypeDef(constructorTypeDefIR, typeArgumentIR*)
  ---- ;; check that the constructor type is well-formed
  -- if bound = $union_set<tid>($bound(p, TC), `{ tid_impl* })
  -- ConstructorType_wf: bound |- constructorTypeIR

;;
;; Instantiation
;;

dec $instantiable_extern(cursor, typingContext, instctxt) : bool

def $instantiable_extern(GLOBAL, TC, instctxt) = true
def $instantiable_extern(BLOCK, TC, instctxt) = true
def $instantiable_extern(LOCAL, TC, instctxt) = true

dec $instantiable_parser(cursor, typingContext, instctxt) : bool

def $instantiable_parser(GLOBAL, TC, instctxt)
  = instctxt = ANON
def $instantiable_parser(BLOCK, TC, instctxt)
  = $is_parser_blockKind(TC.BLOCK.KIND)
def $instantiable_parser(LOCAL, TC, instctxt)
  = $is_parser_state_localKind(TC.LOCAL.KIND)

dec $instantiable_control(cursor, typingContext, instctxt) : bool

def $instantiable_control(GLOBAL, TC, instctxt)
  = instctxt = ANON
def $instantiable_control(BLOCK, TC, instctxt)
  = $is_control_blockKind(TC.BLOCK.KIND)
def $instantiable_control(LOCAL, TC, instctxt)
  = $is_control_apply_method_localKind(TC.LOCAL.KIND)

dec $instantiable_package(cursor, typingContext, instctxt) : bool

def $instantiable_package(GLOBAL, TC, instctxt) = true
def $instantiable_package(BLOCK, TC, instctxt)
  = $is_package_blockKind(TC.BLOCK.KIND)
def $instantiable_package(LOCAL, TC, instctxt) = false

dec $instantiable_table(cursor, typingContext, instctxt) : bool

def $instantiable_table(GLOBAL, TC, instctxt) = false
def $instantiable_table(BLOCK, TC, instctxt)
  = $is_control_blockKind(TC.BLOCK.KIND)
def $instantiable_table(LOCAL, TC, instctxt) = false

dec $instantiable(cursor, typingContext, instctxt, typeIR) : bool

def $instantiable(p, TC, instctxt, typeIR)
  = $instantiable_extern(p, TC, instctxt)
  -- if $is_extern_object_typeIR($canon(typeIR))
def $instantiable(p, TC, instctxt, typeIR)
  = $instantiable_parser(p, TC, instctxt)
  -- if $is_parser_object_typeIR($canon(typeIR))
def $instantiable(p, TC, instctxt, typeIR)
  = $instantiable_control(p, TC, instctxt)
  -- if $is_control_object_typeIR($canon(typeIR))
def $instantiable(p, TC, instctxt, typeIR)
  = $instantiable_package(p, TC, instctxt)
  -- if $is_package_object_typeIR($canon(typeIR))
def $instantiable(p, TC, instctxt, typeIR)
  = $instantiable_table(p, TC, instctxt)
  -- if $is_table_object_typeIR($canon(typeIR))

;;; Instantiation of a package

rule Inst_ok/package:
  GLOBAL TC instctxt |- constructorTypeIR `< typeArgumentIR* `# tid_infer* > 
                                          `( argumentIR* `# id_default* )
                      : typeIR_object_inferred `< typeArgumentIR_inferred* >
                                               `( argumentIR_cast* )
  ---- ;; if the constructor is for a package object
  -- if CONSTRUCTOR `( parameterTypeIR* ) `-> typeIR_object = constructorTypeIR
  -- if PACKAGE `< _ > = $canon(typeIR_object)
  ---- ;; filter default arguments
  -- if parameterTypeIR_non_default*
      = $filter_default_parameters(parameterTypeIR*, id_default*)
  ---- ;; check arity
  -- if $(|parameterTypeIR_non_default*| = |argumentIR*|)
  ---- ;; align parameters and arguments if named
  -- if parameterTypeIR_aligned*
      = $align_parameters(parameterTypeIR_non_default*, argumentIR*)
  ---- ;; perform type inference
  -- if inference = $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*)
  -- if (typeIR_inferred = $find_map<tid, typeIR>(inference, tid_infer))*
  -- if typeArgumentIR_inferred* = typeArgumentIR* ++ typeIR_inferred*
  ---- ;; substitute inferred types
  -- if (parameterTypeIR_aligned_inferred
      = $subst_parameterType(inference, parameterTypeIR_aligned))*
  -- if typeIR_object_inferred
      = $subst_type(inference, typeIR_object)
  ---- ;; check that the substituted constructor is still well-formed
  -- if constructorTypeIR_inferred
      = CONSTRUCTOR `( parameterTypeIR_aligned_inferred* ) `-> typeIR_object_inferred
  -- ConstructorType_wf: $bound(GLOBAL, TC) |- constructorTypeIR_inferred
  ---- ;; check instantiation site
  -- if $instantiable(GLOBAL, TC, instctxt, typeIR_object_inferred)
  ---- ;; check call convention
  -- Call_convention_ok:
      BLOCK TC NOACTION |- parameterTypeIR_aligned_inferred* `@ argumentIR*
                         : argumentIR_cast*

;;; Instantiation of a non-package

rule Inst_ok/non-package:
  p TC instctxt |- constructorTypeIR `< typeArgumentIR* `# tid_infer* > 
                                     `( argumentIR* `# id_default* )
                 : typeIR_object_inferred `< typeArgumentIR_inferred* >
                                          `( argumentIR_cast* )
  ---- ;; if the constructor is not for a package object
  -- if CONSTRUCTOR `( parameterTypeIR* ) `-> typeIR_object = constructorTypeIR
  -- if ~$is_package_object_typeIR($canon(typeIR_object))
  ---- ;; filter default arguments
  -- if parameterTypeIR_non_default*
      = $filter_default_parameters(parameterTypeIR*, id_default*)
  ---- ;; check arity
  -- if $(|parameterTypeIR_non_default*| = |argumentIR*|)
  ---- ;; align parameters and arguments if named
  -- if parameterTypeIR_aligned*
      = $align_parameters(parameterTypeIR_non_default*, argumentIR*)
  ---- ;; perform type inference
  -- if inference = $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*)
  -- if (typeIR_inferred = $find_map<tid, typeIR>(inference, tid_infer))*
  -- if typeArgumentIR_inferred* = typeArgumentIR* ++ typeIR_inferred*
  ---- ;; substitute inferred types
  -- if (parameterTypeIR_aligned_inferred
      = $subst_parameterType(inference, parameterTypeIR_aligned))*
  -- if typeIR_object_inferred
      = $subst_type(inference, typeIR_object)
  ---- ;; check that the substituted constructor is still well-formed
  -- if constructorTypeIR_inferred
      = CONSTRUCTOR `( parameterTypeIR_aligned_inferred* ) `-> typeIR_object_inferred
  -- ConstructorType_wf: $bound(p, TC) |- constructorTypeIR_inferred
  ---- ;; check instantiation site
  -- if $instantiable(p, TC, instctxt, typeIR_object_inferred)
  ---- ;; check call convention
  -- Call_convention_ok:
      p TC NOACTION |- parameterTypeIR_aligned_inferred* `@ argumentIR*
                     : argumentIR_cast*
