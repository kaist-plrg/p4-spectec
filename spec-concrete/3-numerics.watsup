;;
;; Bitwise operations
;;

dec $pow2(nat) : int

dec $shl(int, int) : int
dec $shr(int, int) : int
dec $shr_arith(int, int, int) : int

dec $bneg(int) : int
dec $band(int, int) : int
dec $bxor(int, int) : int
dec $bor(int, int) : int

dec $bitacc(int, int, int) : int

;;
;; Unary operations
;;

;;; Unary bitwise not

dec $un_bnot(value) : value

def $un_bnot(w W i) = w W i'
  -- if i' = $bneg(i)

;;; Unary logical not

dec $un_lnot(value) : value

def $un_lnot(B b) = B (~b)

;;; Unary plus

dec $un_plus(value) : value

def $un_plus(D i) = D i
def $un_plus(w W i) = w W i
def $un_plus(w S i) = w S i

;;; Unary minus

dec $un_minus(value) : value

def $un_minus(D i) = D $(-i)
def $un_minus(w W i) = w W i'
  -- if i' = $($pow2(w) - i)
def $un_minus(w S i) = w S i'
  -- if i' = $to_bitstr(w, $to_int(w, $(-i)))

;;
;; Binary operation
;;

;;; Binary plus

dec $bin_plus(value, value) : value

def $bin_plus(D i_l, D i_r) = D $(i_l + i_r)
def $bin_plus(w W i_l, w W i_r) = w W i'
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)
  -- if i' = $to_bitstr(w, $(i_l' + i_r'))
def $bin_plus(w S i_l, w S i_r) = w S i'
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)
  -- if i' = $to_bitstr(w, $(i_l' + i_r'))

;;; Binary saturating plus

dec $bin_satplus(value, value) : value 

;;; Binary minus

dec $bin_minus(value, value) : value

def $bin_minus(D i_l, D i_r) = D $(i_l - i_r)
def $bin_minus(w W i_l, w W i_r) = w W i'
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)
  -- if i' = $to_bitstr(w, $(i_l' - i_r'))
def $bin_plus(w S i_l, w S i_r) = w S i'
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)
  -- if i' = $to_bitstr(w, $(i_l' - i_r'))

;;; Binary saturating minus

dec $bin_satminus(value, value) : value

;;; Binary multiplication

dec $bin_mul(value, value) : value

def $bin_mul(D i_l, D i_r) = D $(i_l * i_r)
def $bin_minus(w W i_l, w W i_r) = w W i'
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)
  -- if i' = $to_bitstr(w, $(i_l' * i_r'))
def $bin_plus(w S i_l, w S i_r) = w S i'
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)
  -- if i' = $to_bitstr(w, $(i_l' * i_r'))

;;; Binary division

dec $bin_div(value, value) : value

def $bin_div(D i_l, D i_r) = D $(i_l / i_r)

;;; Binary modulo

dec $bin_mod(value, value) : value

def $bin_mod(D i_l, D i_r) = D $(i_l \ i_r)

;;; Binary shift left

dec $bin_shl(value, value) : value

def $bin_shl(D i_l, D i_r) = D $shl(i_l, i_r)
def $bin_shl(D i_l, w_r W i_r) = D $shl(i_l, i_r)
def $bin_shl(D i_l, w_r S i_r) = D $shl(i_l, i_r')
  -- if i_r' = $to_int(w_r, i_r)

def $bin_shl(w_l W i_l, D i_r)
  = $bin_shl(w_l W i_l, w_l W $to_int(w_l, i_r))
def $bin_shl(w_l W i_l, w_r W i_r) = w_l W i'
  -- if i' = $to_bitstr(w_l, $shl(i_l, i_r))
def $bin_shl(w_l W i_l, w_r S i_r) = w_l W i'
  -- if i_r' = $to_int(w_r, i_r)
  -- if i' = $to_bitstr(w_l, $shl(i_l, i_r'))

def $bin_shl(w_l S i_l, D i_r)
  = $bin_shl(w_l S i_l, w_l S $to_int(w_l, i_r))
def $bin_shl(w_l S i_l, w_r W i_r) = w_l S i'
  -- if i_l' = $to_int(w_l, i_l)
  -- if i' = $to_bitstr(w_l, $shl(i_l', i_r))
def $bin_shl(w_l S i_l, w_r S i_r) = w_l S i'
  -- if i_l' = $to_int(w_l, i_l)
  -- if i_r' = $to_int(w_r, i_r)
  -- if i' = $to_bitstr(w_l, $shl(i_l', i_r'))

;;; Binary shift right

dec $bin_shr(value, value) : value

def $bin_shr(D i_l, D i_r) = D $shr(i_l, i_r)
def $bin_shr(D i_l, w_r W i_r) = D $shr(i_l, i_r)
def $bin_shr(D i_l, w_r S i_r) = D $shr(i_l, i_r')
  -- if i_r' = $to_int(w_r, i_r)

def $bin_shr(w_l W i_l, D i_r)
  = $bin_shr(w_l W i_l, w_l W $to_int(w_l, i_r))
def $bin_shr(w_l W i_l, w_r W i_r) = w_l W i'
  -- if i' = $to_bitstr(w_l, $shr(i_l, i_r))
def $bin_shr(w_l W i_l, w_r S i_r) = w_l W i'
  -- if i_r' = $to_int(w_r, i_r)
  -- if i' = $to_bitstr(w_l, $shr(i_l, i_r'))

def $bin_shr(w_l S i_l, D i_r) = w_l S i''
  -- if i_l' = $to_int(w_l, i_l)
  -- if $(i_l' < 0)
  -- if i' = $shr_arith(i_l, i_r, $($pow2(w_l) - 1))
  -- if i'' = $to_bitstr(w_l, i')
def $bin_shr(w_l S i_l, D i_r) = w_l S i''
  -- if i_l' = $to_int(w_l, i_l)
  -- if $(i_l' >= 0)
  -- if i' = $shr(i_l, i_r)
  -- if i'' = $to_bitstr(w_l, i')
def $bin_shr(w_l S i_l, w_r W i_r) = w_l S i''
  -- if i_l' = $to_int(w_l, i_l)
  -- if $(i_l' < 0)
  -- if i' = $shr_arith(i_l, i_r, $($pow2(w_l) - 1))
  -- if i'' = $to_bitstr(w_l, i')
def $bin_shr(w_l S i_l, w_r W i_r) = w_l S i''
  -- if i_l' = $to_int(w_l, i_l)
  -- if $(i_l' >= 0)
  -- if i' = $shr(i_l, i_r)
  -- if i'' = $to_bitstr(w_l, i')
def $bin_shr(w_l S i_l, w_r S i_r) = w_l S i''
  -- if i_l' = $to_int(w_l, i_l)
  -- if i_r' = $to_int(w_r, i_r)
  -- if $(i_l' < 0)
  -- if i' = $shr_arith(i_l, i_r, $($pow2(w_l) - 1))
  -- if i'' = $to_bitstr(w_l, i')
def $bin_shr(w_l S i_l, w_r S i_r) = w_l S i''
  -- if i_l' = $to_int(w_l, i_l)
  -- if i_r' = $to_int(w_r, i_r)
  -- if $(i_l' >= 0)
  -- if i' = $shr(i_l, i_r)
  -- if i'' = $to_bitstr(w_l, i')

;;; Binary less than or equal

dec $bin_le(value, value) : bool

def $bin_le(D i_l, D i_r) = $(i_l <= i_r)
def $bin_le(w W i_l, w W i_r) = $(i_l <= i_r)
def $bin_le(w S i_l, w S i_r) = $(i_l' <= i_r')
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)

;;; Binary greater than or equal

dec $bin_ge(value, value) : bool

def $bin_ge(D i_l, D i_r) = $(i_l >= i_r)
def $bin_ge(w W i_l, w W i_r) = $(i_l >= i_r)
def $bin_ge(w S i_l, w S i_r) = $(i_l' >= i_r')
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)

;;; Binary less than

dec $bin_lt(value, value) : bool

def $bin_lt(D i_l, D i_r) = $(i_l < i_r)
def $bin_lt(w W i_l, w W i_r) = $(i_l < i_r)
def $bin_lt(w S i_l, w S i_r) = $(i_l' < i_r')
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)

;;; Binary greater than

dec $bin_gt(value, value) : bool

def $bin_gt(D i_l, D i_r) = $(i_l > i_r)
def $bin_gt(w W i_l, w W i_r) = $(i_l > i_r)
def $bin_gt(w S i_l, w S i_r) = $(i_l' > i_r')
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)

;;; Binary equals

dec $bin_eq(value, value) : bool
dec $bin_eqs(value*, value*) : bool
dec $bin_eqs_fields((value, id)*, (value, id)*) : bool

def $bin_eq(primitiveValue_a, primitiveValue_b)
  = (primitiveValue_a = primitiveValue_b)

def $bin_eq(D i_a, D i_b) = (i_a = i_b)
def $bin_eq(w_a W i_a, w_b W i_b) = (w_a = w_b) /\ (i_a = i_b)
def $bin_eq(w_a S i_a, w_b S i_b) = (w_a = w_b) /\ (i_a = i_b)
def $bin_eq(w_a V i_a `# _, w_b V i_b `# _) = (w_a = w_b) /\ (i_a = i_b)

def $bin_eq(`[ value_a* ], `[ value_b* ])
  = $bin_eqs(value_a*, value_b*)
def $bin_eq(`( value_a* ), `( value_b* ))
  = $bin_eqs(value_a*, value_b*)
def $bin_eq(`[ value_a* `# `( _; n_s_a ) ], `[ value_b* `# `( _; n_s_b ) ])
  = $bin_eqs(value_a*, value_b*) /\ (n_s_a = n_s_b)
def $bin_eq(
    STRUCT tid_a `{ (value_f_a id_f_a `;)* },
    STRUCT tid_b `{ (value_f_b id_f_b `;)* }
  )
  = (tid_a = tid_b)
    /\ $bin_eqs_fields((value_f_a, id_f_a)*, (value_f_b, id_f_b)*)
def $bin_eq(
    HEADER tid_a `{ b_a (value_f_a id_f_a `;)* },
    HEADER tid_b `{ b_b (value_f_b id_f_b `;)* }
  )
  = (tid_a = tid_b)
    /\ (b_a = b_b)
    /\ $bin_eqs_fields((value_f_a, id_f_a)*, (value_f_b, id_f_b)*)
def $bin_eq(
    HEADER_UNION tid_a `{ (value_f_a id_f_a `;)* },
    HEADER_UNION tid_b `{ (value_f_b id_f_b `;)* }
  )
  = (tid_a = tid_b)
    /\ $bin_eqs_fields((value_f_a, id_f_a)*, (value_f_b, id_f_b)*)
def $bin_eq(tid_a `. id_f_a, tid_b `. id_f_b)
  = (tid_a = tid_b) /\ (id_f_a = id_f_b)
def $bin_eq(tid_a `. id_f_a `# value_f_a, tid_b `. id_f_b `# value_f_b)
  = (tid_a = tid_b) /\ (id_f_a = id_f_b) /\ $bin_eq(value_f_a, value_f_b)
def $bin_eq(`{#}, `{#}) = true

def $bin_eqs(eps, eps) = true
def $bin_eqs(eps, _ :: _) = false
def $bin_eqs(_ :: _, eps) = false
def $bin_eqs(value_a_h :: value_a_t*, value_b_h :: value_b_t*)
  = $bin_eq(value_a_h, value_b_h) /\ $bin_eqs(value_a_t*, value_b_t*)

def $bin_eqs_fields(eps, eps) = true
def $bin_eqs_fields(eps, _ :: _) = false
def $bin_eqs_fields(_ :: _, eps) = false
def $bin_eqs_fields(
    (value_a_h, id_a_h) :: (value_a_t, id_a_t)*,
    (value_b_h, id_b_h) :: (value_b_t, id_b_t)*)
  = (id_a_h = id_b_h) /\ $bin_eq(value_a_h, value_b_h)
    /\ $bin_eqs_fields((value_a_t, id_a_t)*, (value_b_t, id_b_t)*)

;;; Binary not equals

dec $bin_ne(value, value) : bool

def $bin_ne(value_l, value_r) = ~$bin_eq(value_l, value_r)

;;; Binary bitwise and

dec $bin_band(value, value) : value

def $bin_band(w W i_l, w W i_r) = w W i'
  -- if i' = $to_bitstr(w, $band(i_l, i_r))

def $bin_band(w S i_l, w S i_r) = w S i'
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)
  -- if i' = $to_bitstr(w, $band(i_l', i_r'))

;;; Binary bitwise xor

dec $bin_bxor(value, value) : value

def $bin_bxor(w W i_l, w W i_r) = w W i'
  -- if i' = $to_bitstr(w, $bxor(i_l, i_r))

def $bin_bxor(w S i_l, w S i_r) = w S i'
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)
  -- if i' = $to_bitstr(w, $bxor(i_l', i_r'))

;;; Binary bitwise or

dec $bin_bor(value, value) : value

def $bin_bor(w W i_l, w W i_r) = w W i'
  -- if i' = $to_bitstr(w, $bor(i_l, i_r))

def $bin_bor(w S i_l, w S i_r) = w S i'
  -- if i_l' = $to_int(w, i_l)
  -- if i_r' = $to_int(w, i_r)
  -- if i' = $to_bitstr(w, $bor(i_l', i_r'))

;;; Binary bitwise concat

dec $bin_concat(value, value) : value

def $bin_concat(w_l W i_l, w_r W i_r) = w W i''
  -- if i_l' = $shl(i_l, w_r)
  -- if i_l'' = $(i_l' + i_r)
  -- if w = $(w_l + w_r)
  -- if i'' = $to_bitstr(w, i_l'')
def $bin_concat(w_l W i_l, w_r S i_r) = w W i''
  -- if i_l' = $shl(i_l, w_r)
  -- if i_l'' = $(i_l' + i_r)
  -- if w = $(w_l + w_r)
  -- if i'' = $to_bitstr(w, i_l'')

def $bin_concat(w_l S i_l, w_r W i_r) = w S i'''
  -- if i_l' = $to_int(w_l, i_l)
  -- if i_l'' = $shl(i_l', w_r)
  -- if i_l''' = $(i_l'' + i_r)
  -- if w = $(w_l + w_r)
  -- if i''' = $to_bitstr(w, i_l''')
def $bin_concat(w_l S i_l, w_r S i_r) = w S i'''
  -- if i_l' = $to_int(w_l, i_l)
  -- if i_l'' = $shl(i_l', w_r)
  -- if i_l''' = $(i_l'' + i_r)
  -- if w = $(w_l + w_r)
  -- if i''' = $to_bitstr(w, i_l''')

;;; Binary logical and

dec $bin_land(value, value) : value

def $bin_land(B b_l, B b_r) = B (b_l /\ b_r)

;;; Binary logical or

dec $bin_lor(value, value) : value

def $bin_lor(B b_l, B b_r) = B (b_l \/ b_r)

;;
;; Type cast operations
;;

dec $cast_op(typeIR, value) : value

dec $default(typeIR) : value
dec $default'(typeIR) : value

;;; Cast from boolean

dec $cast_bool(typeIR, bool) : value
dec $cast_bool'(typeIR, bool) : value

def $cast_bool(typeIR, b) = $cast_bool'($canon(typeIR), b)

def $cast_bool'(BOOL, b) = B b
def $cast_bool'(BIT `< w >, true) = w W 1
def $cast_bool'(BIT `< w >, false) = w W 0
def $cast_bool'(TYPE _ typeIR, b) = $cast_bool(typeIR, b)

def $cast_op(typeIR, B b) = $cast_bool(typeIR, b)

;;; Cast from integer

dec $cast_arbint(typeIR, int) : value
dec $cast_arbint'(typeIR, int) : value

def $cast_arbint(typeIR, i) = $cast_arbint'($canon(typeIR), i)

def $cast_arbint'(BOOL, i) = B (i = 0)
def $cast_arbint'(INT, i) = D i
def $cast_arbint'(BIT `< w >, i) = w W ($to_bitstr(w, i))
def $cast_arbint'(INT `< w >, i) = w S ($to_bitstr(w, i))
def $cast_arbint'(TYPE _ typeIR, i) = $cast_arbint(typeIR, i)
def $cast_arbint'(SET `< typeIR >, i) = SET `{ $cast_arbint(typeIR, i) }

def $cast_op(typeIR, D i) = $cast_arbint(typeIR, i)

;;; Cast from fixed unsigned integer

dec $cast_fixbit(typeIR, nat, int) : value
dec $cast_fixbit'(typeIR, nat, int) : value

def $cast_fixbit(typeIR, w, i) = $cast_fixbit'($canon(typeIR), w, i)

def $cast_fixbit'(BOOL, w, i) = B (i = 1)
def $cast_fixbit'(INT, _, i) = D i
def $cast_fixbit'(BIT `< w_to >, _, i) = w_to W i'
  -- if i' = $to_bitstr(w_to, i)
def $cast_fixbit'(INT `< w_to >, _, i) = w_to S i'
  -- if i' = $to_bitstr(w_to, i)
def $cast_fixbit'(TYPE _ typeIR, w, i) = $cast_fixbit(typeIR, w, i)
def $cast_fixbit'(SET `< typeIR >, w, i) = SET `{ $cast_fixbit(typeIR, w, i) }

def $cast_op(typeIR, w W i) = $cast_fixbit(typeIR, w, i)

;;; Cast from fixed signed integer

dec $cast_fixint(typeIR, nat, int) : value
dec $cast_fixint'(typeIR, nat, int) : value

def $cast_fixint(typeIR, w, i) = $cast_fixint'($canon(typeIR), w, i)

def $cast_fixint'(INT, w, i) = D $to_int(w, i)
def $cast_fixint'(BIT `< w_to >, w_from, i) = w_to W i'
  -- if i' = $to_bitstr(w_to, $to_int(w_from, i))
def $cast_fixint'(INT `< w_to >, w_from, i) = w_to S i'
  -- if i' = $to_bitstr(w_to, $to_int(w_from, i))
def $cast_fixint'(TYPE _ typeIR, w, i) = $cast_fixint(typeIR, w, i)
def $cast_fixint'(SET `< typeIR >, w, i) = SET `{ $cast_fixint(typeIR, w, i) }

def $cast_op(typeIR, w S i) = $cast_fixint(typeIR, w, i)

;;; Cast from struct

dec $cast_struct(typeIR, tid, (value, id)*) : value
dec $cast_struct'(typeIR, tid, (value, id)*) : value

def $cast_struct(typeIR, tid, (value_f, id_f)*)
  = $cast_struct'($canon(typeIR), tid, (value_f, id_f)*)

def $cast_struct'(STRUCT tid `{ _ }, tid, (value_f, id_f)*)
  = STRUCT tid `{ (value_f id_f `;)* }

def $cast_op(typeIR, STRUCT tid `{ (value_f id_f `;)* })
  = $cast_struct(typeIR, tid, (value_f, id_f)*)

;;; Cast from header

dec $cast_header(typeIR, tid, bool, (value, id)*) : value
dec $cast_header'(typeIR, tid, bool, (value, id)*) : value

def $cast_header(typeIR, tid, b, (value_f, id_f)*)
  = $cast_header'($canon(typeIR), tid, b, (value_f, id_f)*)

def $cast_header'(HEADER tid `{ _ }, tid, b, (value_f, id_f)*)
  = HEADER tid `{ b (value_f id_f `;)* }

def $cast_op(typeIR, HEADER tid `{ b (value_f id_f `;)* })
  = $cast_header(typeIR, tid, b, (value_f, id_f)*)

;;; Cast from serializable enum field

def $cast_op(typeIR, _ `. _ `# value) = $cast_op(typeIR, value)

;; Cast from sequence

dec $cast_sequence(typeIR, value*) : value
dec $cast_sequence'(typeIR, value*) : value

def $cast_sequence(typeIR, value*)
  = $cast_sequence'($canon(typeIR), value*)

def $cast_sequence'(LIST `< typeIR >, value*)
  = `[ $cast_op(typeIR, value)* ]

def $cast_sequence'(TUPLE `< typeIR* >, value*)
  = `( $cast_op(typeIR, value)* )

def $cast_sequence'(typeIR `[ n_s ], value*)
  = `[ value_cast* `# `( n_idx; n_s ) ]
  -- if (value_cast = $cast_op(typeIR, value))*
  -- if n_idx = |value*|

def $cast_sequence'(STRUCT tid `{ (typeIR_f id_f `;)* }, value*)
  = STRUCT tid `{ (value_cast id_f `;)* }
  -- if (value_cast = $cast_op(typeIR_f, value))*

def $cast_sequence'(HEADER tid `{ (typeIR_f id_f `;)* }, value*)
  = HEADER tid `{ true (value_cast id_f `;)* }
  -- if (value_cast = $cast_op(typeIR_f, value))*

def $cast_op(typeIR, SEQ `( value* )) = $cast_sequence(typeIR, value*)

;; Cast from default sequence

;; Cast from record

dec $cast_record(typeIR, (value, id)*) : value
dec $cast_record'(typeIR, (value, id)*) : value

def $cast_record(typeIR, (value, id)*)
  = $cast_record'($canon(typeIR), (value, id)*)

def $cast_record'(
    STRUCT tid `{ (typeIR_t_f id_t_f `;)* },
    (value_f, id_f)*
  )
  = STRUCT tid `{ (value_f_cast id_f `;)* }
  -- if (value_f' = $find_map<id, value>(`{ (id_f `: value_f)* }, id_t_f))*
  -- if (value_f_cast = $cast_op(typeIR_t_f, value_f'))*

def $cast_record'(
    HEADER tid `{ (typeIR_t_f id_t_f `;)* },
    (value_f, id_f)*
  )
  = HEADER tid `{ true (value_f_cast id_f `;)* }
  -- if (value_f' = $find_map<id, value>(`{ (id_f `: value_f)* }, id_t_f))*
  -- if (value_f_cast = $cast_op(typeIR_t_f, value_f'))*

def $cast_op(typeIR, RECORD `{ (value id `;)* })
  = $cast_record(typeIR, (value, id)*)

;; Cast from default record

;; Cast from default

def $cast_op(typeIR, DEFAULT) = $default(typeIR)

;; Cast from invalid

dec $cast_invalid(typeIR) : value
dec $cast_invalid'(typeIR) : value

def $cast_invalid(typeIR) = $cast_invalid'($canon(typeIR))

def $cast_invalid'(typeIR) = $default(typeIR)
  -- if HEADER _ `{ (_ _ `;)* } = typeIR

def $cast_invalid'(typeIR) = $default(typeIR)
  -- if HEADER_UNION _ `{ (_ _ `;)* } = typeIR

def $cast_op(typeIR, `{#}) = $cast_invalid(typeIR)

;; Cast from set

dec $cast_set_singleton(typeIR, value) : value
dec $cast_set_singleton'(typeIR, value) : value

def $cast_set_singleton(typeIR, value)
  = $cast_set_singleton'($canon(typeIR), value)

def $cast_set_singleton'(SET `< typeIR >, value)
  = SET `{ $cast_op(typeIR, value) }

dec $cast_set_mask(typeIR, value, value) : value
dec $cast_set_mask'(typeIR, value, value) : value

def $cast_set_mask(typeIR, value_b, value_m)
  = $cast_set_mask'($canon(typeIR), value_b, value_m)

def $cast_set_mask'(SET `< typeIR >, value_b, value_m)
  = SET `{ value_b_cast `&&& value_m_cast }
  -- if value_b_cast = $cast_op(typeIR, value_b)
  -- if value_m_cast = $cast_op(typeIR, value_m)

dec $cast_set_range(typeIR, value, value) : value
dec $cast_set_range'(typeIR, value, value) : value

def $cast_set_range(typeIR, value_l, value_u)
  = $cast_set_range'($canon(typeIR), value_l, value_u)

def $cast_set_range'(SET `< typeIR >, value_l, value_u)
  = SET `{ value_l_cast `.. value_u_cast }
  -- if value_l_cast = $cast_op(typeIR, value_l)
  -- if value_u_cast = $cast_op(typeIR, value_u)

def $cast_op(typeIR, SET `{ value })
  = $cast_set_singleton(typeIR, value)
def $cast_op(typeIR, SET `{ value_b `&&& value_m })
  = $cast_set_mask(typeIR, value_b, value_m)
def $cast_op(typeIR, SET `{ value_l `.. value_u })
  = $cast_set_range(typeIR, value_l, value_u)

;;
;; Default valueues for types
;; (TODO) This should be target-specific
;;

def $default(typeIR) = $default'($canon(typeIR))

def $default'(BOOL) = B false
def $default'(ERROR) = ERROR `. "NoError"
def $default'(STRING) = `" text_empty `"
  -- if text_empty = ""

def $default'(INT) = D 0
def $default'(BIT `< w >) = w W 0
def $default'(INT `< w >) = w S 0
def $default'(VARBIT `< w >) = w V 0 `# 0

def $default'(TUPLE `< typeIR* >) = `[ $default(typeIR)* ]

def $default'(typeIR `[ n_s ]) = `[ value* `# `( 0; n_s ) ]
  -- if value* = $repeat_<value>($default(typeIR), n_s)

def $default'(STRUCT tid `{ (typeIR_f id_f `;)* })
  = STRUCT tid `{ ($default(typeIR_f) id_f `;)* }

def $default'(HEADER tid `{ (typeIR_f id_f `;)* })
  = HEADER tid `{ false ($default(typeIR_f) id_f `;)* }

def $default'(HEADER_UNION tid `{ (typeIR_f id_f `;)* })
  = HEADER_UNION tid `{ ($default(typeIR_f) id_f `;)* }

def $default'(ENUM tid `{ id_f_h :: _ }) = tid `. id_f_h

def $default'(ENUM tid `# typeIR `{ (id_f `= value_f `;)* })
  = tid `. id_zero `# value_zero
  -- if value_zero = $cast_arbint(typeIR, 0)
  -- if id_zero = $assoc_<value, id>(value_zero, (value_f, id_f)*)

def $default'(ENUM tid `# typeIR `{ (id_f `= value_f `;)* })
  = tid `. id_zero `# value_zero
  -- if value_zero = $cast_arbint(typeIR, 0)
  -- if eps = $assoc_<value, id>(value_zero, (value_f, id_f)*)
  -- if id_zero = "__UNSPECIFIED"

;;
;; Bitstring access
;;

dec $bitacc_op(value, value, value) : value

def $bitacc_op(value_b, value_h, value_l) = w W i
  -- if i_b = $to_number(value_b)
  -- if i_h = $to_number(value_h)
  -- if i_l = $to_number(value_l)
  -- if w = $(i_h + 1 - i_l)
  -- if i = $bitacc(i_b, i_h, i_l)

;;
;; Size
;;

dec $sizeof(typeIR, id) : value

dec $sizeof_minSizeInBits(typeIR) : value
dec $sizeof_minSizeInBits'(typeIR) : nat
dec $sizeof_minSizeInBits''(typeIR) : nat

dec $sizeof_minSizeInBytes(typeIR) : value

dec $sizeof_maxSizeInBits(typeIR) : value
dec $sizeof_maxSizeInBits'(typeIR) : nat
dec $sizeof_maxSizeInBits''(typeIR) : nat

dec $sizeof_maxSizeInBytes(typeIR) : value

;;; Minimum size in bits

def $sizeof_minSizeInBits(typeIR) = D $sizeof_minSizeInBits'(typeIR)
def $sizeof_minSizeInBits'(typeIR) = $sizeof_minSizeInBits''($canon(typeIR))

def $sizeof_minSizeInBits''(BOOL) = 1
def $sizeof_minSizeInBits''(INT `< w >) = w
def $sizeof_minSizeInBits''(BIT `< w >) = w
def $sizeof_minSizeInBits''(VARBIT `< _ >) = 0
def $sizeof_minSizeInBits''(TYPE _ typeIR) = $sizeof_minSizeInBits'(typeIR)
def $sizeof_minSizeInBits''(ENUM _ `# typeIR `{ _ }) = $sizeof_minSizeInBits'(typeIR)
def $sizeof_minSizeInBits''(TUPLE `< typeIR* >) = $sum($sizeof_minSizeInBits'(typeIR)*)
def $sizeof_minSizeInBits''(typeIR `[ n_size ]) = $($sizeof_minSizeInBits'(typeIR) * n_size)
def $sizeof_minSizeInBits''(STRUCT _ `{ (typeIR _ `;)* }) = $sum($sizeof_minSizeInBits'(typeIR)*)
def $sizeof_minSizeInBits''(HEADER _ `{ (typeIR _ `;)* }) = $sum($sizeof_minSizeInBits'(typeIR)*)
def $sizeof_minSizeInBits''(HEADER_UNION _ `{ (typeIR _ `;)* }) = $min($sizeof_minSizeInBits'(typeIR)*)

def $sizeof(typeIR, "minSizeInBits") = $sizeof_minSizeInBits(typeIR)

;;; Minimum size in bytes

def $sizeof_minSizeInBytes(typeIR) = D $(n_size / 8)
  -- if n_size = $sizeof_minSizeInBits'(typeIR)

def $sizeof(typeIR, "minSizeInBytes") = $sizeof_minSizeInBytes(typeIR)

;; Maximum size in bits

def $sizeof_maxSizeInBits(typeIR) = D $sizeof_maxSizeInBits'(typeIR)
def $sizeof_maxSizeInBits'(typeIR) = $sizeof_maxSizeInBits''($canon(typeIR))

def $sizeof_maxSizeInBits''(BOOL) = 1
def $sizeof_maxSizeInBits''(INT `< w >) = w
def $sizeof_maxSizeInBits''(BIT `< w >) = w
def $sizeof_maxSizeInBits''(VARBIT `< w >) = w
def $sizeof_maxSizeInBits''(TYPE _ typeIR) = $sizeof_maxSizeInBits'(typeIR)
def $sizeof_maxSizeInBits''(ENUM _ `# typeIR `{ _ }) = $sizeof_maxSizeInBits'(typeIR)
def $sizeof_maxSizeInBits''(TUPLE `< typeIR* >) = $sum($sizeof_maxSizeInBits'(typeIR)*)
def $sizeof_maxSizeInBits''(typeIR `[ n_size ]) = $($sizeof_maxSizeInBits'(typeIR) * n_size)
def $sizeof_maxSizeInBits''(STRUCT _ `{ (typeIR _ `;)* }) = $sum($sizeof_maxSizeInBits'(typeIR)*)
def $sizeof_maxSizeInBits''(HEADER _ `{ (typeIR _ `;)* }) = $sum($sizeof_maxSizeInBits'(typeIR)*)
def $sizeof_maxSizeInBits''(HEADER_UNION _ `{ (typeIR _ `;)* }) = $max($sizeof_maxSizeInBits'(typeIR)*)

def $sizeof(typeIR, "maxSizeInBits") = $sizeof_maxSizeInBits(typeIR)

;;; Maximum size in bytes

def $sizeof_maxSizeInBytes(typeIR) = D $(n_size / 8)
  -- if n_size = $sizeof_maxSizeInBits'(typeIR)

def $sizeof(typeIR, "maxSizeInBytes") = $sizeof_maxSizeInBytes(typeIR)
